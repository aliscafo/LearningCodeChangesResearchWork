538
#method_before
@Test
@GerritConfig(name = "sendemail.allowTLD", value = "example")
public void testCustomTopLevelDomain() throws Exception {
    assertThat(validator.isValid("foo@bar.local")).isFalse();
    assertThat(validator.isValid("foo@bar.example")).isTrue();
}
#method_after
@Test
@GerritConfig(name = "sendemail.allowTLD", value = "example")
public void testCustomTopLevelDomain() throws Exception {
    assertThat(validator.isValid("foo@bar.local")).isFalse();
    assertThat(validator.isValid("foo@bar.example")).isTrue();
    assertThat(validator.isValid("foo@example")).isTrue();
}
#end_block

#method_before
protected <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
            reindexers.put(def.getName(), reindexer);
            if (onlineUpgrade && latest != search.version) {
                reindexer.start();
            }
        }
    }
}
#method_after
protected <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.version != search.version) {
            indexes.addWriteIndex(factory.create(v.schema));
        } else {
            indexes.addWriteIndex(searchIndex);
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
            reindexers.put(def.getName(), reindexer);
            if (onlineUpgrade && latest != search.version) {
                reindexer.start();
            }
        }
    }
}
#end_block

#method_before
protected ProvisionException fail(Throwable t) {
    ProvisionException e = new ProvisionException("Error scanning indexes");
    e.initCause(t);
    return e;
}
#method_after
private ProvisionException fail(Throwable t) {
    ProvisionException e = new ProvisionException("Error scanning indexes");
    e.initCause(t);
    return e;
}
#end_block

#method_before
JestHttpClient build() {
    JestClientFactory factory = new JestClientFactory();
    factory.setHttpClientConfig(new HttpClientConfig.Builder(urls).multiThreaded(true).discoveryEnabled(false).discoveryFrequency(1L, TimeUnit.MINUTES).build());
    return (JestHttpClient) factory.getObject();
}
#method_after
JestHttpClient build() {
    JestClientFactory factory = new JestClientFactory();
    factory.setHttpClientConfig(new HttpClientConfig.Builder(cfg.urls).multiThreaded(true).discoveryEnabled(false).discoveryFrequency(1L, TimeUnit.MINUTES).build());
    return (JestHttpClient) factory.getObject();
}
#end_block

#method_before
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to add email address");
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (!validator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    if (input.noConfirmation && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to use no_confirmation");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser() || input.noConfirmation) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (!validator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException {
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#method_after
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    Set<Address> smtpRcptToPlaintextOnly = new HashSet<>();
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
        }
        // In addition, check if users only want to receive plaintext email.
        for (Account.Id id : rcptTo) {
            Account thisUser = args.accountCache.get(id).getAccount();
            GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
            if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                removeUser(thisUser);
            } else if (useHtml() && prefs.getEmailFormat() == EmailFormat.PLAINTEXT) {
                removeUser(thisUser);
                smtpRcptToPlaintextOnly.add(new Address(thisUser.getFullName(), thisUser.getPreferredEmail()));
            }
            if (smtpRcptTo.isEmpty() && smtpRcptToPlaintextOnly.isEmpty()) {
                return;
            }
        }
        // inbound email replies.
        if (!headers.containsKey("Reply-To")) {
            StringJoiner j = new StringJoiner(", ");
            if (fromId != null) {
                Address address = toAddress(fromId);
                if (address != null) {
                    j.add(address.getEmail());
                }
            }
            smtpRcptTo.stream().forEach(a -> j.add(a.getEmail()));
            smtpRcptToPlaintextOnly.stream().forEach(a -> j.add(a.getEmail()));
            setHeader("Reply-To", j.toString());
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        if (!smtpRcptTo.isEmpty()) {
            // Send multipart message
            args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
        }
        if (!smtpRcptToPlaintextOnly.isEmpty()) {
            // Send plaintext message
            Map<String, EmailHeader> shallowCopy = new HashMap<>();
            shallowCopy.putAll(headers);
            // Remove To and Cc
            shallowCopy.remove(HDR_TO);
            shallowCopy.remove(HDR_CC);
            for (Address a : smtpRcptToPlaintextOnly) {
                // Add new To
                EmailHeader.AddressList to = new EmailHeader.AddressList();
                to.add(a);
                shallowCopy.put(HDR_TO, to);
            }
            args.emailSender.send(va.smtpFromAddress, smtpRcptToPlaintextOnly, shallowCopy, va.body);
        }
    }
}
#end_block

#method_before
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!validator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.onRemove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    ExternalId extUser = ExternalId.createUsername(username, id, input.httpPassword);
    if (externalIds.get(db, extUser.key()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (externalIds.get(db, ExternalId.Key.create(SCHEME_MAILTO, input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!validator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<ExternalId> extIds = new ArrayList<>();
    extIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        extIds.addAll(c.create(id, username, input.email));
    }
    ExternalIdsUpdate externalIdsUpdate = externalIdsUpdateFactory.create();
    try {
        externalIdsUpdate.insert(db, extIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        try {
            externalIdsUpdate.insert(db, ExternalId.createEmail(id, input.email));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                externalIdsUpdate.delete(db, extUser);
            } catch (IOException | ConfigInvalidException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    accountsUpdate.create().insert(db, a);
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
boolean execute() {
    try {
        HttpResult result = send();
        if (result.isSuccessful()) {
            return true;
        }
        log.error("Unable to " + name + ": " + result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to " + name, e);
    }
    return false;
}
#method_after
boolean execute() {
    try {
        HttpResult result = send();
        if (result.isSuccessful()) {
            return true;
        }
        log.error("Unable to {}: {}", name, result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to {}", name, e);
    }
    return false;
}
#end_block

#method_before
@Override
public String getHtmlMessage() {
    if (Strings.isNullOrEmpty(id)) {
        return null;
    }
    if (Strings.isNullOrEmpty(expiresAt)) {
        return null;
    }
    if (today().compareTo(expiresAt) > 0) {
        return null;
    }
    return msg;
}
#method_after
@Override
public String getHtmlMessage() {
    if (Strings.isNullOrEmpty(id)) {
        return null;
    }
    if (Strings.isNullOrEmpty(expiresAt)) {
        log.warn("expiresAt not defined, not message will be shown");
        return null;
    }
    if (today().compareTo(expiresAt) > 0) {
        return null;
    }
    return msg;
}
#end_block

#method_before
private static String today() {
    return YYYYMMdd.format(new Date());
}
#method_after
private static String today() {
    return new SimpleDateFormat("YYYYMMdd").format(new Date());
}
#end_block

#method_before
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT patch_set_id, file_name FROM account_patch_reviews APR1 " + "WHERE account_id = ? AND change_id = ? AND patch_set_id = " + "(SELECT MAX(patch_set_id) FROM account_patch_reviews APR2 WHERE " + "APR1.account_id = APR2.account_id " + "AND APR1.change_id = APR2.change_id " + "AND patch_set_id <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                ImmutableSet.Builder<String> builder = ImmutableSet.builder();
                do {
                    builder.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(AccountPatchReviewStore.PatchSetWithReviewedFiles.create(id, builder.build()));
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#method_after
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT patch_set_id, file_name FROM account_patch_reviews APR1 " + "WHERE account_id = ? AND change_id = ? AND patch_set_id = " + "(SELECT MAX(patch_set_id) FROM account_patch_reviews APR2 WHERE " + "APR1.account_id = APR2.account_id " + "AND APR1.change_id = APR2.change_id " + "AND patch_set_id <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                ImmutableSet.Builder<String> builder = ImmutableSet.builder();
                do {
                    builder.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(AccountPatchReviewStore.PatchSetWithReviewedFiles.create(id, builder.build()));
            }
            return Optional.empty();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#end_block

#method_before
private void checkGlobalCapabilityPermissions(Project.NameKey projectName) throws BadRequestException, AuthException, PermissionBackendException {
    if (!allProjects.equals(projectName)) {
        throw new BadRequestException("Cannot edit global capabilities for projects other than " + allProjects.get());
    }
    try {
        permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
    } catch (AuthException e) {
        throw new AuthException("Editing global capabilities requires " + GlobalCapability.ADMINISTRATE_SERVER);
    }
}
#method_after
private void checkGlobalCapabilityPermissions(Project.NameKey projectName) throws BadRequestException, AuthException, PermissionBackendException {
    if (!allProjects.equals(projectName)) {
        throw new BadRequestException("Cannot edit global capabilities for projects other than " + allProjects.get());
    }
    permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Repository repository = ctx.getRepository();
    Ref destinationRef = repository.exactRef(ctx.getChange().getDest().get());
    if (destinationRef == null) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    RevCommit revCommit = revWalk.parseCommit(objectId);
    return IncludedInResolver.includedInOne(repository, revWalk, revCommit, Collections.singletonList(destinationRef));
}
#method_after
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Optional<ObjectId> destId = ctx.getRepoView().getRef(ctx.getChange().getDest().get());
    if (!destId.isPresent()) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    return revWalk.isMergedInto(revWalk.parseCommit(objectId), revWalk.parseCommit(destId.get()));
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    String prefix = new PatchSet.Id(id, 1).toRefName();
    prefix = prefix.substring(0, prefix.length() - 1);
    for (Ref ref : ctx.getRepository().getRefDatabase().getRefs(prefix).values()) {
        ctx.addRefUpdate(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    String prefix = new PatchSet.Id(id, 1).toRefName();
    prefix = prefix.substring(0, prefix.length() - 1);
    for (Map.Entry<String, ObjectId> e : ctx.getRepoView().getRefs(prefix).entrySet()) {
        ctx.addRefUpdate(e.getValue(), ObjectId.zeroId(), prefix + e.getKey());
    }
}
#end_block

#method_before
@Override
public Response<?> apply(RevisionResource rsrc, Input input) throws RestApiException, UpdateException, OrmException, PermissionBackendException {
    if (isDeletingOnlyPatchSet(rsrc)) {
        // A change cannot have zero patch sets; the change is deleted instead.
        rsrc.permissions().database(db).check(ChangePermission.DELETE);
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.setOrder(BatchUpdate.Order.DB_BEFORE_REPO);
        bu.addOp(rsrc.getChange().getId(), new Op(rsrc.getPatchSet().getId()));
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(RevisionResource rsrc, Input input) throws RestApiException, UpdateException, OrmException, PermissionBackendException {
    if (isDeletingOnlyPatchSet(rsrc)) {
        // A change cannot have zero patch sets; the change is deleted instead.
        rsrc.permissions().database(db).check(ChangePermission.DELETE);
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.setOrder(Order.DB_BEFORE_REPO);
        bu.addOp(rsrc.getChange().getId(), new Op(rsrc.getPatchSet().getId()));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    if (deleteChangeOp != null) {
        deleteChangeOp.updateRepo(ctx);
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.fromString(patchSet.getRevision().get()), ObjectId.zeroId(), patchSet.getRefName()));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    if (deleteChangeOp != null) {
        deleteChangeOp.updateRepo(ctx);
        return;
    }
    ctx.addRefUpdate(ObjectId.fromString(patchSet.getRevision().get()), ObjectId.zeroId(), patchSet.getRefName());
}
#end_block

#method_before
private List<Boolean> getPatchSetDraftStatuses(Change.Id id) throws Exception {
    Collection<RevisionInfo> revisionInfos = gApi.changes().id(id.get()).get(EnumSet.of(ListChangesOption.ALL_REVISIONS)).revisions.values();
    return revisionInfos.stream().map(revisionInfo -> revisionInfo.draft).collect(Collectors.toList());
}
#method_after
private List<Boolean> getPatchSetDraftStatuses(Change.Id id) throws Exception {
    Collection<RevisionInfo> revisionInfos = gApi.changes().id(id.get()).get(EnumSet.of(ListChangesOption.ALL_REVISIONS)).revisions.values();
    return revisionInfos.stream().map(revisionInfo -> revisionInfo.draft).collect(toList());
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(Change.Status.DRAFT);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(Change.Status.DRAFT);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(Change.Status.DRAFT);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(Change.Status.DRAFT);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Collection<PatchSet> patchSets = psUtil.byChange(db, ctx.getNotes());
    // Change status in database.
    patchSets.forEach(patchSet -> patchSet.setDraft(draftStatus));
    db.patchSets().update(patchSets);
    // Change status in NoteDb.
    PatchSetState patchSetState = draftStatus ? PatchSetState.DRAFT : PatchSetState.PUBLISHED;
    patchSets.stream().map(PatchSet::getId).map(ctx::getUpdate).forEach(changeUpdate -> changeUpdate.setPatchSetState(patchSetState));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Collection<PatchSet> patchSets = psUtil.byChange(db, ctx.getNotes());
    // Change status in database.
    patchSets.forEach(patchSet -> patchSet.setDraft(draftStatus));
    db.patchSets().update(patchSets);
    // Change status in NoteDb.
    PatchSetState patchSetState = draftStatus ? PatchSetState.DRAFT : PatchSetState.PUBLISHED;
    patchSets.stream().map(PatchSet::getId).map(ctx::getUpdate).forEach(changeUpdate -> changeUpdate.setPatchSetState(patchSetState));
    return true;
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self project:{" + project.get() + "}")).isEmpty();
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    submitPreview.setFormat(format);
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit preview", e);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException, PermissionBackendException {
    if (rsrc.getChange().getStatus() == Change.Status.MERGED) {
        throw new MethodNotAllowedException("delete not permitted");
    } else if (!allowDrafts && rsrc.getChange().getStatus() == Change.Status.DRAFT) {
        // If drafts are disabled, only an administrator can delete a draft.
        try {
            permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
        } catch (AuthException e) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
    } else {
        rsrc.permissions().database(db).check(ChangePermission.DELETE);
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.setOrder(BatchUpdate.Order.DB_BEFORE_REPO);
        bu.addOp(id, opProvider.get());
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException, PermissionBackendException {
    if (rsrc.getChange().getStatus() == Change.Status.MERGED) {
        throw new MethodNotAllowedException("delete not permitted");
    } else if (!allowDrafts && rsrc.getChange().getStatus() == Change.Status.DRAFT) {
        // If drafts are disabled, only an administrator can delete a draft.
        try {
            permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
        } catch (AuthException e) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
    } else {
        rsrc.permissions().database(db).check(ChangePermission.DELETE);
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.setOrder(Order.DB_BEFORE_REPO);
        bu.addOp(id, opProvider.get());
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private boolean couldDeleteWhenIn(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            // New or abandoned changes can be deleted with the right permissions.
            return true;
        case MERGED:
            // Merged changes should never be deleted.
            return false;
        case DRAFT:
            if (allowDrafts) {
                // Drafts can only be deleted if the server has drafts enabled.
                return true;
            }
            try {
                // If drafts are disabled, only administrators may delete.
                return permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER);
            } catch (PermissionBackendException e) {
                return false;
            }
    }
    return false;
}
#method_after
private boolean couldDeleteWhenIn(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            // New or abandoned changes can be deleted with the right permissions.
            return true;
        case MERGED:
            // Merged changes should never be deleted.
            return false;
        case DRAFT:
            if (allowDrafts) {
                // Drafts can only be deleted if the server has drafts enabled.
                return true;
            }
            // If drafts are disabled, only administrators may delete.
            return permissionBackend.user(user).testOrFalse(GlobalPermission.ADMINISTRATE_SERVER);
    }
    return false;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#method_after
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public Class<?> findClass(String name) throws ClassNotFoundException {
    String path = name.replace('.', '/') + ".class";
    InputStream resource = target.getResourceAsStream(path);
    if (resource != null) {
        try {
            byte[] bytes = getBytes(resource);
            return defineClass(name, bytes, 0, bytes.length);
        } catch (IOException e) {
        }
    }
    throw new ClassNotFoundException(name);
}
#method_after
public Class<?> findClass(String name) throws ClassNotFoundException {
    String path = name.replace('.', '/') + ".class";
    InputStream resource = target.getResourceAsStream(path);
    if (resource != null) {
        try {
            byte[] bytes = ByteStreams.toByteArray(resource);
            return defineClass(name, bytes, 0, bytes.length);
        } catch (IOException e) {
        }
    }
    throw new ClassNotFoundException(name);
}
#end_block

#method_before
@Option(name = "--repeat", aliases = { "-r" }, usage = "Run the command multiple times")
private void parse(String arg) {
    runCount = Integer.parseInt(arg);
}
#method_after
@Option(name = "--repeat", aliases = { "-r" }, usage = "Run the command multiple times")
private void parse(String arg) {
    count = Integer.parseInt(arg);
    countSet = true;
}
#end_block

#method_before
@Override
public void onBeanParseEnd(String plugin, Object bean) {
    AdminExampleCommand cmd = (AdminExampleCommand) bean;
    cmd.setRunCount(runCount);
}
#method_after
@Override
public void onBeanParseEnd(String plugin, Object bean) {
    AdminExampleCommand cmd = (AdminExampleCommand) bean;
    if (countSet) {
        cmd.setCount(count);
    }
}
#end_block

#method_before
@Override
protected void run() {
    while (runCount-- > 0) {
        stdout.print("Hello, example administrator\n");
    }
}
#method_after
@Override
protected void run() {
    while (count-- > 0) {
        stdout.print("Hello, example administrator\n");
    }
}
#end_block

#method_before
private void initAuthType() {
    AuthType authType = auth.select("Authentication method", "type", flags.dev ? AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT : AuthType.OPENID);
    switch(authType) {
        case HTTP:
        case HTTP_LDAP:
            {
                String hdr = auth.get("httpHeader");
                if (ui.yesno(hdr != null, "Get username from custom HTTP header")) {
                    auth.string("Username HTTP header", "httpHeader", "SM_USER");
                } else if (hdr != null) {
                    auth.unset("httpHeader");
                }
                auth.string("SSO logout URL", "logoutUrl", null);
                break;
            }
        case LDAP:
        case OAUTH:
            {
                auth.select("Git/HTTP authentication", "gitBasicAuthPolicy", GitBasicAuthPolicy.HTTP);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case LDAP_BIND:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    switch(authType) {
        case LDAP:
        case LDAP_BIND:
        case HTTP_LDAP:
            {
                String server = ldap.string("LDAP server", "server", "ldap://localhost");
                if (// 
                server != null && // 
                !server.startsWith("ldap://") && !server.startsWith("ldaps://")) {
                    if (ui.yesno(false, "Use SSL")) {
                        server = "ldaps://" + server;
                    } else {
                        server = "ldap://" + server;
                    }
                    ldap.set("server", server);
                }
                ldap.string("LDAP username", "username", null);
                ldap.password("username", "password");
                String aBase = ldap.string("Account BaseDN", "accountBase", dnOf(server));
                ldap.string("Group BaseDN", "groupBase", aBase);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case HTTP:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
}
#method_after
private void initAuthType() {
    AuthType authType = auth.select("Authentication method", "type", flags.dev ? AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT : AuthType.OPENID);
    switch(authType) {
        case HTTP:
        case HTTP_LDAP:
            {
                String hdr = auth.get("httpHeader");
                if (ui.yesno(hdr != null, "Get username from custom HTTP header")) {
                    auth.string("Username HTTP header", "httpHeader", "SM_USER");
                } else if (hdr != null) {
                    auth.unset("httpHeader");
                }
                auth.string("SSO logout URL", "logoutUrl", null);
                break;
            }
        case LDAP:
            {
                auth.select("Git/HTTP authentication", "gitBasicAuthPolicy", HTTP, EnumSet.of(HTTP, HTTP_LDAP, LDAP));
                break;
            }
        case OAUTH:
            {
                GitBasicAuthPolicy gitBasicAuth = auth.select("Git/HTTP authentication", "gitBasicAuthPolicy", HTTP, EnumSet.of(HTTP, OAUTH));
                if (gitBasicAuth == OAUTH) {
                    ui.message("*WARNING* Please make sure that your chosen OAuth provider\n" + "supports Git token authentication.\n");
                }
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case LDAP_BIND:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    switch(authType) {
        case LDAP:
        case LDAP_BIND:
        case HTTP_LDAP:
            {
                String server = ldap.string("LDAP server", "server", "ldap://localhost");
                if (// 
                server != null && // 
                !server.startsWith("ldap://") && !server.startsWith("ldaps://")) {
                    if (ui.yesno(false, "Use SSL")) {
                        server = "ldaps://" + server;
                    } else {
                        server = "ldap://" + server;
                    }
                    ldap.set("server", server);
                }
                ldap.string("LDAP username", "username", null);
                ldap.password("username", "password");
                String aBase = ldap.string("Account BaseDN", "accountBase", dnOf(server));
                ldap.string("Group BaseDN", "groupBase", aBase);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case HTTP:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
}
#end_block

#method_before
@Test
public void origin() throws Exception {
    Result change = createChange();
    String url = "/changes/" + change.getChangeId() + "/detail";
    RestResponse r = adminRestSession.get(url);
    r.assertOK();
    assertThat(r.getHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN)).isNull();
    assertThat(r.getHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS)).isNull();
    check(url, true, "http://example.com");
    check(url, true, "https://sub.example.com");
    check(url, true, "http://friend.ly");
    check(url, false, "http://evil.attacker");
    check(url, false, "http://friendsly");
}
#method_after
@Test
public void origin() throws Exception {
    Result change = createChange();
    String url = "/changes/" + change.getChangeId() + "/detail";
    RestResponse r = adminRestSession.get(url);
    r.assertOK();
    assertThat(r.getHeader(ACCESS_CONTROL_ALLOW_ORIGIN)).isNull();
    assertThat(r.getHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS)).isNull();
    check(url, true, "http://example.com");
    check(url, true, "https://sub.example.com");
    check(url, true, "http://friend.ly");
    check(url, false, "http://evil.attacker");
    check(url, false, "http://friendsly");
}
#end_block

#method_before
@Test
public void putWithOriginRefused() throws Exception {
    Result change = createChange();
    String origin = "http://example.com";
    RestResponse r = adminRestSession.putWithHeader("/changes/" + change.getChangeId() + "/topic", new BasicHeader(HttpHeaders.ORIGIN, origin), "A");
    r.assertOK();
    checkCors(r, false, origin);
}
#method_after
@Test
public void putWithOriginRefused() throws Exception {
    Result change = createChange();
    String origin = "http://example.com";
    RestResponse r = adminRestSession.putWithHeader("/changes/" + change.getChangeId() + "/topic", new BasicHeader(ORIGIN, origin), "A");
    r.assertOK();
    checkCors(r, false, origin);
}
#end_block

#method_before
@Test
public void preflightOk() throws Exception {
    Result change = createChange();
    String origin = "http://example.com";
    Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
    req.addHeader(HttpHeaders.ORIGIN, origin);
    req.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, "GET");
    req.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS, "X-Requested-With");
    RestResponse res = adminRestSession.execute(req);
    res.assertOK();
    checkCors(res, true, origin);
}
#method_after
@Test
public void preflightOk() throws Exception {
    Result change = createChange();
    String origin = "http://example.com";
    Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
    req.addHeader(ORIGIN, origin);
    req.addHeader(ACCESS_CONTROL_REQUEST_METHOD, "GET");
    req.addHeader(ACCESS_CONTROL_REQUEST_HEADERS, "X-Requested-With");
    RestResponse res = adminRestSession.execute(req);
    res.assertOK();
    checkCors(res, true, origin);
}
#end_block

#method_before
@Test
public void preflightBadOrigin() throws Exception {
    Result change = createChange();
    Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
    req.addHeader(HttpHeaders.ORIGIN, "http://evil.attacker");
    req.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, "GET");
    adminRestSession.execute(req).assertBadRequest();
}
#method_after
@Test
public void preflightBadOrigin() throws Exception {
    Result change = createChange();
    Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
    req.addHeader(ORIGIN, "http://evil.attacker");
    req.addHeader(ACCESS_CONTROL_REQUEST_METHOD, "GET");
    adminRestSession.execute(req).assertBadRequest();
}
#end_block

#method_before
@Test
public void preflightBadMethod() throws Exception {
    Result change = createChange();
    for (String method : new String[] { "POST", "PUT", "DELETE", "PATCH" }) {
        Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
        req.addHeader(HttpHeaders.ORIGIN, "http://example.com");
        req.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, method);
        adminRestSession.execute(req).assertBadRequest();
    }
}
#method_after
@Test
public void preflightBadMethod() throws Exception {
    Result change = createChange();
    for (String method : new String[] { "POST", "PUT", "DELETE", "PATCH" }) {
        Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
        req.addHeader(ORIGIN, "http://example.com");
        req.addHeader(ACCESS_CONTROL_REQUEST_METHOD, method);
        adminRestSession.execute(req).assertBadRequest();
    }
}
#end_block

#method_before
@Test
public void preflightBadHeader() throws Exception {
    Result change = createChange();
    Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
    req.addHeader(HttpHeaders.ORIGIN, "http://example.com");
    req.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, "GET");
    req.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS, "X-Gerrit-Auth");
    adminRestSession.execute(req).assertBadRequest();
}
#method_after
@Test
public void preflightBadHeader() throws Exception {
    Result change = createChange();
    Request req = Request.Options(adminRestSession.url() + "/a/changes/" + change.getChangeId() + "/detail");
    req.addHeader(ORIGIN, "http://example.com");
    req.addHeader(ACCESS_CONTROL_REQUEST_METHOD, "GET");
    req.addHeader(ACCESS_CONTROL_REQUEST_HEADERS, "X-Gerrit-Auth");
    adminRestSession.execute(req).assertBadRequest();
}
#end_block

#method_before
private RestResponse check(String url, boolean accept, String origin) throws Exception {
    Header hdr = new BasicHeader(HttpHeaders.ORIGIN, origin);
    RestResponse r = adminRestSession.getWithHeader(url, hdr);
    r.assertOK();
    checkCors(r, accept, origin);
    return r;
}
#method_after
private RestResponse check(String url, boolean accept, String origin) throws Exception {
    Header hdr = new BasicHeader(ORIGIN, origin);
    RestResponse r = adminRestSession.getWithHeader(url, hdr);
    r.assertOK();
    checkCors(r, accept, origin);
    return r;
}
#end_block

#method_before
private void checkCors(RestResponse r, boolean accept, String origin) {
    String allowOrigin = r.getHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN);
    String allowCred = r.getHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS);
    String allowMethods = r.getHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS);
    String allowHeaders = r.getHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS);
    if (accept) {
        assertThat(allowOrigin).isEqualTo(origin);
        assertThat(allowCred).isEqualTo("true");
        assertThat(allowMethods).isEqualTo("GET, OPTIONS");
        assertThat(allowHeaders).isEqualTo("X-Requested-With");
    } else {
        assertThat(allowOrigin).isNull();
        assertThat(allowCred).isNull();
        assertThat(allowMethods).isNull();
        assertThat(allowHeaders).isNull();
    }
}
#method_after
private void checkCors(RestResponse r, boolean accept, String origin) {
    String allowOrigin = r.getHeader(ACCESS_CONTROL_ALLOW_ORIGIN);
    String allowCred = r.getHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS);
    String allowMethods = r.getHeader(ACCESS_CONTROL_ALLOW_METHODS);
    String allowHeaders = r.getHeader(ACCESS_CONTROL_ALLOW_HEADERS);
    if (accept) {
        assertThat(allowOrigin).isEqualTo(origin);
        assertThat(allowCred).isEqualTo("true");
        assertThat(allowMethods).isEqualTo("GET, OPTIONS");
        assertThat(allowHeaders).isEqualTo("X-Requested-With");
    } else {
        assertThat(allowOrigin).isNull();
        assertThat(allowCred).isNull();
        assertThat(allowMethods).isNull();
        assertThat(allowHeaders).isNull();
    }
}
#end_block

#method_before
private boolean equals(PatchSet p, String id) {
    boolean exact = getField() == EXACT_COMMIT;
    String rev = p.getRevision() != null ? p.getRevision().get() : null;
    return (exact && id.equals(rev)) || (!exact && rev != null && rev.startsWith(id));
}
#method_after
protected boolean equals(PatchSet p, String id) {
    boolean exact = getField() == EXACT_COMMIT;
    String rev = p.getRevision() != null ? p.getRevision().get() : null;
    return (exact && id.equals(rev)) || (!exact && rev != null && rev.startsWith(id));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    index = new FakeChangeIndex(FakeChangeIndex.V2);
    indexes = new ChangeIndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new ChangeIndexRewriter(indexes, IndexConfig.builder().maxPages(3).build());
}
#method_after
@Before
public void setUp() throws Exception {
    index = new FakeChangeIndex(FakeChangeIndex.V2);
    indexes = new ChangeIndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new ChangeIndexRewriter(indexes, IndexConfig.builder().maxTerms(3).build());
}
#end_block

#method_before
public static IndexConfig fromConfig(Config cfg) {
    Builder b = builder();
    return b.maxLimit(cfg.getInt("index", null, "maxLimit", b.maxLimit())).maxPages(cfg.getInt("index", null, "maxPages", b.maxPages())).maxTerms(cfg.getInt("index", null, "maxTerms", b.maxTerms())).build();
}
#method_after
public static IndexConfig fromConfig(Config cfg) {
    Builder b = builder();
    setIfPresent(cfg, "maxLimit", b::maxLimit);
    setIfPresent(cfg, "maxPages", b::maxPages);
    setIfPresent(cfg, "maxTerms", b::maxTerms);
    return b.build();
}
#end_block

#method_before
private List<ChangeControl> asChangeControls(List<ChangeData> cds, CurrentUser user) throws OrmException {
    // Protect against Lucene returning a copy of the change from the open/closed subindexes. This
    // is a special case of stale data in the index, when a delete from one index has flakily not
    // been processed yet, but the add to the other index has. Normally, we just ignore staleness
    // and return stale results, and downstream callers figure out how to deal with it. But in the
    // specific case of ChangesCollection, returning two identical results would cause an immediate
    // ResourceNotFoundException, which doesn't even give callers a chance to recover.
    Set<Change.Id> seen = Sets.newHashSetWithExpectedSize(cds.size());
    List<ChangeControl> ctls = new ArrayList<>(cds.size());
    for (ChangeData cd : cds) {
        if (seen.add(cd.getId())) {
            ctls.add(cd.changeControl(user));
        }
    }
    return ctls;
}
#method_after
private List<ChangeControl> asChangeControls(List<ChangeData> cds, CurrentUser user) throws OrmException {
    List<ChangeControl> ctls = new ArrayList<>(cds.size());
    if (!indexConfig.separateChangeSubIndexes()) {
        for (ChangeData cd : cds) {
            ctls.add(cd.changeControl(user));
        }
        return ctls;
    }
    // If an index implementation uses separate non-atomic subindexes, it's possible to temporarily
    // observe a change as present in both subindexes, if this search is concurrent with a write.
    // Dedup to avoid confusing the caller. We can choose an arbitrary ChangeData instance because
    // the index results have no stored fields, so the data is already reloaded. (It's also possible
    // that a change might appear in zero subindexes, but there's nothing we can do here to help
    // this case.)
    Set<Change.Id> seen = Sets.newHashSetWithExpectedSize(cds.size());
    for (ChangeData cd : cds) {
        if (seen.add(cd.getId())) {
            ctls.add(cd.changeControl(user));
        }
    }
    return ctls;
}
#end_block

#method_before
private void addEmail(String email) throws UnloggedFailure, RestApiException, OrmException, IOException, PermissionBackendException {
    EmailInput in = new EmailInput();
    in.email = email;
    in.noConfirmation = true;
    try {
        createEmailFactory.create(email).apply(rsrc, in);
    } catch (EmailException e) {
        throw die(e.getMessage());
    }
}
#method_after
private void addEmail(String email) throws UnloggedFailure, RestApiException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    EmailInput in = new EmailInput();
    in.email = email;
    in.noConfirmation = true;
    try {
        createEmailFactory.create(email).apply(rsrc, in);
    } catch (EmailException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
private void deleteEmail(String email) throws RestApiException, OrmException, IOException, PermissionBackendException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#method_after
private void deleteEmail(String email) throws RestApiException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    a.setStatus(Strings.nullToEmpty(input.status));
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getStatus()) ? Response.none() : Response.ok(a.getStatus());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    String newStatus = input.status;
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            a.setStatus(Strings.nullToEmpty(newStatus));
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getStatus()) ? Response.none() : Response.ok(a.getStatus());
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, OrmException, IOException {
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (email.equals(a.getPreferredEmail())) {
        return Response.ok("");
    }
    a.setPreferredEmail(email);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Response.created("");
}
#method_after
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, OrmException, IOException {
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            if (email.equals(a.getPreferredEmail())) {
                alreadyPreferred.set(true);
            } else {
                a.setPreferredEmail(email);
            }
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#end_block

#method_before
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, PermissionBackendException {
    if (self.get() != rsrc.getUser() || input.noConfirmation) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (!OutgoingEmailValidator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser() || input.noConfirmation) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (!OutgoingEmailValidator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, PermissionBackendException {
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#method_after
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#method_after
@Override
public Response<?> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#end_block

#method_before
public Response<?> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException {
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow deleting emails");
    }
    Set<AccountExternalId> extIds = dbProvider.get().accountExternalIds().byAccount(user.getAccountId()).toList().stream().filter(e -> email.equals(e.getEmailAddress())).collect(toSet());
    if (extIds.isEmpty()) {
        throw new ResourceNotFoundException(email);
    }
    try {
        for (AccountExternalId extId : extIds) {
            AuthRequest authRequest = new AuthRequest(extId.getKey().get());
            authRequest.setEmailAddress(email);
            accountManager.unlink(user.getAccountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
public Response<?> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException {
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow deleting emails");
    }
    Set<ExternalId> extIds = externalIds.byAccount(dbProvider.get(), user.getAccountId()).stream().filter(e -> email.equals(e.email())).collect(toSet());
    if (extIds.isEmpty()) {
        throw new ResourceNotFoundException(email);
    }
    try {
        for (ExternalId extId : extIds) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(email);
            accountManager.unlink(user.getAccountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void addEmail(EmailInput input) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), input.email);
    try {
        createEmailFactory.create(input.email).apply(rsrc, input);
    } catch (EmailException | OrmException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot add email", e);
    }
}
#method_after
@Override
public void addEmail(EmailInput input) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), input.email);
    try {
        createEmailFactory.create(input.email).apply(rsrc, input);
    } catch (EmailException | OrmException | IOException | ConfigInvalidException | PermissionBackendException e) {
        throw new RestApiException("Cannot add email", e);
    }
}
#end_block

#method_before
@Override
public void deleteEmail(String email) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), email);
    try {
        deleteEmail.apply(rsrc, null);
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete email", e);
    }
}
#method_after
@Override
public void deleteEmail(String email) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), email);
    try {
        deleteEmail.apply(rsrc, null);
    } catch (OrmException | IOException | ConfigInvalidException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete email", e);
    }
}
#end_block

#method_before
@Override
public List<AccountExternalIdInfo> getExternalIds() throws RestApiException {
    try {
        return getExternalIds.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get external IDs", e);
    }
}
#method_after
@Override
public List<AccountExternalIdInfo> getExternalIds() throws RestApiException {
    try {
        return getExternalIds.apply(account);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot get external IDs", e);
    }
}
#end_block

#method_before
@Override
public void deleteExternalIds(List<String> externalIds) throws RestApiException {
    try {
        deleteExternalIds.apply(account, externalIds);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot delete external IDs", e);
    }
}
#method_after
@Override
public void deleteExternalIds(List<String> externalIds) throws RestApiException {
    try {
        deleteExternalIds.apply(account, externalIds);
    } catch (IOException | OrmException | ConfigInvalidException e) {
        throw new RestApiException("Cannot delete external IDs", e);
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            a.setFullName(newName);
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new DefaultPermissionBackendModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public List<PluginDefinedInfo> create(ChangeData cd) {
    List<PluginDefinedInfo> plugins = new ArrayList<PluginDefinedInfo>(attributeFactories.plugins().size());
    for (String plugin : attributeFactories.plugins()) {
        for (Provider<ChangeAttributeFactory> provider : attributeFactories.byPlugin(plugin).values()) {
            PluginDefinedInfo pda = null;
            try {
                pda = provider.get().create(cd, this, plugin);
            } catch (RuntimeException e) {
            /* Eat runtime exceptions so that queries don't fail. */
            }
            if (pda != null) {
                pda.name = plugin;
                plugins.add(pda);
            }
        }
    }
    if (plugins.isEmpty()) {
        plugins = null;
    }
    return plugins;
}
#method_after
@Override
public List<PluginDefinedInfo> create(ChangeData cd) {
    List<PluginDefinedInfo> plugins = new ArrayList<>(attributeFactories.plugins().size());
    for (String plugin : attributeFactories.plugins()) {
        for (Provider<ChangeAttributeFactory> provider : attributeFactories.byPlugin(plugin).values()) {
            PluginDefinedInfo pda = null;
            try {
                pda = provider.get().create(cd, this, plugin);
            } catch (RuntimeException e) {
            /* Eat runtime exceptions so that queries don't fail. */
            }
            if (pda != null) {
                pda.name = plugin;
                plugins.add(pda);
            }
        }
    }
    if (plugins.isEmpty()) {
        plugins = null;
    }
    return plugins;
}
#end_block

#method_before
@Override
public List<?> apply(TopLevelResource rsrc) throws BadRequestException, AuthException, OrmException {
    List<List<ChangeInfo>> out;
    try {
        out = query();
    } catch (QueryParseException e) {
        // This is a hack to detect an operator that requires authentication.
        Pattern p = Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer|has:.*)$");
        Matcher m = p.matcher(e.getMessage());
        if (m.matches()) {
            String op = m.group(1);
            throw new AuthException("Must be signed-in to use " + op);
        }
        throw new BadRequestException(e.getMessage());
    }
    return out.size() == 1 ? out.get(0) : out;
}
#method_after
@Override
public List<?> apply(TopLevelResource rsrc) throws BadRequestException, AuthException, OrmException {
    List<List<ChangeInfo>> out;
    try {
        out = query();
    } catch (QueryParseException e) {
        // This is a hack to detect an operator that requires authentication.
        Pattern p = Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer|has:.*)$");
        Matcher m = p.matcher(e.getMessage());
        if (m.matches()) {
            String op = m.group(1);
            throw new AuthException("Must be signed-in to use " + op);
        }
        throw new BadRequestException(e.getMessage(), e);
    }
    return out.size() == 1 ? out.get(0) : out;
}
#end_block

#method_before
private List<List<ChangeInfo>> query() throws OrmException, QueryParseException {
    if (imp.isDisabled()) {
        throw new QueryParseException("query disabled");
    }
    if (queries == null || queries.isEmpty()) {
        queries = Collections.singletonList("status:open");
    } else if (queries.size() > 10) {
        // users from submitting too much to the server in a single call.
        throw new QueryParseException("limit of 10 queries");
    }
    int cnt = queries.size();
    List<QueryResult<ChangeData>> results = imp.query(qb.parse(queries));
    ChangeJson cjson = json.create(options);
    cjson.setPluginDefinedAttributesFactory(this.imp);
    List<List<ChangeInfo>> res = cjson.formatQueryResults(results);
    for (int n = 0; n < cnt; n++) {
        List<ChangeInfo> info = res.get(n);
        if (results.get(n).more()) {
            info.get(info.size() - 1)._moreChanges = true;
        }
    }
    return res;
}
#method_after
private List<List<ChangeInfo>> query() throws OrmException, QueryParseException {
    if (imp.isDisabled()) {
        throw new QueryParseException("query disabled");
    }
    if (queries == null || queries.isEmpty()) {
        queries = Collections.singletonList("status:open");
    } else if (queries.size() > 10) {
        // users from submitting too much to the server in a single call.
        throw new QueryParseException("limit of 10 queries");
    }
    int cnt = queries.size();
    List<QueryResult<ChangeData>> results = imp.query(qb.parse(queries));
    boolean requireLazyLoad = containsAnyOf(options, ImmutableSet.of(DETAILED_LABELS, LABELS)) && !qb.getArgs().getSchema().hasField(ChangeField.STORED_SUBMIT_RECORD_LENIENT);
    ChangeJson cjson = json.create(options);
    cjson.setPluginDefinedAttributesFactory(this.imp);
    List<List<ChangeInfo>> res = cjson.lazyLoad(requireLazyLoad || containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results);
    for (int n = 0; n < cnt; n++) {
        List<ChangeInfo> info = res.get(n);
        if (results.get(n).more()) {
            info.get(info.size() - 1)._moreChanges = true;
        }
    }
    return res;
}
#end_block

#method_before
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException, NoSuchChangeException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException | NoSuchChangeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#method_after
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.empty(), true);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult<ChangeData>, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult<ChangeData> in) {
            return in.entities();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = new HashMap<>();
    for (QueryResult<ChangeData> r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.entities());
        if (!infos.isEmpty() && r.more()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(QueryResult::entities));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = new HashMap<>();
    for (QueryResult<ChangeData> r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.entities());
        if (!infos.isEmpty() && r.more()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private void ensureLoaded(Iterable<ChangeData> all) throws OrmException {
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION) || has(MESSAGES)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    if (has(REVIEWED) && userProvider.get().isIdentifiedUser()) {
        ChangeData.ensureReviewedByLoadedForOpenChanges(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
}
#method_after
private void ensureLoaded(Iterable<ChangeData> all) throws OrmException {
    if (lazyLoad) {
        ChangeData.ensureChangeLoaded(all);
        if (has(ALL_REVISIONS)) {
            ChangeData.ensureAllPatchSetsLoaded(all);
        } else if (has(CURRENT_REVISION) || has(MESSAGES)) {
            ChangeData.ensureCurrentPatchSetLoaded(all);
        }
        if (has(REVIEWED) && userProvider.get().isIdentifiedUser()) {
            ChangeData.ensureReviewedByLoadedForOpenChanges(all);
        }
        ChangeData.ensureCurrentApprovalsLoaded(all);
    } else {
        for (ChangeData cd : all) {
            cd.setLazyLoad(false);
        }
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
            if (state == ReviewerStateInternal.REMOVED) {
                continue;
            }
            Collection<AccountInfo> reviewers = toAccountInfo(cd.reviewers().byState(state));
            reviewers.addAll(toAccountInfoByEmail(cd.reviewersByEmail().byState(state)));
            if (!reviewers.isEmpty()) {
                out.reviewers.put(state.asReviewerState(), reviewers);
            }
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    return cd.submitRecords(SUBMIT_RULE_OPTIONS_LENIENT);
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus.TO_LABEL_INFO));
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().all());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    SetMultimap<Account.Id, PatchSetApproval> current = MultimapBuilder.hashKeys().hashSetValues().build();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, tag, date);
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, permittedVotingRange, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#method_after
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.permittedVotingRange = permittedVotingRange;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, Collection<LabelInfo> labels) {
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (ctl.canRemoveReviewer(id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> toAccountInfo(Collection<Account.Id> accounts) {
    return FluentIterable.from(accounts).transform(new Function<Account.Id, AccountInfo>() {

        @Override
        public AccountInfo apply(Account.Id id) {
            return accountLoader.get(id);
        }
    }).toSortedList(AccountInfoComparator.ORDER_NULLS_FIRST);
}
#method_after
private Collection<AccountInfo> toAccountInfo(Collection<Account.Id> accounts) {
    return accounts.stream().map(accountLoader::get).sorted(AccountInfoComparator.ORDER_NULLS_FIRST).collect(toList());
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, rw, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, Repository repo, boolean fillCommit) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(ctl.getChange().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Test
public void addingMultipleReviewersAndCCsAtOnceSendsOnlyOneEmail() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput();
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        for (int i = 0; i < 10; i++) {
            reviewInput.reviewer(String.format("%s-%s@gerritcodereview.com", state, i), state, true);
        }
    }
    sender.clear();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(reviewInput);
    assertThat(sender.getMessages()).hasSize(1);
}
#method_after
@Test
public void addingMultipleReviewersAndCCsAtOnceSendsOnlyOneEmail() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput();
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        for (int i = 0; i < 10; i++) {
            reviewInput.reviewer(String.format("%s-%s@gerritcodereview.com", state, i), state, true);
        }
    }
    assertThat(reviewInput.reviewers).hasSize(20);
    sender.clear();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(reviewInput);
    assertThat(sender.getMessages()).hasSize(1);
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
public void execute(Collection<BatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryRun) throws UpdateException, RestApiException {
    checkNotNull(listener);
    checkSameProject(updates);
    // collection.
    if (migration.disableChangeReviewDb()) {
        ImmutableList<NoteDbBatchUpdate> noteDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        NoteDbBatchUpdate.execute(noteDbUpdates, listener, requestId, dryRun);
    } else {
        ImmutableList<ReviewDbBatchUpdate> reviewDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        ReviewDbBatchUpdate.execute(reviewDbUpdates, listener, requestId, dryRun);
    }
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
public void execute(Collection<BatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryRun) throws UpdateException, RestApiException {
    checkNotNull(listener);
    checkDifferentProject(updates);
    // collection.
    if (migration.disableChangeReviewDb()) {
        ImmutableList<NoteDbBatchUpdate> noteDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        NoteDbBatchUpdate.execute(noteDbUpdates, listener, requestId, dryRun);
    } else {
        ImmutableList<ReviewDbBatchUpdate> reviewDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        ReviewDbBatchUpdate.execute(reviewDbUpdates, listener, requestId, dryRun);
    }
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    submitPreview.setFormat(format);
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit preview", e);
    }
}
#end_block

#method_before
public WithUser user(Provider<CurrentUser> user) {
    return user(user.get());
}
#method_after
public WithUser user(Provider<CurrentUser> user) {
    return user(checkNotNull(user, "Provider<CurrentUser>").get());
}
#end_block

#method_before
public ForRef ref(Branch.NameKey ref) {
    return project(ref.getParentKey()).ref(ref.get());
}
#method_after
public ForRef ref(Branch.NameKey ref) {
    return project(ref.getParentKey()).ref(ref.get()).database(db);
}
#end_block

#method_before
public ForChange change(ChangeData cd) throws OrmException {
    return ref(cd.change().getDest()).change(cd);
}
#method_after
public ForChange change(ChangeData cd) {
    try {
        return ref(cd.change().getDest()).change(cd);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#end_block

#method_before
public boolean testOrFalse(ChangePermissionOrLabel perm) {
    try {
        return test(perm);
    } catch (PermissionBackendException e) {
        return false;
    }
}
#method_after
public boolean testOrFalse(ChangePermissionOrLabel perm) {
    try {
        return test(perm);
    } catch (PermissionBackendException e) {
        logger.warn("Cannot test " + perm + "; assuming false", e);
        return false;
    }
}
#end_block

#method_before
public Set<LabelPermission.WithValue> test(LabelType type) throws PermissionBackendException {
    checkNotNull(type, "LabelType");
    List<LabelValue> vals = type.getValues();
    Set<LabelPermission.WithValue> r = Sets.newHashSetWithExpectedSize(vals.size());
    for (LabelValue v : vals) {
        r.add(new LabelPermission.WithValue(type.getName(), v.getValue()));
    }
    return test(r);
}
#method_after
public Set<LabelPermission.WithValue> test(LabelType label) throws PermissionBackendException {
    return test(valuesOf(checkNotNull(label, "LabelType")));
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
        }
    }
    postReviewers.emailReviewers(change, to, cc, notify, accountsToNotify);
}
#method_after
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, @Nullable NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.state == ReviewerState.REVIEWER) {
            to.addAll(addition.reviewers.keySet());
            toByEmail.addAll(addition.reviewersByEmail);
        } else if (addition.state == ReviewerState.CC) {
            cc.addAll(addition.reviewers.keySet());
            ccByEmail.addAll(addition.reviewersByEmail);
        }
    }
    if (reviewerAdditions.size() > 0) {
        reviewerAdditions.get(0).op.emailReviewers(change, to, cc, toByEmail, ccByEmail, notify, accountsToNotify);
    }
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException, PermissionBackendException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    PermissionBackend.ForChange perm = rev.permissions();
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        if (caller.getUser().isInternalUser()) {
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    IdentifiedUser reviewer = accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf);
    try {
        perm.user(reviewer).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", reviewer.getAccountId()));
    }
    ChangeControl target = caller.forUser(reviewer);
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException, PermissionBackendException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    CurrentUser caller = rev.getUser();
    PermissionBackend.ForChange perm = rev.permissions().database(db);
    LabelTypes labelTypes = rev.getControl().getLabelTypes();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = labelTypes.byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        if (!caller.isInternalUser()) {
            try {
                perm.check(new LabelPermission.WithValue(ON_BEHALF_OF, type, ent.getValue()));
            } catch (AuthException e) {
                throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", type.getName(), in.onBehalfOf));
            }
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    IdentifiedUser reviewer = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(reviewer).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", reviewer.getAccountId()));
    }
    ChangeControl ctl = rev.getControl().forUser(reviewer);
    return new RevisionResource(changes.parse(ctl), rev.getPatchSet());
}
#end_block

#method_before
private void checkLabels(RevisionResource rsrc, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException {
    LabelTypes types = rsrc.getControl().getLabelTypes();
    PermissionBackend.ForChange perm = rsrc.permissions();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = types.byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        checkOrSquash(perm, lt, strict, ent);
    }
}
#method_after
private void checkLabels(RevisionResource rsrc, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException {
    LabelTypes types = rsrc.getControl().getLabelTypes();
    PermissionBackend.ForChange perm = rsrc.permissions();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = types.byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        short val = ent.getValue();
        try {
            perm.check(new LabelPermission.WithValue(lt, val));
        } catch (AuthException e) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", lt.getName(), val));
            }
            ent.setValue(perm.squashThenCheck(lt, val));
        }
    }
}
#end_block

#method_before
private <T extends CommentInput> void cleanUpComments(Map<String, List<T>> commentsPerPath) {
    Iterator<List<T>> mapValueIterator = commentsPerPath.values().iterator();
    while (mapValueIterator.hasNext()) {
        List<T> comments = mapValueIterator.next();
        if (comments == null) {
            mapValueIterator.remove();
            continue;
        }
        cleanUpComments(comments);
        if (comments.isEmpty()) {
            mapValueIterator.remove();
        }
    }
}
#method_after
private static <T extends CommentInput> void cleanUpComments(Map<String, List<T>> commentsPerPath) {
    Iterator<List<T>> mapValueIterator = commentsPerPath.values().iterator();
    while (mapValueIterator.hasNext()) {
        List<T> comments = mapValueIterator.next();
        if (comments == null) {
            mapValueIterator.remove();
            continue;
        }
        cleanUpComments(comments);
        if (comments.isEmpty()) {
            mapValueIterator.remove();
        }
    }
}
#end_block

#method_before
private <T extends CommentInput> void cleanUpComments(List<T> comments) {
    Iterator<T> commentsIterator = comments.iterator();
    while (commentsIterator.hasNext()) {
        T comment = commentsIterator.next();
        if (comment == null) {
            commentsIterator.remove();
            continue;
        }
        comment.message = Strings.nullToEmpty(comment.message).trim();
        if (comment.message.isEmpty()) {
            commentsIterator.remove();
        }
    }
}
#method_after
private static <T extends CommentInput> void cleanUpComments(List<T> comments) {
    Iterator<T> commentsIterator = comments.iterator();
    while (commentsIterator.hasNext()) {
        T comment = commentsIterator.next();
        if (comment == null) {
            commentsIterator.remove();
            continue;
        }
        comment.message = Strings.nullToEmpty(comment.message).trim();
        if (comment.message.isEmpty()) {
            commentsIterator.remove();
        }
    }
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, OrmException {
    cleanUpComments(commentsPerPath);
    ensureCommentsAreAddable(revision, commentsPerPath);
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws OrmException, BadRequestException {
    Set<String> revisionFilePaths = getAffectedFilePaths(revision);
    for (Map.Entry<String, List<T>> entry : commentsPerPath.entrySet()) {
        String path = entry.getKey();
        PatchSet.Id patchSetId = revision.getChange().currentPatchSetId();
        ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId);
        List<T> comments = entry.getValue();
        for (T comment : comments) {
            ensureLineIsNonNegative(comment.line, path);
            ensureCommentNotOnMagicFilesOfAutoMerge(path, comment);
            ensureRangeIsValid(path, comment.range);
        }
    }
}
#end_block

#method_before
private void ensurePathRefersToAvailableOrMagicFile(String path, Set<String> availableFilePaths, PatchSet.Id patchSetId) throws BadRequestException {
    if (!availableFilePaths.contains(path) && !Patch.isMagic(path)) {
        throw new BadRequestException(String.format("file %s not found in revision %s", path, patchSetId));
    }
}
#method_after
private static void ensurePathRefersToAvailableOrMagicFile(String path, Set<String> availableFilePaths, PatchSet.Id patchSetId) throws BadRequestException {
    if (!availableFilePaths.contains(path) && !Patch.isMagic(path)) {
        throw new BadRequestException(String.format("file %s not found in revision %s", path, patchSetId));
    }
}
#end_block

#method_before
private void ensureLineIsNonNegative(Integer line, String path) throws BadRequestException {
    if (line != null && line < 0) {
        throw new BadRequestException(String.format("negative line number %d not allowed on %s", line, path));
    }
}
#method_after
private static void ensureLineIsNonNegative(Integer line, String path) throws BadRequestException {
    if (line != null && line < 0) {
        throw new BadRequestException(String.format("negative line number %d not allowed on %s", line, path));
    }
}
#end_block

#method_before
private <T extends CommentInput> void ensureCommentNotOnMagicFilesOfAutoMerge(String path, T comment) throws BadRequestException {
    if (Patch.isMagic(path) && comment.side == Side.PARENT && comment.parent == null) {
        throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
    }
}
#method_after
private static <T extends CommentInput> void ensureCommentNotOnMagicFilesOfAutoMerge(String path, T comment) throws BadRequestException {
    if (Patch.isMagic(path) && comment.side == Side.PARENT && comment.parent == null) {
        throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
    }
}
#end_block

#method_before
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#method_after
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureSizeOfJsonInputIsWithinBounds(c);
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#end_block

#method_before
private void ensureRobotIdIsSet(String robotId, String commentPath) throws BadRequestException {
    if (robotId == null) {
        throw new BadRequestException(String.format("robotId is missing for robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureRobotIdIsSet(String robotId, String commentPath) throws BadRequestException {
    if (robotId == null) {
        throw new BadRequestException(String.format("robotId is missing for robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRobotRunIdIsSet(String robotRunId, String commentPath) throws BadRequestException {
    if (robotRunId == null) {
        throw new BadRequestException(String.format("robotRunId is missing for robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureRobotRunIdIsSet(String robotRunId, String commentPath) throws BadRequestException {
    if (robotRunId == null) {
        throw new BadRequestException(String.format("robotRunId is missing for robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureFixSuggestionsAreAddable(List<FixSuggestionInfo> fixSuggestionInfos, String commentPath) throws BadRequestException {
    if (fixSuggestionInfos == null) {
        return;
    }
    for (FixSuggestionInfo fixSuggestionInfo : fixSuggestionInfos) {
        ensureDescriptionIsSet(commentPath, fixSuggestionInfo.description);
        ensureFixReplacementsAreAddable(commentPath, fixSuggestionInfo.replacements);
    }
}
#method_after
private static void ensureFixSuggestionsAreAddable(List<FixSuggestionInfo> fixSuggestionInfos, String commentPath) throws BadRequestException {
    if (fixSuggestionInfos == null) {
        return;
    }
    for (FixSuggestionInfo fixSuggestionInfo : fixSuggestionInfos) {
        ensureDescriptionIsSet(commentPath, fixSuggestionInfo.description);
        ensureFixReplacementsAreAddable(commentPath, fixSuggestionInfo.replacements);
    }
}
#end_block

#method_before
private void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureFixReplacementsAreAddable(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(commentPath, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureReplacementPathIsSet(commentPath, fixReplacementInfo.path);
        ensureReplacementPathRefersToFileOfComment(commentPath, fixReplacementInfo.path);
        ensureRangeIsSet(commentPath, fixReplacementInfo.range);
        ensureRangeIsValid(commentPath, fixReplacementInfo.range);
        ensureReplacementStringIsSet(commentPath, fixReplacementInfo.replacement);
    }
}
#method_after
private static void ensureFixReplacementsAreAddable(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(commentPath, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureReplacementPathIsSet(commentPath, fixReplacementInfo.path);
        ensureRangeIsSet(commentPath, fixReplacementInfo.range);
        ensureRangeIsValid(commentPath, fixReplacementInfo.range);
        ensureReplacementStringIsSet(commentPath, fixReplacementInfo.replacement);
    }
    Map<String, List<FixReplacementInfo>> replacementsPerFilePath = fixReplacementInfos.stream().collect(groupingBy(fixReplacement -> fixReplacement.path));
    for (List<FixReplacementInfo> sameFileReplacements : replacementsPerFilePath.values()) {
        ensureRangesDoNotOverlap(commentPath, sameFileReplacements);
    }
}
#end_block

#method_before
private void ensureReplacementsArePresent(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    if (fixReplacementInfos == null || fixReplacementInfos.isEmpty()) {
        throw new BadRequestException(String.format("At least one replacement is " + "required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureReplacementsArePresent(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    if (fixReplacementInfos == null || fixReplacementInfos.isEmpty()) {
        throw new BadRequestException(String.format("At least one replacement is " + "required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsSet(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureRangeIsSet(String commentPath, Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsValid(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not" + " valid for the replacement of the robot comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#method_after
private static void ensureRangeIsValid(String commentPath, Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#end_block

#method_before
private void ensureReplacementStringIsSet(String commentPath, String replacement) throws BadRequestException {
    if (replacement == null) {
        throw new BadRequestException(String.format("A content for replacement " + "must be indicated for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureReplacementStringIsSet(String commentPath, String replacement) throws BadRequestException {
    if (replacement == null) {
        throw new BadRequestException(String.format("A content for replacement " + "must be indicated for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private List<FixReplacement> toFixReplacements(List<FixReplacementInfo> fixReplacementInfos) {
    return fixReplacementInfos.stream().map(this::toFixReplacement).collect(Collectors.toList());
}
#method_after
private List<FixReplacement> toFixReplacements(List<FixReplacementInfo> fixReplacementInfos) {
    return fixReplacementInfos.stream().map(this::toFixReplacement).collect(toList());
}
#end_block

#method_before
private boolean isReviewer(ChangeContext ctx) throws OrmException {
    if (ctx.getAccountId().equals(ctx.getChange().getOwner())) {
        return true;
    }
    for (PostReviewers.Addition addition : reviewerResults) {
        if (addition.op.addedReviewers == null) {
            continue;
        }
        for (PatchSetApproval psa : addition.op.addedReviewers) {
            if (psa.getAccountId().equals(ctx.getAccountId())) {
                return true;
            }
        }
    }
    ChangeData cd = changeDataFactory.create(db.get(), ctx.getControl());
    ReviewerSet reviewers = cd.reviewers();
    if (reviewers.byState(REVIEWER).contains(ctx.getAccountId())) {
        return true;
    }
    return false;
}
#method_after
private boolean isReviewer(ChangeContext ctx) throws OrmException {
    if (ctx.getAccountId().equals(ctx.getChange().getOwner())) {
        return true;
    }
    ChangeData cd = changeDataFactory.create(db.get(), ctx.getControl());
    ReviewerSet reviewers = cd.reviewers();
    if (reviewers.byState(REVIEWER).contains(ctx.getAccountId())) {
        return true;
    }
    return false;
}
#end_block

#method_before
public static Map<Change.Id, ChangeData> asMap(List<ChangeData> changes) {
    return changes.stream().collect(Collectors.toMap(ChangeData::getId, cd -> cd));
}
#method_after
public static Map<Change.Id, ChangeData> asMap(List<ChangeData> changes) {
    return changes.stream().collect(toMap(ChangeData::getId, cd -> cd));
}
#end_block

#method_before
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        Long count = Stream.concat(publishedComments().stream(), robotComments().stream()).filter(c -> (c.unresolved == Boolean.TRUE)).count();
        unresolvedCommentCount = count.intValue();
    }
    return unresolvedCommentCount;
}
#method_after
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        List<Comment> comments = Stream.concat(publishedComments().stream(), robotComments().stream()).collect(toList());
        Set<String> nonLeafSet = comments.stream().map(c -> c.parentUuid).collect(toSet());
        Long count = comments.stream().filter(c -> (c.unresolved && !nonLeafSet.contains(c.key.uuid))).count();
        unresolvedCommentCount = count.intValue();
    }
    return unresolvedCommentCount;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (RawText.isBinary(ol.getBytes())) {
            continue;
        }
        try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) {
            if (doesInputStreanContainCR(isr)) {
                messages.add(new CommitValidationMessage("found carriage return (CR) character in file: " + path, true));
            }
        }
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        try (InputStream in = ol.openStream()) {
            if (RawText.isBinary(in) || contentTypeUtil.isBlacklistedBinaryContentType(ol, path, cfg)) {
                continue;
            }
        }
        try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) {
            if (doesInputStreanContainCR(isr)) {
                messages.add(new CommitValidationMessage("found carriage return (CR) character in file: " + path, true));
            }
        }
    }
    return messages;
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (RawText.isBinary(ol.getBytes())) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        try (InputStream in = ol.openStream()) {
            if (RawText.isBinary(in) || contentTypeUtil.isBlacklistedBinaryContentType(ol, path, cfg)) {
                continue;
            }
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, String[] blockedTypes, boolean whitelist) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        String contentType = contentTypeUtil.getContentType(ol.getBytes(), path);
        if ((contentTypeUtil.matchesAny(contentType, blockedTypes) && !whitelist) || (!contentTypeUtil.matchesAny(contentType, blockedTypes) && whitelist)) {
            messages.add(new CommitValidationMessage("found blocked content type (" + contentType + ") in file: " + path, true));
        }
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, String[] blockedTypes, boolean whitelist) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        String contentType = contentTypeUtil.getContentType(ol, path);
        if ((contentTypeUtil.matchesAny(contentType, blockedTypes) && !whitelist) || (!contentTypeUtil.matchesAny(contentType, blockedTypes) && whitelist)) {
            messages.add(new CommitValidationMessage("found blocked content type (" + contentType + ") in file: " + path, true));
        }
    }
    return messages;
}
#end_block

#method_before
public String getContentType(byte[] bytes, String pathname) throws IOException {
    return mimeUtil.getMimeType(pathname, bytes).toString();
}
#method_after
public String getContentType(ObjectLoader ol, String pathname) throws IOException {
    try (InputStream is = ol.openStream()) {
        return mimeUtil.getMimeType(pathname, is).toString();
    }
}
#end_block

#method_before
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input, boolean allowGroup) throws OrmException, RestApiException, IOException {
    boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).getConfig().getEnableReviewerByEmail();
    // Add by Account.Id
    Account.Id accountId = null;
    try {
        accountId = accounts.parse(input.reviewer).getAccountId();
    } catch (UnprocessableEntityException e) {
        if (!allowGroup && !allowByEmail) {
            throw e;
        }
    }
    if (accountId != null) {
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails));
    }
    // Add a whole group
    if (allowGroup) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e) {
            if (!allowByEmail) {
                throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, input.reviewer));
            }
        }
    }
    // Add by email
    return putAccountByEmail(input.reviewer, rsrc, input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails));
}
#method_after
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input, boolean allowGroup) throws OrmException, RestApiException, IOException {
    boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail();
    Addition byAccountId = addByAccountId(rsrc, input, allowGroup, allowByEmail);
    if (byAccountId != null) {
        return byAccountId;
    }
    Addition wholeGroup = addWholeGroup(rsrc, input, allowGroup, allowByEmail);
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(rsrc, input);
}
#end_block

#method_before
void gatherResults() throws OrmException {
    // the Op because the accounts are in a different table.
    if (migration.readChanges() && op.state == CC) {
        result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
        for (Account.Id accountId : op.addedCCs) {
            result.ccs.add(json.format(new ReviewerInfo(accountId.get()), reviewers.get(accountId)));
        }
        accountLoaderFactory.create(true).fill(result.ccs);
        for (Address a : reviewersByEmail) {
            result.ccs.add(new AccountInfo(a.getName(), a.getEmail()));
        }
    } else {
        result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
        for (PatchSetApproval psa : op.addedReviewers) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        accountLoaderFactory.create(true).fill(result.reviewers);
        for (Address a : reviewersByEmail) {
            result.reviewers.add(ReviewerInfo.byEmail(a.getName(), a.getEmail()));
        }
    }
}
#method_after
void gatherResults() throws OrmException {
    // Generate result details and fill AccountLoader. This occurs outside
    // the Op because the accounts are in a different table.
    PostReviewersOp.Result opResult = op.getResult();
    if (migration.readChanges() && state == CC) {
        result.ccs = Lists.newArrayListWithCapacity(opResult.addedCCs().size());
        for (Account.Id accountId : opResult.addedCCs()) {
            result.ccs.add(json.format(new ReviewerInfo(accountId.get()), reviewers.get(accountId)));
        }
        accountLoaderFactory.create(true).fill(result.ccs);
        for (Address a : reviewersByEmail) {
            result.ccs.add(new AccountInfo(a.getName(), a.getEmail()));
        }
    } else {
        result.reviewers = Lists.newArrayListWithCapacity(opResult.addedReviewers().size());
        for (PatchSetApproval psa : opResult.addedReviewers()) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        accountLoaderFactory.create(true).fill(result.reviewers);
        for (Address a : reviewersByEmail) {
            result.reviewers.add(ReviewerInfo.byEmail(a.getName(), a.getEmail()));
        }
    }
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), Lists.transform(addedReviewers, r -> r.getAccountId()), addedCCs == null ? ImmutableList.of() : addedCCs, reviewersByEmail, addedCCsByEmail, notify, accountsToNotify);
    if (!addedReviewers.isEmpty()) {
        List<Account> reviewers = addedReviewers.stream().map(r -> accountCache.get(r.getAccountId()).getAccount()).collect(toList());
        reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    opResult = Result.builder().setAddedReviewers(ImmutableList.copyOf(addedReviewers)).setAddedCCs(ImmutableList.copyOf(addedCCs)).build();
    emailReviewers(rsrc.getChange(), Lists.transform(addedReviewers, r -> r.getAccountId()), addedCCs == null ? ImmutableList.of() : addedCCs, reviewersByEmail, addedCCsByEmail, notify, accountsToNotify);
    if (!addedReviewers.isEmpty()) {
        List<Account> reviewers = addedReviewers.stream().map(r -> accountCache.get(r.getAccountId()).getAccount()).collect(toList());
        reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen());
    }
}
#end_block

#method_before
public void emailReviewers(Change change, Collection<Account.Id> added, Collection<Account.Id> copied, Collection<Address> addedByEmail, Collection<Address> copiedByEmail, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    if (added.isEmpty() && copied.isEmpty() && addedByEmail.isEmpty() && copiedByEmail.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (Account.Id id : added) {
        if (!id.equals(userId)) {
            toMail.add(id);
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty() && addedByEmail.isEmpty() && copiedByEmail.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        if (notify != null) {
            cm.setNotify(notify);
        }
        cm.setAccountsToNotify(accountsToNotify);
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addReviewersByEmail(addedByEmail);
        cm.addExtraCC(toCopy);
        cm.addExtraCCByEmail(copiedByEmail);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#method_after
public void emailReviewers(Change change, Collection<Account.Id> added, Collection<Account.Id> copied, Collection<Address> addedByEmail, Collection<Address> copiedByEmail, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    if (added.isEmpty() && copied.isEmpty() && addedByEmail.isEmpty() && copiedByEmail.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (Account.Id id : added) {
        if (!id.equals(userId)) {
            toMail.add(id);
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty() && addedByEmail.isEmpty() && copiedByEmail.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setNotify(MoreObjects.firstNonNull(notify, NotifyHandling.ALL));
        cm.setAccountsToNotify(accountsToNotify);
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addReviewersByEmail(addedByEmail);
        cm.addExtraCC(toCopy);
        cm.addExtraCCByEmail(copiedByEmail);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
            toByEmail.addAll(addition.op.reviewersByEmail);
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
            ccByEmail.addAll(addition.op.reviewersByEmail);
        }
    }
    if (reviewerAdditions.size() > 0) {
        reviewerAdditions.get(0).op.emailReviewers(change, to, cc, toByEmail, ccByEmail, notify, accountsToNotify);
    }
}
#method_after
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, @Nullable NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.state == ReviewerState.REVIEWER) {
            to.addAll(addition.reviewers.keySet());
            toByEmail.addAll(addition.reviewersByEmail);
        } else if (addition.state == ReviewerState.CC) {
            cc.addAll(addition.reviewers.keySet());
            ccByEmail.addAll(addition.reviewersByEmail);
        }
    }
    if (reviewerAdditions.size() > 0) {
        reviewerAdditions.get(0).op.emailReviewers(change, to, cc, toByEmail, ccByEmail, notify, accountsToNotify);
    }
}
#end_block

#method_before
private <T extends CommentInput> void cleanUpComments(Map<String, List<T>> commentsPerPath) {
    Iterator<List<T>> mapValueIterator = commentsPerPath.values().iterator();
    while (mapValueIterator.hasNext()) {
        List<T> comments = mapValueIterator.next();
        if (comments == null) {
            mapValueIterator.remove();
            continue;
        }
        cleanUpComments(comments);
        if (comments.isEmpty()) {
            mapValueIterator.remove();
        }
    }
}
#method_after
private static <T extends CommentInput> void cleanUpComments(Map<String, List<T>> commentsPerPath) {
    Iterator<List<T>> mapValueIterator = commentsPerPath.values().iterator();
    while (mapValueIterator.hasNext()) {
        List<T> comments = mapValueIterator.next();
        if (comments == null) {
            mapValueIterator.remove();
            continue;
        }
        cleanUpComments(comments);
        if (comments.isEmpty()) {
            mapValueIterator.remove();
        }
    }
}
#end_block

#method_before
private <T extends CommentInput> void cleanUpComments(List<T> comments) {
    Iterator<T> commentsIterator = comments.iterator();
    while (commentsIterator.hasNext()) {
        T comment = commentsIterator.next();
        if (comment == null) {
            commentsIterator.remove();
            continue;
        }
        comment.message = Strings.nullToEmpty(comment.message).trim();
        if (comment.message.isEmpty()) {
            commentsIterator.remove();
        }
    }
}
#method_after
private static <T extends CommentInput> void cleanUpComments(List<T> comments) {
    Iterator<T> commentsIterator = comments.iterator();
    while (commentsIterator.hasNext()) {
        T comment = commentsIterator.next();
        if (comment == null) {
            commentsIterator.remove();
            continue;
        }
        comment.message = Strings.nullToEmpty(comment.message).trim();
        if (comment.message.isEmpty()) {
            commentsIterator.remove();
        }
    }
}
#end_block

#method_before
private void ensurePathRefersToAvailableOrMagicFile(String path, Set<String> availableFilePaths, PatchSet.Id patchSetId) throws BadRequestException {
    if (!availableFilePaths.contains(path) && !Patch.isMagic(path)) {
        throw new BadRequestException(String.format("file %s not found in revision %s", path, patchSetId));
    }
}
#method_after
private static void ensurePathRefersToAvailableOrMagicFile(String path, Set<String> availableFilePaths, PatchSet.Id patchSetId) throws BadRequestException {
    if (!availableFilePaths.contains(path) && !Patch.isMagic(path)) {
        throw new BadRequestException(String.format("file %s not found in revision %s", path, patchSetId));
    }
}
#end_block

#method_before
private void ensureLineIsNonNegative(Integer line, String path) throws BadRequestException {
    if (line != null && line < 0) {
        throw new BadRequestException(String.format("negative line number %d not allowed on %s", line, path));
    }
}
#method_after
private static void ensureLineIsNonNegative(Integer line, String path) throws BadRequestException {
    if (line != null && line < 0) {
        throw new BadRequestException(String.format("negative line number %d not allowed on %s", line, path));
    }
}
#end_block

#method_before
private <T extends CommentInput> void ensureCommentNotOnMagicFilesOfAutoMerge(String path, T comment) throws BadRequestException {
    if (Patch.isMagic(path) && comment.side == Side.PARENT && comment.parent == null) {
        throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
    }
}
#method_after
private static <T extends CommentInput> void ensureCommentNotOnMagicFilesOfAutoMerge(String path, T comment) throws BadRequestException {
    if (Patch.isMagic(path) && comment.side == Side.PARENT && comment.parent == null) {
        throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
    }
}
#end_block

#method_before
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#method_after
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureSizeOfJsonInputIsWithinBounds(c);
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#end_block

#method_before
private void ensureRobotIdIsSet(String robotId, String commentPath) throws BadRequestException {
    if (robotId == null) {
        throw new BadRequestException(String.format("robotId is missing for robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureRobotIdIsSet(String robotId, String commentPath) throws BadRequestException {
    if (robotId == null) {
        throw new BadRequestException(String.format("robotId is missing for robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRobotRunIdIsSet(String robotRunId, String commentPath) throws BadRequestException {
    if (robotRunId == null) {
        throw new BadRequestException(String.format("robotRunId is missing for robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureRobotRunIdIsSet(String robotRunId, String commentPath) throws BadRequestException {
    if (robotRunId == null) {
        throw new BadRequestException(String.format("robotRunId is missing for robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureFixSuggestionsAreAddable(List<FixSuggestionInfo> fixSuggestionInfos, String commentPath) throws BadRequestException {
    if (fixSuggestionInfos == null) {
        return;
    }
    for (FixSuggestionInfo fixSuggestionInfo : fixSuggestionInfos) {
        ensureDescriptionIsSet(commentPath, fixSuggestionInfo.description);
        ensureFixReplacementsAreAddable(commentPath, fixSuggestionInfo.replacements);
    }
}
#method_after
private static void ensureFixSuggestionsAreAddable(List<FixSuggestionInfo> fixSuggestionInfos, String commentPath) throws BadRequestException {
    if (fixSuggestionInfos == null) {
        return;
    }
    for (FixSuggestionInfo fixSuggestionInfo : fixSuggestionInfos) {
        ensureDescriptionIsSet(commentPath, fixSuggestionInfo.description);
        ensureFixReplacementsAreAddable(commentPath, fixSuggestionInfo.replacements);
    }
}
#end_block

#method_before
private void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureFixReplacementsAreAddable(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(commentPath, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureReplacementPathIsSet(commentPath, fixReplacementInfo.path);
        ensureReplacementPathRefersToFileOfComment(commentPath, fixReplacementInfo.path);
        ensureRangeIsSet(commentPath, fixReplacementInfo.range);
        ensureRangeIsValid(commentPath, fixReplacementInfo.range);
        ensureReplacementStringIsSet(commentPath, fixReplacementInfo.replacement);
    }
}
#method_after
private static void ensureFixReplacementsAreAddable(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(commentPath, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureReplacementPathIsSet(commentPath, fixReplacementInfo.path);
        ensureRangeIsSet(commentPath, fixReplacementInfo.range);
        ensureRangeIsValid(commentPath, fixReplacementInfo.range);
        ensureReplacementStringIsSet(commentPath, fixReplacementInfo.replacement);
    }
    Map<String, List<FixReplacementInfo>> replacementsPerFilePath = fixReplacementInfos.stream().collect(groupingBy(fixReplacement -> fixReplacement.path));
    for (List<FixReplacementInfo> sameFileReplacements : replacementsPerFilePath.values()) {
        ensureRangesDoNotOverlap(commentPath, sameFileReplacements);
    }
}
#end_block

#method_before
private void ensureReplacementsArePresent(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    if (fixReplacementInfos == null || fixReplacementInfos.isEmpty()) {
        throw new BadRequestException(String.format("At least one replacement is " + "required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureReplacementsArePresent(String commentPath, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    if (fixReplacementInfos == null || fixReplacementInfos.isEmpty()) {
        throw new BadRequestException(String.format("At least one replacement is " + "required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsSet(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureRangeIsSet(String commentPath, Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsValid(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#method_after
private static void ensureRangeIsValid(String commentPath, Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#end_block

#method_before
private void ensureReplacementStringIsSet(String commentPath, String replacement) throws BadRequestException {
    if (replacement == null) {
        throw new BadRequestException(String.format("A content for replacement " + "must be indicated for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private static void ensureReplacementStringIsSet(String commentPath, String replacement) throws BadRequestException {
    if (replacement == null) {
        throw new BadRequestException(String.format("A content for replacement " + "must be indicated for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private boolean isReviewer(ChangeContext ctx) throws OrmException {
    if (ctx.getAccountId().equals(ctx.getChange().getOwner())) {
        return true;
    }
    for (PostReviewers.Addition addition : reviewerResults) {
        if (addition.op.addedReviewers == null) {
            continue;
        }
        for (PatchSetApproval psa : addition.op.addedReviewers) {
            if (psa.getAccountId().equals(ctx.getAccountId())) {
                return true;
            }
        }
    }
    ChangeData cd = changeDataFactory.create(db.get(), ctx.getControl());
    ReviewerSet reviewers = cd.reviewers();
    if (reviewers.byState(REVIEWER).contains(ctx.getAccountId())) {
        return true;
    }
    return false;
}
#method_after
private boolean isReviewer(ChangeContext ctx) throws OrmException {
    if (ctx.getAccountId().equals(ctx.getChange().getOwner())) {
        return true;
    }
    ChangeData cd = changeDataFactory.create(db.get(), ctx.getControl());
    ReviewerSet reviewers = cd.reviewers();
    if (reviewers.byState(REVIEWER).contains(ctx.getAccountId())) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, AuthException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    return apply(rsrc.getControl(), input);
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    return apply(rsrc.getControl(), input);
}
#end_block

#method_before
private static Iterable<String> getLabels(ChangeData input, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : input.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && input.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#method_after
private static Iterable<String> getLabels(ChangeData cd, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : cd.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && cd.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#end_block

#method_before
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getAuthor());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getAuthor());
}
#end_block

#method_before
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getCommitter());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getCommitter());
}
#end_block

#method_before
private static String getTopic(ChangeData input) throws OrmException {
    Change c = input.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#method_after
private static String getTopic(ChangeData cd) throws OrmException {
    Change c = cd.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    if (!self.get().getAccountId().equals(rsrc.getChange().getOwner()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to set private status");
    }
    if (rsrc.getChange().isPrivate()) {
        return Response.ok("");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(true);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.created("");
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not allowed to mark private");
    }
    if (rsrc.getChange().isPrivate()) {
        return Response.ok("");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(true);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.created("");
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setPrivate(isPrivate);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setPrivate(isPrivate);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setPrivate(isPrivate);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setPrivate(isPrivate);
    return true;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource rsrc, DeletePrivate.Input input) throws RestApiException, UpdateException {
    if (!self.get().getAccountId().equals(rsrc.getChange().getOwner()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete private status");
    }
    if (!rsrc.getChange().isPrivate()) {
        throw new ResourceConflictException("change is not private");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(false);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, DeletePrivate.Input input) throws RestApiException, UpdateException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not allowed to unmark private");
    }
    if (!rsrc.getChange().isPrivate()) {
        throw new ResourceConflictException("change is not private");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(false);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.none();
}
#end_block

#method_before
@Test
public void setPrivateByOtherUser() throws Exception {
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    setApiUser(accounts.user2());
    assertThat(gApi.changes().id(result.getChangeId()).isPrivate()).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to set private status");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#method_after
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self project:{" + project.get() + "}")).isEmpty();
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return (isAdmin() || (isOwner() && getRefControl().canDeleteOwnChanges()));
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#method_after
boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate);
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    get(CHANGE_KIND, "private").to(GetPrivate.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate.IsMergeablePredicate(args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate.IsPrivatePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.reviewer(args, id)).collect(toList()));
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
static void execute(ImmutableList<NoteDbBatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    setRequestIds(updates, requestId);
    try {
        Order order = getOrder(updates);
        // BatchUpdateListener is MergeOp, which only uses one order.
        switch(order) {
            case REPO_BEFORE_DB:
                for (NoteDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (NoteDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                for (NoteDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(dryrun), dryrun);
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (NoteDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(dryrun), dryrun);
                }
                listener.afterUpdateChanges();
                for (NoteDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (NoteDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        ChangeIndexer.allAsList(updates.stream().flatMap(u -> u.indexFutures.stream()).collect(toList())).get();
        // Fire ref update events only after all mutations are finished, since callers may assume a
        // patch set ref being created means the change was created, or a branch advancing meaning
        // some changes were closed.
        updates.stream().filter(u -> u.batchRefUpdate != null).forEach(u -> u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getAccount().orElse(null)));
        if (!dryrun) {
            for (NoteDbBatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (Exception e) {
        wrapAndThrowException(e);
    }
}
#method_after
static void execute(ImmutableList<NoteDbBatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    setRequestIds(updates, requestId);
    try {
        Order order = getOrder(updates, listener);
        // about the order in which their methods are called.
        switch(order) {
            case REPO_BEFORE_DB:
                for (NoteDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (NoteDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                for (NoteDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(dryrun), dryrun);
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (NoteDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(dryrun), dryrun);
                }
                for (NoteDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                for (NoteDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        ChangeIndexer.allAsList(updates.stream().flatMap(u -> u.indexFutures.stream()).collect(toList())).get();
        // Fire ref update events only after all mutations are finished, since callers may assume a
        // patch set ref being created means the change was created, or a branch advancing meaning
        // some changes were closed.
        updates.stream().filter(u -> u.batchRefUpdate != null).forEach(u -> u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getAccount().orElse(null)));
        if (!dryrun) {
            for (NoteDbBatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (Exception e) {
        wrapAndThrowException(e);
    }
}
#end_block

#method_before
@Override
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    repoView.getCommands().add(cmd);
}
#method_after
@Override
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    commands.add(cmd);
}
#end_block

#method_before
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContextImpl ctx = new RepoContextImpl();
        for (BatchUpdateOp op : ops.values()) {
            op.updateRepo(ctx);
        }
        logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size());
        for (RepoOnlyOp op : repoOnlyOps) {
            op.updateRepo(ctx);
        }
        if (onSubmitValidators != null && !getRefUpdates().isEmpty()) {
            // Validation of refs has to take place here and not at the beginning
            // executeRefUpdates. Otherwise failing validation in a second
            // BatchUpdate object will happen *after* first object's
            // executeRefUpdates has finished, hence after first repo's refs have
            // been updated, which is too late.
            onSubmitValidators.validate(project, ctx.getRevWalk().getObjectReader(), repoView.getCommands());
        }
        // TODO(dborowitz): Don't flush when fusing phases.
        if (repoView != null) {
            logDebug("Flushing inserter");
            repoView.getInserter().flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.throwIfInstanceOf(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContextImpl ctx = new RepoContextImpl();
        for (BatchUpdateOp op : ops.values()) {
            op.updateRepo(ctx);
        }
        logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size());
        for (RepoOnlyOp op : repoOnlyOps) {
            op.updateRepo(ctx);
        }
        if (onSubmitValidators != null && commands != null && !commands.isEmpty()) {
            // Validation of refs has to take place here and not at the beginning of executeRefUpdates.
            // Otherwise, failing validation in a second BatchUpdate object will happen *after* the
            // first update's executeRefUpdates has finished, hence after first repo's refs have been
            // updated, which is too late.
            onSubmitValidators.validate(project, ctx.getRevWalk().getObjectReader(), commands);
        }
        // TODO(dborowitz): Don't flush when fusing phases.
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.throwIfInstanceOf(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeRefUpdates(boolean dryrun) throws IOException, RestApiException {
    if (getRefUpdates().isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repoView.getRepository().getRefDatabase().newBatchUpdate();
    repoView.getCommands().addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    try (RevWalk updateRw = new RevWalk(repoView.getRepository())) {
        batchRefUpdate.execute(updateRw, NullProgressMonitor.INSTANCE);
    }
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new RestApiException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates(boolean dryrun) throws IOException, RestApiException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    // that might have access to unflushed objects.
    try (RevWalk updateRw = new RevWalk(repo)) {
        batchRefUpdate.execute(updateRw, NullProgressMonitor.INSTANCE);
    }
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new RestApiException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private Map<Change.Id, ChangeResult> executeChangeOps(boolean dryrun) throws Exception {
    logDebug("Executing change ops");
    Map<Change.Id, ChangeResult> result = Maps.newLinkedHashMapWithExpectedSize(ops.keySet().size());
    Repository repo = getRepository();
    // update as in executeUpdateRepo.
    try (ObjectInserter ins = repo.newObjectInserter();
        RevWalk rw = new RevWalk(ins.newReader());
        NoteDbUpdateManager updateManager = updateManagerFactory.create(project).setChangeRepo(repo, rw, ins, new ChainedReceiveCommands(repo))) {
        if (user.isIdentifiedUser()) {
            updateManager.setRefLogIdent(user.asIdentifiedUser().newRefLogIdent(when, tz));
        }
        for (Map.Entry<Change.Id, Collection<BatchUpdateOp>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            ChangeContextImpl ctx = newChangeContext(id);
            boolean dirty = false;
            logDebug("Applying {} ops for change {}", e.getValue().size(), id);
            for (BatchUpdateOp op : e.getValue()) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                result.put(id, ChangeResult.SKIPPED);
                continue;
            }
            for (ChangeUpdate u : ctx.updates.values()) {
                updateManager.add(u);
            }
            if (ctx.deleted) {
                logDebug("Change {} was deleted", id);
                updateManager.deleteChange(id);
                result.put(id, ChangeResult.DELETED);
            } else {
                result.put(id, ChangeResult.UPSERTED);
            }
        }
        if (!dryrun) {
            logDebug("Executing NoteDb updates");
            updateManager.execute();
        }
    }
    return result;
}
#method_after
private Map<Change.Id, ChangeResult> executeChangeOps(boolean dryrun) throws Exception {
    logDebug("Executing change ops");
    Map<Change.Id, ChangeResult> result = Maps.newLinkedHashMapWithExpectedSize(ops.keySet().size());
    Repository repo = getRepository();
    // update as in executeUpdateRepo.
    try (ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader);
        NoteDbUpdateManager updateManager = updateManagerFactory.create(project).setChangeRepo(repo, rw, ins, new ChainedReceiveCommands(repo))) {
        if (user.isIdentifiedUser()) {
            updateManager.setRefLogIdent(user.asIdentifiedUser().newRefLogIdent(when, tz));
        }
        for (Map.Entry<Change.Id, Collection<BatchUpdateOp>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            ChangeContextImpl ctx = newChangeContext(id);
            boolean dirty = false;
            logDebug("Applying {} ops for change {}", e.getValue().size(), id);
            for (BatchUpdateOp op : e.getValue()) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                result.put(id, ChangeResult.SKIPPED);
                continue;
            }
            for (ChangeUpdate u : ctx.updates.values()) {
                updateManager.add(u);
            }
            if (ctx.deleted) {
                logDebug("Change {} was deleted", id);
                updateManager.deleteChange(id);
                result.put(id, ChangeResult.DELETED);
            } else {
                result.put(id, ChangeResult.UPSERTED);
            }
        }
        if (!dryrun) {
            logDebug("Executing NoteDb updates");
            updateManager.execute();
        }
    }
    return result;
}
#end_block

#method_before
private ChangeContextImpl newChangeContext(Change.Id id) throws NoSuchChangeException, OrmException {
    logDebug("Opening change {} for update", id);
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (!isNew) {
        // Pass a synthetic change into ChangeNotes.Factory, which will take care of checking for
        // existence and populating columns from the parsed notes state.
        // TODO(dborowitz): This dance made more sense when using Reviewdb; consider a nicer way.
        c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
    } else {
        logDebug("Change {} is new", id);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContextImpl(ctl);
}
#method_after
private ChangeContextImpl newChangeContext(Change.Id id) throws OrmException {
    logDebug("Opening change {} for update", id);
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (!isNew) {
        // Pass a synthetic change into ChangeNotes.Factory, which will take care of checking for
        // existence and populating columns from the parsed notes state.
        // TODO(dborowitz): This dance made more sense when using Reviewdb; consider a nicer way.
        c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
    } else {
        logDebug("Change {} is new", id);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContextImpl(ctl);
}
#end_block

#method_before
public void validate(Project.NameKey project, ObjectReader objectReader, ChainedReceiveCommands commands) throws IntegrationException {
    try {
        for (OnSubmitValidationListener listener : this.listeners) {
            listener.preBranchUpdate(new Arguments(project, objectReader, commands));
        }
    } catch (ValidationException e) {
        throw new IntegrationException(e.getMessage());
    }
}
#method_after
public void validate(Project.NameKey project, ObjectReader objectReader, ChainedReceiveCommands commands) throws IntegrationException {
    try (RevWalk rw = new RevWalk(objectReader)) {
        Arguments args = new Arguments(project, rw, commands);
        for (OnSubmitValidationListener listener : listeners) {
            listener.preBranchUpdate(args);
        }
    } catch (ValidationException e) {
        throw new IntegrationException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    repoView.getCommands().add(cmd);
}
#method_after
@Override
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    commands.add(cmd);
}
#end_block

#method_before
static void execute(ImmutableList<ReviewDbBatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    setRequestIds(updates, requestId);
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        ChangeIndexer.allAsList(updates.stream().flatMap(u -> u.indexFutures.stream()).collect(toList())).get();
        // Fire ref update events only after all mutations are finished, since callers may assume a
        // patch set ref being created means the change was created, or a branch advancing meaning
        // some changes were closed.
        updates.stream().filter(u -> u.batchRefUpdate != null).forEach(u -> u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getAccount().orElse(null)));
        if (!dryrun) {
            for (ReviewDbBatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (Exception e) {
        wrapAndThrowException(e);
    }
}
#method_after
static void execute(ImmutableList<ReviewDbBatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    setRequestIds(updates, requestId);
    try {
        Order order = getOrder(updates, listener);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        ChangeIndexer.allAsList(updates.stream().flatMap(u -> u.indexFutures.stream()).collect(toList())).get();
        // Fire ref update events only after all mutations are finished, since callers may assume a
        // patch set ref being created means the change was created, or a branch advancing meaning
        // some changes were closed.
        updates.stream().filter(u -> u.batchRefUpdate != null).forEach(u -> u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getAccount().orElse(null)));
        if (!dryrun) {
            for (ReviewDbBatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (Exception e) {
        wrapAndThrowException(e);
    }
}
#end_block

#method_before
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContextImpl ctx = new RepoContextImpl();
        for (BatchUpdateOp op : ops.values()) {
            op.updateRepo(ctx);
        }
        logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size());
        for (RepoOnlyOp op : repoOnlyOps) {
            op.updateRepo(ctx);
        }
        if (onSubmitValidators != null && !getRefUpdates().isEmpty()) {
            // Validation of refs has to take place here and not at the beginning
            // executeRefUpdates. Otherwise failing validation in a second
            // BatchUpdate object will happen *after* first object's
            // executeRefUpdates has finished, hence after first repo's refs have
            // been updated, which is too late.
            onSubmitValidators.validate(project, ctx.getRevWalk().getObjectReader(), repoView.getCommands());
        }
        if (repoView != null) {
            logDebug("Flushing inserter");
            repoView.getInserter().flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.throwIfInstanceOf(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContextImpl ctx = new RepoContextImpl();
        for (BatchUpdateOp op : ops.values()) {
            op.updateRepo(ctx);
        }
        logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size());
        for (RepoOnlyOp op : repoOnlyOps) {
            op.updateRepo(ctx);
        }
        if (onSubmitValidators != null && commands != null && !commands.isEmpty()) {
            // Validation of refs has to take place here and not at the beginning of executeRefUpdates.
            // Otherwise, failing validation in a second BatchUpdate object will happen *after* the
            // first update's executeRefUpdates has finished, hence after first repo's refs have been
            // updated, which is too late.
            onSubmitValidators.validate(project, ctx.getRevWalk().getObjectReader(), commands);
        }
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.throwIfInstanceOf(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeRefUpdates(boolean dryrun) throws IOException, RestApiException {
    if (getRefUpdates().isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    // TODO(dborowitz): Really?
    initRepository();
    batchRefUpdate = repoView.getRepository().getRefDatabase().newBatchUpdate();
    repoView.getCommands().addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    try (RevWalk updateRw = new RevWalk(repoView.getRepository())) {
        batchRefUpdate.execute(updateRw, NullProgressMonitor.INSTANCE);
    }
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new RestApiException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates(boolean dryrun) throws IOException, RestApiException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    // that might have access to unflushed objects.
    try (RevWalk updateRw = new RevWalk(repo)) {
        batchRefUpdate.execute(updateRw, NullProgressMonitor.INSTANCE);
    }
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new RestApiException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private List<ChangeTask> executeChangeOps(boolean parallel, boolean dryrun) throws UpdateException, RestApiException {
    List<ChangeTask> tasks;
    boolean success = false;
    Stopwatch sw = Stopwatch.createStarted();
    try {
        logDebug("Executing change ops (parallel? {})", parallel);
        ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
        tasks = new ArrayList<>(ops.keySet().size());
        try {
            if (notesMigration.commitChangeWrites() && repoView != null) {
                // A NoteDb change may have been rebuilt since the repo was originally
                // opened, so make sure we see that.
                logDebug("Preemptively scanning for repo changes");
                repoView.getRepository().scanForRepoChanges();
            }
            if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
                // Fail fast before attempting any writes if changes are read-only, as
                // this is a programmer error.
                logDebug("Failing early due to read-only Changes table");
                throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
            }
            List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
            for (Map.Entry<Change.Id, Collection<BatchUpdateOp>> e : ops.asMap().entrySet()) {
                ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread(), dryrun);
                tasks.add(task);
                if (!parallel) {
                    logDebug("Direct execution of task for ops: {}", ops);
                }
                futures.add(executor.submit(task));
            }
            if (parallel) {
                logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
            }
            Futures.allAsList(futures).get();
            if (notesMigration.commitChangeWrites()) {
                if (!dryrun) {
                    executeNoteDbUpdates(tasks);
                }
            }
            success = true;
        } catch (ExecutionException | InterruptedException e) {
            Throwables.throwIfInstanceOf(e.getCause(), UpdateException.class);
            Throwables.throwIfInstanceOf(e.getCause(), RestApiException.class);
            throw new UpdateException(e);
        } catch (OrmException | IOException e) {
            throw new UpdateException(e);
        }
    } finally {
        metrics.executeChangeOpsLatency.record(success, sw.elapsed(NANOSECONDS), NANOSECONDS);
    }
    return tasks;
}
#method_after
private List<ChangeTask> executeChangeOps(boolean parallel, boolean dryrun) throws UpdateException, RestApiException {
    List<ChangeTask> tasks;
    boolean success = false;
    Stopwatch sw = Stopwatch.createStarted();
    try {
        logDebug("Executing change ops (parallel? {})", parallel);
        ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
        tasks = new ArrayList<>(ops.keySet().size());
        try {
            if (notesMigration.commitChangeWrites() && repo != null) {
                // A NoteDb change may have been rebuilt since the repo was originally
                // opened, so make sure we see that.
                logDebug("Preemptively scanning for repo changes");
                repo.scanForRepoChanges();
            }
            if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
                // Fail fast before attempting any writes if changes are read-only, as
                // this is a programmer error.
                logDebug("Failing early due to read-only Changes table");
                throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
            }
            List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
            for (Map.Entry<Change.Id, Collection<BatchUpdateOp>> e : ops.asMap().entrySet()) {
                ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread(), dryrun);
                tasks.add(task);
                if (!parallel) {
                    logDebug("Direct execution of task for ops: {}", ops);
                }
                futures.add(executor.submit(task));
            }
            if (parallel) {
                logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
            }
            Futures.allAsList(futures).get();
            if (notesMigration.commitChangeWrites()) {
                if (!dryrun) {
                    executeNoteDbUpdates(tasks);
                }
            }
            success = true;
        } catch (ExecutionException | InterruptedException e) {
            Throwables.throwIfInstanceOf(e.getCause(), UpdateException.class);
            Throwables.throwIfInstanceOf(e.getCause(), RestApiException.class);
            throw new UpdateException(e);
        } catch (OrmException | IOException e) {
            throw new UpdateException(e);
        }
    } finally {
        metrics.executeChangeOpsLatency.record(success, sw.elapsed(NANOSECONDS), NANOSECONDS);
    }
    return tasks;
}
#end_block

#method_before
private NoteDbUpdateManager stageNoteDbUpdate(ChangeContextImpl ctx, boolean deleted) throws OrmException, IOException {
    logDebug("Staging NoteDb update");
    NoteDbUpdateManager updateManager = updateManagerFactory.create(ctx.getProject()).setChangeRepo(ctx.getRepository(), ctx.getRevWalk(), null, new ChainedReceiveCommands(ctx.getRepository()));
    if (ctx.getUser().isIdentifiedUser()) {
        updateManager.setRefLogIdent(ctx.getUser().asIdentifiedUser().newRefLogIdent(ctx.getWhen(), tz));
    }
    for (ChangeUpdate u : ctx.updates.values()) {
        updateManager.add(u);
    }
    Change c = ctx.getChange();
    if (deleted) {
        updateManager.deleteChange(c.getId());
    }
    try {
        updateManager.stageAndApplyDelta(c);
    } catch (MismatchedStateException ex) {
        // Refused to apply update because NoteDb was out of sync, which can
        // only happen if ReviewDb is the primary storage for this change.
        // 
        // Go ahead with this ReviewDb update; it's still out of sync, but this
        // is no worse than before, and it will eventually get rebuilt.
        logDebug("Ignoring MismatchedStateException while staging");
    }
    return updateManager;
}
#method_after
private NoteDbUpdateManager stageNoteDbUpdate(ChangeContextImpl ctx, boolean deleted) throws OrmException, IOException {
    logDebug("Staging NoteDb update");
    NoteDbUpdateManager updateManager = updateManagerFactory.create(ctx.getProject()).setChangeRepo(ctx.getRepository(), ctx.getRevWalk(), null, new ChainedReceiveCommands(repo));
    if (ctx.getUser().isIdentifiedUser()) {
        updateManager.setRefLogIdent(ctx.getUser().asIdentifiedUser().newRefLogIdent(ctx.getWhen(), tz));
    }
    for (ChangeUpdate u : ctx.updates.values()) {
        updateManager.add(u);
    }
    Change c = ctx.getChange();
    if (deleted) {
        updateManager.deleteChange(c.getId());
    }
    try {
        updateManager.stageAndApplyDelta(c);
    } catch (MismatchedStateException ex) {
        // Refused to apply update because NoteDb was out of sync, which can
        // only happen if ReviewDb is the primary storage for this change.
        // 
        // Go ahead with this ReviewDb update; it's still out of sync, but this
        // is no worse than before, and it will eventually get rebuilt.
        logDebug("Ignoring MismatchedStateException while staging");
    }
    return updateManager;
}
#end_block

#method_before
public ChainedReceiveCommands getCommands() {
    return commands;
}
#method_after
public ImmutableMap<String, ReceiveCommand> getCommands() {
    return commands;
}
#end_block

#method_before
@Test
public void submitWithValidation() throws Exception {
    AtomicBoolean called = new AtomicBoolean(false);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            called.set(true);
            HashSet<String> refs = Sets.newHashSet(args.getCommands().getCommands().keySet());
            assertThat(refs).contains("refs/heads/master");
            refs.remove("refs/heads/master");
            if (!refs.isEmpty()) {
                // Some submit strategies need to insert new patchset.
                assertThat(refs).hasSize(1);
                assertThat(refs.iterator().next()).startsWith(RefNames.REFS_CHANGES);
            }
        }
    });
    PushOneCommit.Result change = createChange();
    approve(change.getChangeId());
    submit(change.getChangeId());
    assertThat(called.get()).isTrue();
}
#method_after
@Test
public void submitWithValidation() throws Exception {
    AtomicBoolean called = new AtomicBoolean(false);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            called.set(true);
            HashSet<String> refs = Sets.newHashSet(args.getCommands().keySet());
            assertThat(refs).contains("refs/heads/master");
            refs.remove("refs/heads/master");
            if (!refs.isEmpty()) {
                // Some submit strategies need to insert new patchset.
                assertThat(refs).hasSize(1);
                assertThat(refs.iterator().next()).startsWith(RefNames.REFS_CHANGES);
            }
        }
    });
    PushOneCommit.Result change = createChange();
    approve(change.getChangeId());
    submit(change.getChangeId());
    assertThat(called.get()).isTrue();
}
#end_block

#method_before
@Test
public void submitWithValidationMultiRepo() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    // Create test projects
    TestRepository<?> repoA = createProjectWithPush("project-a", null, getSubmitType());
    TestRepository<?> repoB = createProjectWithPush("project-b", null, getSubmitType());
    // Create changes on project-a
    PushOneCommit.Result change1 = createChange(repoA, "master", "Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange(repoA, "master", "Change 2", "b.txt", "content", topic);
    // Create changes on project-b
    PushOneCommit.Result change3 = createChange(repoB, "master", "Change 3", "a.txt", "content", topic);
    PushOneCommit.Result change4 = createChange(repoB, "master", "Change 4", "b.txt", "content", topic);
    List<PushOneCommit.Result> changes = Lists.newArrayList(change1, change2, change3, change4);
    for (PushOneCommit.Result change : changes) {
        approve(change.getChangeId());
    }
    // Construct validator which will throw on a second call.
    // Since there are 2 repos, first submit attempt will fail, the second will
    // succeed.
    List<String> projectsCalled = new ArrayList<>(4);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            assertThat(args.getCommands().getCommands()).containsKey("refs/heads/master");
            try (RevWalk rw = args.newRevWalk()) {
                rw.parseBody(rw.parseCommit(args.getCommands().get("refs/heads/master").get()));
            } catch (IOException e) {
                assertThat(e).isNull();
            }
            projectsCalled.add(args.getProject().get());
            if (projectsCalled.size() == 2) {
                throw new ValidationException("time to fail");
            }
        }
    });
    submitWithConflict(change4.getChangeId(), "time to fail");
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.NEW, name(topic), admin);
    }
    submit(change4.getChangeId());
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"), name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.MERGED, name(topic), admin);
    }
}
#method_after
@Test
public void submitWithValidationMultiRepo() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    // Create test projects
    TestRepository<?> repoA = createProjectWithPush("project-a", null, getSubmitType());
    TestRepository<?> repoB = createProjectWithPush("project-b", null, getSubmitType());
    // Create changes on project-a
    PushOneCommit.Result change1 = createChange(repoA, "master", "Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange(repoA, "master", "Change 2", "b.txt", "content", topic);
    // Create changes on project-b
    PushOneCommit.Result change3 = createChange(repoB, "master", "Change 3", "a.txt", "content", topic);
    PushOneCommit.Result change4 = createChange(repoB, "master", "Change 4", "b.txt", "content", topic);
    List<PushOneCommit.Result> changes = Lists.newArrayList(change1, change2, change3, change4);
    for (PushOneCommit.Result change : changes) {
        approve(change.getChangeId());
    }
    // Construct validator which will throw on a second call.
    // Since there are 2 repos, first submit attempt will fail, the second will
    // succeed.
    List<String> projectsCalled = new ArrayList<>(4);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            String master = "refs/heads/master";
            assertThat(args.getCommands()).containsKey(master);
            ReceiveCommand cmd = args.getCommands().get(master);
            ObjectId newMasterId = cmd.getNewId();
            try (Repository repo = repoManager.openRepository(project)) {
                assertThat(repo.exactRef(master).getObjectId()).isEqualTo(cmd.getOldId());
                assertThat(args.getRef(master)).hasValue(newMasterId);
                args.getRevWalk().parseBody(args.getRevWalk().parseCommit(newMasterId));
            } catch (IOException e) {
                throw new AssertionError("failed checking new ref value", e);
            }
            projectsCalled.add(args.getProject().get());
            if (projectsCalled.size() == 2) {
                throw new ValidationException("time to fail");
            }
        }
    });
    submitWithConflict(change4.getChangeId(), "time to fail");
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.NEW, name(topic), admin);
    }
    submit(change4.getChangeId());
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"), name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.MERGED, name(topic), admin);
    }
}
#end_block

#method_before
<T> boolean parse(T param, Multimap<String, String> in, HttpServletRequest req, HttpServletResponse res) throws IOException {
    CmdLineParser clp = parserFactory.create(param);
    DynamicOptions.parse(dynamicBeans, clp, param);
    try {
        clp.parseOptionMap(in);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            replyError(req, res, SC_BAD_REQUEST, e.getMessage(), e);
            return false;
        }
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter msg = new StringWriter();
        clp.printQueryStringUsage(req.getRequestURI(), msg);
        msg.write('\n');
        msg.write('\n');
        clp.printUsage(msg, null);
        msg.write('\n');
        CacheHeaders.setNotCacheable(res);
        replyBinaryResult(req, res, BinaryResult.create(msg.toString()).setContentType("text/plain"));
        return false;
    }
    return true;
}
#method_after
<T> boolean parse(T param, ListMultimap<String, String> in, HttpServletRequest req, HttpServletResponse res) throws IOException {
    CmdLineParser clp = parserFactory.create(param);
    DynamicOptions.parse(dynamicBeans, clp, param);
    try {
        clp.parseOptionMap(in);
    } catch (CmdLineException | NumberFormatException e) {
        if (!clp.wasHelpRequestedByOption()) {
            replyError(req, res, SC_BAD_REQUEST, e.getMessage(), e);
            return false;
        }
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter msg = new StringWriter();
        clp.printQueryStringUsage(req.getRequestURI(), msg);
        msg.write('\n');
        msg.write('\n');
        clp.printUsage(msg, null);
        msg.write('\n');
        CacheHeaders.setNotCacheable(res);
        replyBinaryResult(req, res, BinaryResult.create(msg.toString()).setContentType("text/plain"));
        return false;
    }
    return true;
}
#end_block

#method_before
static void splitQueryString(String queryString, Multimap<String, String> config, Multimap<String, String> params) {
    if (!Strings.isNullOrEmpty(queryString)) {
        for (String kvPair : Splitter.on('&').split(queryString)) {
            Iterator<String> i = Splitter.on('=').limit(2).split(kvPair).iterator();
            String key = Url.decode(i.next());
            String val = i.hasNext() ? Url.decode(i.next()) : "";
            if (RESERVED_KEYS.contains(key)) {
                config.put(key, val);
            } else {
                params.put(key, val);
            }
        }
    }
}
#method_after
static void splitQueryString(String queryString, ListMultimap<String, String> config, ListMultimap<String, String> params) {
    if (!Strings.isNullOrEmpty(queryString)) {
        for (String kvPair : Splitter.on('&').split(queryString)) {
            Iterator<String> i = Splitter.on('=').limit(2).split(kvPair).iterator();
            String key = Url.decode(i.next());
            String val = i.hasNext() ? Url.decode(i.next()) : "";
            if (RESERVED_KEYS.contains(key)) {
                config.put(key, val);
            } else {
                params.put(key, val);
            }
        }
    }
}
#end_block

#method_before
public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException {
    Multimap<String, String> map = LinkedHashMultimap.create();
    for (Map.Entry<String, String[]> ent : parameters.entrySet()) {
        for (String val : ent.getValue()) {
            map.put(ent.getKey(), val);
        }
    }
    parseOptionMap(map);
}
#method_after
public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException {
    ListMultimap<String, String> map = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Map.Entry<String, String[]> ent : parameters.entrySet()) {
        for (String val : ent.getValue()) {
            map.put(ent.getKey(), val);
        }
    }
    parseOptionMap(map);
}
#end_block

#method_before
public void parseOptionMap(Multimap<String, String> params) throws CmdLineException {
    List<String> tmp = Lists.newArrayListWithCapacity(2 * params.size());
    for (final String key : params.keySet()) {
        String name = makeOption(key);
        if (isBoolean(name)) {
            boolean on = false;
            for (String value : params.get(key)) {
                on = toBoolean(key, value);
            }
            if (on) {
                tmp.add(name);
            }
        } else {
            for (String value : params.get(key)) {
                tmp.add(name);
                tmp.add(value);
            }
        }
    }
    parser.parseArgument(tmp.toArray(new String[tmp.size()]));
}
#method_after
public void parseOptionMap(ListMultimap<String, String> params) throws CmdLineException {
    List<String> tmp = Lists.newArrayListWithCapacity(2 * params.size());
    for (final String key : params.keySet()) {
        String name = makeOption(key);
        if (isBoolean(name)) {
            boolean on = false;
            for (String value : params.get(key)) {
                on = toBoolean(key, value);
            }
            if (on) {
                tmp.add(name);
            }
        } else {
            for (String value : params.get(key)) {
                tmp.add(name);
                tmp.add(value);
            }
        }
    }
    parser.parseArgument(tmp.toArray(new String[tmp.size()]));
}
#end_block

#method_before
private PluginConfigInfo getPluginInfo() {
    PluginConfigInfo info = new PluginConfigInfo();
    info.hasAvatars = toBoolean(avatar.get() != null);
    info.jsResourcePaths = new ArrayList<>();
    info.htmlResourcePaths = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        String path = u.getJavaScriptResourcePath();
        if (path.endsWith(".html")) {
            info.htmlResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), path));
        } else {
            info.jsResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), path));
        }
    }
    return info;
}
#method_after
private PluginConfigInfo getPluginInfo() {
    PluginConfigInfo info = new PluginConfigInfo();
    info.hasAvatars = toBoolean(avatar.get() != null);
    info.jsResourcePaths = new ArrayList<>();
    info.htmlResourcePaths = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        String path = String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath());
        if (path.endsWith(".html")) {
            info.htmlResourcePaths.add(path);
        } else {
            info.jsResourcePaths.add(path);
        }
    }
    return info;
}
#end_block

#method_before
public synchronized void rescan() {
    SetMultimap<String, Path> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, Path> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, Path> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        Path path = entry.getValue();
        String fileName = path.getFileName().toString();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(path)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(path.toFile())) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(path)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", active.getName()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, path, active);
            if (!loadedPlugin.isDisabled()) {
                log.info(String.format("%s plugin %s, version %s", active == null ? "Loaded" : "Reloaded", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    SetMultimap<String, Path> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, Path> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, Path> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        Path path = entry.getValue();
        String fileName = path.getFileName().toString();
        if (!isUiPlugin(fileName) && !serverPluginFactory.handles(path)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(path.toFile())) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(path)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", active.getName()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, path, active);
            if (!loadedPlugin.isDisabled()) {
                log.info(String.format("%s plugin %s, version %s", active == null ? "Loaded" : "Reloaded", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin loadPlugin(String name, Path srcPlugin, FileSnapshot snapshot) throws InvalidPluginException {
    String pluginName = srcPlugin.getFileName().toString();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getFileName()));
    }
}
#method_after
private Plugin loadPlugin(String name, Path srcPlugin, FileSnapshot snapshot) throws InvalidPluginException {
    String pluginName = srcPlugin.getFileName().toString();
    if (isUiPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getFileName()));
    }
}
#end_block

#method_before
public String getGerritPluginName(Path srcPath) {
    String fileName = srcPath.getFileName().toString();
    if (isJsPlugin(fileName)) {
        return fileName.substring(0, fileName.lastIndexOf('.'));
    }
    if (serverPluginFactory.handles(srcPath)) {
        return serverPluginFactory.getPluginName(srcPath);
    }
    return null;
}
#method_after
public String getGerritPluginName(Path srcPath) {
    String fileName = srcPath.getFileName().toString();
    if (isUiPlugin(fileName)) {
        return fileName.substring(0, fileName.lastIndexOf('.'));
    }
    if (serverPluginFactory.handles(srcPath)) {
        return serverPluginFactory.getPluginName(srcPath);
    }
    return null;
}
#end_block

#method_before
public static void load(List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) {
    plugins.removeIf(p -> !p.endsWith(".js"));
    if (plugins == null || plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    } else {
        self = new PluginLoader(loadTimeout, callback);
        self.load(plugins);
        self.startTimers();
        self.center();
    }
}
#method_after
public static void load(List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) {
    if (plugins == null || plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    }
    plugins = plugins.stream().filter(p -> p.endsWith(".js")).collect(Collectors.toList());
    if (plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    } else {
        self = new PluginLoader(loadTimeout, callback);
        self.load(plugins);
        self.startTimers();
        self.center();
    }
}
#end_block

#method_before
public Set<String> getMissingDownstreamMerges(ChangeInfo upstreamChange) throws RestApiException, IOException, ConfigInvalidException {
    Set<String> missingDownstreamBranches = new HashSet<>();
    String topic = upstreamChange.topic;
    String upstreamRevision = upstreamChange.currentRevision;
    Set<String> downstreamBranches = config.getDownstreamBranches(upstreamChange.branch, upstreamChange.project);
    for (String downstreamBranch : downstreamBranches) {
        boolean dsExists = false;
        String query = "topic:" + topic + " status:open branch:" + downstreamBranch;
        List<ChangeInfo> changes = gApi.changes().query(query).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get();
        for (ChangeInfo change : changes) {
            String changeRevision = change.currentRevision;
            RevisionInfo revision = change.revisions.get(changeRevision);
            List<CommitInfo> parents = revision.commit.parents;
            if (parents.size() > 1) {
                String secondParent = parents.get(1).commit;
                if (secondParent.equals(upstreamRevision)) {
                    dsExists = true;
                    break;
                }
            }
        }
        if (!dsExists) {
            missingDownstreamBranches.add(downstreamBranch);
        }
    }
    return missingDownstreamBranches;
}
#method_after
@VisibleForTesting
protected Set<String> getMissingDownstreamMerges(ChangeInfo upstreamChange) throws RestApiException, IOException, ConfigInvalidException {
    Set<String> missingDownstreamBranches = new HashSet<>();
    Set<String> downstreamBranches = config.getDownstreamBranches(upstreamChange.branch, upstreamChange.project);
    for (String downstreamBranch : downstreamBranches) {
        boolean dsExists = false;
        String query = "topic:" + upstreamChange.topic + " status:open branch:" + downstreamBranch;
        List<ChangeInfo> changes = gApi.changes().query(query).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get();
        for (ChangeInfo change : changes) {
            RevisionInfo revision = change.revisions.get(change.currentRevision);
            List<CommitInfo> parents = revision.commit.parents;
            if (parents.size() > 1) {
                String secondParent = parents.get(1).commit;
                if (secondParent.equals(upstreamChange.currentRevision)) {
                    dsExists = true;
                    break;
                }
            }
        }
        if (!dsExists) {
            missingDownstreamBranches.add(downstreamBranch);
        }
    }
    return missingDownstreamBranches;
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void byTopic() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithTopic(repo, "feature1");
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithTopic(repo, "feature2");
    Change change2 = insert(repo, ins2);
    ChangeInserter ins3 = newChangeWithTopic(repo, "Cherrypick-feature2");
    Change change3 = insert(repo, ins3);
    ChangeInserter ins4 = newChangeWithTopic(repo, "feature2-fixup");
    Change change4 = insert(repo, ins4);
    Change change5 = insert(repo, newChange(repo));
    assertQuery("intopic:foo");
    assertQuery("intopic:feature1", change1);
    assertQuery("intopic:feature2", change4, change3, change2);
    assertQuery("topic:feature2", change2);
    assertQuery("intopic:feature2", change4, change3, change2);
    assertQuery("intopic:fixup", change4);
    assertQuery("topic:\"\"", change5);
    assertQuery("intopic:\"\"", change5);
}
#method_after
@Test
public void byTopic() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithTopic(repo, "feature1");
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithTopic(repo, "feature2");
    Change change2 = insert(repo, ins2);
    ChangeInserter ins3 = newChangeWithTopic(repo, "Cherrypick-feature2");
    Change change3 = insert(repo, ins3);
    ChangeInserter ins4 = newChangeWithTopic(repo, "feature2-fixup");
    Change change4 = insert(repo, ins4);
    Change change5 = insert(repo, newChange(repo));
    assertQuery("intopic:foo");
    assertQuery("intopic:feature1", change1);
    assertQuery("intopic:feature2", change4, change3, change2);
    assertQuery("topic:feature2", change2);
    assertQuery("intopic:feature2", change4, change3, change2);
    assertQuery("intopic:fixup", change4);
    assertQuery("topic:\"\"", change5);
    assertQuery("intopic:\"\"", change5);
    assertQuery("intopic:^feature2.*", change4, change2);
    assertQuery("intopic:{^.*feature2$}", change3, change2);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    ;
}
#method_after
@Before
public void setUp() throws Exception {
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
}
#end_block

#method_before
@Test
public void readConfig() throws Exception {
    RevCommit rev = util.commit(// 
    util.tree(// 
    util.file("groups", util.blob(group(developers))), util.file("project.config", util.blob(// 
    "" + // 
    "[access \"refs/heads/*\"]\n" + // 
    "  exclusiveGroupPermissions = read submit create\n" + // 
    "  submit = group Developers\n" + // 
    "  push = group Developers\n" + // 
    "  read = group Developers\n" + // 
    "[accounts]\n" + // 
    "  sameGroupVisibility = deny group Developers\n" + // 
    "  sameGroupVisibility = block group Staff\n" + // 
    "[contributor-agreement \"Individual\"]\n" + // 
    "  description = A simple description\n" + // 
    "  accepted = group Developers\n" + // 
    "  accepted = group Staff\n" + // 
    "  autoVerify = group Developers\n" + // 
    "  agreementUrl = http://www.example.com/agree\n" + // 
    "[reviewer]\n" + // 
    "  enableByEmail = true\n"))));
    ProjectConfig cfg = read(rev);
    assertThat(cfg.getAccountsSection().getSameGroupVisibility()).hasSize(2);
    ContributorAgreement ca = cfg.getContributorAgreement("Individual");
    assertThat(ca.getName()).isEqualTo("Individual");
    assertThat(ca.getDescription()).isEqualTo("A simple description");
    assertThat(ca.getAgreementUrl()).isEqualTo("http://www.example.com/agree");
    assertThat(ca.getAccepted()).hasSize(2);
    assertThat(ca.getAccepted().get(0).getGroup()).isEqualTo(developers);
    assertThat(ca.getAccepted().get(1).getGroup().getName()).isEqualTo("Staff");
    assertThat(ca.getAutoVerify().getName()).isEqualTo("Developers");
    AccessSection section = cfg.getAccessSection("refs/heads/*");
    assertThat(section).isNotNull();
    assertThat(cfg.getAccessSection("refs/*")).isNull();
    Permission create = section.getPermission(Permission.CREATE);
    Permission submit = section.getPermission(Permission.SUBMIT);
    Permission read = section.getPermission(Permission.READ);
    Permission push = section.getPermission(Permission.PUSH);
    assertThat(create.getExclusiveGroup()).isTrue();
    assertThat(submit.getExclusiveGroup()).isTrue();
    assertThat(read.getExclusiveGroup()).isTrue();
    assertThat(push.getExclusiveGroup()).isFalse();
}
#method_after
@Test
public void readConfig() throws Exception {
    RevCommit rev = util.commit(// 
    util.tree(// 
    util.file("groups", util.blob(group(developers))), util.file("project.config", util.blob(// 
    "" + // 
    "[access \"refs/heads/*\"]\n" + // 
    "  exclusiveGroupPermissions = read submit create\n" + // 
    "  submit = group Developers\n" + // 
    "  push = group Developers\n" + // 
    "  read = group Developers\n" + // 
    "[accounts]\n" + // 
    "  sameGroupVisibility = deny group Developers\n" + // 
    "  sameGroupVisibility = block group Staff\n" + // 
    "[contributor-agreement \"Individual\"]\n" + // 
    "  description = A simple description\n" + // 
    "  accepted = group Developers\n" + // 
    "  accepted = group Staff\n" + // 
    "  autoVerify = group Developers\n" + // 
    "  agreementUrl = http://www.example.com/agree\n"))));
    ProjectConfig cfg = read(rev);
    assertThat(cfg.getAccountsSection().getSameGroupVisibility()).hasSize(2);
    ContributorAgreement ca = cfg.getContributorAgreement("Individual");
    assertThat(ca.getName()).isEqualTo("Individual");
    assertThat(ca.getDescription()).isEqualTo("A simple description");
    assertThat(ca.getAgreementUrl()).isEqualTo("http://www.example.com/agree");
    assertThat(ca.getAccepted()).hasSize(2);
    assertThat(ca.getAccepted().get(0).getGroup()).isEqualTo(developers);
    assertThat(ca.getAccepted().get(1).getGroup().getName()).isEqualTo("Staff");
    assertThat(ca.getAutoVerify().getName()).isEqualTo("Developers");
    AccessSection section = cfg.getAccessSection("refs/heads/*");
    assertThat(section).isNotNull();
    assertThat(cfg.getAccessSection("refs/*")).isNull();
    Permission create = section.getPermission(Permission.CREATE);
    Permission submit = section.getPermission(Permission.SUBMIT);
    Permission read = section.getPermission(Permission.READ);
    Permission push = section.getPermission(Permission.PUSH);
    assertThat(create.getExclusiveGroup()).isTrue();
    assertThat(submit.getExclusiveGroup()).isTrue();
    assertThat(read.getExclusiveGroup()).isTrue();
    assertThat(push.getExclusiveGroup()).isFalse();
}
#end_block

#method_before
@ConfigSuite.Default
public static Config pop3Config() {
    Config cfg = new Config();
    cfg.setString(RECEIVEEMAIL, null, "host", HOST);
    cfg.setString(RECEIVEEMAIL, null, "port", "3110");
    cfg.setString(RECEIVEEMAIL, null, "username", USERNAME);
    cfg.setString(RECEIVEEMAIL, null, "password", PASSWORD);
    cfg.setString(RECEIVEEMAIL, null, "protocol", "POP3");
    cfg.setString(RECEIVEEMAIL, null, "fetchInterval", "99s");
    return cfg;
}
#method_after
@ConfigSuite.Default
public static Config pop3Config() {
    Config cfg = new Config();
    cfg.setString(RECEIVEEMAIL, null, "host", HOST);
    cfg.setString(RECEIVEEMAIL, null, "port", "3110");
    cfg.setString(RECEIVEEMAIL, null, "username", USERNAME);
    cfg.setString(RECEIVEEMAIL, null, "password", PASSWORD);
    cfg.setString(RECEIVEEMAIL, null, "protocol", "POP3");
    cfg.setString(RECEIVEEMAIL, null, "fetchInterval", Integer.toString(Integer.MAX_VALUE));
    return cfg;
}
#end_block

#method_before
@ConfigSuite.Config
public static Config imapConfig() {
    Config cfg = new Config();
    cfg.setString(RECEIVEEMAIL, null, "host", HOST);
    cfg.setString(RECEIVEEMAIL, null, "port", "3143");
    cfg.setString(RECEIVEEMAIL, null, "username", USERNAME);
    cfg.setString(RECEIVEEMAIL, null, "password", PASSWORD);
    cfg.setString(RECEIVEEMAIL, null, "protocol", "IMAP");
    cfg.setString(RECEIVEEMAIL, null, "fetchInterval", "99s");
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config imapConfig() {
    Config cfg = new Config();
    cfg.setString(RECEIVEEMAIL, null, "host", HOST);
    cfg.setString(RECEIVEEMAIL, null, "port", "3143");
    cfg.setString(RECEIVEEMAIL, null, "username", USERNAME);
    cfg.setString(RECEIVEEMAIL, null, "password", PASSWORD);
    cfg.setString(RECEIVEEMAIL, null, "protocol", "IMAP");
    cfg.setString(RECEIVEEMAIL, null, "fetchInterval", Integer.toString(Integer.MAX_VALUE));
    return cfg;
}
#end_block

#method_before
@Override
public void onEvent(Event changeEvent) {
    if (!(changeEvent instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent event = (PatchSetCreatedEvent) changeEvent;
    ChangeAttribute c = event.change.get();
    PatchSetAttribute p = event.patchSet.get();
    log.debug("Received new commit: {}", p.revision);
    Project.NameKey projectName = event.getProjectNameKey();
    boolean autoAddReviewers = true;
    try {
        log.debug("Checking if autoAddReviewers is enabled");
        autoAddReviewers = cfg.getProjectPluginConfigWithInheritance(projectName, pluginName).getBoolean("reviewers", "autoAddReviewers", true);
    } catch (NoSuchProjectException e) {
        log.error("Could not find project {}", projectName);
    }
    log.debug(autoAddReviewers ? "autoAddReviewers is enabled" : "autoAddReviewers is disabled");
    if (autoAddReviewers) {
        try (Repository repo = repoManager.openRepository(projectName)) {
            final ReviewDb reviewDb;
            try (RevWalk walk = new RevWalk(repo)) {
                reviewDb = schemaFactory.open();
                try {
                    Change.Id changeId = new Change.Id(Integer.parseInt(Integer.toString(c.number)));
                    PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(Integer.toString(p.number)));
                    PatchSet ps = reviewDb.patchSets().get(psId);
                    if (ps == null) {
                        log.warn("Could not find patch set {}", psId.get());
                        return;
                    }
                    // psId.getParentKey = changeID
                    final Change change = reviewDb.changes().get(psId.getParentKey());
                    if (change == null) {
                        log.warn("Could not find change {}", psId.getParentKey());
                        return;
                    }
                    RevCommit commit = walk.parseCommit(ObjectId.fromString(p.revision));
                    final Runnable task = reviewAssistantFactory.create(commit, change, ps, repo, projectName);
                    workQueue.getDefaultQueue().submit(new Runnable() {

                        @Override
                        public void run() {
                            RequestContext old = tl.setContext(new RequestContext() {

                                @Override
                                public CurrentUser getUser() {
                                    if (!ReviewAssistant.realUser) {
                                        return pluginUser;
                                    }
                                    return identifiedUserFactory.create(change.getOwner());
                                }

                                @Override
                                public Provider<ReviewDb> getReviewDbProvider() {
                                    return new Provider<ReviewDb>() {

                                        @Override
                                        public ReviewDb get() {
                                            if (db == null) {
                                                try {
                                                    db = schemaFactory.open();
                                                } catch (OrmException e) {
                                                    throw new ProvisionException("Cannot open ReviewDb", e);
                                                }
                                            }
                                            return db;
                                        }
                                    };
                                }
                            });
                            try {
                                task.run();
                            } finally {
                                tl.setContext(old);
                                if (db != null) {
                                    db.close();
                                    db = null;
                                }
                            }
                        }
                    });
                } catch (IOException e) {
                    log.error("Could not get commit for revision {}: {}", p.revision, e);
                } finally {
                    reviewDb.close();
                }
            } catch (OrmException e) {
                log.error("Could not open review database: {}", e);
            }
        } catch (IOException e) {
            log.error("Could not open repository for {}", projectName);
            return;
        }
    }
}
#method_after
@Override
public void onEvent(Event changeEvent) {
    if (!(changeEvent instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent event = (PatchSetCreatedEvent) changeEvent;
    ChangeAttribute c = event.change.get();
    PatchSetAttribute p = event.patchSet.get();
    log.debug("Received new commit: {}", p.revision);
    Project.NameKey projectName = event.getProjectNameKey();
    boolean autoAddReviewers = true;
    try {
        log.debug("Checking if autoAddReviewers is enabled");
        autoAddReviewers = cfg.getProjectPluginConfigWithInheritance(projectName, pluginName).getBoolean("reviewers", "autoAddReviewers", true);
    } catch (NoSuchProjectException e) {
        log.error("Could not find project {}", projectName);
    }
    log.debug(autoAddReviewers ? "autoAddReviewers is enabled" : "autoAddReviewers is disabled");
    if (autoAddReviewers) {
        try (Repository repo = repoManager.openRepository(projectName)) {
            final ReviewDb reviewDb;
            try (RevWalk walk = new RevWalk(repo)) {
                reviewDb = schemaFactory.open();
                try {
                    Change.Id changeId = new Change.Id(c.number);
                    PatchSet.Id psId = new PatchSet.Id(changeId, p.number);
                    PatchSet ps = reviewDb.patchSets().get(psId);
                    if (ps == null) {
                        log.warn("Could not find patch set {}", psId.get());
                        return;
                    }
                    // psId.getParentKey = changeID
                    final Change change = reviewDb.changes().get(psId.getParentKey());
                    if (change == null) {
                        log.warn("Could not find change {}", psId.getParentKey());
                        return;
                    }
                    RevCommit commit = walk.parseCommit(ObjectId.fromString(p.revision));
                    final Runnable task = reviewAssistantFactory.create(commit, change, ps, repo, projectName);
                    workQueue.getDefaultQueue().submit(new Runnable() {

                        @Override
                        public void run() {
                            RequestContext old = tl.setContext(new RequestContext() {

                                @Override
                                public CurrentUser getUser() {
                                    if (!ReviewAssistant.realUser) {
                                        return pluginUser;
                                    }
                                    return identifiedUserFactory.create(change.getOwner());
                                }

                                @Override
                                public Provider<ReviewDb> getReviewDbProvider() {
                                    return new Provider<ReviewDb>() {

                                        @Override
                                        public ReviewDb get() {
                                            if (db == null) {
                                                try {
                                                    db = schemaFactory.open();
                                                } catch (OrmException e) {
                                                    throw new ProvisionException("Cannot open ReviewDb", e);
                                                }
                                            }
                                            return db;
                                        }
                                    };
                                }
                            });
                            try {
                                task.run();
                            } finally {
                                tl.setContext(old);
                                if (db != null) {
                                    db.close();
                                    db = null;
                                }
                            }
                        }
                    });
                } catch (IOException e) {
                    log.error("Could not get commit for revision {}: {}", p.revision, e);
                } finally {
                    reviewDb.close();
                }
            } catch (OrmException e) {
                log.error("Could not open review database: {}", e);
            }
        } catch (IOException e) {
            log.error("Could not open repository for {}", projectName);
            return;
        }
    }
}
#end_block

#method_before
public Map<String, Object> getConfig(String fromBranch, String toBranch) {
    return config.getMergeConfig(fromBranch, toBranch);
}
#method_after
private Config getConfig() throws ConfigInvalidException {
    try {
        return cfgFactory.getProjectPluginConfig(allProjectsName, pluginName);
    } catch (NoSuchProjectException e) {
        throw new ConfigInvalidException("Config invalid because " + allProjectsName.get() + " does not exist!");
    }
}
#end_block

#method_before
public boolean isSkipMerge(String fromBranch, String toBranch, String commitMessage) {
    return config.isSkipMerge(fromBranch, toBranch, commitMessage);
}
#method_after
public boolean isSkipMerge(String fromBranch, String toBranch, String commitMessage) throws ConfigInvalidException {
    Pattern alwaysBlankMergePattern = getConfigPattern("alwaysBlankMerge");
    if (alwaysBlankMergePattern.matches(commitMessage)) {
        return true;
    }
    Pattern blankMergePattern = getConfigPattern("blankMerge");
    // If regex matches blank_merge (DO NOT MERGE), skip iff merge_all is false
    if (blankMergePattern.matches(commitMessage)) {
        return !getMergeAll(fromBranch, toBranch);
    }
    return false;
}
#end_block

#method_before
public String getAutomergeLabel() {
    return config.getAutomergeLabel();
}
#method_after
public String getAutomergeLabel() throws ConfigInvalidException {
    String automergeLabel = getConfig().getString("global", null, "automergeLabel");
    return automergeLabel != null ? automergeLabel : "Verified";
}
#end_block

#method_before
public Set<String> getProjectsInScope(String fromBranch, String toBranch) throws RestApiException, IOException {
    try {
        Set<String> projectSet = new HashSet<String>();
        Set<String> fromProjectSet = getManifestProjects(fromBranch);
        projectSet.addAll(fromProjectSet);
        Set<String> toProjectSet = getManifestProjects(fromBranch, toBranch);
        // Take intersection of project sets, unless one is empty.
        if (projectSet.isEmpty()) {
            projectSet = toProjectSet;
        } else if (!toProjectSet.isEmpty()) {
            projectSet.retainAll(toProjectSet);
        }
        // The lower the level a config is applied, the higher priority it has
        // For example, a project ignored in the global config but added in the branch config will
        // be added to the final project set, not ignored
        applyConfig(projectSet, config.getGlobal());
        applyConfig(projectSet, config.getMergeConfig(fromBranch));
        applyConfig(projectSet, config.getMergeConfig(fromBranch, toBranch));
        log.debug("Project set for {} to {} is {}", fromBranch, toBranch, projectSet);
        return projectSet;
    } catch (RestApiException | IOException e) {
        log.error("Error reading manifest for {}!", fromBranch, e);
        throw e;
    }
}
#method_after
public Set<String> getProjectsInScope(String fromBranch, String toBranch) throws RestApiException, IOException, ConfigInvalidException {
    try {
        Set<String> projectSet = getManifestProjects(fromBranch, toBranch);
        projectSet = applyConfig(fromBranch, toBranch, projectSet);
        log.debug("Project set for {} to {} is {}", fromBranch, toBranch, projectSet);
        return projectSet;
    } catch (RestApiException | IOException e) {
        log.error("Error reading manifest for {}!", fromBranch, e);
        throw e;
    }
}
#end_block

#method_before
public Set<String> getDownstreamBranches(String fromBranch, String project) throws RestApiException, IOException {
    Set<String> downstreamBranches = new HashSet<String>();
    Map<String, Map> fromBranchConfig = config.getMergeConfig(fromBranch);
    if (fromBranchConfig != null) {
        for (String key : fromBranchConfig.keySet()) {
            if (!configOptionKeys.contains(key)) {
                // If it's not a config option, then the key is the toBranch
                Set<String> projectsInScope = getProjectsInScope(fromBranch, key);
                if (projectsInScope.contains(project)) {
                    downstreamBranches.add(key);
                }
            }
        }
    }
    return downstreamBranches;
}
#method_after
public Set<String> getDownstreamBranches(String fromBranch, String project) throws RestApiException, IOException, ConfigInvalidException {
    Set<String> downstreamBranches = new HashSet<String>();
    // List all subsections of automerger, split by :
    Set<String> subsections = getConfig().getSubsections(pluginName);
    for (String subsection : subsections) {
        // Subsections are of the form "fromBranch:toBranch"
        String[] branchPair = subsection.split(Pattern.quote(BRANCH_DELIMITER));
        if (branchPair.length != 2) {
            throw new ConfigInvalidException("Automerger config branch pair malformed: " + subsection);
        }
        if (fromBranch.equals(branchPair[0])) {
            // If fromBranches match, check if project is in both their manifests
            Set<String> projectsInScope = getProjectsInScope(branchPair[0], branchPair[1]);
            if (projectsInScope.contains(project)) {
                downstreamBranches.add(branchPair[1]);
            }
        }
    }
    return downstreamBranches;
}
#end_block

#method_before
// Returns contents of manifest file for the given branch pair
private Set<String> getManifestProjects(String fromBranch, String toBranch) throws RestApiException, IOException {
    Map<String, Object> toBranchConfig = config.getMergeConfig(fromBranch, toBranch);
    if (toBranchConfig == null) {
        return new HashSet<>();
    }
    Map<String, String> manifestProjectInfo = getManifestInfoFromConfig(toBranchConfig);
    return getManifestProjectsForBranch(manifestProjectInfo, toBranch);
}
#method_after
// Returns contents of manifest file for the given branch pair
private Set<String> getManifestProjects(String fromBranch, String toBranch) throws RestApiException, IOException, ConfigInvalidException {
    boolean ignoreSourceManifest = getConfig().getBoolean("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "ignoreSourceManifest", false);
    Set<String> toProjects = getProjectsInManifest(getManifestProject(), getManifestFile(), toBranch);
    if (ignoreSourceManifest) {
        return toProjects;
    }
    Set<String> fromProjects = getProjectsInManifest(getManifestProject(), getManifestFile(), fromBranch);
    fromProjects.retainAll(toProjects);
    return fromProjects;
}
#end_block

#method_before
private void applyConfig(Set<String> projects, Map givenConfig) {
    if (givenConfig == null) {
        return;
    }
    if (givenConfig.containsKey("set_projects")) {
        List<String> setProjects = (ArrayList<String>) givenConfig.get("set_projects");
        projects.clear();
        projects.addAll(setProjects);
        // if we set projects we can ignore the rest
        return;
    }
    if (givenConfig.containsKey("add_projects")) {
        List<String> addProjects = (List<String>) givenConfig.get("add_projects");
        projects.addAll(addProjects);
    }
    if (givenConfig.containsKey("ignore_projects")) {
        List<String> ignoreProjects = (List<String>) givenConfig.get("ignore_projects");
        projects.removeAll(ignoreProjects);
    }
}
#method_after
private Set<String> applyConfig(String fromBranch, String toBranch, Set<String> inputProjects) throws ConfigInvalidException {
    Set<String> projects = new HashSet<>(inputProjects);
    List<String> setProjects = Arrays.asList(getConfig().getStringList("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "setProjects"));
    if (!setProjects.isEmpty()) {
        projects.clear();
        projects.addAll(setProjects);
        // if we set projects we can ignore the rest
        return projects;
    }
    List<String> addProjects = Arrays.asList(getConfig().getStringList("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "addProjects"));
    projects.addAll(addProjects);
    List<String> ignoreProjects = Arrays.asList(getConfig().getStringList("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "ignoreProjects"));
    projects.removeAll(ignoreProjects);
    return projects;
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = event.getChange();
    String revision = event.getRevision().commit.commit;
    log.debug("Detected revision {} abandoned on {}.", revision, change.project);
    abandonDownstream(change, revision);
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = event.getChange();
    String revision = event.getRevision().commit.commit;
    log.debug("Detected revision {} abandoned on {}.", revision, change.project);
    try {
        abandonDownstream(change, revision);
    } catch (ConfigInvalidException e) {
        log.error("Automerger plugin failed onChangeAbandoned for {}", change.id, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.debug("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        } catch (RestApiException e) {
            log.error("RestApiException when editing downstream topics of {}", change.id, e);
        }
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.debug("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        } catch (RestApiException e) {
            log.error("RestApiException when editing downstream topics of {}", change.id, e);
        }
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException e) {
            log.error("RestApiException when updating downstream votes of {}", change.id, e);
        }
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException | ConfigInvalidException e) {
            log.error("Exception when updating downstream votes of {}", change.id, e);
        }
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onChangeRestored for {}", change.id, e);
    }
}
#end_block

#method_before
@Override
public void onDraftPublished(DraftPublishedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onDraftPublished for {}", change.id, e);
    }
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onRevisionCreated for {}", change.id, e);
    }
}
#end_block

#method_before
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException {
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    short vote = 0;
    try {
        createDownstreamMerges(mdsMergeInput);
        reviewInput.message = "Automerging to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
    } catch (FailedMergeException e) {
        reviewInput.message = e.displayConflicts();
        reviewInput.notify = NotifyHandling.ALL;
        vote = -1;
    }
    // Zero out automerge label if success, -1 vote if fail.
    labels.put(config.getAutomergeLabel(), vote);
    reviewInput.labels = labels;
    gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput);
}
#method_after
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, ConfigInvalidException {
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    short vote = 0;
    try {
        createDownstreamMerges(mdsMergeInput);
        reviewInput.message = "Automerging to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
    } catch (FailedMergeException e) {
        reviewInput.message = e.getDisplayString();
        reviewInput.notify = NotifyHandling.ALL;
        vote = -1;
    }
    // Zero out automerge label if success, -1 vote if fail.
    labels.put(config.getAutomergeLabel(), vote);
    reviewInput.labels = labels;
    gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput);
}
#end_block

#method_before
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException {
    List<String> failedMerges = new ArrayList<String>();
    List<Integer> existingDownstream;
    for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
        // Otherwise, create them.
        try {
            boolean createDownstreams = true;
            if (mdsMergeInput.obsoleteRevision != null) {
                existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
                if (!existingDownstream.isEmpty()) {
                    log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                    // it's possible to construct it so that it's not
                    for (Integer dsChangeNumber : existingDownstream) {
                        updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                        createDownstreams = false;
                    }
                }
            }
            if (createDownstreams) {
                log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
                sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
                sdsMergeInput.sourceId = mdsMergeInput.sourceId;
                sdsMergeInput.project = mdsMergeInput.project;
                sdsMergeInput.topic = mdsMergeInput.topic;
                sdsMergeInput.subject = mdsMergeInput.subject;
                sdsMergeInput.downstreamBranch = downstreamBranch;
                sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
                createSingleDownstreamMerge(sdsMergeInput);
            }
        } catch (MergeConflictException e) {
            // TODO(stephenli): also put host in the map
            Map<String, String> substitutionMap = new HashMap<>();
            substitutionMap.put("branch", downstreamBranch);
            substitutionMap.put("revision", mdsMergeInput.currentRevision);
            String resolvedString = assembleConflictMessage(substitutionMap, e.getMessage());
            log.debug("Merge conflict from {} to {}", mdsMergeInput.currentRevision, downstreamBranch);
            failedMerges.add(resolvedString);
            log.debug("Abandoning downstream of {}", mdsMergeInput.sourceId);
            abandonDownstream(gApi.changes().id(mdsMergeInput.sourceId).info(), mdsMergeInput.currentRevision);
        }
    }
    if (!failedMerges.isEmpty()) {
        throw new FailedMergeException(failedMerges);
    }
}
#method_after
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException, ConfigInvalidException {
    // Map from branch to error message
    Map<String, String> failedMergeBranchMap = new TreeMap<String, String>();
    List<Integer> existingDownstream;
    for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
        // Otherwise, create them.
        try {
            boolean createDownstreams = true;
            if (mdsMergeInput.obsoleteRevision != null) {
                existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
                if (!existingDownstream.isEmpty()) {
                    log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                    // it's possible to construct it so that it's not
                    for (Integer dsChangeNumber : existingDownstream) {
                        updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                        createDownstreams = false;
                    }
                }
            }
            if (createDownstreams) {
                log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
                sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
                sdsMergeInput.sourceId = mdsMergeInput.sourceId;
                sdsMergeInput.project = mdsMergeInput.project;
                sdsMergeInput.topic = mdsMergeInput.topic;
                sdsMergeInput.subject = mdsMergeInput.subject;
                sdsMergeInput.downstreamBranch = downstreamBranch;
                sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
                createSingleDownstreamMerge(sdsMergeInput);
            }
        } catch (MergeConflictException e) {
            failedMergeBranchMap.put(downstreamBranch, e.getMessage());
            log.debug("Abandoning downstream of {}", mdsMergeInput.sourceId);
            abandonDownstream(gApi.changes().id(mdsMergeInput.sourceId).info(), mdsMergeInput.currentRevision);
        }
    }
    if (!failedMergeBranchMap.isEmpty()) {
        throw new FailedMergeException(failedMergeBranchMap, mdsMergeInput.currentRevision, config.getHostName(), config.getConflictMessage(), mdsMergeInput.topic);
    }
}
#end_block

#method_before
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException {
    String currentTopic = setTopic(sdsMergeInput.sourceId, sdsMergeInput.topic);
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = sdsMergeInput.currentRevision;
    log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
    ChangeInput downstreamChangeInput = new ChangeInput();
    downstreamChangeInput.project = sdsMergeInput.project;
    downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
    downstreamChangeInput.subject = sdsMergeInput.subject + " am: " + sdsMergeInput.currentRevision.substring(0, 10);
    downstreamChangeInput.topic = currentTopic;
    downstreamChangeInput.merge = mergeInput;
    if (!sdsMergeInput.doMerge) {
        mergeInput.strategy = "ours";
        downstreamChangeInput.subject = sdsMergeInput.subject + " skipped: " + sdsMergeInput.currentRevision.substring(0, 10);
        log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
    }
    gApi.changes().create(downstreamChangeInput);
}
#method_after
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException {
    String currentTopic = setTopic(sdsMergeInput.sourceId, sdsMergeInput.topic);
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = sdsMergeInput.currentRevision;
    mergeInput.strategy = "recursive";
    log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
    ChangeInput downstreamChangeInput = new ChangeInput();
    downstreamChangeInput.project = sdsMergeInput.project;
    downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
    downstreamChangeInput.subject = sdsMergeInput.subject + " am: " + sdsMergeInput.currentRevision.substring(0, 10);
    downstreamChangeInput.topic = currentTopic;
    downstreamChangeInput.merge = mergeInput;
    if (!sdsMergeInput.doMerge) {
        mergeInput.strategy = "ours";
        downstreamChangeInput.subject = sdsMergeInput.subject + " skipped: " + sdsMergeInput.currentRevision.substring(0, 10);
        log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
    }
    gApi.changes().create(downstreamChangeInput);
}
#end_block

#method_before
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.sourceId = change.id;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = change.topic;
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#method_after
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException, ConfigInvalidException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.sourceId = change.id;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = change.topic;
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#end_block

#method_before
private void abandonDownstream(ChangeInfo change, String revision) {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#method_after
private void abandonDownstream(ChangeInfo change, String revision) throws ConfigInvalidException {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#end_block

#method_before
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    if (label.equals(config.getAutomergeLabel())) {
        log.debug("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#method_after
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException, ConfigInvalidException {
    if (label.equals(config.getAutomergeLabel())) {
        log.debug("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#end_block

#method_before
private ChangeContextImpl newChangeContext(Change.Id id) throws NoSuchChangeException, OrmException {
    logDebug("Opening change {} for update", id);
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (!isNew) {
        // Pass a synthetic change into ChangeNotes.Factory, which will take care of checking for
        // existence and populating columns from the parsed notes state.
        // TODO(dborowitz): This dance made more sense when using Reviewdb; consider a nicer way.
        c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
    } else {
        logDebug("Change {} is new", id);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContextImpl(ctl);
}
#method_after
private ChangeContextImpl newChangeContext(Change.Id id) throws OrmException {
    logDebug("Opening change {} for update", id);
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (!isNew) {
        // Pass a synthetic change into ChangeNotes.Factory, which will take care of checking for
        // existence and populating columns from the parsed notes state.
        // TODO(dborowitz): This dance made more sense when using Reviewdb; consider a nicer way.
        c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
    } else {
        logDebug("Change {} is new", id);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContextImpl(ctl);
}
#end_block

#method_before
@Override
public void close() {
    if (closeRepo) {
        revWalk.close();
        inserter.close();
        repo.close();
    }
}
#method_after
@Override
public void close() {
    if (closeRepo) {
        revWalk.getObjectReader().close();
        revWalk.close();
        inserter.close();
        repo.close();
    }
}
#end_block

#method_before
public BatchUpdate insertChange(InsertChangeOp op) {
    Context ctx = newContext();
    Change c = op.createChange(ctx);
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#method_after
public BatchUpdate insertChange(InsertChangeOp op) throws IOException {
    Context ctx = newContext();
    Change c = op.createChange(ctx);
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#end_block

#method_before
@Test
public void downstreamBranchesTest_configException() throws Exception {
    defaultSetup("wrong.config");
    thrown.expect(ConfigInvalidException.class);
    thrown.expectMessage("Automerger config branch pair malformed: master..ds_one");
    configLoader.getDownstreamBranches("master", "platform/some/project");
}
#method_after
@Test
public void downstreamBranchesTest_configException() throws Exception {
    defaultSetup("wrong.config");
    exception.expect(ConfigInvalidException.class);
    exception.expectMessage("Automerger config branch pair malformed: master..ds_one");
    configLoader.getDownstreamBranches("master", "platform/some/project");
}
#end_block

#method_before
@Test
public void testExpectedFlow() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("subject", "filename", "content", "testtopic");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().change().getProject().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new patchset to create the downstreams
    amendChange(result.getChangeId());
    result.assertOkStatus();
    // Check that there are the correct number of changes in the topic
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + gApi.changes().id(result.getChangeId()).topic()).get();
    assertThat(changesInTopic).hasSize(3);
    // +2 and submit
    merge(result);
}
#method_after
@Test
public void testExpectedFlow() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("subject", "filename", "content", "testtopic");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().project().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new patchset to create the downstreams
    amendChange(result.getChangeId());
    result.assertOkStatus();
    // Check that there are the correct number of changes in the topic
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + gApi.changes().id(result.getChangeId()).topic()).get();
    assertThat(changesInTopic).hasSize(3);
    // +2 and submit
    merge(result);
}
#end_block

#method_before
@Test
public void testBlankMerge() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("DO NOT MERGE subject", "filename", "content", "testtopic");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().change().getProject().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new patchset to create the downstreams
    amendChange(result.getChangeId(), "DO NOT MERGE subject", "filename", "content");
    result.assertOkStatus();
    ChangeApi change = gApi.changes().id(result.getChangeId());
    BinaryResult content = change.current().file("filename").content();
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + change.topic()).get();
    assertThat(changesInTopic).hasSize(3);
    for (ChangeInfo c : changesInTopic) {
        ChangeApi downstreamChange = gApi.changes().id(c._number);
        // It should skip ds_one, since this is a DO NOT MERGE
        if (c.branch.equals("ds_one")) {
            assertThat(downstreamChange.get().subject).contains("skipped:");
            assertThat(downstreamChange.current().files().keySet()).contains("filename");
            assertThat(downstreamChange.current().files().get("filename").linesDeleted).isEqualTo(1);
        } else if (c.branch.equals("ds_two")) {
            // It should not skip ds_two, since it is marked with mergeAll: true
            assertThat(downstreamChange.get().subject).doesNotContain("skipped:");
            BinaryResult downstreamContent = downstreamChange.current().file("filename").content();
            assertThat(downstreamContent.asString()).isEqualTo(content.asString());
        } else {
            assertThat(c.branch).isEqualTo("master");
        }
    }
}
#method_after
@Test
public void testBlankMerge() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("DO NOT MERGE subject", "filename", "content", "testtopic");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().project().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new patchset to create the downstreams
    amendChange(result.getChangeId(), "DO NOT MERGE subject", "filename", "content");
    result.assertOkStatus();
    ChangeApi change = gApi.changes().id(result.getChangeId());
    BinaryResult content = change.current().file("filename").content();
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + change.topic()).get();
    assertThat(changesInTopic).hasSize(3);
    for (ChangeInfo c : changesInTopic) {
        ChangeApi downstreamChange = gApi.changes().id(c._number);
        // It should skip ds_one, since this is a DO NOT MERGE
        if (c.branch.equals("ds_one")) {
            assertThat(downstreamChange.get().subject).contains("skipped:");
            assertThat(downstreamChange.current().files().keySet()).contains("filename");
            assertThat(downstreamChange.current().files().get("filename").linesDeleted).isEqualTo(1);
        } else if (c.branch.equals("ds_two")) {
            // It should not skip ds_two, since it is marked with mergeAll: true
            assertThat(downstreamChange.get().subject).doesNotContain("skipped:");
            BinaryResult downstreamContent = downstreamChange.current().file("filename").content();
            assertThat(downstreamContent.asString()).isEqualTo(content.asString());
        } else {
            assertThat(c.branch).isEqualTo("master");
        }
    }
}
#end_block

#method_before
@Test
public void testAlwaysBlankMerge() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("DO NOT MERGE ANYWHERE subject", "filename", "content", "testtopic");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().change().getProject().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new patchset to create the downstreams
    amendChange(result.getChangeId(), "DO NOT MERGE ANYWHERE subject", "filename", "content");
    result.assertOkStatus();
    ChangeApi change = gApi.changes().id(result.getChangeId());
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + change.topic()).get();
    assertThat(changesInTopic).hasSize(3);
    for (ChangeInfo c : changesInTopic) {
        ChangeApi downstreamChange = gApi.changes().id(c._number);
        // It should skip ds_one, since this is a DO NOT MERGE
        if (c.branch.equals("ds_one") || c.branch.equals("ds_two")) {
            assertThat(downstreamChange.get().subject).contains("skipped:");
            assertThat(downstreamChange.current().files().keySet()).contains("filename");
            assertThat(downstreamChange.current().files().get("filename").linesDeleted).isEqualTo(1);
        } else {
            assertThat(c.branch).isEqualTo("master");
        }
    }
}
#method_after
@Test
public void testAlwaysBlankMerge() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("DO NOT MERGE ANYWHERE subject", "filename", "content", "testtopic");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().project().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new patchset to create the downstreams
    amendChange(result.getChangeId(), "DO NOT MERGE ANYWHERE subject", "filename", "content");
    result.assertOkStatus();
    ChangeApi change = gApi.changes().id(result.getChangeId());
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + change.topic()).get();
    assertThat(changesInTopic).hasSize(3);
    for (ChangeInfo c : changesInTopic) {
        ChangeApi downstreamChange = gApi.changes().id(c._number);
        // It should skip ds_one and ds_two, since this is a DO NOT MERGE ANYWHERE
        if (c.branch.equals("ds_one") || c.branch.equals("ds_two")) {
            assertThat(downstreamChange.get().subject).contains("skipped:");
            assertThat(downstreamChange.current().files().keySet()).contains("filename");
            assertThat(downstreamChange.current().files().get("filename").linesDeleted).isEqualTo(1);
        } else {
            assertThat(c.branch).isEqualTo("master");
        }
    }
}
#end_block

#method_before
@Test
public void testDownstreamMergeConflict() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("subject", "filename", "echo Hello");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().change().getProject().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    result.assertOkStatus();
    merge(result);
    // Reset to create a sibling
    ObjectId initial = repo().exactRef("HEAD").getLeaf().getObjectId();
    testRepo.reset(initial);
    // Set up a merge conflict between master and ds_one
    PushOneCommit.Result ds1Result = createChange(testRepo, "ds_one", "subject", "filename", "echo \"Hello asdfsd World\"", "randtopic");
    ds1Result.assertOkStatus();
    merge(ds1Result);
    // Reset to allow our merge conflict to come
    testRepo.reset(initial);
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new change to create the downstreams
    PushOneCommit.Result masterResult = pushFactory.create(db, admin.getIdent(), testRepo, "subject", "filename", "echo 'Hello World!'").to("refs/for/master");
    masterResult.assertOkStatus();
    // Since there's a conflict with ds_one, there should only be two changes in the topic
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + gApi.changes().id(masterResult.getChangeId()).topic()).get();
    assertThat(changesInTopic).hasSize(2);
}
#method_after
@Test
public void testDownstreamMergeConflict() throws Exception {
    Project.NameKey manifestNameKey = defaultSetup();
    // Create initial change
    PushOneCommit.Result result = createChange("subject", "filename", "echo Hello");
    // Project name is scoped by test, so we need to get it from our initial change
    String projectName = result.getChange().project().get();
    createBranch(new Branch.NameKey(projectName, "ds_one"));
    createBranch(new Branch.NameKey(projectName, "ds_two"));
    result.assertOkStatus();
    merge(result);
    // Reset to create a sibling
    ObjectId initial = repo().exactRef("HEAD").getLeaf().getObjectId();
    testRepo.reset(initial);
    // Set up a merge conflict between master and ds_one
    PushOneCommit.Result ds1Result = createChange(testRepo, "ds_one", "subject", "filename", "echo \"Hello asdfsd World\"", "randtopic");
    ds1Result.assertOkStatus();
    merge(ds1Result);
    // Reset to allow our merge conflict to come
    testRepo.reset(initial);
    pushConfig("automerger.config", manifestNameKey.get(), projectName);
    // After we upload our config, we upload a new change to create the downstreams
    PushOneCommit.Result masterResult = pushFactory.create(db, admin.getIdent(), testRepo, "subject", "filename", "echo 'Hello World!'").to("refs/for/master");
    masterResult.assertOkStatus();
    // Since there's a conflict with ds_one, there should only be two changes in the topic
    List<ChangeInfo> changesInTopic = gApi.changes().query("topic: " + gApi.changes().id(masterResult.getChangeId()).topic()).get();
    assertThat(changesInTopic).hasSize(2);
}
#end_block

#method_before
private void pushConfig(String resourceName, String manifestName, String project) throws Exception {
    TestRepository<InMemoryRepository> allProjectRepo = cloneProject(allProjects, admin);
    GitUtil.fetch(allProjectRepo, RefNames.REFS_CONFIG + ":config");
    allProjectRepo.reset("config");
    try (InputStream in = getClass().getResourceAsStream(resourceName)) {
        String resourceString = CharStreams.toString(new InputStreamReader(in, Charsets.UTF_8));
        Config cfg = new Config();
        cfg.fromText(resourceString);
        // Update manifest project path to the result of createProject(resourceName), since it is
        // scoped to the test method
        cfg.setString("global", null, "manifestProject", manifestName);
        cfg.setString("automerger", "master:ds_one", "setProjects", project);
        cfg.setString("automerger", "master:ds_two", "setProjects", project);
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectRepo, "Subject", "automerger.config", cfg.toText());
        push.to("refs/meta/config").assertOkStatus();
    }
}
#method_after
private void pushConfig(String resourceName, String manifestName, String project) throws Exception {
    TestRepository<InMemoryRepository> allProjectRepo = cloneProject(allProjects, admin);
    GitUtil.fetch(allProjectRepo, RefNames.REFS_CONFIG + ":config");
    allProjectRepo.reset("config");
    try (InputStream in = getClass().getResourceAsStream(resourceName)) {
        String resourceString = CharStreams.toString(new InputStreamReader(in, Charsets.UTF_8));
        Config cfg = new Config();
        cfg.fromText(resourceString);
        // Update manifest project path to the result of createProject(resourceName), since it is
        // scoped to the test method
        cfg.setString("global", null, "manifestProject", manifestName);
        cfg.setString("automerger", "master:ds_one", "setProjects", project);
        cfg.setString("automerger", "master:ds_two", "setProjects", project);
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectRepo, "Subject", "automerger.config", cfg.toText());
        push.to(RefNames.REFS_CONFIG).assertOkStatus();
    }
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
    files.add(TestUtils.createEmptyFile(GOOD, repo));
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
    files.add(TestUtils.createEmptyFile(GOOD, repo));
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testAddTooLongPath() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, new RevWalk(repo), getMaxPathLength());
    Set<String> expected = ImmutableSet.of("ERROR: path too long: " + TOO_LONG);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testAddTooLongPath() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, rw, getMaxPathLength());
        Set<String> expected = ImmutableSet.of("ERROR: path too long: " + TOO_LONG);
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
@Test
public void testDeleteTooLongPath() throws Exception {
    RevCommit c = makeCommit();
    try (Git git = new Git(repo)) {
        Set<File> files = new HashSet<>();
        files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
        TestUtils.removeFiles(git, files);
        c = git.commit().setMessage("Delete file which is too long").call();
    }
    List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, new RevWalk(repo), getMaxPathLength());
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testDeleteTooLongPath() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        try (Git git = new Git(repo)) {
            Set<File> files = new HashSet<>();
            files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
            TestUtils.removeFiles(git, files);
            c = git.commit().setMessage("Delete file which is too long").call();
            rw.parseCommit(c);
        }
        List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, rw, getMaxPathLength());
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
private RevCommit makeCommitWithSymlink() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    File link = new File(repo.getDirectory().getParent(), "foo.txt");
    Files.createSymbolicLink(link.toPath(), Paths.get("bar.txt"));
    files.put(link, null);
    link = new File(repo.getDirectory().getParent(), "symbolicFolder");
    Files.createSymbolicLink(link.toPath(), Paths.get("folder"));
    files.put(link, null);
    return TestUtils.makeCommit(repo, "Commit with symlink.", files);
}
#method_after
private RevCommit makeCommitWithSymlink(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    File link = new File(repo.getDirectory().getParent(), "foo.txt");
    Files.createSymbolicLink(link.toPath(), Paths.get("bar.txt"));
    files.put(link, null);
    link = new File(repo.getDirectory().getParent(), "symbolicFolder");
    Files.createSymbolicLink(link.toPath(), Paths.get("folder"));
    files.put(link, null);
    return TestUtils.makeCommit(rw, repo, "Commit with symlink.", files);
}
#end_block

#method_before
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c, new RevWalk(repo));
    Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSymlink() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithSymlink(rw);
        List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, rw.parseCommit(c), rw);
        Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
private RevCommit makeCommitWithoutSymlink() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommitWithoutSymlink(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testWithoutSymlink() throws Exception {
    RevCommit c = makeCommitWithoutSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c, new RevWalk(repo));
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testWithoutSymlink() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithoutSymlink(rw);
        List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, rw.parseCommit(c), rw);
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
private RevCommit makeCommit(List<String> blockedExtensions) throws NoFilepatternException, IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String extension : blockedExtensions) {
        files.add(new File(repo.getDirectory().getParent(), "foo." + extension));
    }
    // valid extensions
    files.add(new File(repo.getDirectory().getParent(), "foo.java"));
    files.add(new File(repo.getDirectory().getParent(), "foo.core.tmp"));
    files.add(new File(repo.getDirectory().getParent(), "foo.c"));
    files.add(new File(repo.getDirectory().getParent(), "foo.txt"));
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw, List<String> blockedExtensions) throws NoFilepatternException, IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String extension : blockedExtensions) {
        files.add(new File(repo.getDirectory().getParent(), "foo." + extension));
    }
    // valid extensions
    files.add(new File(repo.getDirectory().getParent(), "foo.java"));
    files.add(new File(repo.getDirectory().getParent(), "foo.core.tmp"));
    files.add(new File(repo.getDirectory().getParent(), "foo.c"));
    files.add(new File(repo.getDirectory().getParent(), "foo.txt"));
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testBlockedExtensions() throws Exception {
    RevCommit c = makeCommit(BLOCKED_EXTENSIONS_LC);
    List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, new RevWalk(repo), BLOCKED_EXTENSIONS_LC);
    List<String> expected = new ArrayList<>();
    for (String extension : BLOCKED_EXTENSIONS_LC) {
        expected.add("ERROR: blocked file: foo." + extension);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testBlockedExtensions() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, BLOCKED_EXTENSIONS_LC);
        List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, rw, BLOCKED_EXTENSIONS_LC);
        List<String> expected = new ArrayList<>();
        for (String extension : BLOCKED_EXTENSIONS_LC) {
            expected.add("ERROR: blocked file: foo." + extension);
        }
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
@Test
public void testBlockedExtensionsCaseInsensitive() throws Exception {
    RevCommit c = makeCommit(BLOCKED_EXTENSIONS_UC);
    List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, new RevWalk(repo), BLOCKED_EXTENSIONS_LC);
    List<String> expected = new ArrayList<>();
    for (String extension : BLOCKED_EXTENSIONS_UC) {
        expected.add("ERROR: blocked file: foo." + extension);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testBlockedExtensionsCaseInsensitive() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, BLOCKED_EXTENSIONS_UC);
        List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, rw, BLOCKED_EXTENSIONS_LC);
        List<String> expected = new ArrayList<>();
        for (String extension : BLOCKED_EXTENSIONS_UC) {
            expected.add("ERROR: blocked file: foo." + extension);
        }
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
private RevCommit makeCommitWithSubmodule() throws IOException, GitAPIException {
    try (Git git = new Git(repo)) {
        SubmoduleAddCommand addCommand = git.submoduleAdd();
        addCommand.setURI(repo.getDirectory().getCanonicalPath());
        addCommand.setPath("modules/library");
        addCommand.call().close();
        git.add().addFilepattern(".").call();
        return git.commit().setMessage("Commit with submodule.").call();
    }
}
#method_after
private RevCommit makeCommitWithSubmodule(RevWalk rw) throws IOException, GitAPIException {
    try (Git git = new Git(repo)) {
        SubmoduleAddCommand addCommand = git.submoduleAdd();
        addCommand.setURI(repo.getDirectory().getCanonicalPath());
        addCommand.setPath("modules/library");
        addCommand.call().close();
        git.add().addFilepattern(".").call();
        return rw.parseCommit(git.commit().setMessage("Commit with submodule.").call());
    }
}
#end_block

#method_before
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, new RevWalk(repo));
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: submodules are not allowed: modules/library");
}
#method_after
@Test
public void testWithSubmodule() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithSubmodule(rw);
        List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, rw);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: submodules are not allowed: modules/library");
    }
}
#end_block

#method_before
private RevCommit makeCommitWithoutSubmodule() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommitWithoutSubmodule(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testWithoutSubmodule() throws Exception {
    RevCommit c = makeCommitWithoutSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, new RevWalk(repo));
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testWithoutSubmodule() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithoutSubmodule(rw);
        List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, rw);
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
public static void visitChangedEntries(Repository repo, RevCommit c, RevWalk revWalk, TreeWalkVisitor visitor) throws IOException {
    try (TreeWalk tw = new TreeWalk(revWalk.getObjectReader())) {
        tw.setRecursive(true);
        tw.setFilter(TreeFilter.ANY_DIFF);
        tw.addTree(revWalk.parseTree(c.getTree()));
        if (c.getParentCount() > 0) {
            for (RevCommit p : c.getParents()) {
                if (p.getTree() == null) {
                    revWalk.parseHeaders(p);
                }
                tw.addTree(p.getTree());
            }
            while (tw.next()) {
                if (isDifferentToAllParents(c, tw)) {
                    visitor.onVisit(tw);
                }
            }
        } else {
            while (tw.next()) {
                visitor.onVisit(tw);
            }
        }
    }
}
#method_after
public static void visitChangedEntries(Repository repo, RevCommit c, RevWalk revWalk, TreeWalkVisitor visitor) throws IOException {
    try (TreeWalk tw = new TreeWalk(revWalk.getObjectReader())) {
        tw.setRecursive(true);
        tw.setFilter(TreeFilter.ANY_DIFF);
        tw.addTree(c.getTree());
        if (c.getParentCount() > 0) {
            for (RevCommit p : c.getParents()) {
                if (p.getTree() == null) {
                    revWalk.parseHeaders(p);
                }
                tw.addTree(p.getTree());
            }
            while (tw.next()) {
                if (isDifferentToAllParents(c, tw)) {
                    visitor.onVisit(tw);
                }
            }
        } else {
            while (tw.next()) {
                visitor.onVisit(tw);
            }
        }
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.user, receiveEvent.getProjectNameKey(), receiveEvent.getRefName(), KEY_CHECK_BLOCKED_KEYWORD)) {
            ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, receiveEvent.revWalk, blockedKeywordPatterns.values(), cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("includes files containing blocked keywords", messages);
                }
            }
        }
    } catch (NoSuchProjectException e) {
        throw new CommitValidationException("Upload validator failed to find project: " + receiveEvent.project.getName(), e);
    } catch (IOException | ExecutionException e) {
        throw new CommitValidationException("Upload validator errored while validating", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.user, receiveEvent.getProjectNameKey(), receiveEvent.getRefName(), KEY_CHECK_BLOCKED_KEYWORD)) {
            ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, receiveEvent.revWalk, blockedKeywordPatterns.values(), cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("includes files containing blocked keywords", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content;
    content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid line endings
    String content = "Testline1\r\n" + "Testline2\n" + "Testline3\r\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid line endings
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid line endings
    String content = "Testline1\r\n" + "Testline2\n" + "Testline3\r\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid line endings
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(rw, repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    InvalidLineEndingValidator validator = new InvalidLineEndingValidator(null, new ContentTypeUtil(PATTERN_CACHE), null, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, new RevWalk(repo), EMPTY_PLUGIN_CONFIG);
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found carriage return (CR) character in file: foo.txt");
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        InvalidLineEndingValidator validator = new InvalidLineEndingValidator(null, new ContentTypeUtil(PATTERN_CACHE), null, null, null);
        List<CommitValidationMessage> m = validator.performValidation(repo, c, rw, EMPTY_PLUGIN_CONFIG);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found carriage return (CR) character in file: foo.txt");
    }
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit foobar with test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(rw, repo, "Commit foobar with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, new RevWalk(repo), getPatterns().values(), EMPTY_PLUGIN_CONFIG);
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)", "ERROR: blocked keyword(s) found in: " + Patch.COMMIT_MSG + " (Line: 1) (found: foobar)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null, null);
        List<CommitValidationMessage> m = validator.performValidation(repo, c, rw, getPatterns().values(), EMPTY_PLUGIN_CONFIG);
        Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)", "ERROR: blocked keyword(s) found in: " + Patch.COMMIT_MSG + " (Line: 1) (found: foobar)");
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
private void runCheck(List<String> existingTreePaths, Set<String> testPaths, List<CommitValidationMessage> messages, List<String> visitedPaths) throws Exception {
    RevCommit c = makeCommit(createEmptyDirCacheEntries(existingTreePaths, testRepo), testRepo);
    try (TreeWalk tw = new TreeWalk(repo)) {
        tw.setRecursive(false);
        tw.addTree(c.getTree());
        tw.setFilter(new ListVisitedPathsFilter(visitedPaths));
        validator.checkForDuplicatesAgainstTheWholeTree(tw, testPaths, messages);
    }
}
#method_after
private void runCheck(List<String> existingTreePaths, Set<String> testPaths, List<CommitValidationMessage> messages, List<String> visitedPaths) throws Exception {
    RevCommit c = makeCommit(testRepo.getRevWalk(), createEmptyDirCacheEntries(existingTreePaths, testRepo), testRepo);
    try (TreeWalk tw = new TreeWalk(repo)) {
        tw.setRecursive(false);
        tw.addTree(c.getTree());
        tw.setFilter(new ListVisitedPathsFilter(visitedPaths));
        validator.checkForDuplicatesAgainstTheWholeTree(tw, testPaths, messages);
    }
}
#end_block

#method_before
@Test
public void testCheckInsideOfCommit() throws Exception {
    List<String> filenames = Lists.newArrayList(INITIAL_PATHNAMES);
    // add files with conflicting pathnames
    filenames.add("A");
    filenames.add("F1/ab");
    filenames.add("f2/sF1/aB");
    RevCommit c = makeCommit(createEmptyDirCacheEntries(filenames, testRepo), testRepo);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, new RevWalk(repo));
    assertThat(m).hasSize(4);
    // During checking inside of the commit it's unknown which file is checked
    // first, because of that, both capabilities must be checked.
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("A", "a")), transformMessage(conflict("a", "A")));
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1", "f1")), transformMessage(conflict("f1", "F1")));
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1/ab", "f1/ab")), transformMessage(conflict("f1/ab", "F1/ab")));
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("f2/sF1/aB", "f2/sF1/ab")), transformMessage(conflict("f2/sF1/ab", "f2/sF1/aB")));
}
#method_after
@Test
public void testCheckInsideOfCommit() throws Exception {
    List<String> filenames = Lists.newArrayList(INITIAL_PATHNAMES);
    // add files with conflicting pathnames
    filenames.add("A");
    filenames.add("F1/ab");
    filenames.add("f2/sF1/aB");
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, createEmptyDirCacheEntries(filenames, testRepo), testRepo);
        List<CommitValidationMessage> m = validator.performValidation(repo, c, rw);
        assertThat(m).hasSize(4);
        // During checking inside of the commit it's unknown which file is checked
        // first, because of that, both capabilities must be checked.
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("A", "a")), transformMessage(conflict("a", "A")));
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1", "f1")), transformMessage(conflict("f1", "F1")));
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1/ab", "f1/ab")), transformMessage(conflict("f1/ab", "F1/ab")));
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("f2/sF1/aB", "f2/sF1/ab")), transformMessage(conflict("f2/sF1/ab", "f2/sF1/aB")));
    }
}
#end_block

#method_before
@Test
public void testCheckRenaming() throws Exception {
    RevCommit c = makeCommit(createEmptyDirCacheEntries(INITIAL_PATHNAMES, testRepo), testRepo);
    DirCacheEntry[] entries = new DirCacheEntry[INITIAL_PATHNAMES.size()];
    for (int x = 0; x < INITIAL_PATHNAMES.size(); x++) {
        // Rename files
        entries[x] = createDirCacheEntry(INITIAL_PATHNAMES.get(x).toUpperCase(), EMPTY_CONTENT, testRepo);
    }
    RevCommit c1 = makeCommit(entries, testRepo, c);
    List<CommitValidationMessage> m = validator.performValidation(repo, c1, new RevWalk(repo));
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testCheckRenaming() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, createEmptyDirCacheEntries(INITIAL_PATHNAMES, testRepo), testRepo);
        DirCacheEntry[] entries = new DirCacheEntry[INITIAL_PATHNAMES.size()];
        for (int x = 0; x < INITIAL_PATHNAMES.size(); x++) {
            // Rename files
            entries[x] = createDirCacheEntry(INITIAL_PATHNAMES.get(x).toUpperCase(), EMPTY_CONTENT, testRepo);
        }
        RevCommit c1 = makeCommit(rw, entries, testRepo, c);
        List<CommitValidationMessage> m = validator.performValidation(repo, c1, rw);
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
@Test
public void testBlocked() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml", "text/html" };
    List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(), new RevWalk(repo), patterns, false);
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (application/pdf) in file: foo.pdf", "ERROR: found blocked content type (application/xml) in file: foo.xml", "ERROR: found blocked content type (text/html) in file: foo.html");
}
#method_after
@Test
public void testBlocked() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml", "text/html" };
    try (RevWalk rw = new RevWalk(repo)) {
        List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(rw), rw, patterns, false);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (application/pdf) in file: foo.pdf", "ERROR: found blocked content type (application/xml) in file: foo.xml", "ERROR: found blocked content type (text/html) in file: foo.html");
    }
}
#end_block

#method_before
@Test
public void testWhitelist() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml" };
    List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(), new RevWalk(repo), patterns, true);
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (text/html) in file: foo.html");
}
#method_after
@Test
public void testWhitelist() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml" };
    try (RevWalk rw = new RevWalk(repo)) {
        List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(rw), rw, patterns, true);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (text/html) in file: foo.html");
    }
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    String content = "<?xml version=\"1.0\"?><a><b>c</b></a>";
    files.put(TestUtils.createEmptyFile("foo.xml", repo), content.getBytes(StandardCharsets.UTF_8));
    content = "<html><body><h1>Hello World!</h1></body></html>";
    files.put(TestUtils.createEmptyFile("foo.html", repo), content.getBytes(StandardCharsets.UTF_8));
    files.put(TestUtils.createEmptyFile("foo.pdf", repo), TEST_PDF);
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    String content = "<?xml version=\"1.0\"?><a><b>c</b></a>";
    files.put(TestUtils.createEmptyFile("foo.xml", repo), content.getBytes(StandardCharsets.UTF_8));
    content = "<html><body><h1>Hello World!</h1></body></html>";
    files.put(TestUtils.createEmptyFile("foo.html", repo), content.getBytes(StandardCharsets.UTF_8));
    files.put(TestUtils.createEmptyFile("foo.pdf", repo), TEST_PDF);
    return TestUtils.makeCommit(rw, repo, "Commit with test files.", files);
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        files.add(new File(repo.getDirectory().getParent(), filenames));
    }
    // valid filename
    files.add(new File(repo.getDirectory().getParent(), "test"));
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        files.add(new File(repo.getDirectory().getParent(), filenames));
    }
    // valid filename
    files.add(new File(repo.getDirectory().getParent(), "test"));
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "\\[|\\]|\\*|#", "[%:@]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, new RevWalk(repo), invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "\\[|\\]|\\*|#", "[%:@]" };
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, rw, invalidFilenamePattern);
        Set<String> expected = new HashSet<>();
        for (String filenames : getInvalidFilenames()) {
            expected.add("ERROR: invalid characters found in filename: " + filenames);
        }
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
@Test
@GerritConfig(name = "review.robotCommentSizeLimit", value = "10k")
public void maximumAllowedSizeOfRobotCommentCanBeAdjusted() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    int sizeLimit = 10 * 1024;
    fixReplacementInfo.replacement = getStringFor(sizeLimit);
    exception.expect(BadRequestException.class);
    exception.expectMessage("limit");
    addRobotComment(changeId, withFixRobotCommentInput);
}
#method_after
@Test
@GerritConfig(name = "change.robotCommentSizeLimit", value = "10k")
public void maximumAllowedSizeOfRobotCommentCanBeAdjusted() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    int sizeLimit = 10 * 1024;
    fixReplacementInfo.replacement = getStringFor(sizeLimit);
    exception.expect(BadRequestException.class);
    exception.expectMessage("limit");
    addRobotComment(changeId, withFixRobotCommentInput);
}
#end_block

#method_before
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
        }
    }
    postReviewers.emailReviewers(change, to, cc, notify, accountsToNotify);
}
#method_after
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
            toByEmail.addAll(addition.op.reviewersByEmail);
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
            ccByEmail.addAll(addition.op.reviewersByEmail);
        }
    }
    postReviewers.emailReviewers(change, to, cc, toByEmail, ccByEmail, notify, accountsToNotify);
}
#end_block

#method_before
private void ensureSizeOfJsonInputIsWithinBounds(RobotCommentInput robotCommentInput) throws BadRequestException {
    int robotCommentSizeLimit = getRobotCommentSizeLimit();
    byte[] robotCommentBytes = GSON.toJson(robotCommentInput).getBytes(StandardCharsets.UTF_8);
    int robotCommentSize = robotCommentBytes.length;
    if (robotCommentSize > robotCommentSizeLimit) {
        throw new BadRequestException(String.format("Size %d (bytes) of robot comment is greater than limit %d (bytes)", robotCommentSize, robotCommentSizeLimit));
    }
}
#method_after
private void ensureSizeOfJsonInputIsWithinBounds(RobotCommentInput robotCommentInput) throws BadRequestException {
    OptionalInt robotCommentSizeLimit = getRobotCommentSizeLimit();
    if (robotCommentSizeLimit.isPresent()) {
        int sizeLimit = robotCommentSizeLimit.getAsInt();
        byte[] robotCommentBytes = GSON.toJson(robotCommentInput).getBytes(StandardCharsets.UTF_8);
        int robotCommentSize = robotCommentBytes.length;
        if (robotCommentSize > sizeLimit) {
            throw new BadRequestException(String.format("Size %d (bytes) of robot comment is greater than limit %d (bytes)", robotCommentSize, sizeLimit));
        }
    }
}
#end_block

#method_before
private int getRobotCommentSizeLimit() {
    int robotCommentSizeLimit = gerritConfig.getInt("review", "robotCommentSizeLimit", DEFAULT_ROBOT_COMMENT_SIZE_LIMIT_IN_BYTES);
    if (robotCommentSizeLimit < 0) {
        return DEFAULT_ROBOT_COMMENT_SIZE_LIMIT_IN_BYTES;
    }
    return robotCommentSizeLimit;
}
#method_after
private OptionalInt getRobotCommentSizeLimit() {
    int robotCommentSizeLimit = gerritConfig.getInt("change", "robotCommentSizeLimit", DEFAULT_ROBOT_COMMENT_SIZE_LIMIT_IN_BYTES);
    if (robotCommentSizeLimit <= 0) {
        return OptionalInt.empty();
    }
    return OptionalInt.of(robotCommentSizeLimit);
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    PermissionBackend.WithUser perm = permissionBackend.user(self);
    if (self.get() != rsrc.getUser()) {
        perm.check(GlobalPermission.ADMINISTRATE_SERVER);
        perm = permissionBackend.user(rsrc.getUser());
    }
    Map<String, Object> have = new LinkedHashMap<>();
    for (GlobalOrPluginPermission p : perm.test(permissionsToTest())) {
        have.put(p.permissionName(), true);
    }
    addRanges(have, rsrc);
    addPriority(have, rsrc);
    return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
    }.getType());
}
#method_after
@Override
public Object apply(AccountResource resource) throws AuthException {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = new LinkedHashMap<>();
    for (String name : GlobalCapability.getAllNames()) {
        if (want(name)) {
            if (GlobalCapability.hasRange(name)) {
                if (cc.hasExplicitRange(name)) {
                    have.put(name, new Range(cc.getRange(name)));
                }
            } else if (!name.equals(PRIORITY) && cc.canPerform(name)) {
                have.put(name, true);
            }
        }
    }
    for (String pluginName : pluginCapabilities.plugins()) {
        for (String capability : pluginCapabilities.byPlugin(pluginName).keySet()) {
            String name = String.format("%s-%s", pluginName, capability);
            if (want(name) && cc.canPerform(name)) {
                have.put(name, true);
            }
        }
    }
    have.put(ACCESS_DATABASE, cc.canAccessDatabase());
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(EMAIL_REVIEWERS, cc.canEmailReviewers());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(MAINTAIN_SERVER, cc.canMaintainServer());
    have.put(MODIFY_ACCOUNT, cc.canModifyAccount());
    have.put(RUN_GC, cc.canRunGC());
    have.put(STREAM_EVENTS, cc.canStreamEvents());
    have.put(VIEW_ALL_ACCOUNTS, cc.canViewAllAccounts());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_PLUGINS, cc.canViewPlugins());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
    }.getType());
}
#end_block

#method_before
public boolean canAccessDatabase() {
    try {
        return doCanForDefaultPermissionBackend(GlobalPermission.ACCESS_DATABASE);
    } catch (PermissionBackendException e) {
        return false;
    }
}
#method_after
public boolean canAccessDatabase() {
    return canPerform(GlobalCapability.ACCESS_DATABASE);
}
#end_block

#method_before
@Override
public IntraLineDiff call() throws Exception {
    Future<IntraLineDiff> result = diffExecutor.submit(() -> {
        return IntraLineLoader.compute(args.aText(), args.bText(), args.edits());
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for IntraLineDiff" + " in project " + args.project() + " on commit " + args.commit().name() + " for path " + args.path() + " comparing " + key.getBlobA().name() + ".." + key.getBlobB().name());
        result.cancel(true);
        return new IntraLineDiff(IntraLineDiff.Status.TIMEOUT);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.throwIfInstanceOf(e.getCause(), Exception.class);
        throw new Exception(e.getMessage(), e.getCause());
    }
}
#method_after
@Override
public IntraLineDiff call() throws Exception {
    Future<IntraLineDiff> result = diffExecutor.submit(() -> IntraLineLoader.compute(args.aText(), args.bText(), args.edits()));
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for IntraLineDiff" + " in project " + args.project() + " on commit " + args.commit().name() + " for path " + args.path() + " comparing " + key.getBlobA().name() + ".." + key.getBlobB().name());
        result.cancel(true);
        return new IntraLineDiff(IntraLineDiff.Status.TIMEOUT);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.throwIfInstanceOf(e.getCause(), Exception.class);
        throw new Exception(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
// See GuiceRequestScopePropagator#wrapImpl
@SuppressWarnings("javadoc")
public final <T> Callable<T> wrap(Callable<T> callable) {
    RequestContext callerContext = checkNotNull(local.getContext());
    Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable)));
    return () -> {
        if (callerContext == local.getContext()) {
            return callable.call();
        }
        return wrapped.call();
    };
}
#method_after
// See GuiceRequestScopePropagator#wrapImpl
@SuppressWarnings("javadoc")
public final <T> Callable<T> wrap(final Callable<T> callable) {
    final RequestContext callerContext = checkNotNull(local.getContext());
    final Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable)));
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            if (callerContext == local.getContext()) {
                return callable.call();
            }
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#end_block

#method_before
@Override
protected final <T> Callable<T> wrapImpl(final Callable<T> callable) {
    final C ctx = continuingContext(requireContext());
    return () -> {
        C old = threadLocal.get();
        threadLocal.set(ctx);
        try {
            return callable.call();
        } finally {
            if (old != null) {
                threadLocal.set(old);
            } else {
                threadLocal.remove();
            }
        }
    };
}
#method_after
@Override
protected final <T> Callable<T> wrapImpl(final Callable<T> callable) {
    C ctx = continuingContext(requireContext());
    return () -> {
        C old = threadLocal.get();
        threadLocal.set(ctx);
        try {
            return callable.call();
        } finally {
            if (old != null) {
                threadLocal.set(old);
            } else {
                threadLocal.remove();
            }
        }
    };
}
#end_block

#method_before
ListenableFuture<?> insert(final Document doc) {
    return submit(() -> {
        return writer.addDocument(doc);
    });
}
#method_after
ListenableFuture<?> insert(final Document doc) {
    return submit(() -> writer.addDocument(doc));
}
#end_block

#method_before
ListenableFuture<?> replace(final Term term, final Document doc) {
    return submit(() -> {
        return writer.updateDocument(term, doc);
    });
}
#method_after
ListenableFuture<?> replace(final Term term, final Document doc) {
    return submit(() -> writer.updateDocument(term, doc));
}
#end_block

#method_before
ListenableFuture<?> delete(final Term term) {
    return submit(() -> {
        return writer.deleteDocuments(term);
    });
}
#method_after
ListenableFuture<?> delete(final Term term) {
    return submit(() -> writer.deleteDocuments(term));
}
#end_block

#method_before
void put(K key, ValueHolder<V> holder) {
    if (holder.clean) {
        return;
    }
    BloomFilter<K> b = bloomFilter;
    if (b != null) {
        b.put(key);
        bloomFilter = b;
    }
    SqlHandle c = null;
    try {
        c = acquire();
        if (c.put == null) {
            c.put = c.conn.prepareStatement("MERGE INTO data VALUES(?,?,?,?)");
        }
        try {
            keyType.set(c.put, 1, key);
            c.put.setObject(2, holder.value, Types.JAVA_OBJECT);
            c.put.setTimestamp(3, new Timestamp(holder.created));
            c.put.setTimestamp(4, TimeUtil.nowTs());
            c.put.executeUpdate();
            holder.clean = true;
        } finally {
            c.put.clearParameters();
        }
    } catch (SQLException e) {
        log.warn("Cannot put into cache " + url, e);
        c = close(c);
    } finally {
        release(c);
    }
}
#method_after
void put(K key, ValueHolder<V> holder) {
    if (holder.clean) {
        return;
    }
    BloomFilter<K> b = bloomFilter;
    if (b != null) {
        b.put(key);
        bloomFilter = b;
    }
    SqlHandle c = null;
    try {
        c = acquire();
        if (c.put == null) {
            c.put = c.conn.prepareStatement("MERGE INTO data (k, v, created, accessed) VALUES(?,?,?,?)");
        }
        try {
            keyType.set(c.put, 1, key);
            c.put.setObject(2, holder.value, Types.JAVA_OBJECT);
            c.put.setTimestamp(3, new Timestamp(holder.created));
            c.put.setTimestamp(4, TimeUtil.nowTs());
            c.put.executeUpdate();
            holder.clean = true;
        } finally {
            c.put.clearParameters();
        }
    } catch (SQLException e) {
        log.warn("Cannot put into cache " + url, e);
        c = close(c);
    } finally {
        release(c);
    }
}
#end_block

#method_before
void prune(Cache<K, ?> mem) {
    SqlHandle c = null;
    try {
        c = acquire();
        try (Statement s = c.conn.createStatement()) {
            long used = 0;
            try (ResultSet r = s.executeQuery("SELECT SUM(OCTET_LENGTH(k) + OCTET_LENGTH(v)) FROM data")) {
                used = r.next() ? r.getLong(1) : 0;
            }
            if (used <= maxSize) {
                return;
            }
            try (ResultSet r = s.executeQuery("SELECT" + " k" + ",OCTET_LENGTH(k) + OCTET_LENGTH(v)" + ",created" + " FROM data" + " ORDER BY accessed")) {
                while (maxSize < used && r.next()) {
                    K key = keyType.get(r, 1);
                    Timestamp created = r.getTimestamp(3);
                    if (mem.getIfPresent(key) != null && !expired(created)) {
                        touch(c, key);
                    } else {
                        invalidate(c, key);
                        used -= r.getLong(2);
                    }
                }
            }
        }
    } catch (SQLException e) {
        log.warn("Cannot prune cache " + url, e);
        c = close(c);
    } finally {
        release(c);
    }
}
#method_after
void prune(Cache<K, ?> mem) {
    SqlHandle c = null;
    try {
        c = acquire();
        try (Statement s = c.conn.createStatement()) {
            long used = 0;
            try (ResultSet r = s.executeQuery("SELECT SUM(space) FROM data")) {
                used = r.next() ? r.getLong(1) : 0;
            }
            if (used <= maxSize) {
                return;
            }
            try (ResultSet r = s.executeQuery("SELECT" + " k" + ",space" + ",created" + " FROM data" + " ORDER BY accessed")) {
                while (maxSize < used && r.next()) {
                    K key = keyType.get(r, 1);
                    Timestamp created = r.getTimestamp(3);
                    if (mem.getIfPresent(key) != null && !expired(created)) {
                        touch(c, key);
                    } else {
                        invalidate(c, key);
                        used -= r.getLong(2);
                    }
                }
            }
        }
    } catch (SQLException e) {
        log.warn("Cannot prune cache " + url, e);
        c = close(c);
    } finally {
        release(c);
    }
}
#end_block

#method_before
DiskStats diskStats() {
    long size = 0;
    long space = 0;
    SqlHandle c = null;
    try {
        c = acquire();
        try (Statement s = c.conn.createStatement();
            ResultSet r = s.executeQuery("SELECT" + " COUNT(*)" + ",SUM(OCTET_LENGTH(k) + OCTET_LENGTH(v))" + " FROM data")) {
            if (r.next()) {
                size = r.getLong(1);
                space = r.getLong(2);
            }
        }
    } catch (SQLException e) {
        log.warn("Cannot get DiskStats for " + url, e);
        c = close(c);
    } finally {
        release(c);
    }
    return new DiskStats(size, space, hitCount.get(), missCount.get());
}
#method_after
DiskStats diskStats() {
    long size = 0;
    long space = 0;
    SqlHandle c = null;
    try {
        c = acquire();
        try (Statement s = c.conn.createStatement();
            ResultSet r = s.executeQuery("SELECT" + " COUNT(*)" + ",SUM(space)" + " FROM data")) {
            if (r.next()) {
                size = r.getLong(1);
                space = r.getLong(2);
            }
        }
    } catch (SQLException e) {
        log.warn("Cannot get DiskStats for " + url, e);
        c = close(c);
    } finally {
        release(c);
    }
    return new DiskStats(size, space, hitCount.get(), missCount.get());
}
#end_block

#method_before
@Override
public void onPluginLoad() {
    Plugin.get().screenRegex("jobs/(.*)", new JobsScreen.Factory());
    new RestApi("config").view("server").view(Plugin.get().getPluginName(), "config").get(new AsyncCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo info) {
            if (info.showJobsSummaryPanel()) {
                Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new JobsSummaryPanel.Factory());
            }
            if (info.showJobsPanel()) {
                if (info.showJobsPanelBelowTabPanel()) {
                    Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, new JobsPanel.Factory(info));
                } else {
                    Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new JobsPanel.Factory(info));
                }
            }
            if (info.showJobsDropDownPanel()) {
                Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new JobsDropDownPanel.Factory(info));
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        // never invoked
        }
    });
}
#method_after
@Override
public void onPluginLoad() {
    Plugin.get().screenRegex("jobs/(.*)", new JobsScreen.Factory());
    new RestApi("config").view("server").view(Plugin.get().getPluginName(), "config").get(new AsyncCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo info) {
            if (info.showJobsSummaryPanel()) {
                Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new JobsSummaryPanel.Factory());
            }
            if (info.showJobsPanel()) {
                Plugin.get().panel(info.showJobsBelowRelatedInfoBlock() ? GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK : GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new JobsPanel.Factory(info));
            }
            if (info.showJobsDropDownPanel()) {
                Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new JobsDropDownPanel.Factory(info));
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        // never invoked
        }
    });
}
#end_block

#method_before
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    if (input.showJobsSummaryPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsSummaryPanel", input.showJobsSummaryPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsSummaryPanel");
    }
    if (input.showJobsPanelBelowTabPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanelBelowTabPanel", input.showJobsPanelBelowTabPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanelBelowTabPanel");
    }
    if (input.sortJobsPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsPanel", JobsSorting.valueOf(input.sortJobsPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsPanel");
    }
    if (input.sortJobsDropDownPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsDropDownPanel", JobsSorting.valueOf(input.sortJobsDropDownPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    if (input.showJobsSummaryPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsSummaryPanel", input.showJobsSummaryPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsSummaryPanel");
    }
    if (input.showJobsBelowRelatedInfoBlock != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsBelowRelatedInfoBlock", input.showJobsBelowRelatedInfoBlock);
    } else {
        cfg.unset("plugin", pluginName, "showJobsBelowRelatedInfoBlock");
    }
    if (input.sortJobsPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsPanel", JobsSorting.valueOf(input.sortJobsPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsPanel");
    }
    if (input.sortJobsDropDownPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsDropDownPanel", JobsSorting.valueOf(input.sortJobsDropDownPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#end_block

#method_before
@Override
public ConfigInfo apply(ConfigResource resource) {
    ConfigInfo info = new ConfigInfo();
    info.showJobsPanel = cfg.getBoolean("showJobsPanel", true);
    info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true);
    info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true);
    info.showJobsPanelBelowTabPanel = cfg.getBoolean("showJobsPanelBelowTabPanel", false);
    info.sortJobsPanel = cfg.getEnum(JobsSorting.values(), "sortJobsPanel", JobsSorting.REPORTER);
    info.sortJobsDropDownPanel = cfg.getEnum(JobsSorting.values(), "sortJobsDropDownPanel", JobsSorting.REPORTER);
    return info;
}
#method_after
@Override
public ConfigInfo apply(ConfigResource resource) {
    ConfigInfo info = new ConfigInfo();
    info.showJobsPanel = cfg.getBoolean("showJobsPanel", true);
    info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true);
    info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true);
    info.showJobsBelowRelatedInfoBlock = cfg.getBoolean("showJobsBelowRelatedInfoBlock", false);
    info.sortJobsPanel = cfg.getEnum(JobsSorting.values(), "sortJobsPanel", JobsSorting.REPORTER);
    info.sortJobsDropDownPanel = cfg.getEnum(JobsSorting.values(), "sortJobsDropDownPanel", JobsSorting.REPORTER);
    return info;
}
#end_block

#method_before
@Override
public void onRemoveByKeys(ObjectId newNotesRev, Account.Id accountId, Collection<ExternalId.Key> extIdKeys) throws IOException {
    updateCache(newNotesRev, m -> Collections2.transform(m.get(accountId), e -> e.key()).removeAll(extIdKeys));
}
#method_after
@Override
public void onRemoveByKeys(ObjectId newNotesRev, Account.Id accountId, Collection<ExternalId.Key> extIdKeys) throws IOException {
    updateCache(newNotesRev, m -> removeKeys(m.get(accountId), extIdKeys));
}
#end_block

#method_before
@Override
public void onRemoveByKeys(ObjectId newNotesRev, Collection<ExternalId.Key> extIdKeys) throws IOException {
    updateCache(newNotesRev, m -> Collections2.transform(m.values(), e -> e.key()).removeAll(extIdKeys));
}
#method_after
@Override
public void onRemoveByKeys(ObjectId newNotesRev, Collection<ExternalId.Key> extIdKeys) throws IOException {
    updateCache(newNotesRev, m -> removeKeys(m.values(), extIdKeys));
}
#end_block

#method_before
@Override
public void onUpdate(ObjectId newNotesRev, Collection<ExternalId> updatedExtIds) throws IOException {
    updateCache(newNotesRev, m -> {
        Collections2.transform(m.values(), e -> e.key()).removeAll(updatedExtIds.stream().map(e -> e.key()).collect(toSet()));
        for (ExternalId updatedExtId : updatedExtIds) {
            m.put(updatedExtId.accountId(), updatedExtId);
        }
    });
}
#method_after
@Override
public void onUpdate(ObjectId newNotesRev, Collection<ExternalId> updatedExtIds) throws IOException {
    updateCache(newNotesRev, m -> {
        removeKeys(m.values(), updatedExtIds.stream().map(e -> e.key()).collect(toSet()));
        for (ExternalId updatedExtId : updatedExtIds) {
            m.put(updatedExtId.accountId(), updatedExtId);
        }
    });
}
#end_block

#method_before
@Override
public void onReplaceByKeys(ObjectId newNotesRev, Account.Id accountId, Collection<ExternalId.Key> toRemove, Collection<ExternalId> toAdd) throws IOException {
    ExternalIdsUpdate.checkSameAccount(toAdd, accountId);
    updateCache(newNotesRev, m -> {
        Collections2.transform(m.get(accountId), e -> e.key()).removeAll(toRemove);
        for (ExternalId extId : toAdd) {
            m.put(extId.accountId(), extId);
        }
    });
}
#method_after
@Override
public void onReplaceByKeys(ObjectId newNotesRev, Account.Id accountId, Collection<ExternalId.Key> toRemove, Collection<ExternalId> toAdd) throws IOException {
    ExternalIdsUpdate.checkSameAccount(toAdd, accountId);
    updateCache(newNotesRev, m -> {
        removeKeys(m.get(accountId), toRemove);
        for (ExternalId extId : toAdd) {
            m.put(extId.accountId(), extId);
        }
    });
}
#end_block

#method_before
@Override
public void onReplaceByKeys(ObjectId newNotesRev, Collection<ExternalId.Key> toRemove, Collection<ExternalId> toAdd) throws IOException {
    updateCache(newNotesRev, m -> {
        Collections2.transform(m.values(), e -> e.key()).removeAll(toRemove);
        for (ExternalId extId : toAdd) {
            m.put(extId.accountId(), extId);
        }
    });
}
#method_after
@Override
public void onReplaceByKeys(ObjectId newNotesRev, Collection<ExternalId.Key> toRemove, Collection<ExternalId> toAdd) throws IOException {
    updateCache(newNotesRev, m -> {
        removeKeys(m.values(), toRemove);
        for (ExternalId extId : toAdd) {
            m.put(extId.accountId(), extId);
        }
    });
}
#end_block

#method_before
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).get(accountId);
    } catch (ExecutionException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).get(accountId);
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#end_block

#method_before
@Override
public Set<ExternalId> byEmail(String email) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).values().stream().filter(e -> email.equals(e.email())).collect(toSet());
    } catch (ExecutionException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException("Cannot list external ids by email", e);
    }
}
#method_after
@Override
public Set<ExternalId> byEmail(String email) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).values().stream().filter(e -> email.equals(e.email())).collect(toSet());
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by email", e);
    }
}
#end_block

#method_before
public void writeToConfig(Config c) {
    String externalIdKey = key().get();
    c.setString(EXTERNAL_ID_SECTION, externalIdKey, ACCOUNT_ID_KEY, Integer.toString(accountId().get()));
    if (email() != null) {
        c.setString(EXTERNAL_ID_SECTION, externalIdKey, EMAIL_KEY, email());
    }
    if (password() != null) {
        c.setString(EXTERNAL_ID_SECTION, externalIdKey, PASSWORD_KEY, password());
    }
}
#method_after
public void writeToConfig(Config c) {
    String externalIdKey = key().get();
    // Do not use c.setInt(...) to write the account ID because c.setInt(...) persists integers
    // that can be expressed in KiB as a unit strings, e.g. "1024000" is stored as "100k". Using
    // c.setString(...) ensures that account IDs are human readable.
    c.setString(EXTERNAL_ID_SECTION, externalIdKey, ACCOUNT_ID_KEY, Integer.toString(accountId().get()));
    if (email() != null) {
        c.setString(EXTERNAL_ID_SECTION, externalIdKey, EMAIL_KEY, email());
    }
    if (password() != null) {
        c.setString(EXTERNAL_ID_SECTION, externalIdKey, PASSWORD_KEY, password());
    }
}
#end_block

#method_before
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).get(accountId);
    } catch (ExecutionException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).get(accountId);
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#end_block

#method_before
@Override
public Set<ExternalId> byEmail(String email) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).values().stream().filter(e -> email.equals(e.email())).collect(toSet());
    } catch (ExecutionException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException("Cannot list external ids by email", e);
    }
}
#method_after
@Override
public Set<ExternalId> byEmail(String email) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).values().stream().filter(e -> email.equals(e.email())).collect(toSet());
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by email", e);
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (BadRequestException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate).setValidatePolicy(CommitValidators.Policy.NONE);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            permissionBackend.user(user).project(project.getNameKey()).ref(refName).changeWithoutData(changeId).check(ChangePermission.EDIT_HASHTAGS);
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws Exception {
                // return pseudo dirty state to trigger reindexing
                return true;
            }
        });
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) {
    bu.addOp(psId.getParentKey(), new BatchUpdate.Op() {

        @Override
        public boolean updateChange(ChangeContext ctx) throws OrmException {
            PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
            List<String> oldGroups = ps.getGroups();
            if (oldGroups == null) {
                if (groups == null) {
                    return false;
                }
            } else if (sameGroups(oldGroups, groups)) {
                return false;
            }
            psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
            return true;
        }
    });
}
#method_after
private void addOps(BatchUpdate bu) {
    bu.addOp(psId.getParentKey(), new BatchUpdateOp() {

        @Override
        public boolean updateChange(ChangeContext ctx) throws OrmException {
            PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
            List<String> oldGroups = ps.getGroups();
            if (oldGroups == null) {
                if (groups == null) {
                    return false;
                }
            } else if (sameGroups(oldGroups, groups)) {
                return false;
            }
            psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
            return true;
        }
    });
}
#end_block

#method_before
public boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#method_after
boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#end_block

#method_before
public boolean canEditTopicName() {
    return canPerform(Permission.EDIT_TOPIC_NAME);
}
#method_after
boolean canEditTopicName() {
    return canPerform(Permission.EDIT_TOPIC_NAME);
}
#end_block

#method_before
public boolean canEditHashtags() {
    return canPerform(Permission.EDIT_HASHTAGS);
}
#method_after
boolean canEditHashtags() {
    return canPerform(Permission.EDIT_HASHTAGS);
}
#end_block

#method_before
public boolean canEditAssignee() {
    return canPerform(Permission.EDIT_ASSIGNEE);
}
#method_after
boolean canEditAssignee() {
    return canPerform(Permission.EDIT_ASSIGNEE);
}
#end_block

#method_before
@Override
public ForRef user(CurrentUser user) {
    return forUser(user).asForRef();
}
#method_after
@Override
public ForRef user(CurrentUser user) {
    return forUser(user).asForRef().database(db);
}
#end_block

#method_before
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#method_after
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd, db);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#end_block

#method_before
@Override
public ForChange change(ChangeNotes notes) {
    Change change = notes.getChange();
    checkArgument(getProjectControl().getProject().getNameKey().equals(change.getProject()), "mismatched project");
    return getProjectControl().controlFor(notes).asForChange();
}
#method_after
@Override
public ForChange change(ChangeNotes notes) {
    Change change = notes.getChange();
    checkArgument(getProjectControl().getProject().getNameKey().equals(change.getProject()), "mismatched project");
    return getProjectControl().controlFor(notes).asForChange(null, db);
}
#end_block

#method_before
@Override
public void check(RefPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(RefPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(Permission.CREATE);
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case CREATE_CHANGE:
            return canUpload();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case CREATE_CHANGE:
            return canUpload();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#method_after
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
private boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#method_after
public boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return (isAdmin() || (isOwner() && getRefControl().canDeleteOwnChanges()));
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#method_after
public boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#end_block

#method_before
private boolean canRestore(ReviewDb db) throws OrmException {
    return // Anyone who can abandon the change can restore it back
    canAbandon(db) && // as long as you can upload too
    getRefControl().canUpload();
}
#method_after
public boolean canRestore(ReviewDb db) throws OrmException {
    return // Anyone who can abandon the change can restore it back
    canAbandon(db) && // as long as you can upload too
    getRefControl().canUpload();
}
#end_block

#method_before
ForChange asForChange() {
    return new ForChangeImpl(null);
}
#method_after
ForChange asForChange(@Nullable ChangeData cd, @Nullable Provider<ReviewDb> db) {
    return new ForChangeImpl(cd, db);
}
#end_block

#method_before
@Nullable
private ReviewDb db() {
    return cd != null ? cd.db() : null;
}
#method_after
private ReviewDb db() {
    if (db != null) {
        return db.get();
    } else if (cd != null) {
        return cd.db();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public ForChange user(CurrentUser user) {
    return getUser().equals(user) ? this : forUser(user).asForChange(cd);
}
#method_after
@Override
public ForChange user(CurrentUser user) {
    return getUser().equals(user) ? this : forUser(user).asForChange(cd, db);
}
#end_block

#method_before
@Override
public void check(ChangePermissionOrLabel perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(ChangePermissionOrLabel perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), cd);
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case REMOVE_REVIEWER:
                // TODO Honor specific removal filters?
                return getRefControl().canRemoveReviewer();
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return canSubmit();
            case // TODO Honor specific removal filters?
            REMOVE_REVIEWER:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
private boolean can(LabelPermission perm) {
    PermissionRange r = label(perm.permissionName().get());
    return r.getMin() < 0 || r.getMax() > 0;
}
#method_after
private boolean can(LabelPermission perm) {
    return !label(perm.permissionName().get()).isEmpty();
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#method_after
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return (isAdmin() || (isOwner() && getRefControl().canDeleteOwnChanges()));
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#method_after
private boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#end_block

#method_before
public boolean canEditHashtags() {
    return // owner (aka creator) of the change can edit hashtags
    isOwner() || // branch owner can edit hashtags
    getRefControl().isOwner() || // project owner can edit hashtags
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can edit hashtag on a specific ref
    getRefControl().canEditHashtags();
}
#method_after
private boolean canEditHashtags() {
    return // owner (aka creator) of the change can edit hashtags
    isOwner() || // branch owner can edit hashtags
    getRefControl().isOwner() || // project owner can edit hashtags
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can edit hashtag on a specific ref
    getRefControl().canEditHashtags();
}
#end_block

#method_before
ForChange asForChange() {
    return new ForChangeImpl(null);
}
#method_after
ForChange asForChange(@Nullable ChangeData cd, @Nullable Provider<ReviewDb> db) {
    return new ForChangeImpl(cd, db);
}
#end_block

#method_before
@Nullable
private ReviewDb db() {
    return cd != null ? cd.db() : null;
}
#method_after
private ReviewDb db() {
    if (db != null) {
        return db.get();
    } else if (cd != null) {
        return cd.db();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public ForChange user(CurrentUser user) {
    return getUser().equals(user) ? this : forUser(user).asForChange(cd);
}
#method_after
@Override
public ForChange user(CurrentUser user) {
    return getUser().equals(user) ? this : forUser(user).asForChange(cd, db);
}
#end_block

#method_before
@Override
public void check(ChangePermissionOrLabel perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(ChangePermissionOrLabel perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), cd);
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case REMOVE_REVIEWER:
                // TODO Honor specific removal filters?
                return getRefControl().canRemoveReviewer();
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            // TODO Honor specific removal filters?
            case REMOVE_REVIEWER:
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
private boolean can(LabelPermission perm) {
    PermissionRange r = label(perm.permissionName().get());
    return r.getMin() < 0 || r.getMax() > 0;
}
#method_after
private boolean can(LabelPermission perm) {
    return !label(perm.permissionName().get()).isEmpty();
}
#end_block

#method_before
private static <T extends ChangePermissionOrLabel> Set<T> newSet(Collection<T> permSet) {
    if (permSet instanceof EnumSet) {
        @SuppressWarnings({ "unchecked", "rawtypes" })
        Set<T> s = ((EnumSet) permSet).clone();
        s.clear();
        return s;
    }
    return Sets.newHashSetWithExpectedSize(permSet.size());
}
#method_after
static <T extends ChangePermissionOrLabel> Set<T> newSet(Collection<T> permSet) {
    if (permSet instanceof EnumSet) {
        @SuppressWarnings({ "unchecked", "rawtypes" })
        Set<T> s = ((EnumSet) permSet).clone();
        s.clear();
        return s;
    }
    return Sets.newHashSetWithExpectedSize(permSet.size());
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            Set<ChangePermission> can = permissionBackend.user(user).change(c).test(EnumSet.of(ChangePermission.READ, ChangePermission.SUBMIT));
            if (!can.contains(ChangePermission.READ)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!can.contains(ChangePermission.SUBMIT)) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(cd);
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (PermissionBackendException | OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            Set<ChangePermission> can = permissionBackend.user(user).database(dbProvider).change(c).test(EnumSet.of(ChangePermission.READ, ChangePermission.SUBMIT));
            if (!can.contains(ChangePermission.READ)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!can.contains(ChangePermission.SUBMIT)) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (PermissionBackendException | OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    PatchSet.Id current = change.currentPatchSetId();
    String topic = change.getTopic();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    boolean visible;
    try {
        visible = change.getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && !resource.getPatchSet().isDraft() && resource.permissions().test(ChangePermission.SUBMIT);
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (PermissionBackendException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not check submit permission", e);
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    String topic = change.getTopic();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    boolean visible;
    try {
        visible = change.getStatus().isOpen() && resource.isCurrent() && !resource.getPatchSet().isDraft() && resource.permissions().test(ChangePermission.SUBMIT);
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (PermissionBackendException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not check submit permission", e);
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
private IdentifiedUser onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException, PermissionBackendException {
    PermissionBackend.ForChange perm = rsrc.permissions();
    perm.check(ChangePermission.SUBMIT);
    perm.check(ChangePermission.SUBMIT_AS);
    CurrentUser caller = rsrc.getUser();
    IdentifiedUser submitter = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(submitter).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", submitter.getAccountId()));
    }
    return submitter;
}
#method_after
private IdentifiedUser onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException, PermissionBackendException {
    PermissionBackend.ForChange perm = rsrc.permissions().database(dbProvider);
    perm.check(ChangePermission.SUBMIT);
    perm.check(ChangePermission.SUBMIT_AS);
    CurrentUser caller = rsrc.getUser();
    IdentifiedUser submitter = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(submitter).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", submitter.getAccountId()));
    }
    return submitter;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.noOptions().format(out.change);
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    submitPreview.setFormat(format);
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit preview", e);
    }
}
#end_block

#method_before
public boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#method_after
boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#end_block

#method_before
public boolean canEditTopicName() {
    return canPerform(Permission.EDIT_TOPIC_NAME);
}
#method_after
boolean canEditTopicName() {
    return canPerform(Permission.EDIT_TOPIC_NAME);
}
#end_block

#method_before
public boolean canEditHashtags() {
    return canPerform(Permission.EDIT_HASHTAGS);
}
#method_after
boolean canEditHashtags() {
    return canPerform(Permission.EDIT_HASHTAGS);
}
#end_block

#method_before
public boolean canEditAssignee() {
    return canPerform(Permission.EDIT_ASSIGNEE);
}
#method_after
boolean canEditAssignee() {
    return canPerform(Permission.EDIT_ASSIGNEE);
}
#end_block

#method_before
@Override
public ForRef user(CurrentUser user) {
    return forUser(user).asForRef();
}
#method_after
@Override
public ForRef user(CurrentUser user) {
    return forUser(user).asForRef().database(db);
}
#end_block

#method_before
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#method_after
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd, db);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#end_block

#method_before
@Override
public ForChange change(ChangeNotes notes) {
    Change change = notes.getChange();
    checkArgument(getProjectControl().getProject().getNameKey().equals(change.getProject()), "mismatched project");
    return getProjectControl().controlFor(notes).asForChange();
}
#method_after
@Override
public ForChange change(ChangeNotes notes) {
    Change change = notes.getChange();
    checkArgument(getProjectControl().getProject().getNameKey().equals(change.getProject()), "mismatched project");
    return getProjectControl().controlFor(notes).asForChange(null, db);
}
#end_block

#method_before
@Override
public void check(RefPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(RefPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(Permission.CREATE);
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case CREATE_CHANGE:
            return canUpload();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case CREATE_CHANGE:
            return canUpload();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Override
public ForProject project(Project.NameKey project) {
    try {
        ProjectState state = projectCache.checkedGet(project);
        if (state != null) {
            return state.controlFor(user).asForProject();
        }
        return FailedPermissionBackend.project("not found");
    } catch (IOException e) {
        return FailedPermissionBackend.project("unavailable", e);
    }
}
#method_after
@Override
public ForProject project(Project.NameKey project) {
    try {
        ProjectState state = projectCache.checkedGet(project);
        if (state != null) {
            return state.controlFor(user).asForProject().database(db);
        }
        return FailedPermissionBackend.project("not found");
    } catch (IOException e) {
        return FailedPermissionBackend.project("unavailable", e);
    }
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = new ArrayList<>();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append("A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() {
    metrics.claCheckCount.increment();
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = new ArrayList<>();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append("A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
@Override
public ForProject user(CurrentUser user) {
    return forUser(user).asForProject();
}
#method_after
@Override
public ForProject user(CurrentUser user) {
    return forUser(user).asForProject().database(db);
}
#end_block

#method_before
@Override
public ForRef ref(String ref) {
    return controlForRef(ref).asForRef();
}
#method_after
@Override
public ForRef ref(String ref) {
    return controlForRef(ref).asForRef().database(db);
}
#end_block

#method_before
@Override
public void check(ProjectPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(ProjectPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
public WithUser user(Provider<CurrentUser> user) {
    return user(user.get());
}
#method_after
public WithUser user(Provider<CurrentUser> user) {
    return user(checkNotNull(user, "Provider<CurrentUser>").get());
}
#end_block

#method_before
public ForRef ref(Branch.NameKey ref) {
    return project(ref.getParentKey()).ref(ref.get());
}
#method_after
public ForRef ref(Branch.NameKey ref) {
    return project(ref.getParentKey()).ref(ref.get()).database(db);
}
#end_block

#method_before
public ForChange change(ChangeData cd) throws OrmException {
    return ref(cd.change().getDest()).change(cd);
}
#method_after
public ForChange change(ChangeData cd) {
    try {
        return ref(cd.change().getDest()).change(cd);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#end_block

#method_before
public boolean testOrFalse(ChangePermissionOrLabel perm) {
    try {
        return test(perm);
    } catch (PermissionBackendException e) {
        return false;
    }
}
#method_after
public boolean testOrFalse(ChangePermissionOrLabel perm) {
    try {
        return test(perm);
    } catch (PermissionBackendException e) {
        logger.warn("Cannot test " + perm + "; assuming false", e);
        return false;
    }
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#method_after
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return (isAdmin() || (isOwner() && getRefControl().canDeleteOwnChanges()));
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
ForChange asForChange() {
    return new ForChangeImpl(null);
}
#method_after
ForChange asForChange(@Nullable ChangeData cd, @Nullable Provider<ReviewDb> db) {
    return new ForChangeImpl(cd, db);
}
#end_block

#method_before
@Nullable
private ReviewDb db() {
    return cd != null ? cd.db() : null;
}
#method_after
private ReviewDb db() {
    if (db != null) {
        return db.get();
    } else if (cd != null) {
        return cd.db();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public ForChange user(CurrentUser user) {
    return getUser().equals(user) ? this : forUser(user).asForChange(cd);
}
#method_after
@Override
public ForChange user(CurrentUser user) {
    return getUser().equals(user) ? this : forUser(user).asForChange(cd, db);
}
#end_block

#method_before
@Override
public void check(ChangePermissionOrLabel perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(ChangePermissionOrLabel perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), cd);
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case REMOVE_REVIEWER:
                // TODO Honor specific removal filters?
                return getRefControl().canRemoveReviewer();
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return canSubmit();
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return canSubmit();
            case // TODO Honor specific removal filters?
            REMOVE_REVIEWER:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
private boolean can(LabelPermission perm) {
    PermissionRange r = label(perm.permissionName().get());
    return r.getMin() < 0 || r.getMax() > 0;
}
#method_after
private boolean can(LabelPermission perm) {
    return !label(perm.permissionName().get()).isEmpty();
}
#end_block

#method_before
private static <T extends ChangePermissionOrLabel> Set<T> newSet(Collection<T> permSet) {
    if (permSet instanceof EnumSet) {
        @SuppressWarnings({ "unchecked", "rawtypes" })
        Set<T> s = ((EnumSet) permSet).clone();
        s.clear();
        return s;
    }
    return Sets.newHashSetWithExpectedSize(permSet.size());
}
#method_after
static <T extends ChangePermissionOrLabel> Set<T> newSet(Collection<T> permSet) {
    if (permSet instanceof EnumSet) {
        @SuppressWarnings({ "unchecked", "rawtypes" })
        Set<T> s = ((EnumSet) permSet).clone();
        s.clear();
        return s;
    }
    return Sets.newHashSetWithExpectedSize(permSet.size());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new DefaultPermissionBackendModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new DefaultPermissionBackendModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#method_after
boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#end_block

#method_before
@Override
public ForRef user(CurrentUser user) {
    return forUser(user).asForRef();
}
#method_after
@Override
public ForRef user(CurrentUser user) {
    return forUser(user).asForRef().database(db);
}
#end_block

#method_before
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#method_after
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd, db);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#end_block

#method_before
@Override
public ForChange change(ChangeNotes notes) {
    Change change = notes.getChange();
    checkArgument(getProjectControl().getProject().getNameKey().equals(change.getProject()), "mismatched project");
    return getProjectControl().controlFor(notes).asForChange();
}
#method_after
@Override
public ForChange change(ChangeNotes notes) {
    Change change = notes.getChange();
    checkArgument(getProjectControl().getProject().getNameKey().equals(change.getProject()), "mismatched project");
    return getProjectControl().controlFor(notes).asForChange(null, db);
}
#end_block

#method_before
@Override
public void check(RefPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.toString());
    }
}
#method_after
@Override
public void check(RefPermission perm) throws AuthException, PermissionBackendException {
    if (!can(perm)) {
        throw new AuthException(perm.describeForException() + " not permitted");
    }
}
#end_block

#method_before
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(Permission.CREATE);
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case CREATE_CHANGE:
            return canUpload();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case CREATE_CHANGE:
            return canUpload();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Override
public synchronized void stop() {
    if (executor != null) {
        executor.shutdownNow();
    }
    if (daemonAcceptor != null) {
        try {
            daemonAcceptor.close(true).await();
            sshDaemonLog.info("Stopped Gerrit SSHD");
        } catch (IOException e) {
            sshDaemonLog.warn("Exception caught while closing", e);
        } finally {
            daemonAcceptor = null;
        }
    }
}
#method_after
@Override
public synchronized void stop() {
    if (daemonAcceptor != null) {
        try {
            daemonAcceptor.close(true).await();
            shutdownExecutors();
            sshDaemonLog.info("Stopped Gerrit SSHD");
        } catch (IOException e) {
            sshDaemonLog.warn("Exception caught while closing", e);
        } finally {
            daemonAcceptor = null;
        }
    }
}
#end_block

#method_before
public Change.Id cherryPick(Change.Id sourceChangeId, PatchSet.Id sourcePatchId, Branch.NameKey sourceBranch, String sourceChangeTopic, Project.NameKey project, ObjectId sourceCommit, String message, String targetRef, RefControl targetRefControl, int parent) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(targetRef)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    String destinationBranch = RefNames.shortName(targetRef);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(targetRef);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = targetRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = targetRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, targetRefControl.getRefName(), newTopic, sourceBranch, sourceCommit);
                    if (sourceChangeId != null && sourcePatchId != null)
                        bu.addOp(sourceChangeId, new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(@Nullable Change.Id sourceChangeId, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, Project.NameKey project, ObjectId sourceCommit, String message, String targetRef, RefControl targetRefControl, int parent) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(targetRef)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    String destinationBranch = RefNames.shortName(targetRef);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(targetRef);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = targetRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = targetRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, targetRefControl.getRefName(), newTopic, sourceBranch, sourceCommit);
                    if (sourceChangeId != null && sourcePatchId != null) {
                        bu.addOp(sourceChangeId, new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, destinationBranch, cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#end_block

#method_before
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch, ObjectId sourceCommit) {
    StringBuilder stringBuilder = new StringBuilder("Patch Set ").append(patchSetId.get());
    if (sourceBranch != null) {
        stringBuilder.append(": Cherry Picked from branch ").append(sourceBranch.getShortName());
    } else {
        stringBuilder.append(": Cherry Picked from commit ").append(sourceCommit);
    }
    return stringBuilder.append(".").toString();
}
#method_after
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch, ObjectId sourceCommit) {
    StringBuilder stringBuilder = new StringBuilder("Patch Set ").append(patchSetId.get());
    if (sourceBranch != null) {
        stringBuilder.append(": Cherry Picked from branch ").append(sourceBranch.getShortName());
    } else {
        stringBuilder.append(": Cherry Picked from commit ").append(sourceCommit.getName());
    }
    return stringBuilder.append(".").toString();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(PROJECT_KIND, "cherrypickcommit").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ProjectResource rsrc, CherryPickCommitInput input) throws OrmException, IOException, UpdateException, RestApiException {
    checkAndCleanInput(input);
    // TODO(xchangcheng): do we need to check if the commit is visible?
    ProjectControl projectControl = rsrc.getControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    String refName = RefNames.fullName(destination);
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + commit + " to " + input.destination);
    }
    Project.NameKey project = rsrc.getNameKey();
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(null, null, null, null, project, ObjectId.fromString(commit), input.message, refName, refControl, parent);
        return json.noOptions().format(project, cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public ChangeInfo apply(CommitResource rsrc, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    String message = Strings.nullToEmpty(input.message).trim();
    String destination = Strings.nullToEmpty(input.destination).trim();
    int parent = input.parent == null ? 1 : input.parent;
    if (destination.isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    ProjectControl projectControl = rsrc.getProject();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    RevCommit commit = rsrc.getCommit();
    String refName = RefNames.fullName(destination);
    RefControl refControl = projectControl.controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + commit + " to " + destination);
    }
    Project.NameKey project = projectControl.getProject().getNameKey();
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(null, null, null, null, project, commit, message.isEmpty() ? commit.getFullMessage() : message, refName, refControl, parent);
        return json.noOptions().format(project, cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    if (input.showJobsSummaryPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsSummaryPanel", input.showJobsSummaryPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsSummaryPanel");
    }
    if (input.sortJobsPanel != null) {
        cfg.setString("plugin", pluginName, "sortJobsPanel", input.sortJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "sortJobsPanel");
    }
    if (input.sortJobsDropDownPanel != null) {
        cfg.setString("plugin", pluginName, "sortJobsDropDownPanel", input.sortJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "sortJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    if (input.showJobsSummaryPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsSummaryPanel", input.showJobsSummaryPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsSummaryPanel");
    }
    if (input.sortJobsPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsPanel", JobsSorting.valueOf(input.sortJobsPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsPanel");
    }
    if (input.sortJobsDropDownPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsDropDownPanel", JobsSorting.valueOf(input.sortJobsDropDownPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#end_block

#method_before
@Override
public ConfigInfo apply(ConfigResource resource) {
    ConfigInfo info = new ConfigInfo();
    info.showJobsPanel = cfg.getBoolean("showJobsPanel", true);
    info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true);
    info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true);
    info.sortJobsPanel = cfg.getString("sortJobsPanel", "REPORTER");
    info.sortJobsDropDownPanel = cfg.getString("sortJobsDropDownPanel", "REPORTER");
    return info;
}
#method_after
@Override
public ConfigInfo apply(ConfigResource resource) {
    ConfigInfo info = new ConfigInfo();
    info.showJobsPanel = cfg.getBoolean("showJobsPanel", true);
    info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true);
    info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true);
    info.sortJobsPanel = cfg.getEnum(JobsSorting.values(), "sortJobsPanel", JobsSorting.REPORTER);
    info.sortJobsDropDownPanel = cfg.getEnum(JobsSorting.values(), "sortJobsDropDownPanel", JobsSorting.REPORTER);
    return info;
}
#end_block

#method_before
@VisibleForTesting
static List<String> getReviewerByEmailFieldValues(ReviewerByEmailSet reviewersByEmail) {
    List<String> r = new ArrayList<>(reviewersByEmail.asTable().size() * 2);
    for (Table.Cell<ReviewerStateInternal, Address, Timestamp> c : reviewersByEmail.asTable().cellSet()) {
        String v = getReviewerByEmailFieldValue(c.getRowKey(), c.getColumnKey());
        r.add(v);
        r.add(v + ',' + c.getValue().getTime());
    }
    return r;
}
#method_after
@VisibleForTesting
static List<String> getReviewerByEmailFieldValues(ReviewerByEmailSet reviewersByEmail) {
    List<String> r = new ArrayList<>(reviewersByEmail.asTable().size() * 2);
    for (Table.Cell<ReviewerStateInternal, Address, Timestamp> c : reviewersByEmail.asTable().cellSet()) {
        String v = getReviewerByEmailFieldValue(c.getRowKey(), c.getColumnKey());
        r.add(v);
        if (c.getColumnKey().getName() != null) {
            // Add another entry without the name to provide search functionality on the email
            Address emailOnly = new Address(c.getColumnKey().getEmail());
            r.add(getReviewerByEmailFieldValue(c.getRowKey(), emailOnly));
        }
        r.add(v + ',' + c.getValue().getTime());
    }
    return r;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    try {
        reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, Address.parse(who), state);
    } catch (IllegalArgumentException e) {
    // Drop this exception. Consequently don't query for reviewersByEmail
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null)
            throw e;
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    } else {
        return reviewerByEmailPredicate;
    }
}
#method_after
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    }
    return reviewerByEmailPredicate;
}
#end_block

#method_before
@Test
public void reviewerAndCcByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.setEnableReviewerByEmail(true);
    saveProjectConfig(project, cfg);
    String userByEmail = "John Doe <un.registered@reviewer.com>";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    assertQuery("reviewer:\"" + userByEmail + "\"", change1);
    assertQuery("cc:\"" + userByEmail + "\"", change2);
}
#method_after
@Test
public void reviewerAndCcByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.setEnableReviewerByEmail(true);
    saveProjectConfig(project, cfg);
    String userByEmail = "un.registered@reviewer.com";
    String userByEmailWithName = "John Doe <" + userByEmail + ">";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    assertQuery("reviewer:\"" + userByEmailWithName + "\"", change1);
    assertQuery("cc:\"" + userByEmailWithName + "\"", change2);
    // Omitting the name:
    assertQuery("reviewer:\"" + userByEmail + "\"", change1);
    assertQuery("cc:\"" + userByEmail + "\"", change2);
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        for (Map.Entry<ReviewerStateInternal, Map<Address, Timestamp>> e : cd.reviewersByEmail().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfoByEmail(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        for (Map.Entry<ReviewerStateInternal, Map<Address, Timestamp>> e : cd.reviewersByEmail().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfoByEmail(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (ctl.canRemoveReviewer(id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (ctl.canRemoveReviewer(id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void addByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRFCAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        ChangeInfo info = gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
        assertThat(info.reviewers).isEqualTo(ImmutableMap.of(state, ImmutableList.of(acc)));
    }
}
#method_after
@Test
public void addByEmail() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRfcAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        ChangeInfo info = gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
        assertThat(info.reviewers).isEqualTo(ImmutableMap.of(state, ImmutableList.of(acc)));
        // All reviewers added by email should be removable
        assertThat(info.removableReviewers).isEqualTo(ImmutableList.of(acc));
    }
}
#end_block

#method_before
@Test
public void removeByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput addInput = new AddReviewerInput();
        addInput.reviewer = toRFCAddressString(acc);
        addInput.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(addInput);
        DeleteReviewerByEmailInput deleteInput = new DeleteReviewerByEmailInput();
        deleteInput.reviewer = addInput.reviewer;
        gApi.changes().id(r.getChangeId()).deleteReviewerByEmail(deleteInput);
        ChangeInfo info = gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
        assertThat(info.reviewers).isEmpty();
    }
}
#method_after
@Test
public void removeByEmail() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput addInput = new AddReviewerInput();
        addInput.reviewer = toRfcAddressString(acc);
        addInput.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(addInput);
        gApi.changes().id(r.getChangeId()).reviewer(acc.email).remove();
        ChangeInfo info = gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
        assertThat(info.reviewers).isEmpty();
    }
}
#end_block

#method_before
@Test
public void convertFromCCToReviewer() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    PushOneCommit.Result r = createChange();
    AddReviewerInput addInput = new AddReviewerInput();
    addInput.reviewer = toRFCAddressString(acc);
    addInput.state = ReviewerState.CC;
    gApi.changes().id(r.getChangeId()).addReviewer(addInput);
    AddReviewerInput modifyInput = new AddReviewerInput();
    modifyInput.reviewer = addInput.reviewer;
    modifyInput.state = ReviewerState.REVIEWER;
    gApi.changes().id(r.getChangeId()).addReviewer(modifyInput);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    assertThat(info.reviewers).isEqualTo(ImmutableMap.of(ReviewerState.REVIEWER, ImmutableList.of(acc)));
}
#method_after
@Test
public void convertFromCCToReviewer() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    PushOneCommit.Result r = createChange();
    AddReviewerInput addInput = new AddReviewerInput();
    addInput.reviewer = toRfcAddressString(acc);
    addInput.state = ReviewerState.CC;
    gApi.changes().id(r.getChangeId()).addReviewer(addInput);
    AddReviewerInput modifyInput = new AddReviewerInput();
    modifyInput.reviewer = addInput.reviewer;
    modifyInput.state = ReviewerState.REVIEWER;
    gApi.changes().id(r.getChangeId()).addReviewer(modifyInput);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    assertThat(info.reviewers).isEqualTo(ImmutableMap.of(ReviewerState.REVIEWER, ImmutableList.of(acc)));
}
#end_block

#method_before
@Test
public void addedReviewersGetNotified() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRFCAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        List<Message> messages = sender.getMessages();
        assertThat(messages).hasSize(1);
        assertThat(messages.get(0).rcpt()).containsExactly(Address.parse(input.reviewer));
        sender.clear();
    }
}
#method_after
@Test
public void addedReviewersGetNotified() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRfcAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        List<Message> messages = sender.getMessages();
        assertThat(messages).hasSize(1);
        assertThat(messages.get(0).rcpt()).containsExactly(Address.parse(input.reviewer));
        sender.clear();
    }
}
#end_block

#method_before
@Test
public void removingReviewerTriggersNotification() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput addInput = new AddReviewerInput();
        addInput.reviewer = toRFCAddressString(acc);
        addInput.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(addInput);
        // Review change as user
        ReviewInput reviewInput = new ReviewInput();
        reviewInput.message = "I have a comment";
        setApiUser(user);
        revision(r).review(reviewInput);
        setApiUser(admin);
        sender.clear();
        // Delete as admin
        DeleteReviewerByEmailInput deleteReviewerInput = new DeleteReviewerByEmailInput();
        deleteReviewerInput.reviewer = addInput.reviewer;
        gApi.changes().id(r.getChangeId()).deleteReviewerByEmail(deleteReviewerInput);
        List<Message> messages = sender.getMessages();
        assertThat(messages).hasSize(1);
        assertThat(messages.get(0).rcpt()).containsExactly(Address.parse(addInput.reviewer), user.emailAddress);
        sender.clear();
    }
}
#method_after
@Test
public void removingReviewerTriggersNotification() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput addInput = new AddReviewerInput();
        addInput.reviewer = toRfcAddressString(acc);
        addInput.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(addInput);
        // Review change as user
        ReviewInput reviewInput = new ReviewInput();
        reviewInput.message = "I have a comment";
        setApiUser(user);
        revision(r).review(reviewInput);
        setApiUser(admin);
        sender.clear();
        // Delete as admin
        gApi.changes().id(r.getChangeId()).reviewer(addInput.reviewer).remove();
        List<Message> messages = sender.getMessages();
        assertThat(messages).hasSize(1);
        assertThat(messages.get(0).rcpt()).containsExactly(Address.parse(addInput.reviewer), user.emailAddress);
        sender.clear();
    }
}
#end_block

#method_before
@Test
public void reviewerAndCCReceiveRegularNotification() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRFCAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        sender.clear();
        gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
        if (state == ReviewerState.CC) {
            assertNotifyCc(Address.parse(input.reviewer));
        } else {
            assertNotifyTo(Address.parse(input.reviewer));
        }
    }
}
#method_after
@Test
public void reviewerAndCCReceiveRegularNotification() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRfcAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        sender.clear();
        gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
        if (state == ReviewerState.CC) {
            assertNotifyCc(Address.parse(input.reviewer));
        } else {
            assertNotifyTo(Address.parse(input.reviewer));
        }
    }
}
#end_block

#method_before
@Test
public void rejectMissingEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    PushOneCommit.Result r = createChange();
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("email invalid");
    gApi.changes().id(r.getChangeId()).addReviewer("");
}
#method_after
@Test
public void rejectMissingEmail() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("email invalid");
    gApi.changes().id(r.getChangeId()).addReviewer("");
}
#end_block

#method_before
@Test
public void rejectMalformedEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    PushOneCommit.Result r = createChange();
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("email invalid");
    gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@");
}
#method_after
@Test
public void rejectMalformedEmail() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("email invalid");
    gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@");
}
#end_block

#method_before
@Test
public void rejectOnNonPublicChange() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    PushOneCommit.Result r = createDraftChange();
    exception.expect(BadRequestException.class);
    exception.expectMessage("change is not publicly visible");
    gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@gerritcodereview.com>");
}
#method_after
@Test
public void rejectOnNonPublicChange() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createDraftChange();
    exception.expect(BadRequestException.class);
    exception.expectMessage("change is not publicly visible");
    gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@gerritcodereview.com>");
}
#end_block

#method_before
@Test
public void rejectWhenFeatureIsDisabled() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.setEnableReviewerByEmail(false);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Foo Bar <foo.bar@gerritcodereview.com> " + "does not identify a registered user or group");
    gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@gerritcodereview.com>");
}
#method_after
@Test
public void rejectWhenFeatureIsDisabled() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.setEnableReviewerByEmail(false);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Foo Bar <foo.bar@gerritcodereview.com> does not identify a registered user or group");
    gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@gerritcodereview.com>");
}
#end_block

#method_before
@Test
public void reviewersByEmailAreServedFromIndex() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRFCAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        notesMigration.setFailOnLoad(true);
        try {
            ChangeInfo info = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOption(ListChangesOption.DETAILED_LABELS).get());
            assertThat(info.reviewers).isEqualTo(ImmutableMap.of(state, ImmutableList.of(acc)));
        } finally {
            notesMigration.setFailOnLoad(false);
        }
    }
}
#method_after
@Test
public void reviewersByEmailAreServedFromIndex() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    AccountInfo acc = new AccountInfo("Foo Bar", "foo.bar@gerritcodereview.com");
    for (ReviewerState state : ImmutableList.of(ReviewerState.CC, ReviewerState.REVIEWER)) {
        PushOneCommit.Result r = createChange();
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = toRfcAddressString(acc);
        input.state = state;
        gApi.changes().id(r.getChangeId()).addReviewer(input);
        notesMigration.setFailOnLoad(true);
        try {
            ChangeInfo info = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOption(ListChangesOption.DETAILED_LABELS).get());
            assertThat(info.reviewers).isEqualTo(ImmutableMap.of(state, ImmutableList.of(acc)));
        } finally {
            notesMigration.setFailOnLoad(false);
        }
    }
}
#end_block

#method_before
protected static Predicate<ChangeData> create(Arguments args, Predicate<ChangeData> p) {
    if (!args.allowsDrafts) {
        // even doing this?
        return Predicate.and(p, Predicate.not(new ChangeStatusPredicate(Change.Status.DRAFT)));
    }
    return p;
}
#method_after
protected static Predicate<ChangeData> create(Arguments args, Predicate<ChangeData> p) {
    if (!args.allowsDrafts) {
        return Predicate.and(p, Predicate.not(new ChangeStatusPredicate(Change.Status.DRAFT)));
    }
    return p;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, ImmutableSet.of());
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, Set<Address> unregisteredCcs) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, ImmutableSet.copyOf(unregisteredCcs));
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit commit = walk.parseCommit(update.getResult());
        walk.parseBody(commit);
        assertThat(commit.getFullMessage()).endsWith("Hashtags: tag1,tag2\n");
    }
}
#method_after
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit commit = walk.parseCommit(update.getResult());
        walk.parseBody(commit);
        assertThat(commit.getFullMessage()).contains("Hashtags: tag1,tag2\n");
    }
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        // Label names/values are safe to append without sanitizing.
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    // Label names/values are safe to append without sanitizing.
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    if (readOnlyUntil != null) {
        addFooter(msg, FOOTER_READ_ONLY_UNTIL, ChangeNoteUtil.formatTime(serverIdent, readOnlyUntil));
    }
    for (Map.Entry<Address, UnregisteredCcState> e : unregisteredCcs.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey(), e.getKey().toString());
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Map.Entry<Address, ReviewerStateInternal> e : reviewersByEmail.entrySet()) {
        addFooter(msg, e.getValue().getByEmailFooterKey(), e.getKey().toString());
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        // Label names/values are safe to append without sanitizing.
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    // Label names/values are safe to append without sanitizing.
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    if (readOnlyUntil != null) {
        addFooter(msg, FOOTER_READ_ONLY_UNTIL, ChangeNoteUtil.formatTime(serverIdent, readOnlyUntil));
    }
    if (isPrivate != null) {
        addFooter(msg, FOOTER_PRIVATE, isPrivate);
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && unregisteredCcs.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null;
}
#method_after
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && reviewersByEmail.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null && isPrivate == null;
}
#end_block

#method_before
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        pruneUnregisteredCcs();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#method_after
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        pruneReviewersByEmail();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, unregisteredCcs.rowKeySet());
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    for (UnregisteredCcState state : UnregisteredCcState.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseUnregisteredCcs(ts, state, line);
        }
    // Don't update timestamp when an unregistered CC was added, matching what we do for reviewers
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
        for (String line : commit.getFooterLineValues(state.getByEmailFooterKey())) {
            parseReviewerByEmail(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#end_block

#method_before
static void execute(ImmutableList<ReviewDbBatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    setRequestIds(updates, requestId);
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        ChangeIndexer.allAsList(updates.stream().flatMap(u -> u.indexFutures.stream()).collect(toList())).get();
        // Fire ref update events only after all mutations are finished, since callers may assume a
        // patch set ref being created means the change was created, or a branch advancing meaning
        // some changes were closed.
        updates.stream().filter(u -> u.batchRefUpdate != null).forEach(u -> u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getAccount().orElse(null)));
        if (!dryrun) {
            for (ReviewDbBatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (Exception e) {
        handleException(e);
    }
}
#method_after
static void execute(ImmutableList<ReviewDbBatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    setRequestIds(updates, requestId);
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (ReviewDbBatchUpdate u : updates) {
                    u.reindexChanges(u.executeChangeOps(updateChangesInParallel, dryrun));
                }
                listener.afterUpdateChanges();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (ReviewDbBatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterUpdateRefs();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        ChangeIndexer.allAsList(updates.stream().flatMap(u -> u.indexFutures.stream()).collect(toList())).get();
        // Fire ref update events only after all mutations are finished, since callers may assume a
        // patch set ref being created means the change was created, or a branch advancing meaning
        // some changes were closed.
        updates.stream().filter(u -> u.batchRefUpdate != null).forEach(u -> u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getAccount().orElse(null)));
        if (!dryrun) {
            for (ReviewDbBatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (Exception e) {
        wrapAndThrowException(e);
    }
}
#end_block

#method_before
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (JiraRestException | MalformedURLException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#method_after
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#end_block

#method_before
public boolean issueExists(String issueKey) throws JiraRestException {
    boolean ret = true;
    try {
        // This throws an exception if it does not exist: no exception means: issue exists
        doGet("/rest/api/2/issue/" + issueKey, null);
    } catch (JiraRestException e) {
        if (e.getStatusCode().get() == HttpURLConnection.HTTP_NOT_FOUND) {
            log.error("Issue " + issueKey + " not found ");
            ret = false;
        } else if (e.getStatusCode().get() == HttpURLConnection.HTTP_FORBIDDEN) {
            log.error("No permission to read Issue " + issueKey);
            ret = false;
        } else {
            throw e;
        }
    }
    return ret;
}
#method_after
public boolean issueExists(String issueKey) throws IOException {
    JiraRestApi<JiraIssue> api = apiBuilder.getIssue();
    api.doGet("/" + issueKey, HTTP_OK, new int[] { HTTP_NOT_FOUND, HTTP_FORBIDDEN });
    Integer code = api.getResponseCode();
    switch(code) {
        case HTTP_OK:
            return true;
        case HTTP_NOT_FOUND:
            log.error("Issue " + issueKey + " not found ");
            return false;
        case HTTP_FORBIDDEN:
            log.error("No permission to read Issue " + issueKey);
            return false;
        default:
            // Cannot happen due to passCodes filter
            throw new IOException("Unexpected HTTP code received:" + code.toString());
    }
}
#end_block

#method_before
public Iterable<JiraTransition.Item> getTransitions(String issueKey) throws JiraRestException {
    JiraTransition t = (JiraTransition) doGet("/rest/api/2/issue/" + issueKey + "/transitions", new TypeToken<JiraTransition>() {
    }.getType());
    return Arrays.asList(t.transitions);
}
#method_after
public List<JiraTransition.Item> getTransitions(String issueKey) throws IOException {
    JiraRestApi<JiraTransition> api = apiBuilder.get(JiraTransition.class, "/issue");
    return Arrays.asList(api.doGet("/" + issueKey + "/transitions", HTTP_OK).transitions);
}
#end_block

#method_before
public void addComment(String issueKey, String comment) throws JiraRestException {
    if (!issueExists(issueKey)) {
        log.error("Issue {} does not exist or no access permission", issueKey);
        return;
    }
    log.debug("Trying to add comment for issue " + issueKey);
    doPost("/rest/api/2/issue/" + issueKey + "/comment", gson.toJson(new JiraComment(comment)));
    log.debug("Comment added to issue " + issueKey);
}
#method_after
public void addComment(String issueKey, String comment) throws IOException {
    if (issueExists(issueKey)) {
        log.debug("Trying to add comment for issue {}", issueKey);
        apiBuilder.getIssue().doPost("/" + issueKey + "/comment", gson.toJson(new JiraComment(comment)), HTTP_CREATED);
        log.debug("Comment added to issue {}", issueKey);
    } else {
        log.error("Issue {} does not exist or no access permission", issueKey);
    }
}
#end_block

#method_before
public boolean doTransition(String issueKey, String transition) throws JiraRestException, InvalidTransitionException {
    log.debug("Making transition to {} for {}", transition, issueKey);
    JiraTransition.Item t = getTransitionByName(getTransitions(issueKey), transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    log.debug("Transition issue {} to '{}' ({})", issueKey, transition, t.getId());
    doPost("/rest/api/2/issue/" + issueKey + "/transitions", gson.toJson(new JiraTransition(t)));
    return true;
}
#method_after
public boolean doTransition(String issueKey, String transition) throws IOException, InvalidTransitionException {
    log.debug("Making transition to {} for {}", transition, issueKey);
    JiraTransition.Item t = getTransitionByName(issueKey, transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    log.debug("Transition issue {} to '{}' ({})", issueKey, transition, t.getId());
    return apiBuilder.getIssue().doPost("/" + issueKey + "/transitions", gson.toJson(new JiraTransition(t)), HTTP_NO_CONTENT);
}
#end_block

#method_before
public JiraServerInfo sysInfo() throws JiraRestException {
    return (JiraServerInfo) doGet("/rest/api/2/serverInfo", new TypeToken<JiraServerInfo>() {
    }.getType());
}
#method_after
public JiraServerInfo sysInfo() throws IOException {
    return apiBuilder.getServerInfo().doGet("", HTTP_OK);
}
#end_block

#method_before
public Iterable<JiraProject> getProjects() throws JiraRestException {
    return (List<JiraProject>) doGet("/rest/api/2/project", new TypeToken<List<JiraProject>>() {
    }.getType());
}
#method_after
public JiraProject[] getProjects() throws IOException {
    return apiBuilder.getProjects().doGet("", HTTP_OK);
}
#end_block

#method_before
private JiraTransition.Item getTransitionByName(Iterable<JiraTransition.Item> transitions, String transition) {
    JiraTransition.Item ret = null;
    for (JiraTransition.Item t : transitions) {
        if (transition.equals(t.getName())) {
            ret = t;
            break;
        }
    }
    return ret;
}
#method_after
private JiraTransition.Item getTransitionByName(String issueKey, String transition) throws IOException {
    for (JiraTransition.Item t : getTransitions(issueKey)) {
        if (transition.equals(t.getName())) {
            return t;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public String healthCheck(final Check check) throws IOException {
    return execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            if (check.equals(Check.ACCESS))
                return healthCheckAccess();
            else
                return healthCheckSysinfo();
        }
    });
}
#method_after
@Override
public String healthCheck(final Check check) throws IOException {
    return execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            if (check.equals(Check.ACCESS))
                return healthCheckAccess();
            return healthCheckSysinfo();
        }
    });
}
#end_block

#method_before
private void doPerformAction(final String issueKey, final String actionName) throws JiraRestException, InvalidTransitionException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    boolean ret = client().doTransition(issueKey, actionName);
    if (ret) {
        log.debug("Action " + actionName + " successful on Issue " + issueKey);
    } else {
        log.debug("Action {} on Issue {} not possible", actionName, issueKey);
    }
}
#method_after
private void doPerformAction(final String issueKey, final String actionName) throws IOException, InvalidTransitionException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    boolean ret = client().doTransition(issueKey, actionName);
    if (ret) {
        log.debug("Action " + actionName + " successful on Issue " + issueKey);
    } else {
        log.debug("Action {} on Issue {} not possible", actionName, issueKey);
    }
}
#end_block

#method_before
private JiraClient client() throws JiraRestException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (MalformedURLException e) {
            String msg = "Unable to connect to " + getUrl() + " as " + getUsername();
            log.info(msg);
            throw new JiraRestException(msg, e);
        }
    }
    return client;
}
#method_after
private JiraClient client() throws MalformedURLException {
    if (client == null) {
        log.debug("Connecting to jira at {}", getUrl());
        client = new JiraClient(getUrl(), getUsername(), getPassword());
        log.debug("Authenticating as User {}", getUsername());
    }
    return client;
}
#end_block

#method_before
private <P> P execute(Callable<P> function) throws IOException {
    int attempt = 0;
    while (true) {
        try {
            return function.call();
        } catch (Exception ex) {
            if (isRecoverable(ex) && ++attempt < MAX_ATTEMPTS) {
                log.debug("Call failed - retrying, attempt {} of {}", attempt, MAX_ATTEMPTS);
                continue;
            }
            if (ex instanceof IOException)
                throw ((IOException) ex);
            else
                throw new IOException(ex);
        }
    }
}
#method_after
private <P> P execute(Callable<P> function) throws IOException {
    int attempt = 0;
    while (true) {
        try {
            return function.call();
        } catch (Exception ex) {
            if (isRecoverable(ex) && ++attempt < MAX_ATTEMPTS) {
                log.debug("Call failed - retrying, attempt {} of {}", attempt, MAX_ATTEMPTS);
                continue;
            }
            if (ex instanceof IOException)
                throw ((IOException) ex);
            throw new IOException(ex);
        }
    }
}
#end_block

#method_before
private String healthCheckAccess() throws JiraRestException {
    client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#method_after
private String healthCheckAccess() throws IOException {
    client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#end_block

#method_before
private String healthCheckSysinfo() throws JiraRestException {
    JiraServerInfo info = client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"system\"=\"Jira\",\"version\"=\"" + info.getVersion() + "\",\"url\"=\"" + getUrl() + "\",\"build\"=\"" + info.getBuildNumber() + "\"}";
    log.debug("Healtheck on sysinfo result: {}", result);
    return result;
}
#method_after
private String healthCheckSysinfo() throws IOException {
    JiraServerInfo info = client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"system\"=\"Jira\",\"version\"=\"" + info.getVersion() + "\",\"url\"=\"" + getUrl() + "\",\"build\"=\"" + info.getBuildNumber() + "\"}";
    log.debug("Healtheck on sysinfo result: {}", result);
    return result;
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "unknown command type " + cmd.getType() + " prohibited by Gerrit");
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "don't know how to update command type " + cmd.getType());
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd, "create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "ref update access denied");
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
public boolean isEnabledForRef(IdentifiedUser user, Project.NameKey projectName, String refName, String validatorOp) {
    PluginConfig conf = configFactory.get(projectName);
    return conf != null && isValidConfig(conf, projectName) && (activeForRef(conf, refName)) && (activeForProject(conf, projectName.get())) && (!hasCriteria(conf, "skipGroup") || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf, user));
}
#method_after
public boolean isEnabledForRef(IdentifiedUser user, Project.NameKey projectName, String refName, String validatorOp) {
    PluginConfig conf = configFactory.get(projectName);
    return conf != null && isValidConfig(conf, projectName) && (activeForRef(conf, refName)) && (activeForEmail(conf, user.getAccount().getPreferredEmail())) && (activeForProject(conf, projectName.get())) && (!hasCriteria(conf, "skipGroup") || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf, user));
}
#end_block

#method_before
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit foobar with test files.", files);
}
#method_after
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit foobar with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, getPatterns().values(), EMPTY_PLUGIN_CONFIG);
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)", "ERROR: blocked keyword(s) found in: commit message (Line: 1)" + " (found: foobar)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, getPatterns().values(), EMPTY_PLUGIN_CONFIG);
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)", "ERROR: blocked keyword(s) found in: " + Patch.COMMIT_MSG + " (Line: 1) (found: foobar)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
public static AbstractModule module() {
    return new AbstractModule() {

        @Override
        protected void configure() {
            DynamicSet.bind(binder(), CommitValidationListener.class).to(BlockedKeywordValidator.class);
            bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)).toInstance(new ProjectConfigEntry("Blocked Keyword Pattern", null, ProjectConfigEntryType.ARRAY, null, false, "Pushes of commits that contain files with blocked keywords " + "will be rejected."));
        }
    };
}
#method_after
public static AbstractModule module() {
    return new AbstractModule() {

        @Override
        protected void configure() {
            DynamicSet.bind(binder(), CommitValidationListener.class).to(BlockedKeywordValidator.class);
            bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)).toInstance(new ProjectConfigEntry("Blocked Keyword Pattern", null, ProjectConfigEntryType.ARRAY, null, false, "Pushes of commits that contain files or commit messages with " + "blocked keywords will be rejected."));
        }
    };
}
#end_block

#method_before
private static void checkCommitMessageForBlockedKeywords(ImmutableCollection<Pattern> blockedKeywordPatterns, List<CommitValidationMessage> messages, String commitMessage) {
    int line = 0;
    for (String l : commitMessage.split("[\r\n]+")) {
        line++;
        checkLineForBlockedKeywords(blockedKeywordPatterns, messages, "commit message", line, l);
    }
}
#method_after
private static void checkCommitMessageForBlockedKeywords(ImmutableCollection<Pattern> blockedKeywordPatterns, List<CommitValidationMessage> messages, String commitMessage) {
    int line = 0;
    for (String l : commitMessage.split("[\r\n]+")) {
        line++;
        checkLineForBlockedKeywords(blockedKeywordPatterns, messages, Patch.COMMIT_MSG, line, l);
    }
}
#end_block

#method_before
@Test
public void update() throws OrmException, FileNotFoundException, IOException {
    db.create();
    final Path site = Paths.get(UUID.randomUUID().toString());
    final SitePaths paths = new SitePaths(site);
    SchemaUpdater u = Guice.createInjector(new FactoryModule() {

        @Override
        protected void configure() {
            bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
            }).toInstance(db);
            bind(SitePaths.class).toInstance(paths);
            Config cfg = new Config();
            cfg.setString("user", null, "name", "Gerrit Code Review");
            cfg.setString("user", null, "email", "gerrit@localhost");
            // 
            bind(Config.class).annotatedWith(// 
            GerritServerConfig.class).toInstance(cfg);
            // 
            bind(PersonIdent.class).annotatedWith(// 
            GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
            bind(AllProjectsName.class).toInstance(new AllProjectsName("All-Projects"));
            bind(AllUsersName.class).toInstance(new AllUsersName("All-Users"));
            bind(GitRepositoryManager.class).toInstance(new InMemoryRepositoryManager());
            // 
            bind(String.class).annotatedWith(// 
            AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(DataSourceType.class).to(InMemoryH2Type.class);
            install(new ConfigNotesMigration.Module());
        }
    }).getInstance(SchemaUpdater.class);
    for (SchemaVersion s = u.getLatestSchemaVersion(); s.getVersionNbr() > 1; s = s.getPrior()) {
        try {
            assertThat(s.getPrior().getVersionNbr()).named("schema %s has prior version %s. Not true that", s.getVersionNbr(), s.getPrior().getVersionNbr()).isEqualTo(s.getVersionNbr() - 1);
        } catch (ProvisionException e) {
            // version.
            break;
        }
    }
    u.update(new UpdateUI() {

        @Override
        public void message(String msg) {
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return def;
        }

        @Override
        public boolean isBatch() {
            return true;
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> pruneList) throws OrmException {
            for (String sql : pruneList) {
                e.execute(sql);
            }
        }
    });
    db.assertSchemaVersion();
    final SystemConfig sc = db.getSystemConfig();
    assertThat(sc.sitePath).isEqualTo(paths.site_path.toAbsolutePath().toString());
}
#method_after
@Test
public void update() throws OrmException, FileNotFoundException, IOException {
    db.create();
    final Path site = Paths.get(UUID.randomUUID().toString());
    final SitePaths paths = new SitePaths(site);
    SchemaUpdater u = Guice.createInjector(new FactoryModule() {

        @Override
        protected void configure() {
            bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
            }).toInstance(db);
            bind(SitePaths.class).toInstance(paths);
            Config cfg = new Config();
            cfg.setString("user", null, "name", "Gerrit Code Review");
            cfg.setString("user", null, "email", "gerrit@localhost");
            // 
            bind(Config.class).annotatedWith(// 
            GerritServerConfig.class).toInstance(cfg);
            // 
            bind(PersonIdent.class).annotatedWith(// 
            GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
            bind(AllProjectsName.class).toInstance(new AllProjectsName("All-Projects"));
            bind(AllUsersName.class).toInstance(new AllUsersName("All-Users"));
            bind(GitRepositoryManager.class).toInstance(new InMemoryRepositoryManager());
            // 
            bind(String.class).annotatedWith(// 
            AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(DataSourceType.class).to(InMemoryH2Type.class);
            bind(SystemGroupBackend.class);
            install(new ConfigNotesMigration.Module());
        }
    }).getInstance(SchemaUpdater.class);
    for (SchemaVersion s = u.getLatestSchemaVersion(); s.getVersionNbr() > 1; s = s.getPrior()) {
        try {
            assertThat(s.getPrior().getVersionNbr()).named("schema %s has prior version %s. Not true that", s.getVersionNbr(), s.getPrior().getVersionNbr()).isEqualTo(s.getVersionNbr() - 1);
        } catch (ProvisionException e) {
            // version.
            break;
        }
    }
    u.update(new UpdateUI() {

        @Override
        public void message(String msg) {
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return def;
        }

        @Override
        public boolean isBatch() {
            return true;
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> pruneList) throws OrmException {
            for (String sql : pruneList) {
                e.execute(sql);
            }
        }
    });
    db.assertSchemaVersion();
    final SystemConfig sc = db.getSystemConfig();
    assertThat(sc.sitePath).isEqualTo(paths.site_path.toAbsolutePath().toString());
}
#end_block

#method_before
public static ReceiveCommand storeNew(ObjectInserter ins, String name, int val) throws IOException {
    checkArgument(!name.startsWith(Constants.R_REFS), "expected ref suffix, got %s", name);
    ObjectId newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8));
    return new ReceiveCommand(ObjectId.zeroId(), newId, RefNames.REFS_SEQUENCES + name);
}
#method_after
public static ReceiveCommand storeNew(ObjectInserter ins, String name, int val) throws IOException {
    ObjectId newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8));
    return new ReceiveCommand(ObjectId.zeroId(), newId, RefNames.REFS_SEQUENCES + name);
}
#end_block

#method_before
private void initAllProjects(Repository git) throws IOException, ConfigInvalidException {
    BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git, bru)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(MoreObjects.firstNonNull(Strings.emptyToNull(message), "Initialized Gerrit Code Review " + Version.getVersion()));
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Access inherited by all other projects.");
        p.setRequireChangeID(InheritableBoolean.TRUE);
        p.setUseContentMerge(InheritableBoolean.TRUE);
        p.setUseContributorAgreements(InheritableBoolean.FALSE);
        p.setUseSignedOffBy(InheritableBoolean.FALSE);
        p.setEnableSignedPush(InheritableBoolean.FALSE);
        AccessSection cap = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection tags = config.getAccessSection("refs/tags/*", true);
        AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
        AccessSection refsFor = config.getAccessSection("refs/for/*", true);
        AccessSection magic = config.getAccessSection("refs/for/" + AccessSection.ALL, true);
        grant(config, cap, GlobalCapability.ADMINISTRATE_SERVER, admin);
        grant(config, all, Permission.READ, admin, anonymous);
        grant(config, refsFor, Permission.ADD_PATCH_SET, registered);
        if (batch != null) {
            Permission priority = cap.getPermission(GlobalCapability.PRIORITY, true);
            PermissionRule r = rule(config, batch);
            r.setAction(Action.BATCH);
            priority.add(r);
            Permission stream = cap.getPermission(GlobalCapability.STREAM_EVENTS, true);
            stream.add(rule(config, batch));
        }
        LabelType cr = initCodeReviewLabel(config);
        grant(config, heads, cr, -1, 1, registered);
        grant(config, heads, cr, -2, 2, admin, owners);
        grant(config, heads, Permission.CREATE, admin, owners);
        grant(config, heads, Permission.PUSH, admin, owners);
        grant(config, heads, Permission.SUBMIT, admin, owners);
        grant(config, heads, Permission.FORGE_AUTHOR, registered);
        grant(config, heads, Permission.FORGE_COMMITTER, admin, owners);
        grant(config, heads, Permission.EDIT_TOPIC_NAME, true, admin, owners);
        grant(config, tags, Permission.CREATE, admin, owners);
        grant(config, tags, Permission.CREATE_TAG, admin, owners);
        grant(config, tags, Permission.CREATE_SIGNED_TAG, admin, owners);
        grant(config, magic, Permission.PUSH, registered);
        grant(config, magic, Permission.PUSH_MERGE, registered);
        meta.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, meta, Permission.READ, admin, owners);
        grant(config, meta, cr, -2, 2, admin, owners);
        grant(config, meta, Permission.CREATE, admin, owners);
        grant(config, meta, Permission.PUSH, admin, owners);
        grant(config, meta, Permission.SUBMIT, admin, owners);
        config.commitToNewRef(md, RefNames.REFS_CONFIG);
        if (notesMigration.readChangeSequence() && git.exactRef(REFS_SEQUENCES + Sequences.CHANGES) == null) {
            try (ObjectInserter ins = git.newObjectInserter()) {
                bru.addCommand(RepoSequence.storeNew(ins, Sequences.CHANGES, ReviewDb.FIRST_CHANGE_ID));
                ins.flush();
            }
        }
        try (RevWalk rw = new RevWalk(git)) {
            bru.execute(rw, NullProgressMonitor.INSTANCE);
        }
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException("Failed to initialize All-Users refs:\n" + bru);
            }
        }
    }
}
#method_after
private void initAllProjects(Repository git) throws IOException, ConfigInvalidException {
    BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git, bru)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(MoreObjects.firstNonNull(Strings.emptyToNull(message), "Initialized Gerrit Code Review " + Version.getVersion()));
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Access inherited by all other projects.");
        p.setRequireChangeID(InheritableBoolean.TRUE);
        p.setUseContentMerge(InheritableBoolean.TRUE);
        p.setUseContributorAgreements(InheritableBoolean.FALSE);
        p.setUseSignedOffBy(InheritableBoolean.FALSE);
        p.setEnableSignedPush(InheritableBoolean.FALSE);
        AccessSection cap = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection tags = config.getAccessSection("refs/tags/*", true);
        AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
        AccessSection refsFor = config.getAccessSection("refs/for/*", true);
        AccessSection magic = config.getAccessSection("refs/for/" + AccessSection.ALL, true);
        grant(config, cap, GlobalCapability.ADMINISTRATE_SERVER, admin);
        grant(config, all, Permission.READ, admin, anonymous);
        grant(config, refsFor, Permission.ADD_PATCH_SET, registered);
        if (batch != null) {
            Permission priority = cap.getPermission(GlobalCapability.PRIORITY, true);
            PermissionRule r = rule(config, batch);
            r.setAction(Action.BATCH);
            priority.add(r);
            Permission stream = cap.getPermission(GlobalCapability.STREAM_EVENTS, true);
            stream.add(rule(config, batch));
        }
        LabelType cr = initCodeReviewLabel(config);
        grant(config, heads, cr, -1, 1, registered);
        grant(config, heads, cr, -2, 2, admin, owners);
        grant(config, heads, Permission.CREATE, admin, owners);
        grant(config, heads, Permission.PUSH, admin, owners);
        grant(config, heads, Permission.SUBMIT, admin, owners);
        grant(config, heads, Permission.FORGE_AUTHOR, registered);
        grant(config, heads, Permission.FORGE_COMMITTER, admin, owners);
        grant(config, heads, Permission.EDIT_TOPIC_NAME, true, admin, owners);
        grant(config, tags, Permission.CREATE, admin, owners);
        grant(config, tags, Permission.CREATE_TAG, admin, owners);
        grant(config, tags, Permission.CREATE_SIGNED_TAG, admin, owners);
        grant(config, magic, Permission.PUSH, registered);
        grant(config, magic, Permission.PUSH_MERGE, registered);
        meta.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, meta, Permission.READ, admin, owners);
        grant(config, meta, cr, -2, 2, admin, owners);
        grant(config, meta, Permission.CREATE, admin, owners);
        grant(config, meta, Permission.PUSH, admin, owners);
        grant(config, meta, Permission.SUBMIT, admin, owners);
        config.commitToNewRef(md, RefNames.REFS_CONFIG);
        initSequences(git, bru);
        execute(git, bru);
    }
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(db, key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(to);
            }
        }
        return new AuthResult(to, key, false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(db, key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
            }
            byIdCache.evict(to);
        }
        return new AuthResult(to, key, false);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
        }
        AuthResult link = link(to, who);
        byIdCache.evict(to);
        return link;
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
private String toDoc(V v) throws IOException {
    XContentBuilder builder = jsonBuilder().startObject();
    for (Values<V> values : schema.buildFields(v, fillArgs)) {
        String name = values.getField().getName();
        if (values.getField().isRepeatable()) {
            builder.field(name, arrayElements(values.getValues()));
        } else {
            Object element = Iterables.getOnlyElement(values.getValues(), "");
            if (!(element instanceof String) || !((String) element).isEmpty()) {
                builder.field(name, element);
            }
        }
    }
    return builder.endObject().string();
}
#method_after
private String toDoc(V v) throws IOException {
    XContentBuilder builder = jsonBuilder().startObject();
    for (Values<V> values : schema.buildFields(v, fillArgs)) {
        String name = values.getField().getName();
        if (values.getField().isRepeatable()) {
            builder.field(name, Streams.stream(values.getValues()).filter(e -> shouldAddElement(e)).collect(toList()));
        } else {
            Object element = Iterables.getOnlyElement(values.getValues(), "");
            if (shouldAddElement(element)) {
                builder.field(name, element);
            }
        }
    }
    return builder.endObject().string();
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        final boolean inheritChannel = cfg.getBoolean("httpd", "inheritChannel", false);
        c.setInheritChannel(inheritChannel);
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false));
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessage(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#method_after
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessageThat().isEqualTo(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#end_block

#method_before
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessage(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#method_after
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessageThat().isEqualTo(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#end_block

#method_before
private static Iterable<String> getLabels(ChangeData input, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : input.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && input.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#method_after
private static Iterable<String> getLabels(ChangeData cd, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : cd.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && cd.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#end_block

#method_before
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getAuthor());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getAuthor());
}
#end_block

#method_before
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getCommitter());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getCommitter());
}
#end_block

#method_before
private static String getTopic(ChangeData input) throws OrmException {
    Change c = input.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#method_after
private static String getTopic(ChangeData cd) throws OrmException {
    Change c = cd.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#end_block

#method_before
public Builder<I, T> stored() {
    this.stored = true;
    return this;
}
#method_after
public Builder<T> stored() {
    this.stored = true;
    return this;
}
#end_block

#method_before
public FieldDef<I, T> build(Getter<I, T> getter) {
    return new FieldDef<I, T>(name, type, stored) {

        @Override
        public T get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return false;
        }
    };
}
#method_after
public <I> FieldDef<I, T> build(Getter<I, T> getter) {
    return build((in, a) -> getter.get(in));
}
#end_block

#method_before
public FieldDef<I, T> build(Getter<I, T> getter) {
    return new FieldDef<I, T>(name, type, stored) {

        @Override
        public T get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return false;
        }
    };
}
#method_after
public <I> FieldDef<I, T> build(GetterWithArgs<I, T> getter) {
    return new FieldDef<>(name, type, stored, false, getter);
}
#end_block

#method_before
public FieldDef<I, Iterable<T>> buildRepeatable(Getter<I, Iterable<T>> getter) {
    return new FieldDef<I, Iterable<T>>(name, type, stored) {

        @Override
        public Iterable<T> get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return true;
        }
    };
}
#method_after
public <I> FieldDef<I, Iterable<T>> buildRepeatable(Getter<I, Iterable<T>> getter) {
    return buildRepeatable((in, a) -> getter.get(in));
}
#end_block

#method_before
public FieldDef<I, Iterable<T>> buildRepeatable(Getter<I, Iterable<T>> getter) {
    return new FieldDef<I, Iterable<T>>(name, type, stored) {

        @Override
        public Iterable<T> get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return true;
        }
    };
}
#method_after
public <I> FieldDef<I, Iterable<T>> buildRepeatable(GetterWithArgs<I, Iterable<T>> getter) {
    return new FieldDef<>(name, type, stored, true, getter);
}
#end_block

#method_before
private static String checkName(String name) {
    CharMatcher m = CharMatcher.anyOf("abcdefghijklmnopqrstuvwxyz0123456789_");
    checkArgument(m.matchesAllOf(name), "illegal field name: %s", name);
    return name;
}
#method_after
private static String checkName(String name) {
    CharMatcher m = CharMatcher.anyOf("abcdefghijklmnopqrstuvwxyz0123456789_");
    checkArgument(name != null && m.matchesAllOf(name), "illegal field name: %s", name);
    return name;
}
#end_block

#method_before
public final String getName() {
    return name;
}
#method_after
public String getName() {
    return name;
}
#end_block

#method_before
public final FieldType<?> getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return type;
}
#end_block

#method_before
public final boolean isStored() {
    return stored;
}
#method_after
public boolean isStored() {
    return stored;
}
#end_block

#method_before
@Test
public void byDefault() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    RevCommit commit2 = repo.parseBody(repo.commit().message("foosubject").create());
    Change change2 = insert(repo, newChangeForCommit(repo, commit2));
    RevCommit commit3 = repo.parseBody(repo.commit().add("Foo.java", "foo contents").create());
    Change change3 = insert(repo, newChangeForCommit(repo, commit3));
    ChangeInserter ins4 = newChange(repo);
    Change change4 = insert(repo, ins4);
    ReviewInput ri4 = new ReviewInput();
    ri4.message = "toplevel";
    ri4.labels = ImmutableMap.<String, Short>of("Code-Review", (short) 1);
    gApi.changes().id(change4.getId().get()).current().review(ri4);
    ChangeInserter ins5 = newChangeWithTopic(repo, "feature5");
    Change change5 = insert(repo, ins5);
    Change change6 = insert(repo, newChangeForBranch(repo, "branch6"));
    // This query will also get change2 as the id of commit2 starts with '1'.
    assertQuery(change1.getId().get(), change2, change1);
    assertQuery(ChangeTriplet.format(change1), change1);
    assertQuery("foosubject", change2);
    assertQuery("Foo.java", change3);
    assertQuery("Code-Review+1", change4);
    assertQuery("toplevel", change4);
    assertQuery("feature5", change5);
    assertQuery("branch6", change6);
    assertQuery("refs/heads/branch6", change6);
    Change[] expected = new Change[] { change6, change5, change4, change3, change2, change1 };
    assertQuery("user@example.com", expected);
    assertQuery("repo", expected);
}
#method_after
@Test
public void byDefault() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    RevCommit commit2 = repo.parseBody(repo.commit().message("foosubject").create());
    Change change2 = insert(repo, newChangeForCommit(repo, commit2));
    RevCommit commit3 = repo.parseBody(repo.commit().add("Foo.java", "foo contents").create());
    Change change3 = insert(repo, newChangeForCommit(repo, commit3));
    ChangeInserter ins4 = newChange(repo);
    Change change4 = insert(repo, ins4);
    ReviewInput ri4 = new ReviewInput();
    ri4.message = "toplevel";
    ri4.labels = ImmutableMap.<String, Short>of("Code-Review", (short) 1);
    gApi.changes().id(change4.getId().get()).current().review(ri4);
    ChangeInserter ins5 = newChangeWithTopic(repo, "feature5");
    Change change5 = insert(repo, ins5);
    Change change6 = insert(repo, newChangeForBranch(repo, "branch6"));
    assertQuery(change1.getId().get(), change1);
    assertQuery(ChangeTriplet.format(change1), change1);
    assertQuery("foosubject", change2);
    assertQuery("Foo.java", change3);
    assertQuery("Code-Review+1", change4);
    assertQuery("toplevel", change4);
    assertQuery("feature5", change5);
    assertQuery("branch6", change6);
    assertQuery("refs/heads/branch6", change6);
    Change[] expected = new Change[] { change6, change5, change4, change3, change2, change1 };
    assertQuery("user@example.com", expected);
    assertQuery("repo", expected);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (PAT_LEGACY_ID.matcher(query).matches()) {
            try {
                predicates.add(commit(query));
            } catch (IllegalArgumentException e) {
            // Skip.
            }
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
@Test
public void watchProjectNoNotificationForIgnoredChange() throws Exception {
    // watch project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, null);
    // push a change to watched project
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "ignored change", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // ignore the change
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(IGNORE_LABEL)));
    sender.clear();
    // post a comment -> should not trigger email notification since user ignored the change
    setApiUser(admin);
    ReviewInput in = new ReviewInput();
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // assert email notification
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void watchProjectNoNotificationForIgnoredChange() throws Exception {
    // watch project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, null);
    // push a change to watched project
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "ignored change", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // ignore the change
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(IGNORE_LABEL)));
    sender.clear();
    // post a comment -> should not trigger email notification since user ignored the change
    setApiUser(admin);
    ReviewInput in = new ReviewInput();
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).current().review(in);
    // assert email notification
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    String url = "http://localhost:" + wireMockRule.port();
    Configuration cfg = mock(Configuration.class);
    when(cfg.getUser()).thenReturn("user");
    when(cfg.getPassword()).thenReturn("pass");
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(cfg.getConnectionTimeout()).thenReturn(TIMEOUT);
    when(cfg.getSocketTimeout()).thenReturn(TIMEOUT);
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    PeerInfo peerInfo = mock(PeerInfo.class);
    when(peerInfo.getDirectUrl()).thenReturn(url);
    httpSession = new HttpSession(new HttpClientProvider(cfg, peerInfo).get(), url);
    wireMockRule.resetRequests();
}
#method_after
@Before
public void setUp() throws Exception {
    String url = "http://localhost:" + wireMockRule.port();
    Configuration cfg = mock(Configuration.class);
    when(cfg.getUser()).thenReturn("user");
    when(cfg.getPassword()).thenReturn("pass");
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(cfg.getConnectionTimeout()).thenReturn(TIMEOUT);
    when(cfg.getSocketTimeout()).thenReturn(TIMEOUT);
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    PeerInfo peerInfo = mock(PeerInfo.class);
    when(peerInfo.getDirectUrl()).thenReturn(url);
    httpSession = new HttpSession(new HttpClientProvider(cfg).get(), peerInfo);
    wireMockRule.resetRequests();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    when(config.getUser()).thenReturn(EMPTY);
    when(config.getPassword()).thenReturn(EMPTY);
    when(config.getConnectionTimeout()).thenReturn(TIME_INTERVAL);
    when(config.getSocketTimeout()).thenReturn(TIME_INTERVAL);
    when(peerInfo.getDirectUrl()).thenReturn(EMPTY);
}
#method_after
@Before
public void setUp() throws Exception {
    when(config.getUser()).thenReturn(EMPTY);
    when(config.getPassword()).thenReturn(EMPTY);
    when(config.getConnectionTimeout()).thenReturn(TIME_INTERVAL);
    when(config.getSocketTimeout()).thenReturn(TIME_INTERVAL);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Configuration.class).toInstance(config);
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    bind(PeerInfo.class).toInstance(peerInfo);
}
#method_after
@Override
protected void configure() {
    bind(Configuration.class).toInstance(config);
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
public ChangeJson create(ListChangesOption... options) {
    return create(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#method_after
public ChangeJson create(ListChangesOption first, ListChangesOption... rest) {
    return create(Sets.immutableEnumSet(first, rest));
}
#end_block

#method_before
private void evictCache(Cache<?, ?> cache, String cacheName, Object key) {
    if (CacheContants.PROJECT_LIST.equals(cacheName)) {
        // One key is holding the list of projects
        cache.invalidateAll();
    } else {
        cache.invalidate(key);
    }
    logger.debug("Invalidated " + cacheName);
}
#method_after
private void evictCache(Cache<?, ?> cache, String cacheName, Object key) {
    if (Constants.PROJECT_LIST.equals(cacheName)) {
        // One key is holding the list of projects
        cache.invalidateAll();
    } else {
        cache.invalidate(key);
    }
    logger.debug("Invalidated " + cacheName);
}
#end_block

#method_before
@Test
public void AccountIDParse() {
    Account.Id accountId = new Account.Id(1);
    String json = GsonParser.toJson(CacheContants.ACCOUNTS, accountId);
    assertThat(accountId).isEqualTo(GsonParser.fromJson(CacheContants.ACCOUNTS, json));
}
#method_after
@Test
public void AccountIDParse() {
    Account.Id accountId = new Account.Id(1);
    String json = GsonParser.toJson(Constants.ACCOUNTS, accountId);
    assertThat(accountId).isEqualTo(GsonParser.fromJson(Constants.ACCOUNTS, json));
}
#end_block

#method_before
@Test
public void AccountGroupIDParse() {
    AccountGroup.Id accountGroupId = new AccountGroup.Id(1);
    String json = GsonParser.toJson(CacheContants.GROUPS, accountGroupId);
    assertThat(accountGroupId).isEqualTo(GsonParser.fromJson(CacheContants.GROUPS, json));
}
#method_after
@Test
public void AccountGroupIDParse() {
    AccountGroup.Id accountGroupId = new AccountGroup.Id(1);
    String json = GsonParser.toJson(Constants.GROUPS, accountGroupId);
    assertThat(accountGroupId).isEqualTo(GsonParser.fromJson(Constants.GROUPS, json));
}
#end_block

#method_before
@Test
public void AccountGroupUUIDParse() {
    AccountGroup.UUID accountGroupUuid = new AccountGroup.UUID("abc123");
    String json = GsonParser.toJson(CacheContants.GROUPS_BYINCLUDE, accountGroupUuid);
    assertThat(accountGroupUuid).isEqualTo(GsonParser.fromJson(CacheContants.GROUPS_BYINCLUDE, json));
}
#method_after
@Test
public void AccountGroupUUIDParse() {
    AccountGroup.UUID accountGroupUuid = new AccountGroup.UUID("abc123");
    String json = GsonParser.toJson(Constants.GROUPS_BYINCLUDE, accountGroupUuid);
    assertThat(accountGroupUuid).isEqualTo(GsonParser.fromJson(Constants.GROUPS_BYINCLUDE, json));
}
#end_block

#method_before
@Test
public void StringParse() {
    String key = "key";
    String json = GsonParser.toJson(CacheContants.PROJECTS, key);
    assertThat(key).isEqualTo(GsonParser.fromJson(CacheContants.PROJECTS, json));
}
#method_after
@Test
public void StringParse() {
    String key = "key";
    String json = GsonParser.toJson(Constants.PROJECTS, key);
    assertThat(key).isEqualTo(GsonParser.fromJson(Constants.PROJECTS, json));
}
#end_block

#method_before
@Test
public void NoKeyParse() {
    Object object = new Object();
    String json = GsonParser.toJson(CacheContants.PROJECT_LIST, object);
    assertThat(json).isEqualTo(EMPTY_JSON);
}
#method_after
@Test
public void NoKeyParse() {
    Object object = new Object();
    String json = GsonParser.toJson(Constants.PROJECT_LIST, object);
    assertThat(json).isEqualTo(EMPTY_JSON);
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "plugin.high-availability.url", value = "http://localhost:18888"), @GerritConfig(name = "plugin.high-availability.user", value = "admin") })
public void flushAndSendPost() throws Exception {
    final String flushRequest = "/plugins/high-availability/cache/" + CacheContants.PROJECT_LIST;
    wireMockRule.addMockServiceRequestListener(new RequestListener() {

        @Override
        public void requestReceived(Request request, Response response) {
            if (request.getAbsoluteUrl().contains(flushRequest)) {
                synchronized (flushRequest) {
                    flushRequest.notify();
                }
            }
        }
    });
    givenThat(post(urlEqualTo(flushRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_OK)));
    adminSshSession.exec("gerrit flush-caches --cache " + CacheContants.PROJECT_LIST);
    synchronized (flushRequest) {
        flushRequest.wait(TimeUnit.SECONDS.toMillis(5));
    }
    verify(postRequestedFor(urlEqualTo(flushRequest)));
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "plugin.high-availability.url", value = "http://localhost:18888"), @GerritConfig(name = "plugin.high-availability.user", value = "admin") })
public void flushAndSendPost() throws Exception {
    final String flushRequest = "/plugins/high-availability/cache/" + Constants.PROJECT_LIST;
    wireMockRule.addMockServiceRequestListener(new RequestListener() {

        @Override
        public void requestReceived(Request request, Response response) {
            if (request.getAbsoluteUrl().contains(flushRequest)) {
                synchronized (flushRequest) {
                    flushRequest.notify();
                }
            }
        }
    });
    givenThat(post(urlEqualTo(flushRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_OK)));
    adminSshSession.exec("gerrit flush-caches --cache " + Constants.PROJECT_LIST);
    synchronized (flushRequest) {
        flushRequest.wait(TimeUnit.SECONDS.toMillis(5));
    }
    verify(postRequestedFor(urlEqualTo(flushRequest)));
}
#end_block

#method_before
@Test
public void evictAccounts() throws Exception {
    configureMocksFor(CacheContants.ACCOUNTS);
    verifyResponseIsOK();
}
#method_after
@Test
public void evictAccounts() throws Exception {
    configureMocksFor(Constants.ACCOUNTS);
    verifyResponseIsOK();
}
#end_block

#method_before
@Test
public void evictProjectList() throws Exception {
    configureMocksFor(CacheContants.PROJECT_LIST);
    verifyResponseIsOK();
}
#method_after
@Test
public void evictProjectList() throws Exception {
    configureMocksFor(Constants.PROJECT_LIST);
    verifyResponseIsOK();
}
#end_block

#method_before
@Test
public void evictGroups() throws Exception {
    configureMocksFor(CacheContants.GROUPS);
    verifyResponseIsOK();
}
#method_after
@Test
public void evictGroups() throws Exception {
    configureMocksFor(Constants.GROUPS);
    verifyResponseIsOK();
}
#end_block

#method_before
@Test
public void evictGroupsByInclude() throws Exception {
    configureMocksFor(CacheContants.GROUPS_BYINCLUDE);
    verifyResponseIsOK();
}
#method_after
@Test
public void evictGroupsByInclude() throws Exception {
    configureMocksFor(Constants.GROUPS_BYINCLUDE);
    verifyResponseIsOK();
}
#end_block

#method_before
@Test
public void evictGroupsMembers() throws Exception {
    configureMocksFor(CacheContants.GROUPS_MEMBERS);
    servlet.doPost(request, response);
}
#method_after
@Test
public void evictGroupsMembers() throws Exception {
    configureMocksFor(Constants.GROUPS_MEMBERS);
    servlet.doPost(request, response);
}
#end_block

#method_before
@Test
public void evictDefault() throws Exception {
    configureMocksFor(CacheContants.PROJECTS);
    verifyResponseIsOK();
}
#method_after
@Test
public void evictDefault() throws Exception {
    configureMocksFor(Constants.PROJECTS);
    verifyResponseIsOK();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void configureMocksFor(String cacheName) throws IOException {
    when(cacheMap.get("gerrit", cacheName)).thenReturn(mock(Cache.class));
    when(request.getPathInfo()).thenReturn("/" + cacheName);
    when(request.getReader()).thenReturn(reader);
    if (CacheContants.PROJECTS.equals(cacheName)) {
        when(reader.readLine()).thenReturn("abc");
    } else if (CacheContants.GROUPS_BYINCLUDE.equals(cacheName) || CacheContants.GROUPS_MEMBERS.equals(cacheName)) {
        when(reader.readLine()).thenReturn("{\"uuid\":\"abcd1234\"}");
    } else {
        when(reader.readLine()).thenReturn("{}");
    }
}
#method_after
@SuppressWarnings("unchecked")
private void configureMocksFor(String cacheName) throws IOException {
    when(cacheMap.get("gerrit", cacheName)).thenReturn(mock(Cache.class));
    when(request.getPathInfo()).thenReturn("/" + cacheName);
    when(request.getReader()).thenReturn(reader);
    if (Constants.PROJECTS.equals(cacheName)) {
        when(reader.readLine()).thenReturn("abc");
    } else if (Constants.GROUPS_BYINCLUDE.equals(cacheName) || Constants.GROUPS_MEMBERS.equals(cacheName)) {
        when(reader.readLine()).thenReturn("{\"uuid\":\"abcd1234\"}");
    } else {
        when(reader.readLine()).thenReturn("{}");
    }
}
#end_block

#method_before
static Object fromJson(String cacheName, String json) {
    Gson gson = new GsonBuilder().create();
    Object key;
    // Need to add a case for 'adv_bases'
    switch(cacheName) {
        case CacheContants.ACCOUNTS:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), Account.Id.class);
            break;
        case CacheContants.GROUPS:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), AccountGroup.Id.class);
            break;
        case CacheContants.GROUPS_BYINCLUDE:
        case CacheContants.GROUPS_MEMBERS:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), AccountGroup.UUID.class);
            break;
        case CacheContants.PROJECT_LIST:
            key = gson.fromJson(Strings.nullToEmpty(json), Object.class);
            break;
        default:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), String.class);
    }
    return key;
}
#method_after
static Object fromJson(String cacheName, String json) {
    Gson gson = new GsonBuilder().create();
    Object key;
    // Need to add a case for 'adv_bases'
    switch(cacheName) {
        case Constants.ACCOUNTS:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), Account.Id.class);
            break;
        case Constants.GROUPS:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), AccountGroup.Id.class);
            break;
        case Constants.GROUPS_BYINCLUDE:
        case Constants.GROUPS_MEMBERS:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), AccountGroup.UUID.class);
            break;
        case Constants.PROJECT_LIST:
            key = gson.fromJson(Strings.nullToEmpty(json), Object.class);
            break;
        default:
            key = gson.fromJson(Strings.nullToEmpty(json).trim(), String.class);
    }
    return key;
}
#end_block

#method_before
static String toJson(String cacheName, Object key) {
    Gson gson = new GsonBuilder().create();
    String json;
    // Need to add a case for 'adv_bases'
    switch(cacheName) {
        case CacheContants.ACCOUNTS:
            json = gson.toJson(key, Account.Id.class);
            break;
        case CacheContants.GROUPS:
            json = gson.toJson(key, AccountGroup.Id.class);
            break;
        case CacheContants.GROUPS_BYINCLUDE:
        case CacheContants.GROUPS_MEMBERS:
            json = gson.toJson(key, AccountGroup.UUID.class);
            break;
        case CacheContants.PROJECT_LIST:
        default:
            json = gson.toJson(key);
    }
    return json;
}
#method_after
static String toJson(String cacheName, Object key) {
    Gson gson = new GsonBuilder().create();
    String json;
    // Need to add a case for 'adv_bases'
    switch(cacheName) {
        case Constants.ACCOUNTS:
            json = gson.toJson(key, Account.Id.class);
            break;
        case Constants.GROUPS:
            json = gson.toJson(key, AccountGroup.Id.class);
            break;
        case Constants.GROUPS_BYINCLUDE:
        case Constants.GROUPS_MEMBERS:
            json = gson.toJson(key, AccountGroup.UUID.class);
            break;
        case Constants.PROJECT_LIST:
        default:
            json = gson.toJson(key);
    }
    return json;
}
#end_block

#method_before
@Test
public void testEvictCacheOK() throws Exception {
    setupMocksForCache(CacheContants.PROJECTS, EMPTY_JSON2, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.PROJECTS, EMPTY_JSON)).isTrue();
}
#method_after
@Test
public void testEvictCacheOK() throws Exception {
    setupMocksForCache(Constants.PROJECTS, EMPTY_JSON2, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.PROJECTS, EMPTY_JSON)).isTrue();
}
#end_block

#method_before
@Test
public void testEvictAccountsOK() throws Exception {
    setupMocksForCache(CacheContants.ACCOUNTS, ID_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.ACCOUNTS, mock(Account.Id.class))).isTrue();
}
#method_after
@Test
public void testEvictAccountsOK() throws Exception {
    setupMocksForCache(Constants.ACCOUNTS, ID_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.ACCOUNTS, mock(Account.Id.class))).isTrue();
}
#end_block

#method_before
@Test
public void testEvictGroupsOK() throws Exception {
    setupMocksForCache(CacheContants.GROUPS, ID_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.GROUPS, mock(AccountGroup.Id.class))).isTrue();
}
#method_after
@Test
public void testEvictGroupsOK() throws Exception {
    setupMocksForCache(Constants.GROUPS, ID_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.GROUPS, mock(AccountGroup.Id.class))).isTrue();
}
#end_block

#method_before
@Test
public void testEvictGroupsByIncludeOK() throws Exception {
    setupMocksForCache(CacheContants.GROUPS_BYINCLUDE, EMPTY_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.GROUPS_BYINCLUDE, mock(AccountGroup.UUID.class))).isTrue();
}
#method_after
@Test
public void testEvictGroupsByIncludeOK() throws Exception {
    setupMocksForCache(Constants.GROUPS_BYINCLUDE, EMPTY_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.GROUPS_BYINCLUDE, mock(AccountGroup.UUID.class))).isTrue();
}
#end_block

#method_before
@Test
public void testEvictGroupsMembersOK() throws Exception {
    setupMocksForCache(CacheContants.GROUPS_MEMBERS, EMPTY_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.GROUPS_MEMBERS, mock(AccountGroup.UUID.class))).isTrue();
}
#method_after
@Test
public void testEvictGroupsMembersOK() throws Exception {
    setupMocksForCache(Constants.GROUPS_MEMBERS, EMPTY_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.GROUPS_MEMBERS, mock(AccountGroup.UUID.class))).isTrue();
}
#end_block

#method_before
@Test
public void testEvictProjectListOK() throws Exception {
    setupMocksForCache(CacheContants.PROJECT_LIST, EMPTY_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.PROJECT_LIST, new Object())).isTrue();
}
#method_after
@Test
public void testEvictProjectListOK() throws Exception {
    setupMocksForCache(Constants.PROJECT_LIST, EMPTY_JSON, SUCCESSFUL, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.PROJECT_LIST, new Object())).isTrue();
}
#end_block

#method_before
@Test
public void testEvictCacheFailed() throws Exception {
    setupMocksForCache(CacheContants.PROJECTS, EMPTY_JSON2, FAILED, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.PROJECTS, EMPTY_JSON)).isFalse();
}
#method_after
@Test
public void testEvictCacheFailed() throws Exception {
    setupMocksForCache(Constants.PROJECTS, EMPTY_JSON2, FAILED, DO_NOT_THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.PROJECTS, EMPTY_JSON)).isFalse();
}
#end_block

#method_before
@Test
public void testEvictCacheThrowsException() throws Exception {
    setupMocksForCache(CacheContants.PROJECTS, EMPTY_JSON2, FAILED, THROW_EXCEPTION);
    assertThat(restForwarder.evict(CacheContants.PROJECTS, EMPTY_JSON)).isFalse();
}
#method_after
@Test
public void testEvictCacheThrowsException() throws Exception {
    setupMocksForCache(Constants.PROJECTS, EMPTY_JSON2, FAILED, THROW_EXCEPTION);
    assertThat(restForwarder.evict(Constants.PROJECTS, EMPTY_JSON)).isFalse();
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to index")
void addChange(String token) {
    try {
        changeArgumentParser.addChange(token, changes, null, false);
    } catch (UnloggedFailure e) {
        if (continueOnFailures) {
            writeError("warning", e.getMessage());
        } else {
            throw new IllegalArgumentException(e.getMessage(), e);
        }
    } catch (OrmException e) {
        throw new IllegalArgumentException("database is down", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to index")
void addChange(String token) {
    try {
        changeArgumentParser.addChange(token, changes, null, false);
    } catch (UnloggedFailure e) {
        writeError("warning", e.getMessage());
    } catch (OrmException e) {
        throw new IllegalArgumentException("database is down", e);
    }
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    Set<Address> smtpRcptToPlaintextOnly = new HashSet<>();
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // In addition, check if users only want to receive plaintext email.
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                } else if (useHtml() && prefs.getEmailFormat() == EmailFormat.PLAINTEXT) {
                    removeUser(thisUser);
                    smtpRcptToPlaintextOnly.add(new Address(thisUser.getFullName(), thisUser.getPreferredEmail()));
                }
                if (smtpRcptTo.isEmpty() && smtpRcptToPlaintextOnly.isEmpty()) {
                    return;
                }
            }
        }
        // inbound email replies.
        if (!headers.containsKey("Reply-To")) {
            StringJoiner j = new StringJoiner(", ");
            if (fromId != null) {
                Address address = toAddress(fromId);
                if (address != null) {
                    j.add(address.getEmail());
                }
            }
            smtpRcptTo.stream().forEach(a -> j.add(a.getEmail()));
            smtpRcptToPlaintextOnly.stream().forEach(a -> j.add(a.getEmail()));
            setHeader("Reply-To", j.toString());
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        if (!smtpRcptTo.isEmpty()) {
            // Send multipart message
            args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
        }
        if (!smtpRcptToPlaintextOnly.isEmpty()) {
            // Send plaintext message
            Map<String, EmailHeader> shallowCopy = new HashMap<>();
            shallowCopy.putAll(headers);
            // Remove To and Cc
            shallowCopy.remove(HDR_TO);
            shallowCopy.remove(HDR_CC);
            for (Address a : smtpRcptToPlaintextOnly) {
                // Add new To
                EmailHeader.AddressList to = new EmailHeader.AddressList();
                to.add(a);
                shallowCopy.put(HDR_TO, to);
            }
            args.emailSender.send(va.smtpFromAddress, smtpRcptToPlaintextOnly, shallowCopy, va.body);
        }
    }
}
#end_block

#method_before
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    if (notify.compareTo(NotifyHandling.OWNER_REVIEWERS) >= 0) {
        ccAllApprovals();
    }
    if (notify.compareTo(NotifyHandling.ALL) >= 0) {
        bccStarredBy();
        includeWatchers(NotifyType.ALL_COMMENTS);
    }
    // Add header that enables identifying comments on parsed email.
    // Grouping is currently done by timestamp.
    setHeader("X-Gerrit-Comment-Date", timestamp);
    if (incomingEmailEnabled) {
        if (inboundEmailAddress == null) {
            // Remove Reply-To and use outbound SMTP (default) instead.
            removeHeader("Reply-To");
        } else {
            setHeader("Reply-To", inboundEmailAddress);
        }
    }
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (notify.compareTo(NotifyHandling.OWNER_REVIEWERS) >= 0) {
        ccAllApprovals();
    }
    if (notify.compareTo(NotifyHandling.ALL) >= 0) {
        bccStarredBy();
        includeWatchers(NotifyType.ALL_COMMENTS);
    }
    // Add header that enables identifying comments on parsed email.
    // Grouping is currently done by timestamp.
    setHeader("X-Gerrit-Comment-Date", timestamp);
    if (incomingEmailEnabled) {
        if (replyToAddress == null) {
            // Remove Reply-To and use outbound SMTP (default) instead.
            removeHeader("Reply-To");
        } else {
            setHeader("Reply-To", replyToAddress);
        }
    }
}
#end_block

#method_before
private List<Map<String, Object>> commentBlocksToSoyData(List<CommentFormatter.Block> blocks) {
    return blocks.stream().map(b -> {
        Map<String, Object> map = new HashMap<>();
        switch(b.type) {
            case PARAGRAPH:
                map.put("type", "paragraph");
                map.put("text", b.text);
                break;
            case PRE_FORMATTED:
                map.put("type", "pre");
                map.put("text", b.text);
                break;
            case QUOTE:
                map.put("type", "quote");
                map.put("quotedBlocks", commentBlocksToSoyData(b.quotedBlocks));
                break;
            case LIST:
                map.put("type", "list");
                map.put("items", b.items);
                break;
        }
        return map;
    }).collect(Collectors.toList());
}
#method_after
private List<Map<String, Object>> commentBlocksToSoyData(List<CommentFormatter.Block> blocks) {
    return blocks.stream().map(b -> {
        Map<String, Object> map = new HashMap<>();
        switch(b.type) {
            case PARAGRAPH:
                map.put("type", "paragraph");
                map.put("text", b.text);
                break;
            case PRE_FORMATTED:
                map.put("type", "pre");
                map.put("text", b.text);
                break;
            case QUOTE:
                map.put("type", "quote");
                map.put("quotedBlocks", commentBlocksToSoyData(b.quotedBlocks));
                break;
            case LIST:
                map.put("type", "list");
                map.put("items", b.items);
                break;
        }
        return map;
    }).collect(toList());
}
#end_block

#method_before
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.getAuthType() == OAUTH && authConfig.getGitBasicAuthPolicy() != GitBasicAuthPolicy.HTTP) {
        authFilter = ProjectOAuthFilter.class;
    } else {
        authFilter = ProjectBasicAuthFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(authFilter);
    filter("/a/*").through(authFilter);
}
#method_after
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else {
        authFilter = authConfig.getGitBasicAuthPolicy() == GitBasicAuthPolicy.OAUTH ? ProjectOAuthFilter.class : ProjectBasicAuthFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(authFilter);
    filter("/a/*").through(authFilter);
}
#end_block

#method_before
@Test
@GerritConfig(name = "receiveemail.listfilter.mode", value = "OFF")
public void listFilterOff() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(3);
}
#method_after
@Test
@GerritConfig(name = "receiveemail.filter.mode", value = "OFF")
public void listFilterOff() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(3);
}
#end_block

#method_before
@Test
@GerritConfig(name = "receiveemail.listfilter.mode", value = "WHITELIST")
@GerritConfig(name = "receiveemail.listfilter.patterns", values = { ".+ser@example\\.com", "a@b\\.com" })
public void listFilterWhitelistDoesNotFilterListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(3);
}
#method_after
@Test
@GerritConfig(name = "receiveemail.filter.mode", value = "WHITELIST")
@GerritConfig(name = "receiveemail.filter.patterns", values = { ".+ser@example\\.com", "a@b\\.com" })
public void listFilterWhitelistDoesNotFilterListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(3);
}
#end_block

#method_before
@Test
@GerritConfig(name = "receiveemail.listfilter.mode", value = "WHITELIST")
@GerritConfig(name = "receiveemail.listfilter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" })
public void listFilterWhitelistFiltersNotListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have NOT been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(2);
}
#method_after
@Test
@GerritConfig(name = "receiveemail.filter.mode", value = "WHITELIST")
@GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" })
public void listFilterWhitelistFiltersNotListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have NOT been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(2);
}
#end_block

#method_before
@Test
@GerritConfig(name = "receiveemail.listfilter.mode", value = "BLACKLIST")
@GerritConfig(name = "receiveemail.listfilter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" })
public void listFilterBlacklistDoesNotFilterNotListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(3);
}
#method_after
@Test
@GerritConfig(name = "receiveemail.filter.mode", value = "BLACKLIST")
@GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" })
public void listFilterBlacklistDoesNotFilterNotListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(3);
}
#end_block

#method_before
@Test
@GerritConfig(name = "receiveemail.listfilter.mode", value = "BLACKLIST")
@GerritConfig(name = "receiveemail.listfilter.patterns", values = { ".+@example\\.com", "a@b\\.com" })
public void listFilterBlacklistFiltersListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(2);
}
#method_after
@Test
@GerritConfig(name = "receiveemail.filter.mode", value = "BLACKLIST")
@GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@example\\.com", "a@b\\.com" })
public void listFilterBlacklistFiltersListedUser() throws Exception {
    ChangeInfo changeInfo = createChangeAndReplyByEmail();
    // Check that the comments from the email have been persisted
    Collection<ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages;
    assertThat(messages).hasSize(2);
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<AccountExternalId> extIds = new ArrayList<>(2);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                    extUser.setHashedPassword(HashedPassword.fromPassword(httpPassword).encode());
                }
                extIds.add(extUser);
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    extIds.add(extMailto);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<AccountExternalId> extIds = new ArrayList<>(2);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(HashedPassword.fromPassword(httpPassword).encode());
                }
                extIds.add(extUser);
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    extIds.add(extMailto);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ArrayList<AccountExternalId> l = new ArrayList<>();
    for (AccountExternalId id : db.accountExternalIds().all()) {
        String pw = id.getPassword();
        if (pw != null) {
            HashedPassword hpw = HashedPassword.fromPassword(pw);
            id.setHashedPassword(hpw.encode());
        }
        l.add(id);
    }
    db.accountExternalIds().upsert(l);
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    List<AccountExternalId> newIds = db.accountExternalIds().all().toList();
    for (AccountExternalId id : newIds) {
        if (!id.isScheme(AccountExternalId.SCHEME_USERNAME)) {
            continue;
        }
        String password = id.getPassword();
        if (password != null) {
            HashedPassword hashed = HashedPassword.fromPassword(password);
            id.setPassword(hashed.encode());
        }
    }
    db.accountExternalIds().upsert(newIds);
}
#end_block

#method_before
public void setPassword(String p) {
    password = p;
}
#method_after
public void setPassword(String hashed) {
    password = hashed;
}
#end_block

#method_before
@Test
public void encodeOneLine() throws Exception {
    String password = "secret";
    HashedPassword hpw = HashedPassword.fromPassword(password);
    assertThat(hpw.encode()).doesNotContain("\n");
}
#method_after
@Test
public void encodeOneLine() throws Exception {
    String password = "secret";
    HashedPassword hashed = HashedPassword.fromPassword(password);
    assertThat(hashed.encode()).doesNotContain("\n");
    assertThat(hashed.encode()).doesNotContain("\r");
}
#end_block

#method_before
@Test
public void encodeDecode() throws Exception {
    String password = "secret";
    HashedPassword hpw = HashedPassword.fromPassword(password);
    HashedPassword roundtrip = HashedPassword.decode(hpw.encode());
    assertThat(hpw.encode()).isEqualTo(roundtrip.encode());
}
#method_after
@Test
public void encodeDecode() throws Exception {
    String password = "secret";
    HashedPassword hashed = HashedPassword.fromPassword(password);
    HashedPassword roundtrip = HashedPassword.decode(hashed.encode());
    assertThat(hashed.encode()).isEqualTo(roundtrip.encode());
    assertThat(roundtrip.checkPassword(password)).isTrue();
    assertThat(roundtrip.checkPassword("not the password")).isFalse();
}
#end_block

#method_before
@Test
public void lengthLimit() throws Exception {
    String pw = Strings.repeat("1", 70);
    assertThat(HashedPassword.fromPassword(pw).encode().length()).isLessThan(255);
}
#method_after
@Test
public void lengthLimit() throws Exception {
    String password = Strings.repeat("1", 72);
    // make sure it fits in varchar(255).
    assertThat(HashedPassword.fromPassword(password).encode().length()).isLessThan(255);
}
#end_block

#method_before
@Test
public void basicFunctionality() throws Exception {
    String password = "secret";
    HashedPassword hpw = HashedPassword.fromPassword(password);
    assertThat(hpw.checkPassword("false")).isFalse();
    assertThat(hpw.checkPassword(password)).isTrue();
}
#method_after
@Test
public void basicFunctionality() throws Exception {
    String password = "secret";
    HashedPassword hashed = HashedPassword.fromPassword(password);
    assertThat(hashed.checkPassword("false")).isFalse();
    assertThat(hashed.checkPassword(password)).isTrue();
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
        extUser.setHashedPassword(HashedPassword.fromPassword(input.httpPassword).encode());
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(HashedPassword.fromPassword(input.httpPassword).encode());
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (Strings.isNullOrEmpty(req.getUsername()) || Strings.isNullOrEmpty(req.getPassword())) {
        throw new MissingCredentialsException();
    }
    String username;
    if (authConfig.isUserNameToLowerCase()) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null) {
        throw new UnknownUserException();
    } else if (!who.getAccount().isActive()) {
        throw new UserNotAllowedException("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
    }
    who.checkPassword(req.getPassword(), username);
    return new AuthUser(AuthUser.UUID.create(username), username);
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (Strings.isNullOrEmpty(req.getUsername()) || Strings.isNullOrEmpty(req.getPassword())) {
        throw new MissingCredentialsException();
    }
    String username;
    if (authConfig.isUserNameToLowerCase()) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null) {
        throw new UnknownUserException();
    } else if (!who.getAccount().isActive()) {
        throw new UserNotAllowedException("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
    }
    if (!who.checkPassword(req.getPassword(), username)) {
        throw new InvalidCredentialsException();
    }
    return new AuthUser(AuthUser.UUID.create(username), username);
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (who.checkPassword(password, who.getUserName())) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (who.checkPassword(password, username)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (who.checkPassword(password, who.getUserName())) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private boolean failAuthentication(Response rsp, String username) throws IOException {
    log.warn("Authentication failed for {}: password does not match the one" + " stored in Gerrit", username);
    rsp.sendError(SC_UNAUTHORIZED);
    return false;
}
#method_after
private boolean failAuthentication(Response rsp, String username) throws IOException {
    log.warn("Authentication failed for {}: password does not match the one stored in Gerrit", username);
    rsp.sendError(SC_UNAUTHORIZED);
    return false;
}
#end_block

#method_before
public boolean checkPassword(String password, String username) {
    if (password == null) {
        return false;
    }
    for (AccountExternalId id : getExternalIds()) {
        if (id.isScheme(AccountExternalId.SCHEME_USERNAME) && username.equals(id.getSchemeRest())) {
            String hashedStr = id.getHashedPassword();
            if (!hashedStr.isEmpty()) {
                return HashedPassword.decode(hashedStr).checkPassword(password);
            }
            String want = id.getPassword();
            if (!want.isEmpty()) {
                byte[] wantBytes = Strings.toByteArray(want);
                byte[] gotBytes = Strings.toByteArray(password);
                return Arrays.areEqual(wantBytes, gotBytes);
            }
        }
    }
    return false;
}
#method_after
public boolean checkPassword(String password, String username) {
    if (password == null) {
        return false;
    }
    for (AccountExternalId id : getExternalIds()) {
        // Only process the "username:$USER" entry, which is unique.
        if (!id.isScheme(AccountExternalId.SCHEME_USERNAME) || !username.equals(id.getSchemeRest())) {
            continue;
        }
        String hashedStr = id.getPassword();
        if (!Strings.isNullOrEmpty(hashedStr)) {
            try {
                return HashedPassword.decode(hashedStr).checkPassword(password);
            } catch (DecoderException e) {
                logger.error(String.format("DecoderException for user %s: %s ", username, e.getMessage()));
                return false;
            }
        }
    }
    return false;
}
#end_block

#method_before
public static HashedPassword decode(String encoded) {
    String[] fields = encoded.split(":");
    Preconditions.checkState(fields.length == 2);
    return new HashedPassword(codec.decodeBase64(fields[1]), codec.decodeBase64(fields[0]));
}
#method_after
public static HashedPassword decode(String encoded) throws DecoderException {
    if (!encoded.startsWith(ALGORITHM_PREFIX)) {
        throw new DecoderException("unrecognized algorithm");
    }
    String[] fields = encoded.split(":");
    if (fields.length != 4) {
        throw new DecoderException("want 4 fields");
    }
    Integer cost = Ints.tryParse(fields[1]);
    if (cost == null) {
        throw new DecoderException("cost parse failed");
    }
    if (!(cost >= 4 && cost < 32)) {
        throw new DecoderException("cost should be 4..31 inclusive, got " + cost);
    }
    byte[] salt = codec.decode(fields[2]);
    if (salt.length != 16) {
        throw new DecoderException("salt should be 16 bytes, got " + salt.length);
    }
    return new HashedPassword(codec.decode(fields[3]), salt, cost);
}
#end_block

#method_before
private static byte[] hashPassword(String password, byte[] salt) {
    byte[] pwBytes = password.getBytes(StandardCharsets.UTF_8);
    final int cost = 10;
    return BCrypt.generate(pwBytes, salt, cost);
}
#method_after
private static byte[] hashPassword(String password, byte[] salt, int cost) {
    byte[] pwBytes = password.getBytes(StandardCharsets.UTF_8);
    return BCrypt.generate(pwBytes, salt, cost);
}
#end_block

#method_before
public static HashedPassword fromPassword(String password) {
    byte[] salt = newSalt();
    return new HashedPassword(hashPassword(password, salt), salt);
}
#method_after
public static HashedPassword fromPassword(String password) {
    byte[] salt = newSalt();
    return new HashedPassword(hashPassword(password, salt, DEFAULT_COST), salt, DEFAULT_COST);
}
#end_block

#method_before
public String encode() {
    // NOSUBMIT - how to get rid of the line endings?
    return codec.encodeBase64String(salt).replace("\r\n", "") + ":" + codec.encodeBase64String(hashed).replace("\r\n", "");
}
#method_after
public String encode() {
    return ALGORITHM_PREFIX + cost + ":" + codec.encode(salt) + ":" + codec.encode(hashed);
}
#end_block

#method_before
public boolean checkPassword(String password) {
    return Arrays.areEqual(hashPassword(password, salt), hashed);
}
#method_after
public boolean checkPassword(String password) {
    // Constant-time comparison, because we're paranoid.
    return Arrays.areEqual(hashPassword(password, salt, cost), hashed);
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        extUser.setHashedPassword(HashedPassword.fromPassword(httpPass).encode());
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                checkArgument(g != null, "group not found: %s", n);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = null;
        if (SshMode.useSsh()) {
            sshKey = genSshKey();
            authorizedKeys.addKey(id, publicKey(sshKey, email));
            sshKeyCache.evict(username);
        }
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        indexer.index(id);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(HashedPassword.fromPassword(httpPass).encode());
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                checkArgument(g != null, "group not found: %s", n);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = null;
        if (SshMode.useSsh()) {
            sshKey = genSshKey();
            authorizedKeys.addKey(id, publicKey(sshKey, email));
            sshKeyCache.evict(username);
        }
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        indexer.index(id);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.isGitBasicAuth()) {
        if (authConfig.getAuthType() == OAUTH) {
            authFilter = ProjectOAuthFilter.class;
        } else {
            authFilter = ProjectBasicAuthFilter.class;
        }
    } else {
        // NOSUBMIT - what should this look like now without ProjectDigest filter?
        authFilter = ProjectBasicAuthFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filter("/a/*").through(authFilter);
}
#method_after
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.getAuthType() == OAUTH) {
        authFilter = ProjectOAuthFilter.class;
    } else {
        authFilter = ProjectBasicAuthFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(authFilter);
    filter("/a/*").through(authFilter);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    id.setHashedPassword(HashedPassword.fromPassword(newPassword).encode());
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(HashedPassword.fromPassword(newPassword).encode());
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
@Override
public Token getAccessToken(Token requestToken, Verifier verifier) {
    OAuthRequest request = new OAuthRequest(api.getAccessTokenVerb(), api.getAccessTokenEndpoint());
    request.addBodyParameter(OAuthConstants.CLIENT_ID, config.getApiKey());
    request.addBodyParameter(OAuthConstants.CLIENT_SECRET, config.getApiSecret());
    request.addBodyParameter(OAuthConstants.CODE, verifier.getValue());
    request.addBodyParameter(OAuthConstants.REDIRECT_URI, config.getCallback());
    if (config.hasScope())
        request.addBodyParameter(OAuthConstants.SCOPE, config.getScope());
    request.addBodyParameter(GRANT_TYPE, GRANT_TYPE_VALUE);
    Response response = request.send();
    return api.getAccessTokenExtractor().extract(response.getBody());
}
#method_after
@Override
public Token getAccessToken(Token requestToken, Verifier verifier) {
    OAuthRequest request = new OAuthRequest(api.getAccessTokenVerb(), api.getAccessTokenEndpoint());
    request.addBodyParameter(OAuthConstants.CLIENT_ID, config.getApiKey());
    request.addBodyParameter(OAuthConstants.CLIENT_SECRET, config.getApiSecret());
    request.addBodyParameter(OAuthConstants.CODE, verifier.getValue());
    request.addBodyParameter(OAuthConstants.REDIRECT_URI, config.getCallback());
    if (config.hasScope()) {
        request.addBodyParameter(OAuthConstants.SCOPE, config.getScope());
    }
    request.addBodyParameter(GRANT_TYPE, GRANT_TYPE_VALUE);
    Response response = request.send();
    return api.getAccessTokenExtractor().extract(response.getBody());
}
#end_block

#method_before
CurrentUser getUser(String auth, String project, String operation) {
    if (!Strings.isNullOrEmpty(auth)) {
        if (auth.startsWith(BASIC_AUTH_PREFIX)) {
            GitBasicAuthPolicy gitBasicAuthPolicy = authCfg.getGitBasicAuthPolicy();
            if (gitBasicAuthPolicy == HTTP || gitBasicAuthPolicy == HTTP_LDAP) {
                return user.get();
            }
        }
        if (auth.startsWith(SSH_AUTH_PREFIX)) {
            Optional<String> user = sshAuth.getUserFromValidToken(auth.substring(SSH_AUTH_PREFIX.length()), project, operation);
            if (user.isPresent()) {
                AccountState acc = accounts.getByUsername(user.get());
                if (acc != null) {
                    return userFactory.create(acc);
                }
            }
        }
    }
    return anonymous.get();
}
#method_after
CurrentUser getUser(String auth, String project, String operation) {
    if (!Strings.isNullOrEmpty(auth)) {
        if (auth.startsWith(BASIC_AUTH_PREFIX)) {
            return user.get();
        }
        if (auth.startsWith(SSH_AUTH_PREFIX)) {
            Optional<String> user = sshAuth.getUserFromValidToken(auth.substring(SSH_AUTH_PREFIX.length()), project, operation);
            if (user.isPresent()) {
                AccountState acc = accounts.getByUsername(user.get());
                if (acc != null) {
                    return userFactory.create(acc);
                }
            }
        }
    }
    return anonymous.get();
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    if (projects.isEmpty()) {
        throw die("needs at least one project as command arguments");
    }
    projects.stream().map(pc -> pc.getProject().getNameKey()).forEach(p -> index(p));
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    if (projects.isEmpty()) {
        throw die("needs at least one project as command arguments");
    }
    projects.stream().forEach(this::index);
}
#end_block

#method_before
private void index(Repository repo, ListMultimap<ObjectId, ChangeData> byId) throws Exception {
    try (RevWalk walk = new RevWalk(repo)) {
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (o instanceof RevCommit) {
                walk.markStart((RevCommit) o);
            }
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null && !byId.isEmpty()) {
            if (byId.containsKey(bCommit)) {
                indexCds(byId.get(bCommit));
                byId.removeAll(bCommit);
            }
        }
        for (ObjectId id : byId.keySet()) {
            indexCds(byId.get(id));
        }
    }
}
#method_after
private void index(ProjectControl projectControl) {
    try {
        index.apply(new ProjectResource(projectControl), null);
    } catch (Exception e) {
        writeError("error", String.format("Unable to index %s: %s", projectControl.getProject().getName(), e.getMessage()));
    }
}
#end_block

#method_before
private void authorizeUser(CurrentUser user, ProjectState state, String operation) throws LfsUnauthorized {
    ProjectControl control = state.controlFor(user);
    if ((operation.equals(DOWNLOAD) && !control.isReadable()) || (operation.equals(UPLOAD) && Capable.OK != control.canPushToAtLeastOneRef())) {
        throw new LfsUnauthorized(operation.toLowerCase(), state.getProject().getName());
    }
}
#method_after
private void authorizeUser(CurrentUser user, ProjectState state, String operation) throws LfsUnauthorized {
    ProjectControl control = state.controlFor(user);
    if ((operation.equals(DOWNLOAD) && !control.isReadable()) || (operation.equals(UPLOAD) && Capable.OK != control.canPushToAtLeastOneRef())) {
        String op = operation.toLowerCase();
        String project = state.getProject().getName();
        String userName = Strings.isNullOrEmpty(user.getUserName()) ? "anonymous" : user.getUserName();
        log.debug(String.format("operation %s unauthorized for user %s on project %s", op, userName, project));
        throw new LfsUnauthorized(op, project);
    }
}
#end_block

#method_before
CurrentUser getUser(String auth, String project, String operation) {
    if (!Strings.isNullOrEmpty(auth)) {
        if (auth.startsWith(BASIC_AUTH_PREFIX) && authCfg.isGitBasicAuth()) {
            return user.get();
        }
        if (auth.startsWith(SSH_AUTH_PREFIX)) {
            Optional<String> user = sshAuth.verifyToken(auth.substring(SSH_AUTH_PREFIX.length()), project, operation);
            if (user.isPresent()) {
                AccountState acc = accounts.getByUsername(user.get());
                if (acc != null) {
                    return userFactory.create(acc);
                }
            }
        }
    }
    return anonymous.get();
}
#method_after
CurrentUser getUser(String auth, String project, String operation) {
    if (!Strings.isNullOrEmpty(auth)) {
        if (auth.startsWith(BASIC_AUTH_PREFIX) && authCfg.isGitBasicAuth()) {
            return user.get();
        }
        if (auth.startsWith(SSH_AUTH_PREFIX)) {
            Optional<String> user = sshAuth.getUserFromValidToken(auth.substring(SSH_AUTH_PREFIX.length()), project, operation);
            if (user.isPresent()) {
                AccountState acc = accounts.getByUsername(user.get());
                if (acc != null) {
                    return userFactory.create(acc);
                }
            }
        }
    }
    return anonymous.get();
}
#end_block

#method_before
@Override
public String authenticate(CurrentUser user, List<String> args) throws UnloggedFailure, Failure {
    try {
        URL url = new URL(canonicalWebUrl);
        String project = args.get(0);
        String operation = args.get(1);
        String href = url.getProtocol() + "://" + url.getAuthority() + url.getPath() + "/" + project + "/info/lfs";
        Response.Action response = new Response.Action();
        response.href = href;
        response.header = Collections.singletonMap(HDR_AUTHORIZATION, auth.generateToken(user, project, operation));
        return gson.toJson(response);
    } catch (MalformedURLException e) {
        throw new Failure(1, "Server configuration error: " + "forming Git LFS endpoint URL from canonicalWebUrl [" + canonicalWebUrl + "] failed.");
    }
}
#method_after
@Override
public String authenticate(CurrentUser user, List<String> args) throws UnloggedFailure, Failure {
    try {
        URL url = new URL(canonicalWebUrl);
        String path = url.getPath();
        String project = args.get(0);
        String operation = args.get(1);
        StringBuilder href = new StringBuilder(url.getProtocol()).append("://").append(url.getAuthority()).append(path).append(path.endsWith("/") ? "" : "/").append(project).append("/info/lfs");
        LfsSshRequestAuthorizer.SshAuthInfo info = auth.generateAuthInfo(user, project, operation);
        ExpiringAction action = new ExpiringAction(href.toString(), info);
        return gson.toJson(action);
    } catch (MalformedURLException e) {
        throw new Failure(1, "Server configuration error: " + "forming Git LFS endpoint URL from canonicalWebUrl [" + canonicalWebUrl + "] failed.");
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    Writer w = new BufferedWriter(new OutputStreamWriter(res.getOutputStream(), UTF_8));
    Reader r = new BufferedReader(new InputStreamReader(req.getInputStream(), UTF_8));
    LfsRequest request = gson.fromJson(r, LfsRequest.class);
    String path = req.getPathInfo();
    res.setContentType(CONTENTTYPE_VND_GIT_LFS_JSON);
    LargeFileRepository repo = null;
    try {
        repo = getLargeFileRepository(request, path, new AuthInfo(Charset.forName(MoreObjects.firstNonNull(req.getCharacterEncoding(), Charsets.UTF_8.name())), req.getHeader(HDR_AUTHORIZATION)));
        if (repo == null) {
            // $NON-NLS-1$
            throw new LfsException("unexpected error");
        }
        res.setStatus(SC_OK);
        TransferHandler handler = TransferHandler.forOperation(request.operation, repo, request.objects);
        gson.toJson(handler.process(), w);
    } catch (LfsValidationError e) {
        sendError(res, w, SC_UNPROCESSABLE_ENTITY, e.getMessage());
    } catch (LfsRepositoryNotFound e) {
        sendError(res, w, SC_NOT_FOUND, e.getMessage());
    } catch (LfsRepositoryReadOnly e) {
        sendError(res, w, SC_FORBIDDEN, e.getMessage());
    } catch (LfsRateLimitExceeded e) {
        sendError(res, w, SC_RATE_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsBandwidthLimitExceeded e) {
        sendError(res, w, SC_BANDWIDTH_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsInsufficientStorage e) {
        sendError(res, w, SC_INSUFFICIENT_STORAGE, e.getMessage());
    } catch (LfsUnavailable e) {
        sendError(res, w, SC_SERVICE_UNAVAILABLE, e.getMessage());
    } catch (LfsUnauthorized e) {
        sendError(res, w, SC_UNAUTHORIZED, e.getMessage());
    } catch (LfsException e) {
        sendError(res, w, SC_INTERNAL_SERVER_ERROR, e.getMessage());
    } finally {
        w.flush();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    Writer w = new BufferedWriter(new OutputStreamWriter(res.getOutputStream(), UTF_8));
    Reader r = new BufferedReader(new InputStreamReader(req.getInputStream(), UTF_8));
    LfsRequest request = gson.fromJson(r, LfsRequest.class);
    String path = req.getPathInfo();
    res.setContentType(CONTENTTYPE_VND_GIT_LFS_JSON);
    LargeFileRepository repo = null;
    try {
        repo = getLargeFileRepository(request, path, req.getHeader(HDR_AUTHORIZATION));
        if (repo == null) {
            // $NON-NLS-1$
            throw new LfsException("unexpected error");
        }
        res.setStatus(SC_OK);
        TransferHandler handler = TransferHandler.forOperation(request.operation, repo, request.objects);
        gson.toJson(handler.process(), w);
    } catch (LfsValidationError e) {
        sendError(res, w, SC_UNPROCESSABLE_ENTITY, e.getMessage());
    } catch (LfsRepositoryNotFound e) {
        sendError(res, w, SC_NOT_FOUND, e.getMessage());
    } catch (LfsRepositoryReadOnly e) {
        sendError(res, w, SC_FORBIDDEN, e.getMessage());
    } catch (LfsRateLimitExceeded e) {
        sendError(res, w, SC_RATE_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsBandwidthLimitExceeded e) {
        sendError(res, w, SC_BANDWIDTH_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsInsufficientStorage e) {
        sendError(res, w, SC_INSUFFICIENT_STORAGE, e.getMessage());
    } catch (LfsUnavailable e) {
        sendError(res, w, SC_SERVICE_UNAVAILABLE, e.getMessage());
    } catch (LfsUnauthorized e) {
        sendError(res, w, SC_UNAUTHORIZED, e.getMessage());
    } catch (LfsException e) {
        sendError(res, w, SC_INTERNAL_SERVER_ERROR, e.getMessage());
    } finally {
        w.flush();
    }
}
#end_block

#method_before
CurrentUser getUser(String auth, Charset cs) {
    if (Strings.isNullOrEmpty(auth)) {
        return anonymous.get();
    }
    if (auth.startsWith(BASIC_AUTH_PREFIX)) {
        String usernamePassword;
        usernamePassword = new String(Base64.decodeBase64(auth.substring(BASIC_AUTH_PREFIX.length())), cs);
        String username;
        int splitPos = usernamePassword.indexOf(':');
        if (splitPos < 0) {
            username = usernamePassword;
        } else {
            username = usernamePassword.substring(0, splitPos);
        }
        AccountState acc = accounts.getByUsername(username);
        if (acc != null) {
            return userFactory.create(acc);
        }
    }
    return anonymous.get();
}
#method_after
CurrentUser getUser(String auth) {
    if (!Strings.isNullOrEmpty(auth) && auth.startsWith(BASIC_AUTH_PREFIX) && authCfg.isGitBasicAuth()) {
        return user.get();
    }
    return anonymous.get();
}
#end_block

#method_before
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path, LfsGerritProtocolServlet.AuthInfo auth) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        throw new LfsException("no repository at " + pathInfo);
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    authorizeUser(userProvider.getUser(auth.auth, auth.cs), state, request.getOperation());
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals(UPLOAD) && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig().getForProject(project);
    // No config means we default to "not enabled".
    if (config != null && config.isEnabled()) {
        // For uploads, check object sizes against limit if configured
        if (request.getOperation().equals(UPLOAD)) {
            if (config.isReadOnly()) {
                throw new LfsRepositoryReadOnly(project.get());
            }
            long maxObjectSize = config.getMaxObjectSize();
            if (maxObjectSize > 0) {
                for (LfsObject object : request.getObjects()) {
                    if (object.getSize() > maxObjectSize) {
                        throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                    }
                }
            }
        }
        return repoResolver.get(project, config.getBackend());
    }
    throw new LfsUnavailable(project.get());
}
#method_after
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path, String auth) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        throw new LfsException("no repository at " + pathInfo);
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    authorizeUser(userProvider.getUser(auth), state, request.getOperation());
    if (request.getOperation().equals(UPLOAD) && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig().getForProject(project);
    // No config means we default to "not enabled".
    if (config != null && config.isEnabled()) {
        // For uploads, check object sizes against limit if configured
        if (request.getOperation().equals(UPLOAD)) {
            if (config.isReadOnly()) {
                throw new LfsRepositoryReadOnly(project.get());
            }
            long maxObjectSize = config.getMaxObjectSize();
            if (maxObjectSize > 0) {
                for (LfsObject object : request.getObjects()) {
                    if (object.getSize() > maxObjectSize) {
                        throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                    }
                }
            }
        }
        return repoResolver.get(project, config.getBackend());
    }
    throw new LfsUnavailable(project.get());
}
#end_block

#method_before
private void authorizeUser(CurrentUser user, ProjectState state, String operation) throws LfsUnauthorized {
    ProjectControl control = state.controlFor(user);
    switch(operation) {
        case "download":
            if (control.isReadable()) {
                return;
            }
            break;
        case UPLOAD:
            if (Capable.OK == control.canPushToAtLeastOneRef()) {
                return;
            }
            break;
    }
    throw new LfsUnauthorized(String.format("User %s is not authorized to perform %s operation", user.getUserName(), operation));
}
#method_after
private void authorizeUser(CurrentUser user, ProjectState state, String operation) throws LfsUnauthorized {
    ProjectControl control = state.controlFor(user);
    if ((operation.equals(DOWNLOAD) && !control.isReadable()) || (operation.equals(UPLOAD) && Capable.OK != control.canPushToAtLeastOneRef())) {
        throw new LfsUnauthorized(String.format("User %s is not authorized to perform %s operation", Strings.isNullOrEmpty(user.getUserName()) ? "anonymous" : user.getUserName(), operation.toLowerCase()));
    }
}
#end_block

