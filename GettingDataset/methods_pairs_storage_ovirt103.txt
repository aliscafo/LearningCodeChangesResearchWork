355
#method_before
@Override
protected void executeVmCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    // Mark that the stopped vm was suspended before for audit log messages
    suspendedVm = getVm().getStatus() == VMStatus.Suspended;
    if (suspendedVm || StringUtils.isNotEmpty(getActiveSnapshot().getMemoryVolume())) {
        if (!stopSuspendedVm()) {
            return;
        }
        // the following is true when the hibernation volumes don't exist
        if (getTaskIdList().isEmpty()) {
            endVmCommand();
            setCommandShouldBeLogged(true);
        } else {
            setSucceeded(true);
        }
    } else {
        super.executeVmCommand();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    String hiberVol = getActiveSnapshot().getMemoryVolume();
    suspendedVm = getVm().getStatus() == VMStatus.Suspended;
    if (suspendedVm) {
        endVmCommand();
        setCommandShouldBeLogged(true);
    } else {
        super.executeVmCommand();
    }
    removeMemoryDisksIfNeeded(hiberVol);
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    setCommandShouldBeLogged(false);
    if (getVm() == null) {
        log.warn("VM is null, not performing full endAction");
        setSucceeded(true);
    }
    getVm().setStatus(VMStatus.Down);
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    getVmDynamicDao().update(getVm().getDynamicData());
    setSucceeded(true);
}
#method_after
@Override
protected void endVmCommand() {
    setCommandShouldBeLogged(false);
    if (getVm() == null) {
        log.warn("VM is null, not performing full endAction");
        setSucceeded(true);
        return;
    }
    getVm().setStatus(VMStatus.Down);
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    getVmDynamicDao().update(getVm().getDynamicData());
    setSucceeded(true);
}
#end_block

#method_before
protected void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                if (exSchedulerDiscovery.discover()) {
                    reloadPolicyUnits();
                }
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#method_after
private void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                if (exSchedulerDiscovery.discover()) {
                    reloadPolicyUnits();
                }
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#end_block

#method_before
public void reloadPolicyUnits() {
    synchronized (policyUnitsLock) {
        policyUnits = new ConcurrentHashMap<>();
        loadPolicyUnits();
    }
}
#method_after
private void reloadPolicyUnits() {
    synchronized (policyUnitsLock) {
        policyUnits = new ConcurrentHashMap<>();
        loadPolicyUnits();
    }
}
#end_block

#method_before
protected void loadClusterPolicies() {
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#method_after
private void loadClusterPolicies() {
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#end_block

#method_before
protected void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager()));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#method_after
private void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), Injector.injectMembers(PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager())));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#end_block

#method_before
private void markVfsAsUsedByVm(Guid hostId, Guid vmId, Map<Guid, String> passthroughVnicToVfMap) {
    HostNicVfsConfigHelper hostNicVfsConfigHelper = Injector.get(HostNicVfsConfigHelper.class);
    hostNicVfsConfigHelper.setVmIdOnVfs(hostId, vmId, new HashSet<>(passthroughVnicToVfMap.values()));
}
#method_after
private void markVfsAsUsedByVm(Guid hostId, Guid vmId, Map<Guid, String> passthroughVnicToVfMap) {
    NetworkDeviceHelper networkDeviceHelper = Injector.get(NetworkDeviceHelper.class);
    networkDeviceHelper.setVmIdOnVfs(hostId, vmId, new HashSet<>(passthroughVnicToVfMap.values()));
}
#end_block

#method_before
protected void checkAllowOverbooking(VDSGroup cluster) {
    if (OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType() && Config.<Boolean>getValue(ConfigValues.SchedulerAllowOverBooking) && clusterLockMap.get(cluster.getId()).getQueueLength() >= Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold)) {
        log.info("Scheduler: cluster '{}' lock is skipped (cluster is allowed to overbook)", cluster.getName());
        // release pending threads (requests) and current one (+1)
        clusterLockMap.get(cluster.getId()).release(Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold) + 1);
    }
}
#method_after
private void checkAllowOverbooking(VDSGroup cluster) {
    if (OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType() && Config.<Boolean>getValue(ConfigValues.SchedulerAllowOverBooking) && clusterLockMap.get(cluster.getId()).getQueueLength() >= Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold)) {
        log.info("Scheduler: cluster '{}' lock is skipped (cluster is allowed to overbook)", cluster.getName());
        // release pending threads (requests) and current one (+1)
        clusterLockMap.get(cluster.getId()).release(Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold) + 1);
    }
}
#end_block

#method_before
protected boolean shouldWeighClusterHosts(VDSGroup cluster, List<VDS> vdsList) {
    Integer threshold = Config.<Integer>getValue(ConfigValues.SpeedOptimizationSchedulingThreshold);
    // threshold is crossed only when cluster is configured for optimized for speed
    boolean crossedThreshold = OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType() && clusterLockMap.get(cluster.getId()).getQueueLength() > threshold;
    if (crossedThreshold) {
        log.info("Scheduler: skipping whinging hosts in cluster '{}', since there are more than '{}' parallel requests", cluster.getName(), threshold);
    }
    return vdsList.size() > 1 && !crossedThreshold;
}
#method_after
private boolean shouldWeighClusterHosts(VDSGroup cluster, List<VDS> vdsList) {
    Integer threshold = Config.<Integer>getValue(ConfigValues.SpeedOptimizationSchedulingThreshold);
    // threshold is crossed only when cluster is configured for optimized for speed
    boolean crossedThreshold = OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType() && clusterLockMap.get(cluster.getId()).getQueueLength() > threshold;
    if (crossedThreshold) {
        log.info("Scheduler: skipping whinging hosts in cluster '{}', since there are more than '{}' parallel requests", cluster.getName(), threshold);
    }
    return vdsList.size() > 1 && !crossedThreshold;
}
#end_block

#method_before
protected Map<String, String> createClusterPolicyParameters(VDSGroup cluster) {
    Map<String, String> parameters = new HashMap<>();
    if (cluster.getClusterPolicyProperties() != null) {
        parameters.putAll(cluster.getClusterPolicyProperties());
    }
    return parameters;
}
#method_after
private Map<String, String> createClusterPolicyParameters(VDSGroup cluster) {
    Map<String, String> parameters = new HashMap<>();
    if (cluster.getClusterPolicyProperties() != null) {
        parameters.putAll(cluster.getClusterPolicyProperties());
    }
    return parameters;
}
#end_block

#method_before
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<>();
        Set<Guid> listSet = new HashSet<>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#method_after
private void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<>();
        Set<Guid> listSet = new HashSet<>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#end_block

#method_before
protected Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#method_after
private Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#end_block

#method_before
protected VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#method_after
private VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#end_block

#method_before
protected VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#method_after
private VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#end_block

#method_before
protected PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#method_after
private PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#end_block

#method_before
protected ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#method_after
private ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#end_block

#method_before
public void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#method_after
private void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#end_block

#method_before
public void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#method_after
private void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#end_block

#method_before
private static void removeNetworkFromHosts(Network network, CommandContext context, List<VdsNetworkInterface> nics) {
    final ManagementNetworkUtil managementNetworkUtil = Injector.get(ManagementNetworkUtil.class);
    InterfaceDao interfaceDao = Injector.get(InterfaceDao.class);
    VdsStaticDao vdsStaticDao = Injector.get(VdsStaticDao.class);
    NetworkClusterDao networkClusterDao = Injector.get(NetworkClusterDao.class);
    NetworkAttachmentDao networkAttachmentDao = Injector.get(NetworkAttachmentDao.class);
    RemoveNetworkParametersBuilder builder = new RemoveNetworkParametersBuilder(network, context, managementNetworkUtil, interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(nics);
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        Backend.getInstance().runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters, context);
    }
}
#method_after
private static void removeNetworkFromHosts(Network network, CommandContext context, List<VdsNetworkInterface> nics) {
    RemoveNetworkParametersBuilder builder = Injector.get(RemoveNetworkParametersBuilder.class);
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(network, nics);
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        Backend.getInstance().runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters, context);
    }
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder(getContext());
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters);
    }
}
#end_block

#method_before
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !labelChanged();
    return !getNetwork().isExternal() && (labelNotChanged || labelAdded());
}
#method_after
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !labelChanged(getNetwork(), getOldNetwork());
    return !getNetwork().isExternal() && (labelNotChanged || labelAdded(getNetwork(), getOldNetwork()));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded() || labelRenamed()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = interfaceDao.getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged(network, oldNetwork)) {
        createSyncNetworkParameters(network, parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded(network, oldNetwork) || labelRenamed(network, oldNetwork)) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(network, nicsForAdd));
        createSyncNetworkParameters(network, parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved(network, oldNetwork)) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(network, nicsForRemove));
        createSyncNetworkParameters(network, parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createAddNetworkParameters(List<VdsNetworkInterface> nicsForAdd) {
    AddNetworkParametersBuilder builder = new AddNetworkParametersBuilder(getNetwork(), getContext(), interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    return builder.buildParameters(nicsForAdd);
}
#method_after
private ArrayList<VdcActionParametersBase> createAddNetworkParameters(Network network, List<VdsNetworkInterface> nicsForAdd) {
    return addNetworkParametersBuilder.buildParameters(network, nicsForAdd);
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createRemoveNetworkParameters(List<VdsNetworkInterface> nicsForRemove) {
    RemoveNetworkParametersBuilder builder = new RemoveNetworkParametersBuilder(getOldNetwork(), getContext(), managementNetworkUtil, interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    return builder.buildParameters(nicsForRemove);
}
#method_after
private ArrayList<VdcActionParametersBase> createRemoveNetworkParameters(Network oldNetwork, List<VdsNetworkInterface> nicsForRemove) {
    return removeNetworkParametersBuilder.buildParameters(oldNetwork, nicsForRemove);
}
#end_block

#method_before
private List<VdsNetworkInterface> getLabeledNics(Network network) {
    List<NetworkCluster> clusters = getNetworkClusterDao().getAllForNetwork(network.getId());
    List<VdsNetworkInterface> labeledNics = new ArrayList<>();
    for (NetworkCluster networkCluster : clusters) {
        labeledNics.addAll(getDbFacade().getInterfaceDao().getAllInterfacesByLabelForCluster(networkCluster.getClusterId(), network.getLabel()));
    }
    return labeledNics;
}
#method_after
private List<VdsNetworkInterface> getLabeledNics(Network network) {
    List<NetworkCluster> clusters = networkClusterDao.getAllForNetwork(network.getId());
    List<VdsNetworkInterface> labeledNics = new ArrayList<>();
    for (NetworkCluster networkCluster : clusters) {
        labeledNics.addAll(interfaceDao.getAllInterfacesByLabelForCluster(networkCluster.getClusterId(), network.getLabel()));
    }
    return labeledNics;
}
#end_block

#method_before
private void createSyncNetworkParameters(ArrayList<VdcActionParametersBase> parameters, Collection<VdsNetworkInterface> nics) {
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(nic, getNetwork());
        boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkShouldBeSynced) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworkNames(getNetworkName());
        NetworkAttachment attachment = getNetworkToAttachment(hostId).get(getNetwork().getId());
        attachment.setOverrideConfiguration(true);
        setupNetworkParams.getNetworkAttachments().add(attachment);
        parameters.add(setupNetworkParams);
    }
}
#method_after
private void createSyncNetworkParameters(Network network, ArrayList<VdcActionParametersBase> parameters, Collection<VdsNetworkInterface> nics) {
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(nic, network);
        boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkShouldBeSynced) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworkNames(network.getName());
        NetworkAttachment attachment = getNetworkToAttachment(hostId).get(network.getId());
        attachment.setOverrideConfiguration(true);
        setupNetworkParams.getNetworkAttachments().add(attachment);
        parameters.add(setupNetworkParams);
    }
}
#end_block

#method_before
private boolean labelChanged() {
    return !Objects.equals(getNetwork().getLabel(), getOldNetwork().getLabel());
}
#method_after
private static boolean labelChanged(Network network, Network oldNetwork) {
    return !Objects.equals(network.getLabel(), oldNetwork.getLabel());
}
#end_block

#method_before
private boolean labelAdded() {
    return !NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork());
}
#method_after
private static boolean labelAdded(Network network, Network oldNetwork) {
    return !NetworkUtils.isLabeled(oldNetwork) && NetworkUtils.isLabeled(network);
}
#end_block

#method_before
private boolean labelRemoved() {
    return NetworkUtils.isLabeled(getOldNetwork()) && !NetworkUtils.isLabeled(getNetwork());
}
#method_after
private static boolean labelRemoved(Network network, Network oldNetwork) {
    return NetworkUtils.isLabeled(oldNetwork) && !NetworkUtils.isLabeled(network);
}
#end_block

#method_before
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && labelChanged();
}
#method_after
private static boolean labelRenamed(Network network, Network oldNetwork) {
    return NetworkUtils.isLabeled(oldNetwork) && NetworkUtils.isLabeled(network) && labelChanged(network, oldNetwork);
}
#end_block

#method_before
public ArrayList<VdcActionParametersBase> buildParameters(List<VdsNetworkInterface> nics) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (VdsNetworkInterface nic : nics) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(nic.getVdsId());
        setupNetworkParams.setNetworkNames(network.getName());
        VdsNetworkInterface nicToConfigure = getNicToConfigure(getNics(nic.getVdsId()), nic.getId());
        if (nicToConfigure == null) {
            throw new EngineException(EngineError.LABELED_NETWORK_INTERFACE_NOT_FOUND);
        }
        NetworkAttachment networkAttachment = NetworkUtils.createNetworkAttachment(nicToConfigure, getVlanDevice(nicToConfigure, network.getVlanId()), network);
        setupNetworkParams.getNetworkAttachments().add(networkAttachment);
        addBootProtocolForRoleNetworkAttachment(nicToConfigure, network, networkAttachment);
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
public ArrayList<VdcActionParametersBase> buildParameters(Network network, List<VdsNetworkInterface> nics) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (VdsNetworkInterface nic : nics) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(nic.getVdsId());
        setupNetworkParams.setNetworkNames(network.getName());
        VdsNetworkInterface nicToConfigure = getNicToConfigure(getNics(nic.getVdsId()), nic.getId());
        if (nicToConfigure == null) {
            throw new EngineException(EngineError.LABELED_NETWORK_INTERFACE_NOT_FOUND);
        }
        NetworkAttachment networkAttachment = new NetworkAttachment(nicToConfigure, network, NetworkUtils.createIpConfigurationFromVdsNetworkInterface(getVlanDevice(nicToConfigure, network.getVlanId())));
        setupNetworkParams.getNetworkAttachments().add(networkAttachment);
        addBootProtocolForRoleNetworkAttachment(nicToConfigure, network, networkAttachment);
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#end_block

#method_before
public ArrayList<VdcActionParametersBase> buildParameters(List<VdsNetworkInterface> nics) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    if (managementNetworkUtil.isManagementNetwork(network.getId())) {
        return parameters;
    }
    for (VdsNetworkInterface nic : nics) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(nic.getVdsId());
        setupNetworkParams.setNetworkNames(network.getName());
        Map<String, VdsNetworkInterface> nicByNetwork = Entities.hostInterfacesByNetworkName(getNics(nic.getVdsId()));
        VdsNetworkInterface nicToConfigure = getNicToConfigure(getNics(nic.getVdsId()), nic.getId());
        if (nicToConfigure == null) {
            throw new EngineException(EngineError.LABELED_NETWORK_INTERFACE_NOT_FOUND);
        }
        NetworkAttachment networkAttachment = getNetworkToAttachment(nic.getVdsId()).get(network.getId());
        if (networkAttachment != null && networkAttachment.getNicId().equals(nicToConfigure.getId())) {
            setupNetworkParams.getRemovedNetworkAttachments().add(networkAttachment.getId());
        } else {
            VdsNetworkInterface nicWithNetwork = nicByNetwork.get(network.getName());
            if (nicWithNetwork != null && NetworkUtils.stripVlan(nicWithNetwork).equals(nic.getName())) {
                setupNetworkParams.getRemovedUnmanagedNetworks().add(network.getName());
            }
        }
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
public ArrayList<VdcActionParametersBase> buildParameters(Network network, List<VdsNetworkInterface> labeledNics) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    if (managementNetworkUtil.isManagementNetwork(network.getId())) {
        return parameters;
    }
    for (VdsNetworkInterface nic : labeledNics) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(nic.getVdsId());
        setupNetworkParams.setNetworkNames(network.getName());
        Map<String, VdsNetworkInterface> nicByNetworkName = Entities.hostInterfacesByNetworkName(getNics(nic.getVdsId()));
        VdsNetworkInterface nicToConfigure = getNicToConfigure(getNics(nic.getVdsId()), nic.getId());
        if (nicToConfigure == null) {
            throw new EngineException(EngineError.LABELED_NETWORK_INTERFACE_NOT_FOUND);
        }
        NetworkAttachment networkAttachment = getNetworkToAttachment(nic.getVdsId()).get(network.getId());
        if (networkAttachment != null) {
            if (networkAttachment.getNicId().equals(nicToConfigure.getId())) {
                setupNetworkParams.getRemovedNetworkAttachments().add(networkAttachment.getId());
            }
        } else {
            VdsNetworkInterface nicWithNetwork = nicByNetworkName.get(network.getName());
            if (nicWithNetwork != null && NetworkUtils.stripVlan(nicWithNetwork).equals(nic.getName())) {
                setupNetworkParams.getRemovedUnmanagedNetworks().add(network.getName());
            }
        }
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#end_block

#method_before
protected void addAttachmentToParameters(VdsNetworkInterface baseNic, Network network, PersistentHostSetupNetworksParameters params) {
    NetworkAttachment attachmentToConfigure = getNetworkToAttachment(baseNic.getVdsId()).get(network.getId());
    if (attachmentToConfigure == null) {
        // The network is not attached to the host, attach it to the nic with the label
        attachmentToConfigure = NetworkUtils.createNetworkAttachment(baseNic, getVlanDevice(baseNic, network.getVlanId()), network);
    } else if (!attachmentToConfigure.getNicId().equals(baseNic.getId())) {
        // Move the attachment to the nic with the label
        attachmentToConfigure.setNicId(baseNic.getId());
        attachmentToConfigure.setNicName(baseNic.getName());
    }
    addBootProtocolForRoleNetworkAttachment(baseNic, network, attachmentToConfigure);
    params.getNetworkAttachments().add(attachmentToConfigure);
}
#method_after
protected void addAttachmentToParameters(VdsNetworkInterface baseNic, Network network, PersistentHostSetupNetworksParameters params) {
    NetworkAttachment attachmentToConfigure = getNetworkToAttachment(baseNic.getVdsId()).get(network.getId());
    if (attachmentToConfigure == null) {
        // The network is not attached to the host, attach it to the nic with the label
        attachmentToConfigure = new NetworkAttachment(baseNic, network, NetworkUtils.createIpConfigurationFromVdsNetworkInterface(getVlanDevice(baseNic, network.getVlanId())));
    } else if (!attachmentToConfigure.getNicId().equals(baseNic.getId())) {
        // Move the attachment to the nic with the label
        attachmentToConfigure.setNicId(baseNic.getId());
        attachmentToConfigure.setNicName(baseNic.getName());
    }
    addBootProtocolForRoleNetworkAttachment(baseNic, network, attachmentToConfigure);
    params.getNetworkAttachments().add(attachmentToConfigure);
}
#end_block

#method_before
protected VdsNetworkInterface getVlanDevice(final VdsNetworkInterface baseNic, final Integer vlanId) {
    if (vlanId == null) {
        return null;
    }
    return LinqUtils.firstOrNull(getNics(baseNic.getVdsId()), new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface t) {
            return (baseNic.getName().equals(t.getBaseInterface()) && ObjectUtils.objectsEqual(t.getVlanId(), vlanId));
        }
    });
}
#method_after
protected VdsNetworkInterface getVlanDevice(final VdsNetworkInterface baseNic, final Integer vlanId) {
    if (vlanId == null) {
        return null;
    }
    return LinqUtils.firstOrNull(getNics(baseNic.getVdsId()), new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface t) {
            return (baseNic.getName().equals(t.getBaseInterface()) && Objects.equals(t.getVlanId(), vlanId));
        }
    });
}
#end_block

#method_before
public List<VdsNetworkInterface> getNics(Guid hostId) {
    if (!hostIdToNics.containsKey(hostId)) {
        VDS host = new VDS();
        host.setId(hostId);
        NetworkConfigurator configurator = new NetworkConfigurator(host, commandContext);
        hostIdToNics.put(hostId, configurator.filterBondsWithoutSlaves(interfaceDao.getAllInterfacesForVds(hostId)));
    }
    return hostIdToNics.get(hostId);
}
#method_after
public List<VdsNetworkInterface> getNics(Guid hostId) {
    if (!hostIdToNics.containsKey(hostId)) {
        VDS host = new VDS();
        host.setId(hostId);
        NetworkConfigurator configurator = new NetworkConfigurator(host, null);
        hostIdToNics.put(hostId, configurator.filterBondsWithoutSlaves(interfaceDao.getAllInterfacesForVds(hostId)));
    }
    return hostIdToNics.get(hostId);
}
#end_block

#method_before
private void configureNetworks() {
    ChangeClusterParametersBuilder builder = new ChangeClusterParametersBuilder(getContext());
    final PersistentHostSetupNetworksParameters params;
    try {
        params = builder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (EngineException e) {
        auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentHostSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#method_after
private void configureNetworks() {
    final PersistentHostSetupNetworksParameters params;
    try {
        params = changeClusterParametersBuilder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (EngineException e) {
        auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentHostSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#end_block

#method_before
private void removeNetworksNoLongerAttachedViaLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic, String label) {
    List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
    if (sourceLabeledNetworks != null) {
        for (Network sourceLabeledNetwork : sourceLabeledNetworks) {
            String networkName = sourceLabeledNetwork.getName();
            if (isNetworkAssignedToNic(nic, networkName, nicsByNetwork)) {
                // The network was attached to the nic via label (in the source cluster)
                if (!isNetworkAssignedToCluster(targetNetworksByName, networkName)) {
                    // the network is not attached to the target cluster- should be removed from the host
                    params.getRemovedUnmanagedNetworks().add(networkName);
                } else if (isAttachmentShouldBeRemoved(networkName, targetNetworksByName)) {
                    // the target network doesn't have label that exist on the host
                    Network targetNetwork = targetNetworksByName.get(networkName);
                    NetworkAttachment attachment = getNetworkToAttachment(nic.getVdsId()).get(targetNetwork.getId());
                    params.getRemovedNetworkAttachments().add(attachment.getId());
                }
            }
        }
    }
}
#method_after
private void removeNetworksNoLongerAttachedViaLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic, String label) {
    List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
    if (sourceLabeledNetworks != null) {
        for (Network sourceLabeledNetwork : sourceLabeledNetworks) {
            String networkName = sourceLabeledNetwork.getName();
            if (isNetworkAssignedToNic(nic, networkName, nicsByNetwork)) {
                // The network was attached to the nic via label (in the source cluster)
                if (!isNetworkAssignedToTargetCluster(targetNetworksByName, networkName)) {
                    // the network is not attached to the target cluster- should be removed from the host
                    params.getRemovedUnmanagedNetworks().add(networkName);
                } else if (!isNetworkLabelExistInTargetHost(nic.getVdsId(), networkName, targetNetworksByName)) {
                    // the target network doesn't have label that exist on the host
                    Network targetNetwork = targetNetworksByName.get(networkName);
                    NetworkAttachment attachment = getNetworkToAttachment(nic.getVdsId()).get(targetNetwork.getId());
                    params.getRemovedNetworkAttachments().add(attachment.getId());
                }
            }
        }
    }
}
#end_block

#method_before
private boolean isHostContainLabel(String label) {
    for (VdsNetworkInterface nic : getNics(getVdsId())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(label)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isHostContainLabel(Guid hostId, String label) {
    for (VdsNetworkInterface nic : getNics(hostId)) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(label)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public ManageLabeledNetworksParametersBuilder create(CommandContext commandContext, InterfaceDao interfaceDao, VdsStaticDao vdsStaticDao, NetworkClusterDao networkClusterDao, NetworkAttachmentDao networkAttachmentDao) {
    return new ManageLabeledNetworksParametersBuilderImpl(commandContext, interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
}
#method_after
public ManageLabeledNetworksParametersBuilder create(CommandContext commandContext, InterfaceDao interfaceDao, VdsStaticDao vdsStaticDao, NetworkClusterDao networkClusterDao, NetworkAttachmentDao networkAttachmentDao) {
    return Injector.get(ManageLabeledNetworksParametersBuilderImpl.class);
}
#end_block

#method_before
private PersistentHostSetupNetworksParameters combine(PersistentHostSetupNetworksParameters addSetupNetworksParameters, PersistentHostSetupNetworksParameters removeSetupNetworksParameters) {
    Guid hostId = addSetupNetworksParameters.getVdsId();
    final PersistentHostSetupNetworksParameters resultParam = createHostSetupNetworksParameters(hostId);
    extendParamters(resultParam, addSetupNetworksParameters);
    extendParamters(resultParam, removeSetupNetworksParameters);
    return resultParam;
}
#method_after
private PersistentHostSetupNetworksParameters combine(PersistentHostSetupNetworksParameters addSetupNetworksParameters, PersistentHostSetupNetworksParameters removeSetupNetworksParameters) {
    Guid hostId = addSetupNetworksParameters.getVdsId();
    final PersistentHostSetupNetworksParameters resultParam = createHostSetupNetworksParameters(hostId);
    extendParameters(resultParam, addSetupNetworksParameters);
    extendParameters(resultParam, removeSetupNetworksParameters);
    return resultParam;
}
#end_block

#method_before
protected void addAttachmentToParameters(VdsNetworkInterface baseNic, Network network, PersistentHostSetupNetworksParameters params) {
    NetworkAttachment attachmentToConfigure = getNetworkIdToAttachmentMap(baseNic.getVdsId()).get(network.getId());
    if (attachmentToConfigure == null) {
        // The network is not attached to the host, attach it to the nic with the label
        attachmentToConfigure = NetworkUtils.createNetworkAttachment(baseNic, getVlanDevice(baseNic, network.getVlanId()), network);
    } else if (!attachmentToConfigure.getNicId().equals(baseNic.getId())) {
        // Move the attachment to the nic with the label
        attachmentToConfigure.setNicId(baseNic.getId());
        attachmentToConfigure.setNicName(baseNic.getName());
    }
    addBootProtocolForRoleNetworkAttachment(baseNic, network, attachmentToConfigure);
    params.getNetworkAttachments().add(attachmentToConfigure);
}
#method_after
protected void addAttachmentToParameters(VdsNetworkInterface baseNic, Network network, PersistentHostSetupNetworksParameters params) {
    NetworkAttachment attachmentToConfigure = getNetworkIdToAttachmentMap(baseNic.getVdsId()).get(network.getId());
    if (attachmentToConfigure == null) {
        // The network is not attached to the host, attach it to the nic with the label
        attachmentToConfigure = new NetworkAttachment(baseNic, network, NetworkUtils.createIpConfigurationFromVdsNetworkInterface(getVlanDevice(baseNic, network.getVlanId())));
    } else if (!attachmentToConfigure.getNicId().equals(baseNic.getId())) {
        // Move the attachment to the nic with the label
        attachmentToConfigure.setNicId(baseNic.getId());
        attachmentToConfigure.setNicName(baseNic.getName());
    }
    addBootProtocolForRoleNetworkAttachment(baseNic, network, attachmentToConfigure);
    params.getNetworkAttachments().add(attachmentToConfigure);
}
#end_block

#method_before
protected VdsNetworkInterface getVlanDevice(final VdsNetworkInterface baseNic, final Integer vlanId) {
    if (vlanId == null) {
        return null;
    }
    return LinqUtils.firstOrNull(getNics(baseNic.getVdsId()), new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface t) {
            return (baseNic.getName().equals(t.getBaseInterface()) && ObjectUtils.objectsEqual(t.getVlanId(), vlanId));
        }
    });
}
#method_after
protected VdsNetworkInterface getVlanDevice(final VdsNetworkInterface baseNic, final Integer vlanId) {
    if (vlanId == null) {
        return null;
    }
    return LinqUtils.firstOrNull(getNics(baseNic.getVdsId()), new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface t) {
            return (baseNic.getName().equals(t.getBaseInterface()) && Objects.equals(t.getVlanId(), vlanId));
        }
    });
}
#end_block

#method_before
public List<VdsNetworkInterface> getNics(Guid hostId) {
    if (!hostIdToNics.containsKey(hostId)) {
        VDS host = new VDS();
        host.setId(hostId);
        NetworkConfigurator configurator = new NetworkConfigurator(host, commandContext);
        hostIdToNics.put(hostId, configurator.filterBondsWithoutSlaves(interfaceDao.getAllInterfacesForVds(hostId)));
    }
    return hostIdToNics.get(hostId);
}
#method_after
public List<VdsNetworkInterface> getNics(Guid hostId) {
    if (!hostIdToNics.containsKey(hostId)) {
        VDS host = new VDS();
        host.setId(hostId);
        NetworkConfigurator configurator = new NetworkConfigurator(host, null);
        hostIdToNics.put(hostId, configurator.filterBondsWithoutSlaves(interfaceDao.getAllInterfacesForVds(hostId)));
    }
    return hostIdToNics.get(hostId);
}
#end_block

#method_before
public ArrayList<VdcActionParametersBase> buildParameters(List<VdsNetworkInterface> nics) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    if (managementNetworkUtil.isManagementNetwork(network.getId())) {
        return parameters;
    }
    for (VdsNetworkInterface nic : nics) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(nic.getVdsId());
        setupNetworkParams.setNetworkNames(network.getName());
        Map<String, VdsNetworkInterface> nicByNetwork = Entities.hostInterfacesByNetworkName(getNics(nic.getVdsId()));
        VdsNetworkInterface nicToConfigure = getNicToConfigure(getNics(nic.getVdsId()), nic.getId());
        if (nicToConfigure == null) {
            throw new EngineException(EngineError.LABELED_NETWORK_INTERFACE_NOT_FOUND);
        }
        NetworkAttachment networkAttachment = getNetworkIdToAttachmentMap(nic.getVdsId()).get(network.getId());
        if (networkAttachment != null && networkAttachment.getNicId().equals(nicToConfigure.getId())) {
            setupNetworkParams.getRemovedNetworkAttachments().add(networkAttachment.getId());
        } else {
            VdsNetworkInterface nicWithNetwork = nicByNetwork.get(network.getName());
            if (nicWithNetwork != null && NetworkUtils.stripVlan(nicWithNetwork).equals(nic.getName())) {
                setupNetworkParams.getRemovedUnmanagedNetworks().add(network.getName());
            }
        }
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
public ArrayList<VdcActionParametersBase> buildParameters(Network network, List<VdsNetworkInterface> labeledNics) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    if (managementNetworkUtil.isManagementNetwork(network.getId())) {
        return parameters;
    }
    for (VdsNetworkInterface nic : labeledNics) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(nic.getVdsId());
        setupNetworkParams.setNetworkNames(network.getName());
        Map<String, VdsNetworkInterface> nicByNetworkName = Entities.hostInterfacesByNetworkName(getNics(nic.getVdsId()));
        VdsNetworkInterface nicToConfigure = getNicToConfigure(getNics(nic.getVdsId()), nic.getId());
        if (nicToConfigure == null) {
            throw new EngineException(EngineError.LABELED_NETWORK_INTERFACE_NOT_FOUND);
        }
        NetworkAttachment networkAttachment = getNetworkIdToAttachmentMap(nic.getVdsId()).get(network.getId());
        if (networkAttachment != null) {
            if (networkAttachment.getNicId().equals(nicToConfigure.getId())) {
                setupNetworkParams.getRemovedNetworkAttachments().add(networkAttachment.getId());
            }
        } else {
            VdsNetworkInterface nicWithNetwork = nicByNetworkName.get(network.getName());
            if (nicWithNetwork != null && NetworkUtils.stripVlan(nicWithNetwork).equals(nic.getName())) {
                setupNetworkParams.getRemovedUnmanagedNetworks().add(network.getName());
            }
        }
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder(getContext());
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters);
    }
}
#end_block

#method_before
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !labelChanged();
    return !getNetwork().isExternal() && (labelNotChanged || labelAdded());
}
#method_after
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !labelChanged(getNetwork(), getOldNetwork());
    return !getNetwork().isExternal() && (labelNotChanged || labelAdded(getNetwork(), getOldNetwork()));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded() || labelRenamed()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = interfaceDao.getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged(network, oldNetwork)) {
        createSyncNetworkParameters(network, parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded(network, oldNetwork) || labelRenamed(network, oldNetwork)) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(network, nicsForAdd));
        createSyncNetworkParameters(network, parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved(network, oldNetwork)) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(network, nicsForRemove));
        createSyncNetworkParameters(network, parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createAddNetworkParameters(List<VdsNetworkInterface> nicsForAdd) {
    AddNetworkParametersBuilder builder = new AddNetworkParametersBuilder(getNetwork(), getContext(), interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    return builder.buildParameters(nicsForAdd);
}
#method_after
private ArrayList<VdcActionParametersBase> createAddNetworkParameters(Network network, List<VdsNetworkInterface> nicsForAdd) {
    return addNetworkParametersBuilder.buildParameters(network, nicsForAdd);
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createRemoveNetworkParameters(List<VdsNetworkInterface> nicsForRemove) {
    RemoveNetworkParametersBuilder builder = new RemoveNetworkParametersBuilder(getOldNetwork(), getContext(), managementNetworkUtil, interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    return builder.buildParameters(nicsForRemove);
}
#method_after
private ArrayList<VdcActionParametersBase> createRemoveNetworkParameters(Network oldNetwork, List<VdsNetworkInterface> nicsForRemove) {
    return removeNetworkParametersBuilder.buildParameters(oldNetwork, nicsForRemove);
}
#end_block

#method_before
private List<VdsNetworkInterface> getLabeledNics(Network network) {
    List<NetworkCluster> clusters = getNetworkClusterDao().getAllForNetwork(network.getId());
    List<VdsNetworkInterface> labeledNics = new ArrayList<>();
    for (NetworkCluster networkCluster : clusters) {
        labeledNics.addAll(getDbFacade().getInterfaceDao().getAllInterfacesByLabelForCluster(networkCluster.getClusterId(), network.getLabel()));
    }
    return labeledNics;
}
#method_after
private List<VdsNetworkInterface> getLabeledNics(Network network) {
    List<NetworkCluster> clusters = networkClusterDao.getAllForNetwork(network.getId());
    List<VdsNetworkInterface> labeledNics = new ArrayList<>();
    for (NetworkCluster networkCluster : clusters) {
        labeledNics.addAll(interfaceDao.getAllInterfacesByLabelForCluster(networkCluster.getClusterId(), network.getLabel()));
    }
    return labeledNics;
}
#end_block

#method_before
private void createSyncNetworkParameters(ArrayList<VdcActionParametersBase> parameters, Collection<VdsNetworkInterface> nics) {
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(nic, getNetwork());
        boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkShouldBeSynced) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworkNames(getNetworkName());
        NetworkAttachment attachment = getNetworkIdToAttachmentMap(hostId).get(getNetwork().getId());
        attachment.setOverrideConfiguration(true);
        setupNetworkParams.getNetworkAttachments().add(attachment);
        parameters.add(setupNetworkParams);
    }
}
#method_after
private void createSyncNetworkParameters(Network network, ArrayList<VdcActionParametersBase> parameters, Collection<VdsNetworkInterface> nics) {
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(nic, network);
        boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkShouldBeSynced) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworkNames(network.getName());
        NetworkAttachment attachment = getNetworkIdToAttachmentMap(hostId).get(network.getId());
        attachment.setOverrideConfiguration(true);
        setupNetworkParams.getNetworkAttachments().add(attachment);
        parameters.add(setupNetworkParams);
    }
}
#end_block

#method_before
private boolean labelChanged() {
    return !Objects.equals(getNetwork().getLabel(), getOldNetwork().getLabel());
}
#method_after
private static boolean labelChanged(Network network, Network oldNetwork) {
    return !Objects.equals(network.getLabel(), oldNetwork.getLabel());
}
#end_block

#method_before
private boolean labelAdded() {
    return !NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork());
}
#method_after
private static boolean labelAdded(Network network, Network oldNetwork) {
    return !NetworkUtils.isLabeled(oldNetwork) && NetworkUtils.isLabeled(network);
}
#end_block

#method_before
private boolean labelRemoved() {
    return NetworkUtils.isLabeled(getOldNetwork()) && !NetworkUtils.isLabeled(getNetwork());
}
#method_after
private static boolean labelRemoved(Network network, Network oldNetwork) {
    return NetworkUtils.isLabeled(oldNetwork) && !NetworkUtils.isLabeled(network);
}
#end_block

#method_before
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && labelChanged();
}
#method_after
private static boolean labelRenamed(Network network, Network oldNetwork) {
    return NetworkUtils.isLabeled(oldNetwork) && NetworkUtils.isLabeled(network) && labelChanged(network, oldNetwork);
}
#end_block

#method_before
private void configureNetworks() {
    ChangeClusterParametersBuilder builder = new ChangeClusterParametersBuilder(getContext());
    final PersistentHostSetupNetworksParameters params;
    try {
        params = builder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (EngineException e) {
        auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentHostSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#method_after
private void configureNetworks() {
    final PersistentHostSetupNetworksParameters params;
    try {
        params = changeClusterParametersBuilder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (EngineException e) {
        auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentHostSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#end_block

#method_before
private void removeNetworksNoLongerAttachedViaLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic, String label) {
    List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
    if (sourceLabeledNetworks != null) {
        for (Network sourceLabeledNetwork : sourceLabeledNetworks) {
            String networkName = sourceLabeledNetwork.getName();
            if (isNetworkAssignedToNic(nic, networkName, nicsByNetwork)) {
                // The network was attached to the nic via label (in the source cluster)
                if (!isNetworkAssignedToCluster(targetNetworksByName, networkName)) {
                    // the network is not attached to the target cluster- should be removed from the host
                    params.getRemovedUnmanagedNetworks().add(networkName);
                } else if (isAttachmentShouldBeRemoved(networkName, targetNetworksByName)) {
                    // the target network doesn't have label that exist on the host
                    Network targetNetwork = targetNetworksByName.get(networkName);
                    NetworkAttachment attachment = getNetworkIdToAttachmentMap(nic.getVdsId()).get(targetNetwork.getId());
                    params.getRemovedNetworkAttachments().add(attachment.getId());
                }
            }
        }
    }
}
#method_after
private void removeNetworksNoLongerAttachedViaLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic, String label) {
    List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
    if (sourceLabeledNetworks != null) {
        for (Network sourceLabeledNetwork : sourceLabeledNetworks) {
            String networkName = sourceLabeledNetwork.getName();
            if (isNetworkAssignedToNic(nic, networkName, nicsByNetwork)) {
                // The network was attached to the nic via label (in the source cluster)
                if (!isNetworkAssignedToTargetCluster(targetNetworksByName, networkName)) {
                    // the network is not attached to the target cluster- should be removed from the host
                    params.getRemovedUnmanagedNetworks().add(networkName);
                } else if (!isNetworkLabelExistInTargetHost(nic.getVdsId(), networkName, targetNetworksByName)) {
                    // the target network doesn't have label that exist on the host
                    Network targetNetwork = targetNetworksByName.get(networkName);
                    NetworkAttachment attachment = getNetworkIdToAttachmentMap(nic.getVdsId()).get(targetNetwork.getId());
                    params.getRemovedNetworkAttachments().add(attachment.getId());
                }
            }
        }
    }
}
#end_block

#method_before
private boolean isHostContainLabel(String label) {
    for (VdsNetworkInterface nic : getNics(getVdsId())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(label)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isHostContainLabel(Guid hostId, String label) {
    for (VdsNetworkInterface nic : getNics(hostId)) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(label)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected void addAttachmentToParameters(VdsNetworkInterface baseNic, Network network, PersistentHostSetupNetworksParameters params) {
    NetworkAttachment attachmentToConfigure = getNetworkToAttachment().get(network.getId());
    if (attachmentToConfigure == null) {
        // The network is not attached to the host, attach it to the nic with the label
        attachmentToConfigure = NetworkUtils.createNetworkAttachment(baseNic, getVlanDevice(baseNic, network.getVlanId()), network);
    } else if (!attachmentToConfigure.getNicId().equals(baseNic.getId())) {
        // Move the attachment to the nic with the label
        attachmentToConfigure.setNicId(baseNic.getId());
        attachmentToConfigure.setNicName(baseNic.getName());
    }
    addBootProtocolForRoleNetworkAttachment(baseNic, network, attachmentToConfigure);
    params.getNetworkAttachments().add(attachmentToConfigure);
}
#method_after
protected void addAttachmentToParameters(VdsNetworkInterface baseNic, Network network, PersistentHostSetupNetworksParameters params) {
    NetworkAttachment attachmentToConfigure = getNetworkToAttachment().get(network.getId());
    if (attachmentToConfigure == null) {
        // The network is not attached to the host, attach it to the nic with the label
        attachmentToConfigure = new NetworkAttachment(baseNic, network, NetworkUtils.createIpConfigurationFromVdsNetworkInterface(getVlanDevice(baseNic, network.getVlanId())));
    } else if (!attachmentToConfigure.getNicId().equals(baseNic.getId())) {
        // Move the attachment to the nic with the label
        attachmentToConfigure.setNicId(baseNic.getId());
        attachmentToConfigure.setNicName(baseNic.getName());
    }
    addBootProtocolForRoleNetworkAttachment(baseNic, network, attachmentToConfigure);
    params.getNetworkAttachments().add(attachmentToConfigure);
}
#end_block

#method_before
private VdsNetworkInterface getVlanDevice(final VdsNetworkInterface baseNic, final Integer vlanId) {
    if (vlanId == null) {
        return null;
    }
    return LinqUtils.firstOrNull(getNics(), new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface t) {
            return (baseNic.getName().equals(t.getBaseInterface()) && ObjectUtils.objectsEqual(t.getVlanId(), vlanId));
        }
    });
}
#method_after
private VdsNetworkInterface getVlanDevice(final VdsNetworkInterface baseNic, final Integer vlanId) {
    if (vlanId == null) {
        return null;
    }
    return LinqUtils.firstOrNull(getNics(), new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface t) {
            return (baseNic.getName().equals(t.getBaseInterface()) && Objects.equals(t.getVlanId(), vlanId));
        }
    });
}
#end_block

#method_before
private static IpConfiguration createIpConfigurationFromVdsNetworkInterface(VdsNetworkInterface nic) {
    if (nic == null) {
        return null;
    }
    IPv4Address iPv4Address = new IPv4Address();
    iPv4Address.setAddress(nic.getAddress());
    iPv4Address.setNetmask(nic.getSubnet());
    iPv4Address.setGateway(nic.getGateway());
    iPv4Address.setBootProtocol(nic.getBootProtocol());
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setIPv4Addresses(Collections.singletonList(iPv4Address));
    return ipConfiguration;
}
#method_after
public static IpConfiguration createIpConfigurationFromVdsNetworkInterface(VdsNetworkInterface nic) {
    if (nic == null) {
        return null;
    }
    IPv4Address iPv4Address = new IPv4Address();
    iPv4Address.setAddress(nic.getAddress());
    iPv4Address.setNetmask(nic.getSubnet());
    iPv4Address.setGateway(nic.getGateway());
    iPv4Address.setBootProtocol(nic.getBootProtocol());
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setIPv4Addresses(Collections.singletonList(iPv4Address));
    return ipConfiguration;
}
#end_block

#method_before
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (!NetworkUtils.isLabeled(nic)) {
        return;
    }
    for (String label : nic.getLabels()) {
        removeNetworksNoLongerAttachedViaLabel(sourceNetworksByLabel, targetNetworksByName, params, nicsByNetwork, nic, label);
        addNetworksThatShouldBeAttachedViaLabel(targetNetworksByName, targetNetworksByLabel, params, nicsByNetwork, nic, label);
    }
}
#method_after
private void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (!NetworkUtils.isLabeled(nic)) {
        return;
    }
    for (String label : nic.getLabels()) {
        removeNetworksNoLongerAttachedViaLabel(sourceNetworksByLabel, targetNetworksByName, params, nicsByNetwork, nic, label);
        addNetworksThatShouldBeAttachedViaLabel(targetNetworksByName, targetNetworksByLabel, params, nicsByNetwork, nic, label);
    }
}
#end_block

#method_before
private void removeNetworksNoLongerAttachedViaLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic, String label) {
    List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
    if (sourceLabeledNetworks != null) {
        for (Network sourceLabeledNetwork : sourceLabeledNetworks) {
            String networkName = sourceLabeledNetwork.getName();
            if (isNetworkAssignedToNic(nic, networkName, nicsByNetwork)) {
                // The network was attached to the nic via label (in the source cluster)
                if (!isNetworkAssignedToCluster(targetNetworksByName, networkName)) {
                    // the network is not attached to the target cluster- should be removed from the host
                    params.getRemovedUnmanagedNetworks().add(networkName);
                } else if (isAttachmentShouldBeRemoved(networkName, targetNetworksByName)) {
                    // the target network doesn't have label that exist on the host
                    Network targetNetwork = targetNetworksByName.get(networkName);
                    NetworkAttachment attachment = getNetworkToAttachment().get(targetNetwork.getId());
                    params.getRemovedNetworkAttachments().add(attachment.getId());
                }
            }
        }
    }
}
#method_after
private void removeNetworksNoLongerAttachedViaLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, PersistentHostSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic, String label) {
    List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
    if (sourceLabeledNetworks != null) {
        for (Network sourceLabeledNetwork : sourceLabeledNetworks) {
            String networkName = sourceLabeledNetwork.getName();
            if (isNetworkAssignedToNic(nic, networkName, nicsByNetwork)) {
                // The network was attached to the nic via label (in the source cluster)
                if (!isNetworkAssignedToTargetCluster(targetNetworksByName, networkName)) {
                    // the network is not attached to the target cluster- should be removed from the host
                    params.getRemovedUnmanagedNetworks().add(networkName);
                } else if (!isNetworkLabelExistInTargetHost(networkName, targetNetworksByName)) {
                    // the target network doesn't have label that exist on the host
                    Network targetNetwork = targetNetworksByName.get(networkName);
                    NetworkAttachment attachment = getNetworkToAttachment().get(targetNetwork.getId());
                    params.getRemovedNetworkAttachments().add(attachment.getId());
                }
            }
        }
    }
}
#end_block

#method_before
private void createNetworkAttachmentForReportedNetworksNotHavingOne(VdsNetworkInterface nic, String networkName) {
    NetworkAttachment networkAttachment = NetworkUtils.createNetworkAttachment(getBaseInterfaceNicOrThis(nic), nic, clusterNetworks.get(networkName));
    networkAttachment.setId(Guid.newGuid());
    if (customPropertiesForNics != null) {
        networkAttachment.setProperties(customPropertiesForNics.getCustomPropertiesFor(nic));
    }
    networkAttachmentDao.save(networkAttachment);
}
#method_after
private void createNetworkAttachmentForReportedNetworksNotHavingOne(VdsNetworkInterface nic, String networkName) {
    NetworkAttachment networkAttachment = new NetworkAttachment(getBaseInterfaceNicOrThis(nic), clusterNetworks.get(networkName), NetworkUtils.createIpConfigurationFromVdsNetworkInterface(nic));
    networkAttachment.setId(Guid.newGuid());
    if (customPropertiesForNics != null) {
        networkAttachment.setProperties(customPropertiesForNics.getCustomPropertiesFor(nic));
    }
    networkAttachmentDao.save(networkAttachment);
}
#end_block

#method_before
private CreateImageVDSCommandParameters getCreateImageVDSCommandParameters() {
    DiskImage diskImage = getParameters().getDiskInfo();
    if (getStorageDomain().getStorageType().isBlockDomain() && diskImage.getImage().getVolumeType().equals(VolumeType.Sparse) && diskImage.getActualSizeInBytes() != 0) {
        return new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription(getParameters().getDiskInfo()), diskImage.getActualSizeInBytes());
    } else {
        return new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription(getParameters().getDiskInfo()));
    }
}
#method_after
private CreateImageVDSCommandParameters getCreateImageVDSCommandParameters() {
    DiskImage diskImage = getParameters().getDiskInfo();
    CreateImageVDSCommandParameters parameters = new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription(getParameters().getDiskInfo()));
    if (getStorageDomain().getStorageType().isBlockDomain() && diskImage.getImage().getVolumeType().equals(VolumeType.Sparse) && diskImage.getActualSizeInBytes() != 0) {
        parameters.setImageInitialSizeInBytes(diskImage.getActualSizeInBytes());
    }
    return parameters;
}
#end_block

#method_before
protected void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                if (exSchedulerDiscovery.discover()) {
                    reloadPolicyUnits();
                }
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#method_after
private void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                if (exSchedulerDiscovery.discover()) {
                    reloadPolicyUnits();
                }
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#end_block

#method_before
public void reloadPolicyUnits() {
    synchronized (policyUnitsLock) {
        policyUnits = new ConcurrentHashMap<>();
        loadPolicyUnits();
    }
}
#method_after
private void reloadPolicyUnits() {
    synchronized (policyUnitsLock) {
        policyUnits = new ConcurrentHashMap<>();
        loadPolicyUnits();
    }
}
#end_block

#method_before
protected void loadClusterPolicies() {
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#method_after
private void loadClusterPolicies() {
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#end_block

#method_before
protected void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), Injector.injectMembers(PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager())));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#method_after
private void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), Injector.injectMembers(PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager())));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#end_block

#method_before
protected void checkAllowOverbooking(VDSGroup cluster) {
    if (OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType() && Config.<Boolean>getValue(ConfigValues.SchedulerAllowOverBooking) && clusterLockMap.get(cluster.getId()).getQueueLength() >= Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold)) {
        log.info("Scheduler: cluster '{}' lock is skipped (cluster is allowed to overbook)", cluster.getName());
        // release pending threads (requests) and current one (+1)
        clusterLockMap.get(cluster.getId()).release(Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold) + 1);
    }
}
#method_after
private void checkAllowOverbooking(VDSGroup cluster) {
    if (OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType() && Config.<Boolean>getValue(ConfigValues.SchedulerAllowOverBooking) && clusterLockMap.get(cluster.getId()).getQueueLength() >= Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold)) {
        log.info("Scheduler: cluster '{}' lock is skipped (cluster is allowed to overbook)", cluster.getName());
        // release pending threads (requests) and current one (+1)
        clusterLockMap.get(cluster.getId()).release(Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold) + 1);
    }
}
#end_block

#method_before
protected boolean shouldWeighClusterHosts(VDSGroup cluster, List<VDS> vdsList) {
    Integer threshold = Config.<Integer>getValue(ConfigValues.SpeedOptimizationSchedulingThreshold);
    // threshold is crossed only when cluster is configured for optimized for speed
    boolean crossedThreshold = OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType() && clusterLockMap.get(cluster.getId()).getQueueLength() > threshold;
    if (crossedThreshold) {
        log.info("Scheduler: skipping whinging hosts in cluster '{}', since there are more than '{}' parallel requests", cluster.getName(), threshold);
    }
    return vdsList.size() > 1 && !crossedThreshold;
}
#method_after
private boolean shouldWeighClusterHosts(VDSGroup cluster, List<VDS> vdsList) {
    Integer threshold = Config.<Integer>getValue(ConfigValues.SpeedOptimizationSchedulingThreshold);
    // threshold is crossed only when cluster is configured for optimized for speed
    boolean crossedThreshold = OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType() && clusterLockMap.get(cluster.getId()).getQueueLength() > threshold;
    if (crossedThreshold) {
        log.info("Scheduler: skipping whinging hosts in cluster '{}', since there are more than '{}' parallel requests", cluster.getName(), threshold);
    }
    return vdsList.size() > 1 && !crossedThreshold;
}
#end_block

#method_before
protected Map<String, String> createClusterPolicyParameters(VDSGroup cluster) {
    Map<String, String> parameters = new HashMap<>();
    if (cluster.getClusterPolicyProperties() != null) {
        parameters.putAll(cluster.getClusterPolicyProperties());
    }
    return parameters;
}
#method_after
private Map<String, String> createClusterPolicyParameters(VDSGroup cluster) {
    Map<String, String> parameters = new HashMap<>();
    if (cluster.getClusterPolicyProperties() != null) {
        parameters.putAll(cluster.getClusterPolicyProperties());
    }
    return parameters;
}
#end_block

#method_before
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<>();
        Set<Guid> listSet = new HashSet<>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#method_after
private void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<>();
        Set<Guid> listSet = new HashSet<>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#end_block

#method_before
protected Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#method_after
private Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#end_block

#method_before
protected VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#method_after
private VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#end_block

#method_before
protected VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#method_after
private VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#end_block

#method_before
protected PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#method_after
private PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#end_block

#method_before
protected ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#method_after
private ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#end_block

#method_before
public void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#method_after
private void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#end_block

#method_before
public void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#method_after
private void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#end_block

#method_before
@Before
public void setUp() {
    vm = new VM();
    vm.setCpuPerSocket(2);
    vm.setNumOfSockets(2);
    vdsWithoutCores = new VDS();
    vdsWithoutCores.setId(Guid.newGuid());
    vdsWithoutCores.setCpuCores(0);
    vdsWithoutCores.setCpuThreads(0);
    vdsWithCores = new VDS();
    vdsWithCores.setId(Guid.newGuid());
    vdsWithCores.setCpuCores(2);
    vdsWithCores.setCpuThreads(4);
    cluster = new VDSGroup();
    cluster.setId(Guid.newGuid());
    when(vdsGroupDao.get(any(Guid.class))).thenReturn(cluster);
}
#method_after
@Before
public void setUp() {
    vm = new VM();
    vm.setCpuPerSocket(2);
    vm.setNumOfSockets(2);
    vdsWithInvalidCpuInfo = new VDS();
    vdsWithInvalidCpuInfo.setId(Guid.newGuid());
    vdsWithInvalidCpuInfo.setCpuCores(0);
    vdsWithInvalidCpuInfo.setCpuThreads(0);
    vdsWithCores = new VDS();
    vdsWithCores.setId(Guid.newGuid());
    vdsWithCores.setCpuCores(2);
    vdsWithCores.setCpuThreads(4);
    cluster = new VDSGroup();
    cluster.setId(Guid.newGuid());
    when(vdsGroupDao.get(any(Guid.class))).thenReturn(cluster);
}
#end_block

#method_before
@Test
public void shouldKeepHostsWithNoCpuInformation() {
    vdsWithoutCores.setCpuCores(null);
    final List<VDS> candidates = filter();
    assertThat(candidates, hasItem(vdsWithoutCores));
}
#method_after
@Test
public void shouldKeepHostsWithNoCpuInformation() {
    vdsWithInvalidCpuInfo.setCpuCores(null);
    final List<VDS> candidates = filter();
    assertThat(candidates).contains(vdsWithInvalidCpuInfo);
}
#end_block

#method_before
@Test
public void shouldFilterHostWithNotEnoughThreads() {
    cluster.setCountThreadsAsCores(true);
    vdsWithCores.setCpuThreads(3);
    final List<VDS> candidates = filter();
    assertThat(candidates, not(hasItem(vdsWithCores)));
}
#method_after
@Test
public void shouldFilterHostWithNotEnoughThreads() {
    cluster.setCountThreadsAsCores(true);
    vdsWithCores.setCpuThreads(3);
    final List<VDS> candidates = filter();
    assertThat(candidates).doesNotContain(vdsWithCores);
}
#end_block

#method_before
private List<VDS> filter() {
    return cpuPolicyUnit.filter(Arrays.asList(vdsWithoutCores, vdsWithCores), vm, null, mock(PerHostMessages.class));
}
#method_after
private List<VDS> filter() {
    return cpuPolicyUnit.filter(Arrays.asList(vdsWithInvalidCpuInfo, vdsWithCores), vm, null, mock(PerHostMessages.class));
}
#end_block

#method_before
@Override
protected void readOsSection(XmlNode section) {
    _vm.getStaticData().setId(new Guid(section.attributes.get("ovf:id").getValue()));
    this.lastReadEntry = "Description";
    XmlNode node = section.SelectSingleNode("Description");
    if (node != null) {
        int osId = osRepository.getOsIdByUniqueName(node.innerText);
        _vm.getStaticData().setOsId(osId);
        _vm.setClusterArch(osRepository.getArchitectureFromOS(osId));
    } else {
        _vm.setClusterArch(ArchitectureType.undefined);
    }
}
#method_after
@Override
protected void readOsSection(XmlNode section) {
    _vm.getStaticData().setId(new Guid(section.attributes.get("ovf:id").getValue()));
    XmlNode node = selectSingleNode(section, "Description");
    if (node != null) {
        int osId = osRepository.getOsIdByUniqueName(node.innerText);
        _vm.getStaticData().setOsId(osId);
        _vm.setClusterArch(osRepository.getArchitectureFromOS(osId));
    } else {
        _vm.setClusterArch(ArchitectureType.undefined);
    }
}
#end_block

#method_before
@Override
protected void readDiskImageItem(XmlNode node) {
    this.lastReadEntry = "rasd:InstanceId";
    final Guid guid = new Guid(node.SelectSingleNode("rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return diskImage.getImageId().equals(guid);
        }
    });
    this.lastReadEntry = "rasd:HostResource";
    image.setId(OvfParser.GetImageGrupIdFromImageFile(node.SelectSingleNode("rasd:HostResource", _xmlNS).innerText));
    this.lastReadEntry = "rasd:Parent";
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(node.SelectSingleNode("rasd:Parent", _xmlNS).innerText));
    }
    this.lastReadEntry = "rasd:Template";
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(node.SelectSingleNode("rasd:Template", _xmlNS).innerText));
    }
    this.lastReadEntry = "rasd:ApplicationList";
    image.setAppList(node.SelectSingleNode("rasd:ApplicationList", _xmlNS).innerText);
    this.lastReadEntry = "rasd:StorageId";
    XmlNode storageNode = node.SelectSingleNode("rasd:StorageId", _xmlNS);
    if (storageNode != null && StringUtils.isNotEmpty(storageNode.innerText)) {
        image.setStorageIds(new ArrayList<Guid>(Arrays.asList(new Guid(storageNode.innerText))));
    }
    this.lastReadEntry = "rasd:StoragePoolId";
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).innerText));
    }
    this.lastReadEntry = "rasd:CreationDate";
    final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    this.lastReadEntry = "rasd:LastModified";
    final Date lastModified = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    this.lastReadEntry = "rasd:last_modified_date";
    final Date last_modified_date = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:last_modified_date", _xmlNS).innerText);
    if (last_modified_date != null) {
        image.setLastModifiedDate(last_modified_date);
    }
    VmDevice readDevice = readManagedVmDevice(node, image.getId());
    image.setPlugged(readDevice.getIsPlugged());
    image.setReadOnly(readDevice.getIsReadOnly());
}
#method_after
@Override
protected void readDiskImageItem(XmlNode node) {
    final Guid guid = new Guid(selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return diskImage.getImageId().equals(guid);
        }
    });
    image.setId(OvfParser.GetImageGrupIdFromImageFile(selectSingleNode(node, "rasd:HostResource", _xmlNS).innerText));
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(selectSingleNode(node, "rasd:Template", _xmlNS).innerText));
    }
    image.setAppList(selectSingleNode(node, "rasd:ApplicationList", _xmlNS).innerText);
    XmlNode storageNode = selectSingleNode(node, "rasd:StorageId", _xmlNS);
    if (storageNode != null && StringUtils.isNotEmpty(storageNode.innerText)) {
        image.setStorageIds(new ArrayList<Guid>(Arrays.asList(new Guid(storageNode.innerText))));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText));
    }
    final Date creationDate = OvfParser.UtcDateStringToLocaDate(selectSingleNode(node, "rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    final Date lastModified = OvfParser.UtcDateStringToLocaDate(selectSingleNode(node, "rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    final Date last_modified_date = OvfParser.UtcDateStringToLocaDate(selectSingleNode(node, "rasd:last_modified_date", _xmlNS).innerText);
    if (last_modified_date != null) {
        image.setLastModifiedDate(last_modified_date);
    }
    VmDevice readDevice = readManagedVmDevice(node, image.getId());
    image.setPlugged(readDevice.getIsPlugged());
    image.setReadOnly(readDevice.getIsReadOnly());
}
#end_block

#method_before
@Override
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    super.updateSingleNic(node, iface);
    this.lastReadEntry = "rasd:MACAddress";
    iface.setMacAddress((node.SelectSingleNode("rasd:MACAddress", _xmlNS) != null) ? node.SelectSingleNode("rasd:MACAddress", _xmlNS).innerText : "");
}
#method_after
@Override
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    super.updateSingleNic(node, iface);
    iface.setMacAddress((selectSingleNode(node, "rasd:MACAddress", _xmlNS) != null) ? selectSingleNode(node, "rasd:MACAddress", _xmlNS).innerText : "");
}
#end_block

#method_before
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    this.lastReadEntry = OvfProperties.NAME;
    XmlNode node = content.SelectSingleNode(OvfProperties.NAME);
    if (node != null) {
        _vm.getStaticData().setName(node.innerText);
        name = _vm.getStaticData().getName();
    }
    this.lastReadEntry = OvfProperties.TEMPLATE_ID;
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.getStaticData().setVmtGuid(new Guid(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.TEMPLATE_NAME;
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setVmtName(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.INSTANCE_TYPE_ID;
    node = content.SelectSingleNode(OvfProperties.INSTANCE_TYPE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setInstanceTypeId(new Guid(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.IMAGE_TYPE_ID;
    node = content.SelectSingleNode(OvfProperties.IMAGE_TYPE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setImageTypeId(new Guid(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.IS_INITIALIZED;
    node = content.SelectSingleNode(OvfProperties.IS_INITIALIZED);
    if (node != null) {
        _vm.getStaticData().setInitialized(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.QUOTA_ID;
    node = content.SelectSingleNode(OvfProperties.QUOTA_ID);
    if (node != null) {
        Guid quotaId = new Guid(node.innerText);
        if (!Guid.Empty.equals(quotaId)) {
            _vm.getStaticData().setQuotaId(quotaId);
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (StringUtils.isNotEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    // {@link VM#predefinedProperties} and {@link VM#userDefinedProperties}
    // are being set in the above alias handling, we need to update custom properties
    // to keep them consistent
    _vm.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(_vm.getPredefinedProperties(), _vm.getUserDefinedProperties()));
    this.lastReadEntry = OvfProperties.APPLICATIONS_LIST;
    node = content.SelectSingleNode(OvfProperties.APPLICATIONS_LIST);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setAppList(node.innerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setAppList(_images.get(i).getAppList());
                }
            }
        } else {
            _vm.setAppList(_images.get(0).getAppList());
        }
    }
    this.lastReadEntry = OvfProperties.TRUSTED_SERVICE;
    node = content.SelectSingleNode(OvfProperties.TRUSTED_SERVICE);
    if (node != null) {
        _vm.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.ORIGINAL_TEMPLATE_ID;
    node = content.SelectSingleNode(OvfProperties.ORIGINAL_TEMPLATE_ID);
    if (node != null) {
        _vm.getStaticData().setOriginalTemplateGuid(new Guid(node.innerText));
    }
    this.lastReadEntry = OvfProperties.ORIGINAL_TEMPLATE_NAME;
    node = content.SelectSingleNode(OvfProperties.ORIGINAL_TEMPLATE_NAME);
    if (node != null) {
        _vm.getStaticData().setOriginalTemplateName(node.innerText);
    }
    this.lastReadEntry = OvfProperties.USE_LATEST_VERSION;
    node = content.SelectSingleNode(OvfProperties.USE_LATEST_VERSION);
    if (node != null) {
        _vm.setUseLatestVersion(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.USE_HOST_CPU;
    node = content.SelectSingleNode(OvfProperties.USE_HOST_CPU);
    if (node != null) {
        _vm.setUseHostCpuFlags(Boolean.parseBoolean(node.innerText));
    }
}
#method_after
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = selectSingleNode(content, OvfProperties.NAME);
    if (node != null) {
        _vm.getStaticData().setName(node.innerText);
        name = _vm.getStaticData().getName();
    }
    node = selectSingleNode(content, OvfProperties.TEMPLATE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.getStaticData().setVmtGuid(new Guid(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TEMPLATE_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setVmtName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.INSTANCE_TYPE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setInstanceTypeId(new Guid(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IMAGE_TYPE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setImageTypeId(new Guid(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_INITIALIZED);
    if (node != null) {
        _vm.getStaticData().setInitialized(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.QUOTA_ID);
    if (node != null) {
        Guid quotaId = new Guid(node.innerText);
        if (!Guid.Empty.equals(quotaId)) {
            _vm.getStaticData().setQuotaId(quotaId);
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (StringUtils.isNotEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    // {@link VM#predefinedProperties} and {@link VM#userDefinedProperties}
    // are being set in the above alias handling, we need to update custom properties
    // to keep them consistent
    _vm.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(_vm.getPredefinedProperties(), _vm.getUserDefinedProperties()));
    node = selectSingleNode(content, OvfProperties.APPLICATIONS_LIST);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vm.setAppList(node.innerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setAppList(_images.get(i).getAppList());
                }
            }
        } else {
            _vm.setAppList(_images.get(0).getAppList());
        }
    }
    node = selectSingleNode(content, OvfProperties.TRUSTED_SERVICE);
    if (node != null) {
        _vm.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.ORIGINAL_TEMPLATE_ID);
    if (node != null) {
        _vm.getStaticData().setOriginalTemplateGuid(new Guid(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.ORIGINAL_TEMPLATE_NAME);
    if (node != null) {
        _vm.getStaticData().setOriginalTemplateName(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.USE_LATEST_VERSION);
    if (node != null) {
        _vm.setUseLatestVersion(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.USE_HOST_CPU);
    if (node != null) {
        _vm.setUseHostCpuFlags(Boolean.parseBoolean(node.innerText));
    }
}
#end_block

#method_before
private String readEventLogValue(XmlNode content, String name) {
    StringBuilder fullNameSB = new StringBuilder(EXPORT_ONLY_PREFIX);
    fullNameSB.append(name);
    this.lastReadEntry = fullNameSB.toString();
    XmlNode node = content.SelectSingleNode(fullNameSB.toString());
    if (node != null) {
        return node.innerText;
    }
    return null;
}
#method_after
private String readEventLogValue(XmlNode content, String name) {
    StringBuilder fullNameSB = new StringBuilder(EXPORT_ONLY_PREFIX);
    fullNameSB.append(name);
    XmlNode node = selectSingleNode(content, fullNameSB.toString());
    if (node != null) {
        return node.innerText;
    }
    return null;
}
#end_block

#method_before
@Override
protected void readSnapshotsSection(XmlNode section) {
    this.lastReadEntry = "Snapshot";
    XmlNodeList list = section.SelectNodes("Snapshot");
    ArrayList<Snapshot> snapshots = new ArrayList<Snapshot>();
    _vm.setSnapshots(snapshots);
    for (XmlNode node : list) {
        this.lastReadEntry = "VmConfiguration";
        XmlNode vmConfiguration = node.SelectSingleNode("VmConfiguration", _xmlNS);
        Snapshot snapshot = new Snapshot(vmConfiguration != null);
        snapshot.setId(new Guid(node.attributes.get("ovf:id").getValue()));
        snapshot.setVmId(_vm.getId());
        snapshot.setType(SnapshotType.valueOf(node.SelectSingleNode("Type", _xmlNS).innerText));
        snapshot.setStatus(SnapshotStatus.OK);
        snapshot.setDescription(node.SelectSingleNode("Description", _xmlNS).innerText);
        XmlNode memory = node.SelectSingleNode("Memory", _xmlNS);
        if (memory != null) {
            snapshot.setMemoryVolume(memory.innerText);
        }
        final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("CreationDate", _xmlNS).innerText);
        if (creationDate != null) {
            snapshot.setCreationDate(creationDate);
        }
        snapshot.setVmConfiguration(vmConfiguration == null ? null : new String(Base64.decodeBase64(vmConfiguration.innerText)));
        this.lastReadEntry = "ApplicationList";
        XmlNode appList = node.SelectSingleNode("ApplicationList", _xmlNS);
        if (appList != null) {
            snapshot.setAppList(appList.innerText);
        }
        snapshots.add(snapshot);
    }
}
#method_after
@Override
protected void readSnapshotsSection(XmlNode section) {
    XmlNodeList list = selectNodes(section, "Snapshot");
    ArrayList<Snapshot> snapshots = new ArrayList<Snapshot>();
    _vm.setSnapshots(snapshots);
    for (XmlNode node : list) {
        XmlNode vmConfiguration = selectSingleNode(node, "VmConfiguration", _xmlNS);
        Snapshot snapshot = new Snapshot(vmConfiguration != null);
        snapshot.setId(new Guid(node.attributes.get("ovf:id").getValue()));
        snapshot.setVmId(_vm.getId());
        snapshot.setType(SnapshotType.valueOf(selectSingleNode(node, "Type", _xmlNS).innerText));
        snapshot.setStatus(SnapshotStatus.OK);
        snapshot.setDescription(selectSingleNode(node, "Description", _xmlNS).innerText);
        XmlNode memory = selectSingleNode(node, "Memory", _xmlNS);
        if (memory != null) {
            snapshot.setMemoryVolume(memory.innerText);
        }
        final Date creationDate = OvfParser.UtcDateStringToLocaDate(selectSingleNode(node, "CreationDate", _xmlNS).innerText);
        if (creationDate != null) {
            snapshot.setCreationDate(creationDate);
        }
        snapshot.setVmConfiguration(vmConfiguration == null ? null : new String(Base64.decodeBase64(vmConfiguration.innerText)));
        XmlNode appList = selectSingleNode(node, "ApplicationList", _xmlNS);
        if (appList != null) {
            snapshot.setAppList(appList.innerText);
        }
        snapshots.add(snapshot);
    }
}
#end_block

#method_before
private String generateOvfReaderErrorMessage(OvfReader ovf, Exception ex) {
    StringBuilder message = new StringBuilder();
    message.append("OVF error: ").append(ovf.getName()).append(": cannot read '").append(ovf.getLastReadEntry()).append("' with value: ").append(ex.getMessage());
    return message.toString();
}
#method_after
private String generateOvfReaderErrorMessage(OvfReader ovf, Exception ex) {
    StringBuilder message = new StringBuilder();
    if (ovf == null) {
        message.append("Error loading ovf, message").append(ex.getMessage());
    } else {
        message.append("OVF error: ").append(ovf.getName()).append(": cannot read '").append(ovf.getLastReadEntry()).append("' with value: ").append(ex.getMessage());
    }
    return message.toString();
}
#end_block

#method_before
private void readHeader() {
    version = "";
    this.lastReadEntry = "ovf:Envelope";
    XmlNode node = _document.SelectSingleNode("//ovf:Envelope", _xmlNS);
    if (node != null) {
        this.lastReadEntry = "Envelope['versio']";
        version = node.attributes.get("ovf:version").getValue();
    }
}
#method_after
private void readHeader() {
    version = "";
    XmlNode node = selectSingleNode(_document, "//ovf:Envelope", _xmlNS);
    if (node != null) {
        version = node.attributes.get("ovf:version").getValue();
    }
}
#end_block

#method_before
@Override
public void buildDisk() {
    this.lastReadEntry = "Section/Disk";
    XmlNodeList list = _document.SelectNodes("//*/Section/Disk");
    for (XmlNode node : list) {
        this.lastReadEntry = "Section/Disk['ovf:diskId']";
        final Guid guid = new Guid(node.attributes.get("ovf:diskId").getValue());
        DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getImageId().equals(guid);
            }
        });
        this.lastReadEntry = "Section/Disk['ovf:vm_snapshot_id']";
        if (node.attributes.get("ovf:vm_snapshot_id") != null) {
            image.setVmSnapshotId(new Guid(node.attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        this.lastReadEntry = "Section/Disk['ovf:size']";
        if (!StringUtils.isEmpty(node.attributes.get("ovf:size").getValue())) {
            image.setSize(convertGigabyteToBytes(Long.parseLong(node.attributes.get("ovf:size").getValue())));
        }
        this.lastReadEntry = "Section/Disk['ovf:actual_size']";
        if (!StringUtils.isEmpty(node.attributes.get("ovf:actual_size").getValue())) {
            image.setActualSizeInBytes(convertGigabyteToBytes(Long.parseLong(node.attributes.get("ovf:actual_size").getValue())));
        }
        this.lastReadEntry = "Section/Disk['ovf:volume-format']";
        if (node.attributes.get("ovf:volume-format") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-format").getValue())) {
                image.setvolumeFormat(VolumeFormat.valueOf(node.attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setvolumeFormat(VolumeFormat.Unassigned);
            }
        } else {
            image.setvolumeFormat(VolumeFormat.Unassigned);
        }
        this.lastReadEntry = "Section/Disk['ovf:volume-type']";
        if (node.attributes.get("ovf:volume-type") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-type").getValue())) {
                image.setVolumeType(VolumeType.valueOf(node.attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setVolumeType(VolumeType.Unassigned);
            }
        } else {
            image.setVolumeType(VolumeType.Unassigned);
        }
        this.lastReadEntry = "Section/Disk['ovf:disk-interface']";
        if (node.attributes.get("ovf:disk-interface") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-interface").getValue())) {
                image.setDiskInterface(DiskInterface.valueOf(node.attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            image.setDiskInterface(DiskInterface.IDE);
        }
        this.lastReadEntry = "Section/Disk['ovf:boot']";
        if (node.attributes.get("ovf:boot") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:boot").getValue())) {
                image.setBoot(Boolean.parseBoolean(node.attributes.get("ovf:boot").getValue()));
            }
        }
        this.lastReadEntry = "Section/Disk['ovf:wipe-after-delete']";
        if (node.attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        this.lastReadEntry = "Section/Disk['ovf:disk-alias']";
        if (node.attributes.get("ovf:disk-alias") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.attributes.get("ovf:disk-alias").getValue()));
            }
        }
        this.lastReadEntry = "Section/Disk['ovf:disk-disk-description']";
        if (node.attributes.get("ovf:disk-description") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.attributes.get("ovf:disk-description").getValue()));
            }
        }
    }
}
#method_after
@Override
public void buildDisk() {
    XmlNodeList list = selectNodes(_document, "//*/Section/Disk");
    for (XmlNode node : list) {
        final Guid guid = new Guid(node.attributes.get("ovf:diskId").getValue());
        DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getImageId().equals(guid);
            }
        });
        if (node.attributes.get("ovf:vm_snapshot_id") != null) {
            image.setVmSnapshotId(new Guid(node.attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        if (!StringUtils.isEmpty(node.attributes.get("ovf:size").getValue())) {
            image.setSize(convertGigabyteToBytes(Long.parseLong(node.attributes.get("ovf:size").getValue())));
        }
        if (!StringUtils.isEmpty(node.attributes.get("ovf:actual_size").getValue())) {
            image.setActualSizeInBytes(convertGigabyteToBytes(Long.parseLong(node.attributes.get("ovf:actual_size").getValue())));
        }
        if (node.attributes.get("ovf:volume-format") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-format").getValue())) {
                image.setvolumeFormat(VolumeFormat.valueOf(node.attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setvolumeFormat(VolumeFormat.Unassigned);
            }
        } else {
            image.setvolumeFormat(VolumeFormat.Unassigned);
        }
        if (node.attributes.get("ovf:volume-type") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-type").getValue())) {
                image.setVolumeType(VolumeType.valueOf(node.attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setVolumeType(VolumeType.Unassigned);
            }
        } else {
            image.setVolumeType(VolumeType.Unassigned);
        }
        if (node.attributes.get("ovf:disk-interface") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-interface").getValue())) {
                image.setDiskInterface(DiskInterface.valueOf(node.attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            image.setDiskInterface(DiskInterface.IDE);
        }
        if (node.attributes.get("ovf:boot") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:boot").getValue())) {
                image.setBoot(Boolean.parseBoolean(node.attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.attributes.get("ovf:disk-alias") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.attributes.get("ovf:disk-description") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.attributes.get("ovf:disk-description").getValue()));
            }
        }
    }
}
#end_block

#method_before
private VmDevice readVmDevice(XmlNode node, Guid deviceId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    this.lastReadEntry = OvfProperties.VMD_ADDRESS;
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).innerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).innerText));
    } else {
        vmDevice.setAddress("");
    }
    this.lastReadEntry = OvfProperties.VMD_ALIAS;
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).innerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).innerText));
    } else {
        vmDevice.setAlias("");
    }
    this.lastReadEntry = OvfProperties.VMD_SPEC_PARAMS;
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.innerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    this.lastReadEntry = OvfProperties.VMD_TYPE;
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    this.lastReadEntry = OvfProperties.VMD_DEVICE;
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    this.lastReadEntry = OvfProperties.VMD_BOOT_ORDER;
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText)) {
        vmDevice.setBootOrder(Integer.parseInt(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    this.lastReadEntry = OvfProperties.VMD_IS_PLUGGED;
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    this.lastReadEntry = OvfProperties.VMD_IS_READONLY;
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).innerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).innerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    this.lastReadEntry = OvfProperties.VMD_CUSTOM_PROP;
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    this.lastReadEntry = OvfProperties.VMD_SNAPSHOT_PROP;
    if (node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).innerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    }
    return vmDevice;
}
#method_after
private VmDevice readVmDevice(XmlNode node, Guid deviceId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS).innerText)) {
        vmDevice.setAddress(String.valueOf(selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS).innerText));
    } else {
        vmDevice.setAddress("");
    }
    if (selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS).innerText)) {
        vmDevice.setAlias(String.valueOf(selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS).innerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = selectSingleNode(node, OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.innerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText)) {
        vmDevice.setDevice(String.valueOf(selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (selectSingleNode(node, OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText)) {
        vmDevice.setBootOrder(Integer.parseInt(selectSingleNode(node, OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS).innerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS).innerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (selectSingleNode(node, OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).innerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    }
    return vmDevice;
}
#end_block

#method_before
public VmNetworkInterface getNetworkInterface(XmlNode node) {
    // prior to 3.0 the instanceId is int , in 3.1 and on this is Guid
    this.lastReadEntry = "rasd:InstanceId";
    String str = node.SelectSingleNode("rasd:InstanceId", _xmlNS).innerText;
    final Guid guid;
    VmNetworkInterface iface;
    if (!StringUtils.isNumeric(str)) {
        // 3.1 and above OVF format
        guid = new Guid(str);
        iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

            @Override
            public boolean eval(VmNetworkInterface iface) {
                return iface.getId().equals(guid);
            }
        });
        if (iface == null) {
            iface = new VmNetworkInterface();
            iface.setId(guid);
        }
    } else {
        // 3.0 and below OVF format
        iface = new VmNetworkInterface();
    }
    return iface;
}
#method_after
public VmNetworkInterface getNetworkInterface(XmlNode node) {
    // prior to 3.0 the instanceId is int , in 3.1 and on this is Guid
    String str = selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText;
    final Guid guid;
    VmNetworkInterface iface;
    if (!StringUtils.isNumeric(str)) {
        // 3.1 and above OVF format
        guid = new Guid(str);
        iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

            @Override
            public boolean eval(VmNetworkInterface iface) {
                return iface.getId().equals(guid);
            }
        });
        if (iface == null) {
            iface = new VmNetworkInterface();
            iface.setId(guid);
        }
    } else {
        // 3.0 and below OVF format
        iface = new VmNetworkInterface();
    }
    return iface;
}
#end_block

#method_before
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    this.lastReadEntry = "//*/Item";
    for (XmlNode node : section.SelectNodes("Item")) {
        this.lastReadEntry = "rasd:ResourceType";
        switch(node.SelectSingleNode("rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.Graphics:
                // so far graphics doesn't contain anything special
                readManagedVmDevice(node, Guid.newGuid());
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial || VmDeviceType.VIRTIOSERIAL.getName().equals(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#method_after
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    for (XmlNode node : selectNodes(section, "Item")) {
        switch(selectSingleNode(node, "rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.Graphics:
                // so far graphics doesn't contain anything special
                readManagedVmDevice(node, Guid.newGuid());
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial || VmDeviceType.VIRTIOSERIAL.getName().equals(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#end_block

#method_before
protected void readMonitorItem(XmlNode node) {
    this.lastReadEntry = "rasd:VirtualQuantity";
    vmBase.setNumOfMonitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).innerText));
    this.lastReadEntry = "rasd:SinglePciQxl";
    if (node.SelectSingleNode("rasd:SinglePciQxl", _xmlNS) != null) {
        vmBase.setSingleQxlPci(Boolean.parseBoolean(node.SelectSingleNode("rasd:SinglePciQxl", _xmlNS).innerText));
    }
    if (new Version(getVersion()).compareTo(Version.v3_1) >= 0) {
        readManagedVmDevice(node, Guid.newGuid());
    } else {
        // case we need to add monitor devices according to the numOfMonitors field
        for (int i = 0; i < vmBase.getNumOfMonitors(); ++i) {
            readManagedVmDevice(node, Guid.newGuid());
        }
    }
}
#method_after
protected void readMonitorItem(XmlNode node) {
    vmBase.setNumOfMonitors(Integer.parseInt(selectSingleNode(node, "rasd:VirtualQuantity", _xmlNS).innerText));
    if (selectSingleNode(node, "rasd:SinglePciQxl", _xmlNS) != null) {
        vmBase.setSingleQxlPci(Boolean.parseBoolean(selectSingleNode(node, "rasd:SinglePciQxl", _xmlNS).innerText));
    }
    if (new Version(getVersion()).compareTo(Version.v3_1) >= 0) {
        readManagedVmDevice(node, Guid.newGuid());
    } else {
        // case we need to add monitor devices according to the numOfMonitors field
        for (int i = 0; i < vmBase.getNumOfMonitors(); ++i) {
            readManagedVmDevice(node, Guid.newGuid());
        }
    }
}
#end_block

#method_before
private void readCpuItem(XmlNode node) {
    this.lastReadEntry = "rasd:num_of_sockets";
    vmBase.setNumOfSockets(Integer.parseInt(node.SelectSingleNode("rasd:num_of_sockets", _xmlNS).innerText));
    this.lastReadEntry = "rasd:cpu_per_socket";
    vmBase.setCpuPerSocket(Integer.parseInt(node.SelectSingleNode("rasd:cpu_per_socket", _xmlNS).innerText));
}
#method_after
private void readCpuItem(XmlNode node) {
    vmBase.setNumOfSockets(Integer.parseInt(selectSingleNode(node, "rasd:num_of_sockets", _xmlNS).innerText));
    vmBase.setCpuPerSocket(Integer.parseInt(selectSingleNode(node, "rasd:cpu_per_socket", _xmlNS).innerText));
}
#end_block

#method_before
private void readMemoryItem(XmlNode node) {
    this.lastReadEntry = "rasd:VirtualQuantity";
    vmBase.setMemSizeMb(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).innerText));
}
#method_after
private void readMemoryItem(XmlNode node) {
    vmBase.setMemSizeMb(Integer.parseInt(selectSingleNode(node, "rasd:VirtualQuantity", _xmlNS).innerText));
}
#end_block

#method_before
private void readUsbItem(XmlNode node) {
    this.lastReadEntry = "rasd:UsbPolicy";
    vmBase.setUsbPolicy(UsbPolicy.forStringValue(node.SelectSingleNode("rasd:UsbPolicy", _xmlNS).innerText));
}
#method_after
private void readUsbItem(XmlNode node) {
    vmBase.setUsbPolicy(UsbPolicy.forStringValue(selectSingleNode(node, "rasd:UsbPolicy", _xmlNS).innerText));
}
#end_block

#method_before
private VmDevice readOtherHardwareItem(XmlNode node) {
    boolean managed = false;
    this.lastReadEntry = OvfProperties.VMD_TYPE;
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        VmDeviceGeneralType type = VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText));
        this.lastReadEntry = OvfProperties.VMD_DEVICE;
        String device = node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText;
        // special devices are treated as managed devices but still have the OTHER OVF ResourceType
        managed = VmDeviceCommonUtils.isSpecialDevice(device, type);
    }
    return managed ? readManagedVmDevice(node, Guid.newGuid()) : readUnmanagedVmDevice(node, Guid.newGuid());
}
#method_after
private VmDevice readOtherHardwareItem(XmlNode node) {
    boolean managed = false;
    if (selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        VmDeviceGeneralType type = VmDeviceGeneralType.forValue(String.valueOf(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText));
        String device = selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText;
        // special devices are treated as managed devices but still have the OTHER OVF ResourceType
        managed = VmDeviceCommonUtils.isSpecialDevice(device, type);
    }
    return managed ? readManagedVmDevice(node, Guid.newGuid()) : readUnmanagedVmDevice(node, Guid.newGuid());
}
#end_block

#method_before
protected void readGeneralData() {
    this.lastReadEntry = "//*/Content";
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    this.lastReadEntry = OvfProperties.DESCRIPTION;
    node = content.SelectSingleNode(OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    this.lastReadEntry = OvfProperties.COMMENT;
    node = content.SelectSingleNode(OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    this.lastReadEntry = OvfProperties.DOMAIN;
    node = content.SelectSingleNode(OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    this.lastReadEntry = OvfProperties.CREATION_DATE;
    node = content.SelectSingleNode(OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    this.lastReadEntry = OvfProperties.EXPORT_DATE;
    node = content.SelectSingleNode(OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    this.lastReadEntry = OvfProperties.DEFAULT_BOOT_SEQUENCE;
    node = content.SelectSingleNode(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    this.lastReadEntry = OvfProperties.INITRD_URL;
    node = content.SelectSingleNode(OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.KERNEL_URL;
    node = content.SelectSingleNode(OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.KERNEL_PARAMS;
    node = content.SelectSingleNode(OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.GENERATION;
    node = content.SelectSingleNode(OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    this.lastReadEntry = getDefaultDisplayTypeStringRepresentation();
    this.lastReadEntry = getDefaultDisplayTypeStringRepresentation();
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    this.lastReadEntry = "//*/Section";
    XmlNodeList list = content.SelectNodes("Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(version) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // due to depndency on vmBase.getOsId() must be read AFTER readOsSection
    this.lastReadEntry = OvfProperties.TIMEZONE;
    node = content.SelectSingleNode(OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    this.lastReadEntry = OvfProperties.ORIGIN;
    node = content.SelectSingleNode(OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    this.lastReadEntry = OvfProperties.VM_TYPE;
    node = content.SelectSingleNode(OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    this.lastReadEntry = OvfProperties.IS_SMARTCARD_ENABLED;
    node = content.SelectSingleNode(OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.NUM_OF_IOTHREADS;
    node = content.SelectSingleNode(OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.DELETE_PROTECTED;
    node = content.SelectSingleNode(OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.SSO_METHOD;
    node = content.SelectSingleNode(OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.TUNNEL_MIGRATION;
    node = content.SelectSingleNode(OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.VNC_KEYBOARD_LAYOUT;
    node = content.SelectSingleNode(OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.MIN_ALLOCATED_MEMORY;
    node = content.SelectSingleNode(OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.IS_STATELESS;
    node = content.SelectSingleNode(OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.IS_RUN_AND_PAUSE;
    node = content.SelectSingleNode(OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.CREATED_BY_USER_ID;
    node = content.SelectSingleNode(OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.MIGRATION_DOWNTIME;
    node = content.SelectSingleNode(OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.MIGRATION_SUPPORT;
    node = content.SelectSingleNode(OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    this.lastReadEntry = OvfProperties.SERIAL_NUMBER_POLICY;
    node = content.SelectSingleNode(OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    this.lastReadEntry = OvfProperties.CUSTOM_SERIAL_NUMBER;
    node = content.SelectSingleNode(OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.AUTO_STARTUP;
    node = content.SelectSingleNode(OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.PRIORITY;
    node = content.SelectSingleNode(OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    this.lastReadEntry = OvfProperties.IS_BOOT_MENU_ENABLED;
    node = content.SelectSingleNode(OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED;
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.IS_SPICE_COPY_PASTE_ENABLED;
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.IS_AUTO_CONVERGE;
    node = content.SelectSingleNode(OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.IS_MIGRATE_COMPRESSED;
    node = content.SelectSingleNode(OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.CUSTOM_EMULATED_MACHINE;
    node = content.SelectSingleNode(OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.CUSTOM_CPU_NAME;
    node = content.SelectSingleNode(OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.PREDEFINED_PROPERTIES;
    node = content.SelectSingleNode(OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    this.lastReadEntry = OvfProperties.USER_DEFINED_PROPERTIES;
    node = content.SelectSingleNode(OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(version) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // due to depndency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
private void readDedicatedHostsList() {
    // initialize to empty list
    vmBase.setDedicatedVmForVdsList(new LinkedList<Guid>());
    // search all dedicated hosts with xPath
    this.lastReadEntry = "//*/Content/";
    XmlNodeList hostsList = _document.SelectNodes("//*/Content/" + OvfProperties.DEDICATED_VM_FOR_VDS);
    for (XmlNode hostNode : hostsList) {
        if (hostNode != null && StringUtils.isNotEmpty(hostNode.innerText)) {
            vmBase.getDedicatedVmForVdsList().add(Guid.createGuidFromString(hostNode.innerText));
        }
    }
}
#method_after
private void readDedicatedHostsList() {
    // initialize to empty list
    vmBase.setDedicatedVmForVdsList(new LinkedList<Guid>());
    // search all dedicated hosts with xPath
    XmlNodeList hostsList = selectNodes(_document, "//*/Content/" + OvfProperties.DEDICATED_VM_FOR_VDS);
    for (XmlNode hostNode : hostsList) {
        if (hostNode != null && StringUtils.isNotEmpty(hostNode.innerText)) {
            vmBase.getDedicatedVmForVdsList().add(Guid.createGuidFromString(hostNode.innerText));
        }
    }
}
#end_block

#method_before
private void readVmInit(XmlNode content) {
    this.lastReadEntry = "Vminit";
    XmlNode node = content.SelectSingleNode("VmInit");
    VmInit vmInit = vmBase.getVmInit();
    vmInit.setId(vmBase.getId());
    if (node != null) {
        this.lastReadEntry = "ovf:hostname";
        if (node.attributes.get("ovf:hostname") != null) {
            vmInit.setHostname(node.attributes.get("ovf:hostname").getValue());
        }
        this.lastReadEntry = "ovf:domain";
        if (node.attributes.get("ovf:domain") != null) {
            vmInit.setDomain(node.attributes.get("ovf:domain").getValue());
        }
        this.lastReadEntry = "ovf:timeZone";
        if (node.attributes.get("ovf:timeZone") != null) {
            vmInit.setTimeZone(node.attributes.get("ovf:timeZone").getValue());
        }
        this.lastReadEntry = "ovf:authorizedKeys";
        if (node.attributes.get("ovf:authorizedKeys") != null) {
            vmInit.setAuthorizedKeys(node.attributes.get("ovf:authorizedKeys").getValue());
        }
        this.lastReadEntry = "ovf:regenerateKeys";
        if (node.attributes.get("ovf:regenerateKeys") != null) {
            vmInit.setRegenerateKeys(Boolean.parseBoolean(node.attributes.get("ovf:regenerateKeys").getValue()));
        }
        this.lastReadEntry = "ovf:dnsServers";
        if (node.attributes.get("ovf:dnsServers") != null) {
            vmInit.setDnsServers(node.attributes.get("ovf:dnsServers").getValue());
        }
        this.lastReadEntry = "ovf:dnsSearch";
        if (node.attributes.get("ovf:dnsSearch") != null) {
            vmInit.setDnsSearch(node.attributes.get("ovf:dnsSearch").getValue());
        }
        this.lastReadEntry = "ovf:networks";
        if (node.attributes.get("ovf:networks") != null) {
            vmInit.setNetworks(VmInitUtils.jsonNetworksToList(node.attributes.get("ovf:networks").getValue()));
        }
        this.lastReadEntry = "ovf:winKey";
        if (node.attributes.get("ovf:winKey") != null) {
            vmInit.setWinKey(node.attributes.get("ovf:winKey").getValue());
        }
        this.lastReadEntry = "ovf:rootPassword";
        if (node.attributes.get("ovf:rootPassword") != null) {
            vmInit.setRootPassword(node.attributes.get("ovf:rootPassword").getValue());
        }
        this.lastReadEntry = "ovf:customScript";
        if (node.attributes.get("ovf:customScript") != null) {
            vmInit.setCustomScript(node.attributes.get("ovf:customScript").getValue());
        }
    }
}
#method_after
private void readVmInit(XmlNode content) {
    XmlNode node = selectSingleNode(content, "VmInit");
    VmInit vmInit = vmBase.getVmInit();
    vmInit.setId(vmBase.getId());
    if (node != null) {
        if (node.attributes.get("ovf:hostname") != null) {
            vmInit.setHostname(node.attributes.get("ovf:hostname").getValue());
        }
        if (node.attributes.get("ovf:domain") != null) {
            vmInit.setDomain(node.attributes.get("ovf:domain").getValue());
        }
        if (node.attributes.get("ovf:timeZone") != null) {
            vmInit.setTimeZone(node.attributes.get("ovf:timeZone").getValue());
        }
        if (node.attributes.get("ovf:authorizedKeys") != null) {
            vmInit.setAuthorizedKeys(node.attributes.get("ovf:authorizedKeys").getValue());
        }
        if (node.attributes.get("ovf:regenerateKeys") != null) {
            vmInit.setRegenerateKeys(Boolean.parseBoolean(node.attributes.get("ovf:regenerateKeys").getValue()));
        }
        if (node.attributes.get("ovf:dnsServers") != null) {
            vmInit.setDnsServers(node.attributes.get("ovf:dnsServers").getValue());
        }
        if (node.attributes.get("ovf:dnsSearch") != null) {
            vmInit.setDnsSearch(node.attributes.get("ovf:dnsSearch").getValue());
        }
        if (node.attributes.get("ovf:networks") != null) {
            vmInit.setNetworks(VmInitUtils.jsonNetworksToList(node.attributes.get("ovf:networks").getValue()));
        }
        if (node.attributes.get("ovf:winKey") != null) {
            vmInit.setWinKey(node.attributes.get("ovf:winKey").getValue());
        }
        if (node.attributes.get("ovf:rootPassword") != null) {
            vmInit.setRootPassword(node.attributes.get("ovf:rootPassword").getValue());
        }
        if (node.attributes.get("ovf:customScript") != null) {
            vmInit.setCustomScript(node.attributes.get("ovf:customScript").getValue());
        }
    }
}
#end_block

#method_before
protected void buildNicReference() {
    this.lastReadEntry = "//*/Nic";
    XmlNodeList list = _document.SelectNodes("//*/Nic", _xmlNS);
    for (XmlNode node : list) {
        VmNetworkInterface iface = new VmNetworkInterface();
        this.lastReadEntry = "ovf:id";
        iface.setId(new Guid(node.attributes.get("ovf:id").getValue()));
        interfaces.add(iface);
    }
    if (!list.iterator().hasNext()) {
        StringBuilder sb = new StringBuilder();
        sb.append("//*/Item[");
        sb.append(OvfProperties.VMD_RESOURCE_TYPE);
        sb.append("=");
        sb.append(OvfHardware.Network);
        sb.append("]");
        this.lastReadEntry = sb.toString();
        list = _document.SelectNodes(sb.toString(), _xmlNS);
        for (XmlNode node : list) {
            VmNetworkInterface iface = new VmNetworkInterface();
            iface.setId(Guid.newGuid());
            updateSingleNic(node, iface);
            interfaces.add(iface);
        }
    }
}
#method_after
protected void buildNicReference() {
    XmlNodeList list = selectNodes(_document, "//*/Nic", _xmlNS);
    for (XmlNode node : list) {
        VmNetworkInterface iface = new VmNetworkInterface();
        iface.setId(new Guid(node.attributes.get("ovf:id").getValue()));
        interfaces.add(iface);
    }
    if (!list.iterator().hasNext()) {
        StringBuilder sb = new StringBuilder();
        sb.append("//*/Item[");
        sb.append(OvfProperties.VMD_RESOURCE_TYPE);
        sb.append("=");
        sb.append(OvfHardware.Network);
        sb.append("]");
        list = selectNodes(_document, sb.toString(), _xmlNS);
        for (XmlNode node : list) {
            VmNetworkInterface iface = new VmNetworkInterface();
            iface.setId(Guid.newGuid());
            updateSingleNic(node, iface);
            interfaces.add(iface);
        }
    }
}
#end_block

#method_before
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    this.lastReadEntry = OvfProperties.VMD_CONNECTION;
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    this.lastReadEntry = OvfProperties.VMD_VNIC_PROFILE_NAME;
    XmlNode vnicProfileNameNode = node.SelectSingleNode(OvfProperties.VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    this.lastReadEntry = OvfProperties.VMD_LINKED;
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    this.lastReadEntry = OvfProperties.VMD_NAME;
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).innerText);
    this.lastReadEntry = "rasd:ResourceSubType";
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    this.lastReadEntry = "rasd:speed";
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#method_after
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    String networkName = selectSingleNode(node, OvfProperties.VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = selectSingleNode(node, OvfProperties.VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = selectSingleNode(node, OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    iface.setName(selectSingleNode(node, OvfProperties.VMD_NAME, _xmlNS).innerText);
    String resourceSubType = selectSingleNode(node, "rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = selectSingleNode(node, "rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#end_block

#method_before
private void buildImageReference() {
    this.lastReadEntry = "//*/File";
    XmlNodeList list = _document.SelectNodes("//*/File", _xmlNS);
    for (XmlNode node : list) {
        // If the disk storage type is Cinder then override the disk image with Cinder object, otherwise use the disk image.
        DiskImage disk = new DiskImage();
        // If the OVF is old and does not contain any storage type reference then we assume we can only have disk image.
        if (node.attributes.get("ovf:disk_storage_type") != null) {
            String diskStorageType = node.attributes.get("ovf:disk_storage_type").getValue();
            if (diskStorageType != null && diskStorageType.equals(DiskStorageType.CINDER.name())) {
                disk = new CinderDisk();
            }
        }
        disk.setImageId(new Guid(node.attributes.get("ovf:id").getValue()));
        disk.setId(OvfParser.GetImageGrupIdFromImageFile(node.attributes.get("ovf:href").getValue()));
        // Default values:
        disk.setActive(true);
        disk.setImageStatus(ImageStatus.OK);
        disk.setDescription(node.attributes.get("ovf:description").getValue());
        _images.add(disk);
    }
}
#method_after
private void buildImageReference() {
    XmlNodeList list = selectNodes(_document, "//*/File", _xmlNS);
    for (XmlNode node : list) {
        // If the disk storage type is Cinder then override the disk image with Cinder object, otherwise use the disk image.
        DiskImage disk = new DiskImage();
        // If the OVF is old and does not contain any storage type reference then we assume we can only have disk image.
        if (node.attributes.get("ovf:disk_storage_type") != null) {
            String diskStorageType = node.attributes.get("ovf:disk_storage_type").getValue();
            if (diskStorageType != null && diskStorageType.equals(DiskStorageType.CINDER.name())) {
                disk = new CinderDisk();
            }
        }
        disk.setImageId(new Guid(node.attributes.get("ovf:id").getValue()));
        disk.setId(OvfParser.GetImageGrupIdFromImageFile(node.attributes.get("ovf:href").getValue()));
        // Default values:
        disk.setActive(true);
        disk.setImageStatus(ImageStatus.OK);
        disk.setDescription(node.attributes.get("ovf:description").getValue());
        _images.add(disk);
    }
}
#end_block

#method_before
private int getResourceType(XmlNode node, String resource) {
    this.lastReadEntry = resource;
    if (node.SelectSingleNode(resource, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(resource, _xmlNS).innerText)) {
        return Integer.parseInt(node.SelectSingleNode(resource, _xmlNS).innerText);
    }
    return -1;
}
#method_after
private int getResourceType(XmlNode node, String resource) {
    if (selectSingleNode(node, resource, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, resource, _xmlNS).innerText)) {
        return Integer.parseInt(selectSingleNode(node, resource, _xmlNS).innerText);
    }
    return -1;
}
#end_block

#method_before
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.parseInt(OvfHardware.Monitor) == resourceType) {
            // if default display type is defined in the ovf, set the video device that is suitable for it
            if (defaultDisplayType != null) {
                vmDevice.setDevice(defaultDisplayType.getDefaultVmDeviceType().getName());
            } else {
                // get number of monitors from VirtualQuantity in OVF
                this.lastReadEntry = OvfProperties.VMD_VIRTUAL_QUANTITY;
                if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText)) {
                    int virtualQuantity = Integer.parseInt(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText);
                    if (virtualQuantity > 1) {
                        vmDevice.setDevice(VmDeviceType.QXL.getName());
                    } else {
                        // get first supported display device
                        List<Pair<GraphicsType, DisplayType>> supportedGraphicsAndDisplays = osRepository.getGraphicsAndDisplays(vmBase.getOsId(), new Version(getVersion()));
                        if (!supportedGraphicsAndDisplays.isEmpty()) {
                            DisplayType firstDisplayType = supportedGraphicsAndDisplays.get(0).getSecond();
                            vmDevice.setDevice(firstDisplayType.getDefaultVmDeviceType().getName());
                        } else {
                            vmDevice.setDevice(VmDeviceType.CIRRUS.getName());
                        }
                    }
                } else {
                    // default to spice if quantity not found
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                }
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.parseInt(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-5 as the VmInterfaceType enum
        VmInterfaceType nicType = VmInterfaceType.forValue(resourceSubType);
        if (nicType != null) {
            if (nicType == VmInterfaceType.pciPassthrough) {
                vmDevice.setDevice(VmDeviceType.HOST_DEVICE.getName());
            } else {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#method_after
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.parseInt(OvfHardware.Monitor) == resourceType) {
            // if default display type is defined in the ovf, set the video device that is suitable for it
            if (defaultDisplayType != null) {
                vmDevice.setDevice(defaultDisplayType.getDefaultVmDeviceType().getName());
            } else {
                // get number of monitors from VirtualQuantity in OVF
                if (selectSingleNode(node, OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText)) {
                    int virtualQuantity = Integer.parseInt(selectSingleNode(node, OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText);
                    if (virtualQuantity > 1) {
                        vmDevice.setDevice(VmDeviceType.QXL.getName());
                    } else {
                        // get first supported display device
                        List<Pair<GraphicsType, DisplayType>> supportedGraphicsAndDisplays = osRepository.getGraphicsAndDisplays(vmBase.getOsId(), new Version(getVersion()));
                        if (!supportedGraphicsAndDisplays.isEmpty()) {
                            DisplayType firstDisplayType = supportedGraphicsAndDisplays.get(0).getSecond();
                            vmDevice.setDevice(firstDisplayType.getDefaultVmDeviceType().getName());
                        } else {
                            vmDevice.setDevice(VmDeviceType.CIRRUS.getName());
                        }
                    }
                } else {
                    // default to spice if quantity not found
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                }
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.parseInt(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-5 as the VmInterfaceType enum
        VmInterfaceType nicType = VmInterfaceType.forValue(resourceSubType);
        if (nicType != null) {
            if (nicType == VmInterfaceType.pciPassthrough) {
                vmDevice.setDevice(VmDeviceType.HOST_DEVICE.getName());
            } else {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#end_block

#method_before
public String getLastReadEntry() {
    return this.lastReadEntry;
}
#method_after
public String getLastReadEntry() {
    return lastReadEntry;
}
#end_block

#method_before
@Override
protected void readOsSection(XmlNode section) {
    _vmTemplate.setId(new Guid(section.attributes.get("ovf:id").getValue()));
    this.lastReadEntry = "Description";
    XmlNode node = section.SelectSingleNode("Description");
    if (node != null) {
        int osId = osRepository.getOsIdByUniqueName(node.innerText);
        _vmTemplate.setOsId(osId);
        _vmTemplate.setClusterArch(osRepository.getArchitectureFromOS(osId));
    } else {
        _vmTemplate.setClusterArch(ArchitectureType.undefined);
    }
}
#method_after
@Override
protected void readOsSection(XmlNode section) {
    _vmTemplate.setId(new Guid(section.attributes.get("ovf:id").getValue()));
    XmlNode node = selectSingleNode(section, "Description");
    if (node != null) {
        int osId = osRepository.getOsIdByUniqueName(node.innerText);
        _vmTemplate.setOsId(osId);
        _vmTemplate.setClusterArch(osRepository.getArchitectureFromOS(osId));
    } else {
        _vmTemplate.setClusterArch(ArchitectureType.undefined);
    }
}
#end_block

#method_before
@Override
protected void readDiskImageItem(XmlNode node) {
    this.lastReadEntry = "rasd:InstanceId";
    final Guid guid = new Guid(node.SelectSingleNode("rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return diskImage.getImageId().equals(guid);
        }
    });
    this.lastReadEntry = "rasd:HostResource";
    image.setId(OvfParser.GetImageGrupIdFromImageFile(node.SelectSingleNode("rasd:HostResource", _xmlNS).innerText));
    this.lastReadEntry = "rasd:Parent";
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(node.SelectSingleNode("rasd:Parent", _xmlNS).innerText));
    }
    this.lastReadEntry = "rasd:Template";
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(node.SelectSingleNode("rasd:Template", _xmlNS).innerText));
    }
    this.lastReadEntry = "rasd:ApplicationList";
    image.setAppList(node.SelectSingleNode("rasd:ApplicationList", _xmlNS).innerText);
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:StorageId", _xmlNS).innerText)) {
        image.setStorageIds(new ArrayList<Guid>(Arrays.asList(new Guid(node.SelectSingleNode("rasd:StorageId", _xmlNS).innerText))));
    }
    this.lastReadEntry = "rasd:StoragePoolId";
    if (StringUtils.isNotEmpty(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).innerText));
    }
    this.lastReadEntry = "rasd:CreationDate";
    final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    this.lastReadEntry = "rasd:LastModified";
    final Date lastModified = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    readManagedVmDevice(node, image.getId());
}
#method_after
@Override
protected void readDiskImageItem(XmlNode node) {
    final Guid guid = new Guid(selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return diskImage.getImageId().equals(guid);
        }
    });
    image.setId(OvfParser.GetImageGrupIdFromImageFile(selectSingleNode(node, "rasd:HostResource", _xmlNS).innerText));
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(selectSingleNode(node, "rasd:Template", _xmlNS).innerText));
    }
    image.setAppList(selectSingleNode(node, "rasd:ApplicationList", _xmlNS).innerText);
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StorageId", _xmlNS).innerText)) {
        image.setStorageIds(new ArrayList<Guid>(Arrays.asList(new Guid(selectSingleNode(node, "rasd:StorageId", _xmlNS).innerText))));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText));
    }
    final Date creationDate = OvfParser.UtcDateStringToLocaDate(selectSingleNode(node, "rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    final Date lastModified = OvfParser.UtcDateStringToLocaDate(selectSingleNode(node, "rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    readManagedVmDevice(node, image.getId());
}
#end_block

#method_before
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    this.lastReadEntry = OvfProperties.NAME;
    XmlNode node = content.SelectSingleNode(OvfProperties.NAME);
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    this.lastReadEntry = OvfProperties.TEMPLATE_ID;
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    this.lastReadEntry = OvfProperties.IS_DISABLED;
    node = content.SelectSingleNode(OvfProperties.IS_DISABLED);
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.TRUSTED_SERVICE;
    node = content.SelectSingleNode(OvfProperties.TRUSTED_SERVICE);
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    this.lastReadEntry = OvfProperties.TEMPLATE_TYPE;
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_TYPE);
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    this.lastReadEntry = OvfProperties.BASE_TEMPLATE_ID;
    node = content.SelectSingleNode(OvfProperties.BASE_TEMPLATE_ID);
    if (node != null) {
        _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
    } else {
        // in case base template is missing, we assume it is a base template
        _vmTemplate.setBaseTemplateId(_vmTemplate.getId());
    }
    this.lastReadEntry = OvfProperties.TEMPLATE_VERSION_NUMBER;
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_VERSION_NUMBER);
    if (node != null) {
        _vmTemplate.setTemplateVersionNumber(Integer.parseInt(node.innerText));
    }
    this.lastReadEntry = OvfProperties.TEMPLATE_VERSION_NAME;
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_VERSION_NAME);
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
    this.lastReadEntry = "AutoStartup";
    node = content.SelectSingleNode("AutoStartup");
    if (node != null) {
        _vmTemplate.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
}
#method_after
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = selectSingleNode(content, OvfProperties.NAME);
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = selectSingleNode(content, OvfProperties.TEMPLATE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_DISABLED);
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.TRUSTED_SERVICE);
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.TEMPLATE_TYPE);
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.BASE_TEMPLATE_ID);
    if (node != null) {
        _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
    } else {
        // in case base template is missing, we assume it is a base template
        _vmTemplate.setBaseTemplateId(_vmTemplate.getId());
    }
    node = selectSingleNode(content, OvfProperties.TEMPLATE_VERSION_NUMBER);
    if (node != null) {
        _vmTemplate.setTemplateVersionNumber(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.TEMPLATE_VERSION_NAME);
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
    node = selectSingleNode(content, "AutoStartup");
    if (node != null) {
        _vmTemplate.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
}
#end_block

#method_before
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setProvisionedSize(entity.getSize());
    model.setActualSize(entity.getDiskStorageType() == org.ovirt.engine.core.common.businessentities.storage.DiskStorageType.CINDER ? null : entity.getActualSizeInBytes());
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getImageStatus() != null) {
        DiskStatus status = map(entity.getImageStatus());
        model.setStatus(StatusUtils.create(status == null ? null : status.value()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#method_after
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setProvisionedSize(entity.getSize());
    if (entity.hasActualSize()) {
        model.setActualSize(entity.getActualSizeInBytes());
    }
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getImageStatus() != null) {
        DiskStatus status = map(entity.getImageStatus());
        model.setStatus(StatusUtils.create(status == null ? null : status.value()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#end_block

#method_before
protected void loadVmInit() {
    if (!getVm().isInitialized() && getVm().getVmInit() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
    }
}
#method_after
protected void loadVmInit() {
    if (getVm() != null && getVm().getVmInit() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
    }
}
#end_block

#method_before
@Override
public void runningSucceded() {
    setFlow(RunVmFlow.RUNNING_SUCCEEDED);
    removeMemoryFromActiveSnapshot();
    super.runningSucceded();
}
#method_after
@Override
public void runningSucceded() {
    removeMemoryFromActiveSnapshot();
    setFlow(RunVmFlow.RUNNING_SUCCEEDED);
    super.runningSucceded();
}
#end_block

#method_before
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryVolumes(memory, getActionType(), true);
    }
}
#method_after
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    if (getFlow() == RunVmFlow.RESUME_HIBERNATE) {
        removeHibernationDisks(memory);
    } else // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryVolumes(memory, getActionType(), true);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getStorageDomain() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    if (!getStorageDomain().getStoragePoolId().equals(getStoragePoolId())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_AND_CLUSTER_IN_DIFFERENT_POOL);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
    }
    if (getStorageDomain().getStatus() != StorageDomainStatus.Active) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
    }
    if (getVdsId() != null && !validate(validateRequestedProxyHost())) {
        return false;
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateUniqueVmName()) {
        return false;
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!validateStorageSpace()) {
        return false;
    }
    if (getParameters().getVirtioIsoName() != null && getActiveIsoDomainId() == null) {
        return failCanDoAction(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getStorageDomain() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    if (!getStorageDomain().getStoragePoolId().equals(getStoragePoolId())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_AND_CLUSTER_IN_DIFFERENT_POOL);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
    }
    if (getStorageDomain().getStatus() != StorageDomainStatus.Active) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
    }
    if (getVdsId() != null && !validate(validateRequestedProxyHost())) {
        return false;
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateUniqueVmName()) {
        return false;
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!validateStorageSpace()) {
        return false;
    }
    if (getParameters().getVirtioIsoName() != null && getActiveIsoDomainId() == null) {
        return failCanDoAction(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    return true;
}
#end_block

#method_before
@Override
protected void perform() {
    addMemoryDisk();
    addMetadataDisk();
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    createMemoryDumpDisk();
    createMemoryMetadataDisk();
    setSucceeded(true);
}
#end_block

#method_before
private void addDisk(DiskImage disk) {
    VdcReturnValueBase returnValue = runInternalActionWithTasksContext(VdcActionType.AddDisk, buildAddDiskParameters(disk));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), String.format("Failed to create disk! %s", disk.getDiskAlias()));
    }
    getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
}
#method_after
private Guid addDisk(DiskImage disk) {
    AddDiskParameters addDiskParameters = new AddDiskParameters(Guid.Empty, disk);
    addDiskParameters.setStorageDomainId(getStorageDomainId());
    addDiskParameters.setParentCommand(getActionType());
    addDiskParameters.setParentParameters(getParameters());
    addDiskParameters.setShouldBeLogged(false);
    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.AddDisk, addDiskParameters);
    if (vdcReturnValue.getSucceeded()) {
        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        return vdcReturnValue.getActionReturnValue();
    } else {
        throw new EngineException(vdcReturnValue.getFault().getError(), String.format("Failed to create disk! %s", disk.getDiskAlias()));
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            List<VDS> hosts = (List<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(false);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = UICommand.createDefaultOkUiCommand("OnRemove", StorageListModel.this);
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            List<VDS> hosts = (List<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = UICommand.createDefaultOkUiCommand("OnRemove", StorageListModel.this);
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
@Override
protected void perform() {
    DiskImage memoryDisk = MemoryUtils.createMemoryDiskForVm(getVm(), getStorageDomain().getStorageType());
    Guid dumpDiskId = addDisk(memoryDisk);
    DiskImage metaDataDisk = MemoryUtils.createMetadataDiskForVm(getVm());
    Guid metadataDiskId = addDisk(metaDataDisk);
    DiskImage dumpDisk = getDisk(dumpDiskId);
    DiskImage metadataDisk = getDisk(metadataDiskId);
    getSnapshotDao().updateHibernationMemory(getVmId(), dumpDisk.getId(), metadataDisk.getId(), createHibernationVolumeString(dumpDisk, metadataDisk));
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    Guid dumpDiskId = createMemoryDumpDisk();
    Guid metadataDiskId = createMemoryMetadataDisk();
    DiskImage dumpDisk = getDisk(dumpDiskId);
    DiskImage metadataDisk = getDisk(metadataDiskId);
    getSnapshotDao().updateHibernationMemory(getVmId(), dumpDisk.getId(), metadataDisk.getId(), createHibernationVolumeString(dumpDisk, metadataDisk));
    setSucceeded(true);
}
#end_block

#method_before
private Guid addDisk(DiskImage disk) {
    VdcReturnValueBase returnValue = runInternalActionWithTasksContext(VdcActionType.AddDisk, buildAddDiskParameters(disk));
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
        return returnValue.getActionReturnValue();
    } else {
        throw new EngineException(returnValue.getFault().getError(), String.format("Failed to create disk! %s", disk.getDiskAlias()));
    }
}
#method_after
private Guid addDisk(DiskImage disk) {
    AddDiskParameters addDiskParameters = new AddDiskParameters(Guid.Empty, disk);
    addDiskParameters.setStorageDomainId(getStorageDomainId());
    addDiskParameters.setParentCommand(getActionType());
    addDiskParameters.setParentParameters(getParameters());
    addDiskParameters.setShouldBeLogged(false);
    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.AddDisk, addDiskParameters);
    if (vdcReturnValue.getSucceeded()) {
        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        return vdcReturnValue.getActionReturnValue();
    } else {
        throw new EngineException(vdcReturnValue.getFault().getError(), String.format("Failed to create disk! %s", disk.getDiskAlias()));
    }
}
#end_block

#method_before
private void cleanupPassthroughVnics() {
    Map<Guid, String> vnicToVfMap = getVnicToVfMap();
    if (vnicToVfMap != null) {
        networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(vnicToVfMap.values()));
    }
    vfScheduler.cleanVmData(getVmId());
}
#method_after
private void cleanupPassthroughVnics() {
    Map<Guid, String> vnicToVfMap = getVnicToVfMap();
    if (vnicToVfMap != null) {
        hostNicVfsConfigHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(vnicToVfMap.values()));
    }
    vfScheduler.cleanVmData(getVmId());
}
#end_block

#method_before
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#method_after
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJob(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#end_block

#method_before
protected boolean isVmPartOfManualPool() {
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    final VmPool vmPool = getDbFacade().getVmPoolDao().get(getVm().getVmPoolId());
    return vmPool.getVmPoolType().equals(VmPoolType.MANUAL);
}
#method_after
protected boolean isVmPartOfManualPool() {
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    final VmPool vmPool = getDbFacade().getVmPoolDao().get(getVm().getVmPoolId());
    return vmPool.getVmPoolType().equals(VmPoolType.Manual);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("user_id", Guid.isNullOrEmpty(entity.getUserId()) ? Guid.Empty : entity.getUserId()).addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("parent_command_id", Guid.isNullOrEmpty(entity.getParentCommandId()) ? Guid.Empty : entity.getParentCommandId()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("job_id", Guid.isNullOrEmpty(entity.getJobId()) ? Guid.Empty : entity.getJobId()).addValue("step_id", Guid.isNullOrEmpty(entity.getStepId()) ? Guid.Empty : entity.getStepId()).addValue("command_parameters", serializeParameters(entity.getCommandParameters())).addValue("command_params_class", entity.getCommandParameters() == null ? null : entity.getCommandParameters().getClass().getName()).addValue("status", entity.getCommandStatus().toString()).addValue("executed", entity.isExecuted()).addValue("callback_enabled", entity.isCallbackEnabled()).addValue("return_value", serializeReturnValue(entity.getReturnValue())).addValue("return_value_class", entity.getReturnValue() == null ? null : entity.getReturnValue().getClass().getName());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("user_id", Guid.isNullOrEmpty(entity.getUserId()) ? Guid.Empty : entity.getUserId()).addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("parent_command_id", entity.getParentCommandId()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("job_id", Guid.isNullOrEmpty(entity.getJobId()) ? Guid.Empty : entity.getJobId()).addValue("step_id", Guid.isNullOrEmpty(entity.getStepId()) ? Guid.Empty : entity.getStepId()).addValue("command_parameters", serializeParameters(entity.getCommandParameters())).addValue("command_params_class", entity.getCommandParameters() == null ? null : entity.getCommandParameters().getClass().getName()).addValue("created_at", entity.getCreatedAt()).addValue("status", entity.getCommandStatus().toString()).addValue("executed", entity.isExecuted()).addValue("callback_enabled", entity.isCallbackEnabled()).addValue("return_value", serializeReturnValue(entity.getReturnValue())).addValue("return_value_class", entity.getReturnValue() == null ? null : entity.getReturnValue().getClass().getName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getParameters().setVdsmTaskIds(new ArrayList<Guid>());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getReturnValue().getInternalVdsmTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        getParameters().getVdsmTaskIds().add(result);
        setSucceeded(vdsReturnValue.getSucceeded());
        persistCommand(getParameters().getParentCommand(), true);
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        setSucceeded(false);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getParameters().setVdsmTaskIds(new ArrayList<Guid>());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getReturnValue().getInternalVdsmTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        getParameters().getVdsmTaskIds().add(result);
        setSucceeded(vdsReturnValue.getSucceeded());
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        setSucceeded(false);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    CommandEntity other = (CommandEntity) obj;
    return ObjectUtils.objectsEqual(commandId, other.commandId) && commandType == other.commandType && ObjectUtils.objectsEqual(getGuid(rootCommandId), getGuid(other.rootCommandId));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    CommandEntity other = (CommandEntity) obj;
    return ObjectUtils.objectsEqual(commandId, other.commandId) && commandType == other.commandType && ObjectUtils.objectsEqual(getGuid(parentCommandId), getGuid(other.parentCommandId)) && ObjectUtils.objectsEqual(getGuid(rootCommandId), getGuid(other.rootCommandId));
}
#end_block

#method_before
@PostConstruct
protected final void postConstruct() {
    if (!isCompensationContext()) {
        init();
    }
}
#method_after
@PostConstruct
protected final void postConstruct() {
    if (!isCompensationContext()) {
        initCommandBase();
        init();
    }
}
#end_block

#method_before
protected BackendInternal getBackend() {
    return Injector.get(BackendInternal.class);
}
#method_after
protected BackendInternal getBackend() {
    return backendInternal;
}
#end_block

#method_before
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        startFinalizingStep();
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        startFinalizingStep();
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
        callEndActionOnParentCoCoChild(isEndSuccessfully());
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean hasParentCommand() {
    return getParentCommand() != VdcActionType.Unknown;
}
#method_after
protected boolean hasParentCommand() {
    return getParentCommandType() != VdcActionType.Unknown;
}
#end_block

#method_before
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#method_after
protected boolean isQuotaDependant() {
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE) {
        return false;
    }
    if (!isInternalExecution()) {
        return true;
    }
    return getActionType().isQuotaDependentAsInternalCommand();
}
#end_block

#method_before
protected boolean isExecutedAsChildCommand() {
    return getParentCommand() != VdcActionType.Unknown;
}
#method_after
protected boolean isExecutedAsChildCommand() {
    return getParentCommandType() != VdcActionType.Unknown;
}
#end_block

#method_before
protected VdcActionParametersBase getParametersForTask(VdcActionType actionType, VdcActionParametersBase parameters) {
    VdcActionType parentCommandType = getParentCommand(actionType);
    // If there is no parent command, the command that its type
    // will be stored in the DB for thr task is the one creating the command
    VdcActionParametersBase parentParameters = null;
    if (isParentCoCoChild()) {
        if (getTaskType() == AsyncTaskType.notSupported) {
            parentParameters = getParameters().getParentParameters();
        }
    } else {
        if (parentHasCallback()) {
            if (getTaskType() == AsyncTaskType.notSupported) {
                parentParameters = getParameters().getParentParameters();
            }
        } else {
            parentParameters = getParameters().getParentParameters();
        }
    }
    if (parentCommandType == VdcActionType.Unknown || parentParameters == null) {
        return parameters;
    }
    // The parent parameters are the ones that are kept for the task.
    // In order to make sure that in case of rollback-by-command, the ROLLBACK
    // flow will be called, the execution reason of the child command is set
    // to the one of the parent command (if its REGULAR_FLOW, the execution
    // reason of the parent command remains REGULAR_FLOW).
    parentParameters.setExecutionReason(parameters.getExecutionReason());
    parentParameters.setCommandType(parentCommandType);
    return parentParameters;
}
#method_after
protected VdcActionParametersBase getParametersForTask(VdcActionType actionType, VdcActionParametersBase parameters) {
    VdcActionType parentCommandType = getParentCommandType(actionType);
    // If there is no parent command, the command that its type
    // will be stored in the DB for thr task is the one creating the command
    VdcActionParametersBase parentParameters = getParentParameters();
    if (parentCommandType == VdcActionType.Unknown || parentParameters == null) {
        return parameters;
    }
    // The parent parameters are the ones that are kept for the task.
    // In order to make sure that in case of rollback-by-command, the ROLLBACK
    // flow will be called, the execution reason of the child command is set
    // to the one of the parent command (if its REGULAR_FLOW, the execution
    // reason of the parent command remains REGULAR_FLOW).
    parentParameters.setExecutionReason(parameters.getExecutionReason());
    parentParameters.setCommandType(parentCommandType);
    return parentParameters;
}
#end_block

#method_before
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group " + permSubject.getActionGroup().name() + " with role type " + permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#method_after
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group ").append(permSubject.getActionGroup().name()).append(" with role type ").append(permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#end_block

#method_before
public T getParameters() {
    return _parameters;
}
#method_after
@Override
public T getParameters() {
    return _parameters;
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType actionType, final String taskKey) {
    VdcActionType parentCommand = getRootCommand(actionType);
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType actionType, final String taskKey) {
    VdcActionType parentCommand = getRootCommandType(actionType);
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#end_block

#method_before
private Guid createTaskImpl(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return CommandCoordinatorUtil.createTask(taskId, this, asyncTaskCreationInfo, getRootCommand(parentCommand), description, entitiesMap);
}
#method_after
private Guid createTaskImpl(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return CommandCoordinatorUtil.createTask(taskId, this, asyncTaskCreationInfo, getRootCommandType(parentCommand), description, entitiesMap);
}
#end_block

#method_before
protected ArrayList<Guid> getTaskIdList() {
    return getParentCommand() != VdcActionType.Unknown ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
}
#method_after
protected ArrayList<Guid> getTaskIdList() {
    return getParentCommandType() != VdcActionType.Unknown ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
}
#end_block

#method_before
protected List<String> extractVariableDeclarations(Iterable<String> appendedCanDoMsgs) {
    final List<String> result = new ArrayList<>();
    Iterator<String> iter = appendedCanDoMsgs.iterator();
    while (iter.hasNext()) {
        result.addAll(Arrays.asList(iter.next().split("(?=\\$)")));
    }
    return result;
}
#method_after
protected List<String> extractVariableDeclarations(Iterable<String> appendedCanDoMsgs) {
    final List<String> result = new ArrayList<>();
    for (String appendedCanDoMsg : appendedCanDoMsgs) {
        result.addAll(Arrays.asList(appendedCanDoMsg.split("(?=\\$)")));
    }
    return result;
}
#end_block

#method_before
protected VdcReturnValueBase convertToVdcReturnValueBase(final VDSReturnValue vdsReturnValue) {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(false);
    returnValue.setActionReturnValue(vdsReturnValue.getReturnValue());
    returnValue.setExecuteFailedMessages(new ArrayList<String>() {

        {
            add(vdsReturnValue.getVdsError().getMessage());
        }
    });
    return returnValue;
}
#method_after
protected VdcReturnValueBase convertToVdcReturnValueBase(final VDSReturnValue vdsReturnValue) {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(false);
    returnValue.setActionReturnValue(vdsReturnValue.getReturnValue());
    String message = vdsReturnValue.getVdsError().getMessage();
    returnValue.setExecuteFailedMessages(new ArrayList<>(Collections.singleton(message)));
    return returnValue;
}
#end_block

#method_before
protected long getEngineSessionSeqId() {
    String sessionId = getParameters().getSessionId();
    if (sessionId == null && getContext() != null) {
        sessionId = getContext().getEngineContext().getSessionId();
    }
    if (sessionId == null) {
        throw new RuntimeException("No sessionId found for command " + getClass().getName());
    }
    return SessionDataContainer.getInstance().getEngineSessionSeqId(sessionId);
}
#method_after
protected long getEngineSessionSeqId() {
    String sessionId = getParameters().getSessionId();
    if (sessionId == null && getContext() != null) {
        sessionId = getContext().getEngineContext().getSessionId();
    }
    if (sessionId == null) {
        throw new RuntimeException("No sessionId found for command " + getClass().getName());
    }
    return getSessionDataContainer().getEngineSessionSeqId(sessionId);
}
#end_block

#method_before
public VdcActionParametersBase getParentParameters() {
    VdcActionParametersBase parentParameters = getParameters();
    if (isParentCoCoChild()) {
        if (getTaskType() == AsyncTaskType.notSupported) {
            parentParameters = getParameters().getParentParameters();
        }
    } else {
        if (parentHasCallback()) {
            if (getTaskType() == AsyncTaskType.notSupported) {
                parentParameters = getParameters().getParentParameters();
            }
        } else {
            parentParameters = getParameters().getParentParameters();
        }
    }
    return parentParameters;
}
#method_after
public VdcActionParametersBase getParentParameters() {
    VdcActionParametersBase parentParameters = getParameters();
    if (parentHasCallback()) {
        if (getTaskType() == AsyncTaskType.notSupported) {
            parentParameters = getParameters().getParentParameters();
        }
    } else {
        parentParameters = getParameters().getParentParameters();
    }
    return parentParameters;
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P withRootCommandInfo(P params, VdcActionType actionType) {
    VdcActionType parentCommand = getParentCommand(actionType);
    params.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    params.setParentCommand(parentCommand);
    return params;
}
#method_after
protected <P extends VdcActionParametersBase> P withRootCommandInfo(P params, VdcActionType actionType) {
    VdcActionType parentCommand = getParentCommandType(actionType);
    params.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    params.setParentCommand(parentCommand);
    return params;
}
#end_block

#method_before
private boolean shouldRemoveCommand(AsyncTask asyncTask) {
    if (asyncTask == null || Guid.isNullOrEmpty(asyncTask.getCommandId())) {
        return false;
    }
    CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
    CommandEntity parentEntity = coco.getCommandEntity(asyncTask.getRootCommandId());
    return (cmdEntity != null && !cmdEntity.isCallbackEnabled() && (parentEntity == null || !parentEntity.isCallbackEnabled()));
}
#method_after
private boolean shouldRemoveCommand(AsyncTask asyncTask) {
    if (asyncTask == null || Guid.isNullOrEmpty(asyncTask.getCommandId())) {
        return false;
    }
    CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
    CommandEntity parentEntity = null;
    if (cmdEntity != null) {
        parentEntity = coco.getCommandEntity(cmdEntity.getParentCommandId());
    }
    return (cmdEntity != null && !cmdEntity.isCallbackEnabled() && (parentEntity == null || !parentEntity.isCallbackEnabled()));
}
#end_block

#method_before
private static void addContextMessage(ExtMap context, boolean error, String message) {
    ExtKey key;
    if (error) {
        key = ContextKeys.ERR_MESSAGES;
    } else {
        key = ContextKeys.OUT_MESSAGES;
    }
    ((List<String>) context.get(key, List.class)).add(message);
}
#method_after
protected static void addContextMessage(ExtMap context, boolean error, String message) {
    ExtKey key;
    if (error) {
        key = ContextKeys.ERR_MESSAGES;
    } else {
        key = ContextKeys.OUT_MESSAGES;
    }
    ((List<String>) context.get(key, List.class)).add(message);
}
#end_block

#method_before
@Override
public void edit(final UnitVmModel object) {
    super.edit(object);
    if (object.getIsNew()) {
        object.getNumOfDesktops().setEntity(1);
    }
    prestartedVmsEditor.setEnabled(true);
}
#method_after
@Override
public void edit(final UnitVmModel object) {
    super.edit(object);
    if (object.getIsNew()) {
        object.getNumOfDesktops().setEntity(1);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        activateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    // Master domain must not go through the Activating status.
    changeStorageDomainStatusInTransaction(map, (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) ? StorageDomainStatus.Locked : StorageDomainStatus.Activating);
    freeLock();
    log.info("ActivateStorage Domain. Before Connect all hosts to pool. Time: {}", new Date());
    List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
    if (!validateHostsConnectionResults(hostsConnectionResults)) {
        log.info("Cannot connect storage server, aborting Storage Domain activation. Time: {}", new Date());
        setSucceeded(false);
        return;
    }
    syncStorageDomainInfo(hostsConnectionResults);
    runVdsCommand(VDSCommandType.ActivateStorageDomain, new ActivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId()));
    log.info("ActivateStorage Domain. After Connect all hosts to pool. Time: {}", new Date());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            map.setStatus(StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                calcStoragePoolStatusByDomainsStatus();
            }
            return null;
        }
    });
    refreshAllVdssInPool();
    log.info("ActivateStorage Domain. After change storage pool status in vds. Time: {}", new Date());
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        IsoDomainListSyncronizer.getInstance().refresheIsoDomainWhenActivateDomain(getStorageDomain().getId(), getStoragePool().getId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        activateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    // Master domain must not go through the Activating status.
    changeStorageDomainStatusInTransaction(map, (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) ? StorageDomainStatus.Locked : StorageDomainStatus.Activating);
    freeLock();
    log.info("ActivateStorage Domain. Before Connect all hosts to pool. Time: {}", new Date());
    List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
    if (isAllHostConnectionFailed(hostsConnectionResults)) {
        log.error("Cannot connect storage server, aborting Storage Domain activation.");
        setSucceeded(false);
        return;
    }
    syncStorageDomainInfo(hostsConnectionResults);
    runVdsCommand(VDSCommandType.ActivateStorageDomain, new ActivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId()));
    log.info("ActivateStorage Domain. After Connect all hosts to pool. Time: {}", new Date());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            map.setStatus(StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                calcStoragePoolStatusByDomainsStatus();
            }
            return null;
        }
    });
    refreshAllVdssInPool();
    log.info("ActivateStorage Domain. After change storage pool status in vds. Time: {}", new Date());
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        IsoDomainListSyncronizer.getInstance().refresheIsoDomainWhenActivateDomain(getStorageDomain().getId(), getStoragePool().getId());
    }
    setSucceeded(true);
}
#end_block

#method_before
static boolean validatePinningAndMigration(List<String> reasons, VmStatic vmStaticData, String cpuPinning) {
    final boolean cpuPinMigrationEnabled = Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinMigrationEnabled));
    if (!cpuPinMigrationEnabled && (vmStaticData.getMigrationSupport() == MigrationSupport.MIGRATABLE || vmStaticData.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE) && StringUtils.isNotEmpty(cpuPinning)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE.toString());
        return false;
    }
    if (vmStaticData.isAutoStartup() && vmStaticData.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
        return false;
    }
    return true;
}
#method_after
static boolean validatePinningAndMigration(List<String> reasons, VmStatic vmStaticData, String cpuPinning) {
    final boolean cpuPinMigrationEnabled = Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinMigrationEnabled));
    if (!cpuPinMigrationEnabled && (vmStaticData.getMigrationSupport() == MigrationSupport.MIGRATABLE || vmStaticData.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE) && StringUtils.isNotEmpty(cpuPinning)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE.toString());
        return false;
    }
    if (vmStaticData.isAutoStartup() && // VM has to be either migratable
    (vmStaticData.getMigrationSupport() != MigrationSupport.MIGRATABLE && // or have multiple hosts (no host means any host) in the pinning list
    vmStaticData.getDedicatedVmForVdsList().size() == 1)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
public void updateHaAvailability() {
    boolean automaticMigrationAllowed = getModel().getMigrationMode().getSelectedItem() == MigrationSupport.MIGRATABLE;
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    boolean isHighlyAvailable = getModel().getIsHighlyAvailable().getEntity();
    if (!automaticMigrationAllowed && pinToHostSize < 2) {
        getModel().getIsHighlyAvailable().setChangeProhibitionReason(constants.hostNonMigratable());
        getModel().getIsHighlyAvailable().setEntity(false);
    }
    getModel().getIsHighlyAvailable().setIsChangeable(isHighlyAvailable || automaticMigrationAllowed || pinToHostSize >= 2);
}
#method_after
public void updateHaAvailability() {
    boolean automaticMigrationAllowed = getModel().getMigrationMode().getSelectedItem() == MigrationSupport.MIGRATABLE;
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    boolean isHighlyAvailable = getModel().getIsHighlyAvailable().getEntity();
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (!automaticMigrationAllowed && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2) && !isHighlyAvailable) {
        getModel().getIsHighlyAvailable().setChangeProhibitionReason(constants.hostNonMigratable());
        getModel().getIsHighlyAvailable().setEntity(false);
        isHighlyAvailable = false;
    }
    getModel().getIsHighlyAvailable().setIsChangeable(isHighlyAvailable || automaticMigrationAllowed || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#end_block

#method_before
public void updateMigrationAvailability() {
    Boolean haHost = getModel().getIsHighlyAvailable().getEntity();
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    if (haHost && pinToHostSize < 2) {
        getModel().getMigrationMode().setChangeProhibitionReason(constants.hostIsHa());
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.MIGRATABLE);
    }
    getModel().getMigrationMode().setIsChangeable(!haHost || pinToHostSize >= 2);
}
#method_after
public void updateMigrationAvailability() {
    Boolean haHost = getModel().getIsHighlyAvailable().getEntity();
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (haHost && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2)) {
        getModel().getMigrationMode().setChangeProhibitionReason(constants.hostIsHa());
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.MIGRATABLE);
    }
    getModel().getMigrationMode().setIsChangeable(!haHost || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayAndGraphics();
            behavior.updateNumOfIoThreads();
            initUsbPolicy();
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
            behavior.updateHaAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayAndGraphics();
            behavior.updateNumOfIoThreads();
            initUsbPolicy();
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        }
    }
}
#end_block

#method_before
private void watchdogModelSelectedItemChanged(Object sender, EventArgs args) {
    if (getWatchdogModel().getSelectedItem() == null) {
        getWatchdogAction().setIsChangeable(false);
        getWatchdogAction().setSelectedItem(null);
    } else {
        getWatchdogAction().setIsChangeable(true);
    }
}
#method_after
private void watchdogModelSelectedItemChanged(Object sender, EventArgs args) {
    if (getWatchdogModel().getSelectedItem() == null) {
        getWatchdogAction().setIsChangeable(false);
    } else {
        getWatchdogAction().setIsChangeable(true);
    }
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(osType));
    getInitrd_path().setIsChangeable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangeable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangeable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
    getInstanceImages().updateActionsAvailability();
    updateIconAccordingToOs();
    initGraphicsConsoles();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(osType));
    getInitrd_path().setIsChangeable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangeable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangeable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
    getInstanceImages().updateActionsAvailability();
    updateIconAccordingToOs();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private void updateIconAccordingToOs() {
    final Integer osId = getOSType().getSelectedItem();
    final String oldIcon = getIcon().getEntity() == null ? null : getIcon().getEntity().getIcon();
    final Guid osDefaultIconId = AsyncDataProvider.getInstance().getOsDefaultIconId(osId, false);
    IconCache.getInstance().getOrFetchIcon(osDefaultIconId, new IconCache.IconCallback() {

        @Override
        public void onSuccess(String currentOsDefaultIcon) {
            String iconToShow = getIconToShow(currentOsDefaultIcon);
            Guid smallIconId = getSmallIconId(iconToShow, oldIcon, currentOsDefaultIcon, osDefaultIconId);
            IconWithOsDefault newIconPair = new IconWithOsDefault(iconToShow, currentOsDefaultIcon, smallIconId);
            getIcon().setEntity(newIconPair);
        }
    });
}
#method_after
private void updateIconAccordingToOs() {
    final Integer osId = getOSType().getSelectedItem();
    final Guid largeOsIconId = AsyncDataProvider.getInstance().getOsDefaultIconId(osId, false);
    final Guid smallOsIconId = AsyncDataProvider.getInstance().getSmallByLargeOsDefaultIconId(largeOsIconId);
    if (getIcon().getEntity() == null) {
        IconWithOsDefault.create(largeOsIconId, smallOsIconId, new IconWithOsDefault.IconWithOsDefaultCallback() {

            @Override
            public void onCreated(IconWithOsDefault instance) {
                getIcon().setEntity(instance);
            }
        });
    } else {
        getIcon().getEntity().withDifferentOsIcon(largeOsIconId, smallOsIconId, new IconWithOsDefault.IconWithOsDefaultCallback() {

            @Override
            public void onCreated(IconWithOsDefault instance) {
                getIcon().setEntity(instance);
            }
        });
    }
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<VmWatchdogType> watchDogModels = new ArrayList<VmWatchdogType>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(vmWatchdogType);
    }
    watchDogModels.add(0, null);
    VmWatchdogType oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<VmWatchdogType> watchDogModels = new ArrayList<VmWatchdogType>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(vmWatchdogType);
    }
    watchDogModels.add(0, null);
    VmWatchdogType oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    if (watchDogModels.contains(getWatchdogModel().getSelectedItem())) {
        getWatchdogModel().setItems(watchDogModels, getWatchdogModel().getSelectedItem());
    } else {
        getWatchdogModel().setItems(watchDogModels);
    }
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
public boolean isCpuPinningValid(final String cpuPinning, VmStatic vmStatic) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return true;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        addCanDoActionMessage(EngineMessage.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    HashSet<Integer> vcpus = new HashSet<>();
    String[] rules = cpuPinning.split("_");
    int maxvCPU = vmStatic.getNumOfCpus();
    VDS dedicatedVds = null;
    // can not check if no dedicated vds was configured
    if (vmStatic.getDedicatedVmForVdsList().isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_WITH_UNDEFINED_HOST);
    }
    for (Guid dedicatedHostGuid : vmStatic.getDedicatedVmForVdsList()) {
        dedicatedVds = getVds(dedicatedHostGuid);
        Collection<Integer> onlinePcpus = new HashSet<>();
        if (dedicatedVds.getOnlineCpus() != null) {
            String[] onlinePcpusStr = dedicatedVds.getOnlineCpus().split(",");
            for (String Pcpu : onlinePcpusStr) {
                onlinePcpus.add(Integer.parseInt(Pcpu));
            }
        }
        for (String rule : rules) {
            // [0] vcpu, [1] pcpu
            String[] splitRule = rule.split("#");
            int currVcpu = Integer.parseInt(splitRule[0]);
            if (currVcpu >= maxvCPU) {
                // ERROR maps to a non existent vcpu
                return failCanDoAction(EngineMessage.VM_PINNING_VCPU_DOES_NOT_EXIST);
            }
            if (!vcpus.add(currVcpu)) {
                // ERROR contains more than one definition for the same vcpu
                return failCanDoAction(EngineMessage.VM_PINNING_DUPLICATE_DEFINITION);
            }
            Collection<Integer> currPcpus = parsePCpuPinningNumbers(splitRule[1]);
            if (currPcpus == null) {
                return failCanDoAction(EngineMessage.VM_PINNING_FORMAT_INVALID);
            }
            if (currPcpus.size() == 0) {
                // definition of pcpus is no cpu, e.g 0#1,^1
                return failCanDoAction(EngineMessage.VM_PINNING_PINNED_TO_NO_CPU);
            }
        }
    }
    return true;
}
#method_after
public boolean isCpuPinningValid(final String cpuPinning, VmStatic vmStatic) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return true;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        addCanDoActionMessage(EngineMessage.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    HashSet<Integer> vcpus = new HashSet<>();
    String[] rules = cpuPinning.split("_");
    int maxvCPU = vmStatic.getNumOfCpus();
    // can not check if no dedicated vds was configured
    if (vmStatic.getDedicatedVmForVdsList().isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_WITH_UNDEFINED_HOST);
    }
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxvCPU) {
            // ERROR maps to a non existent vcpu
            return failCanDoAction(EngineMessage.VM_PINNING_VCPU_DOES_NOT_EXIST);
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more than one definition for the same vcpu
            return failCanDoAction(EngineMessage.VM_PINNING_DUPLICATE_DEFINITION);
        }
        Collection<Integer> currPcpus = parsePCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return failCanDoAction(EngineMessage.VM_PINNING_FORMAT_INVALID);
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return failCanDoAction(EngineMessage.VM_PINNING_PINNED_TO_NO_CPU);
        }
    }
    return true;
}
#end_block

#method_before
static boolean validatePinningAndMigration(List<String> reasons, VmStatic vmStaticData, String cpuPinning) {
    final boolean cpuPinMigrationEnabled = Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinMigrationEnabled));
    if (!cpuPinMigrationEnabled && (vmStaticData.getMigrationSupport() == MigrationSupport.MIGRATABLE || vmStaticData.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE) && StringUtils.isNotEmpty(cpuPinning)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE.toString());
        return false;
    }
    if (vmStaticData.isAutoStartup() && // VM has to be either migratable
    (vmStaticData.getMigrationSupport() != MigrationSupport.MIGRATABLE && // or have multiple hosts in the pinning list
    vmStaticData.getDedicatedVmForVdsList().size() < 2)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
        return false;
    }
    return true;
}
#method_after
static boolean validatePinningAndMigration(List<String> reasons, VmStatic vmStaticData, String cpuPinning) {
    final boolean cpuPinMigrationEnabled = Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinMigrationEnabled));
    if (!cpuPinMigrationEnabled && (vmStaticData.getMigrationSupport() == MigrationSupport.MIGRATABLE || vmStaticData.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE) && StringUtils.isNotEmpty(cpuPinning)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE.toString());
        return false;
    }
    if (vmStaticData.isAutoStartup() && // VM has to be either migratable
    (vmStaticData.getMigrationSupport() != MigrationSupport.MIGRATABLE && // or have multiple hosts (no host means any host) in the pinning list
    vmStaticData.getDedicatedVmForVdsList().size() == 1)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean canDo = false;
    if (!Guid.isNullOrEmpty(getParameters().getUserId())) {
        DbUser dbUser = getDbFacade().getDbUserDao().get(getParameters().getUserId());
        if (dbUser == null) {
            addCanDoActionMessage(EngineMessage.USER_MUST_EXIST_IN_DB);
            return false;
        }
        UserProfile userProfile = getDbFacade().getUserProfileDao().getByUserId(getParameters().getUserId());
        if (userProfile == null || StringUtils.isEmpty(userProfile.getSshPublicKey())) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_PROFILE_NOT_EXIST);
            return false;
        }
        canDo = true;
    } else if (StringUtils.isNotEmpty(getParameters().getAuthzName()) && StringUtils.isNotEmpty(getParameters().getUserName())) {
        DbUser dbUser = getDbFacade().getDbUserDao().getByUsernameAndDomain(getParameters().getUserName(), getParameters().getAuthzName());
        if (dbUser == null) {
            addCanDoActionMessage(EngineMessage.USER_MUST_EXIST_IN_DB);
            return false;
        }
    } else if (StringUtils.isNotEmpty(getParameters().getAuthzName()) && StringUtils.isNotEmpty(getParameters().getExternalId()) && StringUtils.isNotEmpty(getParameters().getNamespace())) {
        DbUser dbUser = getDbFacade().getDbUserDao().getByExternalId(getParameters().getAuthzName(), getParameters().getExternalId());
        if (dbUser == null) {
            addCanDoActionMessage(EngineMessage.USER_MUST_EXIST_IN_DB);
            return false;
        }
        AuthenticationProfile profile = getProfileByAuthzName(getParameters().getAuthzName());
        if (profile == null) {
            log.error("Can't login because authentication profile '{}' doesn't exist.", getParameters().getAuthzName());
            addCanDoActionMessage(EngineMessage.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        canDo = true;
    }
    return canDo;
}
#method_after
@Override
protected boolean canDoAction() {
    return isInternalExecution() ? true : failCanDoAction(EngineMessage.USER_CANNOT_RUN_ACTION_INTERNAL_COMMAND);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUser dbUser = null;
    if (!Guid.isNullOrEmpty(getParameters().getUserId())) {
        dbUser = getDbFacade().getDbUserDao().get(getParameters().getUserId());
    } else if (StringUtils.isNotEmpty(getParameters().getAuthzName()) && StringUtils.isNotEmpty(getParameters().getUserName())) {
        dbUser = getDbFacade().getDbUserDao().getByUsernameAndDomain(getParameters().getUserName(), getParameters().getAuthzName());
    }
    if (StringUtils.isNotEmpty(getParameters().getAuthzName()) && StringUtils.isNotEmpty(getParameters().getExternalId()) && StringUtils.isNotEmpty(getParameters().getNamespace())) {
        dbUser = getDbFacade().getDbUserDao().getByExternalId(getParameters().getNamespace(), getParameters().getExternalId());
    }
    setCurrentUser(dbUser);
    loginOnBehalf(dbUser.getExternalId(), dbUser.getDomain(), dbUser.getNamespace());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        DbUser dbUser = getDbUser();
        logInfo = String.format("for user %s", dbUser.getLoginName());
        getReturnValue().setActionReturnValue(createSession(dbUser, dbUser.getDomain(), loginOnBehalf(dbUser)));
        setSucceeded(true);
    } catch (Exception ex) {
        log.error("Unable to create engine session: {}", ex.getMessage());
        log.debug("Unable to create engine session", ex);
    }
}
#end_block

#method_before
private void loginOnBehalf(String externalId, String authzName, String namespace) {
    try {
        AuthenticationProfile profile = getProfileByAuthzName(authzName);
        DirectoryUser pR = DirectoryUtils.findDirectoryUserById(profile.getAuthz(), namespace, externalId, true, true);
        Collection<ExtMap> principalRecords = AuthzUtils.findPrincipalsByIds(profile.getAuthz(), namespace, Arrays.asList(externalId), true, true);
        if (!principalRecords.isEmpty()) {
            ExtMap principalRecord = principalRecords.iterator().next();
            DirectoryUtils.flatGroups(principalRecord);
            attachUserToSession(profile, principalRecord);
        }
    } catch (Exception ex) {
        log.debug("Exception", ex);
    }
}
#method_after
private ExtMap loginOnBehalf(DbUser dbUser) {
    Collection<ExtMap> principalRecords = AuthzUtils.findPrincipalsByIds(EngineExtensionsManager.getInstance().getExtensionByName(dbUser.getDomain()), dbUser.getNamespace(), Arrays.asList(dbUser.getExternalId()), true, true);
    if (principalRecords.isEmpty()) {
        throw new EngineException(EngineError.PRINCIPAL_NOT_FOUND, String.format(" user %s in domain '%s", dbUser.getLoginName(), dbUser.getDomain()));
    }
    return principalRecords.iterator().next();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    // Not needed for admin operations.
    return Collections.emptyList();
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_VDC_LOGIN : AuditLogType.USER_VDC_LOGIN_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("LoginOnBehalfLogInfo", logInfo);
    return getSucceeded() ? AuditLogType.USER_LOGIN_ON_BEHALF : AuditLogType.USER_LOGIN_ON_BEHALF_FAILED;
}
#end_block

#method_before
private List<Map<String, String>> availablePublicKeys(String keyFingerPrint, String keyType, String keyContent) {
    List<Map<String, String>> jsonUsers = new ArrayList<>();
    VdcQueryParametersBase userProfileParams = new VdcQueryParametersBase();
    VdcQueryReturnValue v = backend.runInternalQuery(VdcQueryType.GetAllUserProfiles, userProfileParams);
    if (v != null) {
        List<UserProfile> profiles = v.getReturnValue();
        for (UserProfile profile : profiles) {
            if (StringUtils.isNotEmpty(profile.getSshPublicKey())) {
                for (String publicKey : StringUtils.split(profile.getSshPublicKey(), "\n")) {
                    if (StringUtils.isNotEmpty(publicKey)) {
                        Map<String, String> jsonUser = new HashMap<String, String>();
                        jsonUser.put("entityid", profile.getUserId().toString());
                        jsonUser.put("entity", "user-id");
                        jsonUser.put("username", profile.getLoginName());
                        jsonUser.put("key", publicKey.trim());
                        jsonUsers.add(jsonUser);
                    }
                }
            }
        }
    }
    return jsonUsers;
}
#method_after
private List<Map<String, String>> availablePublicKeys(String keyFingerPrint, String keyType, String keyContent) {
    List<Map<String, String>> jsonUsers = new ArrayList<>();
    VdcQueryParametersBase userProfileParams = new VdcQueryParametersBase();
    VdcQueryReturnValue v = backend.runInternalQuery(VdcQueryType.GetAllUserProfiles, userProfileParams);
    if (v != null) {
        List<UserProfile> profiles = v.getReturnValue();
        for (UserProfile profile : profiles) {
            if (StringUtils.isNotEmpty(profile.getSshPublicKey())) {
                for (String publicKey : StringUtils.split(profile.getSshPublicKey(), "\n")) {
                    if (StringUtils.isNotEmpty(publicKey)) {
                        Map<String, String> jsonUser = new HashMap<String, String>();
                        jsonUser.put("entityid", profile.getUserId().toString());
                        jsonUser.put("entity", profile.getLoginName());
                        jsonUser.put("key", publicKey.trim());
                        jsonUsers.add(jsonUser);
                    }
                }
            }
        }
    }
    return jsonUsers;
}
#end_block

#method_before
private List<Map<String, String>> availableConsoles(String userIdAsString) {
    List<Map<String, String>> jsonVms = new ArrayList<>();
    Guid userGuid = null;
    try {
        if (StringUtils.isNotEmpty(userIdAsString)) {
            userGuid = Guid.createGuidFromString(userIdAsString);
        }
    } catch (IllegalArgumentException e) {
        log.debug("Could not read User GUID");
    }
    if (userGuid != null) {
        VdcReturnValueBase retValue1 = backend.runInternalAction(VdcActionType.LoginOnBehalf, new LoginOnBehalfParameters(userGuid));
        IdQueryParameters userParam = new IdQueryParameters(userGuid);
        VdcQueryReturnValue retVms = backend.runInternalQuery(VdcQueryType.GetAllVms, userParam);
        if (retVms != null) {
            List<VM> vmsList = retVms.getReturnValue();
            for (VM vm : vmsList) {
                Map<String, String> jsonVm = new HashMap<String, String>();
                if (vm.getRunOnVds() != null) {
                    // TODO: avoid one query per loop. Bulk query?
                    VdcQueryReturnValue retValue = backend.runInternalQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(vm.getRunOnVds()));
                    if (retValue != null && retValue.getReturnValue() != null) {
                        VDS vds = (VDS) retValue.getReturnValue();
                        jsonVm.put("vmid", vm.getId().toString());
                        jsonVm.put("vmname", vm.getName());
                        jsonVm.put("host", vds.getHostName());
                        /* there is only one serial console, no need and no way to distinguish them */
                        jsonVm.put("console", "default");
                        jsonVms.add(jsonVm);
                    }
                }
            }
        }
    }
    return jsonVms;
}
#method_after
private List<Map<String, String>> availableConsoles(String userIdAsString) {
    List<Map<String, String>> jsonVms = new ArrayList<>();
    Guid userGuid = null;
    try {
        if (StringUtils.isNotEmpty(userIdAsString)) {
            userGuid = Guid.createGuidFromString(userIdAsString);
        }
    } catch (IllegalArgumentException e) {
        log.debug("Could not read User GUID");
    }
    if (userGuid != null) {
        VdcReturnValueBase loginResult = backend.runInternalAction(VdcActionType.LoginOnBehalf, new LoginOnBehalfParameters(userGuid));
        if (!loginResult.getSucceeded()) {
            throw new RuntimeException("Unable to create session using LoginOnBehalf");
        }
        String engineSessionId = loginResult.getActionReturnValue();
        try {
            VdcQueryReturnValue retVms = backend.runInternalQuery(VdcQueryType.GetAllVmsForUserAndActionGroup, new GetEntitiesWithPermittedActionParameters(ActionGroup.CONNECT_TO_SERIAL_CONSOLE), new EngineContext().withSessionId(engineSessionId));
            if (retVms != null) {
                List<VM> vmsList = retVms.getReturnValue();
                for (VM vm : vmsList) {
                    Map<String, String> jsonVm = new HashMap<String, String>();
                    if (vm.getRunOnVds() != null) {
                        // TODO: avoid one query per loop. Bulk query?
                        VdcQueryReturnValue retValue = backend.runInternalQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(vm.getRunOnVds()));
                        if (retValue != null && retValue.getReturnValue() != null) {
                            VDS vds = (VDS) retValue.getReturnValue();
                            jsonVm.put("vmid", vm.getId().toString());
                            jsonVm.put("vmname", vm.getName());
                            jsonVm.put("host", vds.getHostName());
                            /* there is only one serial console, no need and no way to distinguish them */
                            jsonVm.put("console", "default");
                            jsonVms.add(jsonVm);
                        }
                    }
                }
            }
        } finally {
            backend.runInternalAction(VdcActionType.LogoutSession, new VdcActionParametersBase(engineSessionId));
        }
    }
    return jsonVms;
}
#end_block

#method_before
@Before
public void setup() {
    doReturn(dbFacade).when(validator).getDbFacade();
    doReturn(storageServerConnectionExtensionDao).when(dbFacade).getStorageServerConnectionExtensionDao();
    doReturn(vdsDao).when(dbFacade).getVdsDao();
    doReturn(new VDS()).when(vdsDao).get(any(Guid.class));
    conn = new StorageServerConnectionExtension();
    conn.setHostId(Guid.newGuid());
    conn.setIqn("iqn1");
    conn.setUserName("user1");
    conn.setPassword("password1");
}
#method_after
@Before
public void setup() {
    Guid hostId = Guid.newGuid();
    doReturn(dbFacade).when(validator).getDbFacade();
    doReturn(storageServerConnectionExtensionDao).when(dbFacade).getStorageServerConnectionExtensionDao();
    doReturn(vdsDao).when(dbFacade).getVdsDao();
    doReturn(new VDS()).when(vdsDao).get(hostId);
    conn = new StorageServerConnectionExtension();
    conn.setHostId(hostId);
    conn.setIqn("iqn1");
    conn.setUserName("user1");
    conn.setPassword("password1");
}
#end_block

#method_before
@Test
public void testIsConnectionDoesNotExistForHostAndTargetSucceeds() {
    when(storageServerConnectionExtensionDao.getByHostIdAndTarget(conn.getHostId(), conn.getIqn())).thenReturn(null);
    assertTrue(validator.isConnectionDoesNotExistForHostAndTarget(conn.getHostId(), conn.getIqn()).isValid());
}
#method_after
@Test
public void testIsConnectionDoesNotExistForHostAndTargetSucceeds() {
    when(storageServerConnectionExtensionDao.getByHostIdAndTarget(conn.getHostId(), conn.getIqn())).thenReturn(null);
    assertTrue(validator.isConnectionDoesNotExistForHostAndTarget(conn).isValid());
}
#end_block

#method_before
@Test
public void testIsConnectionDoesNotExistForHostAndTargetFails() {
    when(storageServerConnectionExtensionDao.getByHostIdAndTarget(conn.getHostId(), conn.getIqn())).thenReturn(new StorageServerConnectionExtension());
    assertNotNull(validator.isConnectionDoesNotExistForHostAndTarget(conn.getHostId(), conn.getIqn()).getMessage());
}
#method_after
@Test
public void testIsConnectionDoesNotExistForHostAndTargetFails() {
    when(storageServerConnectionExtensionDao.getByHostIdAndTarget(conn.getHostId(), conn.getIqn())).thenReturn(new StorageServerConnectionExtension());
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS, validator.isConnectionDoesNotExistForHostAndTarget(conn).getMessage());
}
#end_block

#method_before
public ValidationResult isConnectionDoesNotExistForHostAndTarget(Guid hostId, String iqn) {
    StorageServerConnectionExtension existingConnExt = getDbFacade().getStorageServerConnectionExtensionDao().getByHostIdAndTarget(hostId, iqn);
    if (existingConnExt != null) {
        VDS host = getDbFacade().getVdsDao().get(hostId);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS, String.format(String.format("$target %s", iqn)), String.format("$vdsName %s", host.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isConnectionDoesNotExistForHostAndTarget(StorageServerConnectionExtension connExt) {
    StorageServerConnectionExtension existingConnExt = getDbFacade().getStorageServerConnectionExtensionDao().getByHostIdAndTarget(connExt.getHostId(), connExt.getIqn());
    if (existingConnExt != null && !existingConnExt.getId().equals(connExt.getId())) {
        VDS host = getDbFacade().getVdsDao().get(connExt.getHostId());
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS, String.format(String.format("$target %s", connExt.getIqn())), String.format("$vdsName %s", host.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void testUpdateFailsOnExistingHostAndTargetCombination() {
    Guid hostId = Guid.newGuid();
    StorageServerConnectionExtension conn = createConnection(hostId, "iqn1", "user", "pass");
    StorageServerConnectionExtensionParameters params = new StorageServerConnectionExtensionParameters(conn);
    UpdateStorageServerConnectionExtensionCommand realCmd = new UpdateStorageServerConnectionExtensionCommand(params);
    UpdateStorageServerConnectionExtensionCommand cmd = spy(realCmd);
    when(cmd.getConnectionExtensionValidator()).thenReturn(storageServerConnectionExtensionValidator);
    when(storageServerConnectionExtensionValidator.isConnectionExtensionExists(conn.getId())).thenReturn(ValidationResult.VALID);
    when(storageServerConnectionExtensionValidator.isConnectionDoesNotExistForHostAndTarget(conn.getHostId(), conn.getIqn())).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS);
}
#method_after
@Test
public void testUpdateFailsOnExistingHostAndTargetCombination() {
    Guid hostId = Guid.newGuid();
    StorageServerConnectionExtension conn = createConnection(hostId, "iqn1", "user", "pass");
    StorageServerConnectionExtensionParameters params = new StorageServerConnectionExtensionParameters(conn);
    UpdateStorageServerConnectionExtensionCommand realCmd = new UpdateStorageServerConnectionExtensionCommand(params);
    UpdateStorageServerConnectionExtensionCommand cmd = spy(realCmd);
    when(cmd.getConnectionExtensionValidator()).thenReturn(storageServerConnectionExtensionValidator);
    when(storageServerConnectionExtensionValidator.isConnectionExtensionExists(conn.getId())).thenReturn(ValidationResult.VALID);
    when(storageServerConnectionExtensionValidator.isConnectionDoesNotExistForHostAndTarget(conn)).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnectionExtension conn = getParameters().getStorageServerConnectionExtension();
    return validate(StorageServerConnectionExtensionValidator.isConnectionExtensionExists(conn.getId())) && validate(StorageServerConnectionExtensionValidator.isConnectionDoesNotExistForHostAndTarget(conn.getHostId(), conn.getIqn()));
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnectionExtension conn = getParameters().getStorageServerConnectionExtension();
    return validate(getConnectionExtensionValidator().isConnectionExtensionExists(conn.getId())) && validate(getConnectionExtensionValidator().isConnectionDoesNotExistForHostAndTarget(conn));
}
#end_block

#method_before
public static ValidationResult isConnectionExtensionExists(Guid connExtId) {
    StorageServerConnectionExtension connExt = DbFacade.getInstance().getStorageServerConnectionExtensionDao().get(connExtId);
    if (connExt == null) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_DOES_NOT_EXIST, String.format("$%1$s %2$s", "connExtId", connExtId.toString()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isConnectionExtensionExists(Guid connExtId) {
    StorageServerConnectionExtension connExt = DbFacade.getInstance().getStorageServerConnectionExtensionDao().get(connExtId);
    if (connExt == null) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_DOES_NOT_EXIST, String.format("$%1$s %2$s", "connExtId", connExtId.toString()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public static ValidationResult isConnectionDoesNotExistForHostAndTarget(Guid hostId, String iqn) {
    StorageServerConnectionExtension existingConnExt = DbFacade.getInstance().getStorageServerConnectionExtensionDao().getByHostIdAndTarget(hostId, iqn);
    if (existingConnExt != null) {
        VDS host = DbFacade.getInstance().getVdsDao().get(hostId);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS, String.format(String.format("$target %s", iqn)), String.format("$vdsName %s", host.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isConnectionDoesNotExistForHostAndTarget(StorageServerConnectionExtension connExt) {
    StorageServerConnectionExtension existingConnExt = DbFacade.getInstance().getStorageServerConnectionExtensionDao().getByHostIdAndTarget(connExt.getHostId(), connExt.getIqn());
    if (existingConnExt != null && !existingConnExt.getId().equals(connExt.getId())) {
        VDS host = DbFacade.getInstance().getVdsDao().get(connExt.getHostId());
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_EXTENSION_ALREADY_EXISTS, String.format(String.format("$target %s", connExt.getIqn())), String.format("$vdsName %s", host.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnectionExtension newConnExt = getParameters().getStorageServerConnectionExtension();
    return validate(StorageServerConnectionExtensionValidator.isConnectionDoesNotExistForHostAndTarget(newConnExt.getHostId(), newConnExt.getIqn()));
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnectionExtension newConnExt = getParameters().getStorageServerConnectionExtension();
    return validate(getConnectionExtensionValidator().isConnectionDoesNotExistForHostAndTarget(newConnExt));
}
#end_block

#method_before
private ImageStatus checkImageStatus(CinderDisk removedVolume) {
    try {
        return getCinderBroker().getImageStatusByClassificationType(removedVolume);
    } catch (OpenStackResponseException ex) {
        if (ex.getStatus() == HttpStatus.SC_NOT_FOUND) {
            // Send image status as OK, since the disk might already be deleted.
            return ImageStatus.OK;
        }
        printError(removedVolume, ex);
    } catch (Exception e) {
        printError(removedVolume, e);
    }
    return ImageStatus.ILLEGAL;
}
#method_after
private ImageStatus checkImageStatus(CinderDisk removedVolume) {
    try {
        return getCinderBroker().getImageStatusByClassificationType(removedVolume);
    } catch (OpenStackResponseException ex) {
        if (ex.getStatus() == HttpStatus.SC_NOT_FOUND) {
            // Send image status as OK, since the disk might already be deleted.
            log.info("Image status could not be provided since the cinder image might have already been removed from Cinder.");
            return ImageStatus.OK;
        }
        logError(removedVolume, ex);
    } catch (Exception e) {
        logError(removedVolume, e);
    }
    return ImageStatus.ILLEGAL;
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<String>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<String>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#end_block

#method_before
private StorageFormatType updatePoolAndDomainsFormat(final Version spVersion) {
    final StoragePool storagePool = getStoragePool();
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDao().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            if (FeatureSupported.ovfStoreOnAnyDomain(spVersion)) {
                getVmStaticDao().incrementDbGenerationForAllInStoragePool(storagePool.getId());
            }
            return null;
        }
    });
    return targetFormat;
}
#method_after
private StorageFormatType updatePoolAndDomainsFormat(final Version spVersion) {
    final StoragePool storagePool = getStoragePool();
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setCompatibilityVersion(spVersion);
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDao().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            if (FeatureSupported.ovfStoreOnAnyDomain(spVersion)) {
                getVmStaticDao().incrementDbGenerationForAllInStoragePool(storagePool.getId());
            }
            return null;
        }
    });
    return targetFormat;
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getCompatibilityVersion();
    final Version oldSpVersion = getOldStoragePool().getCompatibilityVersion();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    StorageFormatType targetFormat = updatePoolAndDomainsFormat(spVersion);
    if (getOldStoragePool().getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (EngineException e) {
            if (e.getVdsError() != null && e.getErrorCode() == EngineError.PoolUpgradeInProgress) {
                updatePoolAndDomainsFormat(oldSpVersion);
            }
            log.warn("Upgrade process of Storage Pool '{}' has encountered a problem due to following reason: {}", spId, e.getMessage());
            auditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), new ArrayList<Guid>());
}
#method_after
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getCompatibilityVersion();
    final Version oldSpVersion = getOldStoragePool().getCompatibilityVersion();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    StorageFormatType targetFormat = updatePoolAndDomainsFormat(spVersion);
    if (getOldStoragePool().getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (EngineException e) {
            log.warn("Upgrade process of Storage Pool '{}' has encountered a problem due to following reason: {}", spId, e.getMessage());
            auditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
            // and return.
            if (e.getVdsError() != null && e.getErrorCode() == EngineError.PoolUpgradeInProgress) {
                updatePoolAndDomainsFormat(oldSpVersion);
                return;
            }
        }
    }
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), new ArrayList<Guid>());
}
#end_block

#method_before
private void updateMemberDomainsFormat(StorageFormatType targetFormat) {
    Guid spId = getStoragePool().getId();
    StorageDomainStaticDao sdStatDao = DbFacade.getInstance().getStorageDomainStaticDao();
    List<StorageDomainStatic> domains = sdStatDao.getAllForStoragePool(spId);
    for (StorageDomainStatic domain : domains) {
        StorageDomainType sdType = domain.getStorageDomainType();
        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
            log.info("Updating storage domain '{}' (type '{}') to format '{}'", domain.getId(), sdType, targetFormat);
            domain.setStorageFormat(targetFormat);
            sdStatDao.update(domain);
        }
    }
}
#method_after
private void updateMemberDomainsFormat(StorageFormatType targetFormat) {
    Guid spId = getStoragePool().getId();
    StorageDomainStaticDao sdStatDao = DbFacade.getInstance().getStorageDomainStaticDao();
    List<StorageDomainStatic> domains = sdStatDao.getAllForStoragePool(spId);
    for (StorageDomainStatic domain : domains) {
        StorageDomainType sdType = domain.getStorageDomainType();
        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
            log.info("Setting storage domain '{}' (type '{}') to format '{}'", domain.getId(), sdType, targetFormat);
            domain.setStorageFormat(targetFormat);
            sdStatDao.update(domain);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    boolean poolStatusDeterminedByHostsStatus = FeatureSupported.dataCenterWithoutSpm(storagePool.getCompatibilityVersion());
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatuses(_storagePoolId, StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown, "no reporting hosts");
                        // TODO: need to check if it's fine to skip the update when the status is already NonResponsive (as domains status maybe be not updated.
                        if (poolStatusDeterminedByHostsStatus && storagePool.getStatus() != StoragePoolStatus.NonResponsive) {
                            updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NON_RESPONSIVE_NO_REPORTING_HOSTS, EngineError.ENGINE);
                        }
                    } else if (poolStatusDeterminedByHostsStatus && storagePool.getStatus() != StoragePoolStatus.Up) {
                        updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.Up, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_UP_REPORTING_HOSTS, null);
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        if (!poolStatusDeterminedByHostsStatus) {
                            proceedStoragePoolStats(storagePool);
                        } else {
                            List<StorageDomain> storageDomains = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePool.getId());
                            domainsInMaintenanceCheck(storageDomains, storagePool);
                        }
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    boolean poolStatusDeterminedByHostsStatus = FeatureSupported.dataCenterWithoutSpm(storagePool.getCompatibilityVersion());
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, IrsBrokerCommand.reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown, "no reporting hosts");
                        // TODO: need to check if it's fine to skip the update when the status is already NonResponsive (as domains status maybe be not updated.
                        if (poolStatusDeterminedByHostsStatus && storagePool.getStatus() != StoragePoolStatus.NonResponsive) {
                            updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NON_RESPONSIVE_NO_REPORTING_HOSTS, EngineError.ENGINE);
                        }
                    } else if (poolStatusDeterminedByHostsStatus && storagePool.getStatus() != StoragePoolStatus.Up) {
                        updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.Up, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_UP_REPORTING_HOSTS, null);
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        if (!poolStatusDeterminedByHostsStatus) {
                            proceedStoragePoolStats(storagePool);
                        } else {
                            List<StorageDomain> storageDomains = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePool.getId());
                            domainsInMaintenanceCheck(storageDomains);
                        }
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#end_block

#method_before
private static Collection<Guid> getVdsConnectedToPool(Guid storagePoolId) {
    // every change to it should be inspected carefully.
    return Entities.getIds(DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatuses(storagePoolId, vdsConnectedToPoolStatuses));
}
#method_after
private static Set<Guid> getVdsConnectedToPool(Guid storagePoolId) {
    Set<Guid> vdsNotInMaintenance = new HashSet<>();
    // every change to it should be inspected carefully.
    for (VDS vds : DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(storagePoolId, null)) {
        if (vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.NonOperational) {
            vdsNotInMaintenance.add(vds.getId());
        }
    }
    return vdsNotInMaintenance;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = currentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb, storagePool);
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = currentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb);
}
#end_block

#method_before
private void domainsInMaintenanceCheck(List<StorageDomain> storageDomains, StoragePool pool) {
    for (StorageDomain domainInDb : storageDomains) {
        if (domainInDb.getStatus() == StorageDomainStatus.PreparingForMaintenance) {
            queueDomainMaintenanceCheck(domainInDb, pool);
        }
    }
}
#method_after
private void domainsInMaintenanceCheck(List<StorageDomain> storageDomains) {
    for (StorageDomain domainInDb : storageDomains) {
        if (domainInDb.getStatus() == StorageDomainStatus.PreparingForMaintenance) {
            queueDomainMaintenanceCheck(domainInDb);
        }
    }
}
#end_block

#method_before
public void queueDomainMaintenanceCheck(final StorageDomain domain, final StoragePool pool) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domain.getId(), null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            Collection<Guid> vdsConnectedToPool = getVdsConnectedToPool(_storagePoolId);
            Set<Guid> vdsDomInMaintenance = _domainsInMaintenance.get(domain.getId());
            if (vdsConnectedToPool.isEmpty() || (vdsDomInMaintenance != null && vdsDomInMaintenance.containsAll(vdsConnectedToPool))) {
                log.info("Moving domain '{}' to maintenance", domain.getId());
                DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(domain.getStoragePoolIsoMapData().getId(), StorageDomainStatus.Maintenance);
                AuditLogableBase auditLogableBase = new AuditLogableBase();
                auditLogableBase.addCustomValue("StorageDomainName", domain.getName());
                auditLogableBase.addCustomValue("StoragePoolName", pool.getName());
            }
            return null;
        }
    });
}
#method_after
public void queueDomainMaintenanceCheck(final StorageDomain domain) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domain.getId(), null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            Set<Guid> vdsConnectedToPool = getVdsConnectedToPool(_storagePoolId);
            Set<Guid> vdsDomInMaintenance = _domainsInMaintenance.get(domain.getId());
            if (vdsConnectedToPool.isEmpty() || (vdsDomInMaintenance != null && vdsDomInMaintenance.containsAll(vdsConnectedToPool))) {
                log.info("Moving domain '{}' to maintenance", domain.getId());
                DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(domain.getStoragePoolIsoMapData().getId(), StorageDomainStatus.Maintenance);
            }
            return null;
        }
    });
}
#end_block

#method_before
public void updateVdsDomainsData(VDS vds, final ArrayList<VDSDomainsData> data) {
    if (!shouldProcessVdsDomainReport(vds)) {
        return;
    }
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        Guid vdsId = vds.getId();
        String vdsName = vds.getName();
        try {
            Set<Guid> monitoredDomains = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                monitoredDomains.add(tempData.getDomainId());
            }
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = Collections.emptyMap();
            if (StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus.contains(vds.getStatus())) {
                domainsProblematicReportInfo = handleMonitoredDomainsForHost(vdsId, vdsName, data, monitoredDomains, storagePool);
            }
            Set<Guid> domainsInMaintenance = Collections.emptySet();
            if (StoragePoolDomainHelper.vdsDomainsMaintenanceMonitoringStatus.contains(vds.getStatus())) {
                domainsInMaintenance = handleDomainsInMaintenanceForHost(monitoredDomains);
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#method_after
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInMaintenance = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = new HashMap<>();
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> activeDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            Set<Guid> unknownDomainsInPool = new HashSet<>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Inactive));
            // build a list of all the domains in
            // pool (activeDomainsInPool and unknownDomainsInPool) that are not
            // visible by the host.
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : activeDomainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            for (Guid tempDomainId : unknownDomainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            // Unknown domains in pool
            for (VDSDomainsData tempData : data) {
                if (activeDomainsInPool.contains(tempData.getDomainId()) || unknownDomainsInPool.contains(tempData.getDomainId())) {
                    DomainMonitoringResult domainMonitoringResult = analyzeDomainReport(tempData, storagePool, false);
                    if (domainMonitoringResult.invalidAndActual()) {
                        domainsProblematicReportInfo.put(tempData.getDomainId(), domainMonitoringResult);
                    } else if (domainMonitoringResult.actual() && tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if ((inActiveDomainsInPool.contains(tempData.getDomainId()) || // in data centers with spm, unknown domains are moving to Active status according to the pool metadata.
                (FeatureSupported.dataCenterWithoutSpm(storagePool.getCompatibilityVersion()) && unknownDomainsInPool.contains(tempData.getDomainId()))) && analyzeDomainReport(tempData, storagePool, false).validAndActual()) {
                    log.warn("Storage Domain '{}' was reported by Host '{}' as Active in Pool '{}', moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                    // For block domains, synchronize LUN details comprising the storage domain with the DB
                    StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(tempData.getDomainId());
                    if (storageDomain.getStorageType().isBlockDomain()) {
                        ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(storageDomain.getId(), vdsId);
                    }
                }
            }
            Set<Guid> maintInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
            maintInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
            domainsInMaintenance = new HashSet<Guid>();
            for (Guid tempDomainId : maintInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInMaintenance.add(tempDomainId);
                }
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#end_block

#method_before
@Override
public int compare(AuditLog x, AuditLog y) {
    long xid = x.getAuditLogId();
    long yid = y.getAuditLogId();
    return Long.valueOf(xid).compareTo(yid);
}
#method_after
@Override
public int compare(AuditLog x, AuditLog y) {
    long xid = x.getAuditLogId();
    long yid = y.getAuditLogId();
    return Long.compare(xid, yid);
}
#end_block

#method_before
@Override
public int compare(DiskImage x, DiskImage y) {
    return x.getActualSize() < y.getActualSize() ? -1 : x.getActualSize() < y.getActualSize() ? 1 : 0;
}
#method_after
@Override
public int compare(DiskImage x, DiskImage y) {
    return Double.compare(x.getActualSize(), y.getActualSize());
}
#end_block

#method_before
private void markExpiredCommandsAsFailure() {
    long maxTime = DateTime.getNow().addMinutes((-1) * Config.<Integer>getValue(ConfigValues.CoCoCommandLifeInMinutes)).getTime();
    Iterator<Entry<Guid, CommandContainer>> iterator = cmdCallbackMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandContainer> entry = iterator.next();
        List<Guid> childCmdIds = coco.getChildCommandIds(entry.getKey());
        if (childCmdIds.isEmpty()) {
            markExpiredCommandAsFailure(entry.getKey(), maxTime);
        } else {
            for (Guid childId : childCmdIds) {
                markExpiredCommandAsFailure(childId, maxTime);
            }
        }
    }
}
#method_after
private void markExpiredCommandsAsFailure() {
    for (Entry<Guid, CommandContainer> entry : cmdCallbackMap.entrySet()) {
        List<Guid> childCmdIds = coco.getChildCommandIds(entry.getKey());
        if (childCmdIds.isEmpty()) {
            markExpiredCommandAsFailure(entry.getKey());
        } else {
            for (Guid childId : childCmdIds) {
                markExpiredCommandAsFailure(childId);
            }
        }
    }
}
#end_block

#method_before
private void markExpiredCommandAsFailure(Guid cmdId, long maxTime) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity != null && cmdEntity.getCommandStatus() == CommandStatus.ACTIVE && cmdEntity.getCreatedAt().getTime() < maxTime) {
        coco.updateCommandStatus(cmdId, CommandStatus.FAILED);
    }
}
#method_after
private void markExpiredCommandAsFailure(Guid cmdId) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity != null && cmdEntity.getCommandStatus() == CommandStatus.ACTIVE) {
        Calendar cal = Calendar.getInstance();
        Integer cmdLifeTimeInMin = cmdEntity.getCommandParameters().getLifeInMinutes();
        cal.add(Calendar.MINUTE, (-1) * (cmdLifeTimeInMin == null ? Config.<Integer>getValue(ConfigValues.CoCoLifeInMinutes) : cmdLifeTimeInMin));
        if (cmdEntity.getCreatedAt().getTime() < cal.getTime().getTime()) {
            log.warn("Marking expired command as Failed: command '{} ({})' that started at '{}' has been marked as Failed.", cmdEntity.getCommandType(), cmdEntity.getId(), cmdEntity.getCreatedAt());
            coco.updateCommandStatus(cmdId, CommandStatus.FAILED);
        }
    }
}
#end_block

#method_before
protected boolean validateSoundDevice() {
    if (!VmDeviceCommonUtils.checkSoundDeviceExists(getVm().getManagedVmDeviceMap().values())) {
        return true;
    }
    if (!osRepository.isSoundDeviceEnabled(getVm().getStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#method_after
protected boolean validateSoundDevice() {
    if (!VmDeviceCommonUtils.isSoundDeviceExists(getVm().getManagedVmDeviceMap().values())) {
        return true;
    }
    if (!osRepository.isSoundDeviceEnabled(getVm().getStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameters.getVmStaticData().getVmType() == VmType.Desktop);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        Map<Guid, Guid> diskImageMap = future.get().getActionReturnValue();
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks from template disks.", e);
    }
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContext().withoutExecutionContext().withoutLock(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        Map<Guid, Guid> diskImageMap = future.get().getActionReturnValue();
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks from template disks.", e);
    }
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(getVmTemplateId(), getParameters().getVmStaticData(), getVdsGroup(), getParameters().getGraphicsDevices());
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getVdsGroup());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getVdsGroup(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#end_block

#method_before
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    install(new CommonGinModule());
    bindEventBus();
    bindFrontendInfrastructure();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(PlaceManager.class, placeManager);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).to(ClientStorageImpl.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bind(AlertManager.class).in(Singleton.class);
    bindTypeAndImplAsSingleton(ClientLogProvider.class, LocalStorageLogHandler.class);
    requestStaticInjection(AssetProvider.class);
}
#method_after
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    install(new CommonGinModule());
    bindEventBus();
    bindFrontendInfrastructure();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(PlaceManager.class, placeManager);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).to(ClientStorageImpl.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bind(AlertManager.class).in(Singleton.class);
    bindTypeAndImplAsSingleton(ClientLogProvider.class, LocalStorageLogHandler.class);
    bind(BrowserHacks.class).asEagerSingleton();
    requestStaticInjection(AssetProvider.class);
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().setIsValid(getExternalComputeResource().getSelectedItem() != null);
        getExternalHostGroups().setIsValid(getExternalHostGroups().getSelectedItem() != null);
    } else {
        getExternalComputeResource().setIsValid(true);
        getExternalHostGroups().setIsValid(true);
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean fenceAgentsValid = true;
    if (getIsPm().getEntity()) {
        fenceAgentsValid = getFenceAgentListModel().validate();
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, fenceAgentsValid);
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().setIsValid(getExternalComputeResource().getSelectedItem() != null);
        getExternalHostGroups().setIsValid(getExternalHostGroups().getSelectedItem() != null);
    } else {
        getExternalComputeResource().setIsValid(true);
        getExternalHostGroups().setIsValid(true);
    }
    if (getExternalHostProviderEnabled().getEntity() && getProviders().getSelectedItem() == null) {
        getProviders().getInvalidityReasons().add(constants.validateSelectExternalProvider());
        getProviders().setIsValid(false);
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean fenceAgentsValid = true;
    if (getIsPm().getEntity()) {
        fenceAgentsValid = getFenceAgentListModel().validate();
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid() && getProviders().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, fenceAgentsValid);
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    vdsProtocol = vds.getProtocol();
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsChangeable(editTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = new ArrayList<>();
        // Keep a list of examined agents to prevent duplicate management IPs from showing up in the UI.
        Set<String> examinedAgents = new HashSet<>();
        for (FenceAgent agent : vds.getFenceAgents()) {
            FenceAgentModel model = new FenceAgentModel();
            model.setHost(this);
            // Set primary PM parameters.
            model.getManagementIp().setEntity(agent.getIp());
            model.getPmUserName().setEntity(agent.getUser());
            model.getPmPassword().setEntity(agent.getPassword());
            model.getPmType().setSelectedItem(agent.getType());
            if (agent.getPort() != null) {
                model.getPmPort().setEntity(agent.getPort());
            }
            model.getPmEncryptOptions().setEntity(agent.getEncryptOptions());
            model.setPmOptionsMap(VdsStatic.pmOptionsStringToMap(agent.getOptions()));
            model.setOrder(agent.getOrder());
            if (!examinedAgents.contains(model.getManagementIp().getEntity())) {
                boolean added = false;
                for (FenceAgentModel concurrentModel : agents) {
                    if (model.getOrder().getEntity() != null && model.getOrder().getEntity().equals(concurrentModel.getOrder().getEntity())) {
                        concurrentModel.getConcurrentList().add(model);
                        added = true;
                        break;
                    }
                }
                if (!added) {
                    agents.add(model);
                }
            }
            examinedAgents.add(model.getManagementIp().getEntity());
        }
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangeable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangeable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangeable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangeable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    vdsProtocol = vds.getProtocol();
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsChangeable(editTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = new ArrayList<>();
        // Keep a list of examined agents to prevent duplicate management IPs from showing up in the UI.
        Set<Pair<String, String>> examinedAgents = new HashSet<>();
        for (FenceAgent agent : vds.getFenceAgents()) {
            FenceAgentModel model = new FenceAgentModel();
            model.setHost(this);
            // Set primary PM parameters.
            model.getManagementIp().setEntity(agent.getIp());
            model.getPmUserName().setEntity(agent.getUser());
            model.getPmPassword().setEntity(agent.getPassword());
            model.getPmType().setSelectedItem(agent.getType());
            if (agent.getPort() != null) {
                model.getPmPort().setEntity(agent.getPort());
            }
            model.getPmEncryptOptions().setEntity(agent.getEncryptOptions());
            model.setPmOptionsMap(VdsStatic.pmOptionsStringToMap(agent.getOptions()));
            model.setOrder(agent.getOrder());
            if (!examinedAgents.contains(new Pair<String, String>(model.getManagementIp().getEntity(), model.getPmType().getSelectedItem()))) {
                boolean added = false;
                for (FenceAgentModel concurrentModel : agents) {
                    if (model.getOrder().getEntity() != null && model.getOrder().getEntity().equals(concurrentModel.getOrder().getEntity())) {
                        concurrentModel.getConcurrentList().add(model);
                        added = true;
                        break;
                    }
                }
                if (!added) {
                    agents.add(model);
                }
            }
            examinedAgents.add(new Pair<String, String>(model.getManagementIp().getEntity(), model.getPmType().getSelectedItem()));
        }
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangeable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangeable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangeable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangeable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanStorageModel = (SanStorageModel) model.getCurrentStorageItem();
    ArrayList<String> usedLunsMessages = sanStorageModel.getUsedLunsMessages();
    if (usedLunsMessages.isEmpty()) {
        onSaveSanStorage();
    } else {
        forceCreationWarning(usedLunsMessages);
    }
}
#method_after
public void saveNewSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Map<LunStatus, List<LUNs>> lunsMapByStatus = sanStorageModel.getLunsMapByStatus(sanStorageModel.getAddedLuns());
    if (!lunsMapByStatus.get(LunStatus.Unknown).isEmpty()) {
        Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
        Model target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
        List<String> unkownStatusLuns = new ArrayList<>();
        for (LUNs lun : lunsMapByStatus.get(LunStatus.Unknown)) {
            unkownStatusLuns.add(lun.getLUN_id());
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getSucceeded()) {
                    List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                    postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
                } else {
                    sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
                }
            }
        }, true));
    } else {
        postGetLunsMessages(sanStorageModel.getUsedLunsMessages(lunsMapByStatus.get(LunStatus.Used)));
    }
}
#end_block

#method_before
protected boolean connectStorageDomain(StorageDomain storageDomain) {
    try {
        return StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVdsId());
    } catch (RuntimeException e) {
        log.error("Exception while connecting storage domain", e);
        return false;
    }
}
#method_after
protected boolean connectStorageDomain(StorageDomain storageDomain) {
    try {
        return StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVdsId());
    } catch (RuntimeException e) {
        log.error("Exception while connecting a storage domain", e);
        return false;
    }
}
#end_block

#method_before
protected boolean disconnectStorageDomain(StorageDomain storageDomain) {
    try {
        return StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).disconnectStorageFromDomainByVdsId(storageDomain, getVdsId());
    } catch (RuntimeException e) {
        log.error("Exception while disconnect storage domain", e);
        return false;
    }
}
#method_after
protected boolean disconnectStorageDomain(StorageDomain storageDomain) {
    try {
        return StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).disconnectStorageFromDomainByVdsId(storageDomain, getVdsId());
    } catch (RuntimeException e) {
        log.error("Exception while disconnecting a storage domain", e);
        return false;
    }
}
#end_block

#method_before
protected void updateWipeAfterDeleteChangeability() {
    if (isVmAttachedToPool()) {
        getIsWipeAfterDelete().setIsChangeable(false);
    } else {
        getIsWipeAfterDelete().setIsChangeable(true);
    }
}
#method_after
protected void updateWipeAfterDeleteChangeability() {
    getIsWipeAfterDelete().setIsChangeable(!isVmAttachedToPool());
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    if (!(value instanceof IconWithOsDefault)) {
        throw new IllegalArgumentException(// $NON-NLS-1$
        "Illegal argument type: " + // $NON-NLS-1$
        (value == null ? "null" : value.getClass().toString()));
    }
    final IconWithOsDefault iconWithOsDefault = (IconWithOsDefault) value;
    return iconWithOsDefault.getValidationResult();
}
#method_after
@Override
public ValidationResult validate(Object value) {
    if (!(value instanceof IconWithOsDefault)) {
        throw new IllegalArgumentException(// $NON-NLS-1$
        "Illegal argument type: " + // $NON-NLS-1$
        (value == null ? "null" : value.getClass().toString()));
    }
    final IconWithOsDefault iconWithOsDefault = (IconWithOsDefault) value;
    if (iconWithOsDefault.getValidationResult() == null) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        return ValidationResult.fail(constants.iconNotValidatedYet());
    }
    return iconWithOsDefault.getValidationResult();
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(getVmTemplateId(), getParameters().getVmStaticData(), getVdsGroup(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getVdsGroup());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getVdsGroup(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#end_block

#method_before
protected void autoSelectGraphicsDevice() {
    if (getParameters().getGraphicsDevices().size() == 0) {
        DisplayType defaultDisplayType = getParameters().getVmStaticData().getDefaultDisplayType();
        int osId = getParameters().getVmStaticData().getOsId();
        Version clusterVersion = getVdsGroup().getCompatibilityVersion();
        List<GraphicsType> templateGraphics = VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId());
        // otherwise choose the first supported graphics device
        if (!VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, templateGraphics, defaultDisplayType)) {
            GraphicsType defaultGraphicsType = null;
            List<Pair<GraphicsType, DisplayType>> pairs = osRepository.getGraphicsAndDisplays().get(osId).get(clusterVersion);
            for (Pair<GraphicsType, DisplayType> pair : pairs) {
                if (pair.getSecond().equals(defaultDisplayType)) {
                    defaultGraphicsType = pair.getFirst();
                    break;
                }
            }
            if (defaultGraphicsType != null) {
                VmDeviceType vmDisplayType = defaultDisplayType.getDefaultVmDeviceType();
                GraphicsDevice defaultGraphicsDevice = new GraphicsDevice(vmDisplayType);
                getParameters().getGraphicsDevices().put(defaultGraphicsType, defaultGraphicsDevice);
            }
        }
    }
}
#method_after
protected void autoSelectGraphicsDevice() {
    if (// if not set by user in params
    getParameters().getGraphicsDevices().isEmpty() && getVdsGroup() != null) {
        // and VdsGroup is known
        DisplayType defaultDisplayType = getParameters().getVmStaticData().getDefaultDisplayType();
        int osId = getParameters().getVmStaticData().getOsId();
        Version clusterVersion = getVdsGroup().getCompatibilityVersion();
        List<GraphicsType> templateGraphics = VmDeviceUtils.getGraphicsTypesOfEntity(vmDevicesSourceId);
        // otherwise choose the first supported graphics device
        if (!VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, templateGraphics, defaultDisplayType)) {
            GraphicsType defaultGraphicsType = null;
            List<Pair<GraphicsType, DisplayType>> pairs = osRepository.getGraphicsAndDisplays(osId, clusterVersion);
            for (Pair<GraphicsType, DisplayType> pair : pairs) {
                if (pair.getSecond().equals(defaultDisplayType)) {
                    defaultGraphicsType = pair.getFirst();
                    break;
                }
            }
            if (defaultGraphicsType != null) {
                for (GraphicsType graphicsType : GraphicsType.values()) {
                    // reset graphics devices
                    getParameters().getGraphicsDevices().put(graphicsType, null);
                }
                VmDeviceType vmDisplayType = defaultGraphicsType.getCorrespondingDeviceType();
                GraphicsDevice defaultGraphicsDevice = new GraphicsDevice(vmDisplayType);
                getParameters().getGraphicsDevices().put(defaultGraphicsType, defaultGraphicsDevice);
            }
        }
    }
}
#end_block

#method_before
private static int getMaxNumberOfMonitors() {
    int max = 0;
    String numOfMonitorsStr = Config.getValue(ConfigValues.ValidNumOfMonitors).toString().replaceAll("[\\[\\]]", "");
    String[] values = numOfMonitorsStr.split(",");
    for (String val : values) {
        val = val.trim();
        if (Integer.valueOf(val) > max) {
            max = Integer.valueOf(val);
        }
    }
    return max;
}
#method_after
private static int getMaxNumberOfMonitors() {
    int max = 0;
    String numOfMonitorsStr = Config.getValue(ConfigValues.ValidNumOfMonitors).toString().replaceAll("[\\[\\]]", "");
    String[] values = numOfMonitorsStr.split(",");
    for (String text : values) {
        text = text.trim();
        int val = Integer.parseInt(text);
        if (val > max) {
            max = val;
        }
    }
    return max;
}
#end_block

#method_before
@Override
public Capabilities list() {
    Capabilities caps = new Capabilities();
    for (Version v : getSupportedClusterLevels()) {
        caps.getVersions().add(generateVersionCaps(v));
    }
    caps.setPermits(getPermits());
    caps.setSchedulingPolicies(getSchedulingPolicies());
    return caps;
}
#method_after
@Override
public Capabilities list() {
    Capabilities caps = new Capabilities();
    for (Version v : getSupportedClusterLevels()) {
        caps.getVersions().add(generateVersionCaps(v));
    }
    caps.setSchedulingPolicies(getSchedulingPolicies());
    return caps;
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagementAgents(version, getPowerManagementAgents(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addGraphicsTypes(version, GraphicsType.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    addConsoleDisconnectActions(version, ConsoleDisconnectAction.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    addQuotaModeTypes(version);
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new Cpus());
        for (ServerCpu sc : getServerCpuList(v)) {
            Cpu cpu = new Cpu();
            cpu.setType(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCpus().add(cpu);
        }
        addPowerManagementAgents(version, getPowerManagementAgents(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addGraphicsTypes(version, GraphicsType.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addVmPoolTypes(version, VmPoolType.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    addConsoleDisconnectActions(version, ConsoleDisconnectAction.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    addQuotaModeTypes(version);
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
private void addHostNICStates(VersionCaps version, NicStatus[] values) {
    version.setHostNicStates(new HostNICStates());
    for (NicStatus status : values) {
        version.getHostNicStates().getHostNICStates().add(status.value());
    }
}
#method_after
private void addHostNICStates(VersionCaps version, NicStatus[] values) {
    version.setHostNicStates(new HostNicStates());
    for (NicStatus status : values) {
        version.getHostNicStates().getHostNicStates().add(status.value());
    }
}
#end_block

#method_before
private void verifyVersion(VersionCaps version, int major, int minor, boolean current, String cpuName, int cpuLevel, boolean localStorage, boolean hooks, boolean thp) {
    assertEquals(major, version.getMajor().intValue());
    assertEquals(minor, version.getMinor().intValue());
    assertEquals(current, version.isCurrent());
    assertNotNull(version.getCpus());
    assertTrue(version.getCpus().getCPUs().size() == 1);
    verifyCPU(version.getCpus().getCPUs().get(0), cpuName, cpuLevel);
    assertNotNull(version.getPowerManagement());
    assertEquals(1, version.getPowerManagement().getAgents().size());
    verifyPowerManagement(version.getPowerManagement().getAgents().get(0));
    verifyVmTypes(version.getVmTypes().getVmTypes());
    verifyStorageTypes(version.getStorageTypes().getStorageTypes(), localStorage);
    verifyStorageDomainTypes(version.getStorageDomainTypes().getStorageDomainTypes());
    verifyFenceTypes(version.getFenceTypes().getFenceTypes());
    verifyBootDevices(version.getBootDevices().getBootDevices());
    verifyDisplayTypes(version.getDisplayTypes().getDisplayTypes());
    verifyNicTypes(version.getNicInterfaces().getNicInterfaces());
    verifyDiskFormats(version.getDiskFormats().getDiskFormats());
    verifyDiskInterfaces(version.getDiskInterfaces().getDiskInterfaces());
    verifyVmAffinities(version, version.getVmAffinities());
    verifyMigrateOnErrorOptions(version, version.getErrorHandling());
    verifyOsTypes(version.getOsTypes().getOsTypes());
    if (hooks) {
        verifyHooksEnvs(version.getCustomProperties().getCustomProperty());
    }
    if (thp) {
        assertNotNull(version.getFeatures());
        assertFalse(version.getFeatures().getFeature().isEmpty());
        assertNotNull(version.getFeatures().getFeature().get(0).getTransparentHugepages());
    }
}
#method_after
private void verifyVersion(VersionCaps version, int major, int minor, boolean current, String cpuName, int cpuLevel, boolean localStorage, boolean hooks, boolean thp) {
    assertEquals(major, version.getMajor().intValue());
    assertEquals(minor, version.getMinor().intValue());
    assertEquals(current, version.isCurrent());
    assertNotNull(version.getCpus());
    assertTrue(version.getCpus().getCpus().size() == 1);
    verifyCPU(version.getCpus().getCpus().get(0), cpuName, cpuLevel);
    assertNotNull(version.getPowerManagement());
    assertEquals(1, version.getPowerManagement().getAgents().size());
    verifyPowerManagement(version.getPowerManagement().getAgents().get(0));
    assertTrue(version.getCpus().getCpus().size() == 1);
    verifyCPU(version.getCpus().getCpus().get(0), cpuName, cpuLevel);
    assertNotNull(version.getPowerManagement());
    verifyVmTypes(version.getVmTypes().getVmTypes());
    verifyStorageTypes(version.getStorageTypes().getStorageTypes(), localStorage);
    verifyStorageDomainTypes(version.getStorageDomainTypes().getStorageDomainTypes());
    verifyFenceTypes(version.getFenceTypes().getFenceTypes());
    verifyBootDevices(version.getBootDevices().getBootDevices());
    verifyDisplayTypes(version.getDisplayTypes().getDisplayTypes());
    verifyNicTypes(version.getNicInterfaces().getNicInterfaces());
    verifyDiskFormats(version.getDiskFormats().getDiskFormats());
    verifyDiskInterfaces(version.getDiskInterfaces().getDiskInterfaces());
    verifyVmAffinities(version, version.getVmAffinities());
    verifyMigrateOnErrorOptions(version, version.getErrorHandling());
    verifyOsTypes(version.getOsTypes().getOsTypes());
    if (hooks) {
        verifyHooksEnvs(version.getCustomProperties().getCustomProperty());
    }
    if (thp) {
        assertNotNull(version.getFeatures());
        assertFalse(version.getFeatures().getFeature().isEmpty());
        assertNotNull(version.getFeatures().getFeature().get(0).getTransparentHugepages());
    }
}
#end_block

#method_before
private void verifyCPU(CPU cpu, String name, Integer level) {
    assertNotNull(cpu);
    assertEquals(name, cpu.getId());
    assertEquals(level, cpu.getLevel());
}
#method_after
private void verifyCPU(Cpu cpu, String name, Integer level) {
    assertNotNull(cpu);
    assertEquals(name, cpu.getType());
    assertEquals(level, cpu.getLevel());
}
#end_block

#method_before
@Test
public void testUpdateSshHost() {
    SSH sshConf = new SSH();
    sshConf.setPort(22);
    sshConf.setUser(new User());
    sshConf.getUser().setUserName("root");
    sshConf.setFingerprint("1234");
    VdsStatic vdsStatic = new VdsStatic();
    vdsStatic.setSshUsername("root");
    vdsStatic.setSshPort(22);
    vdsStatic.setSshKeyFingerprint("1234");
    VdsStatic mappedVdsStatic = HostMapper.map(sshConf, vdsStatic);
    assertEquals(mappedVdsStatic.getSshPort(), 22);
    assertEquals(mappedVdsStatic.getSshKeyFingerprint(), "1234");
    assertEquals(mappedVdsStatic.getSshUsername(), "root");
}
#method_after
@Test
public void testUpdateSshHost() {
    Ssh sshConf = new Ssh();
    sshConf.setPort(22);
    sshConf.setUser(new User());
    sshConf.getUser().setUserName("root");
    sshConf.setFingerprint("1234");
    VdsStatic vdsStatic = new VdsStatic();
    vdsStatic.setSshUsername("root");
    vdsStatic.setSshPort(22);
    vdsStatic.setSshKeyFingerprint("1234");
    VdsStatic mappedVdsStatic = HostMapper.map(sshConf, vdsStatic);
    assertEquals(mappedVdsStatic.getSshPort(), 22);
    assertEquals(mappedVdsStatic.getSshKeyFingerprint(), "1234");
    assertEquals(mappedVdsStatic.getSshUsername(), "root");
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        map(model.getProtocol(), entity);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetExternalHostProvider()) {
        String providerId = model.getExternalHostProvider().getId();
        entity.setHostProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        map(model.getProtocol(), entity);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetExternalHostProvider()) {
        String providerId = model.getExternalHostProvider().getId();
        entity.setHostProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VdsSpmStatus.class, to = SpmState.class)
public static SpmState map(VdsSpmStatus entityStatus, SpmState template) {
    switch(entityStatus) {
        case None:
            return SpmState.NONE;
        case Contending:
            return SpmState.CONTENDING;
        case SPM:
            return SpmState.SPM;
        default:
            return null;
    }
}
#method_after
@Mapping(from = Ssh.class, to = VdsStatic.class)
public static VdsStatic map(Ssh model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetUser() && model.getUser().isSetUserName()) {
        entity.setSshUsername(model.getUser().getUserName());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setSshPort(model.getPort());
    }
    if (model.isSetFingerprint()) {
        entity.setSshKeyFingerprint(model.getFingerprint());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (Ssh) null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    return model;
}
#end_block

#method_before
private void verifyCapabilities(Capabilities capabilities) {
    assertNotNull(capabilities);
    assertEquals(2, capabilities.getVersions().size());
    verifyVersion(capabilities.getVersions().get(0), 1, 5, false, "bar", 0, false, false, false);
    verifyVersion(capabilities.getVersions().get(1), 10, 3, true, "foo", 15, true, true, true);
    verifyPermits(capabilities);
    verifySchedulingPolicies(capabilities);
}
#method_after
private void verifyCapabilities(Capabilities capabilities) {
    assertNotNull(capabilities);
    assertEquals(2, capabilities.getVersions().size());
    verifyVersion(capabilities.getVersions().get(0), 1, 5, false, "bar", 0, false, false, false);
    verifyVersion(capabilities.getVersions().get(1), 10, 3, true, "foo", 15, true, true, true);
    verifySchedulingPolicies(capabilities);
}
#end_block

#method_before
private void verifyVersion(VersionCaps version, int major, int minor, boolean current, String cpuName, int cpuLevel, boolean localStorage, boolean hooks, boolean thp) {
    assertEquals(major, version.getMajor().intValue());
    assertEquals(minor, version.getMinor().intValue());
    assertEquals(current, version.isCurrent());
    assertNotNull(version.getCpus());
    assertTrue(version.getCpus().getCPUs().size() == 1);
    verifyCPU(version.getCpus().getCPUs().get(0), cpuName, cpuLevel);
    assertNotNull(version.getPowerManagement());
    assertEquals(1, version.getPowerManagement().getAgents().size());
    verifyPowerManagement(version.getPowerManagement().getAgents().get(0));
    verifyVmTypes(version.getVmTypes().getVmTypes());
    verifyStorageTypes(version.getStorageTypes().getStorageTypes(), localStorage);
    verifyStorageDomainTypes(version.getStorageDomainTypes().getStorageDomainTypes());
    verifyFenceTypes(version.getFenceTypes().getFenceTypes());
    verifyBootDevices(version.getBootDevices().getBootDevices());
    verifyDisplayTypes(version.getDisplayTypes().getDisplayTypes());
    verifyNicTypes(version.getNicInterfaces().getNicInterfaces());
    verifyDiskFormats(version.getDiskFormats().getDiskFormats());
    verifyDiskInterfaces(version.getDiskInterfaces().getDiskInterfaces());
    verifyVmAffinities(version, version.getVmAffinities());
    verifyMigrateOnErrorOptions(version, version.getErrorHandling());
    verifyOsTypes(version.getOsTypes().getOsTypes());
    if (hooks) {
        verifyHooksEnvs(version.getCustomProperties().getCustomProperty());
    }
    if (thp) {
        assertNotNull(version.getFeatures());
        assertFalse(version.getFeatures().getFeature().isEmpty());
        assertNotNull(version.getFeatures().getFeature().get(0).getTransparentHugepages());
    }
}
#method_after
private void verifyVersion(VersionCaps version, int major, int minor, boolean current, String cpuName, int cpuLevel, boolean localStorage, boolean hooks, boolean thp) {
    assertEquals(major, version.getMajor().intValue());
    assertEquals(minor, version.getMinor().intValue());
    assertEquals(current, version.isCurrent());
    assertNotNull(version.getCpus());
    assertTrue(version.getCpus().getCpus().size() == 1);
    verifyCPU(version.getCpus().getCpus().get(0), cpuName, cpuLevel);
    assertNotNull(version.getPowerManagement());
    assertEquals(1, version.getPowerManagement().getAgents().size());
    verifyPowerManagement(version.getPowerManagement().getAgents().get(0));
    verifyVmTypes(version.getVmTypes().getVmTypes());
    verifyStorageTypes(version.getStorageTypes().getStorageTypes(), localStorage);
    verifyStorageDomainTypes(version.getStorageDomainTypes().getStorageDomainTypes());
    verifyFenceTypes(version.getFenceTypes().getFenceTypes());
    verifyBootDevices(version.getBootDevices().getBootDevices());
    verifyDisplayTypes(version.getDisplayTypes().getDisplayTypes());
    verifyNicTypes(version.getNicInterfaces().getNicInterfaces());
    verifyDiskFormats(version.getDiskFormats().getDiskFormats());
    verifyDiskInterfaces(version.getDiskInterfaces().getDiskInterfaces());
    verifyVmAffinities(version, version.getVmAffinities());
    verifyMigrateOnErrorOptions(version, version.getErrorHandling());
    verifyOsTypes(version.getOsTypes().getOsTypes());
    if (hooks) {
        verifyHooksEnvs(version.getCustomProperties().getCustomProperty());
    }
    if (thp) {
        assertNotNull(version.getFeatures());
        assertFalse(version.getFeatures().getFeature().isEmpty());
        assertNotNull(version.getFeatures().getFeature().get(0).getTransparentHugepages());
    }
}
#end_block

#method_before
private void verifyCPU(CPU cpu, String name, Integer level) {
    assertNotNull(cpu);
    assertEquals(name, cpu.getId());
    assertEquals(level, cpu.getLevel());
}
#method_after
private void verifyCPU(Cpu cpu, String name, Integer level) {
    assertNotNull(cpu);
    assertEquals(name, cpu.getType());
    assertEquals(level, cpu.getLevel());
}
#end_block

#method_before
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    mapCommonModelToEntity(entity, model);
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
        if (model.getDisplay().isSetDisconnectAction()) {
            DisplayDisconnectAction action = DisplayDisconnectAction.fromValue(model.getDisplay().getDisconnectAction());
            entity.setConsoleDisconnectAction(map(action, null));
        }
    }
    if (model.isSetTimeZone()) {
        if (model.getTimeZone().isSetName()) {
            String timezone = model.getTimeZone().getName();
            if (timezone.isEmpty()) {
                // normalize default timezone representation
                timezone = null;
            }
            entity.setTimeZone(timezone);
        }
    } else // now only accepted for backwards compatibility
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperty()));
    }
    if (model.isSetLargeIcon() && model.getLargeIcon().isSetId()) {
        entity.setLargeIconId(GuidUtils.asGuid(model.getLargeIcon().getId()));
    }
    if (model.isSetSmallIcon() && model.getSmallIcon().isSetId()) {
        entity.setSmallIconId(GuidUtils.asGuid(model.getSmallIcon().getId()));
    }
}
#method_after
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    mapCommonModelToEntity(entity, model);
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
        if (model.getDisplay().isSetDisconnectAction()) {
            DisplayDisconnectAction action = DisplayDisconnectAction.fromValue(model.getDisplay().getDisconnectAction());
            entity.setConsoleDisconnectAction(map(action, null));
        }
    }
    if (model.isSetTimeZone()) {
        if (model.getTimeZone().isSetName()) {
            String timezone = model.getTimeZone().getName();
            if (timezone.isEmpty()) {
                // normalize default timezone representation
                timezone = null;
            }
            entity.setTimeZone(timezone);
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperty()));
    }
    if (model.isSetLargeIcon() && model.getLargeIcon().isSetId()) {
        entity.setLargeIconId(GuidUtils.asGuid(model.getLargeIcon().getId()));
    }
    if (model.isSetSmallIcon() && model.getSmallIcon().isSetId()) {
        entity.setSmallIconId(GuidUtils.asGuid(model.getSmallIcon().getId()));
    }
}
#end_block

#method_before
protected static void mapCommonEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    IO io = model.getIo();
    if (io == null) {
        io = new IO();
        model.setIo(io);
    }
    io.setThreads(entity.getNumOfIoThreads());
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getCustomEmulatedMachine() != null) {
        model.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    }
    if (entity.getCustomCpuName() != null) {
        model.setCustomCpuModel(entity.getCustomCpuName());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
}
#method_after
protected static void mapCommonEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    Io io = model.getIo();
    if (io == null) {
        io = new Io();
        model.setIo(io);
    }
    io.setThreads(entity.getNumOfIoThreads());
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new Cpu());
    model.getCpu().setTopology(topology);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getCustomEmulatedMachine() != null) {
        model.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    }
    if (entity.getCustomCpuName() != null) {
        model.setCustomCpuModel(entity.getCustomCpuName());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
}
#end_block

#method_before
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    mapCommonEntityToModel(model, entity);
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getTimeZone() != null) {
        model.setTimeZone(new TimeZone());
        model.getTimeZone().setName(entity.getTimeZone());
    }
    // Deprecated: Should be removed in 4.x, use the TimeZone complex type instead
    model.setTimezone(entity.getTimeZone());
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    model.setCpuShares(entity.getCpuShares());
    if (entity.getLargeIconId() != null) {
        if (!model.isSetLargeIcon()) {
            model.setLargeIcon(new Icon());
        }
        model.getLargeIcon().setId(entity.getLargeIconId().toString());
    }
    if (entity.getSmallIconId() != null) {
        if (!model.isSetSmallIcon()) {
            model.setSmallIcon(new Icon());
        }
        model.getSmallIcon().setId(entity.getSmallIconId().toString());
    }
}
#method_after
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    mapCommonEntityToModel(model, entity);
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getTimeZone() != null) {
        model.setTimeZone(new TimeZone());
        model.getTimeZone().setName(entity.getTimeZone());
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    model.setCpuShares(entity.getCpuShares());
    if (entity.getLargeIconId() != null) {
        if (!model.isSetLargeIcon()) {
            model.setLargeIcon(new Icon());
        }
        model.getLargeIcon().setId(entity.getLargeIconId().toString());
    }
    if (entity.getSmallIconId() != null) {
        if (!model.isSetSmallIcon()) {
            model.setSmallIcon(new Icon());
        }
        model.getSmallIcon().setId(entity.getSmallIconId().toString());
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.NumaTuneMode.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.NumaTuneMode mode, String incoming) {
    if (mode == null) {
        return null;
    }
    switch(mode) {
        case STRICT:
            return NumaTuneMode.STRICT.value();
        case INTERLEAVE:
            return NumaTuneMode.INTERLEAVE.value();
        case PREFERRED:
            return NumaTuneMode.PREFERRED.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = Vm.class, to = VmStatic.class)
public static VmStatic map(Vm vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy()) {
        if (vm.getPlacementPolicy().isSetAffinity()) {
            // read migration policy
            VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
            if (vmAffinity != null) {
                staticVm.setMigrationSupport(map(vmAffinity, null));
            }
        }
        // reset previous dedicated host or hosts
        Set<Guid> hostGuidsSet = new HashSet<>();
        // read multiple hosts if there are few
        if (vm.getPlacementPolicy().isSetHosts() && vm.getPlacementPolicy().getHosts().getHosts().size() > 0) {
            for (Host currHost : vm.getPlacementPolicy().getHosts().getHosts()) {
                Guid hostGuid;
                if (currHost.isSetId()) {
                    hostGuid = Guid.createGuidFromString(currHost.getId());
                } else {
                    continue;
                }
                hostGuidsSet.add(hostGuid);
            }
        }
        staticVm.setDedicatedVmForVdsList(new LinkedList<Guid>(hostGuidsSet));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(InitializationMapper.map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    if (vm.isSetExternalHostProvider()) {
        String providerId = vm.getExternalHostProvider().getId();
        staticVm.setProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            String userName = user.getUserName();
            if (StringUtils.equals(userName, "root")) {
                entity.setUserName(userName);
                String userPassword = user.getPassword();
                if (userPassword != null) {
                    entity.setRootPassword(userPassword);
                }
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (Nic iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            String userName = user.getUserName();
            if (StringUtils.equals(userName, "root")) {
                entity.setUserName(userName);
                String userPassword = user.getPassword();
                if (userPassword != null) {
                    entity.setRootPassword(userPassword);
                }
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVCpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#method_after
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VcpuPin pin : tune.getVcpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#end_block

#method_before
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null || cpuPinning.equals("")) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVCpuPin().add(pin);
    }
    return cpuTune;
}
#method_after
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null || cpuPinning.equals("")) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VcpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVcpuPin().add(pin);
    }
    return cpuTune;
}
#end_block

#method_before
static VCpuPin stringToVCpupin(final String strCpu) {
    final String[] strPin = strCpu.split("#");
    if (strPin.length != 2) {
        throw new IllegalArgumentException("Bad format: " + strCpu);
    }
    final VCpuPin pin = new VCpuPin();
    try {
        pin.setVcpu(Integer.parseInt(strPin[0]));
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Bad format: " + strCpu, e);
    }
    if (strPin[1].matches("\\^?(\\d+(\\-\\d+)?)(,\\^?((\\d+(\\-\\d+)?)))*")) {
        pin.setCpuSet(strPin[1]);
    } else {
        throw new IllegalArgumentException("Bad format: " + strPin[1]);
    }
    return pin;
}
#method_after
static VcpuPin stringToVCpupin(final String strCpu) {
    final String[] strPin = strCpu.split("#");
    if (strPin.length != 2) {
        throw new IllegalArgumentException("Bad format: " + strCpu);
    }
    final VcpuPin pin = new VcpuPin();
    try {
        pin.setVcpu(Integer.parseInt(strPin[0]));
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Bad format: " + strCpu, e);
    }
    if (strPin[1].matches("\\^?(\\d+(\\-\\d+)?)(,\\^?((\\d+(\\-\\d+)?)))*")) {
        pin.setCpuSet(strPin[1]);
    } else {
        throw new IllegalArgumentException("Bad format: " + strPin[1]);
    }
    return pin;
}
#end_block

#method_before
public static UsbPolicy getUsbPolicyOnCreate(Usb usb, Version vdsGroupVersion) {
    if (usb == null || !usb.isSetEnabled() || !usb.isEnabled()) {
        return UsbPolicy.DISABLED;
    } else {
        UsbType usbType = getUsbType(usb);
        if (usbType == null) {
            return getUsbPolicyAccordingToClusterVersion(vdsGroupVersion);
        } else {
            return getUsbPolicyAccordingToUsbType(usbType);
        }
    }
}
#method_after
public static UsbPolicy getUsbPolicyOnCreate(Usb usb) {
    if (usb == null || !usb.isSetEnabled() || !usb.isEnabled()) {
        return UsbPolicy.DISABLED;
    } else {
        UsbType usbType = getUsbType(usb);
        if (usbType == null) {
            return null;
        } else {
            return getUsbPolicyAccordingToUsbType(usbType);
        }
    }
}
#end_block

#method_before
public static UsbPolicy getUsbPolicyOnUpdate(Usb usb, UsbPolicy currentPolicy, Version vdsGroupVersion) {
    if (usb == null)
        return currentPolicy;
    if (usb.isSetEnabled()) {
        if (!usb.isEnabled())
            return UsbPolicy.DISABLED;
        else {
            UsbType usbType = getUsbType(usb);
            if (usbType != null) {
                return getUsbPolicyAccordingToUsbType(usbType);
            } else {
                return currentPolicy == UsbPolicy.DISABLED ? getUsbPolicyAccordingToClusterVersion(vdsGroupVersion) : currentPolicy;
            }
        }
    } else {
        if (currentPolicy == UsbPolicy.DISABLED)
            return UsbPolicy.DISABLED;
        UsbType usbType = getUsbType(usb);
        if (usbType != null) {
            return getUsbPolicyAccordingToUsbType(UsbType.fromValue(usb.getType()));
        } else {
            return currentPolicy;
        }
    }
}
#method_after
public static UsbPolicy getUsbPolicyOnUpdate(Usb usb, UsbPolicy currentPolicy) {
    if (usb == null)
        return currentPolicy;
    if (usb.isSetEnabled()) {
        if (!usb.isEnabled())
            return UsbPolicy.DISABLED;
        else {
            UsbType usbType = getUsbType(usb);
            if (usbType != null) {
                return getUsbPolicyAccordingToUsbType(usbType);
            } else {
                return null;
            }
        }
    } else {
        if (currentPolicy == UsbPolicy.DISABLED)
            return UsbPolicy.DISABLED;
        UsbType usbType = getUsbType(usb);
        if (usbType != null) {
            return getUsbPolicyAccordingToUsbType(UsbType.fromValue(usb.getType()));
        } else {
            return currentPolicy;
        }
    }
}
#end_block

#method_before
private static Sessions mapConsoleSession(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    // currently in format user@domain, so needs to be
    String consoleUserName = vm.getConsoleCurentUserName();
    // parsed.
    if (consoleUserName != null && !consoleUserName.isEmpty()) {
        String userName = parseUserName(consoleUserName);
        String domainName = parseDomainName(consoleUserName);
        User consoleUser = new User();
        consoleUser.setUserName(userName);
        consoleUser.setDomain(new Domain());
        consoleUser.getDomain().setName(domainName);
        Session consoleSession = new Session();
        consoleSession.setUser(consoleUser);
        if (vm.getClientIp() != null && !vm.getClientIp().isEmpty()) {
            IP ip = new IP();
            ip.setAddress(vm.getClientIp());
            consoleSession.setIp(ip);
        }
        consoleSession.setConsoleUser(true);
        // TODO: in the future, map the connection protocol as well
        sessions.getSessions().add(consoleSession);
    }
    return sessions;
}
#method_after
private static Sessions mapConsoleSession(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    // currently in format user@domain, so needs to be
    String consoleUserName = vm.getConsoleCurentUserName();
    // parsed.
    if (consoleUserName != null && !consoleUserName.isEmpty()) {
        String userName = parseUserName(consoleUserName);
        String domainName = parseDomainName(consoleUserName);
        User consoleUser = new User();
        consoleUser.setUserName(userName);
        consoleUser.setDomain(new Domain());
        consoleUser.getDomain().setName(domainName);
        Session consoleSession = new Session();
        consoleSession.setUser(consoleUser);
        if (vm.getClientIp() != null && !vm.getClientIp().isEmpty()) {
            Ip ip = new Ip();
            ip.setAddress(vm.getClientIp());
            consoleSession.setIp(ip);
        }
        consoleSession.setConsoleUser(true);
        // TODO: in the future, map the connection protocol as well
        sessions.getSessions().add(consoleSession);
    }
    return sessions;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.InstanceType.class, to = InstanceType.class)
public static InstanceType map(org.ovirt.engine.core.common.businessentities.InstanceType entity, InstanceType incoming) {
    InstanceType model = incoming != null ? incoming : new InstanceType();
    mapCommonEntityToModel(model, (VmTemplate) entity);
    model.setDisplay(DisplayMapper.map(entity, null));
    if (entity.getDefaultBootSequence() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        model.setOs(os);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.InstanceType.class, to = InstanceType.class)
public static InstanceType map(org.ovirt.engine.core.common.businessentities.InstanceType entity, InstanceType incoming) {
    InstanceType model = incoming != null ? incoming : new InstanceType();
    mapCommonEntityToModel(model, (VmTemplate) entity);
    model.setDisplay(DisplayMapper.map(entity, null));
    if (entity.getDefaultBootSequence() != null) {
        OperatingSystem os = model.getOs();
        if (os == null) {
            os = new OperatingSystem();
        }
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        model.setOs(os);
    }
    return model;
}
#end_block

#method_before
public static void fillDisplayInParams(VM vm, RunVmOnceParams params) {
    if (params == null) {
        return;
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            org.ovirt.engine.core.common.businessentities.DisplayType display = mapDisplayType(displayType, null);
            if (display != null) {
                Set<GraphicsType> graphics = new HashSet<>();
                switch(display) {
                    case qxl:
                        graphics.add(GraphicsType.SPICE);
                        break;
                    case vga:
                    case cirrus:
                        graphics.add(GraphicsType.VNC);
                        break;
                }
                params.setRunOnceGraphics(graphics);
            }
        }
    }
}
#method_after
public static void fillDisplayInParams(Vm vm, RunVmOnceParams params) {
    if (params == null) {
        return;
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            org.ovirt.engine.core.common.businessentities.DisplayType display = mapDisplayType(displayType, null);
            if (display != null) {
                Set<GraphicsType> graphics = new HashSet<>();
                switch(display) {
                    case qxl:
                        graphics.add(GraphicsType.SPICE);
                        break;
                    case vga:
                    case cirrus:
                        graphics.add(GraphicsType.VNC);
                        break;
                }
                params.setRunOnceGraphics(graphics);
            }
        }
    }
}
#end_block

#method_before
protected List<StorageDomainStatic> filterAttachedStorageDomains() {
    List<StorageDomain> connectedStorageDomainsToVds = new ArrayList<>();
    for (StorageDomain storageDomain : getParameters().getStorageDomainList()) {
        if (!connectStorageDomain(storageDomain)) {
            logErrorMessage(storageDomain);
        } else {
            connectedStorageDomainsToVds.add(storageDomain);
        }
    }
    List<StorageDomainStatic> storageDomainsWithAttachedStoragePoolId = getAttachedStorageDomains(connectedStorageDomainsToVds);
    for (StorageDomain storageDomain : connectedStorageDomainsToVds) {
        if (containsRunningVMs(storageDomain)) {
            log.warn("Skipping disconnect Storage Domain {} from VDS '{}' because it has running VMs on it. ", storageDomain.getName(), getVdsId());
            continue;
        }
        if (!disconnectStorageDomain(storageDomain)) {
            log.warn("Could not disconnect Storage Domain {} from VDS '{}'. ", storageDomain.getName(), getVdsId());
        }
    }
    return storageDomainsWithAttachedStoragePoolId;
}
#method_after
protected List<StorageDomainStatic> filterAttachedStorageDomains() {
    List<StorageDomain> connectedStorageDomainsToVds = new ArrayList<>();
    for (StorageDomain storageDomain : getParameters().getStorageDomainList()) {
        if (!connectStorageDomain(storageDomain)) {
            logErrorMessage(storageDomain);
        } else {
            connectedStorageDomainsToVds.add(storageDomain);
        }
    }
    List<StorageDomainStatic> storageDomainsWithAttachedStoragePoolId = getAttachedStorageDomains(connectedStorageDomainsToVds);
    for (StorageDomain storageDomain : connectedStorageDomainsToVds) {
        if (containsRunningHostedEngine(storageDomain)) {
            log.info("Skipping disconnect Storage Domain {} from VDS '{}' because Hosted Engine VM is running on it.", storageDomain.getName(), getVdsId());
            continue;
        }
        if (!disconnectStorageDomain(storageDomain)) {
            log.warn("Could not disconnect Storage Domain {} from VDS '{}'. ", storageDomain.getName(), getVdsId());
        }
    }
    return storageDomainsWithAttachedStoragePoolId;
}
#end_block

#method_before
private void addOrUpdateHooks(Guid clusterId, List<Pair<VDS, VDSReturnValue>> pairResults) {
    try {
        List<GlusterHookEntity> existingHooks = getHooksDao().getByClusterId(clusterId);
        List<Callable<Pair<GlusterHookEntity, VDSReturnValue>>> contentTasksList = new ArrayList<>();
        Map<String, GlusterHookEntity> existingHookMap = new HashMap<>();
        Map<Guid, Set<VDS>> existingHookServersMap = new HashMap<>();
        Map<String, Integer> existingHookConflictMap = new HashMap<>();
        for (final GlusterHookEntity hook : existingHooks) {
            existingHookServersMap.put(hook.getId(), new HashSet<VDS>());
            existingHookConflictMap.put(hook.getHookKey(), hook.getConflictStatus());
            // initialize hook conflict status as this is to be computed again
            hook.setConflictStatus(0);
            existingHookMap.put(hook.getHookKey(), hook);
        }
        Set<String> fetchedHookKeyList = new HashSet<>();
        Map<String, GlusterHookEntity> newHookMap = new HashMap<>();
        List<GlusterServerHook> newServerHooks = new ArrayList<>();
        List<GlusterServerHook> updatedServerHooks = new ArrayList<>();
        List<GlusterServerHook> deletedServerHooks = new ArrayList<>();
        Set<VDS> upServers = new HashSet<>();
        for (Pair<VDS, VDSReturnValue> pairResult : pairResults) {
            final VDS server = pairResult.getFirst();
            upServers.add(server);
            if (!pairResult.getSecond().getSucceeded()) {
                log.info("Failed to get list of hooks from server '{}' with error: {}", server, pairResult.getSecond().getVdsError().getMessage());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_HOOK_LIST_FAILED);
                continue;
            }
            @SuppressWarnings("unchecked")
            List<GlusterHookEntity> fetchedHooks = (List<GlusterHookEntity>) pairResult.getSecond().getReturnValue();
            for (GlusterHookEntity fetchedHook : fetchedHooks) {
                String key = fetchedHook.getHookKey();
                fetchedHookKeyList.add(key);
                GlusterHookEntity existingHook = existingHookMap.get(key);
                if (existingHook != null) {
                    updateHookServerMap(existingHookServersMap, existingHook.getId(), server);
                    GlusterServerHook serverHook = getHooksDao().getGlusterServerHook(existingHook.getId(), server.getId());
                    Integer conflictStatus = getConflictStatus(existingHook, fetchedHook);
                    // aggregate conflicts across hooks
                    existingHook.setConflictStatus(conflictStatus | existingHookMap.get(key).getConflictStatus());
                    if (conflictStatus == 0) {
                        // so remove from server hooks table if exists
                        if (serverHook != null) {
                            deletedServerHooks.add(serverHook);
                        }
                    } else {
                        // there is a conflict. we need to either add or update entry in server hook
                        if (serverHook == null) {
                            newServerHooks.add(buildServerHook(server.getId(), existingHook.getId(), fetchedHook));
                        } else {
                            if (!(serverHook.getChecksum().equals(fetchedHook.getChecksum()) && serverHook.getContentType().equals(fetchedHook.getContentType()) && serverHook.getStatus().equals(fetchedHook.getStatus()))) {
                                log.info("Updating existing server hook '{}' in server '{}' ", key, server);
                                serverHook.setChecksum(fetchedHook.getChecksum());
                                serverHook.setContentType(fetchedHook.getContentType());
                                serverHook.setStatus(fetchedHook.getStatus());
                                updatedServerHooks.add(serverHook);
                            }
                        }
                    }
                } else {
                    GlusterHookEntity newHook = newHookMap.get(key);
                    if (newHook == null) {
                        newHook = fetchedHook;
                        newHook.setClusterId(clusterId);
                        newHook.setId(Guid.newGuid());
                        log.info("Detected new hook '{}' in server '{}', adding to engine hooks", key, server);
                        logMessage(clusterId, key, AuditLogType.GLUSTER_HOOK_DETECTED_NEW);
                        updateContentTasksList(contentTasksList, newHook, server);
                        existingHookServersMap.put(newHook.getId(), new HashSet<VDS>());
                    }
                    Integer conflictStatus = getConflictStatus(newHook, fetchedHook);
                    if (conflictStatus > 0) {
                        newHook.getServerHooks().add(buildServerHook(server.getId(), newHook.getId(), fetchedHook));
                    }
                    newHook.setConflictStatus(newHook.getConflictStatus() | conflictStatus);
                    newHookMap.put(key, newHook);
                    updateHookServerMap(existingHookServersMap, newHook.getId(), server);
                }
            }
        }
        // Save new hooks
        saveNewHooks(newHookMap, contentTasksList);
        // Add new server hooks
        for (GlusterServerHook serverHook : newServerHooks) {
            getHooksDao().saveGlusterServerHook(serverHook);
        }
        // Update existing server hooks
        for (GlusterServerHook serverHook : updatedServerHooks) {
            getHooksDao().updateGlusterServerHook(serverHook);
        }
        // Delete hooks
        for (GlusterServerHook serverHook : deletedServerHooks) {
            getHooksDao().removeGlusterServerHooks(serverHook.getHookId());
        }
        syncExistingHooks(existingHookMap, existingHookServersMap, existingHookConflictMap, upServers);
        // Update missing conflicts for hooks found only in db and not on any of the servers
        Set<String> hooksOnlyInDB = new HashSet<>(existingHookMap.keySet());
        hooksOnlyInDB.removeAll(fetchedHookKeyList);
        for (String key : hooksOnlyInDB) {
            GlusterHookEntity hook = existingHookMap.get(key);
            hook.addMissingConflict();
            logMessage(hook.getClusterId(), hook.getHookKey(), AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED);
            getHooksDao().updateGlusterHookConflictStatus(hook.getId(), hook.getConflictStatus());
        }
    } catch (Exception e) {
        log.error("Exception in sync", e);
        throw new EngineException(EngineError.GlusterHookListException, e.getLocalizedMessage());
    }
}
#method_after
private void addOrUpdateHooks(Guid clusterId, List<Pair<VDS, VDSReturnValue>> pairResults) {
    try {
        List<GlusterHookEntity> existingHooks = getHooksDao().getByClusterId(clusterId);
        List<Callable<Pair<GlusterHookEntity, VDSReturnValue>>> contentTasksList = new ArrayList<>();
        Map<String, GlusterHookEntity> existingHookMap = new HashMap<>();
        Map<Guid, Set<VDS>> existingHookServersMap = new HashMap<>();
        Map<String, Integer> existingHookConflictMap = new HashMap<>();
        for (final GlusterHookEntity hook : existingHooks) {
            existingHookServersMap.put(hook.getId(), new HashSet<VDS>());
            existingHookConflictMap.put(hook.getHookKey(), hook.getConflictStatus());
            // initialize hook conflict status as this is to be computed again
            hook.setConflictStatus(0);
            existingHookMap.put(hook.getHookKey(), hook);
        }
        Set<String> fetchedHookKeyList = new HashSet<>();
        Map<String, GlusterHookEntity> newHookMap = new HashMap<>();
        List<GlusterServerHook> newServerHooks = new ArrayList<>();
        List<GlusterServerHook> updatedServerHooks = new ArrayList<>();
        Set<VDS> upServers = new HashSet<>();
        for (Pair<VDS, VDSReturnValue> pairResult : pairResults) {
            final VDS server = pairResult.getFirst();
            upServers.add(server);
            if (!pairResult.getSecond().getSucceeded()) {
                log.info("Failed to get list of hooks from server '{}' with error: {}", server, pairResult.getSecond().getVdsError().getMessage());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_HOOK_LIST_FAILED);
                continue;
            }
            @SuppressWarnings("unchecked")
            List<GlusterHookEntity> fetchedHooks = (List<GlusterHookEntity>) pairResult.getSecond().getReturnValue();
            for (GlusterHookEntity fetchedHook : fetchedHooks) {
                String key = fetchedHook.getHookKey();
                fetchedHookKeyList.add(key);
                GlusterHookEntity existingHook = existingHookMap.get(key);
                if (existingHook != null) {
                    updateHookServerMap(existingHookServersMap, existingHook.getId(), server);
                    GlusterServerHook serverHook = getHooksDao().getGlusterServerHook(existingHook.getId(), server.getId());
                    Integer conflictStatus = getConflictStatus(existingHook, fetchedHook);
                    // aggregate conflicts across hooks
                    existingHook.setConflictStatus(conflictStatus | existingHookMap.get(key).getConflictStatus());
                    if (conflictStatus != 0) {
                        // there is a conflict. we need to either add or update entry in server hook
                        if (serverHook == null) {
                            newServerHooks.add(buildServerHook(server.getId(), existingHook.getId(), fetchedHook));
                        } else {
                            if (!(serverHook.getChecksum().equals(fetchedHook.getChecksum()) && serverHook.getContentType().equals(fetchedHook.getContentType()) && serverHook.getStatus().equals(fetchedHook.getStatus()))) {
                                log.info("Updating existing server hook '{}' in server '{}' ", key, server);
                                serverHook.setChecksum(fetchedHook.getChecksum());
                                serverHook.setContentType(fetchedHook.getContentType());
                                serverHook.setStatus(fetchedHook.getStatus());
                                updatedServerHooks.add(serverHook);
                            }
                        }
                    }
                } else {
                    GlusterHookEntity newHook = newHookMap.get(key);
                    if (newHook == null) {
                        newHook = fetchedHook;
                        newHook.setClusterId(clusterId);
                        newHook.setId(Guid.newGuid());
                        log.info("Detected new hook '{}' in server '{}', adding to engine hooks", key, server);
                        logMessage(clusterId, key, AuditLogType.GLUSTER_HOOK_DETECTED_NEW);
                        updateContentTasksList(contentTasksList, newHook, server);
                        existingHookServersMap.put(newHook.getId(), new HashSet<VDS>());
                    }
                    Integer conflictStatus = getConflictStatus(newHook, fetchedHook);
                    if (conflictStatus > 0) {
                        newHook.getServerHooks().add(buildServerHook(server.getId(), newHook.getId(), fetchedHook));
                    }
                    newHook.setConflictStatus(newHook.getConflictStatus() | conflictStatus);
                    newHookMap.put(key, newHook);
                    updateHookServerMap(existingHookServersMap, newHook.getId(), server);
                }
            }
        }
        // Save new hooks
        saveNewHooks(newHookMap, contentTasksList);
        // Add new server hooks
        for (GlusterServerHook serverHook : newServerHooks) {
            getHooksDao().saveGlusterServerHook(serverHook);
        }
        // Update existing server hooks
        for (GlusterServerHook serverHook : updatedServerHooks) {
            getHooksDao().updateGlusterServerHook(serverHook);
        }
        syncExistingHooks(existingHookMap, existingHookServersMap, existingHookConflictMap, upServers);
        // Update missing conflicts for hooks found only in db and not on any of the servers
        Set<String> hooksOnlyInDB = new HashSet<>(existingHookMap.keySet());
        hooksOnlyInDB.removeAll(fetchedHookKeyList);
        for (String key : hooksOnlyInDB) {
            GlusterHookEntity hook = existingHookMap.get(key);
            hook.addMissingConflict();
            logMessage(hook.getClusterId(), hook.getHookKey(), AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED);
            getHooksDao().updateGlusterHookConflictStatus(hook.getId(), hook.getConflictStatus());
        }
    } catch (Exception e) {
        log.error("Exception in sync", e);
        throw new EngineException(EngineError.GlusterHookListException, e.getLocalizedMessage());
    }
}
#end_block

#method_before
@Override
public DevicesResource<NIC, Nics> getNicsResource() {
    return inject(new BackendTemplateNicsResource(guid));
}
#method_after
@Override
public DevicesResource<Nic, Nics> getNicsResource() {
    return inject(new BackendTemplateNicsResource(guid));
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    Version compatibilityVersion = Version.getLast();
    if (!updated.isBlank()) {
        compatibilityVersion = lookupCluster(updated.getVdsGroupId()).getCompatibilityVersion();
    }
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), compatibilityVersion));
    UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated);
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    IconHelper.setIconToParams(incoming, params);
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params);
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params);
}
#method_after
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy()));
    UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated);
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    IconHelper.setIconToParams(incoming, params);
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params);
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params);
}
#end_block

#method_before
@Override
protected Template doPopulate(Template model, VmTemplate entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, entity.getId()).isEmpty());
    model.setSoundcardEnabled(VmHelper.getSoundDevicesForEntity(this, entity.getId()).isEmpty());
    setRngDevice(model);
    return model;
}
#method_after
@Override
protected Template doPopulate(Template model, VmTemplate entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtioScsi());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, entity.getId()).isEmpty());
    model.setSoundcardEnabled(VmHelper.getSoundDevicesForEntity(this, entity.getId()).isEmpty());
    setRngDevice(model);
    return model;
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Command);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Command);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        log.info("No changes were detected in setup networks for host '{}' (ID '{}')", getVdsName(), getVdsId());
        if (isInternalExecution()) {
            setActionReturnValue(SETUP_NETWORKS_RESOLUTION.NO_CHANGES_DETECTED);
        }
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds().keySet(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().isCheckConnectivity()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        log.info("No changes were detected in setup networks for host '{}' (ID '{}')", getVdsName(), getVdsId());
        if (isInternalExecution()) {
            setActionReturnValue(SETUP_NETWORKS_RESOLUTION.NO_CHANGES_DETECTED);
        }
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds().keySet(), getInterfaces(), getParameters().getCustomProperties());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().isCheckConnectivity()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            List<VdsNetworkInterface> ifaces = new ArrayList<>(getInterfaces());
            ifaces.addAll(getRemovedBonds().values());
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(Collections.<NetworkAttachment>emptyList(), ifaces);
            // save the new network topology to DB
            hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#method_after
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            List<VdsNetworkInterface> ifaces = new ArrayList<>(getInterfaces());
            ifaces.addAll(getRemovedBonds().values());
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(Collections.<NetworkAttachment>emptyList(), ifaces, getParameters().getCustomProperties());
            // save the new network topology to DB
            hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#end_block

#method_before
public void execute() throws MojoExecutionException {
    // Load the general filters and the filters from the project that is currently being processed:
    List<NodeList> nodeLists = new ArrayList<>();
    if (globalFilters != null) {
        for (String path : globalFilters) {
            NodeList nodes = loadGlobalFilters(path);
            if (nodes != null) {
                nodeLists.add(nodes);
            }
        }
    }
    if (projectFilters != null) {
        for (String path : projectFilters) {
            NodeList nodes = loadProjectFilters(path);
            if (nodes != null) {
                nodeLists.add(nodes);
            }
        }
    }
    // Save all the loaded filters to a single file created in the target directory of the project:
    File filterFile = new File(project.getBasedir(), "target" + File.separator + "findbugs-filters.xml");
    getLog().info("Saving filters to file \"" + filterFile.getAbsolutePath() + "\"");
    saveNodes(filterFile, nodeLists);
    // Load the description of the findbugs plugin:
    Plugin findbugsPluginModel = new Plugin();
    findbugsPluginModel.setGroupId("org.codehaus.mojo");
    findbugsPluginModel.setArtifactId("findbugs-maven-plugin");
    findbugsPluginModel.setVersion("3.0.2");
    PluginDescriptor findbugsPluginDescriptor;
    try {
        findbugsPluginDescriptor = pluginManager.loadPlugin(findbugsPluginModel, project.getRemotePluginRepositories(), session.getRepositorySession());
    } catch (Exception exception) {
        throw new MojoExecutionException("Can't load findbugs plugin \"" + findbugsPluginModel.getId() + "\"", exception);
    }
    getLog().info("Loaded the findbugs plugin \"" + findbugsPluginDescriptor.getId() + "\"");
    // Get the descriptor of the findbugs mojo:
    MojoDescriptor findbugsMojoDescriptor = findbugsPluginDescriptor.getMojo("findbugs");
    if (findbugsMojoDescriptor == null) {
        throw new MojoExecutionException("Can't find findbugs mojo");
    }
    getLog().info("Loaded the findbugs mojo \"" + findbugsMojoDescriptor.getId() + "\"");
    // Prepare the configuration for the findbugs mojo, including the reference to the filters file that has been
    // previously created:
    Xpp3Dom findbugsConfiguration = makeConfiguration(filterFile);
    // Merge the previously prepared configuration with the defaults:
    Xpp3Dom findbugsDefaults = toDom(findbugsMojoDescriptor.getMojoConfiguration());
    findbugsConfiguration = mergeXpp3Dom(findbugsConfiguration, findbugsDefaults);
    // Execute the findbugs plugin:
    MojoExecution findbugsExecution = new MojoExecution(findbugsMojoDescriptor, findbugsConfiguration);
    try {
        pluginManager.executeMojo(session, findbugsExecution);
    } catch (Exception exception) {
        throw new MojoExecutionException("Execution of findbugs mojo failed", exception);
    }
}
#method_after
public void execute() throws MojoExecutionException {
    // Load the general filters and the filters from the project that is currently being processed:
    List<NodeList> nodeLists = new ArrayList<>();
    if (globalFilters != null) {
        for (String path : globalFilters) {
            NodeList nodes = loadGlobalFilters(path);
            if (nodes != null) {
                nodeLists.add(nodes);
            }
        }
    }
    if (projectFilters != null) {
        for (String path : projectFilters) {
            NodeList nodes = loadProjectFilters(path);
            if (nodes != null) {
                nodeLists.add(nodes);
            }
        }
    }
    // Save all the loaded filters to a single file created in the target directory of the project:
    File filterFile = new File(project.getBasedir(), "target" + File.separator + "findbugs-filters.xml");
    getLog().info("Saving filters to file \"" + filterFile.getAbsolutePath() + "\"");
    saveNodes(filterFile, nodeLists);
    // Load the description of the findbugs plugin:
    Plugin findbugsPluginModel = new Plugin();
    findbugsPluginModel.setGroupId("org.codehaus.mojo");
    findbugsPluginModel.setArtifactId("findbugs-maven-plugin");
    findbugsPluginModel.setVersion("3.0.2");
    PluginDescriptor findbugsPluginDescriptor;
    try {
        // We need to use reflection here in order to support Maven 3.0 and Maven 3.1, see the comments in the
        // "invoke" method for details:
        Object remoteRepositories = invoke(project, "getRemotePluginRepositories");
        Object repositorySession = invoke(session, "getRepositorySession");
        findbugsPluginDescriptor = (PluginDescriptor) invoke(pluginManager, "loadPlugin", findbugsPluginModel, remoteRepositories, repositorySession);
    } catch (Exception exception) {
        throw new MojoExecutionException("Can't load findbugs plugin \"" + findbugsPluginModel.getId() + "\"", exception);
    }
    getLog().info("Loaded the findbugs plugin \"" + findbugsPluginDescriptor.getId() + "\"");
    // Get the descriptor of the findbugs mojo:
    MojoDescriptor findbugsMojoDescriptor = findbugsPluginDescriptor.getMojo("findbugs");
    if (findbugsMojoDescriptor == null) {
        throw new MojoExecutionException("Can't find findbugs mojo");
    }
    getLog().info("Loaded the findbugs mojo \"" + findbugsMojoDescriptor.getId() + "\"");
    // Prepare the configuration for the findbugs mojo, including the reference to the filters file that has been
    // previously created:
    Xpp3Dom findbugsConfiguration = makeConfiguration(filterFile);
    // Merge the previously prepared configuration with the defaults:
    Xpp3Dom findbugsDefaults = toDom(findbugsMojoDescriptor.getMojoConfiguration());
    findbugsConfiguration = mergeXpp3Dom(findbugsConfiguration, findbugsDefaults);
    // Execute the findbugs plugin:
    MojoExecution findbugsExecution = new MojoExecution(findbugsMojoDescriptor, findbugsConfiguration);
    try {
        pluginManager.executeMojo(session, findbugsExecution);
    } catch (Exception exception) {
        throw new MojoExecutionException("Execution of findbugs mojo failed", exception);
    }
}
#end_block

#method_before
private NodeList loadProjectFilters(String path) throws MojoExecutionException {
    File file = new File(project.getBasedir(), path);
    if (!file.exists()) {
        getLog().warn("The filters file \"" + file.getAbsolutePath() + "\" doesn't exist");
        return null;
    }
    getLog().info("Loading filters file \"" + file.getAbsolutePath() + "\"");
    try (InputStream in = new FileInputStream(file)) {
        return loadNodes(in);
    } catch (IOException exception) {
        throw new MojoExecutionException("Error loading filters file \"" + file.getAbsolutePath() + "\"", exception);
    }
}
#method_after
private NodeList loadProjectFilters(String path) throws MojoExecutionException {
    File file = new File(project.getBasedir(), path);
    if (!file.exists()) {
        getLog().info("The filters file \"" + file.getAbsolutePath() + "\" doesn't exist");
        return null;
    }
    getLog().info("Loading filters file \"" + file.getAbsolutePath() + "\"");
    try (InputStream in = new FileInputStream(file)) {
        return loadNodes(in);
    } catch (IOException exception) {
        throw new MojoExecutionException("Error loading filters file \"" + file.getAbsolutePath() + "\"", exception);
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(RegistrationResult.RetrievedEventDefinition)) {
        asyncResult_Retrieved();
    }
    if (ev.matchesDefinition(ProvideTickEvent.definition)) {
        syncSearch();
    }
    entityModel.eventRaised(ev, sender, args);
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    entityModel.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(RegistrationResult.RetrievedEventDefinition)) {
        asyncResult_Retrieved();
    }
    if (ev.matchesDefinition(ProvideTickEvent.definition)) {
        syncSearch();
    }
}
#end_block

#method_before
private SetupNetworksParameters toParameters(Action action) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.setInterfaces(nicsToInterfaces(action.getHostNics().getHostNics()));
    parameters.setCustomProperties(nicsToCustomProperties(action.getHostNics().getHostNics()));
    parameters.setVdsId(Guid.createGuidFromStringDefaultEmpty(getHostId()));
    parameters.setForce(action.isSetForce() ? action.isForce() : false);
    parameters.setCheckConnectivity(action.isSetCheckConnectivity() ? action.isCheckConnectivity() : false);
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    parameters.setNetworksToSync(nicsToNetworksToSync(action.getHostNics().getHostNics()));
    return parameters;
}
#method_after
private SetupNetworksParameters toParameters(Action action) {
    List<HostNIC> hostNics = action.getHostNics().getHostNics();
    List<VdsNetworkInterface> existingNics = getCollection();
    BusinessEntityMap<VdsNetworkInterface> existingNicsMapping = new BusinessEntityMap<>(existingNics);
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.setInterfaces(nicsToInterfaces(hostNics, existingNicsMapping));
    parameters.setCustomProperties(nicsToCustomProperties(hostNics, existingNicsMapping));
    parameters.setVdsId(Guid.createGuidFromStringDefaultEmpty(getHostId()));
    parameters.setForce(action.isSetForce() ? action.isForce() : false);
    parameters.setCheckConnectivity(action.isSetCheckConnectivity() ? action.isCheckConnectivity() : false);
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    parameters.setNetworksToSync(nicsToNetworksToSync(hostNics));
    return parameters;
}
#end_block

#method_before
private CustomPropertiesFor<VdsNetworkInterface> nicsToCustomProperties(List<HostNIC> hostNics) {
    CustomPropertiesFor<VdsNetworkInterface> result = new CustomPropertiesFor<>();
    for (HostNIC hostNic : hostNics) {
        if (hostNic.isSetProperties()) {
            result.add(GuidUtils.asGuid(hostNic.getId()), CustomPropertiesParser.toMap(hostNic.getProperties()));
        }
    }
    return result;
}
#method_after
private CustomPropertiesForVdsNetworkInterface nicsToCustomProperties(List<HostNIC> hostNics, BusinessEntityMap<VdsNetworkInterface> existingNicsMapping) {
    CustomPropertiesForVdsNetworkInterface result = new CustomPropertiesForVdsNetworkInterface();
    for (HostNIC hostNic : hostNics) {
        if (hostNic.isSetProperties()) {
            String hostNicName = hostNic.getName();
            String nicName = StringUtils.isEmpty(hostNicName) ? existingNicsMapping.get(hostNic.getId()).getName() : hostNicName;
            result.add(nicName, CustomPropertiesParser.toMap(hostNic.getProperties()));
        }
    }
    return result;
}
#end_block

#method_before
private List<VdsNetworkInterface> nicsToInterfaces(List<HostNIC> hostNics) {
    List<VdsNetworkInterface> ifaces = new ArrayList<>(hostNics.size());
    List<VdsNetworkInterface> existingNics = getCollection();
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(existingNics);
    Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(existingNics);
    for (HostNIC nic : hostNics) {
        VdsNetworkInterface iface = map(nic, null);
        ifaces.add(iface);
        if (nic.isSetBonding() && nic.getBonding().isSetSlaves()) {
            for (HostNIC slave : nic.getBonding().getSlaves().getSlaves()) {
                VdsNetworkInterface slaveIface = map(slave, slave.getId() == null ? lookupInterfaceByName(slave.getName()) : lookupInterfaceById(slave.getId()));
                slaveIface.setBondName(nic.getName());
                ifaces.add(slaveIface);
            }
        }
        if (nic.isSetName() && nicsByName.containsKey(nic.getName())) {
            iface.setLabels(nicsByName.get(nic.getName()).getLabels());
        } else if (nic.isSetId()) {
            Guid nicId = asGuid(nic.getId());
            if (nicsById.containsKey(nicId)) {
                iface.setLabels(nicsById.get(nicId).getLabels());
            }
        }
    }
    return ifaces;
}
#method_after
private List<VdsNetworkInterface> nicsToInterfaces(List<HostNIC> hostNics, BusinessEntityMap<VdsNetworkInterface> existingNicsMapping) {
    List<VdsNetworkInterface> ifaces = new ArrayList<>(hostNics.size());
    for (HostNIC nic : hostNics) {
        VdsNetworkInterface iface = map(nic, null);
        ifaces.add(iface);
        if (nic.isSetBonding() && nic.getBonding().isSetSlaves()) {
            for (HostNIC slave : nic.getBonding().getSlaves().getSlaves()) {
                VdsNetworkInterface slaveIface = map(slave, slave.getId() == null ? lookupInterfaceByName(slave.getName()) : lookupInterfaceById(slave.getId()));
                slaveIface.setBondName(nic.getName());
                ifaces.add(slaveIface);
            }
        }
        if (nic.isSetName() && existingNicsMapping.containsKey(nic.getName())) {
            iface.setLabels(existingNicsMapping.get(nic.getName()).getLabels());
        } else if (nic.isSetId()) {
            Guid nicId = asGuid(nic.getId());
            if (existingNicsMapping.containsKey(nicId)) {
                iface.setLabels(existingNicsMapping.get(nicId).getLabels());
            }
        }
    }
    return ifaces;
}
#end_block

#method_before
@Mapping(from = VdsNetworkInterface.class, to = HostNIC.class)
public static HostNIC map(VdsNetworkInterface entity, HostNIC template) {
    HostNIC model = template != null ? template : new HostNIC();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkName() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setName(entity.getNetworkName());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getBaseInterface() != null) {
        model.setBaseInterface(entity.getBaseInterface());
    }
    if (entity.getVlanId() != null) {
        model.setVlan(new VLAN());
        model.getVlan().setId(entity.getVlanId());
    }
    if (entity.getAddress() != null || entity.getGateway() != null || entity.getSubnet() != null) {
        model.setIp(new IP());
        if (entity.getAddress() != null) {
            model.getIp().setAddress(entity.getAddress());
        }
        if (entity.getGateway() != null) {
            model.getIp().setGateway(entity.getGateway());
        }
        if (entity.getSubnet() != null) {
            model.getIp().setNetmask(entity.getSubnet());
        }
    }
    if (entity.getMacAddress() != null) {
        model.setMac(new MAC());
        model.getMac().setAddress(entity.getMacAddress());
    }
    if (entity.getStatistics().getStatus() != InterfaceStatus.NONE) {
        NicStatus nicStatus = map(entity.getStatistics().getStatus(), null);
        if (nicStatus != null) {
            model.setStatus(StatusUtils.create(nicStatus));
        }
    }
    if (entity.getSpeed() != null && entity.getSpeed() > 0) {
        model.setSpeed(entity.getSpeed() * 1000L * 1000);
    }
    if (!StringUtils.isEmpty(entity.getBondOptions())) {
        if (model.getBonding() == null)
            model.setBonding(new Bonding());
        model.getBonding().setOptions(new Options());
        for (String opt : entity.getBondOptions().split(OPTIONS_DELIMITER)) {
            String[] option_pair = opt.split(OPTIONS_EQ);
            if (option_pair.length == 2) {
                Option option = new Option();
                option.setName(option_pair[0]);
                option.setValue(option_pair[1]);
                option.setType(getType(option_pair));
                model.getBonding().getOptions().getOptions().add(option);
            }
        }
    }
    BootProtocol bootProtocol = BootProtocolMapper.map(entity.getBootProtocol(), null);
    if (bootProtocol != null) {
        model.setBootProtocol(bootProtocol.value());
    }
    model.setMtu(entity.getMtu());
    model.setBridged(entity.isBridged());
    if (entity.getNetworkImplementationDetails() != null) {
        model.setCustomConfiguration(!entity.getNetworkImplementationDetails().isInSync());
    }
    // will not be reported at all.
    // if (entity.hasCustomProperties()) {
    // model.setProperties(CustomPropertiesParser.fromMap(entity.getCustomProperties()));
    // }
    HostNetworkQos qos = entity.getQos();
    if (qos != null) {
        model.setQos(QosMapper.map(qos, null));
    }
    return model;
}
#method_after
@Mapping(from = VdsNetworkInterface.class, to = HostNIC.class)
public static HostNIC map(VdsNetworkInterface entity, HostNIC template) {
    HostNIC model = template != null ? template : new HostNIC();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkName() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setName(entity.getNetworkName());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getBaseInterface() != null) {
        model.setBaseInterface(entity.getBaseInterface());
    }
    if (entity.getVlanId() != null) {
        model.setVlan(new VLAN());
        model.getVlan().setId(entity.getVlanId());
    }
    if (entity.getAddress() != null || entity.getGateway() != null || entity.getSubnet() != null) {
        model.setIp(new IP());
        if (entity.getAddress() != null) {
            model.getIp().setAddress(entity.getAddress());
        }
        if (entity.getGateway() != null) {
            model.getIp().setGateway(entity.getGateway());
        }
        if (entity.getSubnet() != null) {
            model.getIp().setNetmask(entity.getSubnet());
        }
    }
    if (entity.getMacAddress() != null) {
        model.setMac(new MAC());
        model.getMac().setAddress(entity.getMacAddress());
    }
    if (entity.getStatistics().getStatus() != InterfaceStatus.NONE) {
        NicStatus nicStatus = map(entity.getStatistics().getStatus(), null);
        if (nicStatus != null) {
            model.setStatus(StatusUtils.create(nicStatus));
        }
    }
    if (entity.getSpeed() != null && entity.getSpeed() > 0) {
        model.setSpeed(entity.getSpeed() * 1000L * 1000);
    }
    if (!StringUtils.isEmpty(entity.getBondOptions())) {
        if (model.getBonding() == null)
            model.setBonding(new Bonding());
        model.getBonding().setOptions(new Options());
        for (String opt : entity.getBondOptions().split(OPTIONS_DELIMITER)) {
            String[] option_pair = opt.split(OPTIONS_EQ);
            if (option_pair.length == 2) {
                Option option = new Option();
                option.setName(option_pair[0]);
                option.setValue(option_pair[1]);
                option.setType(getType(option_pair));
                model.getBonding().getOptions().getOptions().add(option);
            }
        }
    }
    BootProtocol bootProtocol = BootProtocolMapper.map(entity.getBootProtocol(), null);
    if (bootProtocol != null) {
        model.setBootProtocol(bootProtocol.value());
    }
    model.setMtu(entity.getMtu());
    model.setBridged(entity.isBridged());
    if (entity.getNetworkImplementationDetails() != null) {
        model.setCustomConfiguration(!entity.getNetworkImplementationDetails().isInSync());
    }
    HostNetworkQos qos = entity.getQos();
    if (qos != null) {
        model.setQos(QosMapper.map(qos, null));
    }
    return model;
}
#end_block

#method_before
@Override
protected void verify(HostNIC model, HostNIC transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getNetwork());
    assertEquals(model.getNetwork().getName(), transform.getNetwork().getName());
    assertNotNull(transform.getIp());
    assertEquals(model.getIp().getAddress(), transform.getIp().getAddress());
    assertEquals(model.getIp().getNetmask(), transform.getIp().getNetmask());
    assertEquals(model.getIp().getGateway(), transform.getIp().getGateway());
    assertNotNull(transform.getMac());
    assertEquals(model.getMac().getAddress(), transform.getMac().getAddress());
    assertNotNull(model.getBonding());
    assertEquals(model.getBonding().getOptions().getOptions().size(), transform.getBonding().getOptions().getOptions().size());
    for (int i = 0; i < model.getBonding().getOptions().getOptions().size(); i++) {
        assertEquals(model.getBonding().getOptions().getOptions().get(i).getName(), transform.getBonding().getOptions().getOptions().get(i).getName());
        assertEquals(model.getBonding().getOptions().getOptions().get(i).getValue(), transform.getBonding().getOptions().getOptions().get(i).getValue());
    }
    assertNotNull(model.getProperties());
// assertEquals(CustomPropertiesParser.toMap(model.getProperties()),
// CustomPropertiesParser.toMap(transform.getProperties()));
}
#method_after
@Override
protected void verify(HostNIC model, HostNIC transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getNetwork());
    assertEquals(model.getNetwork().getName(), transform.getNetwork().getName());
    assertNotNull(transform.getIp());
    assertEquals(model.getIp().getAddress(), transform.getIp().getAddress());
    assertEquals(model.getIp().getNetmask(), transform.getIp().getNetmask());
    assertEquals(model.getIp().getGateway(), transform.getIp().getGateway());
    assertNotNull(transform.getMac());
    assertEquals(model.getMac().getAddress(), transform.getMac().getAddress());
    assertNotNull(model.getBonding());
    assertEquals(model.getBonding().getOptions().getOptions().size(), transform.getBonding().getOptions().getOptions().size());
    for (int i = 0; i < model.getBonding().getOptions().getOptions().size(); i++) {
        assertEquals(model.getBonding().getOptions().getOptions().get(i).getName(), transform.getBonding().getOptions().getOptions().get(i).getName());
        assertEquals(model.getBonding().getOptions().getOptions().get(i).getValue(), transform.getBonding().getOptions().getOptions().get(i).getValue());
    }
    assertNotNull(model.getProperties());
}
#end_block

#method_before
public CustomPropertiesFor<VdsNetworkInterface> getCustomProperties() {
    return customProperties;
}
#method_after
public CustomPropertiesForVdsNetworkInterface getCustomProperties() {
    return customProperties;
}
#end_block

#method_before
public void setCustomProperties(CustomPropertiesFor<VdsNetworkInterface> customProperties) {
    this.customProperties = customProperties;
}
#method_after
public void setCustomProperties(CustomPropertiesForVdsNetworkInterface customProperties) {
    this.customProperties = customProperties;
}
#end_block

#method_before
private void storeAttachmentParamsBeforeDetach() {
    NetworkAttachment networkAttachment = getSetupModel().getNetworkAttachmentForNetwork(getNetwork().getId());
    if (networkAttachment == null) {
        return;
    }
    NetworkParameters netParams = new NetworkParameters();
    IPv4Address ipAdrdress = networkAttachment.getIpConfiguration() != null && networkAttachment.getIpConfiguration().hasPrimaryAddressSet() ? networkAttachment.getIpConfiguration().getPrimaryAddress() : null;
    if (ipAdrdress != null) {
        netParams.setBootProtocol(ipAdrdress.getBootProtocol());
        netParams.setAddress(ipAdrdress.getAddress());
        netParams.setSubnet(ipAdrdress.getNetmask());
        netParams.setGateway(ipAdrdress.getGateway());
    }
    netParams.setQos(networkAttachment.getHostNetworkQos());
    netParams.setQosOverridden(networkAttachment.isQosOverridden());
    netParams.setCustomProperties(networkAttachment.getProperties());
    getSetupModel().getNetworkToLastDetachParams().put(getName(), netParams);
}
#method_after
private void storeAttachmentParamsBeforeDetach() {
    NetworkAttachment networkAttachment = getNetworkAttachment();
    if (networkAttachment == null) {
        return;
    }
    NetworkParameters netParams = new NetworkParameters();
    IPv4Address ipAdrdress = networkAttachment.getIpConfiguration() != null && networkAttachment.getIpConfiguration().hasPrimaryAddressSet() ? networkAttachment.getIpConfiguration().getPrimaryAddress() : null;
    if (ipAdrdress != null) {
        netParams.setBootProtocol(ipAdrdress.getBootProtocol());
        netParams.setAddress(ipAdrdress.getAddress());
        netParams.setSubnet(ipAdrdress.getNetmask());
        netParams.setGateway(ipAdrdress.getGateway());
    }
    netParams.setQos(networkAttachment.getHostNetworkQos());
    netParams.setQosOverridden(networkAttachment.isQosOverridden());
    netParams.setCustomProperties(networkAttachment.getProperties());
    getSetupModel().getNetworkToLastDetachParams().put(getName(), netParams);
}
#end_block

#method_before
public boolean isInSync() {
    NetworkImplementationDetails details = getNetworkImplementationDetails();
    return details == null || details.isInSync();
}
#method_after
public boolean isInSync() {
    ReportedConfigurations reportedConfigurations = getReportedConfigurations();
    return reportedConfigurations == null || reportedConfigurations.isNetworkInSync();
}
#end_block

#method_before
public boolean isManaged() {
    NetworkImplementationDetails details = getNetworkImplementationDetails();
    return details == null || details.isManaged();
}
#method_after
public boolean isManaged() {
    return !(isAttached() && getNetworkAttachment() == null);
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : Collections.<String, String>emptyMap();
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public NetworkAttachment getNetworkAttachmentForNetwork(Guid networkId) {
    // unset networkId may mean a bug, but also it can be unmanaged network, which does not have ids.
    if (networkId == null) {
        return null;
    }
    NetworkAttachment updatedAttachment = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId().get(networkId);
    if (updatedAttachment != null) {
        return updatedAttachment;
    }
    NetworkAttachment existingAttachment = getExistingAttachmentByNetworkId(networkId);
    if (existingAttachment != null && !shouldBeRemoved(existingAttachment.getId())) {
        return existingAttachment;
    }
    throw new IllegalArgumentException(// $NON-NLS-1$
    "Unable to find network attachment for network id " + networkId);
}
#method_after
public NetworkAttachment getNetworkAttachmentForNetwork(Guid networkId) {
    // unset networkId may mean a bug, but also it can be unmanaged network, which does not have ids.
    if (networkId == null) {
        return null;
    }
    NetworkAttachment updatedAttachment = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId().get(networkId);
    if (updatedAttachment != null) {
        return updatedAttachment;
    }
    NetworkAttachment existingAttachment = getExistingAttachmentByNetworkId(networkId);
    if (existingAttachment != null && !shouldBeRemoved(existingAttachment.getId())) {
        return existingAttachment;
    }
    return null;
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allBonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initNicModels();
            hostSetupNetworksParametersData.allNics = allNics;
            hostSetupNetworksParametersData.existingNetworkAttachments = existingNetworkAttachments;
            stopProgress();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allBonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initNetworkModels();
            initDcNetworkParams();
            initNicModels();
            hostSetupNetworksParametersData.allNics = allNics;
            hostSetupNetworksParametersData.existingNetworkAttachments = existingNetworkAttachments;
            stopProgress();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#end_block

#method_before
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            initNetworkModels();
            initDcNetworkParams();
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#method_after
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#end_block

#method_before
public boolean isNetworkInSync() {
    return isNetworkMtuInSync() && isNetworkVlanIdInSync() && isNetworkBridgedFlagInSync() && qosParametersEqual() && isIpConfigurationInSync();
}
#method_after
public boolean isNetworkInSync() {
    return reportConfigurationsOnHost().isNetworkInSync();
}
#end_block

#method_before
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    result.setNetworkInSync(isNetworkInSync());
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork(), isNetworkBridgedFlagInSync());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId(), isNetworkVlanIdInSync());
    addReportedIpConfiguration(result);
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos), isOutAverageLinkShareInSync());
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos), isOutAverageUpperLimitInSync());
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos), isOutAverageRealTimeInSync());
    }
    return result;
}
#method_after
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    addReportedIpConfiguration(result);
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    return result;
}
#end_block

#method_before
private void addReportedIpConfiguration(ReportedConfigurations result) {
    if (!isPrimaryAddressExist()) {
        return;
    }
    NetworkBootProtocol definedBootProtocol = networkDataCenterIpConfigurationDefinition.getPrimaryAddress().getBootProtocol();
    result.add(ReportedConfigurationType.BOOT_PROTOCOL, iface.getBootProtocol(), definedBootProtocol);
    if (definedBootProtocol == NetworkBootProtocol.STATIC_IP) {
        result.add(ReportedConfigurationType.NETMASK, iface.getSubnet(), networkDataCenterIpConfigurationDefinition.getPrimaryAddress().getNetmask());
        result.add(ReportedConfigurationType.IP_ADDRESS, iface.getAddress(), networkDataCenterIpConfigurationDefinition.getPrimaryAddress().getAddress());
    }
}
#method_after
private void addReportedIpConfiguration(ReportedConfigurations result) {
    if (!isPrimaryAddressExist()) {
        return;
    }
    NetworkBootProtocol definedBootProtocol = isPrimaryAddressExist() ? getPrimaryAddress().getBootProtocol() : null;
    result.add(ReportedConfigurationType.BOOT_PROTOCOL, iface.getBootProtocol(), definedBootProtocol);
    if (definedBootProtocol == NetworkBootProtocol.STATIC_IP & iface.getBootProtocol() == definedBootProtocol) {
        result.add(ReportedConfigurationType.NETMASK, iface.getSubnet(), isPrimaryAddressExist() ? getPrimaryAddress().getNetmask() : null);
        result.add(ReportedConfigurationType.IP_ADDRESS, iface.getAddress(), isPrimaryAddressExist() ? getPrimaryAddress().getAddress() : null);
    }
}
#end_block

#method_before
public boolean isNetworkInSync() {
    return networkInSync;
}
#method_after
public boolean isNetworkInSync() {
    for (ReportedConfiguration reportedConfig : reportedConfigurationList) {
        if (!reportedConfig.isInSync()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
NetworkInSyncWithVdsNetworkInterface createNetworkInSyncWithVdsNetworkInterface(NetworkAttachment networkAttachment, VdsNetworkInterface nic, Network network) {
    HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
    return new NetworkInSyncWithVdsNetworkInterface(nic, network, hostNetworkQos, networkAttachment.getIpConfiguration());
}
#method_after
NetworkInSyncWithVdsNetworkInterface createNetworkInSyncWithVdsNetworkInterface(NetworkAttachment networkAttachment, VdsNetworkInterface nic, Network network) {
    HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
    return new NetworkInSyncWithVdsNetworkInterface(nic, network, hostNetworkQos, networkAttachment == null ? null : networkAttachment.getIpConfiguration());
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGlusterNw = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGlusterNw = entity.getCluster().isGluster();
    }
    insertHorizontalLine();
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGlusterNw) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGlusterNw) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
    }
    insertHorizontalLine();
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGlusterNw = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGlusterNw = entity.getCluster().isGluster();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGlusterNw) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGlusterNw) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
}
#end_block

#method_before
private String generatePreviewSentence() {
    String outOfSyncPreviewSentence = constants.hostOutOfSyncPreviewSentence();
    outOfSyncPreviewSentence = // $NON-NLS-1$//$NON-NLS-2$
    outOfSyncPreviewSentence.replaceAll("Host", templates.strongTextWithColor("Host", WHITE_TEXT_COLOR).asString());
    outOfSyncPreviewSentence = // $NON-NLS-1$//$NON-NLS-2$
    outOfSyncPreviewSentence.replaceAll("DC", templates.strongTextWithColor("DC", WHITE_TEXT_COLOR).asString());
    final String normalColorText = constants.hostOutOfSyncPreviewSentence().substring(4, constants.hostOutOfSyncPreviewSentence().length() - 3);
    final String output = outOfSyncPreviewSentence.replaceAll(normalColorText, templates.coloredText(normalColorText, TEXT_COLOR).asString());
    return output;
}
#method_after
private String generatePreviewSentence() {
    SafeHtml host = templates.strongTextWithColor(constants.hostForOutOfSyncSentence(), WHITE_TEXT_COLOR);
    SafeHtml dc = templates.strongTextWithColor(constants.dcForOutOfSyncSentence(), WHITE_TEXT_COLOR);
    SafeHtml outOfSyncPreviewSentence = templates.coloredText(constants.hostOutOfSyncPreviewSentence(), TEXT_COLOR);
    return templates.hostOutOfSyncPreviewSentence(host, outOfSyncPreviewSentence, dc).asString();
}
#end_block

#method_before
private List<ReportedConfiguration> filterSyncProperties(LogicalNetworkModel networkModel) {
    ReportedConfigurations reportedConfigurations = networkModel.getReportedConfigurations();
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> output = (List) Linq.where(reportedConfigurationList, new Linq.IPredicate<ReportedConfiguration>() {

        @Override
        public boolean match(ReportedConfiguration reportedConfiguration) {
            return !reportedConfiguration.isInSync();
        }
    });
    return output;
}
#method_after
private List<ReportedConfiguration> filterSyncProperties(LogicalNetworkModel networkModel) {
    ReportedConfigurations reportedConfigurations = networkModel.getReportedConfigurations();
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> output = (List<ReportedConfiguration>) Linq.where(reportedConfigurationList, new Linq.IPredicate<ReportedConfiguration>() {

        @Override
        public boolean match(ReportedConfiguration reportedConfiguration) {
            return !reportedConfiguration.isInSync();
        }
    });
    return output;
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGlusterNw = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGlusterNw = entity.getCluster().isGluster();
    }
    insertHorizontalLine();
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGlusterNw) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
        if (isGlusterNw) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo()));
        }
    }
    insertHorizontalLine();
    // Mtu
    if (!entity.isExternal()) {
        addRow(constants.mtuItemInfo(), entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu()));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGlusterNw = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGlusterNw = entity.getCluster().isGluster();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGlusterNw) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
        if (isGlusterNw) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo()));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        addRow(constants.mtuItemInfo(), entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu()));
    }
}
#end_block

#method_before
private void addSyncDiff(LogicalNetworkModel networkModel) {
    addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.hostOutOfSync()));
    addRow(new SafeHtml() {

        @Override
        public String asString() {
            return generatePreviewSentence();
        }
    });
    List<ReportedConfiguration> panelParameters = createNetworkOutOfSyncPanelParameters(networkModel);
    Widget networkOutOfSyncPanel = new NetworkOutOfSyncPanel(panelParameters).outOfSyncTableAsWidget();
    contents.insertRow(contents.getRowCount());
    contents.setWidget(contents.getRowCount(), 0, networkOutOfSyncPanel);
}
#method_after
private void addSyncDiff(LogicalNetworkModel networkModel) {
    addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.hostOutOfSync()));
    SafeHtml safeHtml = SafeHtmlUtils.fromTrustedString(constants.hostOutOfSyncPreviewSentence());
    addRow(safeHtml);
    List<ReportedConfiguration> panelParameters = filterSyncProperties(networkModel);
    Widget networkOutOfSyncPanel = new NetworkOutOfSyncPanel(panelParameters).outOfSyncTableAsWidget();
    contents.insertRow(contents.getRowCount());
    contents.setWidget(contents.getRowCount(), 0, networkOutOfSyncPanel);
}
#end_block

#method_before
private List<ReportedConfiguration> filterSyncProperties(LogicalNetworkModel networkModel) {
    ReportedConfigurations reportedConfigurations = networkModel.getReportedConfigurations();
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> output = (List) Linq.where(reportedConfigurationList, new Linq.IPredicate<ReportedConfiguration>() {

        @Override
        public boolean match(ReportedConfiguration reportedConfiguration) {
            return !reportedConfiguration.isInSync();
        }
    });
    return output;
}
#method_after
private List<ReportedConfiguration> filterSyncProperties(LogicalNetworkModel networkModel) {
    ReportedConfigurations reportedConfigurations = networkModel.getReportedConfigurations();
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> output = (List<ReportedConfiguration>) Linq.where(reportedConfigurationList, new Linq.IPredicate<ReportedConfiguration>() {

        @Override
        public boolean match(ReportedConfiguration reportedConfiguration) {
            return !reportedConfiguration.isInSync();
        }
    });
    return output;
}
#end_block

#method_before
private void insertHorizontalLine() {
    addRow(new SafeHtml() {

        @Override
        public String asString() {
            // $NON-NLS-1$
            return "<p><hr size=\"2\" width=\"100%\"></p>";
        }
    });
}
#method_after
private void insertHorizontalLine() {
    addRow(templates.horizontalLine());
}
#end_block

#method_before
private void addSyncDiff(LogicalNetworkModel networkModel) {
    addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.hostOutOfSync()));
    addRow(new SafeHtml() {

        @Override
        public String asString() {
            return generatePreviewSentence();
        }
    });
    List<ReportedConfiguration> panelParameters = createNetworkOutOfSyncPanelParameters(networkModel);
    Widget networkOutOfSyncPanel = new NetworkOutOfSyncPanel(panelParameters).outOfSyncTableAsWidget();
    contents.insertRow(contents.getRowCount());
    contents.setWidget(contents.getRowCount(), 0, networkOutOfSyncPanel);
}
#method_after
private void addSyncDiff(LogicalNetworkModel networkModel) {
    addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.hostOutOfSync()));
    SafeHtml safeHtml = SafeHtmlUtils.fromTrustedString(constants.hostOutOfSyncPreviewSentence());
    addRow(safeHtml);
    List<ReportedConfiguration> panelParameters = filterSyncProperties(networkModel);
    Widget networkOutOfSyncPanel = new NetworkOutOfSyncPanel(panelParameters).outOfSyncTableAsWidget();
    contents.insertRow(contents.getRowCount());
    contents.setWidget(contents.getRowCount(), 0, networkOutOfSyncPanel);
}
#end_block

#method_before
private List<ReportedConfiguration> filterSyncProperties(LogicalNetworkModel networkModel) {
    ReportedConfigurations reportedConfigurations = networkModel.getReportedConfigurations();
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> output = (List) Linq.where(reportedConfigurationList, new Linq.IPredicate<ReportedConfiguration>() {

        @Override
        public boolean match(ReportedConfiguration reportedConfiguration) {
            return !reportedConfiguration.isInSync();
        }
    });
    return output;
}
#method_after
private List<ReportedConfiguration> filterSyncProperties(LogicalNetworkModel networkModel) {
    ReportedConfigurations reportedConfigurations = networkModel.getReportedConfigurations();
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> output = (List<ReportedConfiguration>) Linq.where(reportedConfigurationList, new Linq.IPredicate<ReportedConfiguration>() {

        @Override
        public boolean match(ReportedConfiguration reportedConfiguration) {
            return !reportedConfiguration.isInSync();
        }
    });
    return output;
}
#end_block

#method_before
protected void initTooltip() {
    tooltip = new WidgetTooltip(getContents());
    if (this instanceof NetworkPanel) {
        setToolTipMaxWidth(Width.W520);
    }
    tooltip.setPlacement(Placement.BOTTOM);
    String tooltipContent = infoPopup.getTooltipContent(item, this);
    tooltip.setText(tooltipContent);
}
#method_after
protected void initTooltip() {
    tooltip = new WidgetTooltip(getContents());
    tooltip.setPlacement(Placement.BOTTOM);
    String tooltipContent = infoPopup.getTooltipContent(item, this);
    tooltip.setText(tooltipContent);
}
#end_block

#method_before
private Label createLabel(String text, boolean boldText) {
    Label output = new Label(text);
    output.getElement().getStyle().setBackgroundColor(BACKGROUND_COLOR);
    if (boldText) {
        output.getElement().getStyle().setFontWeight(FontWeight.BOLD);
    }
    return output;
}
#method_after
private Label createLabel(String text, boolean boldText) {
    Label output = new Label(text);
    output.getElement().getStyle().setBackgroundColor(BACKGROUND_COLOR);
    if (boldText) {
        output.getElement().getStyle().setFontWeight(FontWeight.BOLD);
    }
    final String textColor = boldText ? WHITE_TEXT_COLOR : TEXT_COLOR;
    output.getElement().getStyle().setColor(textColor);
    // $NON-NLS-1$
    output.getElement().getStyle().setProperty("fontFamily", FONT);
    return output;
}
#end_block

#method_before
private void addTableFirstRow() {
    List<Label> values = new ArrayList<Label>() {

        {
            add(createLabel(constants.PropertyOutOfSyncPopUp(), false));
            add(createLabel(constants.hostOutOfSyncPopUp(), true));
            add(createLabel(constants.dcOutOfSyncPopUp(), true));
        }
    };
    addOutOfSyncRow(values, TextAlign.CENTER);
}
#method_after
private void addTableFirstRow() {
    List<Label> values = new ArrayList<Label>() {

        {
            add(createLabel(constants.PropertyOutOfSyncPopUp(), true));
            add(createLabel(constants.hostOutOfSyncPopUp(), true));
            add(createLabel(constants.dcOutOfSyncPopUp(), true));
        }
    };
    addOutOfSyncRow(values, TextAlign.CENTER);
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getIface() : logicalNetwork.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getNetwork());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getNetwork());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            if (entity.isQosOverridden()) {
                networkDialogModel.getQosModel().init(entity.getQos());
            } else {
                Guid qosId = logicalNetwork.getNetwork().getQosId();
                if (qosId != null) {
                    networkDialogModel.startProgress(null);
                    Frontend.getInstance().runQuery(VdcQueryType.GetQosById, new IdQueryParameters(qosId), new AsyncQuery(new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            networkDialogModel.getQosModel().init((HostNetworkQos) ((VdcQueryReturnValue) returnValue).getReturnValue());
                            networkDialogModel.stopProgress();
                        }
                    }));
                }
            }
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getNetwork().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    boolean qosOverridden = networkDialogModel.getQosOverridden().getEntity();
                    HostNetworkQos qos = null;
                    entity.setQosOverridden(qosOverridden);
                    if (qosOverridden) {
                        qos = new HostNetworkQos();
                        networkDialogModel.getQosModel().flush(qos);
                    }
                    entity.setQos(qos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetwork, entity);
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(nic.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    nic.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, nic, getOverridingHostNetworkQos(displayedQos));
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(LogicalNetworkModel logicalNetwork, VdsNetworkInterface entity) {
    Network updatedNetwork = logicalNetwork.getNetwork();
    Guid updatedNetworkId = updatedNetwork.getId();
    Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = new MapNetworkAttachments(existingNetworkAttachments).byNetworkId();
    Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId();
    NetworkAttachment preexistingNetworkAttachment = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId);
    Guid networkAttachmentId = preexistingNetworkAttachment == null ? null : preexistingNetworkAttachment.getId();
    NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.remove(previousUpdate);
    NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, logicalNetwork.getAttachedToNic().getIface(), logicalNetwork.getVlanNicModel() == null ? null : logicalNetwork.getVlanNicModel().getIface(), networkAttachmentId, hostSetupNetworksParametersData.networksToSync);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.add(updatedNetworkAttachment);
}
#method_after
public void removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(LogicalNetworkModel logicalNetwork, VdsNetworkInterface entity, HostNetworkQos overridingQos) {
    Network updatedNetwork = logicalNetwork.getNetwork();
    Guid updatedNetworkId = updatedNetwork.getId();
    Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = new MapNetworkAttachments(existingNetworkAttachments).byNetworkId();
    Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId();
    NetworkAttachment preexistingNetworkAttachment = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId);
    Guid networkAttachmentId = preexistingNetworkAttachment == null ? null : preexistingNetworkAttachment.getId();
    NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.remove(previousUpdate);
    NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, logicalNetwork.getAttachedToNic().getIface(), logicalNetwork.getVlanNicModel() == null ? null : logicalNetwork.getVlanNicModel().getIface(), networkAttachmentId, hostSetupNetworksParametersData.networksToSync, overridingQos);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.add(updatedNetworkAttachment);
}
#end_block

#method_before
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress(null);
        queryLabels();
    } else {
        initLabelModels();
        initNetworkModels();
        initNicModels();
    }
}
#method_after
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress();
        queryLabels();
    } else {
        initLabelModels();
        initNetworkModels();
        initNicModels();
    }
}
#end_block

#method_before
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<>();
    for (Network network : allNetworks) {
        ReportedConfigurations reportedConfigurations = reportedConfigurationByNetworkId(network.getId());
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, reportedConfigurations, this);
        networkModels.put(network.getName(), networkModel);
        if (networkModel.isManagement()) {
            managementNetworkModel = networkModel;
        }
        if (!network.isExternal()) {
            String label = network.getLabel();
            if (label != null) {
                // The network model is candidate to be drawn as part of the label.
                // This doesn't yet consider whether it actually exists on the interface.
                networkLabelMap.get(label).getNetworks().add(networkModel);
            }
        }
    }
    setNetworks(networkModels);
}
#method_after
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (networkModel.isManagement()) {
            managementNetworkModel = networkModel;
        }
        if (!network.isExternal()) {
            String label = network.getLabel();
            if (label != null) {
                // The network model is candidate to be drawn as part of the label.
                // This doesn't yet consider whether it actually exists on the interface.
                networkLabelMap.get(label).getNetworks().add(networkModel);
            }
        }
    }
    setNetworks(networkModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                NetworkAttachment existingNetworkAttachment = getExistingAttachmentByNetworkId(networkModel.getNetwork().getId());
                netToBeforeSyncParams.put(networkName, createBeforeSyncNetParams(nic, existingNetworkAttachment));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            // initNetworkModels();
            // initDcNetworkParams();
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#method_after
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#end_block

#method_before
public List<String> getNetworksToSync() {
    return networksToSync;
}
#method_after
public Set<String> getNetworksToSync() {
    return networksToSync;
}
#end_block

#method_before
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    if (!hasVlan()) {
        restoreNetworkParameters(targetNic.getIface());
    }
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getIface().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getIface();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new Vlan();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setBaseInterface(targetNic.getName());
        bridge.setVlanId(getVlanId());
        bridge.setMtu(getNetwork().getMtu());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBridged(getNetwork().isVmNetwork());
        restoreNetworkParameters(bridge);
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        targetNicEntity.setMtu(getNetwork().getMtu());
        targetNicEntity.setBridged(getNetwork().isVmNetwork());
        return null;
    }
}
#method_after
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    if (!hasVlan()) {
        restoreNicParameters(targetNic.getIface());
    }
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getIface().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getIface();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new Vlan();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setBaseInterface(targetNic.getName());
        bridge.setVlanId(getVlanId());
        bridge.setMtu(getNetwork().getMtu());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBridged(getNetwork().isVmNetwork());
        restoreNicParameters(bridge);
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        targetNicEntity.setMtu(getNetwork().getMtu());
        targetNicEntity.setBridged(getNetwork().isVmNetwork());
        return null;
    }
}
#end_block

#method_before
public void detach() {
    boolean syncNetworkValues = false;
    if (!isInSync() && isManaged()) {
        getSetupModel().getNetworksToSync().add(getName());
        syncNetworkValues = true;
    }
    assert attachedToNic != null;
    NetworkInterfaceModel attachingNic = attachedToNic;
    // this needs to be null before the NIC items are changed, because they trigger an event
    attachedToNic = null;
    attachedViaLabel = false;
    List<LogicalNetworkModel> nicNetworks = attachingNic.getItems();
    nicNetworks.remove(this);
    // clear network name
    VdsNetworkInterface nicEntity = attachingNic.getIface();
    NetworkParameters netParams = new NetworkParameters();
    VdsNetworkInterface detachedDevice = hasVlan() ? vlanNicModel.getIface() : nicEntity;
    netParams.setBootProtocol(detachedDevice.getBootProtocol());
    netParams.setAddress(detachedDevice.getAddress());
    netParams.setSubnet(detachedDevice.getSubnet());
    netParams.setGateway(detachedDevice.getGateway());
    netParams.setQosOverridden(detachedDevice.isQosOverridden());
    netParams.setQos(detachedDevice.getQos());
    netParams.setCustomProperties(detachedDevice.getCustomProperties());
    getSetupModel().getNetworkToLastDetachParams().put(getName(), netParams);
    if (!hasVlan()) {
        nicEntity.setNetworkName(null);
        nicEntity.setBootProtocol(null);
        nicEntity.setAddress(null);
        nicEntity.setSubnet(null);
        nicEntity.setGateway(null);
        nicEntity.setQosOverridden(false);
        nicEntity.setQos(null);
        nicEntity.setCustomProperties(null);
        nicEntity.setNetworkImplementationDetails(null);
    }
    setVlanNicModel(null);
    // is this a management nic?
    if (nicEntity.getIsManagement()) {
        nicEntity.setType(0);
    }
    if (syncNetworkValues) {
        syncNetworkValues();
    }
}
#method_after
public void detach() {
    boolean syncNetworkValues = false;
    if (!isInSync() && isManaged()) {
        getSetupModel().getNetworksToSync().add(getName());
        syncNetworkValues = true;
    }
    assert attachedToNic != null;
    NetworkInterfaceModel attachingNic = attachedToNic;
    // this needs to be null before the NIC items are changed, because they trigger an event
    attachedToNic = null;
    attachedViaLabel = false;
    List<LogicalNetworkModel> nicNetworks = attachingNic.getItems();
    nicNetworks.remove(this);
    // clear network name
    VdsNetworkInterface nicEntity = attachingNic.getIface();
    storeAttachmentParamsBeforeDetach();
    if (!hasVlan()) {
        nicEntity.setNetworkName(null);
        nicEntity.setBootProtocol(null);
        nicEntity.setAddress(null);
        nicEntity.setSubnet(null);
        nicEntity.setGateway(null);
        nicEntity.setQos(null);
        nicEntity.setCustomProperties(null);
        nicEntity.setNetworkImplementationDetails(null);
    }
    setVlanNicModel(null);
    // is this a management nic?
    if (nicEntity.getIsManagement()) {
        nicEntity.setType(0);
    }
    if (syncNetworkValues) {
        syncNetworkValues();
    }
}
#end_block

#method_before
public boolean isAttached() {
    return reportedConfigurations != null;
}
#method_after
public boolean isAttached() {
    return attachedToNic != null;
}
#end_block

#method_before
public boolean isInSync() {
    ReportedConfigurations reportedConfigurations = getReportedConfigurations();
    return reportedConfigurations != null && reportedConfigurations.isNetworkInSync();
}
#method_after
public boolean isInSync() {
    ReportedConfigurations reportedConfigurations = getReportedConfigurations();
    return reportedConfigurations == null || reportedConfigurations.isNetworkInSync();
}
#end_block

#method_before
public boolean isManaged() {
    return getReportedConfigurations() != null;
}
#method_after
public boolean isManaged() {
    return !(isAttached() && getNetworkAttachment() == null);
}
#end_block

#method_before
public ReportedConfigurations getReportedConfigurations() {
    return reportedConfigurations;
}
#method_after
public ReportedConfigurations getReportedConfigurations() {
    NetworkAttachment networkAttachment = getNetworkAttachment();
    return networkAttachment == null ? null : networkAttachment.getReportedConfigurations();
}
#end_block

#method_before
@Override
protected Widget getContents() {
    Image mgmtNetworkImage;
    Image vmImage;
    Image monitorImage;
    Image migrationImage;
    Image notSyncImage;
    Image alertImage;
    Image glusterNwImage;
    if (!item.isManaged()) {
        monitorImage = null;
        mgmtNetworkImage = null;
        vmImage = null;
        migrationImage = null;
        glusterNwImage = null;
        notSyncImage = null;
        alertImage = null;
    } else {
        monitorImage = item.getNetwork().getCluster().isDisplay() ? new Image(resources.networkMonitor()) : null;
        mgmtNetworkImage = item.isManagement() ? new Image(resources.mgmtNetwork()) : null;
        vmImage = item.getNetwork().isVmNetwork() ? new Image(resources.networkVm()) : null;
        migrationImage = item.getNetwork().getCluster().isMigration() ? new Image(resources.migrationNetwork()) : null;
        glusterNwImage = item.getNetwork().getCluster().isGluster() ? new Image(resources.glusterNetwork()) : null;
        notSyncImage = !item.isInSync() ? new Image(resources.networkNotSyncImage()) : null;
        alertImage = item.getErrorMessage() != null ? new Image(resources.alertImage()) : null;
        if (item.isManagement()) {
            mgmtNetworkImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().isVmNetwork()) {
            vmImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().getCluster().isDisplay()) {
            monitorImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().getCluster().isMigration()) {
            migrationImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().getCluster().isGluster()) {
            glusterNwImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (!item.isInSync()) {
            notSyncImage.setStylePrimaryName(style.networkImageBorder());
        }
    }
    actionButton.setVisible(item.getAttachedToNic() != null && (item.isManaged() || !item.isAttachedViaLabel()));
    Grid rowPanel = new Grid(1, 10);
    rowPanel.setCellSpacing(0);
    // $NON-NLS-1$
    rowPanel.setWidth("100%");
    // $NON-NLS-1$
    rowPanel.setHeight("100%");
    ColumnFormatter columnFormatter = rowPanel.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "5px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "20px");
    // $NON-NLS-1$
    columnFormatter.setWidth(2, "100%");
    rowPanel.setWidget(0, 0, dragImage);
    Panel statusPanel = new HorizontalPanel();
    rowPanel.setWidget(0, 1, statusPanel);
    if (alertImage != null) {
        statusPanel.add(alertImage);
    }
    ImageResource statusImage = getStatusImage();
    if (statusImage != null) {
        statusPanel.add(new Image(statusImage));
    }
    rowPanel.setWidget(0, 2, notSyncImage);
    rowPanel.setWidget(0, 3, createTitlePanel());
    rowPanel.setWidget(0, 4, mgmtNetworkImage);
    rowPanel.setWidget(0, 5, monitorImage);
    rowPanel.setWidget(0, 6, vmImage);
    rowPanel.setWidget(0, 7, migrationImage);
    rowPanel.setWidget(0, 8, glusterNwImage);
    rowPanel.setWidget(0, 9, actionButton);
    return rowPanel;
}
#method_after
@Override
protected Widget getContents() {
    Image mgmtNetworkImage;
    Image vmImage;
    Image monitorImage;
    Image migrationImage;
    Image notSyncImage;
    Image alertImage;
    Image glusterNwImage;
    if (!item.isManaged()) {
        monitorImage = null;
        mgmtNetworkImage = null;
        vmImage = null;
        migrationImage = null;
        glusterNwImage = null;
        notSyncImage = null;
        alertImage = null;
    } else {
        monitorImage = item.getNetwork().getCluster().isDisplay() ? new Image(resources.networkMonitor()) : null;
        mgmtNetworkImage = item.isManagement() ? new Image(resources.mgmtNetwork()) : null;
        vmImage = item.getNetwork().isVmNetwork() ? new Image(resources.networkVm()) : null;
        migrationImage = item.getNetwork().getCluster().isMigration() ? new Image(resources.migrationNetwork()) : null;
        glusterNwImage = item.getNetwork().getCluster().isGluster() ? new Image(resources.glusterNetwork()) : null;
        notSyncImage = !item.isInSync() ? new Image(resources.networkNotSyncImage()) : null;
        alertImage = item.getErrorMessage() != null ? new Image(resources.alertImage()) : null;
        if (item.isManagement()) {
            mgmtNetworkImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().isVmNetwork()) {
            vmImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().getCluster().isDisplay()) {
            monitorImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().getCluster().isMigration()) {
            migrationImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (item.getNetwork().getCluster().isGluster()) {
            glusterNwImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (!item.isInSync()) {
            notSyncImage.setStylePrimaryName(style.networkImageBorder());
        }
    }
    actionButton.setVisible(item.getAttachedToNic() != null && (item.isManaged() || !item.isAttachedViaLabel()));
    Grid rowPanel = new Grid(1, 10);
    rowPanel.setCellSpacing(0);
    // $NON-NLS-1$
    rowPanel.setWidth("100%");
    // $NON-NLS-1$
    rowPanel.setHeight("100%");
    ColumnFormatter columnFormatter = rowPanel.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "5px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "20px");
    // $NON-NLS-1$
    columnFormatter.setWidth(2, "100%");
    rowPanel.setWidget(0, 0, dragImage);
    Panel statusPanel = new HorizontalPanel();
    statusPanel.setStylePrimaryName(style.networkStatusPanel());
    rowPanel.setWidget(0, 1, statusPanel);
    if (alertImage != null) {
        statusPanel.add(alertImage);
    }
    ImageResource statusImage = getStatusImage();
    if (statusImage != null) {
        statusPanel.add(new Image(statusImage));
    }
    if (notSyncImage != null) {
        statusPanel.add(notSyncImage);
    }
    rowPanel.setWidget(0, 2, createTitlePanel());
    rowPanel.setWidget(0, 3, mgmtNetworkImage);
    rowPanel.setWidget(0, 4, monitorImage);
    rowPanel.setWidget(0, 5, vmImage);
    rowPanel.setWidget(0, 6, migrationImage);
    rowPanel.setWidget(0, 7, glusterNwImage);
    rowPanel.setWidget(0, 8, actionButton);
    return rowPanel;
}
#end_block

#method_before
public ValidationResult isLunDiskVisible(final LUNs lun, VDS vds) {
    List<LUNs> luns = executeGetDeviceList(vds.getId(), lun.getLunType(), lun.getLUN_id());
    // Search LUN in the device list
    boolean lunExists = CollectionUtils.exists(luns, new Predicate() {

        @Override
        public boolean evaluate(Object o) {
            return ((LUNs) o).getId().equals(lun.getId());
        }
    });
    return lunExists ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
}
#method_after
public ValidationResult isLunDiskVisible(final LUNs lun, VDS vds) {
    List<LUNs> luns = executeGetDeviceList(vds.getId(), lun.getLunType(), lun.getLUN_id());
    // TODO Once we stop supporting 3.5 DCs and earlier, we can replace the below by "return !luns.isempty()"
    // Search LUN in the device list
    boolean lunExists = CollectionUtils.exists(luns, new Predicate() {

        @Override
        public boolean evaluate(Object o) {
            return ((LUNs) o).getId().equals(lun.getId());
        }
    });
    return lunExists ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
}
#end_block

#method_before
protected List<LUNs> getDeviceList() {
    List<LUNs> luns = new ArrayList<>();
    VdcQueryReturnValue returnValue = executeGetDeviceList(new GetDeviceListQueryParameters(getParameters().getVdsId(), getParameters().getStorageType(), false));
    if (returnValue.getSucceeded()) {
        luns.addAll(returnValue.<List<LUNs>>getReturnValue());
    } else {
        throw new RuntimeException(String.format("GetDeviceList execution failed. Exception message: %1$s", returnValue.getExceptionString()));
    }
    return luns;
}
#method_after
protected List<LUNs> getDeviceList() {
    List<LUNs> luns = new ArrayList<>();
    VdcQueryReturnValue returnValue = executeGetDeviceList(new GetDeviceListQueryParameters(getParameters().getVdsId(), getParameters().getStorageType(), false, null));
    if (returnValue.getSucceeded()) {
        luns.addAll(returnValue.<List<LUNs>>getReturnValue());
    } else {
        throw new RuntimeException(String.format("GetDeviceList execution failed. Exception message: %1$s", returnValue.getExceptionString()));
    }
    return luns;
}
#end_block

#method_before
public static boolean getDeviceListWithoutStatusSupported(Version version) {
    return supportedInConfig(ConfigValues.NetworkExclusivenessPermissiveValidation, version);
}
#method_after
public static boolean getDeviceListWithoutStatusSupported(Version version) {
    return supportedInConfig(ConfigValues.GetDeviceListWithoutStatusSupported, version);
}
#end_block

#method_before
private boolean isCheckStatusSupported() {
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getVdsId());
    return FeatureSupported.getDeviceListWithoutStatusSupported(vds.getVdsGroupCompatibilityVersion());
}
#method_after
private boolean isCheckStatusSupported() {
    return FeatureSupported.getDeviceListWithoutStatusSupported(getVds().getVdsGroupCompatibilityVersion());
}
#end_block

#method_before
public void saveNewSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    List<String> unkownStatusLuns = new ArrayList();
    List<LUNs> usedStatusLuns = new ArrayList();
    for (LunModel lunModel : sanStorageModel.getAddedLuns()) {
        if (lunModel.getStatus() == LunStatus.Used) {
            usedStatusLuns.add((LUNs) lunModel.getEntity());
        } else if (lunModel.getStatus() == LunStatus.Unknown) {
            unkownStatusLuns.add(lunModel.getLunId());
        }
    }
    if (!unkownStatusLuns.isEmpty()) {
        Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
        Object target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
        Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getSucceeded()) {
                    List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                    postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
                } else {
                    sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
                }
            }
        }, true));
    } else {
        postGetLunsMessages(sanStorageModel.getUsedLunsMessages(usedStatusLuns));
    }
}
#method_after
public void saveNewSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Map<LunStatus, List<LUNs>> lunsMapByStatus = sanStorageModel.getLunsMapByStatus(sanStorageModel.getAddedLuns());
    if (!lunsMapByStatus.get(LunStatus.Unknown).isEmpty()) {
        Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
        Model target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
        List<String> unkownStatusLuns = new ArrayList<>();
        for (LUNs lun : lunsMapByStatus.get(LunStatus.Unknown)) {
            unkownStatusLuns.add(lun.getLUN_id());
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getSucceeded()) {
                    List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                    postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
                } else {
                    sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
                }
            }
        }, true));
    } else {
        postGetLunsMessages(sanStorageModel.getUsedLunsMessages(lunsMapByStatus.get(LunStatus.Used)));
    }
}
#end_block

#method_before
protected List<LUNs> getLogicalUnits() {
    return getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(asGuid(hostId), StorageType.UNKNOWN, true));
}
#method_after
protected List<LUNs> getLogicalUnits() {
    // populated as before. We should deprecate in the future or add an option to pass false
    return getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(asGuid(hostId), StorageType.UNKNOWN, true, null));
}
#end_block

#method_before
private List<LUNs> getDeviceList(Guid hostId, StorageType storageType) {
    return getEntity(List.class, VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, storageType, false), "GetDeviceList", true);
}
#method_after
private List<LUNs> getDeviceList(Guid hostId, StorageType storageType) {
    return getEntity(List.class, VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, storageType, false, null), "GetDeviceList", true);
}
#end_block

#method_before
private void refreshHostStorage(Guid hostId) {
    getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, StorageType.ISCSI, Boolean.FALSE));
}
#method_after
private void refreshHostStorage(Guid hostId) {
    getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, StorageType.ISCSI, false, null));
}
#end_block

#method_before
@Override
protected void updateInternal() {
    super.updateInternal();
    if (!(getContainer().isNewStorage() || getContainer().isStorageActive())) {
        return;
    }
    VDS host = (VDS) getContainer().getHost().getSelectedItem();
    if (host == null) {
        proposeDiscover();
        return;
    }
    final Collection<EntityModel<?>> prevSelected = Linq.findSelectedItems((Collection<EntityModel<?>>) getSelectedItem());
    clearItems();
    initializeItems(null, null);
    final SanStorageModel model = this;
    Object target = getWidgetModel() != null ? getWidgetModel() : getContainer();
    AsyncQuery asyncQuery = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response.getSucceeded()) {
                model.applyData((ArrayList<LUNs>) response.getReturnValue(), false, prevSelected);
                // $NON-NLS-1$
                model.setGetLUNsFailure("");
            } else {
                model.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
            }
        }
    }, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(host.getId(), getType(), false), asyncQuery);
}
#method_after
@Override
protected void updateInternal() {
    super.updateInternal();
    if (!(getContainer().isNewStorage() || getContainer().isStorageActive())) {
        return;
    }
    VDS host = (VDS) getContainer().getHost().getSelectedItem();
    if (host == null) {
        proposeDiscover();
        return;
    }
    final Collection<EntityModel<?>> prevSelected = Linq.findSelectedItems((Collection<EntityModel<?>>) getSelectedItem());
    clearItems();
    initializeItems(null, null);
    final SanStorageModel model = this;
    Object target = getWidgetModel() != null ? getWidgetModel() : getContainer();
    AsyncQuery asyncQuery = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response.getSucceeded()) {
                model.applyData((ArrayList<LUNs>) response.getReturnValue(), false, prevSelected);
                // $NON-NLS-1$
                model.setGetLUNsFailure("");
            } else {
                model.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
            }
        }
    }, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(host.getId(), getType(), false, null), asyncQuery);
}
#end_block

#method_before
public ArrayList<String> getUsedLunsMessages(List<LUNs> luns) {
    ArrayList<String> usedLunsMessages = new ArrayList<String>();
    UIMessages messages = ConstantsManager.getInstance().getMessages();
    for (LUNs lun : luns) {
        if (lun.getStatus() == LunStatus.Used) {
            String reason = null;
            if (lun.getvolume_group_id() != null && !lun.getvolume_group_id().isEmpty()) {
                reason = messages.lunUsedByVG(lun.getvolume_group_id());
            }
            usedLunsMessages.add(reason == null ? lun.getLUN_id() : // $NON-NLS-1$ //$NON-NLS-2$
            lun.getLUN_id() + " (" + reason + ")");
        }
    }
    return usedLunsMessages;
}
#method_after
public ArrayList<String> getUsedLunsMessages(List<LUNs> luns) {
    ArrayList<String> usedLunsMessages = new ArrayList<String>();
    UIMessages messages = ConstantsManager.getInstance().getMessages();
    for (LUNs lun : luns) {
        if (lun.getStatus() == LunStatus.Used) {
            String reason = null;
            if (lun.getvolume_group_id() != null && !lun.getvolume_group_id().isEmpty()) {
                reason = messages.lunUsedByVG(lun.getvolume_group_id());
            }
            usedLunsMessages.add(reason == null ? lun.getLUN_id() : messages.usedLunIdReason(lun.getLUN_id(), reason));
        }
    }
    return usedLunsMessages;
}
#end_block

#method_before
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    List<String> unkownStatusLuns = new ArrayList();
    List<LUNs> usedStatusLuns = new ArrayList();
    for (LunModel lunModel : sanStorageModel.getAddedLuns()) {
        if (lunModel.getStatus() == LunStatus.Used) {
            usedStatusLuns.add((LUNs) lunModel.getEntity());
        } else if (lunModel.getStatus() == LunStatus.Unknown) {
            unkownStatusLuns.add(lunModel.getLunId());
        }
    }
    if (!unkownStatusLuns.isEmpty()) {
        Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
        Object target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
        Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getSucceeded()) {
                    List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                    postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
                } else {
                    sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
                }
            }
        }, true));
    } else {
        postGetLunsMessages(sanStorageModel.getUsedLunsMessages(usedStatusLuns));
    }
}
#method_after
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Map<LunStatus, List<LUNs>> lunsMapByStatus = sanStorageModel.getLunsMapByStatus(sanStorageModel.getAddedLuns());
    if (!lunsMapByStatus.get(LunStatus.Unknown).isEmpty()) {
        Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
        Model target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
        List<String> unkownStatusLuns = new ArrayList<>();
        for (LUNs lun : lunsMapByStatus.get(LunStatus.Unknown)) {
            unkownStatusLuns.add(lun.getLUN_id());
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getSucceeded()) {
                    List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                    postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
                } else {
                    sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
                }
            }
        }, true));
    } else {
        postGetLunsMessages(sanStorageModel.getUsedLunsMessages(lunsMapByStatus.get(LunStatus.Used)));
    }
}
#end_block

#method_before
@Override
public VDSReturnValue get(long timeout, TimeUnit unit) throws TimeoutException {
    try {
        status = new StatusOnlyReturnForXmlRpc(httpTask.get(timeout, unit));
        proceedProxyReturnValue();
    } catch (TimeoutException e) {
        httpTask.cancel(true);
        VDSNetworkException ex = new VDSNetworkException("Timeout during xml-rpc call");
        ex.setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, "Timeout during xml-rpc call"));
        setVdsRuntimeError(ex);
        log.error("Timeout waiting for VDSM response: {}", e.getMessage());
        log.debug("Exception", e);
        throw e;
    } catch (VDSNetworkException e) {
        setVdsRuntimeError(e);
        if (!"Policy reset".equals(e.getVdsError().getMessage())) {
            log.error("Error: {}", e.getMessage());
            log.error("Exception", e);
        } else {
            log.info("Policy reset required for network reconfiguration");
        }
    } catch (Exception e) {
        log.error("Error: {}", e.getMessage());
        log.error("Exception", e);
        setVdsRuntimeError(e instanceof RuntimeException ? (RuntimeException) e : new RuntimeException(e));
    }
    return getVDSReturnValue();
}
#method_after
@Override
public VDSReturnValue get(long timeout, TimeUnit unit) throws TimeoutException {
    try {
        status = new StatusOnlyReturnForXmlRpc(httpTask.get(timeout, unit));
        proceedProxyReturnValue();
    } catch (TimeoutException e) {
        httpTask.cancel(true);
        VDSNetworkException ex = new VDSNetworkException("Timeout during xml-rpc call");
        ex.setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, "Timeout during xml-rpc call"));
        setVdsRuntimeError(ex);
        log.error("Timeout waiting for VDSM response: {}", e.getMessage());
        log.debug("Exception", e);
        throw e;
    } catch (VDSNetworkException e) {
        setVdsRuntimeError(e);
        if (isPolicyResetMessage(e.getVdsError().getMessage())) {
            log.info("Policy reset required for network reconfiguration");
        } else {
            log.error("Error: {}", e.getMessage());
            log.error("Exception", e);
        }
    } catch (Exception e) {
        log.error("Error: {}", e.getMessage());
        log.error("Exception", e);
        setVdsRuntimeError(e instanceof RuntimeException ? (RuntimeException) e : new RuntimeException(e));
    }
    return getVDSReturnValue();
}
#end_block

#method_before
@Override
protected void logToAudit() {
    if ("Policy reset".equals(getReturnStatus().message)) {
        return;
    }
    AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId());
    auditLogableBase.setVds(vds);
    auditLogableBase.addCustomValue("message", getReturnStatus().message);
    auditLogDirector.log(auditLogableBase, AuditLogType.VDS_BROKER_COMMAND_FAILURE);
}
#method_after
@Override
protected void logToAudit() {
    if (isPolicyResetMessage(getReturnStatus().message)) {
        return;
    }
    AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId());
    auditLogableBase.setVds(vds);
    auditLogableBase.addCustomValue("message", getReturnStatus().message);
    auditLogDirector.log(auditLogableBase, AuditLogType.VDS_BROKER_COMMAND_FAILURE);
}
#end_block

#method_before
private void prepareVmDao(VM... vmList) {
    List<VM> vms = Arrays.asList(vmList);
    when(vmDao.getVmsByIds(anyList())).thenReturn(vms);
    for (VM vm : vms) {
        when(vmDao.get(eq(vm.getId()))).thenReturn(vm);
    }
}
#method_after
private void prepareVmDao(VM... vmList) {
    final List<VM> vms = Arrays.asList(vmList);
    doAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            final List<VM> selectedVms = new ArrayList<>();
            final Set<Guid> vmIds = new HashSet<>((List<Guid>) invocation.getArguments()[0]);
            for (VM vm : vms) {
                if (vmIds.contains(vm.getId())) {
                    selectedVms.add(vm);
                }
            }
            return selectedVms;
        }
    }).when(vmDao).getVmsByIds(anyList());
    for (VM vm : vmList) {
        when(vmDao.get(eq(vm.getId()))).thenReturn(vm);
    }
}
#end_block

#method_before
public static boolean isPublicKeyValid(String publicKey) {
    int i;
    i = publicKey.indexOf("\n");
    if (i != -1 && i != publicKey.length() - 1) {
        return false;
    }
    /*
         * An OpenSSH public key consists of:
         * [mandatory] The key type
         * [mandatory] A chunk of PEM-encoded data (PEM is a specific type of Base64 encoding)
         * [optional] A comment
         */
    String[] words = publicKey.split("\\s+", 3);
    if (words.length < 2) {
        return false;
    }
    /*
         * As per http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html
         * these character class are US-ASCII only.
         */
    if (!words[0].matches("^[\\p{Alpha}\\p{Digit}-]*$")) {
        return false;
    }
    if (!isBase64(words[1].getBytes(Charset.forName("UTF-8")))) {
        return false;
    }
    return true;
}
#method_after
public static boolean isPublicKeyValid(String publicKey) {
    int i = publicKey.indexOf("\n");
    if (i != -1 && i != publicKey.length() - 1) {
        return false;
    }
    /*
         * An OpenSSH public key consists of:
         * [mandatory] The key type
         * [mandatory] A chunk of PEM-encoded data (PEM is a specific type of Base64 encoding)
         * [optional] A comment
         */
    String[] words = publicKey.split("\\s+", 3);
    if (words.length < 2) {
        return false;
    }
    /*
         * As per http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html
         * these character class are US-ASCII only.
         */
    if (!words[0].matches("^[\\p{Alpha}\\p{Digit}-]*$")) {
        return false;
    }
    if (!isBase64(words[1].getBytes(Charset.forName("UTF-8")))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testMutliKeys() throws Exception {
    assertTrue(OpenSSHUtils.isPublicKeysValid(EXTRA_SSH_KEYS[0] + "\n" + EXTRA_SSH_KEYS[1] + "\n"));
    assertTrue(OpenSSHUtils.isPublicKeysValid(EXTRA_SSH_KEYS[0] + "\n" + EXTRA_SSH_KEYS[1]));
    assertTrue(OpenSSHUtils.isPublicKeysValid(EXTRA_SSH_KEYS[0] + "\n"));
    assertTrue(OpenSSHUtils.isPublicKeysValid(EXTRA_SSH_KEYS[0]));
}
#method_after
@Test
public void testMutliKeys() throws Exception {
    assertTrue(OpenSSHUtils.arePublicKeysValid(EXTRA_SSH_KEYS[0] + "\n" + EXTRA_SSH_KEYS[1] + "\n"));
    assertTrue(OpenSSHUtils.arePublicKeysValid(EXTRA_SSH_KEYS[0] + "\n" + EXTRA_SSH_KEYS[1]));
    assertTrue(OpenSSHUtils.arePublicKeysValid(EXTRA_SSH_KEYS[0] + "\n"));
    assertTrue(OpenSSHUtils.arePublicKeysValid(EXTRA_SSH_KEYS[0]));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid userId = getParameters().getUserProfile().getUserId();
    if (Guid.isNullOrEmpty(userId)) {
        // null/Empty GUID == current user. Fix parameters for later use (e.g. subclasses).
        userId = getUserId();
        getParameters().getUserProfile().setUserId(userId);
    } else if (!userId.equals(getUserId())) {
        return failCanDoAction(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
    }
    String sshPublicKey = getParameters().getUserProfile().getSshPublicKey();
    if (sshPublicKey == null || sshPublicKey.isEmpty()) {
        // the user wants to wipe out its own key, and we're fine with that.
        return true;
    }
    // else it is either a new or replacement key. In both cases, must be a valid key.
    if (!OpenSSHUtils.isPublicKeysValid(sshPublicKey)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_KEY);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid userId = getParameters().getUserProfile().getUserId();
    if (Guid.isNullOrEmpty(userId)) {
        // null/Empty GUID == current user. Fix parameters for later use (e.g. subclasses).
        userId = getUserId();
        getParameters().getUserProfile().setUserId(userId);
    } else if (!userId.equals(getUserId())) {
        return failCanDoAction(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
    }
    String sshPublicKey = getParameters().getUserProfile().getSshPublicKey();
    if (sshPublicKey == null || sshPublicKey.isEmpty()) {
        // the user wants to wipe out its own key, and we're fine with that.
        return true;
    }
    // else it is either a new or replacement key. In both cases, must be a valid key.
    if (!OpenSSHUtils.arePublicKeysValid(sshPublicKey)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_KEY);
    }
    return true;
}
#end_block

#method_before
public ValidationResult isMacAssignableValidator() {
    Boolean allowDupMacs = macPool.isDuplicateMacAddressesAllowed();
    boolean macIsAlreadyUsed = macPool.isMacInUse(macAddress);
    boolean illegalDuplicateMacUsage = macIsAlreadyUsed && !allowDupMacs;
    return ValidationResult.failWith(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE).when(illegalDuplicateMacUsage);
}
#method_after
public ValidationResult isMacAssignableValidator() {
    Boolean allowDupMacs = macPool.isDuplicateMacAddressesAllowed();
    boolean macIsAlreadyUsed = macPool.isMacInUse(macAddress);
    boolean illegalDuplicateMacUsage = macIsAlreadyUsed && !allowDupMacs;
    return ValidationResult.failWith(EngineMessage.NETWORK_MAC_ADDRESS_IN_USE).when(illegalDuplicateMacUsage);
}
#end_block

#method_before
private static void updateSmartcardDevice(VM oldVm, VmBase newVm) {
    if (newVm.isSmartcardEnabled() == oldVm.isSmartcardEnabled()) {
        // the smartcard device did not changed, do nothing
        return;
    }
    updateSmartcardDevice(newVm.getId(), newVm.isSmartcardEnabled());
}
#method_after
/*
     * Smartcard device
     */
private static void updateSmartcardDevice(VM oldVm, VmBase newVm) {
    if (newVm.isSmartcardEnabled() == oldVm.isSmartcardEnabled()) {
        return;
    }
    updateSmartcardDevice(newVm.getId(), newVm.isSmartcardEnabled());
}
#end_block

#method_before
public static void updateSmartcardDevice(Guid vmId, boolean smartcardEnabled) {
    List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD.getName());
    if (!smartcardEnabled) {
        for (VmDevice device : vmDevices) {
            dao.remove(device.getId());
        }
    } else if (vmDevices.isEmpty()) {
        addSmartcardDevice(vmId);
    }
}
#method_after
public static void updateSmartcardDevice(Guid vmId, boolean smartcardEnabled) {
    if (smartcardEnabled) {
        if (!hasSmartcardDevice(vmId)) {
            addSmartcardDevice(vmId);
        }
    } else {
        removeSmartcardDevices(vmId);
    }
}
#end_block

#method_before
public static void addSmartcardDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD, new SmartcardSpecParams(), true, false, null);
}
#method_after
public static VmDevice addSmartcardDevice(Guid vmId) {
    return addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD, getSmartcardDeviceSpecParams(), true, false);
}
#end_block

#method_before
public static void updateConsoleDevice(Guid vmId, Boolean consoleEnabled) {
    if (consoleEnabled == null) {
        // we don't want to update the device
        return;
    }
    List<VmDevice> consoles = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE.getName());
    if (consoleEnabled) {
        if (consoles.isEmpty()) {
            addConsoleDevice(vmId);
        }
    } else {
        for (VmDevice device : consoles) {
            dao.remove(device.getId());
        }
    }
}
#method_after
/*
     * Console device
     */
public static void updateConsoleDevice(Guid vmId, Boolean consoleEnabled) {
    if (consoleEnabled == null) {
        // we don't want to update the device
        return;
    }
    if (consoleEnabled) {
        if (!hasConsoleDevice(vmId)) {
            addConsoleDevice(vmId);
        }
    } else {
        removeConsoleDevices(vmId);
    }
}
#end_block

#method_before
private static void addConsoleDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE, new HashMap<String, Object>(), true, false, null);
}
#method_after
public static VmDevice addConsoleDevice(Guid vmId) {
    return addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE, getConsoleDeviceSpecParams(), true, false);
}
#end_block

#method_before
public static void updateVirtioScsiController(Guid vmId, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    List<VmDevice> controllers = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    if (isVirtioScsiEnabled) {
        if (controllers.isEmpty()) {
            addVirtioScsiController(vmId);
        }
    } else {
        for (VmDevice device : controllers) {
            dao.remove(device.getId());
        }
    }
}
#method_after
/*
     * VirtIO-SCSI controller
     */
public static void updateVirtioScsiController(Guid vmId, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    if (isVirtioScsiEnabled) {
        if (!hasVirtioScsiController(vmId)) {
            addVirtioScsiController(vmId);
        }
    } else {
        removeVirtioScsiControllers(vmId);
    }
}
#end_block

#method_before
private static void addVirtioScsiController(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, new HashMap<String, Object>(), true, false, null);
}
#method_after
public static VmDevice addVirtioScsiController(Guid vmId) {
    return addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, EMPTY_SPEC_PARAMS, true, false);
}
#end_block

#method_before
public static List<VmDevice> getSoundDevices(Guid vmId) {
    return dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
}
#method_after
public static List<VmDevice> getSoundDevices(Guid vmId) {
    return dao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
}
#end_block

#method_before
/**
 * If another plugged network interface has the same MAC address, return false, otherwise returns true
 *
 * @param iface
 *            the network interface to check if can be plugged
 */
private static boolean canPlugInterface(VmNic iface) {
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.existsPluggedInterfaceWithSameMac(iface)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#method_after
private static boolean canPlugInterface(VmNic iface, Guid vdsGroupId) {
    VDSGroup vdsGroup = dbFacade.getVdsGroupDao().get(vdsGroupId);
    Guid dataCenterId = vdsGroup == null ? null : vdsGroup.getStoragePoolId();
    boolean canPlugInterface = canPlugInterfaceInDc(iface, dataCenterId);
    if (!canPlugInterface) {
        new VmInterfaceManager().auditLogMacInUseUnplug(iface);
    }
    return canPlugInterface;
}
#end_block

#method_before
private static void addUsbControllers(VmBase vm, int numOfControllers) {
    // For each controller we need to create one EHCI and companion UHCI controllers
    for (int index = 0; index < numOfControllers; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false, null);
        for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false, null);
        }
    }
}
#method_after
/*
     * USB controller
     */
public static void addUsbControllers(Guid vmId, int numberOfControllers) {
    // For each controller we need to create one EHCI and companion UHCI controllers
    for (int index = 0; index < numberOfControllers; index++) {
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false);
        for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
            addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false);
        }
    }
}
#end_block

#method_before
private static Map<String, Object> getUsbControllerSpecParams(String model, int controllerNumber, int index) {
    Map<String, Object> specParams = new HashMap<String, Object>();
    specParams.put(VdsProperties.Model, model + controllerNumber);
    specParams.put(VdsProperties.Index, Integer.toString(index));
    return specParams;
}
#method_after
private static Map<String, Object> getUsbControllerSpecParams(String model, int controllerNumber, int index) {
    Map<String, Object> specParams = new HashMap<>();
    specParams.put(VdsProperties.Model, model + controllerNumber);
    specParams.put(VdsProperties.Index, Integer.toString(index));
    return specParams;
}
#end_block

#method_before
private static void removeUsbControllers(VmBase vm) {
    List<VmDevice> list = dao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : list) {
        dao.remove(vmDevice.getId());
    }
}
#method_after
public static void removeUsbControllers(Guid vmId) {
    removeVmDevices(getUsbControllers(vmId));
}
#end_block

#method_before
private static int getNeededNumberOfUsbControllers(int numberOfSlots) {
    int numOfcontrollers = numberOfSlots / SLOTS_PER_CONTROLLER;
    // Need to add another controller in case mod result is not 0
    if (numberOfSlots % SLOTS_PER_CONTROLLER != 0) {
        numOfcontrollers++;
    }
    return numOfcontrollers;
}
#method_after
private static int getNeededNumberOfUsbControllers(int numberOfSlots) {
    int numberOfControllers = numberOfSlots / SLOTS_PER_CONTROLLER;
    // Need to add another controller if we have a remainder
    if (numberOfSlots % SLOTS_PER_CONTROLLER != 0) {
        numberOfControllers++;
    }
    return numberOfControllers;
}
#end_block

#method_before
private static void addUsbSlots(VmBase vm, int numOfSlots) {
    for (int index = 1; index <= numOfSlots; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC, getUsbSlotSpecParams(), true, false, null);
    }
}
#method_after
public static void addUsbSlots(Guid vmId, int numberOfSlots) {
    for (int index = 1; index <= numberOfSlots; index++) {
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC, EMPTY_SPEC_PARAMS, true, false);
    }
}
#end_block

#method_before
private static void removeUsbSlots(VmBase vm, int numberOfSlotsToRemove) {
    List<VmDevice> list = getUsbRedirectDevices(vm);
    removeNumberOfDevices(list, numberOfSlotsToRemove);
}
#method_after
public static void removeUsbSlots(Guid vmId) {
    removeVmDevices(getUsbSlots(vmId));
}
#end_block

#method_before
public static void updateMemoryBalloon(Guid id, boolean shouldHaveBalloon) {
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<String, Object>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.newGuid(), id), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true, null);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(id, VmDeviceGeneralType.BALLOON);
            removeNumberOfDevices(list, 1);
        }
    }
}
#method_after
/*
     * Memory balloon device
     */
public static void updateMemoryBalloon(Guid vmId, Boolean isBalloonEnabled) {
    if (isBalloonEnabled == null) {
        // we don't want to update the device
        return;
    }
    if (isBalloonEnabled) {
        if (!hasMemoryBalloon(vmId)) {
            addMemoryBalloon(vmId);
        }
    } else {
        removeMemoryBalloons(vmId);
    }
}
#end_block

#method_before
public static List<GraphicsType> getGraphicsTypesOfEntity(Guid entityId) {
    List<GraphicsType> result = new ArrayList<>();
    if (entityId != null) {
        List<VmDevice> devices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(entityId, VmDeviceGeneralType.GRAPHICS);
        if (devices != null) {
            for (VmDevice device : devices) {
                result.add(GraphicsType.fromString(device.getDevice()));
            }
        }
    }
    return result;
}
#method_after
/*
     * Graphics device
     */
public static List<GraphicsType> getGraphicsTypesOfEntity(Guid entityId) {
    List<GraphicsType> result = new ArrayList<>();
    if (entityId != null) {
        List<VmDevice> devices = getGraphicsDevices(entityId);
        if (devices != null) {
            for (VmDevice device : devices) {
                result.add(GraphicsType.fromString(device.getDevice()));
            }
        }
    }
    return result;
}
#end_block

#method_before
public static List<VmDevice> getWatchdogs(Guid vmId) {
    return dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.WATCHDOG);
}
#method_after
/*
     * Watchdog
     */
public static List<VmDevice> getWatchdogs(Guid vmId) {
    return dao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.WATCHDOG);
}
#end_block

#method_before
public static void copyDiskDevices(Guid dstId, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    for (VmDevice device : devicesDataToUse) {
        if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                Guid id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                device.setId(new VmDeviceId(id, dstId));
                device.setSpecParams(new HashMap<String, Object>());
                dao.save(device);
            }
        }
    }
}
#method_after
/*
     * Disk device
     */
public static void copyDiskDevices(Guid dstId, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping) {
    for (VmDevice device : srcDevices) {
        if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                Guid dstDeviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                device.setId(new VmDeviceId(dstDeviceId, dstId));
                device.setSpecParams(EMPTY_SPEC_PARAMS);
                dao.save(device);
            }
        }
    }
}
#end_block

#method_before
protected static Set<BaseDisk> getDisks(Collection<DiskImage> diskImages) {
    Map<Guid, BaseDisk> diskMap = new HashMap<Guid, BaseDisk>();
    for (Disk diskImage : diskImages) {
        diskMap.put(diskImage.getId(), diskImage);
    }
    return new HashSet<BaseDisk>(diskMap.values());
}
#method_after
public static Set<BaseDisk> getDisks(Collection<DiskImage> diskImages) {
    Map<Guid, BaseDisk> diskMap = new HashMap<>();
    for (Disk diskImage : diskImages) {
        diskMap.put(diskImage.getId(), diskImage);
    }
    return new HashSet<>(diskMap.values());
}
#end_block

#method_before
public static void setVmDevices(VmBase vmBase) {
    Map<Guid, VmDevice> vmManagedDeviceMap = new HashMap<Guid, VmDevice>();
    List<VmDevice> devices = dbFacade.getVmDeviceDao().getVmDeviceByVmId(vmBase.getId());
    vmBase.setUnmanagedDeviceList(dbFacade.getVmDeviceDao().getUnmanagedDevicesByVmId(vmBase.getId()));
    for (VmDevice device : devices) {
        if (device.getIsManaged()) {
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vmBase.setManagedDeviceMap(vmManagedDeviceMap);
}
#method_after
public static void setVmDevices(VmBase vmBase) {
    List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
    vmBase.setUnmanagedDeviceList(dao.getUnmanagedDevicesByVmId(vmBase.getId()));
    Map<Guid, VmDevice> vmManagedDeviceMap = new HashMap<>();
    for (VmDevice device : devices) {
        if (device.getIsManaged()) {
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vmBase.setManagedDeviceMap(vmManagedDeviceMap);
}
#end_block

#method_before
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(entity, isBalloonEnabled(params));
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
        updateVirtioScsiController(entity.getId(), params.isVirtioScsiEnabled());
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase newVmBase = params.getVmStaticData();
    if (newVmBase == null) {
        return;
    }
    updateCdPath(oldVmBase, newVmBase);
    updateBootOrder(oldVmBase, newVmBase);
    updateVideoDevices(oldVmBase, newVmBase);
    updateUsbSlots(oldVmBase, newVmBase);
    updateMemoryBalloon(newVmBase.getId(), params.isBalloonEnabled());
    updateSoundDevice(oldVmBase, newVmBase, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
    updateSmartcardDevice(oldVm, newVmBase);
    updateConsoleDevice(newVmBase.getId(), params.isConsoleEnabled());
    updateVirtioScsiController(newVmBase.getId(), params.isVirtioScsiEnabled());
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    Guid id;
    if (graphicsToSkip == null) {
        graphicsToSkip = new HashSet<>();
    }
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasVmGraphicsDeviceOfType(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            addSoundCard(vmBase, cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = getNumOfMonitors(vm);
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM dstVm, VmBase dstVmBase, boolean dstIsVm, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    VDSGroup cluster = null;
    if (dstVmBase.getVdsGroupId() != null) {
        cluster = DbFacade.getInstance().getVdsGroupDao().get(dstVmBase.getVdsGroupId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new VmStatic params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVm.getStaticData());
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VM vm = dbFacade.getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = dbFacade.getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VM dstVm = dbFacade.getVmDao().get(dstId);
    VmBase dstVmBase = (dstVm != null) ? dstVm.getStaticData() : null;
    boolean dstIsVm = (dstVmBase != null);
    if (!dstIsVm) {
        dstVmBase = dbFacade.getVmTemplateDao().get(dstId);
    }
    List<VmDevice> srcDevices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVm, dstVmBase, dstIsVm, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices);
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null, null);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = dbFacade.getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, boolean isPlugged, Boolean isReadOnly) {
    return addManagedDevice(id, generalType, type, specParams, isPlugged, isReadOnly, "", null, false);
}
#end_block

#method_before
public static <T extends VmBase> void addImportedDevices(T entity, boolean isImportAsNewEntity) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(entity);
    }
    List<VmDevice> vmDeviceToAdd = new ArrayList<VmDevice>();
    List<VmDevice> vmDeviceToUpdate = new ArrayList<VmDevice>();
    VmDeviceDAO dao = dbFacade.getVmDeviceDao();
    addImportedDisks(entity, vmDeviceToUpdate);
    addImportedInterfaces(entity, vmDeviceToUpdate);
    addOtherDevices(entity, vmDeviceToAdd);
    dao.saveAll(vmDeviceToAdd);
    dao.updateAll(vmDeviceToUpdate);
}
#method_after
public static void addImportedDevices(VmBase vmBase, boolean isImportAsNewEntity) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(vmBase);
    }
    List<VmDevice> vmDevicesToAdd = new ArrayList<>();
    List<VmDevice> vmDevicesToUpdate = new ArrayList<>();
    addImportedDiskDevices(vmBase, vmDevicesToUpdate);
    addImportedInterfaces(vmBase, vmDevicesToUpdate);
    addImportedOtherDevices(vmBase, vmDevicesToAdd);
    dao.saveAll(vmDevicesToAdd);
    dao.updateAll(vmDevicesToUpdate);
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNic iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, iface.isPassthrough() ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), null);
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#method_after
private static void addImportedInterfaces(VmBase vmBase, List<VmDevice> vmDevicesToUpdate) {
    for (VmNic iface : vmBase.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addInterface(vmBase.getId(), deviceId, true, iface.isPassthrough(), getVmDeviceAddress(vmBase, deviceId));
        VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            vmBase.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface, vmBase.getVdsGroupId()));
        updateImportedVmDevice(vmBase, vmDevice, deviceId, vmDevicesToUpdate);
    }
}
#end_block

#method_before
private static void setNewIdInImportedCollections(VmBase entity) {
    for (VmDevice managedDevice : entity.getManagedDeviceMap().values()) {
        if (!isDiskOrInterface(managedDevice)) {
            managedDevice.setId(new VmDeviceId(Guid.newGuid(), entity.getId()));
        }
    }
    for (VmDevice unMnagedDevice : entity.getUnmanagedDeviceList()) {
        unMnagedDevice.setId(new VmDeviceId(Guid.newGuid(), entity.getId()));
    }
}
#method_after
private static void setNewIdInImportedCollections(VmBase vmBase) {
    for (VmDevice managedDevice : vmBase.getManagedDeviceMap().values()) {
        if (!isDiskOrInterface(managedDevice)) {
            managedDevice.setId(new VmDeviceId(Guid.newGuid(), vmBase.getId()));
        }
    }
    for (VmDevice unmanagedDevice : vmBase.getUnmanagedDeviceList()) {
        unmanagedDevice.setId(new VmDeviceId(Guid.newGuid(), vmBase.getId()));
    }
}
#end_block

#method_before
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = device != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceType, device) : dao.getVmDeviceByVmIdAndType(vmId, deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceGeneralType, String deviceTypeName, boolean deviceEnabled) {
    List<VmDevice> vmDevices = deviceTypeName != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceGeneralType, deviceTypeName) : dao.getVmDeviceByVmIdAndType(vmId, deviceGeneralType);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    return vmDeviceChanged(vmId, deviceType, null, deviceEnabled);
}
#method_after
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceGeneralType, String deviceTypeName, VmDevice device) {
    List<VmDevice> vmDevices = deviceTypeName != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceGeneralType, deviceTypeName) : dao.getVmDeviceByVmIdAndType(vmId, deviceGeneralType);
    if (device == null) {
        return !vmDevices.isEmpty();
    }
    if (vmDevices.isEmpty()) {
        // && device != null
        return true;
    }
    if (device.getSpecParams() != null) {
        // if device.getSpecParams() == null, it is not used for comparison
        for (VmDevice vmDevice : vmDevices) {
            if (!vmDevice.getSpecParams().equals(device.getSpecParams())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public static Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    VmDeviceUtils.setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (Pair<EditableDeviceOnVmStatusField, Boolean> pair : fieldList) {
        final EditableDeviceOnVmStatusField field = pair.getFirst();
        Boolean isEnabled = pair.getSecond();
        if (Boolean.TRUE.equals(isEnabled)) {
            VmDevice device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), field.generalType(), field.type().getName(), "", 0, new HashMap<String, Object>(), true, true, field.isReadOnly(), "", null, null, null);
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            vmManagedDeviceMap.remove(getVmDeviceIdByName(vmManagedDeviceMap, field.generalType(), field.type().getName()));
        }
    }
    return vmManagedDeviceMap;
}
#method_after
public static Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, EMPTY_SPEC_PARAMS, true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
private MacsStorage createMacsStorage(Collection<LongRange> rangesBoundaries) {
    MacsStorage macsStorage = new MacsStorage(allowDuplicates);
    for (LongRange range : rangesBoundaries) {
        macsStorage.addRange(range.getMinimumLong(), range.getMaximumLong());
    }
    if (macsStorage.availableMacExist()) {
        return macsStorage;
    } else {
        throw new VdcBLLException(VdcBllErrors.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#method_after
private MacsStorage createMacsStorage(Collection<LongRange> rangesBoundaries) {
    MacsStorage macsStorage = new MacsStorage(allowDuplicates);
    for (LongRange range : rangesBoundaries) {
        macsStorage.addRange(range.getMinimumLong(), range.getMaximumLong());
    }
    if (macsStorage.availableMacExist()) {
        return macsStorage;
    } else {
        throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#end_block

#method_before
@Override
public Boolean isDuplicateMacAddressesAllowed() {
    return this.allowDuplicates;
}
#method_after
@Override
public boolean isDuplicateMacAddressesAllowed() {
    return this.allowDuplicates;
}
#end_block

#method_before
private void checkIfInitialized() {
    if (!initialized) {
        throw new VdcBLLException(VdcBllErrors.MAC_POOL_NOT_INITIALIZED);
    }
}
#method_after
private void checkIfInitialized() {
    if (!initialized) {
        throw new EngineException(EngineError.MAC_POOL_NOT_INITIALIZED);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!canPerformNicHotPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
    }
    vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!canPerformNicHotPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addCanDoActionMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
    }
    vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addCanDoActionMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = getParameters().getAction() == PlugAction.PLUG && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        try {
            runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
        } catch (VdcBLLException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = getParameters().getAction() == PlugAction.PLUG && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        try {
            runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#end_block

#method_before
private TransactionMethod<Void> updateDevice() {
    return new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            vmDevice.setIsPlugged(getParameters().getAction() == PlugAction.PLUG ? true : false);
            getVmDeviceDao().update(vmDevice);
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            return null;
        }
    };
}
#method_after
private TransactionMethod<Void> updateDevice() {
    return new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            vmDevice.setIsPlugged(getParameters().getAction() == PlugAction.PLUG ? true : false);
            getVmDeviceDao().update(vmDevice);
            VmDeviceUtils.updateBootOrder(getVm().getId());
            return null;
        }
    };
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage((getParameters().getAction() == PlugAction.PLUG) ? VdcBllMessages.VAR__ACTION__ACTIVATE : VdcBllMessages.VAR__ACTION__DEACTIVATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage((getParameters().getAction() == PlugAction.PLUG) ? EngineMessage.VAR__ACTION__ACTIVATE : EngineMessage.VAR__ACTION__DEACTIVATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__INTERFACE);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__INTERFACE);
}
#end_block

#method_before
protected boolean addMacToPool(String macAddress) {
    if (getMacPool().addMac(macAddress)) {
        return true;
    } else {
        throw new VdcBLLException(VdcBllErrors.MAC_ADDRESS_IS_IN_USE);
    }
}
#method_after
protected boolean addMacToPool(String macAddress) {
    if (getMacPool().addMac(macAddress)) {
        return true;
    } else {
        throw new EngineException(EngineError.MAC_ADDRESS_IS_IN_USE);
    }
}
#end_block

#method_before
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, allDisks, VmDeviceUtils.isVirtioScsiControllerAttached(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.isBalloonEnabled(getVmId()), VmDeviceUtils.isSoundDeviceEnabled(getVmId()), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, allDisks, VmDeviceUtils.hasVirtioScsiController(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.hasMemoryBalloon(getVmId()), VmDeviceUtils.hasSoundDevice(getVmId()), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected ValidationResult vmTemplateEmpty() {
    return getInterface().getVmTemplateId() != null ? new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET) : ValidationResult.VALID;
}
#method_after
protected ValidationResult vmTemplateEmpty() {
    return getInterface().getVmTemplateId() != null ? new ValidationResult(EngineMessage.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET) : ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult vmStatusLegal(VMStatus status) {
    return status == VMStatus.Up || status == VMStatus.Down || status == VMStatus.ImageLocked ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
}
#method_after
protected ValidationResult vmStatusLegal(VMStatus status) {
    return status == VMStatus.Up || status == VMStatus.Down || status == VMStatus.ImageLocked ? ValidationResult.VALID : new ValidationResult(EngineMessage.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    managementNetworkUtil = Mockito.mock(ManagementNetworkUtil.class);
    bond = new Bond();
    bond.setId(Guid.newGuid());
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
}
#end_block

#method_before
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    bond.setSlaves(Arrays.asList(nicA.getName(), nicB.getName()));
    when(networkDaoMock.get(eq(networkA.getId()))).thenReturn(networkA);
    when(networkClusterDaoMock.get(new NetworkClusterId(host.getVdsGroupId(), networkA.getId()))).thenReturn(mock(NetworkCluster.class));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(bond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, CoreMatchers.not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#method_after
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    bond.setSlaves(Arrays.asList(nicA.getName(), nicB.getName()));
    when(networkDaoMock.get(eq(networkA.getId()))).thenReturn(networkA);
    when(networkClusterDaoMock.get(new NetworkClusterId(host.getVdsGroupId(), networkA.getId()))).thenReturn(mock(NetworkCluster.class));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(bond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver);
}
#end_block

