257
#method_before
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockDeviceEntryNumberFomatEx(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CISCO_IP_STATUS_DEVICE_ENTRY_NUMBER_FORMATEX).andThrow(new NumberFormatException());
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#method_after
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockDeviceEntryNumberFomatEx(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CONFIG_WITH_INVALID_ENTRY_NUMBER).andThrow(new NumberFormatException());
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockWithoutUsernameAndPassword(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CISCO_IP_WITHOUT_USERNAME_PASSWORD);
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#method_after
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockWithoutUsernameAndPassword(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CONFIG_WITH_NULL_ENTRY);
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockWithDifferentDeviceState(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CISCO_DIFF_DEVICE_STATE);
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#method_after
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockWithDifferentDeviceState(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CONFIG_WITH_DIFFERENT_DEVICE_STATE);
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockDeviceWithArrayOutOFBoundEx(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CISCO_IP_WITH_ARRAY_OUT_OF_BOUNDEX).andThrow(new ArrayIndexOutOfBoundsException());
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#method_after
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockDeviceWithArrayOutOFBoundEx(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CONFIG_WITH_ARRAY_OUT_OF_BOUNDEX).andThrow(new ArrayIndexOutOfBoundsException());
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockDeviceEntryForDeactivate(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CISCO_DEVICE_ENTRY_FOR_DEACTIVATE).andThrow(new ArrayIndexOutOfBoundsException());
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#method_after
@SuppressWarnings("unchecked")
private Dictionary<String, String> getDictionaryMockDeviceEntryForDeactivate(ComponentContext componentContext) {
    Dictionary<String, String> dictionary = EasyMock.createMock(Dictionary.class);
    expect(dictionary.get(DEV_CONFIG)).andReturn(CONFIG_ENTRY_FOR_DEACTIVATE).andThrow(new ArrayIndexOutOfBoundsException());
    replay(dictionary);
    expect(componentContext.getProperties()).andReturn(dictionary);
    return dictionary;
}
#end_block

#method_before
@Ignore
@Test(expected = IOException.class)
public void testSSHAuthentication() throws IOException, JNCException {
    TestDeviceCreator objForTestDev = new TestDeviceCreator(new NetconfDevice(CISCO_IP, CISCO_PORT, CISCO_USERNAME, CISCO_PASSWORD), true);
    objForTestDev.run();
}
#method_after
@Ignore
@Test(expected = IOException.class)
public void testSSHAuthentication() throws IOException, JNCException {
    TestDeviceCreator objForTestDev = new TestDeviceCreator(new NetconfDevice(DEVICE_IP, DEVICE_PORT, DEVICE_USERNAME, DEVICE_PASSWORD), true);
    objForTestDev.run();
}
#end_block

#method_before
@Test
public void testDeactivate() {
    ComponentContext componentContext = EasyMock.createMock(ComponentContext.class);
    getDictionaryMockDeviceEntryForDeactivate(componentContext);
    replay(componentContext);
    testActiveWithComponentContext();
    provider.deactivate(componentContext);
}
#method_after
@Test
public void testDeactivate() {
    ComponentContext componentContext = EasyMock.createMock(ComponentContext.class);
    getDictionaryMockDeviceEntryForDeactivate(componentContext);
    replay(componentContext);
    testActiveWithDeviceEntryWithDifferentDeviceState();
    provider.deactivate(componentContext);
}
#end_block

#method_before
private DeviceId getDeviceId() throws URISyntaxException {
    String additionalSSP = new StringBuilder(device.getUsername()).append(AT_THE_RATE).append(device.getSshHost()).append(COLON).append(device.getSshPort()).toString();
    DeviceId did = DeviceId.deviceId(new URI(SCHEME, additionalSSP, null));
    return did;
}
#method_after
private DeviceId getDeviceId() throws URISyntaxException {
    String additionalSSP = new StringBuilder(device.getUsername()).append(AT_THE_RATE).append(device.getSshHost()).append(COLON).append(device.getSshPort()).toString();
    DeviceId did = DeviceId.deviceId(new URI(SCHEME_NETCONF, additionalSSP, null));
    return did;
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    // Bail if this is deemed to be a control packet.
    if (isControlPacket(ethPkt)) {
        return;
    }
    // Skip IPv6 multicast packet when IPv6 forward is disabled.
    if (!ipv6Forwarding && isIpv6Multicast(ethPkt)) {
        return;
    }
    HostId id = HostId.hostId(ethPkt.getDestinationMAC());
    // Do not process link-local addresses in any way.
    if (id.mac().isLinkLocal()) {
        return;
    }
    // Do not process IPv4 multicast packets, let mfwd handle them
    if (ignoreIpv4McastPackets && ethPkt.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ip = (IPv4) ethPkt.getPayload();
        IpAddress dstip = IpAddress.valueOf(ip.getDestinationAddress());
        if (IpPrefix.valueOf("224.0.0.0/4").contains(dstip)) {
            return;
        }
    }
    // Do we know who this is for? If not, flood and bail.
    Host dst = hostService.getHost(id);
    if (dst == null) {
        flood(context);
        return;
    }
    // simply forward out to the destination and bail.
    if (pkt.receivedFrom().deviceId().equals(dst.location().deviceId())) {
        if (!context.inPacket().receivedFrom().port().equals(dst.location().port())) {
            installRule(context, dst.location().port());
        }
        return;
    }
    // Otherwise, get a set of paths that lead from here to the
    // destination edge switch.
    Set<Path> paths = topologyService.getPaths(topologyService.currentTopology(), pkt.receivedFrom().deviceId(), dst.location().deviceId());
    if (paths.isEmpty()) {
        // If there are no paths, flood and bail.
        flood(context);
        return;
    }
    // Otherwise, pick a path that does not lead back to where we
    // came from; if no such path, flood and bail.
    Path path = pickForwardPath(paths, pkt.receivedFrom().port());
    if (path == null) {
        log.warn("Doh... don't know where to go... {} -> {} received on {}", ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), pkt.receivedFrom());
        flood(context);
        return;
    }
    // Otherwise forward and be done with it.
    installRule(context, path.src().port());
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    // Bail if this is deemed to be a control packet.
    if (isControlPacket(ethPkt)) {
        return;
    }
    // Skip IPv6 multicast packet when IPv6 forward is disabled.
    if (!ipv6Forwarding && isIpv6Multicast(ethPkt)) {
        return;
    }
    HostId id = HostId.hostId(ethPkt.getDestinationMAC());
    // Do not process link-local addresses in any way.
    if (id.mac().isLinkLocal()) {
        return;
    }
    // Do not process IPv4 multicast packets, let mfwd handle them
    if (ignoreIpv4McastPackets && ethPkt.getEtherType() == Ethernet.TYPE_IPV4) {
        if (id.mac().isMulticast()) {
            return;
        }
    }
    // Do we know who this is for? If not, flood and bail.
    Host dst = hostService.getHost(id);
    if (dst == null) {
        flood(context);
        return;
    }
    // simply forward out to the destination and bail.
    if (pkt.receivedFrom().deviceId().equals(dst.location().deviceId())) {
        if (!context.inPacket().receivedFrom().port().equals(dst.location().port())) {
            installRule(context, dst.location().port());
        }
        return;
    }
    // Otherwise, get a set of paths that lead from here to the
    // destination edge switch.
    Set<Path> paths = topologyService.getPaths(topologyService.currentTopology(), pkt.receivedFrom().deviceId(), dst.location().deviceId());
    if (paths.isEmpty()) {
        // If there are no paths, flood and bail.
        flood(context);
        return;
    }
    // Otherwise, pick a path that does not lead back to where we
    // came from; if no such path, flood and bail.
    Path path = pickForwardPath(paths, pkt.receivedFrom().port());
    if (path == null) {
        log.warn("Doh... don't know where to go... {} -> {} received on {}", ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), pkt.receivedFrom());
        flood(context);
        return;
    }
    // Otherwise forward and be done with it.
    installRule(context, path.src().port());
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    // If IPv6 NDP is disabled, don't handle IPv6 frames.
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    if (!ipv6NeighborDiscovery && (ethPkt.getEtherType() == TYPE_IPV6)) {
        return;
    }
    // Do not ARP for multicast packets.  Let mfwd handle them.
    if (ethPkt.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ip = (IPv4) ethPkt.getPayload();
        IpAddress dstip = IpAddress.valueOf(ip.getDestinationAddress());
        if (IpPrefix.valueOf("224.0.0.0/4").contains(dstip)) {
            return;
        }
    }
    // handle the arp packet.
    proxyArpService.handlePacket(context);
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    // If IPv6 NDP is disabled, don't handle IPv6 frames.
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    if (!ipv6NeighborDiscovery && (ethPkt.getEtherType() == TYPE_IPV6)) {
        return;
    }
    // Do not ARP for multicast packets.  Let mfwd handle them.
    if (ethPkt.getEtherType() == Ethernet.TYPE_IPV4) {
        if (ethPkt.getDestinationMAC().isMulticast()) {
            return;
        }
    }
    // handle the arp packet.
    proxyArpService.handlePacket(context);
}
#end_block

#method_before
@Override
public void deviceDisconnected(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkValidity();
    log.info("Device {} disconnected from this node", deviceId);
    List<Port> ports = store.getPorts(deviceId);
    List<PortDescription> descs = Lists.newArrayList();
    ports.forEach(port -> descs.add(new DefaultPortDescription(port.number(), false, port.type(), port.portSpeed())));
    store.updatePorts(this.provider().id(), deviceId, descs);
    try {
        if (mastershipService.getLocalRole(deviceId) == MASTER) {
            post(store.markOffline(deviceId));
        }
    } catch (IllegalStateException e) {
        log.warn("Failed to mark {} offline", deviceId);
        // only the MASTER should be marking off-line in normal cases,
        // but if I was the last STANDBY connection, etc. and no one else
        // was there to mark the device offline, this instance may need to
        // temporarily request for Master Role and mark offline.
        // there are times when this node will correctly have mastership, BUT
        // that isn't reflected in the ClockManager before the device disconnects.
        // we want to let go of the device anyways, so make sure this happens.
        // FIXME: Store semantics leaking out as IllegalStateException.
        // Consider revising store API to handle this scenario.
        CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
        roleFuture.whenComplete((role, error) -> {
            MastershipTerm term = termService.getMastershipTerm(deviceId);
            // TODO: Move this type of check inside device clock manager, etc.
            if (term != null && localNodeId.equals(term.master())) {
                log.info("Retry marking {} offline", deviceId);
                deviceClockProviderService.setMastershipTerm(deviceId, term);
                post(store.markOffline(deviceId));
            } else {
                log.info("Failed again marking {} offline. {}", deviceId, role);
            }
        });
    } finally {
        try {
            // relinquish master role and ability to be backup.
            mastershipService.relinquishMastership(deviceId).get();
        } catch (InterruptedException e) {
            log.warn("Interrupted while reliquishing role for {}", deviceId);
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            log.error("Exception thrown while relinquishing role for {}", deviceId, e);
        }
    }
}
#method_after
@Override
public void deviceDisconnected(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkValidity();
    log.info("Device {} disconnected from this node", deviceId);
    List<Port> ports = store.getPorts(deviceId);
    List<PortDescription> descs = Lists.newArrayList();
    ports.forEach(port -> descs.add(new DefaultPortDescription(port.number(), false, port.type(), port.portSpeed())));
    store.updatePorts(this.provider().id(), deviceId, descs);
    try {
        if (mastershipService.getLocalRole(deviceId) == MASTER) {
            post(store.markOffline(deviceId));
        }
    } catch (IllegalStateException e) {
        log.warn("Failed to mark {} offline", deviceId);
        // only the MASTER should be marking off-line in normal cases,
        // but if I was the last STANDBY connection, etc. and no one
        // else
        // was there to mark the device offline, this instance may need
        // to
        // temporarily request for Master Role and mark offline.
        // there are times when this node will correctly have
        // mastership, BUT
        // that isn't reflected in the ClockManager before the device
        // disconnects.
        // we want to let go of the device anyways, so make sure this
        // happens.
        // FIXME: Store semantics leaking out as IllegalStateException.
        // Consider revising store API to handle this scenario.
        CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
        roleFuture.whenComplete((role, error) -> {
            MastershipTerm term = termService.getMastershipTerm(deviceId);
            // manager, etc.
            if (term != null && localNodeId.equals(term.master())) {
                log.info("Retry marking {} offline", deviceId);
                deviceClockProviderService.setMastershipTerm(deviceId, term);
                post(store.markOffline(deviceId));
            } else {
                log.info("Failed again marking {} offline. {}", deviceId, role);
            }
        });
    } finally {
        try {
            // relinquish master role and ability to be backup.
            mastershipService.relinquishMastership(deviceId).get();
        } catch (InterruptedException e) {
            log.warn("Interrupted while reliquishing role for {}", deviceId);
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            log.error("Exception thrown while relinquishing role for {}", deviceId, e);
        }
    }
}
#end_block

#method_before
@Override
public void receivedRoleReply(DeviceId deviceId, MastershipRole requested, MastershipRole response) {
    // Several things can happen here:
    // 1. request and response match
    // 2. request and response don't match
    // 3. MastershipRole and requested match (and 1 or 2 are true)
    // 4. MastershipRole and requested don't match (and 1 or 2 are true)
    // 
    // 2, 4, and 3 with case 2 are failure modes.
    // FIXME: implement response to this notification
    log.debug("got reply to a role request for {}: asked for {}, and got {}", deviceId, requested, response);
    if (requested == null && response == null) {
        // something was off with DeviceProvider, maybe check channel too?
        log.warn("Failed to assert role [{}] onto Device {}", requested, deviceId);
        mastershipService.relinquishMastership(deviceId);
        return;
    }
    if (Objects.equals(requested, response)) {
        if (Objects.equals(requested, mastershipService.getLocalRole(deviceId))) {
            return;
        } else {
            return;
        // FIXME roleManager got the device to comply, but doesn't agree with
        // the store; use the store's view, then try to reassert.
        }
    } else {
        // we didn't get back what we asked for. Reelect someone else.
        log.warn("Failed to assert role [{}] onto Device {}", response, deviceId);
        if (response == MastershipRole.MASTER) {
            mastershipService.relinquishMastership(deviceId);
        // TODO: Shouldn't we be triggering event?
        // final Device device = getDevice(deviceId);
        // post(new DeviceEvent(DEVICE_MASTERSHIP_CHANGED, device));
        }
    }
}
#method_after
@Override
public void receivedRoleReply(DeviceId deviceId, MastershipRole requested, MastershipRole response) {
    // Several things can happen here:
    // 1. request and response match
    // 2. request and response don't match
    // 3. MastershipRole and requested match (and 1 or 2 are true)
    // 4. MastershipRole and requested don't match (and 1 or 2 are true)
    // 
    // 2, 4, and 3 with case 2 are failure modes.
    // FIXME: implement response to this notification
    log.debug("got reply to a role request for {}: asked for {}, and got {}", deviceId, requested, response);
    if (requested == null && response == null) {
        // something was off with DeviceProvider, maybe check channel
        // too?
        log.warn("Failed to assert role [{}] onto Device {}", requested, deviceId);
        mastershipService.relinquishMastership(deviceId);
        return;
    }
    if (Objects.equals(requested, response)) {
        if (Objects.equals(requested, mastershipService.getLocalRole(deviceId))) {
            return;
        } else {
            return;
        // FIXME roleManager got the device to comply, but doesn't
        // agree with
        // the store; use the store's view, then try to reassert.
        }
    } else {
        // we didn't get back what we asked for. Reelect someone else.
        log.warn("Failed to assert role [{}] onto Device {}", response, deviceId);
        if (response == MastershipRole.MASTER) {
            mastershipService.relinquishMastership(deviceId);
        // TODO: Shouldn't we be triggering event?
        // final Device device = getDevice(deviceId);
        // post(new DeviceEvent(DEVICE_MASTERSHIP_CHANGED, device));
        }
    }
}
#end_block

#method_before
@Override
public Iterable<Device> getDevices(Type type) {
    checkPermission(Permission.DEVICE_READ);
    return store.getDevices(type);
}
#method_after
@Override
public Iterable<Device> getDevices(Type type) {
    checkPermission(Permission.DEVICE_READ);
    Set<Device> results = new HashSet<>();
    Iterable<Device> devices = store.getDevices();
    if (devices != null) {
        devices.forEach(d -> {
            if (type.equals(d.type())) {
                results.add(d);
            }
        });
    }
    return results;
}
#end_block

#method_before
@Override
public Iterable<Device> getAvailableDevices(Type type) {
    checkPermission(Permission.DEVICE_READ);
    return store.getAvailableDevices(type);
}
#method_after
@Override
public Iterable<Device> getAvailableDevices(Type type) {
    checkPermission(Permission.DEVICE_READ);
    Set<Device> results = new HashSet<>();
    Iterable<Device> availableDevices = store.getAvailableDevices();
    if (availableDevices != null) {
        availableDevices.forEach(d -> {
            if (type.equals(d.type())) {
                results.add(d);
            }
        });
    }
    return results;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    requestPackets();
    log.info("SDN-IP Reactive Routing Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    requestIntercepts();
    log.info("SDN-IP Reactive Routing Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    withdrawPackets();
    packetService.removeProcessor(processor);
    processor = null;
    log.info("SDN-IP Reactive Routing Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    withdrawIntercepts();
    packetService.removeProcessor(processor);
    processor = null;
    log.info("SDN-IP Reactive Routing Stopped");
}
#end_block

#method_before
private void withdrawIntercepts() {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    // Replaced the next line placing a packet request with a packet cancel
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId);
    // IPv6 Neighbor Solicitation packet.
    selector.matchEthType(Ethernet.TYPE_IPV6);
    selector.matchIPProtocol(IPv6.PROTOCOL_ICMP6);
    selector.matchIcmpv6Type(ICMP6.NEIGHBOR_SOLICITATION);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId);
    // IPv6 Neighbor Advertisement packet.
    selector.matchIcmpv6Type(ICMP6.NEIGHBOR_ADVERTISEMENT);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId);
}
#method_after
private void withdrawIntercepts() {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId);
    // IPv6 Neighbor Solicitation packet.
    selector.matchEthType(Ethernet.TYPE_IPV6);
    selector.matchIPProtocol(IPv6.PROTOCOL_ICMP6);
    selector.matchIcmpv6Type(ICMP6.NEIGHBOR_SOLICITATION);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId);
    // IPv6 Neighbor Advertisement packet.
    selector.matchIcmpv6Type(ICMP6.NEIGHBOR_ADVERTISEMENT);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId);
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    modified(context);
    // "org.onosproject.aaa" is the FQDN of our app
    appId = coreService.registerApplication("org.onosproject.aaa");
    // register our event handler
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(EthType.EtherType.EAPOL.ethType().toShort());
    packetService.requestPackets(selector.build(), CONTROL, appId);
    // Instantiate the map of the state machines
    stateMachineMap = Collections.synchronizedMap(Maps.newHashMap());
    hostService.startMonitoringIp(IpAddress.valueOf(radiusIpAddress));
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    modified(context);
    // "org.onosproject.aaa" is the FQDN of our app
    appId = coreService.registerApplication("org.onosproject.aaa");
    // register our event handler
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    requestIntercepts();
    // Instantiate the map of the state machines
    stateMachineMap = Collections.synchronizedMap(Maps.newHashMap());
    hostService.startMonitoringIp(IpAddress.valueOf(radiusIpAddress));
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    appId = coreService.registerApplication("org.onosproject.aaa");
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(EthType.EtherType.EAPOL.ethType().toShort());
    packetService.cancelPackets(selector.build(), CONTROL, appId);
    // de-register and null our handler
    packetService.removeProcessor(processor);
    processor = null;
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    appId = coreService.registerApplication("org.onosproject.aaa");
    withdrawIntercepts();
    // de-register and null our handler
    packetService.removeProcessor(processor);
    processor = null;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 6);
    log.info("vBNG virtual public hosts started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 6);
    requestIntercepts();
    log.info("vBNG virtual public hosts started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    packetService.removeProcessor(processor);
    processor = null;
    log.info("vBNG virtual public hosts Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    withdrawIntercepts();
    packetService.removeProcessor(processor);
    processor = null;
    log.info("vBNG virtual public hosts Stopped");
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    // to load configuration at startup
    modified(context);
    if (disableLinkDiscovery) {
        log.info("Link Discovery has been permanently disabled by configuration");
        return;
    }
    providerService = providerRegistry.register(this);
    deviceService.addListener(listener);
    packetService.addProcessor(listener, 0);
    masterService.addListener(roleListener);
    LinkDiscovery ld;
    for (Device device : deviceService.getAvailableDevices()) {
        if (rules.isSuppressed(device)) {
            log.debug("LinkDiscovery from {} disabled by configuration", device.id());
            continue;
        }
        ld = new LinkDiscovery(device, packetService, masterService, providerService, useBDDP);
        discoverers.put(device.id(), ld);
        for (Port p : deviceService.getPorts(device.id())) {
            if (rules.isSuppressed(p)) {
                log.debug("LinkDiscovery from {}@{} disabled by configuration", p.number(), device.id());
                continue;
            }
            if (!p.number().isLogical()) {
                ld.addPort(p);
            }
        }
    }
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/device", "sync-%d"));
    executor.scheduleAtFixedRate(new SyncDeviceInfoTask(), INIT_DELAY, DELAY, SECONDS);
    requestIntercepts();
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    // to load configuration at startup
    modified(context);
    if (disableLinkDiscovery) {
        log.info("LinkDiscovery has been permanently disabled by configuration");
        return;
    }
    providerService = providerRegistry.register(this);
    deviceService.addListener(listener);
    packetService.addProcessor(listener, 0);
    masterService.addListener(roleListener);
    LinkDiscovery ld;
    for (Device device : deviceService.getAvailableDevices()) {
        if (rules.isSuppressed(device)) {
            log.debug("LinkDiscovery from {} disabled by configuration", device.id());
            continue;
        }
        ld = new LinkDiscovery(device, packetService, masterService, providerService, useBDDP);
        discoverers.put(device.id(), ld);
        for (Port p : deviceService.getPorts(device.id())) {
            if (rules.isSuppressed(p)) {
                log.debug("LinkDiscovery from {}@{} disabled by configuration", p.number(), device.id());
                continue;
            }
            if (!p.number().isLogical()) {
                ld.addPort(p);
            }
        }
    }
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/device", "sync-%d"));
    executor.scheduleAtFixedRate(new SyncDeviceInfoTask(), INIT_DELAY, DELAY, SECONDS);
    requestIntercepts();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    // TODO revoke all packet requests when deactivate
    cfgService.unregisterProperties(getClass(), false);
    withdrawPackets();
    packetService.removeProcessor(processor);
    processor = null;
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    withdrawIntercepts();
    packetService.removeProcessor(processor);
    processor = null;
    log.info("Stopped");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    // TODO revoke unnecessary packet requests when config being modified
    readComponentConfiguration(context);
    requestPackests();
}
#method_after
@Modified
public void modified(ComponentContext context) {
    readComponentConfiguration(context);
    requestPackests();
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Reserve OduClt ports
    if (!deviceResourceService.requestPorts(new HashSet<>(Arrays.asList(srcPort, dstPort)), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    LinkedList<Intent> intents = new LinkedList<>();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent);
    // Create optical connectivity intent if needed
    if (connIntent == null) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            return Collections.emptyList();
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // FIXME: hardcoded ODU signal type
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(OduSignalType.ODU4).bidirectional(intent.isBidirectional()).build();
        intentService.submit(connIntent);
    }
    // Create optical circuit intent
    List<FlowRule> rules = new LinkedList<>();
    rules.add(connectPorts(src, connIntent.getSrc(), intent.priority()));
    rules.add(connectPorts(connIntent.getDst(), dst, intent.priority()));
    // Create flow rules for reverse path
    if (intent.isBidirectional()) {
        rules.add(connectPorts(connIntent.getSrc(), src, intent.priority()));
        rules.add(connectPorts(dst, connIntent.getDst(), intent.priority()));
    }
    circuitIntent = new FlowRuleIntent(appId, rules, intent.resources());
    // Save circuit to connectivity intent mapping
    deviceResourceService.requestMapping(connIntent.id(), intent.id());
    intents.add(circuitIntent);
    return intents;
}
#method_after
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Reserve OduClt ports
    if (!deviceResourceService.requestPorts(Sets.newHashSet(srcPort, dstPort), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    LinkedList<Intent> intents = new LinkedList<>();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent);
    // Create optical connectivity intent if needed
    if (connIntent == null) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            return Collections.emptyList();
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // FIXME: hardcoded ODU signal type
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(OduSignalType.ODU4).bidirectional(intent.isBidirectional()).build();
        intentService.submit(connIntent);
    }
    // Create optical circuit intent
    List<FlowRule> rules = new LinkedList<>();
    rules.add(connectPorts(src, connIntent.getSrc(), intent.priority()));
    rules.add(connectPorts(connIntent.getDst(), dst, intent.priority()));
    // Create flow rules for reverse path
    if (intent.isBidirectional()) {
        rules.add(connectPorts(connIntent.getSrc(), src, intent.priority()));
        rules.add(connectPorts(dst, connIntent.getDst(), intent.priority()));
    }
    circuitIntent = new FlowRuleIntent(appId, rules, intent.resources());
    // Save circuit to connectivity intent mapping
    deviceResourceService.requestMapping(connIntent.id(), intent.id());
    intents.add(circuitIntent);
    return intents;
}
#end_block

#method_before
private void getTLSParameters() {
    String tempString = System.getProperty("enableNettyTLS");
    enableNettyTLS = Strings.isNullOrEmpty(tempString) ? TLS_DISABLED : Boolean.parseBoolean(tempString);
    log.info("enableNettyTLS = {}", enableNettyTLS);
    if (enableNettyTLS) {
        try {
            ksLocation = System.getProperty("ksLocation");
            if (Strings.isNullOrEmpty(ksLocation)) {
                enableNettyTLS = TLS_DISABLED;
                throw new Exception("Invalid keystore location.");
            }
            tsLocation = System.getProperty("tsLocation");
            if (Strings.isNullOrEmpty(tsLocation)) {
                enableNettyTLS = TLS_DISABLED;
                throw new Exception("Invalid truststore location.");
            }
            ksPwd = System.getProperty("ksPwd").toCharArray();
            if (MIN_KS_LENGTH > ksPwd.length) {
                enableNettyTLS = TLS_DISABLED;
                throw new Exception("Invalid keystore password length.");
            }
            tsPwd = System.getProperty("tsPwd").toCharArray();
            if (MIN_KS_LENGTH > tsPwd.length) {
                enableNettyTLS = TLS_DISABLED;
                throw new Exception("Invalid truststore password length.");
            }
            log.info("ksLocation : {}, tsLocation : {}, kwPwd : {}, tsPwd : {}", ksLocation, tsLocation, ksPwd, tsPwd);
        } catch (Throwable e) {
            enableNettyTLS = TLS_DISABLED;
            log.info("Failed to get the netty TLS parameters. " + "Reason: {}.", e.getMessage());
        }
    }
}
#method_after
private void getTLSParameters() {
    String tempString = System.getProperty("enableNettyTLS");
    enableNettyTLS = Strings.isNullOrEmpty(tempString) ? TLS_DISABLED : Boolean.parseBoolean(tempString);
    log.info("enableNettyTLS = {}", enableNettyTLS);
    if (enableNettyTLS) {
        ksLocation = System.getProperty("javax.net.ssl.keyStore");
        if (Strings.isNullOrEmpty(ksLocation)) {
            enableNettyTLS = TLS_DISABLED;
            return;
        }
        tsLocation = System.getProperty("javax.net.ssl.trustStore");
        if (Strings.isNullOrEmpty(tsLocation)) {
            enableNettyTLS = TLS_DISABLED;
            return;
        }
        ksPwd = System.getProperty("javax.net.ssl.keyStorePassword").toCharArray();
        if (MIN_KS_LENGTH > ksPwd.length) {
            enableNettyTLS = TLS_DISABLED;
            return;
        }
        tsPwd = System.getProperty("javax.net.ssl.trustStorePassword").toCharArray();
        if (MIN_KS_LENGTH > tsPwd.length) {
            enableNettyTLS = TLS_DISABLED;
            return;
        }
    }
}
#end_block

#method_before
private String ipv6ToStringHelper() {
    // Populate a buffer with the string of the full address with leading zeros stripped
    StringBuffer buff = new StringBuffer();
    buff.append(String.format("%x:%x:%x:%x:%x:%x:%x:%x", (((octets[0] << 8) & upperBitMask) | (octets[1] & lowerBitMask)), (((octets[2] << 8) & upperBitMask) | (octets[3] & lowerBitMask)), (((octets[4] << 8) & upperBitMask) | (octets[5] & lowerBitMask)), (((octets[6] << 8) & upperBitMask) | (octets[7] & lowerBitMask)), (((octets[8] << 8) & upperBitMask) | (octets[9] & lowerBitMask)), (((octets[10] << 8) & upperBitMask) | (octets[11] & lowerBitMask)), (((octets[12] << 8) & upperBitMask) | (octets[13] & lowerBitMask)), (((octets[14] << 8) & upperBitMask) | (octets[15] & lowerBitMask))));
    // Initialize variables for tracking longest zero subsequence, tiebreaking by first occurence
    int longestSeqStart, longestSeqLen, currSeqStart, currSeqLen;
    longestSeqStart = 0;
    longestSeqLen = 0;
    currSeqStart = 0;
    currSeqLen = 0;
    for (int index = 0; index < buff.length(); index++) {
        if (buff.charAt(index) == ':') {
            if (currSeqLen != 0 && buff.charAt(index + 1) == '0') {
                currSeqLen += 1;
            }
        } else if (buff.charAt(index) == '0' && ((index == 0) || (buff.charAt(index - 1) == ':'))) {
            if (currSeqLen == 0) {
                currSeqStart = index;
            }
            currSeqLen += 1;
        } else {
            if (currSeqLen > longestSeqLen) {
                longestSeqStart = currSeqStart;
                longestSeqLen = currSeqLen;
            }
            currSeqLen = 0;
        }
    }
    if (currSeqLen > longestSeqLen) {
        longestSeqLen = currSeqLen;
        longestSeqStart = currSeqStart;
    }
    if (longestSeqLen > 1) {
        if (buff.length() == (longestSeqStart + longestSeqLen)) {
            buff.append(':');
        }
        buff.delete(longestSeqStart, longestSeqStart + longestSeqLen);
        if (longestSeqStart == 0) {
            buff.insert(0, ':');
        }
    }
    return buff.toString();
}
#method_after
private String ipv6ToStringHelper() {
    // Populate a buffer with the string of the full address with leading zeros stripped
    StringBuffer buff = new StringBuffer();
    buff.append(String.format("%x:%x:%x:%x:%x:%x:%x:%x", (((octets[0] & BIT_MASK) << 8) | (octets[1] & BIT_MASK)), (((octets[2] & BIT_MASK) << 8) | (octets[3] & BIT_MASK)), (((octets[4] & BIT_MASK) << 8) | (octets[5] & BIT_MASK)), (((octets[6] & BIT_MASK) << 8) | (octets[7] & BIT_MASK)), (((octets[8] & BIT_MASK) << 8) | (octets[9] & BIT_MASK)), (((octets[10] & BIT_MASK) << 8) | (octets[11] & BIT_MASK)), (((octets[12] & BIT_MASK) << 8) | (octets[13] & BIT_MASK)), (((octets[14] & BIT_MASK) << 8) | (octets[15] & BIT_MASK))));
    // Initialize variables for tracking longest zero subsequence, tiebreaking by first occurence
    int longestSeqStart, longestSeqLen, currSeqStart, currSeqLen;
    longestSeqStart = 0;
    longestSeqLen = 0;
    currSeqStart = 0;
    currSeqLen = 0;
    for (int index = 0; index < buff.length(); index++) {
        if (buff.charAt(index) == ':') {
            if (currSeqLen != 0 && buff.charAt(index + 1) == '0') {
                currSeqLen += 1;
            }
        } else if (buff.charAt(index) == '0' && ((index == 0) || (buff.charAt(index - 1) == ':'))) {
            if (currSeqLen == 0) {
                currSeqStart = index;
            }
            currSeqLen += 1;
        } else {
            if (currSeqLen > longestSeqLen) {
                longestSeqStart = currSeqStart;
                longestSeqLen = currSeqLen;
            }
            currSeqLen = 0;
        }
    }
    if (currSeqLen > longestSeqLen) {
        longestSeqLen = currSeqLen;
        longestSeqStart = currSeqStart;
    }
    if (longestSeqLen > 1) {
        if (buff.length() == (longestSeqStart + longestSeqLen)) {
            buff.append(':');
        }
        buff.delete(longestSeqStart, longestSeqStart + longestSeqLen);
        if (longestSeqStart == 0) {
            buff.insert(0, ':');
        }
    }
    return buff.toString();
}
#end_block

#method_before
@Override
public void setUpConnectivityInternetToHost(IpAddress hostIpAddress) {
    checkNotNull(hostIpAddress);
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints = configService.getBgpPeerConnectPoints();
    /*for (Interface intf : configService.getInterfaces()) {
            ConnectPoint srcPoint = intf.connectPoint();
            ingressPoints.add(srcPoint);
        }*/
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (hostIpAddress.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
    }
    // Match the destination IP prefix at the first hop
    IpPrefix ipPrefix = hostIpAddress.toIpPrefix();
    selector.matchIPDst(ipPrefix);
    // Rewrite the destination MAC address
    MacAddress hostMac = null;
    ConnectPoint egressPoint = null;
    for (Host host : hostService.getHostsByIp(hostIpAddress)) {
        if (host.mac() != null) {
            hostMac = host.mac();
            egressPoint = host.location();
            break;
        }
    }
    if (hostMac == null) {
        hostService.startMonitoringIp(hostIpAddress);
        return;
    }
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(hostMac);
    Key key = Key.of(ipPrefix.toString(), appId);
    int priority = ipPrefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPoints).egressPoint(egressPoint).priority(priority).build();
    log.trace("Generates ConnectivityInternetToHost intent {}", intent);
    submitReactiveIntent(ipPrefix, intent);
}
#method_after
@Override
public void setUpConnectivityInternetToHost(IpAddress hostIpAddress) {
    checkNotNull(hostIpAddress);
    Set<ConnectPoint> ingressPoints = configService.getBgpPeerConnectPoints();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (hostIpAddress.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
    }
    // Match the destination IP prefix at the first hop
    IpPrefix ipPrefix = hostIpAddress.toIpPrefix();
    selector.matchIPDst(ipPrefix);
    // Rewrite the destination MAC address
    MacAddress hostMac = null;
    ConnectPoint egressPoint = null;
    for (Host host : hostService.getHostsByIp(hostIpAddress)) {
        if (host.mac() != null) {
            hostMac = host.mac();
            egressPoint = host.location();
            break;
        }
    }
    if (hostMac == null) {
        hostService.startMonitoringIp(hostIpAddress);
        return;
    }
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(hostMac);
    Key key = Key.of(ipPrefix.toString(), appId);
    int priority = ipPrefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPoints).egressPoint(egressPoint).priority(priority).build();
    log.trace("Generates ConnectivityInternetToHost intent {}", intent);
    submitReactiveIntent(ipPrefix, intent);
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(stats1, stats1).addEqualityGroup(stats2).testEquals();
    new EqualsTester().addEqualityGroup(stats1, stats1).addEqualityGroup(stats3).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(stats1, stats1).addEqualityGroup(stats2).addEqualityGroup(stats3).testEquals();
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Reserve OCh ports
    if (!deviceResourceService.requestPorts(new HashSet<>(Arrays.asList(srcPort, dstPort)), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Static or dynamic lambda allocation
        String staticLambda = srcPort.annotations().value(AnnotationKeys.STATIC_LAMBDA);
        OchPort srcOchPort = (OchPort) srcPort;
        OchPort dstOchPort = (OchPort) dstPort;
        OchSignal ochSignal;
        // FIXME: need to actually reserve the lambda for static lambda's
        if (staticLambda != null) {
            ochSignal = new OchSignal(Frequency.ofHz(Long.valueOf(staticLambda)), srcOchPort.lambda().channelSpacing(), srcOchPort.lambda().slotGranularity());
        } else if (!srcOchPort.isTunable() || !dstOchPort.isTunable()) {
            // FIXME: also check OCh port
            ochSignal = srcOchPort.lambda();
        } else {
            // Request and reserve lambda on path
            LinkResourceAllocations linkAllocs = assignWavelength(intent, path);
            if (linkAllocs == null) {
                continue;
            }
            LambdaResourceAllocation lambdaAlloc = getWavelength(path, linkAllocs);
            OmsPort omsPort = (OmsPort) deviceService.getPort(path.src().deviceId(), path.src().port());
            ochSignal = new OchSignal(lambdaAlloc, omsPort.maxFrequency(), omsPort.grid());
        }
        // Create installable optical path intent
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    deviceResourceService.releasePorts(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#method_after
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Reserve OCh ports
    if (!deviceResourceService.requestPorts(ImmutableSet.of(srcPort, dstPort), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Static or dynamic lambda allocation
        String staticLambda = srcPort.annotations().value(AnnotationKeys.STATIC_LAMBDA);
        OchPort srcOchPort = (OchPort) srcPort;
        OchPort dstOchPort = (OchPort) dstPort;
        OchSignal ochSignal;
        // FIXME: need to actually reserve the lambda for static lambda's
        if (staticLambda != null) {
            ochSignal = new OchSignal(Frequency.ofHz(Long.valueOf(staticLambda)), srcOchPort.lambda().channelSpacing(), srcOchPort.lambda().slotGranularity());
        } else if (!srcOchPort.isTunable() || !dstOchPort.isTunable()) {
            // FIXME: also check OCh port
            ochSignal = srcOchPort.lambda();
        } else {
            // Request and reserve lambda on path
            LinkResourceAllocations linkAllocs = assignWavelength(intent, path);
            if (linkAllocs == null) {
                continue;
            }
            LambdaResourceAllocation lambdaAlloc = getWavelength(path, linkAllocs);
            OmsPort omsPort = (OmsPort) deviceService.getPort(path.src().deviceId(), path.src().port());
            ochSignal = new OchSignal(lambdaAlloc, omsPort.maxFrequency(), omsPort.grid());
        }
        // Create installable optical path intent
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    deviceResourceService.releasePorts(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#end_block

#method_before
void init(String email) {
    // defaults to the demo account
    int ssid = DEMO_SSID;
    this.email = email;
    // obviously not scalable, but good enough for demo code...
    if (EMAIL_0.equals(email)) {
        ssid = 0;
    } else if (EMAIL_1.equals(email)) {
        ssid = 1;
    }
    this.ssid = ssid;
    subscriberId = lookupSubId(ssid);
    XosManager.INSTANCE.setXosUtilsForSubscriber(subscriberId);
    // if we are using the demo account, tell XOS to reset it...
    // if (ssid == DEMO_SSID) {
    XosManager.INSTANCE.initDemoSubscriber();
    // }
    // NOTE: I think the following should work for non-DEMO account...
    currentBundle = new Bundle(BundleFactory.BASIC_BUNDLE);
    initUsers();
}
#method_after
void init(String email) {
    // defaults to the demo account
    int ssid = DEMO_SSID;
    this.email = email;
    // obviously not scalable, but good enough for demo code...
    if (EMAIL_0.equals(email)) {
        ssid = 0;
    } else if (EMAIL_1.equals(email)) {
        ssid = 1;
    }
    this.ssid = ssid;
    subscriberId = lookupSubId(ssid);
    XosManager.INSTANCE.setXosUtilsForSubscriber(subscriberId);
    // call the initdemo API to ensure users are populated in XOS
    XosManager.INSTANCE.initDemoSubscriber();
    // NOTE: I think the following should work for non-DEMO account...
    currentBundle = new Bundle(BundleFactory.BASIC_BUNDLE);
    initUsers();
}
#end_block

#method_before
public synchronized String jsonDashboard() {
    log.info("jsonDashboard()");
    if (email == null) {
        return jsonLogout();
    }
    String BUNDLE_NAME = BUNDLE + "_name";
    String BUNDLE_DESC = BUNDLE + "_desc";
    BundleDescriptor bundleDescriptor = currentBundle.descriptor();
    ObjectNode root = objectNode();
    root.put(BUNDLE_NAME, bundleDescriptor.displayName());
    root.put(BUNDLE_DESC, bundleDescriptor.description());
    root.set(USERS, userJsonArray());
    addSubId(root);
    return root.toString();
}
#method_after
public synchronized String jsonDashboard() {
    log.info("jsonDashboard()");
    if (email == null) {
        return jsonLogout();
    }
    BundleDescriptor bundleDescriptor = currentBundle.descriptor();
    ObjectNode root = objectNode();
    root.put(BUNDLE_NAME, bundleDescriptor.displayName());
    root.put(BUNDLE_DESC, bundleDescriptor.description());
    root.set(USERS, userJsonArray());
    addSubId(root);
    return root.toString();
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary properties = context.getProperties();
    // TODO for reduction check if the new capacity is smaller than the size of the current mapping
    String propertyString = Tools.get(properties, "maxCapacity");
    // Ignore if propertyString is empty
    if (!propertyString.isEmpty()) {
        try {
            int temp = Integer.parseInt(propertyString);
            // Ensure value is non-negative but allow zero as a way to shutdown the link
            if (temp >= 0) {
                maxCapacity = temp;
            }
        } catch (NumberFormatException e) {
            // Malformed arguments lead to no change of value (user should be notified of error)
            log.error("The value \'" + propertyString + "\' for maxCapacity was not parsable as an integer.", e);
        }
    } else {
        // Notify of empty value but do not return (other properties will also go in this function)
        log.error("The value for maxCapacity was set to an empty value.");
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary properties = context.getProperties();
    // TODO for reduction check if the new capacity is smaller than the size of the current mapping
    String propertyString = Tools.get(properties, "maxCapacity");
    // Ignore if propertyString is empty
    if (!propertyString.isEmpty()) {
        try {
            int temp = Integer.parseInt(propertyString);
            // Ensure value is non-negative but allow zero as a way to shutdown the link
            if (temp >= 0) {
                maxCapacity = temp;
            }
        } catch (NumberFormatException e) {
            // Malformed arguments lead to no change of value (user should be notified of error)
            log.error("The value '{}' for maxCapacity was not parsable as an integer.", propertyString, e);
        }
    } else {
        // Notify of empty value but do not return (other properties will also go in this function)
        log.error("The value for maxCapacity was set to an empty value.");
    }
}
#end_block

#method_before
private boolean isAvailable(Intent request, IntentId resource) {
    if (resource == null) {
        return true;
    }
    Set<IntentId> mapping = deviceResourceService.getMapping(resource);
    if (mapping == null) {
        return true;
    }
    // TODO: hardcoded 80% utilization
    return mapping.size() < maxCapacity;
}
#method_after
private boolean isAvailable(Intent request, IntentId resource) {
    if (resource == null) {
        return true;
    }
    Set<IntentId> mapping = deviceResourceService.getMapping(resource);
    if (mapping == null) {
        return true;
    }
    return mapping.size() < maxCapacity;
}
#end_block

#method_before
protected ObjectNode trafficSummaryMessage(StatsType type) {
    ObjectNode payload = objectNode();
    ArrayNode paths = arrayNode();
    payload.set("paths", paths);
    ObjectNode pathNodeN = objectNode();
    ArrayNode linksNodeN = arrayNode();
    ArrayNode labelsN = arrayNode();
    pathNodeN.put("class", "plain").put("traffic", false);
    pathNodeN.set("links", linksNodeN);
    pathNodeN.set("labels", labelsN);
    paths.add(pathNodeN);
    ObjectNode pathNodeT = objectNode();
    ArrayNode linksNodeT = arrayNode();
    ArrayNode labelsT = arrayNode();
    pathNodeT.put("class", "secondary").put("traffic", true);
    pathNodeT.set("links", linksNodeT);
    pathNodeT.set("labels", labelsT);
    paths.add(pathNodeT);
    Map<LinkKey, BiLink> biLinks = consolidateLinks(linkService.getLinks());
    addEdgeLinks(biLinks);
    for (BiLink link : biLinks.values()) {
        boolean bi = link.two != null;
        if (type == FLOW) {
            link.addLoad(getLinkLoad(link.one));
            link.addLoad(bi ? getLinkLoad(link.two) : null);
        } else if (type == PORT) {
            link.addLoad(portStatsService.load(link.one.src()), BPS_THRESHOLD);
            link.addLoad(portStatsService.load(link.one.dst()), BPS_THRESHOLD);
        }
        if (link.hasTraffic) {
            linksNodeT.add(compactLinkString(link.one));
            labelsT.add(type == PORT ? formatBytes(link.rate) + "ps" : formatBytes(link.bytes));
        } else {
            linksNodeN.add(compactLinkString(link.one));
            labelsN.add("");
        }
    }
    return JsonUtils.envelope("showTraffic", 0, payload);
}
#method_after
protected ObjectNode trafficSummaryMessage(StatsType type) {
    ObjectNode payload = objectNode();
    ArrayNode paths = arrayNode();
    payload.set("paths", paths);
    ObjectNode pathNodeN = objectNode();
    ArrayNode linksNodeN = arrayNode();
    ArrayNode labelsN = arrayNode();
    pathNodeN.put("class", "plain").put("traffic", false);
    pathNodeN.set("links", linksNodeN);
    pathNodeN.set("labels", labelsN);
    paths.add(pathNodeN);
    ObjectNode pathNodeT = objectNode();
    ArrayNode linksNodeT = arrayNode();
    ArrayNode labelsT = arrayNode();
    pathNodeT.put("class", "secondary").put("traffic", true);
    pathNodeT.set("links", linksNodeT);
    pathNodeT.set("labels", labelsT);
    paths.add(pathNodeT);
    Map<LinkKey, BiLink> biLinks = consolidateLinks(linkService.getLinks());
    addEdgeLinks(biLinks);
    for (BiLink link : biLinks.values()) {
        boolean bi = link.two != null;
        if (type == FLOW) {
            link.addLoad(getLinkLoad(link.one));
            link.addLoad(bi ? getLinkLoad(link.two) : null);
        } else if (type == PORT) {
            // For a bi-directional traffic links, use
            // the max link rate of either direction
            link.addLoad(portStatsService.load(link.one.src()), BPS_THRESHOLD, portStatsService.load(link.one.dst()), BPS_THRESHOLD);
        }
        if (link.hasTraffic) {
            linksNodeT.add(compactLinkString(link.one));
            labelsT.add(type == PORT ? formatBitRate(link.rate) + "ps" : formatBytes(link.bytes));
        } else {
            linksNodeN.add(compactLinkString(link.one));
            labelsN.add("");
        }
    }
    return JsonUtils.envelope("showTraffic", 0, payload);
}
#end_block

#method_before
private String formatBytes(long bytes) {
    // TODO: multiply everything by 8 to compute bits/second
    String unit;
    double value;
    if (bytes > GB) {
        value = bytes / GB;
        unit = GB_UNIT;
    } else if (bytes > MB) {
        value = bytes / MB;
        unit = MB_UNIT;
    } else if (bytes > KB) {
        value = bytes / KB;
        unit = KB_UNIT;
    } else {
        value = bytes;
        unit = B_UNIT;
    }
    DecimalFormat format = new DecimalFormat("#,###.##");
    return format.format(value) + " " + unit;
}
#method_after
private String formatBytes(long bytes) {
    String unit;
    double value;
    if (bytes > GIGA) {
        value = bytes / GIGA;
        unit = GBYTES_UNIT;
    } else if (bytes > MEGA) {
        value = bytes / MEGA;
        unit = MBYTES_UNIT;
    } else if (bytes > KILO) {
        value = bytes / KILO;
        unit = KBYTES_UNIT;
    } else {
        value = bytes;
        unit = BYTES_UNIT;
    }
    DecimalFormat format = new DecimalFormat("#,###.##");
    return format.format(value) + " " + unit;
}
#end_block

#method_before
void addLoad(Load load, double threshold) {
    if (load != null) {
        this.hasTraffic = hasTraffic || load.rate() > threshold;
        this.bytes += load.latest();
        this.rate += load.rate();
    }
}
#method_after
void addLoad(Load srcLinkLoad, double srcLinkThreshold, Load dstLinkLoad, double dstLinkThreshold) {
    // use the max of link load at source or destination
    if (srcLinkLoad != null) {
        this.hasTraffic = hasTraffic || srcLinkLoad.rate() > srcLinkThreshold;
        this.bytes = srcLinkLoad.latest();
        this.rate = srcLinkLoad.rate();
    }
    if (dstLinkLoad != null) {
        if (dstLinkLoad.rate() > this.rate) {
            this.bytes = dstLinkLoad.latest();
            this.rate = dstLinkLoad.rate();
            this.hasTraffic = hasTraffic || dstLinkLoad.rate() > dstLinkThreshold;
        }
    }
}
#end_block

#method_before
protected ObjectNode trafficSummaryMessage(StatsType type) {
    ObjectNode payload = objectNode();
    ArrayNode paths = arrayNode();
    payload.set("paths", paths);
    ObjectNode pathNodeN = objectNode();
    ArrayNode linksNodeN = arrayNode();
    ArrayNode labelsN = arrayNode();
    pathNodeN.put("class", "plain").put("traffic", false);
    pathNodeN.set("links", linksNodeN);
    pathNodeN.set("labels", labelsN);
    paths.add(pathNodeN);
    ObjectNode pathNodeT = objectNode();
    ArrayNode linksNodeT = arrayNode();
    ArrayNode labelsT = arrayNode();
    pathNodeT.put("class", "secondary").put("traffic", true);
    pathNodeT.set("links", linksNodeT);
    pathNodeT.set("labels", labelsT);
    paths.add(pathNodeT);
    Map<LinkKey, BiLink> biLinks = consolidateLinks(linkService.getLinks());
    addEdgeLinks(biLinks);
    for (BiLink link : biLinks.values()) {
        boolean bi = link.two != null;
        if (type == FLOW) {
            link.addLoad(getLinkLoad(link.one));
            link.addLoad(bi ? getLinkLoad(link.two) : null);
        } else if (type == PORT) {
            // For a bi-directional traffic links, use
            // the max link rate of either direction
            link.addLoad(portStatsService.load(link.one.src()), BPS_THRESHOLD, portStatsService.load(link.one.dst()), BPS_THRESHOLD);
        }
        if (link.hasTraffic) {
            linksNodeT.add(compactLinkString(link.one));
            labelsT.add(type == PORT ? formatBytes(link.rate) + "ps" : formatBytes(link.bytes));
        } else {
            linksNodeN.add(compactLinkString(link.one));
            labelsN.add("");
        }
    }
    return JsonUtils.envelope("showTraffic", 0, payload);
}
#method_after
protected ObjectNode trafficSummaryMessage(StatsType type) {
    ObjectNode payload = objectNode();
    ArrayNode paths = arrayNode();
    payload.set("paths", paths);
    ObjectNode pathNodeN = objectNode();
    ArrayNode linksNodeN = arrayNode();
    ArrayNode labelsN = arrayNode();
    pathNodeN.put("class", "plain").put("traffic", false);
    pathNodeN.set("links", linksNodeN);
    pathNodeN.set("labels", labelsN);
    paths.add(pathNodeN);
    ObjectNode pathNodeT = objectNode();
    ArrayNode linksNodeT = arrayNode();
    ArrayNode labelsT = arrayNode();
    pathNodeT.put("class", "secondary").put("traffic", true);
    pathNodeT.set("links", linksNodeT);
    pathNodeT.set("labels", labelsT);
    paths.add(pathNodeT);
    Map<LinkKey, BiLink> biLinks = consolidateLinks(linkService.getLinks());
    addEdgeLinks(biLinks);
    for (BiLink link : biLinks.values()) {
        boolean bi = link.two != null;
        if (type == FLOW) {
            link.addLoad(getLinkLoad(link.one));
            link.addLoad(bi ? getLinkLoad(link.two) : null);
        } else if (type == PORT) {
            // For a bi-directional traffic links, use
            // the max link rate of either direction
            link.addLoad(portStatsService.load(link.one.src()), BPS_THRESHOLD, portStatsService.load(link.one.dst()), BPS_THRESHOLD);
        }
        if (link.hasTraffic) {
            linksNodeT.add(compactLinkString(link.one));
            labelsT.add(type == PORT ? formatBitRate(link.rate) + "ps" : formatBytes(link.bytes));
        } else {
            linksNodeN.add(compactLinkString(link.one));
            labelsN.add("");
        }
    }
    return JsonUtils.envelope("showTraffic", 0, payload);
}
#end_block

#method_before
private String formatBytes(long bytes) {
    String unit;
    double value;
    // Convert to bits
    long bits = bytes * 8;
    if (bits > G) {
        value = bits / G;
        unit = GBITS_UNIT;
    } else if (bits > M) {
        value = bits / M;
        unit = MBITS_UNIT;
    } else if (bits > K) {
        value = bits / K;
        unit = KBITS_UNIT;
    } else {
        value = bits;
        unit = BITS_UNIT;
    }
    DecimalFormat format = new DecimalFormat("#,###.##");
    return format.format(value) + " " + unit;
}
#method_after
private String formatBytes(long bytes) {
    String unit;
    double value;
    if (bytes > GIGA) {
        value = bytes / GIGA;
        unit = GBYTES_UNIT;
    } else if (bytes > MEGA) {
        value = bytes / MEGA;
        unit = MBYTES_UNIT;
    } else if (bytes > KILO) {
        value = bytes / KILO;
        unit = KBYTES_UNIT;
    } else {
        value = bytes;
        unit = BYTES_UNIT;
    }
    DecimalFormat format = new DecimalFormat("#,###.##");
    return format.format(value) + " " + unit;
}
#end_block

#method_before
private LinkResourceAllocations assignWavelength(Intent intent, Path path) {
    LinkResourceRequest.Builder request = DefaultLinkResourceRequest.builder(intent.id(), path.links()).addLambdaRequest();
    LinkResourceAllocations allocations = linkResourceService.requestResources(request.build());
    checkWavelengthContinuity(allocations, path);
    return allocations;
}
#method_after
private LinkResourceAllocations assignWavelength(Intent intent, Path path) {
    LinkResourceRequest.Builder request = DefaultLinkResourceRequest.builder(intent.id(), path.links()).addLambdaRequest();
    LinkResourceAllocations allocations = linkResourceService.requestResources(request.build());
    if (!checkWavelengthContinuity(allocations, path)) {
        linkResourceService.releaseResources(allocations);
        return null;
    }
    return allocations;
}
#end_block

#method_before
private SparseAnnotations annotations(JsonNode node) {
    if (node == null) {
        return (SparseAnnotations) DefaultAnnotations.EMPTY;
    }
    DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
    Iterator<String> it = node.fieldNames();
    while (it.hasNext()) {
        String k = it.next();
        builder.set(k, node.get(k).asText());
    }
    return builder.build();
}
#method_after
private SparseAnnotations annotations(JsonNode node) {
    if (node == null) {
        return DefaultAnnotations.EMPTY;
    }
    DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
    Iterator<String> it = node.fieldNames();
    while (it.hasNext()) {
        String k = it.next();
        builder.set(k, node.get(k).asText());
    }
    return builder.build();
}
#end_block

#method_before
@GET
@Path("map")
public String privateIpDeleteNotification() {
    log.info("Received vBNG IP address map request");
    String result = "Private IP - Public IP\n";
    VbngConfigurationService vbngConfigurationService = get(VbngConfigurationService.class);
    Map<IpAddress, IpAddress> map = vbngConfigurationService.getIpAddressMappings();
    Iterator<Entry<IpAddress, IpAddress>> entries = map.entrySet().iterator();
    while (entries.hasNext()) {
        Entry<IpAddress, IpAddress> entry = entries.next();
        result = result + entry.getKey() + " - " + entry.getValue() + "\n";
    }
    return result;
}
#method_after
@GET
@Path("map")
@Produces(MediaType.APPLICATION_JSON)
public Response privateIpDeleteNotification() {
    log.info("Received vBNG IP address map request");
    VbngConfigurationService vbngConfigurationService = get(VbngConfigurationService.class);
    Map<IpAddress, IpAddress> map = vbngConfigurationService.getIpAddressMappings();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("map", new IpAddressMapEntryCodec().encode(map.entrySet(), this));
    return ok(result.toString()).build();
}
#end_block

#method_before
private TunnelDescription buildOpticalTunnel(PcepTunnel pcepTunnel, TunnelId tunnelId) {
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    Tunnel.Type tunnelType = null;
    TunnelName name = TunnelName.tunnelName(pcepTunnel.name());
    // add path after codes of tunnel's path merged
    Path path = createPath(pcepTunnel.getHopList(), pcepTunnel.getPathType(), pcepTunnel.getPathState());
    OpticalTunnelEndPoint.Type endPointType = null;
    switch(pcepTunnel.type()) {
        case OCH:
            tunnelType = Tunnel.Type.OCH;
            endPointType = OpticalTunnelEndPoint.Type.LAMBDA;
            break;
        case OTN:
            tunnelType = Tunnel.Type.ODUK;
            endPointType = OpticalTunnelEndPoint.Type.TIMESLOT;
            break;
        case UNI:
            tunnelType = Tunnel.Type.VLAN;
            endPointType = null;
            break;
        default:
            break;
    }
    DeviceId srcDid = deviceId(uri(pcepTunnel.srcDeviceID()));
    DeviceId dstDid = deviceId(uri(pcepTunnel.dstDeviceId()));
    PortNumber srcPort = PortNumber.portNumber(pcepTunnel.srcPort());
    PortNumber dstPort = PortNumber.portNumber(pcepTunnel.dstPort());
    srcPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(srcDid), Optional.of(srcPort), null, endPointType, OpticalLogicId.logicId(0), true);
    dstPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(dstDid), Optional.of(dstPort), null, endPointType, OpticalLogicId.logicId(0), true);
    // basic annotations
    DefaultAnnotations annotations = DefaultAnnotations.builder().set("SLA", String.valueOf(pcepTunnel.getSla())).set("bandwidth", String.valueOf(pcepTunnel.bandWidth()) + BANDWIDTH_UINT).set("index", String.valueOf(pcepTunnel.id())).build();
    // of a OCH tunnel.
    if (pcepTunnel.underLayTunnelId() != 0) {
        DefaultAnnotations extendAnnotations = DefaultAnnotations.builder().set("underLayTunnelIndex", String.valueOf(pcepTunnel.underLayTunnelId())).build();
        annotations = DefaultAnnotations.merge(annotations, extendAnnotations);
    }
    TunnelDescription tunnel = new DefaultTunnelDescription(tunnelId, srcPoint, dstPoint, tunnelType, new DefaultGroupId(0), id(), name, path, annotations);
    return tunnel;
}
#method_after
private TunnelDescription buildOpticalTunnel(PcepTunnel pcepTunnel, TunnelId tunnelId) {
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    Tunnel.Type tunnelType = null;
    TunnelName name = TunnelName.tunnelName(pcepTunnel.name());
    // add path after codes of tunnel's path merged
    Path path = createPath(pcepTunnel.getHopList(), pcepTunnel.getPathType(), pcepTunnel.getPathState());
    OpticalTunnelEndPoint.Type endPointType = null;
    switch(pcepTunnel.type()) {
        case OCH:
            tunnelType = Tunnel.Type.OCH;
            endPointType = OpticalTunnelEndPoint.Type.LAMBDA;
            break;
        case OTN:
            tunnelType = Tunnel.Type.ODUK;
            endPointType = OpticalTunnelEndPoint.Type.TIMESLOT;
            break;
        case UNI:
            tunnelType = Tunnel.Type.VLAN;
            endPointType = null;
            break;
        default:
            break;
    }
    DeviceId srcDid = deviceId(uri(pcepTunnel.srcDeviceID()));
    DeviceId dstDid = deviceId(uri(pcepTunnel.dstDeviceId()));
    PortNumber srcPort = PortNumber.portNumber(pcepTunnel.srcPort());
    PortNumber dstPort = PortNumber.portNumber(pcepTunnel.dstPort());
    srcPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(srcDid), Optional.of(srcPort), null, endPointType, OpticalLogicId.logicId(0), true);
    dstPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(dstDid), Optional.of(dstPort), null, endPointType, OpticalLogicId.logicId(0), true);
    // basic annotations
    DefaultAnnotations annotations = DefaultAnnotations.builder().set("SLA", String.valueOf(pcepTunnel.getSla())).set("bandwidth", String.valueOf(pcepTunnel.bandWidth()) + BANDWIDTH_UINT).set("index", String.valueOf(pcepTunnel.id())).build();
    // of a OCH tunnel.
    if (pcepTunnel.underlayTunnelId() != 0) {
        DefaultAnnotations extendAnnotations = DefaultAnnotations.builder().set("underLayTunnelIndex", String.valueOf(pcepTunnel.underlayTunnelId())).build();
        annotations = DefaultAnnotations.merge(annotations, extendAnnotations);
    }
    TunnelDescription tunnel = new DefaultTunnelDescription(tunnelId, srcPoint, dstPoint, tunnelType, new DefaultGroupId(0), id(), name, path, annotations);
    return tunnel;
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalPathIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    log.debug("Compiling optical path intent between {} and {}", intent.src(), intent.dst());
    // Create rules for forward and reverse path
    List<FlowRule> rules = createRules(intent);
    if (!intent.isBidirectional()) {
        rules.addAll(createReverseRules(intent));
    }
    return Collections.singletonList(new FlowRuleIntent(appId, createRules(intent), intent.resources()));
}
#method_after
@Override
public List<Intent> compile(OpticalPathIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    log.debug("Compiling optical path intent between {} and {}", intent.src(), intent.dst());
    // Create rules for forward and reverse path
    List<FlowRule> rules = createRules(intent);
    if (intent.isBidirectional()) {
        rules.addAll(createReverseRules(intent));
    }
    return Collections.singletonList(new FlowRuleIntent(appId, createRules(intent), intent.resources()));
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Reserve OduClt ports
    if (!deviceResourceService.requestPorts(new HashSet(Arrays.asList(srcPort, dstPort)), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    LinkedList<Intent> intents = new LinkedList<>();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent);
    // Create optical connectivity intent if needed
    if (connIntent == null) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            return Collections.emptyList();
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // FIXME: hardcoded ODU signal type
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(OduSignalType.ODU4).bidirectional(intent.isBidirectional()).build();
        intents.add(connIntent);
    }
    // Create optical circuit intent
    List<FlowRule> rules = new LinkedList<>();
    rules.add(connectPorts(src, connIntent.getSrc()));
    rules.add(connectPorts(connIntent.getDst(), dst));
    // Create flow rules for reverse path
    if (!intent.isBidirectional()) {
        rules.add(connectPorts(connIntent.getSrc(), src));
        rules.add(connectPorts(dst, connIntent.getDst()));
    }
    circuitIntent = new FlowRuleIntent(appId, rules, intent.resources());
    // Save circuit to connectivity intent mapping
    deviceResourceService.requestMapping(connIntent.id(), circuitIntent.id());
    intents.add(circuitIntent);
    return intents;
}
#method_after
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Reserve OduClt ports
    if (!deviceResourceService.requestPorts(new HashSet(Arrays.asList(srcPort, dstPort)), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    LinkedList<Intent> intents = new LinkedList<>();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent);
    // Create optical connectivity intent if needed
    if (connIntent == null) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            return Collections.emptyList();
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // FIXME: hardcoded ODU signal type
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(OduSignalType.ODU4).bidirectional(intent.isBidirectional()).build();
        intents.add(connIntent);
    }
    // Create optical circuit intent
    List<FlowRule> rules = new LinkedList<>();
    rules.add(connectPorts(src, connIntent.getSrc()));
    rules.add(connectPorts(connIntent.getDst(), dst));
    // Create flow rules for reverse path
    if (intent.isBidirectional()) {
        rules.add(connectPorts(connIntent.getSrc(), src));
        rules.add(connectPorts(dst, connIntent.getDst()));
    }
    circuitIntent = new FlowRuleIntent(appId, rules, intent.resources());
    // Save circuit to connectivity intent mapping
    deviceResourceService.requestMapping(connIntent.id(), circuitIntent.id());
    intents.add(circuitIntent);
    return intents;
}
#end_block

#method_before
@Override
public TunnelId tunnelAdded(TunnelDescription tunnel) {
    long bandwidth = Long.parseLong(tunnel.annotations().value("bandwidth"));
    if (bandwidth < MIN_BANDWIDTH || bandwidth > MAX_BANDWIDTH) {
        error("Update failed, invalid bandwidth.");
        return null;
    }
    // endpoints
    OpticalTunnelEndPoint src = (org.onosproject.incubator.net.tunnel.OpticalTunnelEndPoint) tunnel.src();
    OpticalTunnelEndPoint dst = (OpticalTunnelEndPoint) tunnel.dst();
    // devices
    DeviceId srcId = (DeviceId) src.elementId().get();
    DeviceId dstId = (DeviceId) dst.elementId().get();
    // ports
    long srcPort = src.portNumber().get().toLong();
    long dstPort = dst.portNumber().get().toLong();
    // type
    if (tunnel.type() != Tunnel.Type.VLAN) {
        error("Llegal tunnel type. Only support VLAN tunnel creation.");
        return null;
    }
    PcepTunnel pcepTunnel = controller.applyTunnel(srcId, dstId, srcPort, dstPort, bandwidth, tunnel.tunnelName().value());
    checkNotNull(pcepTunnel, TUNNLE_NOT_NULL);
    TunnelDescription tunnelAdded = buildOpticalTunnel(pcepTunnel, null);
    TunnelId tunnelId = service.tunnelAdded(tunnelAdded);
    tunnelMap.put(String.valueOf(pcepTunnel.id()), tunnelId);
    return tunnelId;
}
#method_after
@Override
public TunnelId tunnelAdded(TunnelDescription tunnel) {
    long bandwidth = Long.parseLong(tunnel.annotations().value("bandwidth"));
    if (bandwidth < MIN_BANDWIDTH || bandwidth > MAX_BANDWIDTH) {
        error("Update failed, invalid bandwidth.");
        return null;
    }
    // endpoints
    OpticalTunnelEndPoint src = (org.onosproject.incubator.net.tunnel.OpticalTunnelEndPoint) tunnel.src();
    OpticalTunnelEndPoint dst = (OpticalTunnelEndPoint) tunnel.dst();
    // devices
    DeviceId srcId = (DeviceId) src.elementId().get();
    DeviceId dstId = (DeviceId) dst.elementId().get();
    // ports
    long srcPort = src.portNumber().get().toLong();
    long dstPort = dst.portNumber().get().toLong();
    // type
    if (tunnel.type() != Tunnel.Type.VLAN) {
        error("Illegal tunnel type. Only support VLAN tunnel creation.");
        return null;
    }
    PcepTunnel pcepTunnel = controller.applyTunnel(srcId, dstId, srcPort, dstPort, bandwidth, tunnel.tunnelName().value());
    checkNotNull(pcepTunnel, TUNNLE_NOT_NULL);
    TunnelDescription tunnelAdded = buildOpticalTunnel(pcepTunnel, null);
    TunnelId tunnelId = service.tunnelAdded(tunnelAdded);
    tunnelMap.put(String.valueOf(pcepTunnel.id()), tunnelId);
    return tunnelId;
}
#end_block

#method_before
private TunnelDescription buildOpticalTunnel(PcepTunnel pcepTunnel, TunnelId tunnelId) {
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    Tunnel.Type tunnelType = null;
    TunnelName name = TunnelName.tunnelName(pcepTunnel.name());
    // add path after codes of tunnel's path merged
    Path path = createPath(pcepTunnel.getHopList(), pcepTunnel.getPathType());
    OpticalTunnelEndPoint.Type endPointType = null;
    switch(pcepTunnel.type()) {
        case OCH:
            tunnelType = Tunnel.Type.OCH;
            endPointType = OpticalTunnelEndPoint.Type.LAMBDA;
            break;
        case OTN:
            tunnelType = Tunnel.Type.ODUK;
            endPointType = OpticalTunnelEndPoint.Type.TIMESLOT;
            break;
        case UNI:
            tunnelType = Tunnel.Type.VLAN;
            endPointType = null;
            break;
        default:
            break;
    }
    DeviceId srcDid = deviceId(uri(pcepTunnel.srcDeviceID()));
    DeviceId dstDid = deviceId(uri(pcepTunnel.dstDeviceId()));
    PortNumber srcPort = PortNumber.portNumber(pcepTunnel.srcPort());
    PortNumber dstPort = PortNumber.portNumber(pcepTunnel.dstPort());
    srcPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(srcDid), Optional.of(srcPort), null, endPointType, OpticalLogicId.logicId(0), true);
    dstPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(dstDid), Optional.of(dstPort), null, endPointType, OpticalLogicId.logicId(0), true);
    // basic annotations
    DefaultAnnotations annotations = DefaultAnnotations.builder().set("SLA", String.valueOf(pcepTunnel.getSla())).set("index", String.valueOf(pcepTunnel.id())).build();
    // OCH tunnel has no concept of bandwidth.
    if (tunnelType != Tunnel.Type.OCH) {
        DefaultAnnotations extendAnnotations = DefaultAnnotations.builder().set("bandwidth", String.valueOf(pcepTunnel.bandWidth())).build();
        annotations = DefaultAnnotations.merge(annotations, extendAnnotations);
    }
    // of a OCH tunnel.
    if (pcepTunnel.underLayTunnelId() != 0) {
        DefaultAnnotations extendAnnotations = DefaultAnnotations.builder().set("underLayTunnelIndex", String.valueOf(pcepTunnel.underLayTunnelId())).build();
        annotations = DefaultAnnotations.merge(annotations, extendAnnotations);
    }
    TunnelDescription tunnel = new DefaultTunnelDescription(tunnelId, srcPoint, dstPoint, tunnelType, new DefaultGroupId(0), id(), name, path, annotations);
    return tunnel;
}
#method_after
private TunnelDescription buildOpticalTunnel(PcepTunnel pcepTunnel, TunnelId tunnelId) {
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    Tunnel.Type tunnelType = null;
    TunnelName name = TunnelName.tunnelName(pcepTunnel.name());
    // add path after codes of tunnel's path merged
    Path path = createPath(pcepTunnel.getHopList(), pcepTunnel.getPathType());
    OpticalTunnelEndPoint.Type endPointType = null;
    switch(pcepTunnel.type()) {
        case OCH:
            tunnelType = Tunnel.Type.OCH;
            endPointType = OpticalTunnelEndPoint.Type.LAMBDA;
            break;
        case OTN:
            tunnelType = Tunnel.Type.ODUK;
            endPointType = OpticalTunnelEndPoint.Type.TIMESLOT;
            break;
        case UNI:
            tunnelType = Tunnel.Type.VLAN;
            endPointType = null;
            break;
        default:
            break;
    }
    DeviceId srcDid = deviceId(uri(pcepTunnel.srcDeviceID()));
    DeviceId dstDid = deviceId(uri(pcepTunnel.dstDeviceId()));
    PortNumber srcPort = PortNumber.portNumber(pcepTunnel.srcPort());
    PortNumber dstPort = PortNumber.portNumber(pcepTunnel.dstPort());
    srcPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(srcDid), Optional.of(srcPort), null, endPointType, OpticalLogicId.logicId(0), true);
    dstPoint = new DefaultOpticalTunnelEndPoint(id(), Optional.of(dstDid), Optional.of(dstPort), null, endPointType, OpticalLogicId.logicId(0), true);
    // basic annotations
    DefaultAnnotations annotations = DefaultAnnotations.builder().set("SLA", String.valueOf(pcepTunnel.getSla())).set("bandwidth", String.valueOf(pcepTunnel.bandWidth()) + BANDWIDTH_UINT).set("index", String.valueOf(pcepTunnel.id())).build();
    // of a OCH tunnel.
    if (pcepTunnel.underLayTunnelId() != 0) {
        DefaultAnnotations extendAnnotations = DefaultAnnotations.builder().set("underLayTunnelIndex", String.valueOf(pcepTunnel.underLayTunnelId())).build();
        annotations = DefaultAnnotations.merge(annotations, extendAnnotations);
    }
    TunnelDescription tunnel = new DefaultTunnelDescription(tunnelId, srcPoint, dstPoint, tunnelType, new DefaultGroupId(0), id(), name, path, annotations);
    return tunnel;
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Reserve OCh ports
    if (!deviceResourceService.requestPorts(new HashSet(Arrays.asList(srcPort, dstPort)), intent)) {
        return Collections.emptyList();
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Request and reserve lambda on path
        LinkResourceAllocations linkAllocs = assignWavelength(intent, path);
        if (linkAllocs == null) {
            continue;
        }
        OmsPort omsPort = (OmsPort) deviceService.getPort(path.src().deviceId(), path.src().port());
        // Create installable optical path intent
        LambdaResourceAllocation lambdaAlloc = getWavelength(path, linkAllocs);
        OchSignal ochSignal = getOchSignal(lambdaAlloc, omsPort.minFrequency(), omsPort.grid());
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    deviceResourceService.releasePorts(intent.id());
    return Collections.emptyList();
}
#method_after
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Reserve OCh ports
    if (!deviceResourceService.requestPorts(new HashSet(Arrays.asList(srcPort, dstPort)), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Request and reserve lambda on path
        LinkResourceAllocations linkAllocs = assignWavelength(intent, path);
        if (linkAllocs == null) {
            continue;
        }
        OmsPort omsPort = (OmsPort) deviceService.getPort(path.src().deviceId(), path.src().port());
        // Create installable optical path intent
        LambdaResourceAllocation lambdaAlloc = getWavelength(path, linkAllocs);
        OchSignal ochSignal = getOchSignal(lambdaAlloc, omsPort.minFrequency(), omsPort.grid());
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    deviceResourceService.releasePorts(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Reserve OduClt ports
    if (!deviceResourceService.requestPorts(new HashSet(Arrays.asList(srcPort, dstPort)), intent)) {
        return Collections.emptyList();
    }
    LinkedList<Intent> intents = new LinkedList<>();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent);
    // Create optical connectivity intent if needed
    if (connIntent == null) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            return Collections.emptyList();
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // FIXME: hardcoded ODU signal type
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(OduSignalType.ODU4).build();
        intents.add(connIntent);
    }
    // Create optical circuit intent
    circuitIntent = new FlowRuleIntent(appId, createRules(src, connIntent.getSrc(), dst, connIntent.getDst()), intent.resources());
    // Save circuit to connectivity intent mapping
    deviceResourceService.requestMapping(connIntent.id(), circuitIntent.id());
    intents.add(circuitIntent);
    return intents;
}
#method_after
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Reserve OduClt ports
    if (!deviceResourceService.requestPorts(new HashSet(Arrays.asList(srcPort, dstPort)), intent)) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    LinkedList<Intent> intents = new LinkedList<>();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent);
    // Create optical connectivity intent if needed
    if (connIntent == null) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            return Collections.emptyList();
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // FIXME: hardcoded ODU signal type
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(OduSignalType.ODU4).build();
        intents.add(connIntent);
    }
    // Create optical circuit intent
    circuitIntent = new FlowRuleIntent(appId, createRules(src, connIntent.getSrc(), dst, connIntent.getDst()), intent.resources());
    // Save circuit to connectivity intent mapping
    deviceResourceService.requestMapping(connIntent.id(), circuitIntent.id());
    intents.add(circuitIntent);
    return intents;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(type, signalType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type().ordinal(), signalType);
}
#end_block

#method_before
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = FlowModBuilderHelper.convertGridType(signal.gridType());
                    byte channelSpacing = FlowModBuilderHelper.convertChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (UnsupportedGridTypeException | UnsupportedChannelSpacingException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                OchSignalTypeCriterion sc = (OchSignalTypeCriterion) c;
                Byte signalType = FlowModBuilderHelper.convertSignalType(sc.signalType());
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(signalType));
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_BOS:
            case MPLS_TC:
            case PBB_ISID:
            case TUNNEL_ID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#method_after
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = FlowModBuilderHelper.convertGridType(signal.gridType());
                    byte channelSpacing = FlowModBuilderHelper.convertChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (UnsupportedGridTypeException | UnsupportedChannelSpacingException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                OchSignalTypeCriterion sc = (OchSignalTypeCriterion) c;
                byte signalType = FlowModBuilderHelper.convertOchSignalType(sc.signalType());
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(signalType));
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_BOS:
            case MPLS_TC:
            case PBB_ISID:
            case TUNNEL_ID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#end_block

#method_before
@Override
public int getDeviceCount() {
    return store.getDeviceCount();
}
#method_after
@Override
public int getDeviceCount() {
    checkPermission(Permission.DEVICE_READ);
    return store.getDeviceCount();
}
#end_block

#method_before
@Override
public Iterable<Device> getDevices() {
    return store.getDevices();
}
#method_after
@Override
public Iterable<Device> getDevices() {
    checkPermission(Permission.DEVICE_READ);
    return store.getDevices();
}
#end_block

#method_before
@Override
public Iterable<Device> getAvailableDevices() {
    return store.getAvailableDevices();
}
#method_after
@Override
public Iterable<Device> getAvailableDevices() {
    checkPermission(Permission.DEVICE_READ);
    return store.getAvailableDevices();
}
#end_block

#method_before
@Override
public Device getDevice(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getDevice(deviceId);
}
#method_after
@Override
public Device getDevice(DeviceId deviceId) {
    checkPermission(Permission.DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getDevice(deviceId);
}
#end_block

#method_before
@Override
public MastershipRole getRole(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return mastershipService.getLocalRole(deviceId);
}
#method_after
@Override
public MastershipRole getRole(DeviceId deviceId) {
    checkPermission(Permission.DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return mastershipService.getLocalRole(deviceId);
}
#end_block

#method_before
@Override
public List<Port> getPorts(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getPorts(deviceId);
}
#method_after
@Override
public List<Port> getPorts(DeviceId deviceId) {
    checkPermission(Permission.DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getPorts(deviceId);
}
#end_block

#method_before
@Override
public List<PortStatistics> getPortStatistics(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getPortStatistics(deviceId);
}
#method_after
@Override
public List<PortStatistics> getPortStatistics(DeviceId deviceId) {
    checkPermission(Permission.DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getPortStatistics(deviceId);
}
#end_block

#method_before
@Override
public Port getPort(DeviceId deviceId, PortNumber portNumber) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(portNumber, PORT_NUMBER_NULL);
    return store.getPort(deviceId, portNumber);
}
#method_after
@Override
public Port getPort(DeviceId deviceId, PortNumber portNumber) {
    checkPermission(Permission.DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(portNumber, PORT_NUMBER_NULL);
    return store.getPort(deviceId, portNumber);
}
#end_block

#method_before
@Override
public boolean isAvailable(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.isAvailable(deviceId);
}
#method_after
@Override
public boolean isAvailable(DeviceId deviceId) {
    checkPermission(Permission.DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.isAvailable(deviceId);
}
#end_block

#method_before
@Override
public void addListener(DeviceListener listener) {
    listenerRegistry.addListener(listener);
}
#method_after
@Override
public void addListener(DeviceListener listener) {
    checkPermission(Permission.DEVICE_EVENT);
    listenerRegistry.addListener(listener);
}
#end_block

#method_before
@Override
public void removeListener(DeviceListener listener) {
    listenerRegistry.removeListener(listener);
}
#method_after
@Override
public void removeListener(DeviceListener listener) {
    checkPermission(Permission.DEVICE_EVENT);
    listenerRegistry.removeListener(listener);
}
#end_block

#method_before
@Override
protected void execute() {
    TunnelService service = get(TunnelService.class);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    if ("MPLS".equals(type) || "VXLAN".equals(type) || "GRE".equals(type)) {
        srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
        dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    } else if ("VLAN".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, null, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, null, OpticalLogicId.logicId(0), true);
    } else if ("ODUK".equals(type)) {
        String[] srcArray = src.split("||");
        checkArgument(srcArray.length < 2, "Illegal src formatter.");
        String[] dstArray = dst.split("||");
        checkArgument(dstArray.length < 2, "Illegal dst formatter.");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
    } else if ("OCH".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
    } else {
        print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
        return;
    }
    Collection<Tunnel> tunnelSet = service.queryTunnel(srcPoint, dstPoint);
    for (Tunnel tunnel : tunnelSet) {
        print(FMT, tunnel.src().toString(), tunnel.dst().toString(), tunnel.type(), tunnel.state(), tunnel.providerId(), tunnel.tunnelName(), tunnel.groupId(), showPath(tunnel.path()));
    }
}
#method_after
@Override
protected void execute() {
    Tunnel.Type trueType = null;
    TunnelService service = get(TunnelService.class);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    Collection<Tunnel> tunnelSet = null;
    if (isNull(src) && isNull(dst) && isNull(type) && isNull(tunnelId)) {
        tunnelSet = service.queryAllTunnels();
    }
    if (!isNull(src) && !isNull(dst) && !isNull(type)) {
        TunnelEndPoint srcPoint = null;
        TunnelEndPoint dstPoint = null;
        if ("MPLS".equals(type) || "VXLAN".equals(type) || "GRE".equals(type)) {
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("VLAN".equals(type)) {
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, null, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, null, OpticalLogicId.logicId(0), true);
        } else if ("ODUK".equals(type)) {
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        } else if ("OCH".equals(type)) {
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
        } else {
            print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
            return;
        }
        tunnelSet = service.queryTunnel(srcPoint, dstPoint);
    }
    if (!isNull(type)) {
        if ("MPLS".equals(type)) {
            trueType = Tunnel.Type.MPLS;
        } else if ("VLAN".equals(type)) {
            trueType = Tunnel.Type.VLAN;
        } else if ("VXLAN".equals(type)) {
            trueType = Tunnel.Type.VXLAN;
        } else if ("GRE".equals(type)) {
            trueType = Tunnel.Type.GRE;
        } else if ("ODUK".equals(type)) {
            trueType = Tunnel.Type.ODUK;
        } else if ("OCH".equals(type)) {
            trueType = Tunnel.Type.OCH;
        } else {
            print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
            return;
        }
        tunnelSet = service.queryTunnel(trueType);
    }
    if (!isNull(tunnelId)) {
        TunnelId id = TunnelId.valueOf(tunnelId);
        Tunnel tunnel = service.queryTunnel(id);
        tunnelSet = new HashSet<Tunnel>();
        tunnelSet.add(tunnel);
    }
    if (tunnelSet != null) {
        for (Tunnel tunnel : tunnelSet) {
            print(FMT, tunnel.tunnelId(), tunnel.src().toString(), tunnel.dst().toString(), tunnel.type(), tunnel.state(), tunnel.providerId(), tunnel.tunnelName(), tunnel.groupId(), showPath(tunnel.path()), annotations(tunnel.annotations()));
        }
    }
}
#end_block

#method_before
private String showPath(Path path) {
    StringBuilder builder = new StringBuilder();
    for (Link link : path.links()) {
        builder.append("DeviceId:" + link.src().deviceId() + "||exgress:" + link.src().port().toString());
        builder.append("DeviceId:" + link.dst().deviceId() + "||exgress:" + link.dst().port().toString());
        builder.append("--");
    }
    builder.deleteCharAt(builder.length() - 1);
    return builder.toString();
}
#method_after
private String showPath(Path path) {
    if (path == null) {
        return "";
    }
    StringBuilder builder = new StringBuilder("(");
    for (Link link : path.links()) {
        builder.append("(DeviceId:" + link.src().deviceId() + " Port:" + link.src().port().toString());
        builder.append(" DeviceId:" + link.dst().deviceId() + " Port:" + link.dst().port().toString() + ")");
    }
    builder.append(annotations(path.annotations()) + ")");
    return builder.toString();
}
#end_block

#method_before
@Override
protected void execute() {
    TunnelService service = get(TunnelService.class);
    ApplicationId appId = new DefaultApplicationId(1, consumerId);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    if ("MPLS".equals(type) || "VXLAN".equals(type) || "GRE".equals(type)) {
        srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
        dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    } else if ("VLAN".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, null, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, null, OpticalLogicId.logicId(0), true);
    } else if ("ODUK".equals(type)) {
        String[] srcArray = src.split("||");
        checkArgument(srcArray.length < 2, "Illegal src formatter.");
        String[] dstArray = dst.split("||");
        checkArgument(dstArray.length < 2, "Illegal dst formatter.");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
    } else if ("OCH".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
    } else {
        print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
        return;
    }
    service.returnTunnel(appId, srcPoint, dstPoint);
}
#method_after
@Override
protected void execute() {
    Tunnel.Type trueType = null;
    TunnelService service = get(TunnelService.class);
    ApplicationId appId = new DefaultApplicationId(1, consumerId);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    if (!isNull(src) && !isNull(dst) && !isNull(type)) {
        TunnelEndPoint srcPoint = null;
        TunnelEndPoint dstPoint = null;
        if ("MPLS".equals(type)) {
            trueType = Tunnel.Type.MPLS;
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("VXLAN".equals(type)) {
            trueType = Tunnel.Type.VXLAN;
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("GRE".equals(type)) {
            trueType = Tunnel.Type.GRE;
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("VLAN".equals(type)) {
            trueType = Tunnel.Type.VLAN;
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, null, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, null, OpticalLogicId.logicId(0), true);
        } else if ("ODUK".equals(type)) {
            trueType = Tunnel.Type.ODUK;
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        } else if ("OCH".equals(type)) {
            trueType = Tunnel.Type.OCH;
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
        } else {
            print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
            return;
        }
        service.returnTunnel(appId, srcPoint, dstPoint, trueType);
    }
    if (!isNull(tunnelId)) {
        TunnelId id = TunnelId.valueOf(tunnelId);
        service.returnTunnel(appId, id);
    }
    if (!isNull(tunnelName)) {
        TunnelName name = TunnelName.tunnelName(tunnelName);
        service.returnTunnel(appId, name);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    TunnelService service = get(TunnelService.class);
    ApplicationId appId = new DefaultApplicationId(1, consumerId);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    if ("MPLS".equals(type) || "VXLAN".equals(type) || "GRE".equals(type)) {
        srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
        dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    } else if ("VLAN".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, null, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, null, OpticalLogicId.logicId(0), true);
    } else if ("ODUK".equals(type)) {
        String[] srcArray = src.split("||");
        checkArgument(srcArray.length < 2, "Illegal src formatter.");
        String[] dstArray = dst.split("||");
        checkArgument(dstArray.length < 2, "Illegal dst formatter.");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
    } else if ("OCH".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
    } else {
        print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
        return;
    }
    Collection<Tunnel> tunnelSet = service.borrowTunnel(appId, srcPoint, dstPoint);
    for (Tunnel tunnel : tunnelSet) {
        print(FMT, tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.providerId(), tunnel.tunnelName(), tunnel.groupId());
    }
}
#method_after
@Override
protected void execute() {
    Collection<Tunnel> tunnelSet = null;
    Tunnel.Type trueType = null;
    TunnelService service = get(TunnelService.class);
    ApplicationId appId = new DefaultApplicationId(1, consumerId);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    if (!isNull(src) && !isNull(dst) && !isNull(type)) {
        TunnelEndPoint srcPoint = null;
        TunnelEndPoint dstPoint = null;
        if ("MPLS".equals(type)) {
            trueType = Tunnel.Type.MPLS;
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("VXLAN".equals(type)) {
            trueType = Tunnel.Type.VXLAN;
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("GRE".equals(type)) {
            trueType = Tunnel.Type.GRE;
            srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
            dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
        } else if ("VLAN".equals(type)) {
            trueType = Tunnel.Type.VLAN;
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, null, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, null, OpticalLogicId.logicId(0), true);
        } else if ("ODUK".equals(type)) {
            trueType = Tunnel.Type.ODUK;
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        } else if ("OCH".equals(type)) {
            trueType = Tunnel.Type.OCH;
            String[] srcArray = src.split("-");
            String[] dstArray = dst.split("-");
            srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
            dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.TIMESLOT, OpticalLogicId.logicId(0), true);
        } else {
            print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
            return;
        }
        tunnelSet = service.borrowTunnel(appId, srcPoint, dstPoint, trueType);
    }
    if (!isNull(tunnelId)) {
        TunnelId id = TunnelId.valueOf(tunnelId);
        Tunnel tunnel = service.borrowTunnel(appId, id);
        tunnelSet = new HashSet<Tunnel>();
        tunnelSet.add(tunnel);
    }
    if (!isNull(tunnelName)) {
        TunnelName name = TunnelName.tunnelName(tunnelName);
        tunnelSet = service.borrowTunnel(appId, name);
    }
    for (Tunnel tunnel : tunnelSet) {
        print(FMT, tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.providerId(), tunnel.tunnelName(), tunnel.groupId());
    }
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    idGenerator = coreService.getIdGenerator(runnelOpTopoic);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    orderRelationship = storageService.<ApplicationId, Set<TunnelSubscription>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    idGenerator = coreService.getIdGenerator(runnelOpTopoic);
    log.info("Started");
}
#end_block

#method_before
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        DefaultAnnotations oldAnno = (DefaultAnnotations) old.annotations();
        SparseAnnotations newAnno = (SparseAnnotations) tunnel.annotations();
        Tunnel newT = new DefaultTunnel(old.providerId(), old.src(), old.dst(), old.type(), old.state(), old.groupId(), old.tunnelId(), old.tunnelName(), old.path(), DefaultAnnotations.merge(oldAnno, newAnno));
        tunnelIdAsKeyStore.remove(tunnel.tunnelId());
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(idGenerator.getNewId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        if (tunnelnameSet == null) {
            tunnelnameSet = new HashSet<TunnelId>();
        }
        tunnelnameSet.add(tunnelId);
        tunnelNameAsKeyStore.put(tunnel.tunnelName(), tunnelnameSet);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        if (srcAndDstKeySet == null) {
            srcAndDstKeySet = new HashSet<TunnelId>();
        }
        srcAndDstKeySet.add(tunnelId);
        srcAndDstKeyStore.put(key, srcAndDstKeySet);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        if (typeKeySet == null) {
            typeKeySet = new HashSet<TunnelId>();
        }
        typeKeySet.add(tunnelId);
        typeKeyStore.put(tunnel.type(), typeKeySet);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#method_after
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        DefaultAnnotations oldAnno = (DefaultAnnotations) old.annotations();
        SparseAnnotations newAnno = (SparseAnnotations) tunnel.annotations();
        Tunnel newT = new DefaultTunnel(old.providerId(), old.src(), old.dst(), old.type(), old.state(), old.groupId(), old.tunnelId(), old.tunnelName(), old.path(), DefaultAnnotations.merge(oldAnno, newAnno));
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(idGenerator.getNewId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        if (tunnelnameSet == null) {
            tunnelnameSet = new HashSet<TunnelId>();
        }
        tunnelnameSet.add(tunnelId);
        tunnelNameAsKeyStore.put(tunnel.tunnelName(), tunnelnameSet);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        if (srcAndDstKeySet == null) {
            srcAndDstKeySet = new HashSet<TunnelId>();
        }
        srcAndDstKeySet.add(tunnelId);
        srcAndDstKeyStore.put(key, srcAndDstKeySet);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        if (typeKeySet == null) {
            typeKeySet = new HashSet<TunnelId>();
        }
        typeKeySet.add(tunnelId);
        typeKeyStore.put(tunnel.type(), typeKeySet);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    service = tunnelProviderRegistry.register(this);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    service = tunnelProviderRegistry.register(this);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    tunnelProviderRegistry.unregister(this);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    tunnelProviderRegistry.unregister(this);
    log.info("Stopped");
}
#end_block

#method_before
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                OchSignal signal = ochSignalCriterion.lambda();
                Optional<Byte> gridType = FlowModBuilderHelper.convertGridType(signal.gridType());
                Optional<Byte> channelSpacing = FlowModBuilderHelper.convertChannelSpacing(signal.channelSpacing());
                gridType.flatMap(grid -> channelSpacing.map(spacing -> new CircuitSignalID(grid, spacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()))).ifPresent(sigId -> mBuilder.setExact(MatchField.OCH_SIGID, sigId));
                break;
            case OCH_SIGTYPE:
                OpticalSignalTypeCriterion sc = (OpticalSignalTypeCriterion) c;
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(sc.signalType()));
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_BOS:
            case MPLS_TC:
            case PBB_ISID:
            case TUNNEL_ID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#method_after
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = FlowModBuilderHelper.convertGridType(signal.gridType());
                    byte channelSpacing = FlowModBuilderHelper.convertChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (UnsupportedGridTypeException | UnsupportedChannelSpacingException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                OpticalSignalTypeCriterion sc = (OpticalSignalTypeCriterion) c;
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(sc.signalType()));
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_BOS:
            case MPLS_TC:
            case PBB_ISID:
            case TUNNEL_ID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#end_block

#method_before
static Optional<Byte> convertGridType(GridType type) {
    switch(type) {
        case DWDM:
            return Optional.of((byte) 1);
        case CWDM:
            return Optional.of((byte) 2);
        case FLEX:
            return Optional.of((byte) 3);
        default:
            log.info("GridType {} is not supported", type);
            return Optional.empty();
    }
}
#method_after
static byte convertGridType(GridType type) {
    // for the following values
    switch(type) {
        case DWDM:
            // OFPGRIDT_DWDM of enum ofp_grid_type
            return 1;
        case CWDM:
            // OFPGRIDT_CWDM of enum ofp_grid_type
            return 2;
        case FLEX:
            // OFPGRIDT_FLEX of enum ofp_grid_type
            return 3;
        default:
            throw new UnsupportedGridTypeException(type);
    }
}
#end_block

#method_before
static Optional<Byte> convertChannelSpacing(ChannelSpacing spacing) {
    switch(spacing) {
        case CHL_100GHZ:
            return Optional.of((byte) 1);
        case CHL_50GHZ:
            return Optional.of((byte) 2);
        case CHL_25GHZ:
            return Optional.of((byte) 3);
        case CHL_12P5GHZ:
            return Optional.of((byte) 4);
        case CHL_6P25GHZ:
            return Optional.of((byte) 5);
        default:
            log.info("ChannelSpacing {} is not supported", spacing);
            return Optional.empty();
    }
}
#method_after
static byte convertChannelSpacing(ChannelSpacing spacing) {
    // for the following values
    switch(spacing) {
        case CHL_100GHZ:
            // OFPCS_100GHZ of enum ofp_chl_spacing
            return 1;
        case CHL_50GHZ:
            // OFPCS_50GHZ of enum ofp_chl_spacing
            return 2;
        case CHL_25GHZ:
            // OFPCS_25GHZ of enum ofp_chl_spacing
            return 3;
        case CHL_12P5GHZ:
            // OFPCS_12P5GHZ of enum ofp_chl_spacing
            return 4;
        case CHL_6P25GHZ:
            // OFPCS_6P25GHZ of enum ofp_chl_spacing
            return 5;
        default:
            throw new UnsupportedChannelSpacingException(spacing);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    VoltTenantService service = get(VoltTenantService.class);
    VoltTenant newTenant = VoltTenant.builder().withServiceSpecificId(serviceSpecificId).withVlanId(vlanId).withPort(ConnectPoint.deviceConnectPoint(port)).build();
    log.debug("tenant: {}", newTenant);
    service.addTenant(newTenant);
}
#method_after
@Override
protected void execute() {
    VoltTenantService service = get(VoltTenantService.class);
    VoltTenant newTenant = VoltTenant.builder().withServiceSpecificId(serviceSpecificId).withVlanId(vlanId).withPort(ConnectPoint.deviceConnectPoint(port)).build();
    service.addTenant(newTenant);
}
#end_block

#method_before
@Override
protected void execute() {
    TunnelAdminService adminService = get(TunnelAdminService.class);
    ProviderId producer = ProviderId.NONE;
    IpTunnelPoint srcPoint = IpTunnelPoint.ipTunnelPoint(IpAddress.valueOf(src));
    IpTunnelPoint dstPoint = IpTunnelPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    adminService.removeTunnels(srcPoint, dstPoint, producer);
}
#method_after
@Override
protected void execute() {
    TunnelAdminService adminService = get(TunnelAdminService.class);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    if ("MPLS".equals(type) || "VLAN".equals(type) || "VXLAN".equals(type) || "GRE".equals(type)) {
        srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
        dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    } else if ("ODUK".equals(type) || "OCH".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
    } else {
        print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
        return;
    }
    adminService.removeTunnels(srcPoint, dstPoint, producerName);
}
#end_block

#method_before
@Override
protected void execute() {
    TunnelService service = get(TunnelService.class);
    IpTunnelPoint srcPoint = IpTunnelPoint.ipTunnelPoint(IpAddress.valueOf(src));
    IpTunnelPoint dstPoint = IpTunnelPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    Collection<Tunnel> tunnelSet = service.queryTunnel(srcPoint, dstPoint);
    for (Tunnel tunnel : tunnelSet) {
        print(FMT, tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.providerId(), tunnel.tunnelName(), tunnel.groupId());
    }
}
#method_after
@Override
protected void execute() {
    TunnelService service = get(TunnelService.class);
    ProviderId producerName = new ProviderId("default", "org.onosproject.provider.tunnel.default");
    TunnelEndPoint srcPoint = null;
    TunnelEndPoint dstPoint = null;
    if ("MPLS".equals(type) || "VLAN".equals(type) || "VXLAN".equals(type) || "GRE".equals(type)) {
        srcPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(src));
        dstPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dst));
    } else if ("ODUK".equals(type) || "OCH".equals(type)) {
        String[] srcArray = src.split("-");
        String[] dstArray = dst.split("-");
        srcPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(srcArray[0])), Optional.of(PortNumber.portNumber(srcArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
        dstPoint = new DefaultOpticalTunnelEndPoint(producerName, Optional.of(DeviceId.deviceId(dstArray[0])), Optional.of(PortNumber.portNumber(dstArray[1])), null, OpticalTunnelEndPoint.Type.LAMBDA, OpticalLogicId.logicId(0), true);
    } else {
        print("Illegal tunnel type. Please input MPLS, VLAN, VXLAN, GRE, ODUK or OCH.");
        return;
    }
    Collection<Tunnel> tunnelSet = service.queryTunnel(srcPoint, dstPoint);
    for (Tunnel tunnel : tunnelSet) {
        print(FMT, tunnel.src().toString(), tunnel.dst().toString(), tunnel.type(), tunnel.state(), tunnel.providerId(), tunnel.tunnelName(), tunnel.groupId());
    }
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    idGenerator = coreService.getIdGenerator(TunnelAdminService.TUNNEL_OP_TOPIC);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withClockService(new WallclockClockManager<>()).build();
    idGenerator = coreService.getIdGenerator(runnelOpTopoic);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    messageHandlingExecutor.shutdown();
    tunnelIdAsKeyStore.destroy();
    srcAndDstKeyStore.destroy();
    typeKeyStore.destroy();
    tunnelNameAsKeyStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    tunnelIdAsKeyStore.destroy();
    srcAndDstKeyStore.destroy();
    typeKeyStore.destroy();
    tunnelNameAsKeyStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void createOrUpdateTunnel(Tunnel tunnel) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null || !"".equals(tunnel.tunnelId())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), old.tunnelId(), tunnel.isDurable(), tunnel.tunnelName(), tunnel.annotations());
        tunnelIdAsKeyStore.remove(tunnel.tunnelId());
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
    } else {
        TunnelId tunnelId = TunnelId.valueOf(idGenerator.getNewId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), tunnelId, tunnel.isDurable(), tunnel.tunnelName(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        tunnelnameSet.add(tunnelId);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        srcAndDstKeySet.add(tunnelId);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        typeKeySet.add(tunnelId);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
    }
}
#method_after
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), old.tunnelId(), tunnel.tunnelName(), tunnel.annotations());
        tunnelIdAsKeyStore.remove(tunnel.tunnelId());
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(idGenerator.getNewId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        if (tunnelnameSet == null) {
            tunnelnameSet = new HashSet<TunnelId>();
        }
        tunnelnameSet.add(tunnelId);
        tunnelNameAsKeyStore.put(tunnel.tunnelName(), tunnelnameSet);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        if (srcAndDstKeySet == null) {
            srcAndDstKeySet = new HashSet<TunnelId>();
        }
        srcAndDstKeySet.add(tunnelId);
        srcAndDstKeyStore.put(key, srcAndDstKeySet);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        if (typeKeySet == null) {
            typeKeySet = new HashSet<TunnelId>();
        }
        typeKeySet.add(tunnelId);
        typeKeyStore.put(tunnel.type(), typeKeySet);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#end_block

#method_before
@Override
public void deleteTunnel(TunnelId tunnelId) {
    Tunnel deletedTunnel = tunnelIdAsKeyStore.get(tunnelId);
    tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(tunnelId);
    tunnelIdAsKeyStore.remove(tunnelId);
    TunnelKey key = new TunnelKey(deletedTunnel.src(), deletedTunnel.dst());
    srcAndDstKeyStore.get(key).remove(tunnelId);
    typeKeyStore.get(deletedTunnel.type()).remove(tunnelId);
    TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
    notifyDelegate(event);
}
#method_after
@Override
public void deleteTunnel(TunnelId tunnelId) {
    Tunnel deletedTunnel = tunnelIdAsKeyStore.get(tunnelId);
    if (deletedTunnel == null) {
        return;
    }
    tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(tunnelId);
    tunnelIdAsKeyStore.remove(tunnelId);
    TunnelKey key = new TunnelKey(deletedTunnel.src(), deletedTunnel.dst());
    srcAndDstKeyStore.get(key).remove(tunnelId);
    typeKeyStore.get(deletedTunnel.type()).remove(tunnelId);
    TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
    notifyDelegate(event);
}
#end_block

#method_before
@Override
public void deleteTunnel(TunnelPoint src, TunnelPoint dst, Type type, ProviderId producerName) {
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyStore.get(key);
    Tunnel deletedTunnel = null;
    TunnelEvent event = null;
    List<TunnelEvent> ls = new ArrayList<TunnelEvent>();
    for (TunnelId id : idSet) {
        deletedTunnel = tunnelIdAsKeyStore.get(id);
        event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
        ls.add(event);
        if (producerName.equals(deletedTunnel.providerId()) && type.equals(deletedTunnel.type())) {
            tunnelIdAsKeyStore.remove(deletedTunnel.tunnelId());
            tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(deletedTunnel.tunnelId());
            srcAndDstKeyStore.get(key).remove(deletedTunnel.tunnelId());
            typeKeyStore.get(deletedTunnel.type()).remove(deletedTunnel.tunnelId());
        }
    }
    notifyDelegate(ls);
}
#method_after
@Override
public void deleteTunnel(TunnelEndPoint src, TunnelEndPoint dst, ProviderId producerName) {
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyStore.get(key);
    if (idSet == null) {
        return;
    }
    Tunnel deletedTunnel = null;
    TunnelEvent event = null;
    List<TunnelEvent> ls = new ArrayList<TunnelEvent>();
    for (TunnelId id : idSet) {
        deletedTunnel = tunnelIdAsKeyStore.get(id);
        event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
        ls.add(event);
        if (producerName.equals(deletedTunnel.providerId())) {
            tunnelIdAsKeyStore.remove(deletedTunnel.tunnelId());
            tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(deletedTunnel.tunnelId());
            srcAndDstKeyStore.get(key).remove(deletedTunnel.tunnelId());
            typeKeyStore.get(deletedTunnel.type()).remove(deletedTunnel.tunnelId());
        }
    }
    notifyDelegate(ls);
}
#end_block

#method_before
private boolean deleteOrder(Order order) {
    Set<Order> orderSet = orderRelationship.get(order.consumerId());
    if (orderSet.contains(order)) {
        orderSet.remove(order);
        return true;
    }
    return false;
}
#method_after
private boolean deleteOrder(TunnelSubscription order) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(order.consumerId());
    if (orderSet == null) {
        return true;
    }
    if (orderSet.contains(order)) {
        orderSet.remove(order);
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryTunnel(Type type) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    Set<TunnelId> tunnelIds = typeKeyStore.get(type);
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#method_after
@Override
public Collection<Tunnel> queryTunnel(Type type) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    Set<TunnelId> tunnelIds = typeKeyStore.get(type);
    if (tunnelIds == null) {
        return Collections.emptySet();
    }
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryTunnel(TunnelPoint src, TunnelPoint dst) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> tunnelIds = srcAndDstKeyStore.get(key);
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#method_after
@Override
public Collection<Tunnel> queryTunnel(TunnelEndPoint src, TunnelEndPoint dst) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> tunnelIds = srcAndDstKeyStore.get(key);
    if (tunnelIds == null) {
        return Collections.emptySet();
    }
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#end_block

#method_before
static TunnelKey tunnelKey(TunnelPoint src, TunnelPoint dst) {
    return new TunnelKey(src, dst);
}
#method_after
static TunnelKey tunnelKey(TunnelEndPoint src, TunnelEndPoint dst) {
    return new TunnelKey(src, dst);
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    store.createOrUpdateTunnel(tunnel);
    if (tunnel.providerId() != null) {
        TunnelProvider provider = getProvider(tunnel.providerId());
        if (provider != null) {
            provider.setupTunnel(tunnel, path);
        }
    } else {
        Set<ProviderId> ids = getProviders();
        for (ProviderId providerId : ids) {
            TunnelProvider provider = getProvider(providerId);
            provider.setupTunnel(tunnel, path);
        }
    }
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    store.createOrUpdateTunnel(tunnel);
    if (tunnel.providerId() != null) {
        TunnelProvider provider = getProvider(tunnel.providerId());
        if (provider != null) {
            provider.updateTunnel(tunnel, path);
        }
    } else {
        Set<ProviderId> ids = getProviders();
        for (ProviderId providerId : ids) {
            TunnelProvider provider = getProvider(providerId);
            provider.updateTunnel(tunnel, path);
        }
    }
}
#end_block

#method_before
@Override
public void removeTunnels(TunnelPoint src, TunnelPoint dst, Type type, ProviderId producerName) {
    store.deleteTunnel(src, dst, type, producerName);
    Collection<Tunnel> setTunnels = store.queryTunnel(src, dst);
    for (Tunnel tunnel : setTunnels) {
        if (producerName != null && !tunnel.providerId().equals(producerName) || !type.equals(tunnel.type())) {
            continue;
        }
        if (tunnel.providerId() != null) {
            TunnelProvider provider = getProvider(tunnel.providerId());
            if (provider != null) {
                provider.releaseTunnel(tunnel);
            }
        } else {
            Set<ProviderId> ids = getProviders();
            for (ProviderId providerId : ids) {
                TunnelProvider provider = getProvider(providerId);
                provider.releaseTunnel(tunnel);
            }
        }
    }
}
#method_after
@Override
public void removeTunnels(TunnelEndPoint src, TunnelEndPoint dst, ProviderId producerName) {
    store.deleteTunnel(src, dst, producerName);
    Collection<Tunnel> setTunnels = store.queryTunnel(src, dst);
    for (Tunnel tunnel : setTunnels) {
        if (producerName != null && !tunnel.providerId().equals(producerName)) {
            continue;
        }
        if (tunnel.providerId() != null) {
            TunnelProvider provider = getProvider(tunnel.providerId());
            if (provider != null) {
                provider.releaseTunnel(tunnel);
            }
        } else {
            Set<ProviderId> ids = getProviders();
            for (ProviderId providerId : ids) {
                TunnelProvider provider = getProvider(providerId);
                provider.releaseTunnel(tunnel);
            }
        }
    }
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryTunnel(TunnelPoint src, TunnelPoint dst) {
    return store.queryTunnel(src, dst);
}
#method_after
@Override
public Collection<Tunnel> queryTunnel(TunnelEndPoint src, TunnelEndPoint dst) {
    return store.queryTunnel(src, dst);
}
#end_block

#method_before
@Override
public void tunnelAdded(TunnelDescription tunnel) {
    Tunnel storedTunnel = new DefaultTunnel(provider().id(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), tunnel.id(), tunnel.tunnelName(), tunnel.annotations());
    store.createOrUpdateTunnel(storedTunnel);
}
#method_after
@Override
public TunnelId tunnelAdded(TunnelDescription tunnel) {
    Tunnel storedTunnel = new DefaultTunnel(provider().id(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), tunnel.id(), tunnel.tunnelName(), tunnel.annotations());
    return store.createOrUpdateTunnel(storedTunnel);
}
#end_block

#method_before
@Override
public void notify(TunnelEvent event) {
    // TODO Auto-generated method stub
    if (event != null) {
        eventDispatcher.post(event);
    }
}
#method_after
@Override
public void notify(TunnelEvent event) {
    if (event != null) {
        eventDispatcher.post(event);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service);
    if (outputJson()) {
        print("%s", json(coreService, flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#method_after
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service);
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#end_block

#method_before
private ObjectNode json(CoreService coreService, ObjectMapper mapper, FlowEntry flow) {
    ObjectNode result = mapper.createObjectNode();
    ArrayNode crit = mapper.createArrayNode();
    for (Criterion c : flow.selector().criteria()) {
        crit.add(c.toString());
    }
    ArrayNode instr = mapper.createArrayNode();
    for (Instruction i : flow.treatment().allInstructions()) {
        instr.add(i.toString());
    }
    ApplicationId appCoreId = coreService.getAppId(flow.appId());
    String appName = appCoreId == null ? Short.toString(flow.appId()) : appCoreId.name();
    result.put("flowId", Long.toHexString(flow.id().value())).put("state", flow.state().toString()).put("bytes", flow.bytes()).put("packets", flow.packets()).put("life", flow.life()).put("tableId", flow.tableId()).put("appId", appName).put("payLoad", flow.payLoad().payLoad().toString());
    result.set("selector", crit);
    result.set("treatment", instr);
    return result;
}
#method_after
private JsonNode json(Iterable<Device> devices, Map<Device, List<FlowEntry>> flows) {
    ObjectMapper mapper = new ObjectMapper();
    ArrayNode result = mapper.createArrayNode();
    for (Device device : devices) {
        result.add(json(mapper, device, flows.get(device)));
    }
    return result;
}
#end_block

#method_before
@Override
protected void execute() {
    ApplicationAdminService applicationAdminService = get(ApplicationAdminService.class);
    Set<Permission> newPermSet = Sets.newHashSet();
    if (command.equals(ADD)) {
        ApplicationId appId = applicationAdminService.getId(name);
        Application app = applicationAdminService.getApplication(appId);
        if (appId == null) {
            print("No such application: %s", name);
            return;
        }
        for (String perm : permissions) {
            try {
                Permission permission = Permission.valueOf(perm);
                newPermSet.add(permission);
            } catch (IllegalArgumentException e) {
                print("%s is not a valid permission.", perm);
                return;
            }
        }
        Set<Permission> oldPermSet = applicationAdminService.getPermissions(appId);
        if (oldPermSet != null) {
            newPermSet.addAll(oldPermSet);
        }
        applicationAdminService.setPermissions(appId, ImmutableSet.copyOf(newPermSet));
    } else if (command.equals(REMOVE)) {
        ApplicationId appId = applicationAdminService.getId(name);
        Application app = applicationAdminService.getApplication(appId);
        if (appId == null) {
            print("No such application: %s", name);
            return;
        }
        Set<Permission> oldPermSet = applicationAdminService.getPermissions(appId);
        if (oldPermSet == null) {
            oldPermSet = ImmutableSet.of();
        }
        Set<String> clearPermSet = Sets.newHashSet(permissions);
        newPermSet.addAll(oldPermSet.stream().filter(perm -> !clearPermSet.contains(perm.name().toUpperCase())).collect(Collectors.toList()));
        applicationAdminService.setPermissions(appId, ImmutableSet.copyOf(newPermSet));
    }
}
#method_after
@Override
protected void execute() {
    ApplicationAdminService applicationAdminService = get(ApplicationAdminService.class);
    Set<Permission> newPermSet = Sets.newHashSet();
    if (command.equals(ADD)) {
        ApplicationId appId = applicationAdminService.getId(name);
        if (appId == null) {
            print("No such application: %s", name);
            return;
        }
        Application app = applicationAdminService.getApplication(appId);
        for (String perm : permissions) {
            try {
                Permission permission = Permission.valueOf(perm);
                newPermSet.add(permission);
            } catch (IllegalArgumentException e) {
                print("%s is not a valid permission.", perm);
                return;
            }
        }
        Set<Permission> oldPermSet = applicationAdminService.getPermissions(appId);
        if (oldPermSet != null) {
            newPermSet.addAll(oldPermSet);
        } else {
            newPermSet.addAll(app.permissions());
        }
        applicationAdminService.setPermissions(appId, ImmutableSet.copyOf(newPermSet));
    } else if (command.equals(REMOVE)) {
        ApplicationId appId = applicationAdminService.getId(name);
        Application app = applicationAdminService.getApplication(appId);
        if (appId == null) {
            print("No such application: %s", name);
            return;
        }
        Set<Permission> oldPermSet = applicationAdminService.getPermissions(appId);
        if (oldPermSet == null) {
            oldPermSet = app.permissions();
        }
        Set<String> clearPermSet = Sets.newHashSet(permissions);
        newPermSet.addAll(oldPermSet.stream().filter(perm -> !clearPermSet.contains(perm.name().toUpperCase())).collect(Collectors.toList()));
        applicationAdminService.setPermissions(appId, ImmutableSet.copyOf(newPermSet));
    } else if (command.equals(CLEAR)) {
        ApplicationId appId = applicationAdminService.getId(name);
        if (appId == null) {
            print("No such application: %s", name);
            return;
        }
        applicationAdminService.setPermissions(appId, ImmutableSet.of());
        print("Cleared the permission list of %s.", appId.name());
    } else if (command.equals(LIST)) {
        ApplicationId appId = applicationAdminService.getId(name);
        if (appId == null) {
            print("No such application: %s", name);
            return;
        }
        Application app = applicationAdminService.getApplication(appId);
        Set<Permission> userPermissions = applicationAdminService.getPermissions(appId);
        Set<Permission> defaultPermissions = app.permissions();
        print("Application Role");
        print("\trole=%s", app.role().name());
        if (defaultPermissions != null) {
            if (!defaultPermissions.isEmpty()) {
                print("Default permissions (specified in app.xml)");
                for (Permission perm : defaultPermissions) {
                    print("\tpermission=%s", perm.name());
                }
            } else {
                print("(No default permissions specified in app.xml)");
            }
        }
        if (userPermissions != null) {
            if (!userPermissions.isEmpty()) {
                print("User permissions");
                for (Permission perm : userPermissions) {
                    print("\tpermission=%s", perm.name());
                }
            } else {
                print("(User has removed all the permissions");
            }
        }
    }
}
#end_block

#method_before
private PortDescription parsePort(JsonNode node) {
    Port.Type type = Port.Type.valueOf(node.path("type").asText("COPPER"));
    switch(type) {
        case COPPER:
            return new DefaultPortDescription(portNumber(node.path("port").asLong(0)), node.path("enabled").asBoolean(true), type, node.path("speed").asLong(1_000));
        case FIBER:
            // Currently, assume OMS when FIBER. Provide sane defaults.
            final Frequency min = Frequency.ofTHz(193.1);
            return new OmsPortDescription(portNumber(node.path("port").asLong(0)), node.path("enabled").asBoolean(true), min, min.add(Frequency.ofTHz(4.4)), Frequency.ofGHz(100));
        default:
            log.warn("{}: Unsupported Port Type");
    }
    return new DefaultPortDescription(portNumber(node.path("port").asLong(0)), node.path("enabled").asBoolean(true), type, node.path("speed").asLong(1_000));
}
#method_after
private PortDescription parsePort(JsonNode node) {
    Port.Type type = Port.Type.valueOf(node.path("type").asText("COPPER"));
    switch(type) {
        case COPPER:
            return new DefaultPortDescription(portNumber(node.path("port").asLong(0)), node.path("enabled").asBoolean(true), type, node.path("speed").asLong(1_000));
        case FIBER:
            // Currently, assume OMS when FIBER. Provide sane defaults.
            return new OmsPortDescription(portNumber(node.path("port").asLong(0)), node.path("enabled").asBoolean(true), CENTER, CENTER.add(TOTAL), Frequency.ofGHz(100));
        default:
            log.warn("{}: Unsupported Port Type");
    }
    return new DefaultPortDescription(portNumber(node.path("port").asLong(0)), node.path("enabled").asBoolean(true), type, node.path("speed").asLong(1_000));
}
#end_block

#method_before
private void parseLink(JsonNode node, boolean reverse) {
    ConnectPoint src = connectPoint(get(node, "src"));
    ConnectPoint dst = connectPoint(get(node, "dst"));
    Link.Type type = Link.Type.valueOf(get(node, "type", "DIRECT"));
    SparseAnnotations annotations = annotations(node.get("annotations"));
    DefaultLinkDescription desc = reverse ? new DefaultLinkDescription(dst, src, type, annotations) : new DefaultLinkDescription(src, dst, type, annotations);
    linkProviderService.linkDetected(desc);
    connectPoints.add(src);
    connectPoints.add(dst);
}
#method_after
private void parseLink(JsonNode node, boolean reverse) {
    ConnectPoint src = connectPoint(get(node, "src"));
    ConnectPoint dst = connectPoint(get(node, "dst"));
    Link.Type type = Link.Type.valueOf(get(node, "type", "DIRECT"));
    SparseAnnotations annotations = annotations(node.get("annotations"));
    // take annotations to update optical ports with correct attributes.
    updatePorts(src, dst, annotations);
    DefaultLinkDescription desc = reverse ? new DefaultLinkDescription(dst, src, type, annotations) : new DefaultLinkDescription(src, dst, type, annotations);
    linkProviderService.linkDetected(desc);
    connectPoints.add(src);
    connectPoints.add(dst);
}
#end_block

#method_before
private PortDescription description(ConnectPoint cp) {
    Port p = deviceService.getPort(cp.deviceId(), cp.port());
    if (p == null) {
        return new DefaultPortDescription(cp.port(), true);
    }
    switch(p.type()) {
        case OMS:
            OmsPort op = (OmsPort) p;
            return new OmsPortDescription(op.number(), op.isEnabled(), op.minFrequency(), op.maxFrequency(), op.grid());
        case OCH:
            OchPort ochp = (OchPort) p;
            return new OchPortDescription(ochp.number(), ochp.isEnabled(), ochp.signalType(), ochp.isTunable(), ochp.lambda());
        case ODUCLT:
            OduCltPort odup = (OduCltPort) p;
            return new OduCltPortDescription(odup.number(), odup.isEnabled(), odup.signalType());
        default:
            return new DefaultPortDescription(cp.port(), true);
    }
}
#method_after
private PortDescription description(ConnectPoint cp) {
    Port p = deviceService.getPort(cp.deviceId(), cp.port());
    if (p == null) {
        return new DefaultPortDescription(cp.port(), true);
    }
    return description(p);
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        scheduleEventHandlerIfNotScheduled(event);
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.debug("Event {} received from Link Service", event.type());
        scheduleEventHandlerIfNotScheduled(event);
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_REMOVED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_REMOVED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.debug("Event {} received from Device Service", event.type());
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#end_block

#method_before
private void scheduleEventHandlerIfNotScheduled(Event event) {
    synchronized (eventQueue) {
        eventQueue.add(event);
        numOfEvents++;
        if (eventHandlerFuture == null || eventHandlerFuture.isDone()) {
            eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
            numOfHandlerScheduled++;
        }
    }
    log.trace("numOfEvents {}, numOfEventHanlderScheduled {}", numOfEvents, numOfHandlerScheduled);
}
#method_after
private void scheduleEventHandlerIfNotScheduled(Event event) {
    synchronized (threadSchedulerLock) {
        eventQueue.add(event);
        numOfEventsQueued++;
        if ((numOfHandlerScheduled - numOfHandlerExecution) == 0) {
            // No pending scheduled event handling threads. So start a new one.
            eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
            numOfHandlerScheduled++;
        }
        log.trace("numOfEventsQueued {}, numOfEventHanlderScheduled {}", numOfEventsQueued, numOfHandlerScheduled);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        synchronized (eventQueue) {
            numOfHandlerExecution++;
            while (!eventQueue.isEmpty()) {
                Event event = eventQueue.poll();
                if (event.type() == LinkEvent.Type.LINK_ADDED) {
                    processLinkAdded((Link) event.subject());
                } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                    processLinkRemoved((Link) event.subject());
                // } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
                // processGroupAdded((Group) event.subject());
                } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                    if (deviceService.isAvailable(((Device) event.subject()).id())) {
                        processDeviceAdded((Device) event.subject());
                    }
                } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
                    processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
                } else {
                    log.warn("Unhandled event type: {}", event.type());
                }
            }
        }
        log.debug("numOfHandlerExecution {} numOfEventHanlderScheduled {} numOfEvents {}", numOfHandlerExecution, numOfHandlerScheduled, numOfEvents);
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#method_after
@Override
public void run() {
    try {
        while (true) {
            Event event = null;
            synchronized (threadSchedulerLock) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED) {
                processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                processLinkRemoved((Link) event.subject());
            // } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
            // processGroupAdded((Group) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                if (deviceService.isAvailable(((Device) event.subject()).id())) {
                    processDeviceAdded((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
                processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#end_block

#method_before
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link);
        }
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
    log.trace("processLinkAdded: re-starting route population process");
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link);
        }
    }
    log.trace("Starting optimized route population process");
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
// log.trace("processLinkAdded: re-starting route population process");
// defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private void processLinkRemoved(Link link) {
    log.debug("A link {} was removed", link.toString());
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portDown(link.src().port());
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link);
    log.trace("processLinkRemoved: re-starting route population process");
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
private void processLinkRemoved(Link link) {
    log.debug("A link {} was removed", link.toString());
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portDown(link.src().port());
    }
    log.trace("Starting optimized route population process");
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link);
// log.trace("processLinkRemoved: re-starting route population process");
// defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
    if (nextObjective.op() == Objective.Operation.REMOVE) {
        if (nextObjective.next().isEmpty()) {
            removeGroup(nextObjective);
        } else {
            removeBucketFromGroup(nextObjective);
        }
    } else if (nextObjective.op() == Objective.Operation.ADD) {
        NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
        if (nextGroup != null) {
            addBucketToGroup(nextObjective);
        } else {
            addGroup(nextObjective);
        }
    } else {
        log.warn("Unsupported operation {}", nextObjective.op());
    }
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    log.debug("Processing NextObjective id{} op{}", nextObjective.id(), nextObjective.op());
    if (nextObjective.op() == Objective.Operation.REMOVE) {
        if (nextObjective.next().isEmpty()) {
            removeGroup(nextObjective);
        } else {
            removeBucketFromGroup(nextObjective);
        }
    } else if (nextObjective.op() == Objective.Operation.ADD) {
        NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
        if (nextGroup != null) {
            addBucketToGroup(nextObjective);
        } else {
            addGroup(nextObjective);
        }
    } else {
        log.warn("Unsupported operation {}", nextObjective.op());
    }
}
#end_block

#method_before
private void addGroup(NextObjective nextObjective) {
    switch(nextObjective.type()) {
        case SIMPLE:
            log.debug("processing SIMPLE next objective");
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() == 1) {
                TrafficTreatment treatment = treatments.iterator().next();
                GroupBucket bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket)), key, null, nextObjective.appId());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case HASHED:
            log.debug("processing HASHED next objective");
            List<GroupBucket> buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createSelectGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(buckets), key, null, nextObjective.appId());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case BROADCAST:
        case FAILOVER:
            log.debug("BROADCAST and FAILOVER next objectives not supported");
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            log.warn("Unsupported next objective type {}", nextObjective.type());
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#method_after
private void addGroup(NextObjective nextObjective) {
    log.debug("addGroup with type{} for nextObjective id {}", nextObjective.type(), nextObjective.id());
    switch(nextObjective.type()) {
        case SIMPLE:
            log.debug("processing SIMPLE next objective");
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() == 1) {
                TrafficTreatment treatment = treatments.iterator().next();
                GroupBucket bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket)), key, null, nextObjective.appId());
                log.debug("Creating SIMPLE group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case HASHED:
            log.debug("processing HASHED next objective");
            List<GroupBucket> buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createSelectGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(buckets), key, null, nextObjective.appId());
                log.debug("Creating HASHED group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case BROADCAST:
        case FAILOVER:
            log.debug("BROADCAST and FAILOVER next objectives not supported");
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            log.warn("Unsupported next objective type {}", nextObjective.type());
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#end_block

#method_before
private void addBucketToGroup(NextObjective nextObjective) {
    log.debug("addBucketToGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    Group group = groupService.getGroup(deviceId, key);
    if (group == null) {
        log.warn("Group is not found in {} for {}", deviceId, key);
        return;
    }
    GroupBucket bucket;
    if (group.type() == GroupDescription.Type.INDIRECT) {
        bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    } else if (group.type() == GroupDescription.Type.SELECT) {
        bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
    } else {
        log.warn("Unsupported Group type {}", group.type());
        return;
    }
    GroupBuckets bucketsToAdd = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(deviceId, key, bucketsToAdd, key, appId);
}
#method_after
private void addBucketToGroup(NextObjective nextObjective) {
    log.debug("addBucketToGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    Group group = groupService.getGroup(deviceId, key);
    if (group == null) {
        log.warn("Group is not found in {} for {}", deviceId, key);
        return;
    }
    GroupBucket bucket;
    if (group.type() == GroupDescription.Type.INDIRECT) {
        bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    } else if (group.type() == GroupDescription.Type.SELECT) {
        bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
    } else {
        log.warn("Unsupported Group type {}", group.type());
        return;
    }
    GroupBuckets bucketsToAdd = new GroupBuckets(Collections.singletonList(bucket));
    log.debug("Adding buckets to group id {} of next objective id {} in device {}", group.id(), nextObjective.id(), deviceId);
    groupService.addBucketsToGroup(deviceId, key, bucketsToAdd, key, appId);
}
#end_block

#method_before
private void removeBucketFromGroup(NextObjective nextObjective) {
    log.debug("removeBucketFromGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    if (nextGroup != null) {
        Collection<TrafficTreatment> treatments = nextObjective.next();
        TrafficTreatment treatment = treatments.iterator().next();
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
        Group group = groupService.getGroup(deviceId, key);
        if (group == null) {
            log.warn("Group is not found in {} for {}", deviceId, key);
            return;
        }
        GroupBucket bucket;
        if (group.type() == GroupDescription.Type.INDIRECT) {
            bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
        } else if (group.type() == GroupDescription.Type.SELECT) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
        } else {
            log.warn("Unsupported Group type {}", group.type());
            return;
        }
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        groupService.removeBucketsFromGroup(deviceId, key, removeBuckets, key, appId);
    }
}
#method_after
private void removeBucketFromGroup(NextObjective nextObjective) {
    log.debug("removeBucketFromGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    if (nextGroup != null) {
        Collection<TrafficTreatment> treatments = nextObjective.next();
        TrafficTreatment treatment = treatments.iterator().next();
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
        Group group = groupService.getGroup(deviceId, key);
        if (group == null) {
            log.warn("Group is not found in {} for {}", deviceId, key);
            return;
        }
        GroupBucket bucket;
        if (group.type() == GroupDescription.Type.INDIRECT) {
            bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
        } else if (group.type() == GroupDescription.Type.SELECT) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
        } else {
            log.warn("Unsupported Group type {}", group.type());
            return;
        }
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        log.debug("Removing buckets from group id {} of next objective id {} in device {}", group.id(), nextObjective.id(), deviceId);
        groupService.removeBucketsFromGroup(deviceId, key, removeBuckets, key, appId);
    }
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String newXosServerAddress = Tools.get(properties, "XOSServerAddress");
    if (!isNullOrEmpty(newXosServerAddress)) {
        xosServerAddress = newXosServerAddress;
    }
    String newXosServerPortString = Tools.get(properties, "XOSServerPort");
    if (!isNullOrEmpty(newXosServerPortString)) {
        xosServerPort = Integer.parseInt(newXosServerPortString);
    }
    String newXosProviderServiceString = Tools.get(properties, "XOSProviderService");
    if (!isNullOrEmpty(newXosProviderServiceString)) {
        xosProviderService = Integer.parseInt(newXosProviderServiceString);
    }
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String newXosServerAddress = Tools.get(properties, XOS_SERVER_ADDRESS_PROPERTY_NAME);
    if (!isNullOrEmpty(newXosServerAddress)) {
        xosServerAddress = newXosServerAddress;
    }
    String newXosServerPortString = Tools.get(properties, XOS_SERVER_PORT_PROPERTY_NAME);
    if (!isNullOrEmpty(newXosServerPortString)) {
        xosServerPort = Integer.parseInt(newXosServerPortString);
    }
    String newXosProviderServiceString = Tools.get(properties, XOS_PROVIDER_SERVICE_PROPERTY_NAME);
    if (!isNullOrEmpty(newXosProviderServiceString)) {
        xosProviderService = Integer.parseInt(newXosProviderServiceString);
    }
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPolicy(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode policyJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Policy policyInfo = POLICY_CODEC.decode(policyJson, this);
    if (policyInfo.type() == Policy.PolicyType.TUNNEL_FLOW) {
        TunnelPolicy policy = new TunnelPolicy((SegmentRoutingManager) srService, (TunnelPolicy) policyInfo);
        srService.createPolicy(policy);
        return Response.ok().build();
    } else {
        return Response.serverError().build();
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPolicy(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode policyJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Policy policyInfo = POLICY_CODEC.decode(policyJson, this);
    if (policyInfo.type() == Policy.Type.TUNNEL_FLOW) {
        TunnelPolicy policy = new TunnelPolicy((SegmentRoutingManager) srService, (TunnelPolicy) policyInfo);
        srService.createPolicy(policy);
        return Response.ok().build();
    } else {
        return Response.serverError().build();
    }
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective fwd) {
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    rules = processForward(fwd);
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::remove);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
@Override
public void forward(ForwardingObjective fwd) {
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    rules = processForward(fwd);
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::remove);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
            log.debug("Provisioned tables in {} with " + "forwarding rules for segment " + "router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "forwarding rules for segment router", deviceId);
        }
    }));
}
#end_block

#method_before
private void removeGroup(NextObjective nextObjective) {
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    groupService.removeGroup(deviceId, key, appId);
}
#method_after
private void removeGroup(NextObjective nextObjective) {
    log.debug("removeGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    groupService.removeGroup(deviceId, key, appId);
}
#end_block

#method_before
private void addBucketToGroup(NextObjective nextObjective) {
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    Group group = groupService.getGroup(deviceId, key);
    if (group == null) {
        log.warn("Group is not found in {} for {}", deviceId, key);
        return;
    }
    GroupBucket bucket;
    if (group.type() == GroupDescription.Type.INDIRECT) {
        bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    } else if (group.type() == GroupDescription.Type.SELECT) {
        bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
    } else {
        log.warn("Unsupported Group type {}", group.type());
        return;
    }
    GroupBuckets bucketsToAdd = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(deviceId, key, bucketsToAdd, key, appId);
}
#method_after
private void addBucketToGroup(NextObjective nextObjective) {
    log.debug("addBucketToGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    Group group = groupService.getGroup(deviceId, key);
    if (group == null) {
        log.warn("Group is not found in {} for {}", deviceId, key);
        return;
    }
    GroupBucket bucket;
    if (group.type() == GroupDescription.Type.INDIRECT) {
        bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    } else if (group.type() == GroupDescription.Type.SELECT) {
        bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
    } else {
        log.warn("Unsupported Group type {}", group.type());
        return;
    }
    GroupBuckets bucketsToAdd = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(deviceId, key, bucketsToAdd, key, appId);
}
#end_block

#method_before
private void removeBucketFromGroup(NextObjective nextObjective) {
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    if (nextGroup != null) {
        Collection<TrafficTreatment> treatments = nextObjective.next();
        TrafficTreatment treatment = treatments.iterator().next();
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
        Group group = groupService.getGroup(deviceId, key);
        if (group == null) {
            log.warn("Group is not found in {} for {}", deviceId, key);
            return;
        }
        GroupBucket bucket;
        if (group.type() == GroupDescription.Type.INDIRECT) {
            bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
        } else if (group.type() == GroupDescription.Type.SELECT) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
        } else {
            log.warn("Unsupported Group type {}", group.type());
            return;
        }
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        groupService.removeBucketsFromGroup(deviceId, key, removeBuckets, key, appId);
    }
}
#method_after
private void removeBucketFromGroup(NextObjective nextObjective) {
    log.debug("removeBucketFromGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    if (nextGroup != null) {
        Collection<TrafficTreatment> treatments = nextObjective.next();
        TrafficTreatment treatment = treatments.iterator().next();
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
        Group group = groupService.getGroup(deviceId, key);
        if (group == null) {
            log.warn("Group is not found in {} for {}", deviceId, key);
            return;
        }
        GroupBucket bucket;
        if (group.type() == GroupDescription.Type.INDIRECT) {
            bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
        } else if (group.type() == GroupDescription.Type.SELECT) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
        } else {
            log.warn("Unsupported Group type {}", group.type());
            return;
        }
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        groupService.removeBucketsFromGroup(deviceId, key, removeBuckets, key, appId);
    }
}
#end_block

#method_before
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    if (ethType.ethType() == Ethernet.TYPE_IPV4) {
        IPCriterion ipSrc = (IPCriterion) selector.getCriterion(Criterion.Type.IPV4_SRC);
        IPCriterion ipDst = (IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST);
        IPProtocolCriterion ipProto = (IPProtocolCriterion) selector.getCriterion(Criterion.Type.IP_PROTO);
        filteredSelectorBuilder.matchEthType(Ethernet.TYPE_IPV4);
        if (ipSrc != null) {
            filteredSelectorBuilder.matchIPSrc(ipSrc.ip());
        }
        if (ipDst != null) {
            filteredSelectorBuilder.matchIPSrc(ipDst.ip());
        }
        if (ipProto != null) {
            filteredSelectorBuilder.matchIPProtocol(Short.valueOf(ipProto.protocol()).byteValue());
        }
        log.debug("processing IPv4 specific forwarding objective");
    } else {
        log.warn("VERSATILE forwarding objective does not support {} yet.", ethType.ethType());
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.group(group.id());
            log.debug("Adding OUTGROUP action");
        }
    } else {
        log.warn("VERSATILE forwarding objective need next objective ID.");
        return Collections.emptySet();
    }
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    TrafficTreatment treatment = treatmentBuilder.build();
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    if (ethType.ethType() == Ethernet.TYPE_IPV4) {
        IPCriterion ipSrc = (IPCriterion) selector.getCriterion(Criterion.Type.IPV4_SRC);
        IPCriterion ipDst = (IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST);
        IPProtocolCriterion ipProto = (IPProtocolCriterion) selector.getCriterion(Criterion.Type.IP_PROTO);
        filteredSelectorBuilder.matchEthType(Ethernet.TYPE_IPV4);
        if (ipSrc != null) {
            filteredSelectorBuilder.matchIPSrc(ipSrc.ip());
        }
        if (ipDst != null) {
            filteredSelectorBuilder.matchIPDst(ipDst.ip());
        }
        if (ipProto != null) {
            filteredSelectorBuilder.matchIPProtocol(Short.valueOf(ipProto.protocol()).byteValue());
        }
        log.debug("processing IPv4 specific forwarding objective");
    } else {
        log.warn("VERSATILE forwarding objective does not support {} yet.", ethType.ethType());
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            log.debug("Adding OUTGROUP action");
        }
    } else {
        log.warn("VERSATILE forwarding objective need next objective ID.");
        return Collections.emptySet();
    }
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    TrafficTreatment treatment = treatmentBuilder.build();
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
protected Collection<FlowRule> processSpecific(ForwardingObjective fwd) {
    log.debug("Processing specific");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || ((((short) ethType.ethType()) != Ethernet.TYPE_IPV4) && (((short) ethType.ethType()) != Ethernet.MPLS_UNICAST))) {
        log.debug("processSpecific: Unsupported " + "forwarding objective criteraia");
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    int forTableId = -1;
    if (((short) ethType.ethType()) == Ethernet.TYPE_IPV4) {
        filteredSelectorBuilder = filteredSelectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip());
        forTableId = ipv4UnicastTableId;
        log.debug("processing IPv4 specific forwarding objective");
    } else {
        filteredSelectorBuilder = filteredSelectorBuilder.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        // TODO: Add Match for BoS
        // if (selector.getCriterion(Criterion.Type.MPLS_BOS) != null) {
        // }
        forTableId = mplsTableId;
        log.debug("processing MPLS specific forwarding objective");
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            treatmentBuilder.add(i);
        }
    }
    // switches.
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.group(group.id());
            log.debug("Adding OUTGROUP action");
        }
    }
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    TrafficTreatment treatment = treatmentBuilder.transition(aclTableId).build();
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(forTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
protected Collection<FlowRule> processSpecific(ForwardingObjective fwd) {
    log.debug("Processing specific");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || ((((short) ethType.ethType()) != Ethernet.TYPE_IPV4) && (((short) ethType.ethType()) != Ethernet.MPLS_UNICAST))) {
        log.warn("processSpecific: Unsupported " + "forwarding objective criteraia");
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    int forTableId = -1;
    if (((short) ethType.ethType()) == Ethernet.TYPE_IPV4) {
        filteredSelectorBuilder = filteredSelectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip());
        forTableId = ipv4UnicastTableId;
        log.debug("processing IPv4 specific forwarding objective");
    } else {
        filteredSelectorBuilder = filteredSelectorBuilder.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        // TODO: Add Match for BoS
        // if (selector.getCriterion(Criterion.Type.MPLS_BOS) != null) {
        // }
        forTableId = mplsTableId;
        log.debug("processing MPLS specific forwarding objective");
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            treatmentBuilder.add(i);
        }
    }
    // switches.
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            log.debug("Adding OUTGROUP action");
        } else {
            log.warn("processSpecific: No associated next objective object");
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
    }
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    TrafficTreatment treatment = treatmentBuilder.transition(aclTableId).build();
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(forTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion p;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        p = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            VlanIdCriterion v = (VlanIdCriterion) c;
            log.debug("adding rule for VLAN: {}", v.vlanId());
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            if (v.vlanId() != VlanId.NONE) {
                selector.matchVlanId(v.vlanId());
                selector.matchInPort(p.port());
                treatment.deferred().popVlan();
            }
            treatment.transition(tmacTableId);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(vlanTableId).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            log.debug("adding rule for IP: {}", ip.ip());
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ip.ip());
            treatment.transition(aclTableId);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(ipv4UnicastTableId).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.info("Provisioned tables for segment router");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.info("Failed to provision tables for segment router");
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            log.debug("adding rule for IP: {}", ip.ip());
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ip.ip());
            treatment.transition(aclTableId);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(ipv4UnicastTableId).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules for segment router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules for segment router", deviceId);
        }
    }));
}
#end_block

#method_before
@Override
public void event(GroupEvent event) {
    if (event.type() == GroupEvent.Type.GROUP_ADDED) {
        GroupKey key = event.subject().appCookie();
        NextObjective obj = pendingGroups.getIfPresent(key);
        if (obj != null) {
            flowObjectiveStore.putNextGroup(obj.id(), new SegmentRoutingGroup(key));
            pass(obj);
            pendingGroups.invalidate(key);
        }
    }
}
#method_after
@Override
public void event(GroupEvent event) {
    if (event.type() == GroupEvent.Type.GROUP_ADDED) {
        log.debug("InnerGroupListener: Group ADDED " + "event received in device {}", deviceId);
        GroupKey key = event.subject().appCookie();
        NextObjective obj = pendingGroups.getIfPresent(key);
        if (obj != null) {
            flowObjectiveStore.putNextGroup(obj.id(), new SegmentRoutingGroup(key));
            pass(obj);
            pendingGroups.invalidate(key);
        }
    } else if (event.type() == GroupEvent.Type.GROUP_ADD_FAILED) {
        log.warn("InnerGroupListener: Group ADD " + "failed event received in device {}", deviceId);
    }
}
#end_block

#method_before
@Override
public int getSegmentId(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("getSegmentId for device{} is {}", deviceId, deviceConfigMap.get(deviceId).nodeSid);
        return deviceConfigMap.get(deviceId).nodeSid;
    } else {
        throw new IllegalStateException();
    }
}
#method_after
@Override
public int getSegmentId(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("getSegmentId for device{} is {}", deviceId, deviceConfigMap.get(deviceId).nodeSid);
        return deviceConfigMap.get(deviceId).nodeSid;
    } else {
        log.warn("getSegmentId for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public MacAddress getDeviceMac(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("getDeviceMac for device{} is {}", deviceId, deviceConfigMap.get(deviceId).mac);
        return deviceConfigMap.get(deviceId).mac;
    } else {
        throw new IllegalStateException();
    }
}
#method_after
@Override
public MacAddress getDeviceMac(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("getDeviceMac for device{} is {}", deviceId, deviceConfigMap.get(deviceId).mac);
        return deviceConfigMap.get(deviceId).mac;
    } else {
        log.warn("getDeviceMac for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
public Ip4Address getRouterIp(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("getDeviceIp for device{} is {}", deviceId, deviceConfigMap.get(deviceId).ip);
        return deviceConfigMap.get(deviceId).ip;
    } else {
        throw new IllegalStateException();
    }
}
#method_after
public Ip4Address getRouterIp(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("getDeviceIp for device{} is {}", deviceId, deviceConfigMap.get(deviceId).ip);
        return deviceConfigMap.get(deviceId).ip;
    } else {
        log.warn("getRouterIp for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public boolean isEdgeDevice(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("isEdgeDevice for device{} is {}", deviceId, deviceConfigMap.get(deviceId).isEdge);
        return deviceConfigMap.get(deviceId).isEdge;
    } else {
        throw new IllegalStateException();
    }
}
#method_after
@Override
public boolean isEdgeDevice(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.debug("isEdgeDevice for device{} is {}", deviceId, deviceConfigMap.get(deviceId).isEdge);
        return deviceConfigMap.get(deviceId).isEdge;
    } else {
        log.warn("isEdgeDevice for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public PolicyType type() {
    return type;
}
#method_after
@Override
public Type type() {
    return type;
}
#end_block

#method_before
public Builder setType(PolicyType type) {
    this.type = type;
    return this;
}
#method_after
public Builder setType(Type type) {
    this.type = type;
    return this;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    networkConfigService.init();
    deviceConfiguration = new DeviceConfiguration(networkConfigService);
    arpHandler = new ArpHandler(this);
    icmpHandler = new IcmpHandler(this);
    ipHandler = new IpHandler(this);
    routingRulePopulator = new RoutingRulePopulator(this);
    defaultRoutingHandler = new DefaultRoutingHandler(this);
    tunnelHandler = new TunnelHandler();
    policyHandler = new PolicyHandler();
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    linkService.addListener(new InternalLinkListener());
    deviceService.addListener(new InternalDeviceListener());
    for (Device device : deviceService.getDevices()) {
        if (mastershipService.getLocalRole(device.id()) == MastershipRole.MASTER) {
            DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService);
            groupHandlerMap.put(device.id(), groupHandler);
            defaultRoutingHandler.populateTtpRules(device.id());
            log.debug("Initiating default group handling for {}", device.id());
        } else {
            log.debug("Activate: Local role {} " + "is not MASTER for device {}", mastershipService.getLocalRole(device.id()), device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withClockService(new WallclockClockManager<>()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    networkConfigService.init();
    deviceConfiguration = new DeviceConfiguration(networkConfigService);
    arpHandler = new ArpHandler(this);
    icmpHandler = new IcmpHandler(this);
    ipHandler = new IpHandler(this);
    routingRulePopulator = new RoutingRulePopulator(this);
    defaultRoutingHandler = new DefaultRoutingHandler(this);
    tunnelHandler = new TunnelHandler();
    policyHandler = new PolicyHandler();
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    linkService.addListener(new InternalLinkListener());
    deviceService.addListener(new InternalDeviceListener());
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populateTtpRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
    log.info("Started");
}
#end_block

#method_before
@Override
public void removeTunnel(Tunnel tunnel) {
    for (Policy policy : policyHandler.getPolicies()) {
        if (policy.type() == Policy.PolicyType.TUNNEL_FLOW) {
            TunnelPolicy tunnelPolicy = (TunnelPolicy) policy;
            if (tunnelPolicy.tunnelId().equals(tunnel.id())) {
                log.warn("Cannot remove the tunnel used by a policy");
                return;
            }
        }
    }
    tunnelHandler.removeTunnel(tunnel);
}
#method_after
@Override
public void removeTunnel(Tunnel tunnel) {
    for (Policy policy : policyHandler.getPolicies()) {
        if (policy.type() == Policy.Type.TUNNEL_FLOW) {
            TunnelPolicy tunnelPolicy = (TunnelPolicy) policy;
            if (tunnelPolicy.tunnelId().equals(tunnel.id())) {
                log.warn("Cannot remove the tunnel used by a policy");
                return;
            }
        }
    }
    tunnelHandler.removeTunnel(tunnel);
}
#end_block

#method_before
public int getNextObjectiveId(DeviceId deviceId, NeighborSet ns) {
    return (groupHandlerMap.get(deviceId) != null) ? groupHandlerMap.get(deviceId).getNextObjectiveId(ns) : -1;
}
#method_after
public int getNextObjectiveId(DeviceId deviceId, NeighborSet ns) {
    if (groupHandlerMap.get(deviceId) != null) {
        log.trace("getNextObjectiveId query in device {}", deviceId);
        return groupHandlerMap.get(deviceId).getNextObjectiveId(ns);
    } else {
        log.warn("getNextObjectiveId query in device {} not found", deviceId);
        return -1;
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    if (mastershipService.getLocalRole(event.subject().id()) != MastershipRole.MASTER) {
        log.debug("Local role {} is not MASTER for device {}", mastershipService.getLocalRole(event.subject().id()), event.subject().id());
        return;
    }
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_REMOVED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_REMOVED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#end_block

#method_before
private void scheduleEventHandlerIfNotScheduled(Event event) {
    eventQueue.add(event);
    numOfEvents++;
    if (eventHandlerFuture == null || eventHandlerFuture.isDone()) {
        eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
        numOfHandlerScheduled++;
    }
    log.trace("numOfEvents {}, numOfEventHanlderScheduled {}", numOfEvents, numOfHandlerScheduled);
}
#method_after
private void scheduleEventHandlerIfNotScheduled(Event event) {
    synchronized (eventQueue) {
        eventQueue.add(event);
        numOfEvents++;
        if (eventHandlerFuture == null || eventHandlerFuture.isDone()) {
            eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
            numOfHandlerScheduled++;
        }
    }
    log.trace("numOfEvents {}, numOfEventHanlderScheduled {}", numOfEvents, numOfHandlerScheduled);
}
#end_block

#method_before
@Override
public void run() {
    numOfHandlerExecution++;
    while (!eventQueue.isEmpty()) {
        Event event = eventQueue.poll();
        if (event.type() == LinkEvent.Type.LINK_ADDED) {
            processLinkAdded((Link) event.subject());
        } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
            processLinkRemoved((Link) event.subject());
        } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
            processGroupAdded((Group) event.subject());
        } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
            if (deviceService.isAvailable(((Device) event.subject()).id())) {
                processDeviceAdded((Device) event.subject());
            }
        }
    }
    log.debug("numOfHandlerExecution {} numOfEventHanlderScheduled {} numOfEvents {}", numOfHandlerExecution, numOfHandlerScheduled, numOfEvents);
}
#method_after
@Override
public void run() {
    try {
        synchronized (eventQueue) {
            numOfHandlerExecution++;
            while (!eventQueue.isEmpty()) {
                Event event = eventQueue.poll();
                if (event.type() == LinkEvent.Type.LINK_ADDED) {
                    processLinkAdded((Link) event.subject());
                } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                    processLinkRemoved((Link) event.subject());
                // } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
                // processGroupAdded((Group) event.subject());
                } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                    if (deviceService.isAvailable(((Device) event.subject()).id())) {
                        processDeviceAdded((Device) event.subject());
                    }
                } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
                    processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
                } else {
                    log.warn("Unhandled event type: {}", event.type());
                }
            }
        }
        log.debug("numOfHandlerExecution {} numOfEventHanlderScheduled {} numOfEvents {}", numOfHandlerExecution, numOfHandlerScheduled, numOfEvents);
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#end_block

#method_before
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    if (mastershipService.getLocalRole(link.src().deviceId()) == MastershipRole.MASTER) {
        DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
        if (groupHandler != null) {
            groupHandler.linkUp(link);
        }
    }
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
}
#method_after
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link);
        }
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
    log.trace("processLinkAdded: re-starting route population process");
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private void processLinkRemoved(Link link) {
    log.debug("A link {} was removed", link.toString());
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portDown(link.src().port());
    }
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link);
}
#method_after
private void processLinkRemoved(Link link) {
    log.debug("A link {} was removed", link.toString());
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portDown(link.src().port());
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link);
    log.trace("processLinkRemoved: re-starting route population process");
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    defaultRoutingHandler.populateTtpRules(device.id());
    DefaultGroupHandler dgh = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService);
    groupHandlerMap.put(device.id(), dgh);
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler dgh = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
    groupHandlerMap.put(device.id(), dgh);
    defaultRoutingHandler.populateTtpRules(device.id());
}
#end_block

#method_before
public static DefaultGroupHandler createGroupHandler(DeviceId deviceId, ApplicationId appId, DeviceProperties config, LinkService linkService, FlowObjectiveService flowObjService) {
    if (config.isEdgeDevice(deviceId)) {
        return new DefaultEdgeGroupHandler(deviceId, appId, config, linkService, flowObjService);
    } else {
        return new DefaultTransitGroupHandler(deviceId, appId, config, linkService, flowObjService);
    }
}
#method_after
public static DefaultGroupHandler createGroupHandler(DeviceId deviceId, ApplicationId appId, DeviceProperties config, LinkService linkService, FlowObjectiveService flowObjService, EventuallyConsistentMap<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjStore) {
    if (config.isEdgeDevice(deviceId)) {
        return new DefaultEdgeGroupHandler(deviceId, appId, config, linkService, flowObjService, nsNextObjStore);
    } else {
        return new DefaultTransitGroupHandler(deviceId, appId, config, linkService, flowObjService, nsNextObjStore);
    }
}
#end_block

#method_before
public void linkUp(Link newLink) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.debug("Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    if (devicePortMap.get(newLink.dst().deviceId()) == null) {
        // New Neighbor
        newNeighbor(newLink);
    } else {
        // Old Neighbor
        newPortToExistingNeighbor(newLink);
    }
}
#method_after
public void linkUp(Link newLink) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.debug("Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    log.trace("linkUp: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the new bucket to be updated
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(newLink.src().port()).setEthDst(deviceConfig.getDeviceMac(newLink.dst().deviceId())).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            NextObjective nextObjective = nextObjBuilder.add();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
}
#end_block

#method_before
public void portDown(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap.get(port), devicePortMap.keySet());
    for (NeighborSet ns : nsSet) {
        // Create the bucket to be removed
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(port).setEthDst(deviceConfig.getDeviceMac(portDeviceMap.get(port))).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = deviceNextObjectiveIds.get(getGroupKey(ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).withId(nextId).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            NextObjective nextObjective = nextObjBuilder.remove();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#method_after
public void portDown(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    log.trace("portDown: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the bucket to be removed
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(port).setEthDst(deviceConfig.getDeviceMac(portDeviceMap.get(port))).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).withId(nextId).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            NextObjective nextObjective = nextObjBuilder.remove();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#end_block

#method_before
public int getNextObjectiveId(NeighborSet ns) {
    Integer nextId = deviceNextObjectiveIds.get(getGroupKey(ns));
    if (nextId == null) {
        createGroupsFromNeighborsets(Collections.singleton(ns));
        nextId = deviceNextObjectiveIds.get(getGroupKey(ns));
        if (nextId == null) {
            log.warn("getNextObjectiveId: unable to create next objective");
            return -1;
        }
    }
    return nextId.intValue();
}
#method_after
public int getNextObjectiveId(NeighborSet ns) {
    Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
    if (nextId == null) {
        log.trace("getNextObjectiveId in device{}: Next objective id " + "not found for {} and creating", deviceId, ns);
        log.trace("getNextObjectiveId: nsNextObjStore contents for device {}: {}", deviceId, nsNextObjStore.entrySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.getKey().deviceId().equals(deviceId))).collect(Collectors.toList()));
        createGroupsFromNeighborsets(Collections.singleton(ns));
        nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId == null) {
            log.warn("getNextObjectiveId: unable to create next objective");
            return -1;
        } else {
            log.debug("getNextObjectiveId in device{}: Next objective id {} " + "created for {}", deviceId, nextId.intValue(), ns);
        }
    } else {
        log.trace("getNextObjectiveId in device{}: Next objective id {} " + "found for {}", deviceId, nextId.intValue(), ns);
    }
    return nextId.intValue();
}
#end_block

#method_before
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId d : ns.getDeviceIds()) {
            if (devicePortMap.get(d) == null) {
                log.warn("Device {} is not in the port map yet", d);
                return;
            }
            for (PortNumber sp : devicePortMap.get(d)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(d)).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        NextObjective nextObj = nextObjBuilder.add();
        flowObjectiveService.next(deviceId, nextObj);
        deviceNextObjectiveIds.put(getGroupKey(ns), nextId);
    }
}
#method_after
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId d : ns.getDeviceIds()) {
            if (devicePortMap.get(d) == null) {
                log.warn("Device {} is not in the port map yet", d);
                return;
            } else if (devicePortMap.get(d).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", d);
                return;
            }
            for (PortNumber sp : devicePortMap.get(d)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(d)).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        NextObjective nextObj = nextObjBuilder.add();
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#end_block

#method_before
public boolean removeGroup(int objectiveId) {
    if (deviceNextObjectiveIds.values().contains(objectiveId)) {
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(objectiveId).withType(NextObjective.Type.HASHED).fromApp(appId);
        NextObjective nextObjective = nextObjBuilder.remove();
        flowObjectiveService.next(deviceId, nextObjective);
        for (Map.Entry<GroupKey, Integer> entry : deviceNextObjectiveIds.entrySet()) {
            if (entry.getValue().equals(objectiveId)) {
                deviceNextObjectiveIds.remove(entry.getKey());
                break;
            }
        }
    }
    return false;
}
#method_after
public boolean removeGroup(int objectiveId) {
    if (nsNextObjStore.containsValue(objectiveId)) {
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(objectiveId).withType(NextObjective.Type.HASHED).fromApp(appId);
        NextObjective nextObjective = nextObjBuilder.remove();
        flowObjectiveService.next(deviceId, nextObjective);
        for (Map.Entry<NeighborSetNextObjectiveStoreKey, Integer> entry : nsNextObjStore.entrySet()) {
            if (entry.getValue().equals(objectiveId)) {
                nsNextObjStore.remove(entry.getKey());
                break;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public ObjectNode encode(Policy policy, CodecContext context) {
    final ObjectNode result = context.mapper().createObjectNode().put(POLICY_ID, policy.id());
    result.put(PRIORITY, policy.priority());
    result.put(TYPE, policy.type().toString());
    if (policy.selector().getCriterion(Criterion.Type.IPV4_DST) != null) {
        IPCriterion criterion = (IPCriterion) policy.selector().getCriterion(Criterion.Type.IPV4_DST);
        result.put(DST_IP, criterion.ip().toString());
    } else if (policy.selector().getCriterion(Criterion.Type.IPV4_SRC) != null) {
        IPCriterion criterion = (IPCriterion) policy.selector().getCriterion(Criterion.Type.IPV4_SRC);
        result.put(SRC_IP, criterion.ip().toString());
    } else if (policy.selector().getCriterion(Criterion.Type.IP_PROTO) != null) {
        IPProtocolCriterion protocolCriterion = (IPProtocolCriterion) policy.selector().getCriterion(Criterion.Type.IP_PROTO);
        result.put(PROTO_TYPE, protocolCriterion.toString());
    }
    if (policy.type() == Policy.PolicyType.TUNNEL_FLOW) {
        result.put(TUNNEL_ID, ((TunnelPolicy) policy).tunnelId());
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(Policy policy, CodecContext context) {
    final ObjectNode result = context.mapper().createObjectNode().put(POLICY_ID, policy.id());
    result.put(PRIORITY, policy.priority());
    result.put(TYPE, policy.type().toString());
    if (policy.selector().getCriterion(Criterion.Type.IPV4_DST) != null) {
        IPCriterion criterion = (IPCriterion) policy.selector().getCriterion(Criterion.Type.IPV4_DST);
        result.put(DST_IP, criterion.ip().toString());
    }
    if (policy.selector().getCriterion(Criterion.Type.IPV4_SRC) != null) {
        IPCriterion criterion = (IPCriterion) policy.selector().getCriterion(Criterion.Type.IPV4_SRC);
        result.put(SRC_IP, criterion.ip().toString());
    }
    if (policy.selector().getCriterion(Criterion.Type.IP_PROTO) != null) {
        IPProtocolCriterion protocolCriterion = (IPProtocolCriterion) policy.selector().getCriterion(Criterion.Type.IP_PROTO);
        result.put(PROTO_TYPE, protocolCriterion.toString());
    }
    if (policy.type() == Policy.Type.TUNNEL_FLOW) {
        result.put(TUNNEL_ID, ((TunnelPolicy) policy).tunnelId());
    }
    return result;
}
#end_block

#method_before
@Override
public Policy decode(ObjectNode json, CodecContext context) {
    String pid = json.path(POLICY_ID).asText();
    String type = json.path(TYPE).asText();
    int priority = json.path(PRIORITY).asInt();
    String dstIp = json.path(DST_IP).asText();
    String srcIp = json.path(SRC_IP).asText();
    String tunnelId = json.path(TUNNEL_ID).asText();
    String protoType = json.path(PROTO_TYPE).asText();
    if (tunnelId != null) {
        TrafficSelector.Builder tsb = DefaultTrafficSelector.builder();
        tsb.matchEthType(Ethernet.TYPE_IPV4);
        if (dstIp != null && !dstIp.isEmpty()) {
            tsb.matchIPDst(IpPrefix.valueOf(dstIp));
        }
        if (srcIp != null && !srcIp.isEmpty()) {
            tsb.matchIPSrc(IpPrefix.valueOf(srcIp));
        }
        if (protoType != null && !protoType.isEmpty()) {
            Short ipProto = Short.valueOf(IpProtocol.valueOf(protoType).value());
            tsb.matchIPProtocol(ipProto.byteValue());
        }
        TunnelPolicy.Builder tpb = TunnelPolicy.builder().setPolicyId(pid);
        if (tunnelId != null) {
            tpb.setTunnelId(tunnelId);
        }
        if (!json.path(PRIORITY).isMissingNode()) {
            tpb.setPriority(priority);
        }
        if (!json.path(TYPE).isMissingNode()) {
            tpb.setType(Policy.PolicyType.valueOf(type));
        }
        tpb.setSelector(tsb.build());
        return tpb.build();
    } else {
        // TODO: handle more policy types
        return null;
    }
}
#method_after
@Override
public Policy decode(ObjectNode json, CodecContext context) {
    String pid = json.path(POLICY_ID).asText();
    String type = json.path(TYPE).asText();
    int priority = json.path(PRIORITY).asInt();
    String dstIp = json.path(DST_IP).asText();
    String srcIp = json.path(SRC_IP).asText();
    String tunnelId = json.path(TUNNEL_ID).asText();
    String protoType = json.path(PROTO_TYPE).asText();
    if (tunnelId != null) {
        TrafficSelector.Builder tsb = DefaultTrafficSelector.builder();
        tsb.matchEthType(Ethernet.TYPE_IPV4);
        if (dstIp != null && !dstIp.isEmpty()) {
            tsb.matchIPDst(IpPrefix.valueOf(dstIp));
        }
        if (srcIp != null && !srcIp.isEmpty()) {
            tsb.matchIPSrc(IpPrefix.valueOf(srcIp));
        }
        if (protoType != null && !protoType.isEmpty()) {
            Short ipProto = Short.valueOf(IpProtocol.valueOf(protoType).value());
            tsb.matchIPProtocol(ipProto.byteValue());
        }
        TunnelPolicy.Builder tpb = TunnelPolicy.builder().setPolicyId(pid);
        if (tunnelId != null) {
            tpb.setTunnelId(tunnelId);
        }
        if (!json.path(PRIORITY).isMissingNode()) {
            tpb.setPriority(priority);
        }
        if (!json.path(TYPE).isMissingNode()) {
            tpb.setType(Policy.Type.valueOf(type));
        }
        tpb.setSelector(tsb.build());
        return tpb.build();
    } else {
        // TODO: handle more policy types
        return null;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    kryoBuilder = new KryoNamespace.Builder().register(DefaultGroup.class, DefaultGroupBucket.class, DefaultGroupDescription.class, DefaultGroupKey.class, GroupDescription.Type.class, Group.GroupState.class, GroupBuckets.class, DefaultGroupId.class, GroupStoreMessage.class, GroupStoreMessage.Type.class, UpdateType.class, GroupStoreMessageSubjects.class, MultiValuedTimestamp.class, GroupStoreKeyMapKey.class, GroupStoreIdMapKey.class, GroupStoreMapKey.class).register(new URISerializer(), URI.class).register(new DeviceIdSerializer(), DeviceId.class).register(PortNumber.class).register(DefaultApplicationId.class).register(DefaultTrafficTreatment.class, Instructions.DropInstruction.class, Instructions.OutputInstruction.class, Instructions.GroupInstruction.class, Instructions.TableTypeTransition.class, FlowRule.Type.class, L0ModificationInstruction.class, L0ModificationInstruction.L0SubType.class, L0ModificationInstruction.ModLambdaInstruction.class, L2ModificationInstruction.class, L2ModificationInstruction.L2SubType.class, L2ModificationInstruction.ModEtherInstruction.class, L2ModificationInstruction.PushHeaderInstructions.class, L2ModificationInstruction.ModVlanIdInstruction.class, L2ModificationInstruction.ModVlanPcpInstruction.class, L2ModificationInstruction.ModMplsLabelInstruction.class, L2ModificationInstruction.ModMplsTtlInstruction.class, L3ModificationInstruction.class, L3ModificationInstruction.L3SubType.class, L3ModificationInstruction.ModIPInstruction.class, L3ModificationInstruction.ModIPv6FlowLabelInstruction.class, L3ModificationInstruction.ModTtlInstruction.class, org.onlab.packet.MplsLabel.class).register(org.onosproject.cluster.NodeId.class).register(KryoNamespaces.BASIC).register(KryoNamespaces.MISC);
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/group", "message-handlers"));
    clusterCommunicator.addSubscriber(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, new ClusterGroupMsgHandler(), messageHandlingExecutor);
    log.debug("Creating EC map groupstorekeymap");
    EventuallyConsistentMapBuilder<GroupStoreKeyMapKey, StoredGroupEntry> keyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    groupStoreEntriesByKey = keyMapBuilder.withName("groupstorekeymap").withSerializer(kryoBuilder).withClockService(new GroupStoreLogicalClockManager<>()).build();
    groupStoreEntriesByKey.addListener(new GroupStoreKeyMapListener());
    log.trace("Current size {}", groupStoreEntriesByKey.size());
    log.debug("Creating EC map pendinggroupkeymap");
    EventuallyConsistentMapBuilder<GroupStoreKeyMapKey, StoredGroupEntry> auditMapBuilder = storageService.eventuallyConsistentMapBuilder();
    auditPendingReqQueue = auditMapBuilder.withName("pendinggroupkeymap").withSerializer(kryoBuilder).withClockService(new GroupStoreLogicalClockManager<>()).build();
    log.trace("Current size {}", auditPendingReqQueue.size());
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    kryoBuilder = new KryoNamespace.Builder().register(DefaultGroup.class, DefaultGroupBucket.class, DefaultGroupDescription.class, DefaultGroupKey.class, GroupDescription.Type.class, Group.GroupState.class, GroupBuckets.class, DefaultGroupId.class, GroupStoreMessage.class, GroupStoreMessage.Type.class, UpdateType.class, GroupStoreMessageSubjects.class, MultiValuedTimestamp.class, GroupStoreKeyMapKey.class, GroupStoreIdMapKey.class, GroupStoreMapKey.class).register(new URISerializer(), URI.class).register(new DeviceIdSerializer(), DeviceId.class).register(PortNumber.class).register(DefaultApplicationId.class).register(DefaultTrafficTreatment.class, Instructions.DropInstruction.class, Instructions.OutputInstruction.class, Instructions.GroupInstruction.class, Instructions.TableTypeTransition.class, FlowRule.Type.class, L0ModificationInstruction.class, L0ModificationInstruction.L0SubType.class, L0ModificationInstruction.ModLambdaInstruction.class, L2ModificationInstruction.class, L2ModificationInstruction.L2SubType.class, L2ModificationInstruction.ModEtherInstruction.class, L2ModificationInstruction.PushHeaderInstructions.class, L2ModificationInstruction.ModVlanIdInstruction.class, L2ModificationInstruction.ModVlanPcpInstruction.class, L2ModificationInstruction.ModMplsLabelInstruction.class, L2ModificationInstruction.ModMplsTtlInstruction.class, L3ModificationInstruction.class, L3ModificationInstruction.L3SubType.class, L3ModificationInstruction.ModIPInstruction.class, L3ModificationInstruction.ModIPv6FlowLabelInstruction.class, L3ModificationInstruction.ModTtlInstruction.class, org.onlab.packet.MplsLabel.class).register(org.onosproject.cluster.NodeId.class).register(KryoNamespaces.BASIC).register(KryoNamespaces.MISC);
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/group", "message-handlers"));
    clusterCommunicator.addSubscriber(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, new ClusterGroupMsgHandler(), messageHandlingExecutor);
    log.debug("Creating EC map groupstorekeymap");
    EventuallyConsistentMapBuilder<GroupStoreKeyMapKey, StoredGroupEntry> keyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    groupStoreEntriesByKey = keyMapBuilder.withName("groupstorekeymap").withSerializer(kryoBuilder).withClockService(new GroupStoreLogicalClockManager<>()).build();
    groupStoreEntriesByKey.addListener(new GroupStoreKeyMapListener());
    log.debug("Current size of groupstorekeymap:{}", groupStoreEntriesByKey.size());
    log.debug("Creating EC map pendinggroupkeymap");
    EventuallyConsistentMapBuilder<GroupStoreKeyMapKey, StoredGroupEntry> auditMapBuilder = storageService.eventuallyConsistentMapBuilder();
    auditPendingReqQueue = auditMapBuilder.withName("pendinggroupkeymap").withSerializer(kryoBuilder).withClockService(new GroupStoreLogicalClockManager<>()).build();
    log.debug("Current size of pendinggroupkeymap:{}", auditPendingReqQueue.size());
    log.info("Started");
}
#end_block

#method_before
@Override
public Iterable<Group> getGroups(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    log.trace("getGroups: for device {} total number of groups {}", deviceId, getGroupStoreKeyMap().values().size());
    return FluentIterable.from(getGroupStoreKeyMap().values()).filter(input -> input.deviceId().equals(deviceId)).transform(input -> input);
}
#method_after
@Override
public Iterable<Group> getGroups(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    log.debug("getGroups: for device {} total number of groups {}", deviceId, getGroupStoreKeyMap().values().size());
    return FluentIterable.from(getGroupStoreKeyMap().values()).filter(input -> input.deviceId().equals(deviceId)).transform(input -> input);
}
#end_block

#method_before
private Iterable<StoredGroupEntry> getStoredGroups(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    log.trace("getGroups: for device {} total number of groups {}", deviceId, getGroupStoreKeyMap().values().size());
    return FluentIterable.from(getGroupStoreKeyMap().values()).filter(input -> input.deviceId().equals(deviceId));
}
#method_after
private Iterable<StoredGroupEntry> getStoredGroups(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    log.debug("getGroups: for device {} total number of groups {}", deviceId, getGroupStoreKeyMap().values().size());
    return FluentIterable.from(getGroupStoreKeyMap().values()).filter(input -> input.deviceId().equals(deviceId));
}
#end_block

#method_before
private int getFreeGroupIdValue(DeviceId deviceId) {
    int freeId = groupIdGen.incrementAndGet();
    while (true) {
        Group existing = getGroup(deviceId, new DefaultGroupId(freeId));
        if (existing == null) {
            existing = (extraneousGroupEntriesById.get(deviceId) != null) ? extraneousGroupEntriesById.get(deviceId).get(new DefaultGroupId(freeId)) : null;
        }
        if (existing != null) {
            freeId = groupIdGen.incrementAndGet();
        } else {
            break;
        }
    }
    log.trace("getFreeGroupIdValue: Next Free ID is {}", freeId);
    return freeId;
}
#method_after
private int getFreeGroupIdValue(DeviceId deviceId) {
    int freeId = groupIdGen.incrementAndGet();
    while (true) {
        Group existing = getGroup(deviceId, new DefaultGroupId(freeId));
        if (existing == null) {
            existing = (extraneousGroupEntriesById.get(deviceId) != null) ? extraneousGroupEntriesById.get(deviceId).get(new DefaultGroupId(freeId)) : null;
        }
        if (existing != null) {
            freeId = groupIdGen.incrementAndGet();
        } else {
            break;
        }
    }
    log.debug("getFreeGroupIdValue: Next Free ID is {}", freeId);
    return freeId;
}
#end_block

#method_before
@Override
public void storeGroupDescription(GroupDescription groupDesc) {
    log.trace("In storeGroupDescription");
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        log.warn("Group already exists with the same key {}", groupDesc.appCookie());
        return;
    }
    // Check if group to be created by a remote instance
    if (mastershipService.getLocalRole(groupDesc.deviceId()) != MastershipRole.MASTER) {
        log.debug("storeGroupDescription: Device {} local role is not MASTER", groupDesc.deviceId());
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupAddRequestMsg(groupDesc.deviceId(), groupDesc);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(groupDesc.deviceId()))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(groupDesc.deviceId()));
        // TODO: Send Group operation failure event
        }
        log.debug("Sent Group operation request for device {} " + "to remote MASTER {}", groupDesc.deviceId(), mastershipService.getMasterFor(groupDesc.deviceId()));
        return;
    }
    log.debug("Store group for device {} is getting handled locally", groupDesc.deviceId());
    storeGroupDescriptionInternal(groupDesc);
}
#method_after
@Override
public void storeGroupDescription(GroupDescription groupDesc) {
    log.debug("In storeGroupDescription");
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        log.warn("Group already exists with the same key {}", groupDesc.appCookie());
        return;
    }
    // Check if group to be created by a remote instance
    if (mastershipService.getLocalRole(groupDesc.deviceId()) != MastershipRole.MASTER) {
        log.debug("storeGroupDescription: Device {} local role is not MASTER", groupDesc.deviceId());
        if (mastershipService.getMasterFor(groupDesc.deviceId()) == null) {
            log.error("No Master for device {}..." + "Can not perform add group operation", groupDesc.deviceId());
            // TODO: Send Group operation failure event
            return;
        }
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupAddRequestMsg(groupDesc.deviceId(), groupDesc);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(groupDesc.deviceId()))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(groupDesc.deviceId()));
            // TODO: Send Group operation failure event
            return;
        }
        log.debug("Sent Group operation request for device {} to remote MASTER {}", groupDesc.deviceId(), mastershipService.getMasterFor(groupDesc.deviceId()));
        return;
    }
    log.debug("Store group for device {} is getting handled locally", groupDesc.deviceId());
    storeGroupDescriptionInternal(groupDesc);
}
#end_block

#method_before
private void storeGroupDescriptionInternal(GroupDescription groupDesc) {
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        return;
    }
    if (deviceAuditStatus.get(groupDesc.deviceId()) == null) {
        // Device group audit has not completed yet
        // Add this group description to pending group key table
        // Create a group entry object with Dummy Group ID
        log.debug("storeGroupDescriptionInternal: Device {} AUDIT " + "pending...Queuing Group ADD request", groupDesc.deviceId());
        StoredGroupEntry group = new DefaultGroup(dummyGroupId, groupDesc);
        group.setState(GroupState.WAITING_AUDIT_COMPLETE);
        EventuallyConsistentMap<GroupStoreKeyMapKey, StoredGroupEntry> pendingKeyTable = getPendingGroupKeyTable();
        pendingKeyTable.put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
        return;
    }
    GroupId id = null;
    if (groupDesc.givenGroupId() == null) {
        // Get a new group identifier
        id = new DefaultGroupId(getFreeGroupIdValue(groupDesc.deviceId()));
    } else {
        id = new DefaultGroupId(groupDesc.givenGroupId());
    }
    // Create a group entry object
    StoredGroupEntry group = new DefaultGroup(id, groupDesc);
    // Insert the newly created group entry into key and id maps
    getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
    // Ensure it also inserted into group id based table to
    // avoid any chances of duplication in group id generation
    getGroupIdTable(groupDesc.deviceId()).put(id, group);
    log.debug("storeGroupDescriptionInternal: Processing Group " + "ADD request for Id {} in device {}", id, groupDesc.deviceId());
    notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
}
#method_after
private void storeGroupDescriptionInternal(GroupDescription groupDesc) {
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        return;
    }
    if (deviceAuditStatus.get(groupDesc.deviceId()) == null) {
        // Device group audit has not completed yet
        // Add this group description to pending group key table
        // Create a group entry object with Dummy Group ID
        log.debug("storeGroupDescriptionInternal: Device {} AUDIT pending...Queuing Group ADD request", groupDesc.deviceId());
        StoredGroupEntry group = new DefaultGroup(dummyGroupId, groupDesc);
        group.setState(GroupState.WAITING_AUDIT_COMPLETE);
        EventuallyConsistentMap<GroupStoreKeyMapKey, StoredGroupEntry> pendingKeyTable = getPendingGroupKeyTable();
        pendingKeyTable.put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
        return;
    }
    GroupId id = null;
    if (groupDesc.givenGroupId() == null) {
        // Get a new group identifier
        id = new DefaultGroupId(getFreeGroupIdValue(groupDesc.deviceId()));
    } else {
        id = new DefaultGroupId(groupDesc.givenGroupId());
    }
    // Create a group entry object
    StoredGroupEntry group = new DefaultGroup(id, groupDesc);
    // Insert the newly created group entry into key and id maps
    getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
    // Ensure it also inserted into group id based table to
    // avoid any chances of duplication in group id generation
    getGroupIdTable(groupDesc.deviceId()).put(id, group);
    log.debug("storeGroupDescriptionInternal: Processing Group ADD request for Id {} in device {}", id, groupDesc.deviceId());
    notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
}
#end_block

#method_before
@Override
public void updateGroupDescription(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if group update to be done by a remote instance
    if (mastershipService.getMasterFor(deviceId) != null && mastershipService.getLocalRole(deviceId) != MastershipRole.MASTER) {
        log.debug("updateGroupDescription: Device {} local " + "role is not MASTER", deviceId);
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupUpdateRequestMsg(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(deviceId))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(deviceId));
        // TODO: Send Group operation failure event
        }
        return;
    }
    log.debug("updateGroupDescription for device {} " + "is getting handled locally", deviceId);
    updateGroupDescriptionInternal(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
}
#method_after
@Override
public void updateGroupDescription(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if group update to be done by a remote instance
    if (mastershipService.getMasterFor(deviceId) != null && mastershipService.getLocalRole(deviceId) != MastershipRole.MASTER) {
        log.debug("updateGroupDescription: Device {} local role is not MASTER", deviceId);
        if (mastershipService.getMasterFor(deviceId) == null) {
            log.error("No Master for device {}..." + "Can not perform update group operation", deviceId);
            // TODO: Send Group operation failure event
            return;
        }
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupUpdateRequestMsg(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(deviceId))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(deviceId));
        // TODO: Send Group operation failure event
        }
        return;
    }
    log.debug("updateGroupDescription for device {} is getting handled locally", deviceId);
    updateGroupDescriptionInternal(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
}
#end_block

#method_before
private void updateGroupDescriptionInternal(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if a group is existing with the provided key
    Group oldGroup = getGroup(deviceId, oldAppCookie);
    if (oldGroup == null) {
        log.warn("updateGroupDescriptionInternal: Group not found...strange");
        return;
    }
    List<GroupBucket> newBucketList = getUpdatedBucketList(oldGroup, type, newBuckets);
    if (newBucketList != null) {
        // Create a new group object from the old group
        GroupBuckets updatedBuckets = new GroupBuckets(newBucketList);
        GroupKey newCookie = (newAppCookie != null) ? newAppCookie : oldAppCookie;
        GroupDescription updatedGroupDesc = new DefaultGroupDescription(oldGroup.deviceId(), oldGroup.type(), updatedBuckets, newCookie, oldGroup.givenGroupId(), oldGroup.appId());
        StoredGroupEntry newGroup = new DefaultGroup(oldGroup.id(), updatedGroupDesc);
        log.trace("updateGroupDescriptionInternal: group " + "entry {} in device {} moving " + "from {} to PENDING_UPDATE", oldGroup.id(), oldGroup.deviceId(), oldGroup.state());
        newGroup.setState(GroupState.PENDING_UPDATE);
        newGroup.setLife(oldGroup.life());
        newGroup.setPackets(oldGroup.packets());
        newGroup.setBytes(oldGroup.bytes());
        // Update the group entry in groupkey based map.
        // Update to groupid based map will happen in the
        // groupkey based map update listener
        log.trace("updateGroupDescriptionInternal with type {}: Group " + "updated with buckets", type);
        getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(newGroup.deviceId(), newGroup.appCookie()), newGroup);
        notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_REQUESTED, newGroup));
    } else {
        log.warn("updateGroupDescriptionInternal with type {}: No " + "change in the buckets in update", type);
    }
}
#method_after
private void updateGroupDescriptionInternal(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if a group is existing with the provided key
    Group oldGroup = getGroup(deviceId, oldAppCookie);
    if (oldGroup == null) {
        log.warn("updateGroupDescriptionInternal: Group not found...strange");
        return;
    }
    List<GroupBucket> newBucketList = getUpdatedBucketList(oldGroup, type, newBuckets);
    if (newBucketList != null) {
        // Create a new group object from the old group
        GroupBuckets updatedBuckets = new GroupBuckets(newBucketList);
        GroupKey newCookie = (newAppCookie != null) ? newAppCookie : oldAppCookie;
        GroupDescription updatedGroupDesc = new DefaultGroupDescription(oldGroup.deviceId(), oldGroup.type(), updatedBuckets, newCookie, oldGroup.givenGroupId(), oldGroup.appId());
        StoredGroupEntry newGroup = new DefaultGroup(oldGroup.id(), updatedGroupDesc);
        log.debug("updateGroupDescriptionInternal: group entry {} in device {} moving from {} to PENDING_UPDATE", oldGroup.id(), oldGroup.deviceId(), oldGroup.state());
        newGroup.setState(GroupState.PENDING_UPDATE);
        newGroup.setLife(oldGroup.life());
        newGroup.setPackets(oldGroup.packets());
        newGroup.setBytes(oldGroup.bytes());
        // Update the group entry in groupkey based map.
        // Update to groupid based map will happen in the
        // groupkey based map update listener
        log.debug("updateGroupDescriptionInternal with type {}: Group updated with buckets", type);
        getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(newGroup.deviceId(), newGroup.appCookie()), newGroup);
        notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_REQUESTED, newGroup));
    } else {
        log.warn("updateGroupDescriptionInternal with type {}: No " + "change in the buckets in update", type);
    }
}
#end_block

#method_before
@Override
public void deleteGroupDescription(DeviceId deviceId, GroupKey appCookie) {
    // Check if group to be deleted by a remote instance
    if (mastershipService.getLocalRole(deviceId) != MastershipRole.MASTER) {
        log.debug("deleteGroupDescription: Device {} local " + "role is not MASTER", deviceId);
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupDeleteRequestMsg(deviceId, appCookie);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(deviceId))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(deviceId));
        // TODO: Send Group operation failure event
        }
        return;
    }
    log.debug("deleteGroupDescription in device {} " + "is getting handled locally", deviceId);
    deleteGroupDescriptionInternal(deviceId, appCookie);
}
#method_after
@Override
public void deleteGroupDescription(DeviceId deviceId, GroupKey appCookie) {
    // Check if group to be deleted by a remote instance
    if (mastershipService.getLocalRole(deviceId) != MastershipRole.MASTER) {
        log.debug("deleteGroupDescription: Device {} local role is not MASTER", deviceId);
        if (mastershipService.getMasterFor(deviceId) == null) {
            log.error("No Master for device {}..." + "Can not perform delete group operation", deviceId);
            // TODO: Send Group operation failure event
            return;
        }
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupDeleteRequestMsg(deviceId, appCookie);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(deviceId))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(deviceId));
        // TODO: Send Group operation failure event
        }
        return;
    }
    log.debug("deleteGroupDescription in device {} is getting handled locally", deviceId);
    deleteGroupDescriptionInternal(deviceId, appCookie);
}
#end_block

#method_before
private void deleteGroupDescriptionInternal(DeviceId deviceId, GroupKey appCookie) {
    // Check if a group is existing with the provided key
    StoredGroupEntry existing = getStoredGroupEntry(deviceId, appCookie);
    if (existing == null) {
        return;
    }
    log.trace("deleteGroupDescriptionInternal: group " + "entry {} in device {} moving " + "from {} to PENDING_DELETE", existing.id(), existing.deviceId(), existing.state());
    synchronized (existing) {
        existing.setState(GroupState.PENDING_DELETE);
    }
    log.debug("deleteGroupDescriptionInternal: in device {} " + "issuing GROUP_REMOVE_REQUESTED", deviceId);
    notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, existing));
}
#method_after
private void deleteGroupDescriptionInternal(DeviceId deviceId, GroupKey appCookie) {
    // Check if a group is existing with the provided key
    StoredGroupEntry existing = getStoredGroupEntry(deviceId, appCookie);
    if (existing == null) {
        return;
    }
    log.debug("deleteGroupDescriptionInternal: group entry {} in device {} moving from {} to PENDING_DELETE", existing.id(), existing.deviceId(), existing.state());
    synchronized (existing) {
        existing.setState(GroupState.PENDING_DELETE);
    }
    log.debug("deleteGroupDescriptionInternal: in device {} issuing GROUP_REMOVE_REQUESTED", deviceId);
    notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, existing));
}
#end_block

#method_before
@Override
public void addOrUpdateGroupEntry(Group group) {
    // check if this new entry is an update to an existing entry
    StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
    GroupEvent event = null;
    if (existing != null) {
        log.trace("addOrUpdateGroupEntry: updating group " + "entry {} in device {}", group.id(), group.deviceId());
        synchronized (existing) {
            for (GroupBucket bucket : group.buckets().buckets()) {
                Optional<GroupBucket> matchingBucket = existing.buckets().buckets().stream().filter((existingBucket) -> (existingBucket.equals(bucket))).findFirst();
                if (matchingBucket.isPresent()) {
                    ((StoredGroupBucketEntry) matchingBucket.get()).setPackets(bucket.packets());
                    ((StoredGroupBucketEntry) matchingBucket.get()).setBytes(bucket.bytes());
                } else {
                    log.warn("addOrUpdateGroupEntry: No matching " + "buckets to update stats");
                }
            }
            existing.setLife(group.life());
            existing.setPackets(group.packets());
            existing.setBytes(group.bytes());
            if (existing.state() == GroupState.PENDING_ADD) {
                log.trace("addOrUpdateGroupEntry: group " + "entry {} in device {} moving " + "from PENDING_ADD to ADDED", existing.id(), existing.deviceId());
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(true);
                event = new GroupEvent(Type.GROUP_ADDED, existing);
            } else {
                log.trace("addOrUpdateGroupEntry: group " + "entry {} in device {} moving " + "from PENDING_UPDATE to ADDED", existing.id(), existing.deviceId());
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(false);
                event = new GroupEvent(Type.GROUP_UPDATED, existing);
            }
            // Re-PUT map entries to trigger map update events
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()), existing);
        }
    } else {
        log.warn("addOrUpdateGroupEntry: Group update " + "happening for a non-existing entry in the map");
    }
    if (event != null) {
        notifyDelegate(event);
    }
}
#method_after
@Override
public void addOrUpdateGroupEntry(Group group) {
    // check if this new entry is an update to an existing entry
    StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
    GroupEvent event = null;
    if (existing != null) {
        log.debug("addOrUpdateGroupEntry: updating group entry {} in device {}", group.id(), group.deviceId());
        synchronized (existing) {
            for (GroupBucket bucket : group.buckets().buckets()) {
                Optional<GroupBucket> matchingBucket = existing.buckets().buckets().stream().filter((existingBucket) -> (existingBucket.equals(bucket))).findFirst();
                if (matchingBucket.isPresent()) {
                    ((StoredGroupBucketEntry) matchingBucket.get()).setPackets(bucket.packets());
                    ((StoredGroupBucketEntry) matchingBucket.get()).setBytes(bucket.bytes());
                } else {
                    log.warn("addOrUpdateGroupEntry: No matching " + "buckets to update stats");
                }
            }
            existing.setLife(group.life());
            existing.setPackets(group.packets());
            existing.setBytes(group.bytes());
            if (existing.state() == GroupState.PENDING_ADD) {
                log.debug("addOrUpdateGroupEntry: group entry {} in device {} moving from {} to ADDED", existing.id(), existing.deviceId(), GroupState.PENDING_ADD);
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(true);
                event = new GroupEvent(Type.GROUP_ADDED, existing);
            } else {
                log.debug("addOrUpdateGroupEntry: group entry {} in device {} moving from {} to ADDED", existing.id(), existing.deviceId(), GroupState.PENDING_UPDATE);
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(false);
                event = new GroupEvent(Type.GROUP_UPDATED, existing);
            }
            // Re-PUT map entries to trigger map update events
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()), existing);
        }
    } else {
        log.warn("addOrUpdateGroupEntry: Group update " + "happening for a non-existing entry in the map");
    }
    if (event != null) {
        notifyDelegate(event);
    }
}
#end_block

#method_before
@Override
public void removeGroupEntry(Group group) {
    StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
    if (existing != null) {
        log.trace("removeGroupEntry: removing group " + "entry {} in device {}", group.id(), group.deviceId());
        // Removal from groupid based map will happen in the
        // map update listener
        getGroupStoreKeyMap().remove(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()));
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVED, existing));
    } else {
        log.warn("removeGroupEntry for {} in device{} is " + "not existing in our maps", group.id(), group.deviceId());
    }
}
#method_after
@Override
public void removeGroupEntry(Group group) {
    StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
    if (existing != null) {
        log.debug("removeGroupEntry: removing group entry {} in device {}", group.id(), group.deviceId());
        // Removal from groupid based map will happen in the
        // map update listener
        getGroupStoreKeyMap().remove(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()));
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVED, existing));
    } else {
        log.warn("removeGroupEntry for {} in device{} is " + "not existing in our maps", group.id(), group.deviceId());
    }
}
#end_block

#method_before
@Override
public void deviceInitialAuditCompleted(DeviceId deviceId, boolean completed) {
    synchronized (deviceAuditStatus) {
        if (completed) {
            log.debug("deviceInitialAuditCompleted: AUDIT " + "completed for device {}", deviceId);
            deviceAuditStatus.put(deviceId, true);
            // Execute all pending group requests
            List<StoredGroupEntry> pendingGroupRequests = getPendingGroupKeyTable().values().stream().filter(g -> g.deviceId().equals(deviceId)).collect(Collectors.toList());
            log.trace("deviceInitialAuditCompleted: processing " + "pending group add requests for device {} and " + "number of pending requests {}", deviceId, pendingGroupRequests.size());
            for (Group group : pendingGroupRequests) {
                GroupDescription tmp = new DefaultGroupDescription(group.deviceId(), group.type(), group.buckets(), group.appCookie(), group.givenGroupId(), group.appId());
                storeGroupDescriptionInternal(tmp);
                getPendingGroupKeyTable().remove(new GroupStoreKeyMapKey(deviceId, group.appCookie()));
            }
        } else {
            Boolean audited = deviceAuditStatus.get(deviceId);
            if (audited != null && audited) {
                log.debug("deviceInitialAuditCompleted: Clearing AUDIT " + "status for device {}", deviceId);
                deviceAuditStatus.put(deviceId, false);
            }
        }
    }
}
#method_after
@Override
public void deviceInitialAuditCompleted(DeviceId deviceId, boolean completed) {
    synchronized (deviceAuditStatus) {
        if (completed) {
            log.debug("AUDIT completed for device {}", deviceId);
            deviceAuditStatus.put(deviceId, true);
            // Execute all pending group requests
            List<StoredGroupEntry> pendingGroupRequests = getPendingGroupKeyTable().values().stream().filter(g -> g.deviceId().equals(deviceId)).collect(Collectors.toList());
            log.debug("processing pending group add requests for device {} and number of pending requests {}", deviceId, pendingGroupRequests.size());
            for (Group group : pendingGroupRequests) {
                GroupDescription tmp = new DefaultGroupDescription(group.deviceId(), group.type(), group.buckets(), group.appCookie(), group.givenGroupId(), group.appId());
                storeGroupDescriptionInternal(tmp);
                getPendingGroupKeyTable().remove(new GroupStoreKeyMapKey(deviceId, group.appCookie()));
            }
        } else {
            Boolean audited = deviceAuditStatus.get(deviceId);
            if (audited != null && audited) {
                log.debug("Clearing AUDIT status for device {}", deviceId);
                deviceAuditStatus.put(deviceId, false);
            }
        }
    }
}
#end_block

#method_before
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    log.trace("addOrUpdateExtraneousGroupEntry: add/update extraneous " + "group entry {} in device {}", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
    // Check the reference counter
    if (group.referenceCount() == 0) {
        log.trace("addOrUpdateExtraneousGroupEntry: Flow reference " + "counter is zero and triggering remove", group.id(), group.deviceId());
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, group));
    }
}
#method_after
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    log.debug("add/update extraneous group entry {} in device {}", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
    // Check the reference counter
    if (group.referenceCount() == 0) {
        log.debug("Flow reference counter is zero and triggering remove", group.id(), group.deviceId());
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, group));
    }
}
#end_block

#method_before
@Override
public void removeExtraneousGroupEntry(Group group) {
    log.trace("removeExtraneousGroupEntry: remove extraneous " + "group entry {} of device {} from store", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.remove(group.id());
}
#method_after
@Override
public void removeExtraneousGroupEntry(Group group) {
    log.debug("remove extraneous group entry {} of device {} from store", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.remove(group.id());
}
#end_block

#method_before
@Override
public void event(EventuallyConsistentMapEvent<GroupStoreKeyMapKey, StoredGroupEntry> mapEvent) {
    GroupEvent groupEvent = null;
    GroupStoreKeyMapKey key = mapEvent.key();
    StoredGroupEntry group = mapEvent.value();
    if ((key == null) && (group == null)) {
        log.error("GroupStoreKeyMapListener: Received " + "event {} with null entry", mapEvent.type());
        return;
    } else if (group == null) {
        group = getGroupIdTable(key.deviceId()).values().stream().filter((storedGroup) -> (storedGroup.appCookie().equals(key.appCookie))).findFirst().get();
        if (group == null) {
            log.error("GroupStoreKeyMapListener: Received " + "event {} with null entry... can not process", mapEvent.type());
            return;
        }
    }
    log.trace("GroupStoreKeyMapListener: received groupid " + "map event {} for id {} in device {}", mapEvent.type(), group.id(), key.deviceId());
    if (mapEvent.type() == EventuallyConsistentMapEvent.Type.PUT) {
        // Update the group ID table
        getGroupIdTable(group.deviceId()).put(group.id(), group);
        if (mapEvent.value().state() == Group.GroupState.ADDED) {
            if (mapEvent.value().isGroupStateAddedFirstTime()) {
                groupEvent = new GroupEvent(Type.GROUP_ADDED, mapEvent.value());
                log.trace("GroupStoreKeyMapListener: Received first time " + "GROUP_ADDED state update for id {} in device {}", group.id(), group.deviceId());
            } else {
                groupEvent = new GroupEvent(Type.GROUP_UPDATED, mapEvent.value());
                log.trace("GroupStoreKeyMapListener: Received following " + "GROUP_ADDED state update for id {} in device {}", group.id(), group.deviceId());
            }
        }
    } else if (mapEvent.type() == EventuallyConsistentMapEvent.Type.REMOVE) {
        groupEvent = new GroupEvent(Type.GROUP_REMOVED, group);
        // Remove the entry from the group ID table
        getGroupIdTable(group.deviceId()).remove(group.id(), group);
    }
    if (groupEvent != null) {
        notifyDelegate(groupEvent);
    }
}
#method_after
@Override
public void event(EventuallyConsistentMapEvent<GroupStoreKeyMapKey, StoredGroupEntry> mapEvent) {
    GroupEvent groupEvent = null;
    GroupStoreKeyMapKey key = mapEvent.key();
    StoredGroupEntry group = mapEvent.value();
    if ((key == null) && (group == null)) {
        log.error("GroupStoreKeyMapListener: Received " + "event {} with null entry", mapEvent.type());
        return;
    } else if (group == null) {
        group = getGroupIdTable(key.deviceId()).values().stream().filter((storedGroup) -> (storedGroup.appCookie().equals(key.appCookie))).findFirst().get();
        if (group == null) {
            log.error("GroupStoreKeyMapListener: Received " + "event {} with null entry... can not process", mapEvent.type());
            return;
        }
    }
    log.trace("received groupid map event {} for id {} in device {}", mapEvent.type(), group.id(), key.deviceId());
    if (mapEvent.type() == EventuallyConsistentMapEvent.Type.PUT) {
        // Update the group ID table
        getGroupIdTable(group.deviceId()).put(group.id(), group);
        if (mapEvent.value().state() == Group.GroupState.ADDED) {
            if (mapEvent.value().isGroupStateAddedFirstTime()) {
                groupEvent = new GroupEvent(Type.GROUP_ADDED, mapEvent.value());
                log.trace("Received first time GROUP_ADDED state update for id {} in device {}", group.id(), group.deviceId());
            } else {
                groupEvent = new GroupEvent(Type.GROUP_UPDATED, mapEvent.value());
                log.trace("Received following GROUP_ADDED state update for id {} in device {}", group.id(), group.deviceId());
            }
        }
    } else if (mapEvent.type() == EventuallyConsistentMapEvent.Type.REMOVE) {
        groupEvent = new GroupEvent(Type.GROUP_REMOVED, group);
        // Remove the entry from the group ID table
        getGroupIdTable(group.deviceId()).remove(group.id(), group);
    }
    if (groupEvent != null) {
        notifyDelegate(groupEvent);
    }
}
#end_block

#method_before
@Override
public void handle(ClusterMessage message) {
    log.trace("ClusterGroupMsgHandler: received remote " + "group message of type {}", message.subject());
    if (message.subject().equals(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST)) {
        GroupStoreMessage groupOp = kryoBuilder.build().deserialize(message.payload());
        log.trace("ClusterGroupMsgHandler: received remote " + "group operation request for device {}", groupOp.deviceId());
        if (mastershipService.getLocalRole(groupOp.deviceId()) != MastershipRole.MASTER) {
            log.warn("ClusterGroupMsgHandler: This node is not " + "MASTER for device {}", groupOp.deviceId());
            return;
        }
        if (groupOp.type() == GroupStoreMessage.Type.ADD) {
            log.trace("ClusterGroupMsgHandler: processing remote group " + "add operation request");
            storeGroupDescriptionInternal(groupOp.groupDesc());
        } else if (groupOp.type() == GroupStoreMessage.Type.UPDATE) {
            log.trace("ClusterGroupMsgHandler: processing remote group " + "update operation request");
            updateGroupDescriptionInternal(groupOp.deviceId(), groupOp.appCookie(), groupOp.updateType(), groupOp.updateBuckets(), groupOp.newAppCookie());
        } else if (groupOp.type() == GroupStoreMessage.Type.DELETE) {
            log.trace("ClusterGroupMsgHandler: processing remote group " + "delete operation request");
            deleteGroupDescriptionInternal(groupOp.deviceId(), groupOp.appCookie());
        }
    } else {
        log.warn("ClusterGroupMsgHandler: Unknown remote message type");
    }
}
#method_after
@Override
public void handle(ClusterMessage message) {
    if (message.subject().equals(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST)) {
        GroupStoreMessage groupOp = kryoBuilder.build().deserialize(message.payload());
        log.debug("received remote group operation {} request for device {}", groupOp.type(), groupOp.deviceId());
        if (mastershipService.getLocalRole(groupOp.deviceId()) != MastershipRole.MASTER) {
            log.warn("ClusterGroupMsgHandler: This node is not " + "MASTER for device {}", groupOp.deviceId());
            return;
        }
        if (groupOp.type() == GroupStoreMessage.Type.ADD) {
            storeGroupDescriptionInternal(groupOp.groupDesc());
        } else if (groupOp.type() == GroupStoreMessage.Type.UPDATE) {
            updateGroupDescriptionInternal(groupOp.deviceId(), groupOp.appCookie(), groupOp.updateType(), groupOp.updateBuckets(), groupOp.newAppCookie());
        } else if (groupOp.type() == GroupStoreMessage.Type.DELETE) {
            deleteGroupDescriptionInternal(groupOp.deviceId(), groupOp.appCookie());
        }
    } else {
        log.warn("ClusterGroupMsgHandler: Unknown remote message type {}", message.subject());
    }
}
#end_block

#method_before
@Override
public void pushGroupMetrics(DeviceId deviceId, Collection<Group> groupEntries) {
    boolean deviceInitialAuditStatus = deviceInitialAuditStatus(deviceId);
    Set<Group> southboundGroupEntries = Sets.newHashSet(groupEntries);
    Set<StoredGroupEntry> storedGroupEntries = Sets.newHashSet(getStoredGroups(deviceId));
    Set<Group> extraneousStoredEntries = Sets.newHashSet(getExtraneousGroups(deviceId));
    log.trace("pushGroupMetrics: Displaying all ({}) " + "southboundGroupEntries for device {}", southboundGroupEntries.size(), deviceId);
    for (Iterator<Group> it = southboundGroupEntries.iterator(); it.hasNext(); ) {
        Group group = it.next();
        log.trace("Group {} in device {}", group, deviceId);
    }
    log.trace("Displaying all ({}) stored group entries for device {}", storedGroupEntries.size(), deviceId);
    for (Iterator<StoredGroupEntry> it1 = storedGroupEntries.iterator(); it1.hasNext(); ) {
        Group group = it1.next();
        log.trace("Stored Group {} for device {}", group, deviceId);
    }
    for (Iterator<Group> it2 = southboundGroupEntries.iterator(); it2.hasNext(); ) {
        Group group = it2.next();
        if (storedGroupEntries.remove(group)) {
            // we both have the group, let's update some info then.
            log.trace("Group AUDIT: group {} exists " + "in both planes for device {}", group.id(), deviceId);
            groupAdded(group);
            it2.remove();
        }
    }
    for (Group group : southboundGroupEntries) {
        if (getGroup(group.deviceId(), group.id()) != null) {
            // in progress while we got a stale info from switch
            if (!storedGroupEntries.remove(getGroup(group.deviceId(), group.id()))) {
                log.warn("Group AUDIT: Inconsistent state:" + "Group exists in ID based table while " + "not present in key based table");
            }
        } else {
            // there are groups in the switch that aren't in the store
            log.trace("Group AUDIT: extraneous group {} exists " + "in data plane for device {}", group.id(), deviceId);
            extraneousStoredEntries.remove(group);
            extraneousGroup(group);
        }
    }
    for (Group group : storedGroupEntries) {
        // there are groups in the store that aren't in the switch
        log.trace("Group AUDIT: group {} missing " + "in data plane for device {}", group.id(), deviceId);
        groupMissing(group);
    }
    for (Group group : extraneousStoredEntries) {
        // there are groups in the extraneous store that
        // aren't in the switch
        log.trace("Group AUDIT: clearing extransoeus group {} " + "from store for device {}", group.id(), deviceId);
        removeExtraneousGroupEntry(group);
    }
    if (!deviceInitialAuditStatus) {
        log.debug("Group AUDIT: Setting device {} initial " + "AUDIT completed", deviceId);
        deviceInitialAuditCompleted(deviceId, true);
    }
}
#method_after
@Override
public void pushGroupMetrics(DeviceId deviceId, Collection<Group> groupEntries) {
    boolean deviceInitialAuditStatus = deviceInitialAuditStatus(deviceId);
    Set<Group> southboundGroupEntries = Sets.newHashSet(groupEntries);
    Set<StoredGroupEntry> storedGroupEntries = Sets.newHashSet(getStoredGroups(deviceId));
    Set<Group> extraneousStoredEntries = Sets.newHashSet(getExtraneousGroups(deviceId));
    log.trace("pushGroupMetrics: Displaying all ({}) southboundGroupEntries for device {}", southboundGroupEntries.size(), deviceId);
    for (Iterator<Group> it = southboundGroupEntries.iterator(); it.hasNext(); ) {
        Group group = it.next();
        log.trace("Group {} in device {}", group, deviceId);
    }
    log.trace("Displaying all ({}) stored group entries for device {}", storedGroupEntries.size(), deviceId);
    for (Iterator<StoredGroupEntry> it1 = storedGroupEntries.iterator(); it1.hasNext(); ) {
        Group group = it1.next();
        log.trace("Stored Group {} for device {}", group, deviceId);
    }
    for (Iterator<Group> it2 = southboundGroupEntries.iterator(); it2.hasNext(); ) {
        Group group = it2.next();
        if (storedGroupEntries.remove(group)) {
            // we both have the group, let's update some info then.
            log.trace("Group AUDIT: group {} exists in both planes for device {}", group.id(), deviceId);
            groupAdded(group);
            it2.remove();
        }
    }
    for (Group group : southboundGroupEntries) {
        if (getGroup(group.deviceId(), group.id()) != null) {
            // in progress while we got a stale info from switch
            if (!storedGroupEntries.remove(getGroup(group.deviceId(), group.id()))) {
                log.warn("Group AUDIT: Inconsistent state:" + "Group exists in ID based table while " + "not present in key based table");
            }
        } else {
            // there are groups in the switch that aren't in the store
            log.debug("Group AUDIT: extraneous group {} exists in data plane for device {}", group.id(), deviceId);
            extraneousStoredEntries.remove(group);
            extraneousGroup(group);
        }
    }
    for (Group group : storedGroupEntries) {
        // there are groups in the store that aren't in the switch
        log.debug("Group AUDIT: group {} missing in data plane for device {}", group.id(), deviceId);
        groupMissing(group);
    }
    for (Group group : extraneousStoredEntries) {
        // there are groups in the extraneous store that
        // aren't in the switch
        log.debug("Group AUDIT: clearing extransoeus group {} from store for device {}", group.id(), deviceId);
        removeExtraneousGroupEntry(group);
    }
    if (!deviceInitialAuditStatus) {
        log.debug("Group AUDIT: Setting device {} initial AUDIT completed", deviceId);
        deviceInitialAuditCompleted(deviceId, true);
    }
}
#end_block

#method_before
private void groupMissing(Group group) {
    switch(group.state()) {
        case PENDING_DELETE:
            log.debug("Group {} delete confirmation from device {}", group, group.deviceId());
            removeGroupEntry(group);
            break;
        case ADDED:
        case PENDING_ADD:
        case PENDING_UPDATE:
            log.debug("Group {} is in store but not on device {}", group, group.deviceId());
            StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
            log.trace("groupMissing: group " + "entry {} in device {} moving " + "from {} to PENDING_ADD", existing.id(), existing.deviceId(), existing.state());
            existing.setState(Group.GroupState.PENDING_ADD);
            // Re-PUT map entries to trigger map update events
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()), existing);
            notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
            break;
        default:
            log.debug("Group {} has not been installed.", group);
            break;
    }
}
#method_after
private void groupMissing(Group group) {
    switch(group.state()) {
        case PENDING_DELETE:
            log.debug("Group {} delete confirmation from device {}", group, group.deviceId());
            removeGroupEntry(group);
            break;
        case ADDED:
        case PENDING_ADD:
        case PENDING_UPDATE:
            log.debug("Group {} is in store but not on device {}", group, group.deviceId());
            StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
            log.debug("groupMissing: group entry {} in device {} moving from {} to PENDING_ADD", existing.id(), existing.deviceId(), existing.state());
            existing.setState(Group.GroupState.PENDING_ADD);
            // Re-PUT map entries to trigger map update events
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()), existing);
            notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
            break;
        default:
            log.debug("Group {} has not been installed.", group);
            break;
    }
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective fwd) {
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    rules = processForward(fwd);
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::remove);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
            log.debug("Provisioned tables with " + "forwarding rules for segment router");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.debug("Failed to provision tables with " + "forwarding rules for segment router");
        }
    }));
}
#method_after
@Override
public void forward(ForwardingObjective fwd) {
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    rules = processForward(fwd);
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(rule -> rule != null).forEach(flowBuilder::remove);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
            log.debug("Provisioned tables in {} with " + "forwarding rules for segment " + "router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "forwarding rules for segment router", deviceId);
        }
    }));
}
#end_block

#method_before
private void addBucketToGroup(NextObjective nextObjective) {
    log.debug("addBucketToGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    Group group = groupService.getGroup(deviceId, key);
    if (group == null) {
        log.warn("Group is not found in {} for {}", deviceId, key);
        return;
    }
    GroupBucket bucket;
    if (group.type() == GroupDescription.Type.INDIRECT) {
        bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    } else if (group.type() == GroupDescription.Type.SELECT) {
        bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
    } else {
        log.warn("Unsupported Group type {}", group.type());
        return;
    }
    GroupBuckets bucketsToAdd = new GroupBuckets(Arrays.asList(bucket));
    groupService.addBucketsToGroup(deviceId, key, bucketsToAdd, key, appId);
}
#method_after
private void addBucketToGroup(NextObjective nextObjective) {
    log.debug("addBucketToGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
    Group group = groupService.getGroup(deviceId, key);
    if (group == null) {
        log.warn("Group is not found in {} for {}", deviceId, key);
        return;
    }
    GroupBucket bucket;
    if (group.type() == GroupDescription.Type.INDIRECT) {
        bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    } else if (group.type() == GroupDescription.Type.SELECT) {
        bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
    } else {
        log.warn("Unsupported Group type {}", group.type());
        return;
    }
    GroupBuckets bucketsToAdd = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(deviceId, key, bucketsToAdd, key, appId);
}
#end_block

#method_before
private void removeBucketFromGroup(NextObjective nextObjective) {
    log.debug("removeBucketFromGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    if (nextGroup != null) {
        Collection<TrafficTreatment> treatments = nextObjective.next();
        TrafficTreatment treatment = treatments.iterator().next();
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
        Group group = groupService.getGroup(deviceId, key);
        if (group == null) {
            log.warn("Group is not found in {} for {}", deviceId, key);
            return;
        }
        GroupBucket bucket;
        if (group.type() == GroupDescription.Type.INDIRECT) {
            bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
        } else if (group.type() == GroupDescription.Type.SELECT) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
        } else {
            log.warn("Unsupported Group type {}", group.type());
            return;
        }
        GroupBuckets removeBuckets = new GroupBuckets(Arrays.asList(bucket));
        groupService.removeBucketsFromGroup(deviceId, key, removeBuckets, key, appId);
    }
}
#method_after
private void removeBucketFromGroup(NextObjective nextObjective) {
    log.debug("removeBucketFromGroup in {}: for next objective id {}", deviceId, nextObjective.id());
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    if (nextGroup != null) {
        Collection<TrafficTreatment> treatments = nextObjective.next();
        TrafficTreatment treatment = treatments.iterator().next();
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
        Group group = groupService.getGroup(deviceId, key);
        if (group == null) {
            log.warn("Group is not found in {} for {}", deviceId, key);
            return;
        }
        GroupBucket bucket;
        if (group.type() == GroupDescription.Type.INDIRECT) {
            bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
        } else if (group.type() == GroupDescription.Type.SELECT) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(treatment);
        } else {
            log.warn("Unsupported Group type {}", group.type());
            return;
        }
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        groupService.removeBucketsFromGroup(deviceId, key, removeBuckets, key, appId);
    }
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            log.debug("adding rule for IP: {}", ip.ip());
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ip.ip());
            treatment.transition(aclTableId);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(ipv4UnicastTableId).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables with fitering " + "rules for segment router");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.debug("Failed to provision tables with " + "fitering rules for segment router");
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            log.debug("adding rule for IP: {}", ip.ip());
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ip.ip());
            treatment.transition(aclTableId);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(ipv4UnicastTableId).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules for segment router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules for segment router", deviceId);
        }
    }));
}
#end_block

#method_before
@Override
public void notify(GroupEvent event) {
    final Group group = event.subject();
    GroupProvider groupProvider = getProvider(group.deviceId());
    GroupOperations groupOps = null;
    switch(event.type()) {
        case GROUP_ADD_REQUESTED:
            log.debug("GROUP_ADD_REQUESTED for Group {} on device {}", group.id(), group.deviceId());
            GroupOperation groupAddOp = GroupOperation.createAddGroupOperation(group.id(), group.type(), group.buckets());
            groupOps = new GroupOperations(Arrays.asList(groupAddOp));
            groupProvider.performGroupOperation(group.deviceId(), groupOps);
            break;
        case GROUP_UPDATE_REQUESTED:
            log.debug("GROUP_UPDATE_REQUESTED for Group {} on device {}", group.id(), group.deviceId());
            GroupOperation groupModifyOp = GroupOperation.createModifyGroupOperation(group.id(), group.type(), group.buckets());
            groupOps = new GroupOperations(Arrays.asList(groupModifyOp));
            groupProvider.performGroupOperation(group.deviceId(), groupOps);
            break;
        case GROUP_REMOVE_REQUESTED:
            log.debug("GROUP_REMOVE_REQUESTED for Group {} on device {}", group.id(), group.deviceId());
            GroupOperation groupDeleteOp = GroupOperation.createDeleteGroupOperation(group.id(), group.type());
            groupOps = new GroupOperations(Arrays.asList(groupDeleteOp));
            groupProvider.performGroupOperation(group.deviceId(), groupOps);
            break;
        case GROUP_ADDED:
        case GROUP_UPDATED:
        case GROUP_REMOVED:
        case GROUP_ADD_FAILED:
        case GROUP_UPDATE_FAILED:
        case GROUP_REMOVE_FAILED:
            eventDispatcher.post(event);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void notify(GroupEvent event) {
    final Group group = event.subject();
    GroupProvider groupProvider = getProvider(group.deviceId());
    GroupOperations groupOps = null;
    switch(event.type()) {
        case GROUP_ADD_REQUESTED:
            log.debug("GROUP_ADD_REQUESTED for Group {} on device {}", group.id(), group.deviceId());
            GroupOperation groupAddOp = GroupOperation.createAddGroupOperation(group.id(), group.type(), group.buckets());
            groupOps = new GroupOperations(Collections.singletonList(groupAddOp));
            groupProvider.performGroupOperation(group.deviceId(), groupOps);
            break;
        case GROUP_UPDATE_REQUESTED:
            log.debug("GROUP_UPDATE_REQUESTED for Group {} on device {}", group.id(), group.deviceId());
            GroupOperation groupModifyOp = GroupOperation.createModifyGroupOperation(group.id(), group.type(), group.buckets());
            groupOps = new GroupOperations(Collections.singletonList(groupModifyOp));
            groupProvider.performGroupOperation(group.deviceId(), groupOps);
            break;
        case GROUP_REMOVE_REQUESTED:
            log.debug("GROUP_REMOVE_REQUESTED for Group {} on device {}", group.id(), group.deviceId());
            GroupOperation groupDeleteOp = GroupOperation.createDeleteGroupOperation(group.id(), group.type());
            groupOps = new GroupOperations(Collections.singletonList(groupDeleteOp));
            groupProvider.performGroupOperation(group.deviceId(), groupOps);
            break;
        case GROUP_ADDED:
        case GROUP_UPDATED:
        case GROUP_REMOVED:
        case GROUP_ADD_FAILED:
        case GROUP_UPDATE_FAILED:
        case GROUP_REMOVE_FAILED:
            eventDispatcher.post(event);
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withClockService(new NSNextObjStoreLogicalClockManager<>()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    networkConfigService.init();
    deviceConfiguration = new DeviceConfiguration(networkConfigService);
    arpHandler = new ArpHandler(this);
    icmpHandler = new IcmpHandler(this);
    ipHandler = new IpHandler(this);
    routingRulePopulator = new RoutingRulePopulator(this);
    defaultRoutingHandler = new DefaultRoutingHandler(this);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    linkService.addListener(new InternalLinkListener());
    deviceService.addListener(new InternalDeviceListener());
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populateTtpRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withClockService(new WallclockClockManager<>()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    networkConfigService.init();
    deviceConfiguration = new DeviceConfiguration(networkConfigService);
    arpHandler = new ArpHandler(this);
    icmpHandler = new IcmpHandler(this);
    ipHandler = new IpHandler(this);
    routingRulePopulator = new RoutingRulePopulator(this);
    defaultRoutingHandler = new DefaultRoutingHandler(this);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    linkService.addListener(new InternalLinkListener());
    deviceService.addListener(new InternalDeviceListener());
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populateTtpRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
    log.info("Started");
}
#end_block

#method_before
private void scheduleEventHandlerIfNotScheduled(Event event) {
    eventQueue.add(event);
    numOfEvents++;
    if (eventHandlerFuture == null || eventHandlerFuture.isDone()) {
        eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
        numOfHandlerScheduled++;
    }
    log.trace("numOfEvents {}, numOfEventHanlderScheduled {}", numOfEvents, numOfHandlerScheduled);
}
#method_after
private void scheduleEventHandlerIfNotScheduled(Event event) {
    synchronized (eventQueue) {
        eventQueue.add(event);
        numOfEvents++;
        if (eventHandlerFuture == null || eventHandlerFuture.isDone()) {
            eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
            numOfHandlerScheduled++;
        }
    }
    log.trace("numOfEvents {}, numOfEventHanlderScheduled {}", numOfEvents, numOfHandlerScheduled);
}
#end_block

#method_before
@Override
public void run() {
    numOfHandlerExecution++;
    while (!eventQueue.isEmpty()) {
        Event event = eventQueue.poll();
        if (event.type() == LinkEvent.Type.LINK_ADDED) {
            processLinkAdded((Link) event.subject());
        } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
            processLinkRemoved((Link) event.subject());
        // } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
        // processGroupAdded((Group) event.subject());
        } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
            if (deviceService.isAvailable(((Device) event.subject()).id())) {
                processDeviceAdded((Device) event.subject());
            }
        } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
            processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
        } else {
            log.warn("Unhandled event type: {}", event.type());
        }
    }
    log.debug("numOfHandlerExecution {} numOfEventHanlderScheduled {} numOfEvents {}", numOfHandlerExecution, numOfHandlerScheduled, numOfEvents);
}
#method_after
@Override
public void run() {
    try {
        synchronized (eventQueue) {
            numOfHandlerExecution++;
            while (!eventQueue.isEmpty()) {
                Event event = eventQueue.poll();
                if (event.type() == LinkEvent.Type.LINK_ADDED) {
                    processLinkAdded((Link) event.subject());
                } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                    processLinkRemoved((Link) event.subject());
                // } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
                // processGroupAdded((Group) event.subject());
                } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                    if (deviceService.isAvailable(((Device) event.subject()).id())) {
                        processDeviceAdded((Device) event.subject());
                    }
                } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
                    processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
                } else {
                    log.warn("Unhandled event type: {}", event.type());
                }
            }
        }
        log.debug("numOfHandlerExecution {} numOfEventHanlderScheduled {} numOfEvents {}", numOfHandlerExecution, numOfHandlerScheduled, numOfEvents);
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#end_block

#method_before
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link);
        }
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link);
        }
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
    log.trace("processLinkAdded: re-starting route population process");
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private void processLinkRemoved(Link link) {
    log.debug("A link {} was removed", link.toString());
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portDown(link.src().port());
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link);
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
private void processLinkRemoved(Link link) {
    log.debug("A link {} was removed", link.toString());
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portDown(link.src().port());
    }
    // defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link);
    log.trace("processLinkRemoved: re-starting route population process");
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
public void linkUp(Link newLink) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.debug("Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    for (NeighborSet ns : nsSet) {
        // Create the new bucket to be updated
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(newLink.src().port()).setEthDst(deviceConfig.getDeviceMac(newLink.dst().deviceId())).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            NextObjective nextObjective = nextObjBuilder.add();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
}
#method_after
public void linkUp(Link newLink) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.debug("Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    log.trace("linkUp: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the new bucket to be updated
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(newLink.src().port()).setEthDst(deviceConfig.getDeviceMac(newLink.dst().deviceId())).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            NextObjective nextObjective = nextObjBuilder.add();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
}
#end_block

#method_before
public void portDown(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    for (NeighborSet ns : nsSet) {
        // Create the bucket to be removed
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(port).setEthDst(deviceConfig.getDeviceMac(portDeviceMap.get(port))).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).withId(nextId).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            NextObjective nextObjective = nextObjBuilder.remove();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#method_after
public void portDown(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    log.trace("portDown: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the bucket to be removed
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(port).setEthDst(deviceConfig.getDeviceMac(portDeviceMap.get(port))).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).withId(nextId).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            NextObjective nextObjective = nextObjBuilder.remove();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#end_block

#method_before
public int getNextObjectiveId(NeighborSet ns) {
    Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
    if (nextId == null) {
        log.trace("getNextObjectiveId in device{}: Next objective id " + "not found for {} and creating", deviceId, ns);
        createGroupsFromNeighborsets(Collections.singleton(ns));
        nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId == null) {
            log.warn("getNextObjectiveId: unable to create next objective");
            return -1;
        }
    } else {
        log.trace("getNextObjectiveId in device{}: Next objective id {} " + "found for {}", deviceId, nextId.intValue(), ns);
    }
    return nextId.intValue();
}
#method_after
public int getNextObjectiveId(NeighborSet ns) {
    Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
    if (nextId == null) {
        log.trace("getNextObjectiveId in device{}: Next objective id " + "not found for {} and creating", deviceId, ns);
        log.trace("getNextObjectiveId: nsNextObjStore contents for device {}: {}", deviceId, nsNextObjStore.entrySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.getKey().deviceId().equals(deviceId))).collect(Collectors.toList()));
        createGroupsFromNeighborsets(Collections.singleton(ns));
        nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId == null) {
            log.warn("getNextObjectiveId: unable to create next objective");
            return -1;
        } else {
            log.debug("getNextObjectiveId in device{}: Next objective id {} " + "created for {}", deviceId, nextId.intValue(), ns);
        }
    } else {
        log.trace("getNextObjectiveId in device{}: Next objective id {} " + "found for {}", deviceId, nextId.intValue(), ns);
    }
    return nextId.intValue();
}
#end_block

#method_before
protected void createGroupsFromNeighborsets(Set<NeighborSet> nsSet) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId d : ns.getDeviceIds()) {
            if (devicePortMap.get(d) == null) {
                log.warn("Device {} is not in the port map yet", d);
                return;
            }
            for (PortNumber sp : devicePortMap.get(d)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(d)).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        NextObjective nextObj = nextObjBuilder.add();
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#method_after
protected void createGroupsFromNeighborsets(Set<NeighborSet> nsSet) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId d : ns.getDeviceIds()) {
            if (devicePortMap.get(d) == null) {
                log.warn("Device {} is not in the port map yet", d);
                return;
            } else if (devicePortMap.get(d).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", d);
                return;
            }
            for (PortNumber sp : devicePortMap.get(d)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(d)).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        NextObjective nextObj = nextObjBuilder.add();
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#end_block

#method_before
public PolicyGroupIdentifier createPolicyGroupChain(String id, List<PolicyGroupParams> params) {
    List<GroupBucketIdentifier> bucketIds = new ArrayList<GroupBucketIdentifier>();
    for (PolicyGroupParams param : params) {
        List<PortNumber> ports = param.getPorts();
        if (ports == null) {
            log.warn("createPolicyGroupChain in sw {} with wrong " + "input parameters", deviceId);
            return null;
        }
        int labelStackSize = (param.getLabelStack() != null) ? param.getLabelStack().size() : 0;
        if (labelStackSize > 1) {
            for (PortNumber sp : ports) {
                PolicyGroupIdentifier previousGroupkey = null;
                DeviceId neighbor = portDeviceMap.get(sp);
                for (int idx = 0; idx < param.getLabelStack().size(); idx++) {
                    int label = param.getLabelStack().get(idx).intValue();
                    if (idx == (labelStackSize - 1)) {
                        // Innermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        bucketIds.add(bucketId);
                    } else if (idx == 0) {
                        // Outermost Group
                        List<GroupBucket> outBuckets = new ArrayList<GroupBucket>();
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Arrays.asList(param), Arrays.asList(bucketId));
                        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                        tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(neighbor)).setEthSrc(nodeMacAddr).pushMpls().setMpls(MplsLabel.mplsLabel(label));
                        /*outBuckets.add(DefaultGroupBucket.
                                           createSelectGroupBucket(tBuilder.build()));
                            GroupDescription desc = new
                                    DefaultGroupDescription(deviceId,
                                                            GroupDescription.Type.INDIRECT,
                                                            new GroupBuckets(outBuckets));
                            //TODO: BoS*/
                        previousGroupkey = key;
                    // groupService.addGroup(desc);
                    // TODO: Use nextObjective APIs here
                    } else {
                        // Intermediate Groups
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Arrays.asList(param), Arrays.asList(bucketId));
                        // Add to group dependency list
                        dependentGroups.put(previousGroupkey, key);
                        previousGroupkey = key;
                    }
                }
            }
        } else {
            int label = -1;
            if (labelStackSize == 1) {
                label = param.getLabelStack().get(0).intValue();
            }
            for (PortNumber sp : ports) {
                GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                bucketIds.add(bucketId);
            }
        }
    }
    PolicyGroupIdentifier innermostGroupkey = null;
    if (!bucketIds.isEmpty()) {
        innermostGroupkey = new PolicyGroupIdentifier(id, params, bucketIds);
        // Add to group dependency list
        boolean fullyResolved = true;
        for (GroupBucketIdentifier bucketId : bucketIds) {
            if (bucketId.type() == BucketOutputType.GROUP) {
                dependentGroups.put(bucketId.outGroup(), innermostGroupkey);
                fullyResolved = false;
            }
        }
        if (fullyResolved) {
            List<GroupBucket> outBuckets = new ArrayList<GroupBucket>();
            for (GroupBucketIdentifier bucketId : bucketIds) {
                DeviceId neighbor = portDeviceMap.get(bucketId.outPort());
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(bucketId.outPort()).setEthDst(deviceConfig.getDeviceMac(neighbor)).setEthSrc(nodeMacAddr);
                if (bucketId.label() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(bucketId.label()));
                }
            // TODO: BoS
            /*outBuckets.add(DefaultGroupBucket.
                                   createSelectGroupBucket(tBuilder.build()));*/
            }
        /*GroupDescription desc = new
                        DefaultGroupDescription(deviceId,
                                                GroupDescription.Type.SELECT,
                                                new GroupBuckets(outBuckets));
                groupService.addGroup(desc);*/
        // TODO: Use nextObjective APIs here
        }
    }
    return innermostGroupkey;
}
#method_after
public PolicyGroupIdentifier createPolicyGroupChain(String id, List<PolicyGroupParams> params) {
    List<GroupBucketIdentifier> bucketIds = new ArrayList<>();
    for (PolicyGroupParams param : params) {
        List<PortNumber> ports = param.getPorts();
        if (ports == null) {
            log.warn("createPolicyGroupChain in sw {} with wrong " + "input parameters", deviceId);
            return null;
        }
        int labelStackSize = (param.getLabelStack() != null) ? param.getLabelStack().size() : 0;
        if (labelStackSize > 1) {
            for (PortNumber sp : ports) {
                PolicyGroupIdentifier previousGroupkey = null;
                DeviceId neighbor = portDeviceMap.get(sp);
                for (int idx = 0; idx < param.getLabelStack().size(); idx++) {
                    int label = param.getLabelStack().get(idx);
                    if (idx == (labelStackSize - 1)) {
                        // Innermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        bucketIds.add(bucketId);
                    } else if (idx == 0) {
                        // Outermost Group
                        List<GroupBucket> outBuckets = new ArrayList<>();
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                        tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(neighbor)).setEthSrc(nodeMacAddr).pushMpls().setMpls(MplsLabel.mplsLabel(label));
                        /*outBuckets.add(DefaultGroupBucket.
                                           createSelectGroupBucket(tBuilder.build()));
                            GroupDescription desc = new
                                    DefaultGroupDescription(deviceId,
                                                            GroupDescription.Type.INDIRECT,
                                                            new GroupBuckets(outBuckets));
                            //TODO: BoS*/
                        previousGroupkey = key;
                    // groupService.addGroup(desc);
                    // TODO: Use nextObjective APIs here
                    } else {
                        // Intermediate Groups
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        // Add to group dependency list
                        dependentGroups.put(previousGroupkey, key);
                        previousGroupkey = key;
                    }
                }
            }
        } else {
            int label = -1;
            if (labelStackSize == 1) {
                label = param.getLabelStack().get(0);
            }
            for (PortNumber sp : ports) {
                GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                bucketIds.add(bucketId);
            }
        }
    }
    PolicyGroupIdentifier innermostGroupkey = null;
    if (!bucketIds.isEmpty()) {
        innermostGroupkey = new PolicyGroupIdentifier(id, params, bucketIds);
        // Add to group dependency list
        boolean fullyResolved = true;
        for (GroupBucketIdentifier bucketId : bucketIds) {
            if (bucketId.type() == BucketOutputType.GROUP) {
                dependentGroups.put(bucketId.outGroup(), innermostGroupkey);
                fullyResolved = false;
            }
        }
        if (fullyResolved) {
            List<GroupBucket> outBuckets = new ArrayList<>();
            for (GroupBucketIdentifier bucketId : bucketIds) {
                DeviceId neighbor = portDeviceMap.get(bucketId.outPort());
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(bucketId.outPort()).setEthDst(deviceConfig.getDeviceMac(neighbor)).setEthSrc(nodeMacAddr);
                if (bucketId.label() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(bucketId.label()));
                }
            // TODO: BoS
            /*outBuckets.add(DefaultGroupBucket.
                                   createSelectGroupBucket(tBuilder.build()));*/
            }
        /*GroupDescription desc = new
                        DefaultGroupDescription(deviceId,
                                                GroupDescription.Type.SELECT,
                                                new GroupBuckets(outBuckets));
                groupService.addGroup(desc);*/
        // TODO: Use nextObjective APIs here
        }
    }
    return innermostGroupkey;
}
#end_block

#method_before
// TODO: Use nextObjective APIs to handle the group chains
/*@Override
    protected void handleGroupEvent(GroupEvent event) {
        if (event.type() == GroupEvent.Type.GROUP_ADDED) {
            if (dependentGroups.get(event.subject().appCookie()) != null) {
                PolicyGroupIdentifier dependentGroupKey = dependentGroups.get(event.subject().appCookie());
                dependentGroups.remove(event.subject().appCookie());
                boolean fullyResolved = true;
                for (GroupBucketIdentifier bucketId:
                            dependentGroupKey.bucketIds()) {
                    if (bucketId.type() != BucketOutputType.GROUP) {
                        continue;
                    }
                    if (dependentGroups.containsKey(bucketId.outGroup())) {
                        fullyResolved = false;
                        break;
                    }
                }

                if (fullyResolved) {
                    List<GroupBucket> outBuckets = new ArrayList<GroupBucket>();
                    for (GroupBucketIdentifier bucketId:
                                dependentGroupKey.bucketIds()) {
                        TrafficTreatment.Builder tBuilder =
                                DefaultTrafficTreatment.builder();
                        if (bucketId.label() != NeighborSet.NO_EDGE_LABEL) {
                            tBuilder.pushMpls()
                                    .setMpls(MplsLabel.
                                             mplsLabel(bucketId.label()));
                        }
                        //TODO: BoS
                        if (bucketId.type() == BucketOutputType.PORT) {
                            DeviceId neighbor = portDeviceMap.
                                        get(bucketId.outPort());
                            tBuilder.setOutput(bucketId.outPort())
                                    .setEthDst(deviceConfig.
                                               getDeviceMac(neighbor))
                                     .setEthSrc(nodeMacAddr);
                        } else {
                            if (groupService.
                                    getGroup(deviceId,
                                             getGroupKey(bucketId.
                                                       outGroup())) == null) {
                                throw new IllegalStateException();
                            }
                            GroupId indirectGroupId = groupService.
                                    getGroup(deviceId,
                                             getGroupKey(bucketId.
                                                         outGroup())).id();
                            tBuilder.group(indirectGroupId);
                        }
                        outBuckets.add(DefaultGroupBucket.
                                       createSelectGroupBucket(tBuilder.build()));
                    }
                    GroupDescription desc = new
                            DefaultGroupDescription(deviceId,
                                                    GroupDescription.Type.SELECT,
                                                    new GroupBuckets(outBuckets));
                    groupService.addGroup(desc);
                }
            }
        }
    }*/
public PolicyGroupIdentifier generatePolicyGroupKey(String id, List<PolicyGroupParams> params) {
    List<GroupBucketIdentifier> bucketIds = new ArrayList<GroupBucketIdentifier>();
    for (PolicyGroupParams param : params) {
        List<PortNumber> ports = param.getPorts();
        if (ports == null) {
            log.warn("generateGroupKey in sw {} with wrong " + "input parameters", deviceId);
            return null;
        }
        int labelStackSize = (param.getLabelStack() != null) ? param.getLabelStack().size() : 0;
        if (labelStackSize > 1) {
            for (PortNumber sp : ports) {
                PolicyGroupIdentifier previousGroupkey = null;
                for (int idx = 0; idx < param.getLabelStack().size(); idx++) {
                    int label = param.getLabelStack().get(idx).intValue();
                    if (idx == (labelStackSize - 1)) {
                        // Innermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        bucketIds.add(bucketId);
                    } else if (idx == 0) {
                        // Outermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Arrays.asList(param), Arrays.asList(bucketId));
                        previousGroupkey = key;
                    } else {
                        // Intermediate Groups
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Arrays.asList(param), Arrays.asList(bucketId));
                        previousGroupkey = key;
                    }
                }
            }
        } else {
            int label = -1;
            if (labelStackSize == 1) {
                label = param.getLabelStack().get(0).intValue();
            }
            for (PortNumber sp : ports) {
                GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                bucketIds.add(bucketId);
            }
        }
    }
    PolicyGroupIdentifier innermostGroupkey = null;
    if (!bucketIds.isEmpty()) {
        innermostGroupkey = new PolicyGroupIdentifier(id, params, bucketIds);
    }
    return innermostGroupkey;
}
#method_after
// TODO: Use nextObjective APIs to handle the group chains
/*@Override
    protected void handleGroupEvent(GroupEvent event) {
        if (event.type() == GroupEvent.Type.GROUP_ADDED) {
            if (dependentGroups.get(event.subject().appCookie()) != null) {
                PolicyGroupIdentifier dependentGroupKey = dependentGroups.get(event.subject().appCookie());
                dependentGroups.remove(event.subject().appCookie());
                boolean fullyResolved = true;
                for (GroupBucketIdentifier bucketId:
                            dependentGroupKey.bucketIds()) {
                    if (bucketId.type() != BucketOutputType.GROUP) {
                        continue;
                    }
                    if (dependentGroups.containsKey(bucketId.outGroup())) {
                        fullyResolved = false;
                        break;
                    }
                }

                if (fullyResolved) {
                    List<GroupBucket> outBuckets = new ArrayList<GroupBucket>();
                    for (GroupBucketIdentifier bucketId:
                                dependentGroupKey.bucketIds()) {
                        TrafficTreatment.Builder tBuilder =
                                DefaultTrafficTreatment.builder();
                        if (bucketId.label() != NeighborSet.NO_EDGE_LABEL) {
                            tBuilder.pushMpls()
                                    .setMpls(MplsLabel.
                                             mplsLabel(bucketId.label()));
                        }
                        //TODO: BoS
                        if (bucketId.type() == BucketOutputType.PORT) {
                            DeviceId neighbor = portDeviceMap.
                                        get(bucketId.outPort());
                            tBuilder.setOutput(bucketId.outPort())
                                    .setEthDst(deviceConfig.
                                               getDeviceMac(neighbor))
                                     .setEthSrc(nodeMacAddr);
                        } else {
                            if (groupService.
                                    getGroup(deviceId,
                                             getGroupKey(bucketId.
                                                       outGroup())) == null) {
                                throw new IllegalStateException();
                            }
                            GroupId indirectGroupId = groupService.
                                    getGroup(deviceId,
                                             getGroupKey(bucketId.
                                                         outGroup())).id();
                            tBuilder.group(indirectGroupId);
                        }
                        outBuckets.add(DefaultGroupBucket.
                                       createSelectGroupBucket(tBuilder.build()));
                    }
                    GroupDescription desc = new
                            DefaultGroupDescription(deviceId,
                                                    GroupDescription.Type.SELECT,
                                                    new GroupBuckets(outBuckets));
                    groupService.addGroup(desc);
                }
            }
        }
    }*/
public PolicyGroupIdentifier generatePolicyGroupKey(String id, List<PolicyGroupParams> params) {
    List<GroupBucketIdentifier> bucketIds = new ArrayList<>();
    for (PolicyGroupParams param : params) {
        List<PortNumber> ports = param.getPorts();
        if (ports == null) {
            log.warn("generateGroupKey in sw {} with wrong " + "input parameters", deviceId);
            return null;
        }
        int labelStackSize = (param.getLabelStack() != null) ? param.getLabelStack().size() : 0;
        if (labelStackSize > 1) {
            for (PortNumber sp : ports) {
                PolicyGroupIdentifier previousGroupkey = null;
                for (int idx = 0; idx < param.getLabelStack().size(); idx++) {
                    int label = param.getLabelStack().get(idx);
                    if (idx == (labelStackSize - 1)) {
                        // Innermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        bucketIds.add(bucketId);
                    } else if (idx == 0) {
                        // Outermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        previousGroupkey = key;
                    } else {
                        // Intermediate Groups
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        previousGroupkey = key;
                    }
                }
            }
        } else {
            int label = -1;
            if (labelStackSize == 1) {
                label = param.getLabelStack().get(0);
            }
            for (PortNumber sp : ports) {
                GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                bucketIds.add(bucketId);
            }
        }
    }
    PolicyGroupIdentifier innermostGroupkey = null;
    if (!bucketIds.isEmpty()) {
        innermostGroupkey = new PolicyGroupIdentifier(id, params, bucketIds);
    }
    return innermostGroupkey;
}
#end_block

#method_before
public void removeGroupChain(PolicyGroupIdentifier key) {
    if (!(key instanceof PolicyGroupIdentifier)) {
        throw new IllegalArgumentException();
    }
    List<PolicyGroupIdentifier> groupsToBeDeleted = new ArrayList<PolicyGroupIdentifier>();
    groupsToBeDeleted.add(key);
    Iterator<PolicyGroupIdentifier> it = groupsToBeDeleted.iterator();
    while (it.hasNext()) {
        PolicyGroupIdentifier innerMostGroupKey = it.next();
        for (GroupBucketIdentifier bucketId : innerMostGroupKey.bucketIds()) {
            if (bucketId.type() != BucketOutputType.GROUP) {
                groupsToBeDeleted.add(bucketId.outGroup());
            }
        }
        /*groupService.removeGroup(deviceId,
                                     getGroupKey(innerMostGroupKey),
                                     appId);*/
        // TODO: Use nextObjective APIs here
        it.remove();
    }
}
#method_after
public void removeGroupChain(PolicyGroupIdentifier key) {
    checkArgument(key != null);
    List<PolicyGroupIdentifier> groupsToBeDeleted = new ArrayList<>();
    groupsToBeDeleted.add(key);
    Iterator<PolicyGroupIdentifier> it = groupsToBeDeleted.iterator();
    while (it.hasNext()) {
        PolicyGroupIdentifier innerMostGroupKey = it.next();
        for (GroupBucketIdentifier bucketId : innerMostGroupKey.bucketIds()) {
            if (bucketId.type() != BucketOutputType.GROUP) {
                groupsToBeDeleted.add(bucketId.outGroup());
            }
        }
        /*groupService.removeGroup(deviceId,
                                     getGroupKey(innerMostGroupKey),
                                     appId);*/
        // TODO: Use nextObjective APIs here
        it.remove();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof NeighborSetNextObjectiveStoreKey)) {
        return false;
    }
    NeighborSetNextObjectiveStoreKey that = (NeighborSetNextObjectiveStoreKey) o;
    return (this.deviceId.equals(that.deviceId) && this.ns.equals(that.ns));
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof NeighborSetNextObjectiveStoreKey)) {
        return false;
    }
    NeighborSetNextObjectiveStoreKey that = (NeighborSetNextObjectiveStoreKey) o;
    return (Objects.equals(this.deviceId, that.deviceId) && Objects.equals(this.ns, that.ns));
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + Objects.hash(this.deviceId) + Objects.hash(this.ns);
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + Objects.hashCode(this.deviceId) + Objects.hashCode(this.ns);
    return result;
}
#end_block

#method_before
public boolean populateAllRoutingRules() {
    populationStatus = Status.STARTED;
    rulePopulator.resetCounter();
    log.info("Starts to populate routing rules");
    for (Device sw : srManager.deviceService.getDevices()) {
        if (srManager.mastershipService.getLocalRole(sw.id()) != MastershipRole.MASTER) {
            continue;
        }
        log.trace("populateAllRoutingRules: running ECMP graph " + "for device {}", sw.id());
        ECMPShortestPathGraph ecmpSpg = new ECMPShortestPathGraph(sw.id(), srManager);
        if (!populateEcmpRoutingRules(sw.id(), ecmpSpg)) {
            populationStatus = Status.ABORTED;
            log.debug("Abort routing rule population");
            return false;
        }
        currentEcmpSpgMap.put(sw.id(), ecmpSpg);
    // TODO: Set adjacency routing rule for all switches
    }
    populationStatus = Status.SUCCEEDED;
    log.info("Completes routing rule population. Total # of rules pushed : {}", rulePopulator.getCounter());
    return true;
}
#method_after
public boolean populateAllRoutingRules() {
    populationStatus = Status.STARTED;
    rulePopulator.resetCounter();
    log.info("Starts to populate routing rules");
    log.debug("populateAllRoutingRules: populationStatus is STARTED");
    for (Device sw : srManager.deviceService.getDevices()) {
        if (srManager.mastershipService.getLocalRole(sw.id()) != MastershipRole.MASTER) {
            log.debug("populateAllRoutingRules: skipping device {}...we are not master", sw.id());
            continue;
        }
        ECMPShortestPathGraph ecmpSpg = new ECMPShortestPathGraph(sw.id(), srManager);
        if (!populateEcmpRoutingRules(sw.id(), ecmpSpg)) {
            log.debug("populateAllRoutingRules: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.debug("Abort routing rule population");
            return false;
        }
        currentEcmpSpgMap.put(sw.id(), ecmpSpg);
    // TODO: Set adjacency routing rule for all switches
    }
    log.debug("populateAllRoutingRules: populationStatus is SUCCEEDED");
    populationStatus = Status.SUCCEEDED;
    log.info("Completes routing rule population. Total # of rules pushed : {}", rulePopulator.getCounter());
    return true;
}
#end_block

#method_before
public boolean populateRoutingRulesForLinkStatusChange(Link linkFail) {
    synchronized (populationStatus) {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished.");
            return true;
        }
        // Take the snapshots of the links
        updatedEcmpSpgMap = new HashMap<>();
        for (Device sw : srManager.deviceService.getDevices()) {
            if (srManager.mastershipService.getLocalRole(sw.id()) != MastershipRole.MASTER) {
                continue;
            }
            ECMPShortestPathGraph ecmpSpgUpdated = new ECMPShortestPathGraph(sw.id(), srManager);
            updatedEcmpSpgMap.put(sw.id(), ecmpSpgUpdated);
        }
        log.info("Starts rule population from link change");
        Set<ArrayList<DeviceId>> routeChanges;
        populationStatus = Status.STARTED;
        if (linkFail == null) {
            // Compare all routes of existing ECMP SPG with the new ones
            routeChanges = computeRouteChange();
        } else {
            // Compare existing ECMP SPG only with the link removed
            routeChanges = computeDamagedRoutes(linkFail);
        }
        if (routeChanges.isEmpty()) {
            log.info("No route changes for the link status change");
            populationStatus = Status.SUCCEEDED;
            return true;
        }
        if (repopulateRoutingRulesForRoutes(routeChanges)) {
            populationStatus = Status.SUCCEEDED;
            log.info("Complete to repopulate the rules. # of rules populated : {}", rulePopulator.getCounter());
            return true;
        } else {
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules.");
            return false;
        }
    }
}
#method_after
public boolean populateRoutingRulesForLinkStatusChange(Link linkFail) {
    synchronized (populationStatus) {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished.");
            return true;
        }
        // Take the snapshots of the links
        updatedEcmpSpgMap = new HashMap<>();
        for (Device sw : srManager.deviceService.getDevices()) {
            if (srManager.mastershipService.getLocalRole(sw.id()) != MastershipRole.MASTER) {
                continue;
            }
            ECMPShortestPathGraph ecmpSpgUpdated = new ECMPShortestPathGraph(sw.id(), srManager);
            updatedEcmpSpgMap.put(sw.id(), ecmpSpgUpdated);
        }
        log.info("Starts rule population from link change");
        Set<ArrayList<DeviceId>> routeChanges;
        log.trace("populateRoutingRulesForLinkStatusChange: " + "populationStatus is STARTED");
        populationStatus = Status.STARTED;
        if (linkFail == null) {
            // Compare all routes of existing ECMP SPG with the new ones
            routeChanges = computeRouteChange();
        } else {
            // Compare existing ECMP SPG only with the link removed
            routeChanges = computeDamagedRoutes(linkFail);
        }
        if (routeChanges.isEmpty()) {
            log.info("No route changes for the link status change");
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            return true;
        }
        if (repopulateRoutingRulesForRoutes(routeChanges)) {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            log.info("Complete to repopulate the rules. # of rules populated : {}", rulePopulator.getCounter());
            return true;
        } else {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules.");
            return false;
        }
    }
}
#end_block

#method_before
private boolean repopulateRoutingRulesForRoutes(Set<ArrayList<DeviceId>> routes) {
    rulePopulator.resetCounter();
    for (ArrayList<DeviceId> link : routes) {
        // When only the source device is defined, reinstall routes to all other devices
        if (link.size() == 1) {
            log.trace("repopulateRoutingRulesForRoutes: running ECMP graph " + "for device {}", link.get(0));
            ECMPShortestPathGraph ecmpSpg = new ECMPShortestPathGraph(link.get(0), srManager);
            if (populateEcmpRoutingRules(link.get(0), ecmpSpg)) {
                currentEcmpSpgMap.put(link.get(0), ecmpSpg);
            } else {
                log.warn("Failed to populate the flow rules from {} to all", link.get(0));
                return false;
            }
        } else {
            DeviceId src = link.get(0);
            DeviceId dst = link.get(1);
            log.trace("repopulateRoutingRulesForRoutes: running ECMP graph " + "for device {}", dst);
            ECMPShortestPathGraph ecmpSpg = updatedEcmpSpgMap.get(dst);
            HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
            for (Integer itrIdx : switchVia.keySet()) {
                HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
                for (DeviceId targetSw : swViaMap.keySet()) {
                    if (!targetSw.equals(src)) {
                        continue;
                    }
                    Set<DeviceId> nextHops = new HashSet<>();
                    for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                        if (via.isEmpty()) {
                            nextHops.add(dst);
                        } else {
                            nextHops.add(via.get(0));
                        }
                    }
                    if (!populateEcmpRoutingRulePartial(targetSw, dst, nextHops)) {
                        return false;
                    }
                }
            }
            currentEcmpSpgMap.put(dst, ecmpSpg);
        }
    }
    return true;
}
#method_after
private boolean repopulateRoutingRulesForRoutes(Set<ArrayList<DeviceId>> routes) {
    rulePopulator.resetCounter();
    for (ArrayList<DeviceId> link : routes) {
        // When only the source device is defined, reinstall routes to all other devices
        if (link.size() == 1) {
            log.trace("repopulateRoutingRulesForRoutes: running ECMP graph for device {}", link.get(0));
            ECMPShortestPathGraph ecmpSpg = new ECMPShortestPathGraph(link.get(0), srManager);
            if (populateEcmpRoutingRules(link.get(0), ecmpSpg)) {
                currentEcmpSpgMap.put(link.get(0), ecmpSpg);
            } else {
                log.warn("Failed to populate the flow rules from {} to all", link.get(0));
                return false;
            }
        } else {
            DeviceId src = link.get(0);
            DeviceId dst = link.get(1);
            log.trace("repopulateRoutingRulesForRoutes: running ECMP graph for device {}", dst);
            ECMPShortestPathGraph ecmpSpg = updatedEcmpSpgMap.get(dst);
            HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
            for (Integer itrIdx : switchVia.keySet()) {
                HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
                for (DeviceId targetSw : swViaMap.keySet()) {
                    if (!targetSw.equals(src)) {
                        continue;
                    }
                    Set<DeviceId> nextHops = new HashSet<>();
                    for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                        if (via.isEmpty()) {
                            nextHops.add(dst);
                        } else {
                            nextHops.add(via.get(0));
                        }
                    }
                    if (!populateEcmpRoutingRulePartial(targetSw, dst, nextHops)) {
                        return false;
                    }
                }
            }
            currentEcmpSpgMap.put(dst, ecmpSpg);
        }
    }
    return true;
}
#end_block

#method_before
private Set<ArrayList<DeviceId>> computeRouteChange() {
    Set<ArrayList<DeviceId>> routes = new HashSet<>();
    for (Device sw : srManager.deviceService.getDevices()) {
        if (srManager.mastershipService.getLocalRole(sw.id()) != MastershipRole.MASTER) {
            log.warn("No mastership for {} and skip route optimization");
            continue;
        }
        log.trace("link of {} - ", sw.id());
        for (Link link : srManager.linkService.getDeviceLinks(sw.id())) {
            log.trace("{} -> {} ", link.src().deviceId(), link.dst().deviceId());
        }
        log.debug("Checking route change for switch {}", sw.id());
        ECMPShortestPathGraph ecmpSpg = currentEcmpSpgMap.get(sw.id());
        if (ecmpSpg == null) {
            log.debug("No existing ECMP path for Switch {}", sw.id());
            ArrayList<DeviceId> route = new ArrayList<>();
            route.add(sw.id());
            routes.add(route);
            continue;
        }
        log.trace("computeRouteChange: running ECMP graph " + "for device {}", sw.id());
        ECMPShortestPathGraph newEcmpSpg = updatedEcmpSpgMap.get(sw.id());
        currentEcmpSpgMap.put(sw.id(), newEcmpSpg);
        HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
        HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchViaUpdated = newEcmpSpg.getAllLearnedSwitchesAndVia();
        for (Integer itrIdx : switchViaUpdated.keySet()) {
            HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMapUpdated = switchViaUpdated.get(itrIdx);
            for (DeviceId srcSw : swViaMapUpdated.keySet()) {
                ArrayList<ArrayList<DeviceId>> viaUpdated = swViaMapUpdated.get(srcSw);
                ArrayList<ArrayList<DeviceId>> via = getVia(switchVia, srcSw);
                if (via.isEmpty() || !viaUpdated.equals(via)) {
                    ArrayList<DeviceId> route = new ArrayList<>();
                    route.add(srcSw);
                    route.add(sw.id());
                    routes.add(route);
                }
            }
        }
    }
    for (ArrayList<DeviceId> link : routes) {
        log.trace("Link changes - ");
        if (link.size() == 1) {
            log.trace(" : {} - all", link.get(0));
        } else {
            log.trace(" : {} - {}", link.get(0), link.get(1));
        }
    }
    return routes;
}
#method_after
private Set<ArrayList<DeviceId>> computeRouteChange() {
    Set<ArrayList<DeviceId>> routes = new HashSet<>();
    for (Device sw : srManager.deviceService.getDevices()) {
        if (srManager.mastershipService.getLocalRole(sw.id()) != MastershipRole.MASTER) {
            log.warn("No mastership for {} and skip route optimization");
            continue;
        }
        log.trace("link of {} - ", sw.id());
        for (Link link : srManager.linkService.getDeviceLinks(sw.id())) {
            log.trace("{} -> {} ", link.src().deviceId(), link.dst().deviceId());
        }
        log.debug("Checking route change for switch {}", sw.id());
        ECMPShortestPathGraph ecmpSpg = currentEcmpSpgMap.get(sw.id());
        if (ecmpSpg == null) {
            log.debug("No existing ECMP graph for device {}", sw.id());
            ArrayList<DeviceId> route = new ArrayList<>();
            route.add(sw.id());
            routes.add(route);
            continue;
        }
        ECMPShortestPathGraph newEcmpSpg = updatedEcmpSpgMap.get(sw.id());
        currentEcmpSpgMap.put(sw.id(), newEcmpSpg);
        HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
        HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchViaUpdated = newEcmpSpg.getAllLearnedSwitchesAndVia();
        for (Integer itrIdx : switchViaUpdated.keySet()) {
            HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMapUpdated = switchViaUpdated.get(itrIdx);
            for (DeviceId srcSw : swViaMapUpdated.keySet()) {
                ArrayList<ArrayList<DeviceId>> viaUpdated = swViaMapUpdated.get(srcSw);
                ArrayList<ArrayList<DeviceId>> via = getVia(switchVia, srcSw);
                if (via.isEmpty() || !viaUpdated.equals(via)) {
                    ArrayList<DeviceId> route = new ArrayList<>();
                    route.add(srcSw);
                    route.add(sw.id());
                    routes.add(route);
                }
            }
        }
    }
    for (ArrayList<DeviceId> link : routes) {
        log.trace("Link changes - ");
        if (link.size() == 1) {
            log.trace(" : {} - all", link.get(0));
        } else {
            log.trace(" : {} - {}", link.get(0), link.get(1));
        }
    }
    return routes;
}
#end_block

#method_before
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // rule for both subnet and router IP.
    if (config.isEdgeDevice(targetSw) && config.isEdgeDevice(destSw)) {
        List<Ip4Prefix> subnets = config.getSubnets(destSw);
        log.trace("populateEcmpRoutingRulePartial in " + "device{} towards {} for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        Ip4Address routerIp = config.getRouterIp(destSw);
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.trace("populateEcmpRoutingRulePartial in " + "device{} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    // If the target switch is an edge router, then set IP rules for the router IP.
    } else if (config.isEdgeDevice(targetSw)) {
        Ip4Address routerIp = config.getRouterIp(destSw);
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.trace("populateEcmpRoutingRulePartial in " + "device{} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    }
    // Populates MPLS rules to all routers
    log.trace("populateEcmpRoutingRulePartial in " + "device{} towards {} for all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops);
    if (!result) {
        return false;
    }
    return true;
}
#method_after
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // rule for both subnet and router IP.
    if (config.isEdgeDevice(targetSw) && config.isEdgeDevice(destSw)) {
        List<Ip4Prefix> subnets = config.getSubnets(destSw);
        log.debug("populateEcmpRoutingRulePartial in device {} towards {} for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        Ip4Address routerIp = config.getRouterIp(destSw);
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.debug("populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    // If the target switch is an edge router, then set IP rules for the router IP.
    } else if (config.isEdgeDevice(targetSw)) {
        Ip4Address routerIp = config.getRouterIp(destSw);
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.debug("populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    }
    // Populates MPLS rules to all routers
    log.debug("populateEcmpRoutingRulePartial in device{} towards {} for all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops);
    if (!result) {
        return false;
    }
    return true;
}
#end_block

#method_before
public void startPopulationProcess() {
    synchronized (populationStatus) {
        if (populationStatus == Status.IDLE || populationStatus == Status.SUCCEEDED || populationStatus == Status.ABORTED) {
            populationStatus = Status.STARTED;
            populateAllRoutingRules();
        }
    }
}
#method_after
public void startPopulationProcess() {
    synchronized (populationStatus) {
        if (populationStatus == Status.IDLE || populationStatus == Status.SUCCEEDED || populationStatus == Status.ABORTED) {
            populationStatus = Status.STARTED;
            populateAllRoutingRules();
        } else {
            log.warn("Not initiating startPopulationProcess as populationStatus is {}", populationStatus);
        }
    }
}
#end_block

#method_before
@Override
public void event(LeadershipEvent event) {
    log.debug("Leadership Event: time = {} type = {} event = {}", event.time(), event.type(), event);
    if (!event.subject().topic().equals(appId.name())) {
        // Not our topic: ignore
        return;
    }
    if (event.subject().leader() == null || !event.subject().leader().equals(localControllerNode.id())) {
        // The event is not about this instance: ignore
        return;
    }
    switch(event.type()) {
        case LEADER_ELECTED:
            log.info("SDN-IP Leader Elected");
            intentSynchronizer.leaderChanged(true);
            break;
        case LEADER_BOOTED:
            log.info("SDN-IP Leader Lost Election");
            intentSynchronizer.leaderChanged(false);
            break;
        case LEADER_REELECTED:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(LeadershipEvent event) {
    log.debug("Leadership Event: time = {} type = {} event = {}", event.time(), event.type(), event);
    if (!event.subject().topic().equals(appId.name())) {
        // Not our topic: ignore
        return;
    }
    if (Objects.equals(event.subject().leader(), localControllerNode.id())) {
        // The event is not about this instance: ignore
        return;
    }
    switch(event.type()) {
        case LEADER_ELECTED:
            log.info("SDN-IP Leader Elected");
            intentSynchronizer.leaderChanged(true);
            break;
        case LEADER_BOOTED:
            log.info("SDN-IP Leader Lost Election");
            intentSynchronizer.leaderChanged(false);
            break;
        case LEADER_REELECTED:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceService lrs = get(LabelResourceService.class);
    Multimap<DeviceId, LabelResource> map = ArrayListMultimap.create();
    String[] labelIds = releaseLabelIds.split(",");
    DefaultLabelResource resource = null;
    for (int i = 0; i < labelIds.length; i++) {
        resource = new DefaultLabelResource(DeviceId.deviceId(deviceId), LabelResourceId.labelResourceId(Long.parseLong(labelIds[i])));
        map.put(DeviceId.deviceId(deviceId), resource);
    }
    lrs.releaseToDevicePool(map);
}
#method_after
@Override
protected void execute() {
    LabelResourceService lrs = get(LabelResourceService.class);
    Multimap<DeviceId, LabelResource> map = ArrayListMultimap.create();
    String[] labelIds = releaseLabelIds.split(",");
    DefaultLabelResource resource = null;
    for (int i = 0; i < labelIds.length; i++) {
        resource = new DefaultLabelResource(DeviceId.deviceId(deviceId), LabelResourceId.labelResourceId(Long.parseLong(labelIds[i])));
        map.put(DeviceId.deviceId(deviceId), resource);
    }
    lrs.releaseToDevicePool(map);
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceService lrs = get(LabelResourceService.class);
    LabelResourcePool pool = lrs.getDeviceLabelResourcePool(DeviceId.deviceId(deviceId));
    if (pool != null) {
        print(FMT, pool.deviceId().toString(), pool.beginLabel(), pool.endLabel(), pool.totalNum(), pool.usedNum(), pool.currentUsedMaxLabelId(), pool.releaseLabelId().toString());
    } else {
        print(FMT, deviceId, null, null, null, null, null, null);
    }
}
#method_after
@Override
protected void execute() {
    LabelResourceService lrs = get(LabelResourceService.class);
    LabelResourcePool pool = lrs.getDeviceLabelResourcePool(DeviceId.deviceId(deviceId));
    if (pool != null) {
        print(FMT, pool.deviceId().toString(), pool.beginLabel(), pool.endLabel(), pool.totalNum(), pool.usedNum(), pool.currentUsedMaxLabelId(), pool.releaseLabelId().toString());
    } else {
        print(FMT, deviceId, null, null, null, null, null, null);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceService lrs = get(LabelResourceService.class);
    Set<LabelResourceId> release = new HashSet<LabelResourceId>();
    String[] labelIds = releaseLabelIds.split(",");
    LabelResourceId resource = null;
    for (int i = 0; i < labelIds.length; i++) {
        resource = LabelResourceId.labelResourceId(Long.parseLong(labelIds[i]));
        release.add(resource);
    }
    lrs.releaseToGlobalPool(release);
}
#method_after
@Override
protected void execute() {
    LabelResourceService lrs = get(LabelResourceService.class);
    Set<LabelResourceId> release = new HashSet<LabelResourceId>();
    String[] labelIds = releaseLabelIds.split(",");
    LabelResourceId resource = null;
    for (int i = 0; i < labelIds.length; i++) {
        resource = LabelResourceId.labelResourceId(Long.parseLong(labelIds[i]));
        release.add(resource);
    }
    lrs.releaseToGlobalPool(release);
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceService lrs = get(LabelResourceService.class);
    Collection<LabelResource> result = lrs.applyFromDevicePool(DeviceId.deviceId(deviceId), Long.parseLong(applyNum));
    if (result.size() > 0) {
        for (Iterator<LabelResource> iterator = result.iterator(); iterator.hasNext(); ) {
            DefaultLabelResource defaultLabelResource = (DefaultLabelResource) iterator.next();
            print(FMT, defaultLabelResource.deviceId().toString(), defaultLabelResource.labelResourceId().toString());
        }
    }
}
#method_after
@Override
protected void execute() {
    LabelResourceService lrs = get(LabelResourceService.class);
    Collection<LabelResource> result = lrs.applyFromDevicePool(DeviceId.deviceId(deviceId), Long.parseLong(applyNum));
    if (result.size() > 0) {
        for (Iterator<LabelResource> iterator = result.iterator(); iterator.hasNext(); ) {
            DefaultLabelResource defaultLabelResource = (DefaultLabelResource) iterator.next();
            print(FMT, defaultLabelResource.deviceId().toString(), defaultLabelResource.labelResourceId().toString());
        }
    }
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.destroyGlobalPool();
}
#method_after
@Override
protected void execute() {
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.destroyGlobalPool();
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.createDevicePool(DeviceId.deviceId(deviceId), LabelResourceId.labelResourceId(Long.parseLong(beginLabel)), LabelResourceId.labelResourceId(Long.parseLong(endLabel)));
}
#method_after
@Override
protected void execute() {
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.createDevicePool(DeviceId.deviceId(deviceId), LabelResourceId.labelResourceId(Long.parseLong(beginLabel)), LabelResourceId.labelResourceId(Long.parseLong(endLabel)));
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.destroyDevicePool(DeviceId.deviceId(deviceId));
}
#method_after
@Override
protected void execute() {
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.destroyDevicePool(DeviceId.deviceId(deviceId));
}
#end_block

#method_before
@Override
public boolean createDevicePool(DeviceId deviceId, LabelResourceId beginLabel, LabelResourceId endLabel) {
    return store.createDevicePool(deviceId, beginLabel, endLabel);
}
#method_after
@Override
public boolean createDevicePool(DeviceId deviceId, LabelResourceId beginLabel, LabelResourceId endLabel) {
    checkNotNull(deviceId, "deviceId is not null");
    checkNotNull(beginLabel, "beginLabel is not null");
    checkNotNull(endLabel, "beginLabel is not null");
    checkArgument(beginLabel.labelId() < 0 || endLabel.labelId() < 0, "The value of beginLabel and the value of endLabel must be both positive number.");
    checkArgument(beginLabel.labelId() > endLabel.labelId(), "The value of endLabel must be greater than the value of endLabel.");
    return store.createDevicePool(deviceId, beginLabel, endLabel);
}
#end_block

#method_before
@Override
public boolean createGlobalPool(LabelResourceId beginLabel, LabelResourceId endLabel) {
    return store.createGlobalPool(beginLabel, endLabel);
}
#method_after
@Override
public boolean createGlobalPool(LabelResourceId beginLabel, LabelResourceId endLabel) {
    checkNotNull(beginLabel, "beginLabel is not null");
    checkNotNull(endLabel, "beginLabel is not null");
    checkArgument(beginLabel.labelId() < 0 || endLabel.labelId() < 0, "The value of beginLabel and the value of endLabel must be both positive number.");
    checkArgument(beginLabel.labelId() > endLabel.labelId(), "The value of endLabel must be greater than the value of endLabel.");
    return store.createGlobalPool(beginLabel, endLabel);
}
#end_block

#method_before
@Override
public boolean destroyDevicePool(DeviceId deviceId) {
    return store.destroyDevicePool(deviceId);
}
#method_after
@Override
public boolean destroyDevicePool(DeviceId deviceId) {
    checkNotNull(deviceId, "deviceId is not null");
    return store.destroyDevicePool(deviceId);
}
#end_block

#method_before
@Override
public Collection<LabelResource> applyFromDevicePool(DeviceId deviceId, long applyNum) {
    return store.applyFromDevicePool(deviceId, applyNum);
}
#method_after
@Override
public Collection<LabelResource> applyFromDevicePool(DeviceId deviceId, long applyNum) {
    checkNotNull(deviceId, "deviceId is not null");
    checkNotNull(applyNum, "applyNum is not null");
    return store.applyFromDevicePool(deviceId, applyNum);
}
#end_block

#method_before
@Override
public Collection<LabelResource> applyFromGlobalPool(long applyNum) {
    return store.applyFromGlobalPool(applyNum);
}
#method_after
@Override
public Collection<LabelResource> applyFromGlobalPool(long applyNum) {
    checkNotNull(applyNum, "applyNum is not null");
    return store.applyFromGlobalPool(applyNum);
}
#end_block

#method_before
@Override
public boolean releaseToDevicePool(Multimap<DeviceId, LabelResource> release) {
    return store.releaseToDevicePool(release);
}
#method_after
@Override
public boolean releaseToDevicePool(Multimap<DeviceId, LabelResource> release) {
    checkNotNull(release, "release is not null");
    return store.releaseToDevicePool(release);
}
#end_block

#method_before
@Override
public boolean releaseToGlobalPool(Set<LabelResourceId> release) {
    return store.releaseToGlobalPool(release);
}
#method_after
@Override
public boolean releaseToGlobalPool(Set<LabelResourceId> release) {
    checkNotNull(release, "release is not null");
    return store.releaseToGlobalPool(release);
}
#end_block

#method_before
@Override
public boolean isDevicePoolFull(DeviceId deviceId) {
    return store.isDevicePoolFull(deviceId);
}
#method_after
@Override
public boolean isDevicePoolFull(DeviceId deviceId) {
    checkNotNull(deviceId, "deviceId is not null");
    return store.isDevicePoolFull(deviceId);
}
#end_block

#method_before
@Override
public long getFreeNumOfDevicePool(DeviceId deviceId) {
    return store.getFreeNumOfDevicePool(deviceId);
}
#method_after
@Override
public long getFreeNumOfDevicePool(DeviceId deviceId) {
    checkNotNull(deviceId, "deviceId is not null");
    return store.getFreeNumOfDevicePool(deviceId);
}
#end_block

#method_before
@Override
public LabelResourcePool getDeviceLabelResourcePool(DeviceId deviceId) {
    return store.getDeviceLabelResourcePool(deviceId);
}
#method_after
@Override
public LabelResourcePool getDeviceLabelResourcePool(DeviceId deviceId) {
    checkNotNull(deviceId, "deviceId is not null");
    return store.getDeviceLabelResourcePool(deviceId);
}
#end_block

#method_before
@Override
public void deviceLabelResourcePoolDetected(DeviceId deviceId, LabelResourceId beginLabel, LabelResourceId endLabel) {
    createDevicePool(deviceId, beginLabel, endLabel);
}
#method_after
@Override
public void deviceLabelResourcePoolDetected(DeviceId deviceId, LabelResourceId beginLabel, LabelResourceId endLabel) {
    checkNotNull(deviceId, "deviceId is not null");
    checkNotNull(beginLabel, "beginLabel is not null");
    checkNotNull(endLabel, "endLabel is not null");
    createDevicePool(deviceId, beginLabel, endLabel);
}
#end_block

#method_before
@Override
public void deviceLabelResourcePoolDestroyed(DeviceId deviceId) {
    destroyDevicePool(deviceId);
}
#method_after
@Override
public void deviceLabelResourcePoolDestroyed(DeviceId deviceId) {
    checkNotNull(deviceId, "deviceId is not null");
    destroyDevicePool(deviceId);
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceService lrs = get(LabelResourceService.class);
    LabelResourcePool pool = lrs.getGlobalLabelResourcePool();
    if (pool != null) {
        print(FMT, pool.deviceId().toString(), pool.beginLabel(), pool.endLabel(), pool.totalNum(), pool.usedNum(), pool.currentUsedMaxLabelId(), pool.releaseLabelId().toString());
    }
}
#method_after
@Override
protected void execute() {
    LabelResourceService lrs = get(LabelResourceService.class);
    LabelResourcePool pool = lrs.getGlobalLabelResourcePool();
    if (pool != null) {
        print(FMT, pool.deviceId().toString(), pool.beginLabel(), pool.endLabel(), pool.totalNum(), pool.usedNum(), pool.currentUsedMaxLabelId(), pool.releaseLabelId().toString());
    }
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.createGlobalPool(LabelResourceId.labelResourceId(Long.parseLong(beginLabel)), LabelResourceId.labelResourceId(Long.parseLong(endLabel)));
}
#method_after
@Override
protected void execute() {
    LabelResourceAdminService lrs = get(LabelResourceAdminService.class);
    lrs.createGlobalPool(LabelResourceId.labelResourceId(Long.parseLong(beginLabel)), LabelResourceId.labelResourceId(Long.parseLong(endLabel)));
}
#end_block

#method_before
@Activate
public void activate() {
    resourcePool = storageService.createConsistentMap(POOL_MAP_NAME, new Serializer() {

        KryoNamespace kryo = new KryoNamespace.Builder().register(KryoNamespaces.API).build();

        @Override
        public <T> byte[] encode(T object) {
            return kryo.serialize(object);
        }

        @Override
        public <T> T decode(byte[] bytes) {
            return kryo.deserialize(bytes);
        }
    });
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/flow", "message-handlers"));
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_CREATED, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            LabelResourcePool operation = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", operation);
            boolean b = internalCreate(operation);
            try {
                message.respond(SERIALIZER.encode(b));
            } catch (IOException e) {
                log.error("Failed to create the resource pool", e);
            }
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_DESTROYED, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            DeviceId deviceId = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", deviceId);
            boolean b = internalDestroy(deviceId);
            try {
                message.respond(SERIALIZER.encode(b));
            } catch (IOException e) {
                log.error("Failed to destroy the resource pool", e);
            }
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_APPLY, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            LabelResourceRequest request = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", request);
            final Collection<LabelResource> resource = internalApply(request);
            try {
                message.respond(SERIALIZER.encode(resource));
            } catch (IOException e) {
                log.error("Failed to apply the label resource", e);
            }
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_RELEASE, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            LabelResourceRequest request = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", request);
            final boolean isSuccess = internalRelease(request);
            try {
                message.respond(SERIALIZER.encode(isSuccess));
            } catch (IOException e) {
                log.error("Failed to release the resource pool", e);
            }
        }
    }, messageHandlingExecutor);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    resourcePool = storageService.<DeviceId, LabelResourcePool>consistentMapBuilder().withName(POOL_MAP_NAME).withSerializer(new Serializer() {

        KryoNamespace kryo = new KryoNamespace.Builder().register(KryoNamespaces.API).build();

        @Override
        public <T> byte[] encode(T object) {
            return kryo.serialize(object);
        }

        @Override
        public <T> T decode(byte[] bytes) {
            return kryo.deserialize(bytes);
        }
    }).withPartitionsDisabled().build();
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/flow", "message-handlers"));
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_CREATED, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            LabelResourcePool operation = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", operation);
            boolean b = internalCreate(operation);
            message.respond(SERIALIZER.encode(b));
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_DESTROYED, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            DeviceId deviceId = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", deviceId);
            boolean b = internalDestroy(deviceId);
            message.respond(SERIALIZER.encode(b));
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_APPLY, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            LabelResourceRequest request = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", request);
            final Collection<LabelResource> resource = internalApply(request);
            message.respond(SERIALIZER.encode(resource));
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(LabelResourceMessageSubjects.LABEL_POOL_RELEASE, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            LabelResourceRequest request = SERIALIZER.decode(message.payload());
            log.trace("received get flow entry request for {}", request);
            final boolean isSuccess = internalRelease(request);
            message.respond(SERIALIZER.encode(isSuccess));
        }
    }, messageHandlingExecutor);
    log.info("Started");
}
#end_block

#method_before
private boolean create(LabelResourcePool pool) {
    if (pool.beginLabel().labelId() < 0 || pool.endLabel().labelId() < 0) {
        log.warn("the value of beginLabel and the value of endLabel must be both positive number.");
        return false;
    }
    Device device = (Device) deviceService.getDevice(pool.deviceId());
    if (device == null) {
        return false;
    }
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(pool.deviceId());
    if (!replicaInfo.master().isPresent()) {
        log.warn("Failed to getFlowEntries: No master for {}", pool);
        return false;
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return internalCreate(pool);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), pool.deviceId());
    ClusterMessage message = new ClusterMessage(clusterService.getLocalNode().id(), LabelResourceMessageSubjects.LABEL_POOL_CREATED, SERIALIZER.encode(pool));
    try {
        Future<byte[]> responseFuture = clusterCommunicator.sendAndReceive(message, replicaInfo.master().get());
        return SERIALIZER.decode(responseFuture.get(FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS));
    } catch (IOException | TimeoutException | ExecutionException | InterruptedException e) {
        log.warn("Unable to fetch flow store contents from {}", replicaInfo.master().get());
    }
    return true;
}
#method_after
private boolean create(LabelResourcePool pool) {
    Device device = (Device) deviceService.getDevice(pool.deviceId());
    if (device == null) {
        return false;
    }
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(pool.deviceId());
    if (!replicaInfo.master().isPresent()) {
        log.warn("Failed to getFlowEntries: No master for {}", pool);
        return false;
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return internalCreate(pool);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), pool.deviceId());
    return complete(clusterCommunicator.sendAndReceive(pool, LabelResourceMessageSubjects.LABEL_POOL_CREATED, SERIALIZER::encode, SERIALIZER::decode, replicaInfo.master().get()));
}
#end_block

#method_before
@Override
public boolean destroyDevicePool(DeviceId deviceId) {
    if (deviceId == null || "".equals(deviceId.toString())) {
        log.warn("the value of device is null");
        return false;
    }
    Device device = (Device) deviceService.getDevice(deviceId);
    if (device == null) {
        return false;
    }
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
    if (!replicaInfo.master().isPresent()) {
        log.warn("Failed to getFlowEntries: No master for {}", deviceId);
        return false;
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return internalDestroy(deviceId);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), deviceId);
    ClusterMessage message = new ClusterMessage(clusterService.getLocalNode().id(), LabelResourceMessageSubjects.LABEL_POOL_DESTROYED, SERIALIZER.encode(deviceId));
    try {
        Future<byte[]> responseFuture = clusterCommunicator.sendAndReceive(message, replicaInfo.master().get());
        return SERIALIZER.decode(responseFuture.get(FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS));
    } catch (IOException | TimeoutException | ExecutionException | InterruptedException e) {
        log.warn("Unable to fetch flow store contents from {}", replicaInfo.master().get());
    }
    return true;
}
#method_after
@Override
public boolean destroyDevicePool(DeviceId deviceId) {
    Device device = (Device) deviceService.getDevice(deviceId);
    if (device == null) {
        return false;
    }
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
    if (!replicaInfo.master().isPresent()) {
        log.warn("Failed to getFlowEntries: No master for {}", deviceId);
        return false;
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return internalDestroy(deviceId);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), deviceId);
    return complete(clusterCommunicator.sendAndReceive(deviceId, LabelResourceMessageSubjects.LABEL_POOL_DESTROYED, SERIALIZER::encode, SERIALIZER::decode, replicaInfo.master().get()));
}
#end_block

#method_before
@Override
public Collection<LabelResource> applyFromDevicePool(DeviceId deviceId, long applyNum) {
    Device device = (Device) deviceService.getDevice(deviceId);
    if (device == null) {
        return Collections.emptyList();
    }
    LabelResourceRequest request = new LabelResourceRequest(deviceId, LabelResourceRequest.Type.APPLY, applyNum, null);
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
    if (!replicaInfo.master().isPresent()) {
        log.warn("Failed to getFlowEntries: No master for {}", deviceId);
        return Collections.emptyList();
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return internalApply(request);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), deviceId);
    ClusterMessage message = new ClusterMessage(clusterService.getLocalNode().id(), LabelResourceMessageSubjects.LABEL_POOL_APPLY, SERIALIZER.encode(request));
    try {
        Future<byte[]> responseFuture = clusterCommunicator.sendAndReceive(message, replicaInfo.master().get());
        return SERIALIZER.decode(responseFuture.get(FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS));
    } catch (IOException | TimeoutException | ExecutionException | InterruptedException e) {
        log.warn("Unable to fetch flow store contents from {}", replicaInfo.master().get());
    }
    return null;
}
#method_after
@Override
public Collection<LabelResource> applyFromDevicePool(DeviceId deviceId, long applyNum) {
    Device device = (Device) deviceService.getDevice(deviceId);
    if (device == null) {
        return Collections.emptyList();
    }
    LabelResourceRequest request = new LabelResourceRequest(deviceId, LabelResourceRequest.Type.APPLY, applyNum, null);
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
    if (!replicaInfo.master().isPresent()) {
        log.warn("Failed to getFlowEntries: No master for {}", deviceId);
        return Collections.emptyList();
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return internalApply(request);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), deviceId);
    return complete(clusterCommunicator.sendAndReceive(request, LabelResourceMessageSubjects.LABEL_POOL_APPLY, SERIALIZER::encode, SERIALIZER::decode, replicaInfo.master().get()));
}
#end_block

#method_before
@Override
public boolean releaseToDevicePool(Multimap<DeviceId, LabelResource> release) {
    Map<DeviceId, Collection<LabelResource>> maps = release.asMap();
    Set<DeviceId> deviceIdSet = maps.keySet();
    LabelResourceRequest request = null;
    for (Iterator<DeviceId> it = deviceIdSet.iterator(); it.hasNext(); ) {
        DeviceId deviceId = (DeviceId) it.next();
        Device device = (Device) deviceService.getDevice(deviceId);
        if (device == null) {
            continue;
        }
        ImmutableSet<LabelResource> collection = ImmutableSet.copyOf(maps.get(deviceId));
        request = new LabelResourceRequest(deviceId, LabelResourceRequest.Type.RELEASE, 0, collection);
        ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
        if (!replicaInfo.master().isPresent()) {
            log.warn("Failed to getFlowEntries: No master for {}", deviceId);
            return false;
        }
        if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
            return internalRelease(request);
        }
        log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), deviceId);
        ClusterMessage message = new ClusterMessage(clusterService.getLocalNode().id(), LabelResourceMessageSubjects.LABEL_POOL_RELEASE, SERIALIZER.encode(request));
        try {
            Future<byte[]> responseFuture = clusterCommunicator.sendAndReceive(message, replicaInfo.master().get());
            return SERIALIZER.decode(responseFuture.get(FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS));
        } catch (IOException | TimeoutException | ExecutionException | InterruptedException e) {
            log.warn("Unable to fetch flow store contents from {}", replicaInfo.master().get());
        }
    }
    return false;
}
#method_after
@Override
public boolean releaseToDevicePool(Multimap<DeviceId, LabelResource> release) {
    Map<DeviceId, Collection<LabelResource>> maps = release.asMap();
    Set<DeviceId> deviceIdSet = maps.keySet();
    LabelResourceRequest request = null;
    for (Iterator<DeviceId> it = deviceIdSet.iterator(); it.hasNext(); ) {
        DeviceId deviceId = (DeviceId) it.next();
        Device device = (Device) deviceService.getDevice(deviceId);
        if (device == null) {
            continue;
        }
        ImmutableSet<LabelResource> collection = ImmutableSet.copyOf(maps.get(deviceId));
        request = new LabelResourceRequest(deviceId, LabelResourceRequest.Type.RELEASE, 0, collection);
        ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
        if (!replicaInfo.master().isPresent()) {
            log.warn("Failed to getFlowEntries: No master for {}", deviceId);
            return false;
        }
        if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
            return internalRelease(request);
        }
        log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", replicaInfo.master().orNull(), deviceId);
        return complete(clusterCommunicator.sendAndReceive(request, LabelResourceMessageSubjects.LABEL_POOL_RELEASE, SERIALIZER::encode, SERIALIZER::decode, replicaInfo.master().get()));
    }
    return false;
}
#end_block

#method_before
@Override
protected void execute() {
    // TODO Auto-generated method stub
    LabelResourceService lrs = get(LabelResourceService.class);
    Collection<LabelResource> result = lrs.applyFromGlobalPool(Long.parseLong(applyNum));
    if (result.size() > 0) {
        for (Iterator<LabelResource> iterator = result.iterator(); iterator.hasNext(); ) {
            DefaultLabelResource defaultLabelResource = (DefaultLabelResource) iterator.next();
            print(FMT, defaultLabelResource.deviceId().toString(), defaultLabelResource.labelResourceId().toString());
        }
    }
}
#method_after
@Override
protected void execute() {
    LabelResourceService lrs = get(LabelResourceService.class);
    Collection<LabelResource> result = lrs.applyFromGlobalPool(Long.parseLong(applyNum));
    if (result.size() > 0) {
        for (Iterator<LabelResource> iterator = result.iterator(); iterator.hasNext(); ) {
            DefaultLabelResource defaultLabelResource = (DefaultLabelResource) iterator.next();
            print(FMT, defaultLabelResource.deviceId().toString(), defaultLabelResource.labelResourceId().toString());
        }
    }
}
#end_block

#method_before
NetworkConfigState getConfigState() {
    return configState;
}
#method_after
public NetworkConfigState getConfigState() {
    return configState;
}
#end_block

#method_before
SwitchConfig getSwitchConfig() {
    return switchConfig;
}
#method_after
public SwitchConfig getSwitchConfig() {
    return switchConfig;
}
#end_block

#method_before
String getMsg() {
    return msg;
}
#method_after
public String getMsg() {
    return msg;
}
#end_block

#method_before
NetworkConfigState getConfigState() {
    return configState;
}
#method_after
public NetworkConfigState getConfigState() {
    return configState;
}
#end_block

#method_before
LinkConfig getLinkConfig() {
    return linkConfig;
}
#method_after
public LinkConfig getLinkConfig() {
    return linkConfig;
}
#end_block

#method_before
String getMsg() {
    return msg;
}
#method_after
public String getMsg() {
    return msg;
}
#end_block

#method_before
private List<ConnectPoint> getCrossConnectPoints(Path path) {
    Iterator<Link> itrLink = path.links().iterator();
    boolean scanning = false;
    List<ConnectPoint> connectPoints = new LinkedList<ConnectPoint>();
    while (itrLink.hasNext()) {
        Link link = itrLink.next();
        // Optical layer ingress point
        if (!scanning && link.type() == Link.Type.OPTICAL) {
            connectPoints.add(checkNotNull(link.dst()));
            scanning = true;
            continue;
        }
        // Optical layer egress point
        if (scanning && link.type() == Link.Type.OPTICAL) {
            connectPoints.add(checkNotNull(link.src()));
            scanning = false;
            continue;
        }
    }
    return connectPoints;
}
#method_after
private List<ConnectPoint> getCrossConnectPoints(Path path) {
    boolean scanning = false;
    List<ConnectPoint> connectPoints = new LinkedList<ConnectPoint>();
    for (Link link : path.links()) {
        if (!isCrossConnectLink(link)) {
            continue;
        }
        if (scanning) {
            connectPoints.add(checkNotNull(link.src()));
            scanning = false;
        } else {
            connectPoints.add(checkNotNull(link.dst()));
            scanning = true;
        }
    }
    return connectPoints;
}
#end_block

#method_before
private boolean checkCrossConnectPoints(List<ConnectPoint> crossConnectPoints) {
    checkArgument(crossConnectPoints.size() % 2 == 0);
    Iterator<ConnectPoint> itr = crossConnectPoints.iterator();
    while (itr.hasNext()) {
        ConnectPoint src = itr.next();
        ConnectPoint dst = itr.next();
        if (inStatusTportMap.get(src) != null || outStatusTportMap.get(dst) != null) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean checkCrossConnectPoints(List<ConnectPoint> crossConnectPoints) {
    checkArgument(crossConnectPoints.size() % 2 == 0);
    Iterator<ConnectPoint> itr = crossConnectPoints.iterator();
    while (itr.hasNext()) {
        // checkArgument at start ensures we'll always have pairs of connect points
        ConnectPoint src = itr.next();
        ConnectPoint dst = itr.next();
        if (inStatusTportMap.get(src) != null || outStatusTportMap.get(dst) != null) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private List<Intent> getIntents(List<ConnectPoint> crossConnectPoints) {
    checkArgument(crossConnectPoints.size() % 2 == 0);
    List<Intent> intents = new LinkedList<Intent>();
    Iterator<ConnectPoint> itr = crossConnectPoints.iterator();
    while (itr.hasNext()) {
        ConnectPoint src = itr.next();
        ConnectPoint dst = itr.next();
        // TODO: should have option for bidirectional OpticalConnectivityIntent
        Intent opticalIntent = OpticalConnectivityIntent.builder().appId(appId).src(src).dst(dst).build();
        Intent opticalIntentRev = OpticalConnectivityIntent.builder().appId(appId).src(dst).dst(src).build();
        intents.add(opticalIntent);
        intents.add(opticalIntentRev);
    }
    return intents;
}
#method_after
private List<Intent> getIntents(List<ConnectPoint> crossConnectPoints) {
    checkArgument(crossConnectPoints.size() % 2 == 0);
    List<Intent> intents = new LinkedList<Intent>();
    Iterator<ConnectPoint> itr = crossConnectPoints.iterator();
    while (itr.hasNext()) {
        // checkArgument at start ensures we'll always have pairs of connect points
        ConnectPoint src = itr.next();
        ConnectPoint dst = itr.next();
        // TODO: should have option for bidirectional OpticalConnectivityIntent
        Intent opticalIntent = OpticalConnectivityIntent.builder().appId(appId).src(src).dst(dst).build();
        Intent opticalIntentRev = OpticalConnectivityIntent.builder().appId(appId).src(dst).dst(src).build();
        intents.add(opticalIntent);
        intents.add(opticalIntentRev);
    }
    return intents;
}
#end_block

#method_before
private List<Intent> getOpticalPath(ConnectPoint ingress, ConnectPoint egress) {
    Set<Path> paths = pathService.getPaths(ingress.deviceId(), egress.deviceId(), new OpticalLinkWeight());
    if (paths.isEmpty()) {
        return Lists.newArrayList();
    }
    List<Intent> connectionList = Lists.newArrayList();
    // Iterate over all paths until a suitable one has been found
    Iterator<Path> itrPath = paths.iterator();
    while (itrPath.hasNext()) {
        Path nextPath = itrPath.next();
        List<ConnectPoint> crossConnectPoints = getCrossConnectPoints(nextPath);
        // Skip to next path if not all connect points are available
        if (!checkCrossConnectPoints(crossConnectPoints)) {
            continue;
        }
        return getIntents(crossConnectPoints);
    }
    return new LinkedList<Intent>();
}
#method_after
private List<Intent> getOpticalPath(ConnectPoint ingress, ConnectPoint egress) {
    Set<Path> paths = pathService.getPaths(ingress.deviceId(), egress.deviceId(), new OpticalLinkWeight());
    if (paths.isEmpty()) {
        return Collections.emptyList();
    }
    List<Intent> connectionList = Lists.newArrayList();
    // Iterate over all paths until a suitable one has been found
    Iterator<Path> itrPath = paths.iterator();
    while (itrPath.hasNext()) {
        Path nextPath = itrPath.next();
        List<ConnectPoint> crossConnectPoints = getCrossConnectPoints(nextPath);
        // Skip to next path if not all connect points are available
        if (!checkCrossConnectPoints(crossConnectPoints)) {
            continue;
        }
        return getIntents(crossConnectPoints);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Activate
public void activate() {
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 6);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // Only IPv4 is supported in current vBNG.
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, VbngManager.appId);
    log.info("vBNG virtual public hosts started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 6);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // Only IPv4 is supported in current vBNG.
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, appId);
    log.info("vBNG virtual public hosts started");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    // Only handle the ARP packets
    if (ethPkt == null || ethPkt.getEtherType() != Ethernet.TYPE_ARP) {
        return;
    }
    ARP arpPacket = (ARP) ethPkt.getPayload();
    // Only handle ARP request packets
    if (arpPacket.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    Ip4Address targetIpAddress = Ip4Address.valueOf(arpPacket.getTargetProtocolAddress());
    // an assigned public IP address
    if (!vbngConfigService.isAssignedPublicIpAddress(targetIpAddress)) {
        return;
    }
    MacAddress virtualHostMac = vbngConfigService.getMacOfPublicIpAddresses();
    if (virtualHostMac == null) {
        return;
    }
    ConnectPoint srcConnectPoint = pkt.receivedFrom();
    Ethernet eth = ARP.buildArpReply(targetIpAddress, virtualHostMac, ethPkt);
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    builder.setOutput(srcConnectPoint.port());
    packetService.emit(new DefaultOutboundPacket(srcConnectPoint.deviceId(), builder.build(), ByteBuffer.wrap(eth.serialize())));
}
#method_after
@Override
public void process(PacketContext context) {
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    // Only handle the ARP packets
    if (ethPkt == null || ethPkt.getEtherType() != Ethernet.TYPE_ARP) {
        return;
    }
    ARP arpPacket = (ARP) ethPkt.getPayload();
    // Only handle ARP request packets
    if (arpPacket.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    Ip4Address targetIpAddress = Ip4Address.valueOf(arpPacket.getTargetProtocolAddress());
    // an assigned public IP address
    if (!vbngConfigService.isAssignedPublicIpAddress(targetIpAddress)) {
        return;
    }
    MacAddress virtualHostMac = vbngConfigService.getPublicFacingMac();
    if (virtualHostMac == null) {
        return;
    }
    ConnectPoint srcConnectPoint = pkt.receivedFrom();
    Ethernet eth = ARP.buildArpReply(targetIpAddress, virtualHostMac, ethPkt);
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    builder.setOutput(srcConnectPoint.port());
    packetService.emit(new DefaultOutboundPacket(srcConnectPoint.deviceId(), builder.build(), ByteBuffer.wrap(eth.serialize())));
}
#end_block

#method_before
private void readConfiguration(String configFilename) {
    File configFile = new File(CONFIG_DIR, configFilename);
    ObjectMapper mapper = new ObjectMapper();
    try {
        log.info("Loading config: {}", configFile.getAbsolutePath());
        VbngConfiguration config = mapper.readValue(configFile, VbngConfiguration.class);
        for (IpPrefix prefix : config.getLocalPublicIpPrefixes()) {
            localPublicIpPrefixes.put(prefix, true);
        }
        nextHopIpAddress = config.getNextHopIpAddress();
        macOfPublicIpAddresses = config.getMacOfPublicIpAddresses();
    } catch (FileNotFoundException e) {
        log.warn("Configuration file not found: {}", configFileName);
    } catch (IOException e) {
        log.error("Error loading configuration", e);
    }
}
#method_after
private void readConfiguration(String configFilename) {
    File configFile = new File(CONFIG_DIR, configFilename);
    ObjectMapper mapper = new ObjectMapper();
    try {
        log.info("Loading config: {}", configFile.getAbsolutePath());
        VbngConfiguration config = mapper.readValue(configFile, VbngConfiguration.class);
        for (IpPrefix prefix : config.getLocalPublicIpPrefixes()) {
            localPublicIpPrefixes.put(prefix, true);
        }
        nextHopIpAddress = config.getNextHopIpAddress();
        macOfPublicIpAddresses = config.getPublicFacingMac();
    } catch (FileNotFoundException e) {
        log.warn("Configuration file not found: {}", configFileName);
    } catch (IOException e) {
        log.error("Error loading configuration", e);
    }
}
#end_block

#method_before
@Override
public Boolean isAssignedPublicIpAddress(IpAddress ipAddress) {
    return ipAddressMap.containsValue(ipAddress);
}
#method_after
@Override
public boolean isAssignedPublicIpAddress(IpAddress ipAddress) {
    return ipAddressMap.containsValue(ipAddress);
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    p2pIntentsFromHost = new ConcurrentHashMap<>();
    p2pIntentsToHost = new ConcurrentHashMap<>();
    privateIpAddressQueue = new LinkedBlockingQueue<>();
    unhandledPriIpAddresses = new HashSet<>();
    privateIpAddressExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("vBNG-CreatorExecutor-%d").build());
    privateIpAddressExecutor.execute(new Runnable() {

        @Override
        public void run() {
            doCreateVbngThread();
        }
    });
    log.info("vBNG Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    p2pIntentsFromHost = new ConcurrentHashMap<>();
    p2pIntentsToHost = new ConcurrentHashMap<>();
    privateIpAddressSet = Sets.newConcurrentHashSet();
    nextHopIpAddress = vbngConfigurationService.getNextHopIpAddress();
    hostListener = new InternalHostListener();
    hostService.addListener(hostListener);
    log.info("vBNG Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.info("vBNG Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    hostService.removeListener(hostListener);
    log.info("vBNG Stopped");
}
#end_block

#method_before
@Override
public IpAddress createVbng(IpAddress privateIpAddress) {
    IpAddress publicIpAddress = vbngConfigurationService.getAvailablePublicIpAddress(privateIpAddress);
    if (publicIpAddress == null) {
        log.info("Did not find an available public IP address to use.");
        return null;
    }
    log.info("Private IP to Public IP mapping: {} --> {}", privateIpAddress, publicIpAddress);
    // next hop
    if (!setupForwardingPaths(privateIpAddress, publicIpAddress)) {
        Set<IpAddressEntry> ipAddressEntries = new HashSet<>();
        ipAddressEntries.add(new IpAddressEntry(privateIpAddress, (short) 1));
        privateIpAddressQueue.add(ipAddressEntries);
    }
    return publicIpAddress;
}
#method_after
@Override
public IpAddress createVbng(IpAddress privateIpAddress) {
    IpAddress publicIpAddress = vbngConfigurationService.getAvailablePublicIpAddress(privateIpAddress);
    if (publicIpAddress == null) {
        log.info("Did not find an available public IP address to use.");
        return null;
    }
    log.info("Private IP to Public IP mapping: {} --> {}", privateIpAddress, publicIpAddress);
    // next hop
    if (!setupForwardingPaths(privateIpAddress, publicIpAddress)) {
        privateIpAddressSet.add(privateIpAddress);
    }
    return publicIpAddress;
}
#end_block

#method_before
private Boolean setupForwardingPaths(IpAddress privateIp, IpAddress publicIp) {
    checkNotNull(privateIp);
    checkNotNull(publicIp);
    IpAddress nextHopIpAddress = vbngConfigurationService.getNextHopIpAddress();
    if (nextHopIpAddress == null) {
        log.info("Did not find next hop IP address");
        return false;
    }
    // we will do nothing and directly return.
    if (p2pIntentsFromHost.containsKey(privateIp) && p2pIntentsToHost.containsKey(privateIp)) {
        return true;
    }
    Host localHost = null;
    Host nextHopHost = null;
    if (!hostService.getHostsByIp(nextHopIpAddress).isEmpty()) {
        nextHopHost = hostService.getHostsByIp(nextHopIpAddress).iterator().next();
    } else {
        // TODO to write a new thread to install intents after ONOS
        // discovers the next hop host
        hostService.startMonitoringIp(nextHopIpAddress);
        if (hostService.getHostsByIp(privateIp).isEmpty()) {
            hostService.startMonitoringIp(privateIp);
        }
        return false;
    }
    if (!hostService.getHostsByIp(privateIp).isEmpty()) {
        localHost = hostService.getHostsByIp(privateIp).iterator().next();
    } else {
        // TODO to write a new thread to install intents after ONOS
        // discovers the next hop host
        hostService.startMonitoringIp(privateIp);
        return false;
    }
    ConnectPoint nextHopConnectPoint = new ConnectPoint(nextHopHost.location().elementId(), nextHopHost.location().port());
    ConnectPoint localHostConnectPoint = new ConnectPoint(localHost.location().elementId(), localHost.location().port());
    // private IP
    if (!p2pIntentsFromHost.containsKey(privateIp)) {
        PointToPointIntent toNextHopIntent = srcMatchIntentGenerator(privateIp, publicIp, nextHopHost.mac(), nextHopConnectPoint, localHostConnectPoint);
        p2pIntentsFromHost.put(privateIp, toNextHopIntent);
        intentService.submit(toNextHopIntent);
    }
    // private IP
    if (!p2pIntentsToHost.containsKey(privateIp)) {
        PointToPointIntent toLocalHostIntent = dstMatchIntentGenerator(publicIp, privateIp, localHost.mac(), localHostConnectPoint, nextHopConnectPoint);
        p2pIntentsToHost.put(nextHopIpAddress, toLocalHostIntent);
        intentService.submit(toLocalHostIntent);
    }
    return true;
}
#method_after
private boolean setupForwardingPaths(IpAddress privateIp, IpAddress publicIp) {
    checkNotNull(privateIp);
    checkNotNull(publicIp);
    if (nextHopIpAddress == null) {
        log.warn("Did not find next hop IP address");
        return false;
    }
    // we will do nothing and directly return.
    if (p2pIntentsFromHost.containsKey(privateIp) && p2pIntentsToHost.containsKey(privateIp)) {
        return true;
    }
    Host localHost = null;
    Host nextHopHost = null;
    if (!hostService.getHostsByIp(nextHopIpAddress).isEmpty()) {
        nextHopHost = hostService.getHostsByIp(nextHopIpAddress).iterator().next();
    } else {
        hostService.startMonitoringIp(nextHopIpAddress);
        if (hostService.getHostsByIp(privateIp).isEmpty()) {
            hostService.startMonitoringIp(privateIp);
        }
        return false;
    }
    if (!hostService.getHostsByIp(privateIp).isEmpty()) {
        localHost = hostService.getHostsByIp(privateIp).iterator().next();
    } else {
        hostService.startMonitoringIp(privateIp);
        return false;
    }
    ConnectPoint nextHopConnectPoint = new ConnectPoint(nextHopHost.location().elementId(), nextHopHost.location().port());
    ConnectPoint localHostConnectPoint = new ConnectPoint(localHost.location().elementId(), localHost.location().port());
    // private IP
    if (!p2pIntentsFromHost.containsKey(privateIp)) {
        PointToPointIntent toNextHopIntent = srcMatchIntentGenerator(privateIp, publicIp, nextHopHost.mac(), nextHopConnectPoint, localHostConnectPoint);
        p2pIntentsFromHost.put(privateIp, toNextHopIntent);
        intentService.submit(toNextHopIntent);
    }
    // private IP
    if (!p2pIntentsToHost.containsKey(privateIp)) {
        PointToPointIntent toLocalHostIntent = dstMatchIntentGenerator(publicIp, privateIp, localHost.mac(), localHostConnectPoint, nextHopConnectPoint);
        p2pIntentsToHost.put(nextHopIpAddress, toLocalHostIntent);
        intentService.submit(toLocalHostIntent);
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    return (int) (index ^ (index >>> 32));
}
#method_after
@Override
public int hashCode() {
    return Long.hashCode(index);
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
    switch(nextObjective.type()) {
        case SIMPLE:
            log.debug("processing SIMPLE next objective");
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() == 1) {
                TrafficTreatment treatment = treatments.iterator().next();
                GroupBucket bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket)), key, null, nextObjective.appId());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case HASHED:
            log.debug("processing HASHED next objective");
            List<GroupBucket> buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createSelectGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(buckets), key, null, nextObjective.appId());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case BROADCAST:
        case FAILOVER:
            log.debug("BROADCAST and FAILOVER next objectives not supported");
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            log.warn("Unsupported next objective type {}", nextObjective.type());
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    if (nextObjective.op() == Objective.Operation.REMOVE) {
        if (nextObjective.next() == null) {
            removeGroup(nextObjective);
        } else {
            removeBucketFromGroup(nextObjective);
        }
    } else if (nextObjective.op() == Objective.Operation.ADD) {
        NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
        if (nextGroup != null) {
            addBucketToGroup(nextObjective);
        } else {
            addGroup(nextObjective);
        }
    } else {
        log.warn("Unsupported operation {}", nextObjective.op());
    }
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("deviceId", deviceId).add("type", type).add("buckets", buckets).add("appId", appId).add("given groupId", givenGroupId).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("deviceId", deviceId).add("type", type).add("buckets", buckets).add("appId", appId).add("givenGroupId", givenGroupId).toString();
}
#end_block

#method_before
@Override
public void addOrUpdateGroupEntry(Group group) {
    // check if this new entry is an update to an existing entry
    StoredGroupEntry existing = (groupEntriesById.get(group.deviceId()) != null) ? groupEntriesById.get(group.deviceId()).get(group.id()) : null;
    GroupEvent event = null;
    if (existing != null) {
        synchronized (existing) {
            for (GroupBucket bucket : group.buckets().buckets()) {
                java.util.Optional<GroupBucket> matchingBucket = existing.buckets().buckets().stream().filter((existingBucket) -> (existingBucket.equals(bucket))).findFirst();
                if (matchingBucket.isPresent()) {
                    ((StoredGroupBucketEntry) matchingBucket.get()).setPackets(bucket.packets());
                    ((StoredGroupBucketEntry) matchingBucket.get()).setBytes(bucket.bytes());
                } else {
                    log.warn("addOrUpdateGroupEntry: No matching " + "buckets to update stats");
                }
            }
            existing.setLife(group.life());
            existing.setPackets(group.packets());
            existing.setBytes(group.bytes());
            if (existing.state() == GroupState.PENDING_ADD) {
                existing.setState(GroupState.ADDED);
                event = new GroupEvent(Type.GROUP_ADDED, existing);
            } else {
                if (existing.state() == GroupState.PENDING_UPDATE) {
                    existing.setState(GroupState.ADDED);
                }
                event = new GroupEvent(Type.GROUP_UPDATED, existing);
            }
        }
    }
    if (event != null) {
        notifyDelegate(event);
    }
}
#method_after
@Override
public void addOrUpdateGroupEntry(Group group) {
    // check if this new entry is an update to an existing entry
    StoredGroupEntry existing = (groupEntriesById.get(group.deviceId()) != null) ? groupEntriesById.get(group.deviceId()).get(group.id()) : null;
    GroupEvent event = null;
    if (existing != null) {
        synchronized (existing) {
            for (GroupBucket bucket : group.buckets().buckets()) {
                Optional<GroupBucket> matchingBucket = existing.buckets().buckets().stream().filter((existingBucket) -> (existingBucket.equals(bucket))).findFirst();
                if (matchingBucket.isPresent()) {
                    ((StoredGroupBucketEntry) matchingBucket.get()).setPackets(bucket.packets());
                    ((StoredGroupBucketEntry) matchingBucket.get()).setBytes(bucket.bytes());
                } else {
                    log.warn("addOrUpdateGroupEntry: No matching " + "buckets to update stats");
                }
            }
            existing.setLife(group.life());
            existing.setPackets(group.packets());
            existing.setBytes(group.bytes());
            if (existing.state() == GroupState.PENDING_ADD) {
                existing.setState(GroupState.ADDED);
                event = new GroupEvent(Type.GROUP_ADDED, existing);
            } else {
                if (existing.state() == GroupState.PENDING_UPDATE) {
                    existing.setState(GroupState.ADDED);
                }
                event = new GroupEvent(Type.GROUP_UPDATED, existing);
            }
        }
    }
    if (event != null) {
        notifyDelegate(event);
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(event.subject().id())) {
                log.info("Device connected {}", event.subject().id());
                if (event.subject().id().equals(deviceId)) {
                    processIntfFilters(true, configService.getInterfaces());
                    // For test only - will be removed before Cardinal release
                    delay(1000);
                    FibEntry fibEntry = new FibEntry(Ip4Prefix.valueOf("10.1.0.0/16"), Ip4Address.valueOf("192.168.10.1"), MacAddress.valueOf("DE:AD:BE:EF:FE:ED"));
                    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntry);
                    updateFibEntry(Collections.singletonList(fibUpdate));
                }
                if (event.subject().id().equals(ctrlDeviceId)) {
                    connectivityManager.notifySwitchAvailable();
                }
            }
            break;
        // TODO other cases
        case DEVICE_UPDATED:
            break;
        case DEVICE_REMOVED:
            break;
        case DEVICE_SUSPENDED:
            break;
        case PORT_ADDED:
            break;
        case PORT_UPDATED:
            break;
        case PORT_REMOVED:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(event.subject().id())) {
                log.info("Device connected {}", event.subject().id());
                if (event.subject().id().equals(deviceId)) {
                    processIntfFilters(true, configService.getInterfaces());
                /* For test only - will be removed before Cardinal release
                            delay(1000);
                            FibEntry fibEntry = new FibEntry(Ip4Prefix.valueOf("10.1.0.0/16"),
                                    Ip4Address.valueOf("192.168.10.1"),
                                    MacAddress.valueOf("DE:AD:BE:EF:FE:ED"));
                            FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntry);
                            updateFibEntry(Collections.singletonList(fibUpdate));
                            */
                }
                if (event.subject().id().equals(ctrlDeviceId)) {
                    connectivityManager.notifySwitchAvailable();
                }
            }
            break;
        // TODO other cases
        case DEVICE_UPDATED:
            break;
        case DEVICE_REMOVED:
            break;
        case DEVICE_SUSPENDED:
            break;
        case PORT_ADDED:
            break;
        case PORT_UPDATED:
            break;
        case PORT_REMOVED:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void updateGroupDescription(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if group update to be done by a remote instance
    if (mastershipService.getLocalRole(deviceId) != MastershipRole.MASTER) {
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupUpdateRequestMsg(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(deviceId))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(deviceId));
        // TODO: Send Group operation failure event
        }
        return;
    }
    updateGroupDescriptionInternal(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
}
#method_after
@Override
public void updateGroupDescription(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if group update to be done by a remote instance
    if (mastershipService.getMasterFor(deviceId) != null && mastershipService.getLocalRole(deviceId) != MastershipRole.MASTER) {
        GroupStoreMessage groupOp = GroupStoreMessage.createGroupUpdateRequestMsg(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
        if (!clusterCommunicator.unicast(groupOp, GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, m -> kryoBuilder.build().serialize(m), mastershipService.getMasterFor(deviceId))) {
            log.warn("Failed to send request to master: {} to {}", groupOp, mastershipService.getMasterFor(deviceId));
        // TODO: Send Group operation failure event
        }
        return;
    }
    updateGroupDescriptionInternal(deviceId, oldAppCookie, type, newBuckets, newAppCookie);
}
#end_block

#method_before
@Override
public void addOrUpdateGroupEntry(Group group) {
    // check if this new entry is an update to an existing entry
    StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
    GroupEvent event = null;
    if (existing != null) {
        log.trace("addOrUpdateGroupEntry: updating group " + "entry {} in device {}", group.id(), group.deviceId());
        synchronized (existing) {
            for (GroupBucket bucket : group.buckets().buckets()) {
                java.util.Optional<GroupBucket> matchingBucket = existing.buckets().buckets().stream().filter((existingBucket) -> (existingBucket.equals(bucket))).findFirst();
                if (matchingBucket.isPresent()) {
                    ((StoredGroupBucketEntry) matchingBucket.get()).setPackets(bucket.packets());
                    ((StoredGroupBucketEntry) matchingBucket.get()).setBytes(bucket.bytes());
                } else {
                    log.warn("addOrUpdateGroupEntry: No matching " + "buckets to update stats");
                }
            }
            existing.setLife(group.life());
            existing.setPackets(group.packets());
            existing.setBytes(group.bytes());
            if (existing.state() == GroupState.PENDING_ADD) {
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(true);
                event = new GroupEvent(Type.GROUP_ADDED, existing);
            } else {
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(false);
                event = new GroupEvent(Type.GROUP_UPDATED, existing);
            }
            // Re-PUT map entries to trigger map update events
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()), existing);
        }
    } else {
        log.warn("addOrUpdateGroupEntry: Group update " + "happening for a non-existing entry in the map");
    }
    if (event != null) {
        notifyDelegate(event);
    }
}
#method_after
@Override
public void addOrUpdateGroupEntry(Group group) {
    // check if this new entry is an update to an existing entry
    StoredGroupEntry existing = getStoredGroupEntry(group.deviceId(), group.id());
    GroupEvent event = null;
    if (existing != null) {
        log.trace("addOrUpdateGroupEntry: updating group " + "entry {} in device {}", group.id(), group.deviceId());
        synchronized (existing) {
            for (GroupBucket bucket : group.buckets().buckets()) {
                Optional<GroupBucket> matchingBucket = existing.buckets().buckets().stream().filter((existingBucket) -> (existingBucket.equals(bucket))).findFirst();
                if (matchingBucket.isPresent()) {
                    ((StoredGroupBucketEntry) matchingBucket.get()).setPackets(bucket.packets());
                    ((StoredGroupBucketEntry) matchingBucket.get()).setBytes(bucket.bytes());
                } else {
                    log.warn("addOrUpdateGroupEntry: No matching " + "buckets to update stats");
                }
            }
            existing.setLife(group.life());
            existing.setPackets(group.packets());
            existing.setBytes(group.bytes());
            if (existing.state() == GroupState.PENDING_ADD) {
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(true);
                event = new GroupEvent(Type.GROUP_ADDED, existing);
            } else {
                existing.setState(GroupState.ADDED);
                existing.setIsGroupStateAddedFirstTime(false);
                event = new GroupEvent(Type.GROUP_UPDATED, existing);
            }
            // Re-PUT map entries to trigger map update events
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()), existing);
        }
    } else {
        log.warn("addOrUpdateGroupEntry: Group update " + "happening for a non-existing entry in the map");
    }
    if (event != null) {
        notifyDelegate(event);
    }
}
#end_block

#method_before
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.serviceDirectory = context.directory();
    this.deviceId = deviceId;
    pendingGroups = CacheBuilder.newBuilder().expireAfterWrite(20, TimeUnit.SECONDS).removalListener((RemovalNotification<GroupKey, NextObjective> notification) -> {
        if (notification.getCause() == RemovalCause.EXPIRED) {
            fail(notification.getValue(), ObjectiveError.GROUPINSTALLATIONFAILED);
        }
    }).build();
    groupChecker.scheduleAtFixedRate(new GroupChecker(), 0, 500, TimeUnit.MILLISECONDS);
    coreService = serviceDirectory.get(CoreService.class);
    flowRuleService = serviceDirectory.get(FlowRuleService.class);
    groupService = serviceDirectory.get(GroupService.class);
    flowObjectiveStore = context.store();
    groupService.addListener(new InnerGroupListener());
    appId = coreService.registerApplication("org.onosproject.driver.OFDPA1Pipeline");
    initializePipeline();
}
#method_after
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.serviceDirectory = context.directory();
    this.deviceId = deviceId;
    pendingNextObjectives = CacheBuilder.newBuilder().expireAfterWrite(20, TimeUnit.SECONDS).removalListener((RemovalNotification<GroupKey, OfdpaGroupChain> notification) -> {
        if (notification.getCause() == RemovalCause.EXPIRED) {
            fail(notification.getValue().nextObjective(), ObjectiveError.GROUPINSTALLATIONFAILED);
        }
    }).build();
    groupChecker.scheduleAtFixedRate(new GroupChecker(), 0, 500, TimeUnit.MILLISECONDS);
    pendingGroups = new ConcurrentHashMap<GroupKey, GroupChainElem>();
    coreService = serviceDirectory.get(CoreService.class);
    flowRuleService = serviceDirectory.get(FlowRuleService.class);
    groupService = serviceDirectory.get(GroupService.class);
    flowObjectiveStore = context.store();
    groupService.addListener(new InnerGroupListener());
    appId = coreService.registerApplication("org.onosproject.driver.OFDPA1Pipeline");
    initializePipeline();
}
#end_block

#method_before
@Override
public void filter(FilteringObjective filterObjective) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void filter(FilteringObjective filteringObjective) {
    if (filteringObjective.type() == FilteringObjective.Type.PERMIT) {
        processFilter(filteringObjective, filteringObjective.op() == Objective.Operation.ADD, filteringObjective.appId());
    } else {
        fail(filteringObjective, ObjectiveError.UNSUPPORTED);
    }
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    switch(nextObjective.type()) {
        case SIMPLE:
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() != 1) {
                log.error("Next Objectives of type Simple should only have a " + "single Traffic Treatment. Next Objective Id:{}", nextObjective.id());
                fail(nextObjective, ObjectiveError.BADPARAMS);
                return;
            }
            processSimpleNextObjective(nextObjective);
            break;
        case HASHED:
        case BROADCAST:
        case FAILOVER:
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            log.warn("Unsupported next objective type {}", nextObjective.type());
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#end_block

#method_before
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    if (ethType.ethType() == Ethernet.TYPE_ARP) {
        log.warn("Installing ARP rule to table 60");
        // currently need to punt from ACL table should use:
        // OF apply-actions-instruction
        // If we use OF write-actions-instruction
        /*TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
            fwd.treatment().allInstructions().stream()
                .forEach(ti -> tb.deferred().add(ti));*/
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).makePermanent().forTable(ACL_TABLE);
    // XXX taking no action due to bug in OFDPA
    // return Collections.singletonList(ruleBuilder.build());
    }
    return Collections.emptySet();
}
#method_after
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    if (ethType.ethType() == Ethernet.TYPE_ARP) {
        log.warn("Installing ARP rule to table 60");
        // currently need to punt from ACL table should use:
        // OF apply-actions-instruction
        // To use OF write-actions-instruction
        /*TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
            fwd.treatment().allInstructions().stream()
                .forEach(ti -> tb.deferred().add(ti));*/
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).makePermanent().forTable(ACL_TABLE);
        // XXX  bug in OFDPA
        return Collections.singletonList(ruleBuilder.build());
    }
    // XXX not handling other versatile flows yet
    return Collections.emptySet();
}
#end_block

#method_before
private Collection<FlowRule> processSpecific(ForwardingObjective fwd) {
    return Collections.emptySet();
}
#method_after
private Collection<FlowRule> processSpecific(ForwardingObjective fwd) {
    log.debug("Processing specific forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    // XXX currently supporting only the L3 unicast table
    if (ethType == null || ethType.ethType() != Ethernet.TYPE_IPV4) {
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    TrafficSelector filteredSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip()).build();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        List<GroupKey> gkeys = appKryo.deserialize(next.data());
        Group group = groupService.getGroup(deviceId, gkeys.get(0));
        if (group == null) {
            log.warn("The group left!");
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        tb.group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(tb.build());
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(UNICAST_ROUTING_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
private void initializePipeline() {
    processPortTable();
    processVlanTable();
    processTmacTable();
    // processIpTable();
    // processMcastTable();
    // processBridgingTable();
    // processAclTable();
    processGroupTable();
}
#method_after
private void initializePipeline() {
    processPortTable();
    processVlanTable();
    processTmacTable();
    processIpTable();
// processMcastTable();
// processBridgingTable();
// processAclTable();
// processGroupTable();
}
#end_block

#method_before
private void processVlanTable() {
    // XXX make these up for now - should really be filtering rules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchInPort(PortNumber.portNumber(10));
    selector.matchVlanId(VlanId.vlanId((short) 100));
    treatment.transition(TMAC_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(appId).makePermanent().forTable(VLAN_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized vlan table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize vlan table");
        }
    }));
// Table miss entry is not required as default is to drop
}
#method_after
private void processVlanTable() {
// make these up for now - should really be filtering rules
/*FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(PortNumber.portNumber(10));
        selector.matchVlanId(VlanId.vlanId((short) 100));
        treatment.transition(TMAC_TABLE);
        FlowRule rule = DefaultFlowRule.builder()
                .forDevice(deviceId)
                .withSelector(selector.build())
                .withTreatment(treatment.build())
                .withPriority(DEFAULT_PRIORITY)
                .fromApp(appId)
                .makePermanent()
                .forTable(VLAN_TABLE).build();
        ops =  ops.add(rule);
        flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {
            @Override
            public void onSuccess(FlowRuleOperations ops) {
                log.info("Initialized vlan table");
            }

            @Override
            public void onError(FlowRuleOperations ops) {
                log.info("Failed to initialize vlan table");
            }
        }));*/
// Table miss entry is not required as ofdpa default is to drop
// In OF terms, the absence of a t.m.e. also implies drop
}
#end_block

#method_before
private void processTmacTable() {
    // XXX this is made up as well -- should be a filtering rule
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchInPort(PortNumber.portNumber(10));
    selector.matchVlanId(VlanId.vlanId((short) 100));
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchEthDst(MacAddress.valueOf("00:00:00:ba:ba:00"));
    treatment.transition(UNICAST_ROUTING_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(appId).makePermanent().forTable(TMAC_TABLE).build();
    ops = ops.add(rule);
    // table miss entry
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(BRIDGING_TABLE);
    rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(appId).makePermanent().forTable(TMAC_TABLE).build();
    // ops =  ops.add(rule); XXX bug in ofdpa
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized tmac table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize tmac table");
        }
    }));
}
#method_after
private void processTmacTable() {
    // this is made up as well -- should be a filtering rule
    /*selector.matchInPort(PortNumber.portNumber(10));
        selector.matchVlanId(VlanId.vlanId((short) 100));
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(MacAddress.valueOf("00:00:00:ba:ba:00"));
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder()
                .forDevice(deviceId)
                .withSelector(selector.build())
                .withTreatment(treatment.build())
                .withPriority(DEFAULT_PRIORITY)
                .fromApp(appId)
                .makePermanent()
                .forTable(TMAC_TABLE).build();
        ops =  ops.add(rule);*/
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(BRIDGING_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(appId).makePermanent().forTable(TMAC_TABLE).build();
    // XXX bug in ofdpa
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized tmac table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize tmac table");
        }
    }));
}
#end_block

#method_before
private void processGroupTable() {
    // XXX Creating a dummy L2 group as per OFDPA requirements
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(10)).build();
    NextObjective nextObjective = DefaultNextObjective.builder().addTreatment(treatment).fromApp(appId).withId(// dummy next objective id
    678).withType(NextObjective.Type.SIMPLE).add();
    Integer l2groupId = 0x0064000a;
    GroupBucket bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
    final GroupKey key = new DefaultGroupKey(appKryo.serialize(678));
    GroupDescription groupDescriptionl2 = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket)), key, l2groupId, appId);
    groupService.addGroup(groupDescriptionl2);
    pendingGroups.put(key, nextObjective);
}
#method_after
@SuppressWarnings("unused")
private void processGroupTable() {
// Creating a dummy L2 group as per OFDPA requirements
/* TrafficTreatment treatment = DefaultTrafficTreatment.builder()
                                        .setOutput(PortNumber.portNumber(10))
                                        .build();
        NextObjective nextObjective = DefaultNextObjective.builder()
                .addTreatment(treatment)
                .fromApp(appId)
                .withId(678) // dummy next objective id
                .withType(NextObjective.Type.SIMPLE)
                .add();
        Integer l2groupId = 0x0064000a;
        GroupBucket bucket =
                DefaultGroupBucket.createIndirectGroupBucket(treatment);
        final GroupKey key = new DefaultGroupKey(appKryo.serialize(678));
        GroupDescription groupDescriptionl2
            = new DefaultGroupDescription(deviceId,
                                      GroupDescription.Type.INDIRECT,
                                      new GroupBuckets(Collections
                                                       .singletonList(bucket)),
                                      key,
                                      l2groupId,
                                      appId);
        groupService.addGroup(groupDescriptionl2);*/
// pendingNextObjectives.put(key, nextObjective);
}
#end_block

#method_before
private void tryGroupChain() {
    // XXX Create a dummy L3 group as per OFDPA requirements
    TrafficTreatment treatment2 = DefaultTrafficTreatment.builder().setEthDst(MacAddress.valueOf("00:00:00:aa:aa:aa")).setEthSrc(MacAddress.valueOf("00:00:00:dd:dd:dd")).setVlanId(VlanId.vlanId((short) 100)).group(new DefaultGroupId(0x0064000a)).build();
    NextObjective nextObjective2 = DefaultNextObjective.builder().addTreatment(treatment2).fromApp(appId).withId(// another dummy next objective id
    67800).withType(NextObjective.Type.SIMPLE).add();
    Integer l3groupId = 0x2000000a;
    GroupBucket bucket2 = DefaultGroupBucket.createIndirectGroupBucket(treatment2);
    final GroupKey key2 = new DefaultGroupKey(appKryo.serialize(67800));
    GroupDescription groupDescriptionl3 = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket2)), key2, l3groupId, appId);
    groupService.addGroup(groupDescriptionl3);
    pendingGroups.put(key2, nextObjective2);
}
#method_after
@SuppressWarnings("unused")
private void tryGroupChain() {
// Create a dummy L3 group as per OFDPA requirements
/*TrafficTreatment treatment2 = DefaultTrafficTreatment.builder()
                .setEthDst(MacAddress.valueOf("00:00:00:aa:aa:aa"))
                .setEthSrc(MacAddress.valueOf("00:00:00:dd:dd:dd"))
                .setVlanId(VlanId.vlanId((short) 100))
                .group(new DefaultGroupId(0x0064000a))
                .build();
        NextObjective nextObjective2 = DefaultNextObjective.builder()
                .addTreatment(treatment2)
                .fromApp(appId)
                .withId(67800) // another dummy next objective id
                .withType(NextObjective.Type.SIMPLE)
                .add();
        Integer l3groupId = 0x2000000a;
        GroupBucket bucket2 = DefaultGroupBucket.createIndirectGroupBucket(treatment2);
        final GroupKey key2 = new DefaultGroupKey(appKryo.serialize(67800));
        GroupDescription groupDescriptionl3
               = new DefaultGroupDescription(deviceId,
                                  GroupDescription.Type.INDIRECT,
                                  new GroupBuckets(Collections
                                                   .singletonList(bucket2)),
                                  key2,
                                  l3groupId,
                                  appId);
        groupService.addGroup(groupDescriptionl3);
        pendingNextObjectives.put(key2, nextObjective2);
    */
}
#end_block

#method_before
@Override
public void run() {
    Set<GroupKey> keys = pendingGroups.asMap().keySet().stream().filter(key -> groupService.getGroup(deviceId, key) != null).collect(Collectors.toSet());
    keys.stream().forEach(key -> {
        NextObjective obj = pendingGroups.getIfPresent(key);
        if (obj == null) {
            return;
        }
        pass(obj);
        pendingGroups.invalidate(key);
        log.info("Heard back from group service. " + "Applying pending objectives for nextId {}", obj.id());
        flowObjectiveStore.putNextGroup(obj.id(), new OfdpaGroup(key));
        tryGroupChain();
    });
}
#method_after
@Override
public void run() {
    Set<GroupKey> keys = pendingNextObjectives.asMap().keySet().stream().filter(key -> groupService.getGroup(deviceId, key) != null).collect(Collectors.toSet());
    keys.stream().forEach(key -> {
        // first check for group chain
        GroupChainElem gce = pendingGroups.remove(key);
        if (gce != null) {
            log.info("Heard back from group service. Processing next " + "group in group chain with group key {}", gce.getGkey());
            processGroupChain(gce);
        } else {
            OfdpaGroupChain obj = pendingNextObjectives.getIfPresent(key);
            if (obj == null) {
                return;
            }
            pass(obj.nextObjective());
            pendingNextObjectives.invalidate(key);
            log.info("Heard back from group service. Applying pending " + "objectives for nextId {}", obj.nextObjective().id());
            flowObjectiveStore.putNextGroup(obj.nextObjective().id(), obj);
        }
    });
}
#end_block

#method_before
@Override
public void event(GroupEvent event) {
    if (event.type() == GroupEvent.Type.GROUP_ADDED) {
        GroupKey key = event.subject().appCookie();
        NextObjective obj = pendingGroups.getIfPresent(key);
        log.info("group ADDED .. Applying pending objectives if any");
        if (obj != null) {
            flowObjectiveStore.putNextGroup(obj.id(), new OfdpaGroup(key));
            pass(obj);
            pendingGroups.invalidate(key);
        }
    }
}
#method_after
@Override
public void event(GroupEvent event) {
    if (event.type() == GroupEvent.Type.GROUP_ADDED) {
        GroupKey key = event.subject().appCookie();
        // first check for group chain
        GroupChainElem gce = pendingGroups.remove(key);
        if (gce != null) {
            log.info("group ADDED .. Processing next group in group chain " + "with group key {}", gce.getGkey());
            processGroupChain(gce);
        } else {
            OfdpaGroupChain obj = pendingNextObjectives.getIfPresent(key);
            log.info("group ADDED .. Applying pending objectives if any");
            if (obj != null) {
                flowObjectiveStore.putNextGroup(obj.nextObjective().id(), obj);
                pass(obj.nextObjective());
                pendingNextObjectives.invalidate(key);
            }
        }
    }
}
#end_block

#method_before
@Override
public void notify(GroupEvent event) {
    assertEquals(expectedEvent, event.type());
    assertEquals(Group.Type.SELECT, event.subject().type());
    assertEquals(D1, event.subject().deviceId());
    assertEquals(createdGroupKey, event.subject().appCookie());
    assertEquals(createdBuckets.buckets(), event.subject().buckets().buckets());
    if (expectedEvent == GroupEvent.Type.GROUP_ADD_REQUESTED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADDED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATED) {
        createdGroupId = event.subject().id();
        assertEquals(true, event.subject().buckets().buckets().containsAll(createdBuckets.buckets()));
        assertEquals(true, createdBuckets.buckets().containsAll(event.subject().buckets().buckets()));
        for (GroupBucket bucket : event.subject().buckets().buckets()) {
            java.util.Optional<GroupBucket> matched = createdBuckets.buckets().stream().filter((expected) -> expected.equals(bucket)).findFirst();
            assertEquals(matched.get().packets(), bucket.packets());
            assertEquals(matched.get().bytes(), bucket.bytes());
        }
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADD_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    }
}
#method_after
@Override
public void notify(GroupEvent event) {
    assertEquals(expectedEvent, event.type());
    assertEquals(Group.Type.SELECT, event.subject().type());
    assertEquals(D1, event.subject().deviceId());
    assertEquals(createdGroupKey, event.subject().appCookie());
    assertEquals(createdBuckets.buckets(), event.subject().buckets().buckets());
    if (expectedEvent == GroupEvent.Type.GROUP_ADD_REQUESTED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADDED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATED) {
        createdGroupId = event.subject().id();
        assertEquals(true, event.subject().buckets().buckets().containsAll(createdBuckets.buckets()));
        assertEquals(true, createdBuckets.buckets().containsAll(event.subject().buckets().buckets()));
        for (GroupBucket bucket : event.subject().buckets().buckets()) {
            Optional<GroupBucket> matched = createdBuckets.buckets().stream().filter((expected) -> expected.equals(bucket)).findFirst();
            assertEquals(matched.get().packets(), bucket.packets());
            assertEquals(matched.get().bytes(), bucket.bytes());
        }
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADD_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    }
}
#end_block

#method_before
@Override
protected TableModel createTableModel() {
    TableModel tm = super.createTableModel();
    tm.setFormatter(LOCATION, HostLocationFormatter.INSTANCE);
    tm.setFormatter(IPS, new IPSetFormatter());
    return tm;
}
#method_after
@Override
protected TableModel createTableModel() {
    TableModel tm = super.createTableModel();
    tm.setFormatter(LOCATION, HostLocationFormatter.INSTANCE);
    tm.setFormatter(IPS, new IpSetFormatter());
    return tm;
}
#end_block

#method_before
@Test
public void underscores() {
    assertEquals("All caps with underscores", "Pending Add", fmt.format("PENDING_ADD"));
}
#method_after
@Test
public void underscores() {
    assertEquals("All caps with underscores", "Pending Add", fmt.format(TestEnum.PENDING_ADD));
}
#end_block

#method_before
@Test
public void multiUnderscores() {
    assertEquals("All caps with underscores", "Waiting Audit Complete", fmt.format("WAITING_AUDIT_COMPLETE"));
}
#method_after
@Test
public void multiUnderscores() {
    assertEquals("All caps with underscores", "Waiting Audit Complete", fmt.format(TestEnum.WAITING_AUDIT_COMPLETE));
}
#end_block

#method_before
@Override
public void addVlan(VlanId vlanId, List<ConnectPoint> ports) {
    checkNotNull(vlanId);
    checkNotNull(ports);
    checkArgument(ports.size() > 1);
    verifyPorts(ports);
    vlans.removeAll(vlanId).forEach(cp -> removeForwarding(vlanId, cp.port()));
    ports.forEach(cp -> {
        if (vlans.put(vlanId, cp)) {
            addForwarding(vlanId, cp.deviceId(), cp.port(), ports.stream().filter(p -> p != cp).map(ConnectPoint::port).collect(Collectors.toList()));
        }
    });
}
#method_after
@Override
public void addVlan(VlanId vlanId, List<ConnectPoint> ports) {
    checkNotNull(vlanId);
    checkNotNull(ports);
    checkArgument(ports.size() > 1);
    verifyPorts(ports);
    removeVlan(vlanId);
    ports.forEach(cp -> {
        if (vlans.put(vlanId, cp)) {
            addForwarding(vlanId, cp.deviceId(), cp.port(), ports.stream().filter(p -> p != cp).map(ConnectPoint::port).collect(Collectors.toList()));
        }
    });
}
#end_block

#method_before
@Override
public void removeVlan(VlanId vlanId) {
    vlans.removeAll(vlanId).forEach(cp -> removeForwarding(vlanId, cp.port()));
}
#method_after
@Override
public void removeVlan(VlanId vlanId) {
    vlans.removeAll(vlanId).forEach(cp -> removeForwarding(vlanId, cp.deviceId(), cp.port()));
}
#end_block

#method_before
private void addForwarding(VlanId vlanId, DeviceId deviceId, PortNumber inPort, List<PortNumber> outPorts) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(vlanId).matchInPort(inPort).build();
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.forEach(p -> treatmentBuilder.setOutput(p));
    ForwardingObjective objective = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(selector).withTreatment(treatmentBuilder.build()).add();
    flowObjectiveService.forward(deviceId, objective);
}
#method_after
private void addForwarding(VlanId vlanId, DeviceId deviceId, PortNumber inPort, List<PortNumber> outPorts) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(vlanId).matchInPort(inPort).build();
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.forEach(p -> treatmentBuilder.setOutput(p));
    ForwardingObjective objective = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(selector).withTreatment(treatmentBuilder.build()).add(new ObjectiveHandler());
    flowObjectiveService.forward(deviceId, objective);
}
#end_block

#method_before
private void removeForwarding(VlanId vlanId, PortNumber inPort) {
// Flow objective service doesn't support removes right now
}
#method_after
private void removeForwarding(VlanId vlanId, DeviceId deviceId, PortNumber inPort) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(vlanId).matchInPort(inPort).build();
    ForwardingObjective objective = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(selector).withTreatment(DefaultTrafficTreatment.builder().build()).remove(new ObjectiveHandler());
    flowObjectiveService.forward(deviceId, objective);
}
#end_block

#method_before
// TODO handle the case: the number of public IP addresses is not enough
@Override
public IpAddress getAvailablePublicIpAddress(IpAddress privateIpAddress) {
    synchronized (this) {
        // If there is already a mapping entry for the private IP address,
        // then fetch the public IP address in the mapping entry and return
        // it.
        IpAddress publicIpAddress = ipAddressMap.get(privateIpAddress);
        if (publicIpAddress != null) {
            return publicIpAddress;
        }
        // There is no mapping for the private IP address.
        Iterator<Entry<IpPrefix, Boolean>> prefixes = localPublicIpPrefixes.entrySet().iterator();
        while (prefixes.hasNext()) {
            Entry<IpPrefix, Boolean> prefix = prefixes.next();
            if (!prefix.getValue()) {
                continue;
            }
            if (prefix.getKey().prefixLength() == 32) {
                updateIpPrefixStatus(prefix.getKey(), false);
                publicIpAddress = prefix.getKey().address();
                ipAddressMap.put(privateIpAddress, publicIpAddress);
                return publicIpAddress;
            }
            int prefixLen = prefix.getKey().prefixLength();
            int availableIpNum = (int) Math.pow(2, IpPrefix.MAX_INET_MASK_LENGTH - prefixLen) - 1;
            for (int i = 1; i <= availableIpNum; i++) {
                publicIpAddress = increaseIpAddress(prefix.getKey().address(), i);
                if (publicIpAddress == null) {
                    return null;
                }
                if (ipAddressMap.values().contains(publicIpAddress)) {
                    continue;
                } else if (i == availableIpNum) {
                    // All the IP addresses are assigned out
                    // Update this IP prefix status to false
                    // Note: in this version we do not consider the
                    // IP recycling issue.
                    updateIpPrefixStatus(prefix.getKey(), false);
                    ipAddressMap.put(privateIpAddress, publicIpAddress);
                    return publicIpAddress;
                } else {
                    ipAddressMap.put(privateIpAddress, publicIpAddress);
                    return publicIpAddress;
                }
            }
        }
        return null;
    }
}
#method_after
// TODO handle the case: the number of public IP addresses is not enough
@Override
public synchronized IpAddress getAvailablePublicIpAddress(IpAddress privateIpAddress) {
    // If there is already a mapping entry for the private IP address,
    // then fetch the public IP address in the mapping entry and return it.
    IpAddress publicIpAddress = ipAddressMap.get(privateIpAddress);
    if (publicIpAddress != null) {
        return publicIpAddress;
    }
    // There is no mapping for the private IP address.
    Iterator<Entry<IpPrefix, Boolean>> prefixes = localPublicIpPrefixes.entrySet().iterator();
    while (prefixes.hasNext()) {
        Entry<IpPrefix, Boolean> prefix = prefixes.next();
        if (!prefix.getValue()) {
            continue;
        }
        if (prefix.getKey().prefixLength() == 32) {
            updateIpPrefixStatus(prefix.getKey(), false);
            publicIpAddress = prefix.getKey().address();
            ipAddressMap.put(privateIpAddress, publicIpAddress);
            return publicIpAddress;
        }
        int prefixLen = prefix.getKey().prefixLength();
        int availableIpNum = (int) Math.pow(2, IpPrefix.MAX_INET_MASK_LENGTH - prefixLen) - 1;
        for (int i = 1; i <= availableIpNum; i++) {
            publicIpAddress = increaseIpAddress(prefix.getKey().address(), i);
            if (publicIpAddress == null) {
                return null;
            }
            if (ipAddressMap.values().contains(publicIpAddress)) {
                continue;
            } else if (i == availableIpNum) {
                // All the IP addresses are assigned out
                // Update this IP prefix status to false
                // Note: in this version we do not consider the
                // IP recycling issue.
                updateIpPrefixStatus(prefix.getKey(), false);
                ipAddressMap.put(privateIpAddress, publicIpAddress);
                return publicIpAddress;
            } else {
                ipAddressMap.put(privateIpAddress, publicIpAddress);
                return publicIpAddress;
            }
        }
    }
    return null;
}
#end_block

