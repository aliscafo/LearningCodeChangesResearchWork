87
#method_before
public static Color getColor(String str) {
    try {
        if (str.charAt(0) == '#') {
            return new Color(Integer.valueOf(str.substring(1, 3), 16), Integer.valueOf(str.substring(3, 5), 16), Integer.valueOf(str.substring(5, 7), 16));
        } else {
            Field field = Class.forName("java.awt.Color").getField(str);
            return (Color) field.get(null);
        }
    } catch (Exception e) {
        return Color.black;
    }
}
#method_after
public static Color getColor(String str) {
    try {
        if (str.charAt(0) == '#') {
            return new Color.decode(str);
        } else {
            Field field = Class.forName("java.awt.Color").getField(str);
            return (Color) field.get(null);
        }
    } catch (Exception e) {
        return Color.black;
    }
}
#end_block

#method_before
public static SwingScilabWindow createWindow(final String uuid, final boolean preserveUUID) {
    readDocument();
    final Element root = doc.getDocumentElement();
    final boolean nullUUID = uuid.equals(NULLUUID);
    final Map<String, Object> attrs = new HashMap<String, Object>();
    Element win = null;
    boolean containsX = true;
    if (!nullUUID) {
        win = getElementWithUUID(root, "Window", uuid);
        if (win == null) {
            return null;
        }
        containsX = !win.getAttribute("x").equals("");
        if (containsX) {
            attrs.put("x", int.class);
            attrs.put("y", int.class);
        }
        attrs.put("height", int.class);
        attrs.put("width", int.class);
        attrs.put("state", int.class);
        ScilabXMLUtilities.readNodeAttributes(win, attrs);
    } else {
        attrs.putAll(defaultWinAttributes);
    }
    SwingScilabWindow window = SwingScilabWindow.createWindow(true);
    window.setVisible(false);
    final String localUUID;
    if (preserveUUID) {
        localUUID = uuid;
    } else {
        localUUID = UUID.randomUUID().toString();
    }
    window.setUUID(localUUID);
    if (containsX) {
        boolean positionned = false;
        Point p = new Point(((Integer) attrs.get("x")).intValue(), ((Integer) attrs.get("y")).intValue());
        // We check that the coordinates are valid
        GraphicsDevice[] gds = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();
        if (gds != null) {
            for (GraphicsDevice gd : gds) {
                Rectangle r = gd.getDefaultConfiguration().getBounds();
                try {
                    if (r.contains(p)) {
                        positionned = true;
                        window.setLocation(p.x, p.y);
                        break;
                    }
                } catch (NullPointerException e) {
                    e.printStackTrace();
                }
            }
        }
        if (!positionned) {
            window.setLocation(DEFAULTX, DEFAULTY);
        }
    }
    window.setSize(((Integer) attrs.get("width")).intValue(), ((Integer) attrs.get("height")).intValue());
    /* remove ICONIFIED at restoration */
    int state = ((Integer) attrs.get("state")).intValue();
    if ((state & SwingScilabWindow.ICONIFIED) == SwingScilabWindow.ICONIFIED) {
        state -= SwingScilabWindow.ICONIFIED;
    }
    window.setExtendedState(state);
    return window;
}
#method_after
public static SwingScilabWindow createWindow(final String uuid, final boolean preserveUUID) {
    readDocument();
    final Element root = doc.getDocumentElement();
    final boolean nullUUID = uuid.equals(NULLUUID);
    final Map<String, Object> attrs = new HashMap<String, Object>();
    Element win = null;
    boolean containsX = true;
    if (!nullUUID) {
        win = getElementWithUUID(root, "Window", uuid);
        if (win == null) {
            return null;
        }
        containsX = !win.getAttribute("x").equals("");
        if (containsX) {
            attrs.put("x", int.class);
            attrs.put("y", int.class);
        }
        attrs.put("height", int.class);
        attrs.put("width", int.class);
        attrs.put("state", int.class);
        ScilabXMLUtilities.readNodeAttributes(win, attrs);
    } else {
        attrs.putAll(defaultWinAttributes);
    }
    SwingScilabWindow window = SwingScilabWindow.createWindow(true);
    window.setVisible(false);
    final String localUUID;
    if (preserveUUID) {
        localUUID = uuid;
    } else {
        localUUID = UUID.randomUUID().toString();
    }
    window.setUUID(localUUID);
    if (containsX) {
        boolean positionned = false;
        Point p = new Point(((Integer) attrs.get("x")).intValue(), ((Integer) attrs.get("y")).intValue());
        // We check that the coordinates are valid
        GraphicsDevice[] gds = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();
        if (gds != null) {
            for (GraphicsDevice gd : gds) {
                Rectangle r = gd.getDefaultConfiguration().getBounds();
                if (r != null) {
                    if (r.contains(p)) {
                        positionned = true;
                        window.setLocation(p.x, p.y);
                        break;
                    }
                }
            }
        }
        if (!positionned) {
            window.setLocation(DEFAULTX, DEFAULTY);
        }
    }
    window.setSize(((Integer) attrs.get("width")).intValue(), ((Integer) attrs.get("height")).intValue());
    /* remove ICONIFIED at restoration */
    int state = ((Integer) attrs.get("state")).intValue();
    if ((state & SwingScilabWindow.ICONIFIED) == SwingScilabWindow.ICONIFIED) {
        state -= SwingScilabWindow.ICONIFIED;
    }
    window.setExtendedState(state);
    return window;
}
#end_block

#method_before
private static Map<String, String> parseCommandLine(String[] args) {
    String option = null;
    boolean in = false;
    Map<String, String> map = new HashMap<String, String>();
    for (int i = 0; i < args.length; i++) {
        if (args[i].length() >= 2 && args[i].charAt(0) == '-') {
            if (option != null) {
                map.put(option, "");
                option = null;
            }
            if (args[i].charAt(1) == '-') {
                option = args[i].substring(2);
            } else {
                option = args[i].substring(1);
            }
        } else {
            if (option != null) {
                map.put(option, args[i]);
                option = null;
            } else if (!in) {
                map.put("input", args[i]);
                in = true;
            } else {
                System.err.println("Not an argument " + args[i]);
                return null;
            }
        }
    }
    if (option != null) {
        map.put(option, "");
    }
    return map;
}
#method_after
private static Map<String, String> parseCommandLine(String[] args) {
    String option = null;
    boolean in = false;
    Map<String, String> map = new HashMap<String, String>();
    for (int i = 0; i < args.length; i++) {
        if (args[i].length() >= 2 && args[i].charAt(0) == '-') {
            if (option != null) {
                map.put(option, "");
            }
            if (args[i].charAt(1) == '-') {
                option = args[i].substring(2);
            } else {
                option = args[i].substring(1);
            }
        } else {
            if (option != null) {
                map.put(option, args[i]);
                option = null;
            } else if (!in) {
                map.put("input", args[i]);
                in = true;
            } else {
                System.err.println("Not an argument " + args[i]);
                return null;
            }
        }
    }
    if (option != null) {
        map.put(option, "");
    }
    return map;
}
#end_block

#method_before
public final void draw(final DrawingTools drawingTools, final ColorMap colorMap, final Text text) throws SciRendererException {
    Texture texture = getTexture(colorMap, text);
    /* The unscaled texture's dimensions */
    Dimension spriteDims = getSpriteDims(colorMap, text);
    Transformation projection = drawingTools.getTransformationManager().getCanvasProjection();
    Integer parentAxesId = text.getParentAxes();
    Axes parentAxes = (Axes) GraphicController.getController().getObjectFromId(parentAxesId);
    if (parentAxes != null) {
        double[][] factors = parentAxes.getScaleTranslateFactors();
        Double[] pos = text.getPosition();
        pos[0] = pos[0] * factors[0][0] + factors[1][0];
        pos[1] = pos[1] * factors[0][1] + factors[1][1];
        pos[2] = pos[2] * factors[0][2] + factors[1][2];
        /* Compute the text box vectors and the text box to texture dimension ratios */
        Vector3d[] textBoxVectors = computeTextBoxVectors(projection, text, texture.getDataProvider().getTextureSize(), parentAxes);
        double[] ratios = computeRatios(projection, text, textBoxVectors, texture.getDataProvider().getTextureSize(), spriteDims);
        /* If text box mode is equal to filled, the texture must be updated */
        if (text.getTextBoxMode() == 2 && ratios[0] != 1.0) {
            texture = updateSprite(colorMap, text, ratios[0], ratios[1]);
        }
        /* Compute the text texture's actual position, which depends on the object's text box mode property */
        Vector3d[] cornerPositions = computeTextPosition(projection, text, textBoxVectors, texture.getDataProvider().getTextureSize());
        /* Draw in window coordinates */
        drawingTools.getTransformationManager().useWindowCoordinate();
        /* The Text object's rotation direction convention is opposite to the standard one, its angle is expressed in radians. */
        drawingTools.draw(texture, AnchorPosition.LOWER_LEFT, cornerPositions[0], -180.0 * text.getFontAngle() / Math.PI);
        drawingTools.getTransformationManager().useSceneCoordinate();
        /* Compute the corners of the text's bounding box in window coordinates */
        Vector3d[] projCorners;
        if (text.getTextBoxMode() == 2) {
            projCorners = computeProjTextBoxCorners(cornerPositions[1], text.getFontAngle(), textBoxVectors);
        } else {
            projCorners = computeProjCorners(cornerPositions[0], text.getFontAngle(), texture.getDataProvider().getTextureSize());
        }
        Vector3d[] corners = computeCorners(projection, projCorners, parentAxes);
        Double[] coordinates = cornersToCoordinateArray(corners);
        /* Set the computed coordinates */
        text.setCorners(coordinates);
    }
}
#method_after
public final void draw(final DrawingTools drawingTools, final ColorMap colorMap, final Text text) throws SciRendererException {
    Texture texture = getTexture(colorMap, text);
    /* The unscaled texture's dimensions */
    Dimension spriteDims = getSpriteDims(colorMap, text);
    Transformation projection = drawingTools.getTransformationManager().getCanvasProjection();
    Integer parentAxesId = text.getParentAxes();
    Axes parentAxes = (Axes) GraphicController.getController().getObjectFromId(parentAxesId);
    if (parentAxes != null) {
        /* Compute the text box vectors and the text box to texture dimension ratios */
        Vector3d[] textBoxVectors = computeTextBoxVectors(projection, text, texture.getDataProvider().getTextureSize(), parentAxes);
        double[] ratios = computeRatios(projection, text, textBoxVectors, texture.getDataProvider().getTextureSize(), spriteDims);
        /* If text box mode is equal to filled, the texture must be updated */
        if (text.getTextBoxMode() == 2 && ratios[0] != 1.0) {
            texture = updateSprite(colorMap, text, ratios[0], ratios[1]);
        }
        /* Compute the text texture's actual position, which depends on the object's text box mode property */
        Vector3d[] cornerPositions = computeTextPosition(projection, text, textBoxVectors, texture.getDataProvider().getTextureSize());
        /* Draw in window coordinates */
        drawingTools.getTransformationManager().useWindowCoordinate();
        /* The Text object's rotation direction convention is opposite to the standard one, its angle is expressed in radians. */
        drawingTools.draw(texture, AnchorPosition.LOWER_LEFT, cornerPositions[0], -180.0 * text.getFontAngle() / Math.PI);
        drawingTools.getTransformationManager().useSceneCoordinate();
        /* Compute the corners of the text's bounding box in window coordinates */
        Vector3d[] projCorners;
        if (text.getTextBoxMode() == 2) {
            projCorners = computeProjTextBoxCorners(cornerPositions[1], text.getFontAngle(), textBoxVectors);
        } else {
            projCorners = computeProjCorners(cornerPositions[0], text.getFontAngle(), texture.getDataProvider().getTextureSize());
        }
        Vector3d[] corners = computeCorners(projection, projCorners, parentAxes);
        Double[] coordinates = cornersToCoordinateArray(corners);
        /* Set the computed coordinates */
        text.setCorners(coordinates);
    }
}
#end_block

#method_before
public void highlightWords(int tok, Pattern pattern, boolean centered) {
    if (pattern != null) {
        removeHighlightedWords();
        int first = -1;
        String text = ((ScilabDocument) getDocument()).getText();
        Highlighter highlighter = getHighlighter();
        List<Integer[]> positions = SearchManager.findToken((ScilabDocument) getDocument(), tok, lexer, pattern);
        if (positions != null) {
            List<Rectangle> marks = new ArrayList<Rectangle>();
            for (Integer[] position : positions) {
                try {
                    highlightedWords.put(position[0], highlighter.addHighlight(position[0], position[1], HIGHLIGHTER));
                    Rectangle r = modelToView(position[0]);
                    if (r != null && (marks.size() == 0 || marks.get(marks.size() - 1).y != r.y)) {
                        marks.add(r);
                    }
                } catch (BadLocationException e) {
                }
            }
            ScilabScrollPane ssp = getScrollPane();
            if (ssp != null) {
                ssp.putMarks(marks);
            }
            if (centered && positions.size() != 0) {
                scrollTextToPos(positions.get(0)[0], false, true);
            }
        }
    }
}
#method_after
public void highlightWords(int tok, Pattern pattern, boolean centered) {
    if (pattern != null) {
        removeHighlightedWords();
        int first = -1;
        Highlighter highlighter = getHighlighter();
        List<Integer[]> positions = SearchManager.findToken((ScilabDocument) getDocument(), tok, lexer, pattern);
        if (positions != null) {
            List<Rectangle> marks = new ArrayList<Rectangle>();
            for (Integer[] position : positions) {
                try {
                    highlightedWords.put(position[0], highlighter.addHighlight(position[0], position[1], HIGHLIGHTER));
                    Rectangle r = modelToView(position[0]);
                    if (r != null && (marks.size() == 0 || marks.get(marks.size() - 1).y != r.y)) {
                        marks.add(r);
                    }
                } catch (BadLocationException e) {
                }
            }
            ScilabScrollPane ssp = getScrollPane();
            if (ssp != null) {
                ssp.putMarks(marks);
            }
            if (centered && positions.size() != 0) {
                scrollTextToPos(positions.get(0)[0], false, true);
            }
        }
    }
}
#end_block

#method_before
public void computeMargins(Axes axes) {
    if (axes.getAutoMargins() && axes.getViewAsEnum() == ViewType.VIEW_2D) {
        Figure figure = (Figure) GraphicController.getController().getObjectFromId(axes.getParentFigure());
        ColorMap colorMap = null;
        if (figure != null) {
            colorMap = figure.getColorMap();
        } else {
            return;
        }
        Dimension[] marginLabels = labelManager.getLabelsSize(colorMap, axes, this);
        Integer[] size = { visitor.getCanvas().getWidth(), visitor.getCanvas().getHeight() };
        if (size[0] != 0 && size[1] != 0) {
            // [x_left, y_up, w, h]
            Double[] axesBounds = axes.getAxesBounds();
            // [l, r, t, b]
            Double[] margins = axes.getMargins();
            // m is a copy of margins
            Double[] mt = new Double[] { 0., 0., 0., 0. };
            // Double[] ml = new Double[] { 0., 0., 0., 0. };
            Double[] ma = new Double[] { 0., 0., 0., 0. };
            Double[] m = new Double[] { 0., 0., 0., 0. };
            AxisProperty.AxisLocation xloc = axes.getXAxis().getAxisLocation();
            AxisProperty.AxisLocation yloc = axes.getYAxis().getAxisLocation();
            final double DEFAULT_MARGIN = 0.125;
            // We compute the adapted margins for axes titles.
            if (marginLabels[0].height != 0 || marginLabels[2].height != 0 || marginLabels[1].width != 0) {
                if (marginLabels[2].height != 0) {
                    final double th = (marginLabels[2].height + 2 + TitlePositioner.TITLEOFFSET) / (size[1] * axesBounds[3]);
                    mt[2] = th;
                }
                if (marginLabels[0].height != 0 && (xloc == AxisProperty.AxisLocation.BOTTOM || xloc == AxisProperty.AxisLocation.TOP)) {
                    final double xh = (marginLabels[0].height + 2) / (size[1] * axesBounds[3]);
                    if (xloc == AxisProperty.AxisLocation.BOTTOM) {
                        mt[3] = xh;
                    } else {
                        mt[2] += xh;
                    }
                }
                if (marginLabels[1].width != 0 && (yloc == AxisProperty.AxisLocation.LEFT || yloc == AxisProperty.AxisLocation.RIGHT)) {
                    final double yh = (marginLabels[1].width + 2) / (size[0] * axesBounds[2]);
                    if (yloc == AxisProperty.AxisLocation.LEFT) {
                        mt[0] = yh;
                    } else {
                        mt[1] = yh;
                    }
                }
            }
            // computeRulers(axes);
            final double xratio = rulerDrawer.getRulerDrawer(axes, 0).getDistanceRatio();
            final double yratio = rulerDrawer.getRulerDrawer(axes, 1).getDistanceRatio();
            if (xloc == AxisProperty.AxisLocation.BOTTOM) {
                ma[3] = (1 - margins[2] - margins[3]) * xratio / 2.;
            } else if (xloc == AxisProperty.AxisLocation.TOP) {
                ma[2] = (1 - margins[2] - margins[3]) * xratio / 2.;
            }
            if (yloc == AxisProperty.AxisLocation.LEFT) {
                ma[0] = (1 - margins[0] - margins[1]) * yratio / 2.;
            } else if (yloc == AxisProperty.AxisLocation.RIGHT) {
                ma[1] = (1 - margins[0] - margins[1]) * yratio / 2.;
            }
            // Get the legend if any (only one ???)
            if (axes.getChildren() != null) {
                for (Integer i : axes.getChildren()) {
                    GraphicObject child = GraphicController.getController().getObjectFromId(i);
                    if (child instanceof Legend) {
                        Legend legend = (Legend) child;
                        Dimension legDims = visitor.getLegendDrawer().computeDimensions(axes, legend);
                        if (legDims != null) {
                            LegendLocation legLoc = legend.getLegendLocationAsEnum();
                            double C;
                            /*
                                 * Legends dimension are linearly dependent of margins... so we need to solve an equation
                                 * to find a good value for margins.
                                 * For example:
                                 *  legend.w = texture.w + 3/8 * line.w + line.w
                                 *  where line.w = LINE_WIDTH * ab[2] * (1 - m[0] - m[1]) * size[0];
                                 *  the minimal value for m[1] is the solution of the equation (where unknown is m[1]):
                                 *   legend.w = ab[2] * m[1] * size[0].
                                 */
                            switch(legLoc) {
                                case OUT_UPPER_RIGHT:
                                case OUT_LOWER_RIGHT:
                                    // 1/8 of LINE_WIDTH is xOffset
                                    // see legendDims[0] = ... in LegendDrawer::draw
                                    // we add 2*xoffset to have a little space around the box
                                    C = legend.getLineWidth() + LegendDrawer.LINE_WIDTH * (3. / 8. + 2. / 8.);
                                    m[0] = Math.max(ma[0] + mt[0], DEFAULT_MARGIN);
                                    m[1] = Math.max(((legDims.width + 2) / (axesBounds[2] * size[0]) + C * (1 - m[0])) / (1 + C) + ma[1] + mt[1], DEFAULT_MARGIN);
                                    break;
                                case OUT_UPPER_LEFT:
                                case OUT_LOWER_LEFT:
                                    C = legend.getLineWidth() + LegendDrawer.LINE_WIDTH * (3. / 8. + 2. / 8.);
                                    m[1] = Math.max(ma[1] + mt[1], DEFAULT_MARGIN);
                                    m[0] = Math.max(((legDims.width + 2) / (axesBounds[2] * size[0]) + C * (1 - m[1])) / (1 + C) + ma[0] + mt[0], DEFAULT_MARGIN);
                                    break;
                                case UPPER_CAPTION:
                                    C = LegendDrawer.Y_OFFSET * (3. + 2.);
                                    m[3] = Math.max(ma[3] + mt[3], DEFAULT_MARGIN);
                                    m[2] = Math.max(Math.max(((legDims.height + 2) / (axesBounds[3] * size[1]) + C * (1 - m[3])) / (1 + C), mt[2]) + ma[2], DEFAULT_MARGIN);
                                    break;
                                case LOWER_CAPTION:
                                    C = LegendDrawer.Y_OFFSET * (3. + 2.);
                                    m[2] = Math.max(ma[2] + mt[2], DEFAULT_MARGIN);
                                    m[3] = Math.max(Math.max(((legDims.height + 2) / (axesBounds[3] * size[1]) + C * (1 - m[2])) / (1 + C), mt[3]) + ma[3], DEFAULT_MARGIN);
                                    break;
                                default:
                            }
                        }
                        break;
                    }
                }
            }
            for (int i = 0; i < m.length; i++) {
                if (m[i] == 0) {
                    m[i] = Math.max(ma[i] + mt[i], DEFAULT_MARGIN);
                }
            }
            if (!m[0].equals(margins[0]) || !m[1].equals(margins[1]) || !m[2].equals(margins[2]) || !m[3].equals(margins[3])) {
                axes.setMargins(m);
            // computeRulers(axes);
            }
        }
    }
}
#method_after
public void computeMargins(Axes axes) {
    if (axes.getAutoMargins() && axes.getViewAsEnum() == ViewType.VIEW_2D) {
        Figure figure = (Figure) GraphicController.getController().getObjectFromId(axes.getParentFigure());
        ColorMap colorMap = null;
        if (figure != null) {
            colorMap = figure.getColorMap();
        } else {
            return;
        }
        Dimension[] marginLabels = labelManager.getLabelsSize(colorMap, axes, this);
        Integer[] size = { visitor.getCanvas().getWidth(), visitor.getCanvas().getHeight() };
        if (size[0] != 0 && size[1] != 0) {
            // [x_left, y_up, w, h]
            Double[] axesBounds = axes.getAxesBounds();
            // [l, r, t, b]
            Double[] margins = axes.getMargins();
            // m is a copy of margins
            Double[] mt = new Double[] { 0., 0., 0., 0. };
            Double[] ma = new Double[] { 0., 0., 0., 0. };
            Double[] m = new Double[] { 0., 0., 0., 0. };
            AxisProperty.AxisLocation xloc = axes.getXAxis().getAxisLocation();
            AxisProperty.AxisLocation yloc = axes.getYAxis().getAxisLocation();
            final double DEFAULT_MARGIN = 0.125;
            // We compute the adapted margins for axes titles.
            if (marginLabels[0].height != 0 || marginLabels[2].height != 0 || marginLabels[1].width != 0) {
                if (marginLabels[2].height != 0) {
                    final double th = (marginLabels[2].height + 2 + TitlePositioner.TITLEOFFSET) / (size[1] * axesBounds[3]);
                    mt[2] = th;
                }
                if (marginLabels[0].height != 0 && (xloc == AxisProperty.AxisLocation.BOTTOM || xloc == AxisProperty.AxisLocation.TOP)) {
                    final double xh = (marginLabels[0].height + 2) / (size[1] * axesBounds[3]);
                    if (xloc == AxisProperty.AxisLocation.BOTTOM) {
                        mt[3] = xh;
                    } else {
                        mt[2] += xh;
                    }
                }
                if (marginLabels[1].width != 0 && (yloc == AxisProperty.AxisLocation.LEFT || yloc == AxisProperty.AxisLocation.RIGHT)) {
                    final double yh = (marginLabels[1].width + 2) / (size[0] * axesBounds[2]);
                    if (yloc == AxisProperty.AxisLocation.LEFT) {
                        mt[0] = yh;
                    } else {
                        mt[1] = yh;
                    }
                }
            }
            // computeRulers(axes);
            final double xratio = rulerDrawer.getRulerDrawer(axes, 0).getDistanceRatio();
            final double yratio = rulerDrawer.getRulerDrawer(axes, 1).getDistanceRatio();
            if (xloc == AxisProperty.AxisLocation.BOTTOM) {
                ma[3] = (1 - margins[2] - margins[3]) * xratio / 2.;
            } else if (xloc == AxisProperty.AxisLocation.TOP) {
                ma[2] = (1 - margins[2] - margins[3]) * xratio / 2.;
            }
            if (yloc == AxisProperty.AxisLocation.LEFT) {
                ma[0] = (1 - margins[0] - margins[1]) * yratio / 2.;
            } else if (yloc == AxisProperty.AxisLocation.RIGHT) {
                ma[1] = (1 - margins[0] - margins[1]) * yratio / 2.;
            }
            // Get the legend if any (only one ???)
            if (axes.getChildren() != null) {
                for (Integer i : axes.getChildren()) {
                    GraphicObject child = GraphicController.getController().getObjectFromId(i);
                    if (child instanceof Legend) {
                        Legend legend = (Legend) child;
                        Dimension legDims = visitor.getLegendDrawer().computeDimensions(axes, legend);
                        if (legDims != null) {
                            LegendLocation legLoc = legend.getLegendLocationAsEnum();
                            double C;
                            /*
                                 * Legends dimension are linearly dependent of margins... so we need to solve an equation
                                 * to find a good value for margins.
                                 * For example:
                                 *  legend.w = texture.w + 3/8 * line.w + line.w
                                 *  where line.w = LINE_WIDTH * ab[2] * (1 - m[0] - m[1]) * size[0];
                                 *  the minimal value for m[1] is the solution of the equation (where unknown is m[1]):
                                 *   legend.w = ab[2] * m[1] * size[0].
                                 */
                            switch(legLoc) {
                                case OUT_UPPER_RIGHT:
                                case OUT_LOWER_RIGHT:
                                    // 1/8 of LINE_WIDTH is xOffset
                                    // see legendDims[0] = ... in LegendDrawer::draw
                                    // we add 2*xoffset to have a little space around the box
                                    C = legend.getLineWidth() + LegendDrawer.LINE_WIDTH * (3. / 8. + 2. / 8.);
                                    m[0] = Math.max(ma[0] + mt[0], DEFAULT_MARGIN);
                                    m[1] = Math.max(((legDims.width + 2) / (axesBounds[2] * size[0]) + C * (1 - m[0])) / (1 + C) + ma[1] + mt[1], DEFAULT_MARGIN);
                                    break;
                                case OUT_UPPER_LEFT:
                                case OUT_LOWER_LEFT:
                                    C = legend.getLineWidth() + LegendDrawer.LINE_WIDTH * (3. / 8. + 2. / 8.);
                                    m[1] = Math.max(ma[1] + mt[1], DEFAULT_MARGIN);
                                    m[0] = Math.max(((legDims.width + 2) / (axesBounds[2] * size[0]) + C * (1 - m[1])) / (1 + C) + ma[0] + mt[0], DEFAULT_MARGIN);
                                    break;
                                case UPPER_CAPTION:
                                    C = LegendDrawer.Y_OFFSET * (3. + 2.);
                                    m[3] = Math.max(ma[3] + mt[3], DEFAULT_MARGIN);
                                    m[2] = Math.max(Math.max(((legDims.height + 2) / (axesBounds[3] * size[1]) + C * (1 - m[3])) / (1 + C), mt[2]) + ma[2], DEFAULT_MARGIN);
                                    break;
                                case LOWER_CAPTION:
                                    C = LegendDrawer.Y_OFFSET * (3. + 2.);
                                    m[2] = Math.max(ma[2] + mt[2], DEFAULT_MARGIN);
                                    m[3] = Math.max(Math.max(((legDims.height + 2) / (axesBounds[3] * size[1]) + C * (1 - m[2])) / (1 + C), mt[3]) + ma[3], DEFAULT_MARGIN);
                                    break;
                                default:
                            }
                        }
                        break;
                    }
                }
            }
            for (int i = 0; i < m.length; i++) {
                if (m[i] == 0) {
                    m[i] = Math.max(ma[i] + mt[i], DEFAULT_MARGIN);
                }
            }
            if (!m[0].equals(margins[0]) || !m[1].equals(margins[1]) || !m[2].equals(margins[2]) || !m[3].equals(margins[3])) {
                axes.setMargins(m);
            // computeRulers(axes);
            }
        }
    }
}
#end_block

#method_before
public String askForClosing() {
    boolean isContentModified = false;
    for (int i = 0; i < getTabPane().getTabCount(); i++) {
        ScilabEditorPane textPaneAt = getTextPane(i);
        if (textPaneAt != null && ((ScilabDocument) textPaneAt.getDocument()).isContentModified()) {
            isContentModified = true;
            break;
        }
    }
    if (isContentModified) {
        return "SciNotes";
    }
    return null;
}
#method_after
public String askForClosing() {
    int numberOfTab = getTabPane().getTabCount();
    boolean isContentModified = false;
    for (int i = 0; i < numberOfTab; i++) {
        ScilabEditorPane textPaneAt = getTextPane(i);
        if (textPaneAt != null && ((ScilabDocument) textPaneAt.getDocument()).isContentModified()) {
            isContentModified = true;
            break;
        }
    }
    if (isContentModified) {
        return "SciNotes";
    }
    return null;
}
#end_block

#method_before
// CSON: MagicNumber
// CSON: IllegalCatch
public static synchronized Xcos getInstance() {
    return getInstance(null);
}
#method_after
public static synchronized Xcos getInstance() {
    return getInstance(null);
}
#end_block

#method_before
public synchronized void quit(boolean force) {
    if (sharedInstance == null) {
        return;
    }
// TODO : perform something ?
}
#method_after
public static synchronized void quit(boolean force) {
    if (sharedInstance == null) {
        return;
    }
// TODO : perform something ?
}
#end_block

#method_before
public void append(String content) {
    try {
        ScilabDocument doc = (ScilabDocument) editor.getTextPane().getDocument();
        doc.setFocused(true);
        Element root = editor.getTextPane().getDocument().getDefaultRootElement();
        int pos = editor.getTextPane().getCaretPosition();
        doc.mergeEditsBegin();
        editor.getTextPane().getDocument().insertString(pos, content, null);
        doc.mergeEditsEnd();
    } catch (BadLocationException e) {
    }
}
#method_after
public void append(String content) {
    try {
        ScilabDocument doc = (ScilabDocument) editor.getTextPane().getDocument();
        doc.setFocused(true);
        Element root = editor.getTextPane().getDocument().getDefaultRootElement();
        int pos = editor.getTextPane().getCaretPosition();
        doc.mergeEditsBegin();
        editor.getTextPane().getDocument().insertString(pos, content, null);
        doc.mergeEditsEnd();
    } catch (BadLocationException e) {
        System.err.println(e);
    }
}
#end_block

#method_before
public void backspace() {
    try {
        Element root = editor.getTextPane().getDocument().getDefaultRootElement();
        int pos = editor.getTextPane().getCaretPosition();
        editor.getTextPane().getDocument().remove(pos - 1, 1);
        editor.getTextPane().setCaretPosition(pos - 1);
    } catch (BadLocationException e) {
    }
}
#method_after
public void backspace() {
    try {
        Element root = editor.getTextPane().getDocument().getDefaultRootElement();
        int pos = editor.getTextPane().getCaretPosition();
        editor.getTextPane().getDocument().remove(pos - 1, 1);
        editor.getTextPane().setCaretPosition(pos - 1);
    } catch (BadLocationException e) {
        System.err.println(e);
    }
}
#end_block

#method_before
@Override
public int write() throws IOException {
    if (g2d != null) {
        g2d.finish();
    }
    if (buffer != null && file != null) {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            buffer.writeTo(fos);
            buffer.close();
            fos.flush();
        } catch (IOException ioe) {
            e.printStackTrace();
        }
    }
    if (out != null) {
        out.close();
    }
    return Export.SUCCESS;
}
#method_after
@Override
public int write() throws IOException {
    if (g2d != null) {
        g2d.finish();
    }
    if (buffer != null && file != null) {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            buffer.writeTo(fos);
            buffer.close();
            fos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if (out != null) {
        out.close();
    }
    return Export.SUCCESS;
}
#end_block

#method_before
@Override
public int write() throws IOException {
    if (g2d != null) {
        g2d.finish();
    }
    if (buffer != null && file != null) {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            buffer.writeTo(fos);
            buffer.close();
            fos.flush();
        } catch (IOException ioe) {
            e.printStackTrace();
        }
    }
    if (out != null) {
        out.close();
    }
    return Export.SUCCESS;
}
#method_after
@Override
public int write() throws IOException {
    if (g2d != null) {
        g2d.finish();
    }
    if (buffer != null && file != null) {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            buffer.writeTo(fos);
            buffer.close();
            fos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if (out != null) {
        out.close();
    }
    return Export.SUCCESS;
}
#end_block

#method_before
@Override
public int write() throws IOException {
    if (g2d != null) {
        try {
            g2dClass.getMethod("endExport").invoke(g2d);
            g2dClass.getMethod("closeStream").invoke(g2d);
        } catch (IllegalAccessException e) {
        } catch (IllegalArgumentException e) {
        } catch (InvocationTargetException e) {
        } catch (NoSuchMethodException e) {
        } catch (SecurityException e) {
        }
    }
    if (buffer != null && file != null) {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            buffer.writeTo(fos);
            buffer.close();
            fos.flush();
        } catch (IOException ioe) {
            e.printStackTrace();
        }
    }
    if (out != null) {
        out.close();
    }
    return Export.SUCCESS;
}
#method_after
@Override
public int write() throws IOException {
    if (g2d != null) {
        try {
            g2dClass.getMethod("endExport").invoke(g2d);
            g2dClass.getMethod("closeStream").invoke(g2d);
        } catch (IllegalAccessException e) {
        } catch (IllegalArgumentException e) {
        } catch (InvocationTargetException e) {
        } catch (NoSuchMethodException e) {
        } catch (SecurityException e) {
        }
    }
    if (buffer != null && file != null) {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            buffer.writeTo(fos);
            buffer.close();
            fos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if (out != null) {
        out.close();
    }
    return Export.SUCCESS;
}
#end_block

#method_before
public static void executeAction(String fileName, ActionOnDocument action) throws IOException {
    Charset charset = null;
    try {
        charset = ScilabEditorKit.tryToGuessEncoding(new File(fileName));
    } catch (CharacterCodingException e) {
        throw new IOException(SciNotesMessages.CANNOT_GUESS_ENCODING + ": " + fileName);
    }
    try (FileInputStream fis = new FileInputStream(fileName);
        InputStreamReader isr = new InputStreamReader(fis, charset);
        BufferedReader reader = new BufferedReader(isr)) {
        ScilabDocument doc = new ScilabDocument();
        ScilabEditorKit kit = new ScilabEditorKit();
        try {
            kit.read(reader, doc, 0);
        } catch (BadLocationException e) {
            System.err.println(e);
        }
        doc.addDocumentListener(doc);
        if (!doc.getBinary()) {
            action.actionOn(doc);
        }
        if (doc.isContentModified()) {
            SaveFile.doSave(doc, new File(fileName), kit);
        }
    } catch (IOExceptiom ioe) {
        System.err.println(ioe);
    }
}
#method_after
public static void executeAction(String fileName, ActionOnDocument action) throws IOException {
    Charset charset = null;
    try {
        charset = ScilabEditorKit.tryToGuessEncoding(new File(fileName));
    } catch (CharacterCodingException e) {
        throw new IOException(SciNotesMessages.CANNOT_GUESS_ENCODING + ": " + fileName);
    }
    try (FileInputStream fis = new FileInputStream(fileName);
        InputStreamReader isr = new InputStreamReader(fis, charset);
        BufferedReader reader = new BufferedReader(isr)) {
        ScilabDocument doc = new ScilabDocument();
        ScilabEditorKit kit = new ScilabEditorKit();
        try {
            kit.read(reader, doc, 0);
        } catch (BadLocationException e) {
            System.err.println(e);
        }
    } catch (IOExceptiom ioe) {
        System.err.println(ioe);
    }
    doc.addDocumentListener(doc);
    if (!doc.getBinary()) {
        action.actionOn(doc);
    }
    if (doc.isContentModified()) {
        SaveFile.doSave(doc, new File(fileName), kit);
    }
}
#end_block

#method_before
public static int createJarArchive(String jarFilePath, String[] filePaths, String filesRootPath, String manifestFilePath, boolean keepAbsolutePaths) throws ScilabJavaException {
    JarOutputStream jarOutputStream = null;
    try {
        // Normalize path (Windows short path => long path, remove '..')
        String[] normalizedFilePaths = new String[filePaths.length];
        int i = 0;
        for (String filePath : filePaths) {
            normalizedFilePaths[i++] = new File(filePath).getCanonicalPath();
        }
        // Use the given root path or compute it
        String commonPath = null;
        if ((filesRootPath == null) || (filesRootPath.isEmpty())) {
            if (!keepAbsolutePaths) {
                commonPath = getCommonPath(normalizedFilePaths);
            }
        } else {
            // Normalize root path
            commonPath = new File(filesRootPath).getCanonicalPath();
        }
        // Finds all the list of all the files in the directory trees
        List<String> expandedFilePaths = expandPaths(normalizedFilePaths);
        // Manifest
        // if specified take the one given in argument, otherwise take META-INF/MANIFEST.MF
        // if does not exist, create a manifest
        Manifest manifest = null;
        if ((manifestFilePath == null) || (manifestFilePath.isEmpty())) {
            manifestFilePath = commonPath + File.separator + "META-INF" + File.separator + "MANIFEST.MF";
        }
        FileInputStream fis = null;
        try {
            if (new File(manifestFilePath).exists()) {
                fis = new FileInputStream(manifestFilePath);
                manifest = new Manifest(fis);
            } else {
                manifest = new Manifest();
            }
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                System.err.println(e);
            }
        }
        // Now create the jar with all the files
        FileOutputStream stream = new FileOutputStream(jarFilePath);
        jarOutputStream = new JarOutputStream(stream, manifest);
        for (String filePath : expandedFilePaths) {
            File file = new File(filePath);
            String pathInJar;
            if ((commonPath != null) && (!commonPath.isEmpty())) {
                pathInJar = getRelativePath(commonPath, filePath);
            } else {
                if (keepAbsolutePaths) {
                    pathInJar = file.getPath();
                } else {
                    pathInJar = file.getName();
                }
            }
            // Skip manifest file, it will be created automatically
            if (pathInJar.equals("META-INF/MANIFEST.MF")) {
                continue;
            }
            addFileToJarArchive(file, pathInJar, jarOutputStream);
        }
        closeJarArchive(jarOutputStream);
        jarOutputStream = null;
        return 0;
    } catch (IOException e) {
        try {
            closeJarArchive(jarOutputStream);
            deleteJarArchive(jarFilePath);
        } catch (Exception e2) {
        }
        throw new ScilabJavaException(String.format("Cannot create jar archive %s: %s", jarFilePath, e.getMessage()));
    }
}
#method_after
public static int createJarArchive(String jarFilePath, String[] filePaths, String filesRootPath, String manifestFilePath, boolean keepAbsolutePaths) throws ScilabJavaException {
    JarOutputStream jarOutputStream = null;
    try {
        // Normalize path (Windows short path => long path, remove '..')
        String[] normalizedFilePaths = new String[filePaths.length];
        int i = 0;
        for (String filePath : filePaths) {
            normalizedFilePaths[i++] = new File(filePath).getCanonicalPath();
        }
        // Use the given root path or compute it
        String commonPath = null;
        if ((filesRootPath == null) || (filesRootPath.isEmpty())) {
            if (!keepAbsolutePaths) {
                commonPath = getCommonPath(normalizedFilePaths);
            }
        } else {
            // Normalize root path
            commonPath = new File(filesRootPath).getCanonicalPath();
        }
        // Finds all the list of all the files in the directory trees
        List<String> expandedFilePaths = expandPaths(normalizedFilePaths);
        // Manifest
        // if specified take the one given in argument, otherwise take META-INF/MANIFEST.MF
        // if does not exist, create a manifest
        Manifest manifest = null;
        if ((manifestFilePath == null) || (manifestFilePath.isEmpty())) {
            manifestFilePath = commonPath + File.separator + "META-INF" + File.separator + "MANIFEST.MF";
        }
        if (new File(manifestFilePath).exists()) {
            FileInputStream fis = null;
            try {
                fis = new FileInputStream(manifestFilePath);
                manifest = new Manifest(fis);
            } catch (IOException e) {
                System.err.println(e);
            } finally {
                if (fis != null) {
                    fis.close();
                }
            }
        } else {
            manifest = new Manifest();
        }
        // Now create the jar with all the files
        FileOutputStream stream = new FileOutputStream(jarFilePath);
        jarOutputStream = new JarOutputStream(stream, manifest);
        for (String filePath : expandedFilePaths) {
            File file = new File(filePath);
            String pathInJar;
            if ((commonPath != null) && (!commonPath.isEmpty())) {
                pathInJar = getRelativePath(commonPath, filePath);
            } else {
                if (keepAbsolutePaths) {
                    pathInJar = file.getPath();
                } else {
                    pathInJar = file.getName();
                }
            }
            // Skip manifest file, it will be created automatically
            if (pathInJar.equals("META-INF/MANIFEST.MF")) {
                continue;
            }
            addFileToJarArchive(file, pathInJar, jarOutputStream);
        }
        closeJarArchive(jarOutputStream);
        jarOutputStream = null;
        return 0;
    } catch (IOException e) {
        try {
            closeJarArchive(jarOutputStream);
            deleteJarArchive(jarFilePath);
        } catch (Exception e2) {
        }
        throw new ScilabJavaException(String.format("Cannot create jar archive %s: %s", jarFilePath, e.getMessage()));
    }
}
#end_block

#method_before
private void parseFile(File f) {
    try {
        BufferedReader reader = new BufferedReader(new FileReader(f));
        String line = null;
        StringBuilder stringBuilder = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            stringBuilder.append(line);
            stringBuilder.append("\n");
        }
        reader.close();
        array = stringBuilder.toString().split("(<!--<)|(>-->)");
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (reader != null) {
            reader.close();
        }
    }
}
#method_after
private void parseFile(File f) {
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(f));
        String line = null;
        StringBuilder stringBuilder = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            stringBuilder.append(line);
            stringBuilder.append("\n");
        }
        array = stringBuilder.toString().split("(<!--<)|(>-->)");
    } catch (IOException e) {
        e.printStackTrace();
    }
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
#end_block

#method_before
public void addAction(Action action) {
    if (head == null) {
        head = 0;
    }
    while (head > 0) {
        /*same as removeFirst without throwing exception if the deque is empty*/
        Action a = history.pollFirst();
        a.dispose();
        --head;
    }
    /*history reached max capacity? remove oldest action*/
    if (history.size() == MAX_HISTORY_SIZE) {
        Action a = history.pollLast();
        a.dispose();
    }
    history.addFirst(action);
}
#method_after
public void addAction(Action action) {
    while (head > 0) {
        /*same as removeFirst without throwing exception if the deque is empty*/
        Action a = history.pollFirst();
        a.dispose();
        --head;
    }
    /*history reached max capacity? remove oldest action*/
    if (history.size() == MAX_HISTORY_SIZE) {
        Action a = history.pollLast();
        a.dispose();
    }
    history.addFirst(action);
}
#end_block

#method_before
public void undo() {
    Action action = history.get(head);
    if (action.exists()) {
        action.undo();
        ++head;
    } else {
        history.remove((int) head);
    }
}
#method_after
public void undo() {
    Action action = history.get(head);
    if (action.exists()) {
        action.undo();
        ++head;
    } else {
        history.remove(head);
    }
}
#end_block

#method_before
public void redo() {
    if (head > 0) {
        --head;
        Action action = history.get(head);
        if (action.exists()) {
            action.redo();
        } else {
            Action a = history.get(head);
            a.dispose();
            history.remove((int) head);
        }
    }
}
#method_after
public void redo() {
    if (head > 0) {
        --head;
        Action action = history.get(head);
        if (action.exists()) {
            action.redo();
        } else {
            Action a = history.get(head);
            a.dispose();
            history.remove(head);
        }
    }
}
#end_block

#method_before
// Pass this method an Object and a Method equipped to handle document events from the Finder
// Documents are registered with the Finder via the CFBundleDocumentTypes dictionary in the
public static void setFileHandler(Object target, Method fileHandler) {
    setHandler(new OSXAdapter("handleOpenFile", target, fileHandler) {

        // Override OSXAdapter.callTarget to send information on the
        // file to be opened
        @Override
        public boolean callTarget(Object appleEvent) {
            if (appleEvent != null) {
                try {
                    Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);
                    String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
                    this.targetMethod.invoke(this.targetObject, new Object[] { filename });
                } catch (RuntimeException ex) {
                    throw ex;
                } catch (Exception ex) {
                }
            }
            return true;
        }
    });
}
#method_after
// Pass this method an Object and a Method equipped to handle document events from the Finder
// Documents are registered with the Finder via the CFBundleDocumentTypes dictionary in the
public static void setFileHandler(Object target, Method fileHandler) {
    setHandler(new OSXAdapter("handleOpenFile", target, fileHandler) {

        // Override OSXAdapter.callTarget to send information on the
        // file to be opened
        @Override
        public boolean callTarget(Object appleEvent) {
            if (appleEvent != null) {
                try {
                    Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);
                    String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
                    this.targetMethod.invoke(this.targetObject, new Object[] { filename });
                } catch (RuntimeException ex) {
                } catch (Exception ex) {
                }
            }
            return true;
        }
    });
}
#end_block

#method_before
public void setEnabled(boolean status) {
    uiTable.setEnabled(status);
    super.setEnabled(status);
}
#method_after
public void setEnabled(boolean status) {
    super.setEnabled(status);
    uiTable.setEnabled(status);
}
#end_block

#method_before
private static void updatePortsPositions(final XcosDiagram diag, BasicBlock block, List<BasicPort> ports, Orientation iter) {
    @SuppressWarnings("serial")
    final List<BasicPort> invertedPorts = new ArrayList<BasicPort>(ports) {

        {
            Collections.reverse(this);
        }
    };
    JavaController controller = new JavaController();
    String[] style = new String[1];
    controller.getObjectProperty(block.getUID(), Kind.BLOCK, ObjectProperties.STYLE, style);
    StyleMap styleMap = new StyleMap(style[0]);
    final boolean mirrored = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_MIRROR));
    final boolean flipped = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_FLIP));
    final int intRotation = Double.valueOf(styleMap.getOrDefault(XcosConstants.STYLE_ROTATION, "0")).intValue();
    final int angle = ((intRotation) % 360 + 360) % 360;
    List<BasicPort> working = ports;
    /* List order modification with the flip flag */
    if (flipped) {
        if (iter == Orientation.NORTH || iter == Orientation.SOUTH) {
            working = invertedPorts;
        }
    }
    /* List order modification with the mirror flag */
    if (mirrored) {
        if (iter == Orientation.EAST || iter == Orientation.WEST) {
            working = invertedPorts;
        }
    }
    /*
         * Ugly modification of the iter to update at the right position Works only for 0 - 90 - 180 - 270 angles.
         */
    Orientation rotated = rotateOrientation(iter, mirrored, flipped);
    updatePortsPosition(diag, block, rotated, angle, working);
}
#method_after
private static void updatePortsPositions(final XcosDiagram diag, BasicBlock block, List<BasicPort> ports, Orientation iter) {
    @SuppressWarnings("serial")
    final List<BasicPort> invertedPorts = new ArrayList<BasicPort>(ports) {

        {
            Collections.reverse(this);
        }
    };
    JavaController controller = new JavaController();
    String[] style = new String[1];
    controller.getObjectProperty(block.getUID(), Kind.BLOCK, ObjectProperties.STYLE, style);
    StyleMap styleMap = new StyleMap(style[0]);
    final boolean mirrored = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_MIRROR));
    final boolean flipped = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_FLIP));
    final int intRotation = Double.valueOf(styleMap.getOrDefault(XcosConstants.STYLE_ROTATION, "0")).intValue();
    final int angle = (intRotation % 360 + 360) % 360;
    List<BasicPort> working = ports;
    /* List order modification with the flip flag */
    if (flipped) {
        if (iter == Orientation.NORTH || iter == Orientation.SOUTH) {
            working = invertedPorts;
        }
    }
    /* List order modification with the mirror flag */
    if (mirrored) {
        if (iter == Orientation.EAST || iter == Orientation.WEST) {
            working = invertedPorts;
        }
    }
    /*
         * Ugly modification of the iter to update at the right position Works only for 0 - 90 - 180 - 270 angles.
         */
    Orientation rotated = rotateOrientation(iter, mirrored, flipped);
    updatePortsPosition(diag, block, rotated, angle, working);
}
#end_block

#method_before
public static void rotateAllPorts(final XcosDiagram diag, BasicBlock block) {
    JavaController controller = new JavaController();
    String[] style = new String[1];
    controller.getObjectProperty(block.getUID(), Kind.BLOCK, ObjectProperties.STYLE, style);
    StyleMap styleMap = new StyleMap(style[0]);
    final boolean mirrored = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_MIRROR));
    final boolean flipped = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_FLIP));
    final int intRotation = Double.valueOf(styleMap.getOrDefault(XcosConstants.STYLE_ROTATION, "0")).intValue();
    final int angle = ((intRotation) % 360 + 360) % 360;
    final int childrenCount = block.getChildCount();
    for (int i = 0; i < childrenCount; ++i) {
        if (block.getChildAt(i) instanceof BasicPort) {
            final BasicPort port = (BasicPort) block.getChildAt(i);
            final Orientation orientation = port.getOrientation();
            diag.getModel().beginUpdate();
            /* Apply angle */
            final mxIGraphModel model = diag.getModel();
            final String rot = Integer.toString(orientation.getRelativeAngle(angle, port.getClass(), flipped, mirrored));
            mxStyleUtils.setCellStyles(model, new Object[] { port }, XcosConstants.STYLE_ROTATION, rot);
            diag.getModel().endUpdate();
        }
    }
}
#method_after
public static void rotateAllPorts(final XcosDiagram diag, BasicBlock block) {
    JavaController controller = new JavaController();
    String[] style = new String[1];
    controller.getObjectProperty(block.getUID(), Kind.BLOCK, ObjectProperties.STYLE, style);
    StyleMap styleMap = new StyleMap(style[0]);
    final boolean mirrored = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_MIRROR));
    final boolean flipped = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_FLIP));
    final int intRotation = Double.valueOf(styleMap.getOrDefault(XcosConstants.STYLE_ROTATION, "0")).intValue();
    final int angle = (intRotation % 360 + 360) % 360;
    final int childrenCount = block.getChildCount();
    for (int i = 0; i < childrenCount; ++i) {
        if (block.getChildAt(i) instanceof BasicPort) {
            final BasicPort port = (BasicPort) block.getChildAt(i);
            final Orientation orientation = port.getOrientation();
            diag.getModel().beginUpdate();
            /* Apply angle */
            final mxIGraphModel model = diag.getModel();
            final String rot = Integer.toString(orientation.getRelativeAngle(angle, port.getClass(), flipped, mirrored));
            mxStyleUtils.setCellStyles(model, new Object[] { port }, XcosConstants.STYLE_ROTATION, rot);
            diag.getModel().endUpdate();
        }
    }
}
#end_block

#method_before
public void init() {
    menu = new JPopupMenu();
    labels = new JMenu(Messages.gettext("Label"));
    legends = new JMenu(Messages.gettext("Legend"));
    copy = new JMenuItem(Messages.gettext("Copy"));
    copy.setToolTipText(Messages.gettext("Copy selected object"));
    cut = new JMenuItem(Messages.gettext("Cut"));
    cut.setToolTipText(Messages.gettext("Cut selected object"));
    paste = new JMenuItem(Messages.gettext("Paste"));
    paste.setToolTipText(Messages.gettext("Paste copied object on this figure"));
    delete = new JMenuItem(Messages.gettext("Delete"));
    delete.setToolTipText(Messages.gettext("Delete selected object"));
    clear = new JMenuItem(Messages.gettext("Clear"));
    clear.setToolTipText(Messages.gettext("Clears the figure"));
    hide = new JMenuItem(Messages.gettext("Hide"));
    hide.setToolTipText(Messages.gettext("Hide selected object"));
    unhide = new JMenuItem(Messages.gettext("Unhide all"));
    unhide.setToolTipText(Messages.gettext("Unhide all objects"));
    clipboardCopy = new JMenuItem(Messages.gettext("Copy to Clipboard"));
    clipboardCopy.setToolTipText(Messages.gettext("Copy figure to system clipboard"));
    labelX = new JMenuItem(Messages.gettext("Label X"));
    labelX.setToolTipText(Messages.gettext("Insert a label in X axis"));
    labelY = new JMenuItem(Messages.gettext("Label Y"));
    labelY.setToolTipText(Messages.gettext("Insert a label in Y axis"));
    labelZ = new JMenuItem(Messages.gettext("Label Z"));
    labelZ.setToolTipText(Messages.gettext("Insert a label in Z axis"));
    title = new JMenuItem(Messages.gettext("Title"));
    title.setToolTipText(Messages.gettext("Insert a label in title"));
    insert = new JMenuItem(Messages.gettext("Insert"));
    insert.setToolTipText(Messages.gettext("Insert a legend into the selected curve"));
    remove = new JMenuItem(Messages.gettext("Remove"));
    remove.setToolTipText(Messages.gettext("Remove the legend from the selected curve"));
    ged = new JMenuItem(Messages.gettext("Open Quick Editor"));
    ged.setToolTipText(Messages.gettext("Initialize the graphics editor"));
    editdata = new JMenuItem(Messages.gettext("Edit curve data"));
    editdata.setToolTipText(Messages.gettext("Enables curve data modification"));
    undo = new JMenuItem(Messages.gettext("Undo"));
    undo.setToolTipText(Messages.gettext("Undo last action"));
    redo = new JMenuItem(Messages.gettext("Redo"));
    redo.setToolTipText(Messages.gettext("Redo last undo action"));
    copyStyle = new JMenuItem(Messages.gettext("Copy style"));
    copyStyle.setToolTipText(Messages.gettext("Copy the style of the axes"));
    pasteStyle = new JMenuItem(Messages.gettext("Paste style"));
    pasteStyle.setToolTipText(Messages.gettext("Paste the copied style on these axes"));
    copy.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCopy();
        }
    });
    cut.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCut();
        }
    });
    paste.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickPaste();
        }
    });
    delete.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickDelete();
        }
    });
    clear.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickClear();
        }
    });
    hide.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickHide();
        }
    });
    unhide.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickUnhide();
        }
    });
    clipboardCopy.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCCopy();
        }
    });
    labelX.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__X__);
        }
    });
    labelY.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__Y__);
        }
    });
    labelZ.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__Z__);
        }
    });
    title.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__TITLE__);
        }
    });
    insert.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickInsert(getSelected());
        }
    });
    remove.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickRemove();
        }
    });
    ged.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickGED();
        }
    });
    editdata.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            setDataModifyEnabled(true);
        }
    });
    undo.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickUndo();
        }
    });
    redo.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickRedo();
        }
    });
    copyStyle.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCopyStyle();
        }
    });
    pasteStyle.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickPasteStyle();
        }
    });
    labels.add(labelX);
    labels.add(labelY);
    labels.add(labelZ);
    labels.add(title);
    legends.add(insert);
    legends.add(remove);
    menu.add(copy);
    menu.add(cut);
    menu.add(paste);
    menu.add(copyStyle);
    menu.add(pasteStyle);
    menu.addSeparator();
    menu.add(delete);
    menu.add(clear);
    menu.add(undo);
    menu.add(redo);
    menu.addSeparator();
    menu.add(hide);
    menu.add(unhide);
    menu.addSeparator();
    menu.add(clipboardCopy);
    menu.addSeparator();
    menu.add(labels);
    menu.add(legends);
    menu.add(editdata);
    if (StartGED.enableNewGed) {
        menu.addSeparator();
        menu.add(ged);
    }
}
#method_after
public void init() {
    menu = new JPopupMenu();
    labels = new JMenu(Messages.gettext("Label"));
    legends = new JMenu(Messages.gettext("Legend"));
    copy = new JMenuItem(Messages.gettext("Copy"));
    copy.setToolTipText(Messages.gettext("Copy selected object"));
    cut = new JMenuItem(Messages.gettext("Cut"));
    cut.setToolTipText(Messages.gettext("Cut selected object"));
    paste = new JMenuItem(Messages.gettext("Paste"));
    paste.setToolTipText(Messages.gettext("Paste copied object on this figure"));
    delete = new JMenuItem(Messages.gettext("Delete"));
    delete.setToolTipText(Messages.gettext("Delete selected object"));
    clear = new JMenuItem(Messages.gettext("Clear"));
    clear.setToolTipText(Messages.gettext("Clears the figure"));
    hide = new JMenuItem(Messages.gettext("Hide"));
    hide.setToolTipText(Messages.gettext("Hide selected object"));
    unhide = new JMenuItem(Messages.gettext("Unhide all"));
    unhide.setToolTipText(Messages.gettext("Unhide all objects"));
    clipboardCopy = new JMenuItem(Messages.gettext("Copy to Clipboard"));
    clipboardCopy.setToolTipText(Messages.gettext("Copy figure to system clipboard"));
    title = new JMenuItem(Messages.gettext("Title"));
    title.setToolTipText(Messages.gettext("Insert a title"));
    labelX = new JMenuItem(Messages.gettext("Label X"));
    labelX.setToolTipText(Messages.gettext("Insert a label in X axis"));
    labelY = new JMenuItem(Messages.gettext("Label Y"));
    labelY.setToolTipText(Messages.gettext("Insert a label in Y axis"));
    labelZ = new JMenuItem(Messages.gettext("Label Z"));
    labelZ.setToolTipText(Messages.gettext("Insert a label in Z axis"));
    insert = new JMenuItem(Messages.gettext("Insert"));
    insert.setToolTipText(Messages.gettext("Insert a legend into the selected curve"));
    remove = new JMenuItem(Messages.gettext("Remove"));
    remove.setToolTipText(Messages.gettext("Remove the legend from the selected curve"));
    ged = new JMenuItem(Messages.gettext("Open Quick Editor"));
    ged.setToolTipText(Messages.gettext("Initialize the graphics editor"));
    editdata = new JMenuItem(Messages.gettext("Edit curve data"));
    editdata.setToolTipText(Messages.gettext("Enables curve data modification"));
    undo = new JMenuItem(Messages.gettext("Undo"));
    undo.setToolTipText(Messages.gettext("Undo last action"));
    redo = new JMenuItem(Messages.gettext("Redo"));
    redo.setToolTipText(Messages.gettext("Redo last undo action"));
    copyStyle = new JMenuItem(Messages.gettext("Copy style"));
    copyStyle.setToolTipText(Messages.gettext("Copy the style of the axes"));
    pasteStyle = new JMenuItem(Messages.gettext("Paste style"));
    pasteStyle.setToolTipText(Messages.gettext("Paste the copied style on these axes"));
    copy.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCopy();
        }
    });
    cut.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCut();
        }
    });
    paste.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickPaste();
        }
    });
    delete.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickDelete();
        }
    });
    clear.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickClear();
        }
    });
    hide.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickHide();
        }
    });
    unhide.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickUnhide();
        }
    });
    clipboardCopy.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCCopy();
        }
    });
    labelX.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__X__);
        }
    });
    labelY.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__Y__);
        }
    });
    labelZ.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__Z__);
        }
    });
    title.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickLabel(AxesHandler.axisTo.__TITLE__);
        }
    });
    insert.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickInsert(getSelected());
        }
    });
    remove.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickRemove();
        }
    });
    ged.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickGED();
        }
    });
    editdata.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            setDataModifyEnabled(true);
        }
    });
    undo.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickUndo();
        }
    });
    redo.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickRedo();
        }
    });
    copyStyle.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickCopyStyle();
        }
    });
    pasteStyle.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            onClickPasteStyle();
        }
    });
    labels.add(labelX);
    labels.add(labelY);
    labels.add(labelZ);
    labels.add(title);
    legends.add(insert);
    legends.add(remove);
    menu.add(copy);
    menu.add(cut);
    menu.add(paste);
    menu.add(copyStyle);
    menu.add(pasteStyle);
    menu.addSeparator();
    menu.add(delete);
    menu.add(clear);
    menu.add(undo);
    menu.add(redo);
    menu.addSeparator();
    menu.add(hide);
    menu.add(unhide);
    menu.addSeparator();
    menu.add(clipboardCopy);
    menu.addSeparator();
    menu.add(labels);
    menu.add(legends);
    menu.add(editdata);
    if (StartGED.enableNewGed) {
        menu.addSeparator();
        menu.add(ged);
    }
}
#end_block

#method_before
private static SplitBlock getRootSplitBlock(SplitBlock splitblock) {
    mxICell port = getSplitInLinkPort(splitblock);
    if (port == null) {
        return null;
    }
    while ((port != null) && (port.getParent() instanceof SplitBlock)) {
        port = getSplitInLinkPort(((SplitBlock) port.getParent()));
    }
    mxICell edge = port.getEdgeAt(0);
    mxICell cell = ((mxCell) edge).getTarget();
    return ((SplitBlock) cell.getParent());
}
#method_after
private static SplitBlock getRootSplitBlock(SplitBlock splitblock) {
    mxICell port = getSplitInLinkPort(splitblock);
    while ((port != null) && (port.getParent() instanceof SplitBlock)) {
        port = getSplitInLinkPort(((SplitBlock) port.getParent()));
    }
    if (port == null) {
        return null;
    }
    mxICell edge = port.getEdgeAt(0);
    mxICell cell = ((mxCell) edge).getTarget();
    return ((SplitBlock) cell.getParent());
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, double[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_0(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, double[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_1(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, int[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_1(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, int[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_2(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, boolean[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_2(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, boolean[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_3(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, String[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_3(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, String[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_4(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, long[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_4(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, long[] v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_5(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfDouble v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_5(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfDouble.getCPtr(v), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfDouble v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_6(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfDouble.getCPtr(v), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfInt v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_6(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfInt.getCPtr(v), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfInt v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_7(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfInt.getCPtr(v), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfBool v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_7(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfBool.getCPtr(v), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfBool v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_8(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfBool.getCPtr(v), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfString v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_8(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfString.getCPtr(v), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfString v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_9(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfString.getCPtr(v), v);
}
#end_block

#method_before
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfScicosID v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_9(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfScicosID.getCPtr(v), v);
}
#method_after
public boolean getObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfScicosID v) {
    return JavaControllerJNI.Controller_getObjectProperty__SWIG_10(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfScicosID.getCPtr(v), v);
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, double v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_0(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, double v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_1(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, int v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_1(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, int v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_2(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, boolean v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_2(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, boolean v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_3(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, long v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_3(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, long v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_4(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, String v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_4(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, String v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_5(swigCPtr, this, uid, k.ordinal(), p.ordinal(), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfDouble v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_5(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfDouble.getCPtr(v), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfDouble v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_6(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfDouble.getCPtr(v), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfInt v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_6(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfInt.getCPtr(v), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfInt v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_7(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfInt.getCPtr(v), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfBool v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_7(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfBool.getCPtr(v), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfBool v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_8(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfBool.getCPtr(v), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfString v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_8(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfString.getCPtr(v), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfString v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_9(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfString.getCPtr(v), v)];
}
#end_block

#method_before
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfScicosID v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_9(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfScicosID.getCPtr(v), v)];
}
#method_after
public UpdateStatus setObjectProperty(long uid, Kind k, ObjectProperties p, VectorOfScicosID v) {
    return UpdateStatus.class.getEnumConstants()[JavaControllerJNI.Controller_setObjectProperty__SWIG_10(swigCPtr, this, uid, k.ordinal(), p.ordinal(), VectorOfScicosID.getCPtr(v), v)];
}
#end_block

#method_before
public static PortKind port_from_property(ObjectProperties p) {
    return PortKind.class.getEnumConstants()[JavaControllerJNI.port_from_property(p.ordinal())];
}
#method_after
public static int port_from_property(ObjectProperties p) {
    return JavaControllerJNI.port_from_property(p.ordinal());
}
#end_block

#method_before
public static ObjectProperties property_from_port(PortKind p) {
    return ObjectProperties.class.getEnumConstants()[JavaControllerJNI.property_from_port(p.ordinal())];
}
#method_after
public static ObjectProperties property_from_port(int p) {
    return ObjectProperties.class.getEnumConstants()[JavaControllerJNI.property_from_port(p)];
}
#end_block

#method_before
private SuperBlock allocateSuperBlock(final JavaController controller, final XcosDiagram parentGraph, final Object[] selection) throws ScilabInterpreterManagement.InterpreterException {
    final SuperBlock superBlock = (SuperBlock) XcosCellFactory.createBlock(INTERFUNCTION_NAME);
    /*
         * Remove the default allocated ports
         */
    while (superBlock.getChildCount() > 0) {
        superBlock.remove(superBlock.getChildCount() - 1);
    }
    VectorOfScicosID children = new VectorOfScicosID();
    controller.setObjectProperty(superBlock.getUID(), superBlock.getKind(), ObjectProperties.CHILDREN, children);
    /*
         * Place the super block
         */
    final mxRectangle dims = parentGraph.getBoundingBoxFromGeometry(selection);
    final double minX = dims.getX();
    final double maxX = minX + dims.getWidth();
    final double minY = dims.getY();
    final double maxY = minY + dims.getHeight();
    mxGeometry geom = superBlock.getGeometry();
    geom.setX((maxX + minX - geom.getWidth()) / 2.0);
    geom.setY((maxY + minY - geom.getHeight()) / 2.0);
    superBlock.setGeometry(geom);
    /*
         * get statistics to flip and rotate
         */
    VectorOfDouble mvcAngle = new VectorOfDouble();
    int angleCounter = 0;
    int flipCounter = 0;
    int mirrorCounter = 0;
    for (Object object : selection) {
        if (object instanceof BasicBlock) {
            final BasicBlock b = (BasicBlock) object;
            String[] style = new String[1];
            controller.getObjectProperty(b.getUID(), Kind.BLOCK, ObjectProperties.STYLE, style);
            StyleMap styleMap = new StyleMap(style[0]);
            final boolean mirrored = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_MIRROR));
            final boolean flipped = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_FLIP));
            final double doubleRotation = Double.valueOf(styleMap.getOrDefault(XcosConstants.STYLE_ROTATION, "0"));
            angleCounter += doubleRotation;
            if (flipped) {
                flipCounter++;
            }
            if (mirrored) {
                mirrorCounter++;
            }
        }
    }
    /*
         * apply statistics to flip and rotate
         */
    final int halfSize = selection.length / 2;
    String[] style = new String[1];
    controller.getObjectProperty(superBlock.getUID(), superBlock.getKind(), ObjectProperties.STYLE, style);
    StyleMap styleMap = new StyleMap(style[0]);
    styleMap.put(XcosConstants.STYLE_ROTATION, Double.toString(BlockPositioning.roundAngle(angleCounter / selection.length)));
    if (flipCounter > halfSize) {
        styleMap.put(XcosConstants.STYLE_FLIP, Boolean.toString(true));
    }
    if (mirrorCounter > halfSize) {
        styleMap.put(XcosConstants.STYLE_MIRROR, Boolean.toString(true));
    }
    controller.setObjectProperty(superBlock.getUID(), superBlock.getKind(), ObjectProperties.STYLE, styleMap.toString());
    return superBlock;
}
#method_after
private SuperBlock allocateSuperBlock(final JavaController controller, final XcosDiagram parentGraph, final Object[] selection) throws ScilabInterpreterManagement.InterpreterException {
    final SuperBlock superBlock = (SuperBlock) XcosCellFactory.createBlock(INTERFUNCTION_NAME);
    /*
         * Remove the default allocated ports
         */
    while (superBlock.getChildCount() > 0) {
        superBlock.remove(superBlock.getChildCount() - 1);
    }
    VectorOfScicosID children = new VectorOfScicosID();
    controller.setObjectProperty(superBlock.getUID(), superBlock.getKind(), ObjectProperties.CHILDREN, children);
    /*
         * Place the super block
         */
    final mxRectangle dims = parentGraph.getBoundingBoxFromGeometry(selection);
    final double minX = dims.getX();
    final double maxX = minX + dims.getWidth();
    final double minY = dims.getY();
    final double maxY = minY + dims.getHeight();
    mxGeometry geom = superBlock.getGeometry();
    geom.setX((maxX + minX - geom.getWidth()) / 2.0);
    geom.setY((maxY + minY - geom.getHeight()) / 2.0);
    superBlock.setGeometry(geom);
    /*
         * get statistics to flip and rotate
         */
    VectorOfDouble mvcAngle = new VectorOfDouble();
    int angleCounter = 0;
    int flipCounter = 0;
    int mirrorCounter = 0;
    for (Object object : selection) {
        if (object instanceof BasicBlock) {
            final BasicBlock b = (BasicBlock) object;
            String[] style = new String[1];
            controller.getObjectProperty(b.getUID(), Kind.BLOCK, ObjectProperties.STYLE, style);
            StyleMap styleMap = new StyleMap(style[0]);
            final boolean mirrored = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_MIRROR));
            final boolean flipped = Boolean.TRUE.toString().equals(styleMap.get(XcosConstants.STYLE_FLIP));
            final int intRotation = Double.valueOf(styleMap.getOrDefault(XcosConstants.STYLE_ROTATION, "0")).intValue();
            angleCounter += intRotation;
            if (flipped) {
                flipCounter++;
            }
            if (mirrored) {
                mirrorCounter++;
            }
        }
    }
    /*
         * apply statistics to flip and rotate
         */
    final int halfSize = selection.length / 2;
    String[] style = new String[1];
    controller.getObjectProperty(superBlock.getUID(), superBlock.getKind(), ObjectProperties.STYLE, style);
    StyleMap styleMap = new StyleMap(style[0]);
    styleMap.put(XcosConstants.STYLE_ROTATION, Integer.toString(BlockPositioning.roundAngle(angleCounter / selection.length)));
    if (flipCounter > halfSize) {
        styleMap.put(XcosConstants.STYLE_FLIP, Boolean.toString(true));
    }
    if (mirrorCounter > halfSize) {
        styleMap.put(XcosConstants.STYLE_MIRROR, Boolean.toString(true));
    }
    controller.setObjectProperty(superBlock.getUID(), superBlock.getKind(), ObjectProperties.STYLE, styleMap.toString());
    return superBlock;
}
#end_block

#method_before
private void installListeners(PaletteBlockView view) {
    view.addMouseListener(new PaletteBlockMouseListener());
    DragSource dragSource = DragSource.getDefaultDragSource();
    dragSource.createDefaultDragGestureRecognizer(this.getView(), DnDConstants.ACTION_COPY, new PaletteDragGestureListener(getModel(), this));
}
#method_after
private void installListeners(PaletteBlockView view) {
    view.addMouseListener(new PaletteBlockMouseListener());
    DragSource dragSource = DragSource.getDefaultDragSource();
    dragSource.createDefaultDragGestureRecognizer(this.getView(), DnDConstants.ACTION_MOVE, new PaletteDragGestureListener(getModel(), this));
}
#end_block

#method_before
public Transferable getTransferable() {
    Transferable transfer = transferable.get();
    if (transfer == null) {
        BasicBlock block;
        try {
            block = XcosCellFactory.createBlock(model.getName());
        } catch (ScilabInterpreterManagement.InterpreterException ex) {
            LOG.finest(String.format(UNABLE_TO_LOAD_BLOCK, model.getName()));
            getView().setEnabled(false);
            throw new InvalidDnDOperationException();
        }
        getView().setEnabled(true);
        /* Render it and export it */
        block.getGeometry().setX(BLOCK_DEFAULT_POSITION);
        block.getGeometry().setY(BLOCK_DEFAULT_POSITION);
        INTERNAL_GRAPH.addCell(block);
        INTERNAL_GRAPH.selectAll();
        BlockPositioning.updateBlockView(INTERNAL_GRAPH, block);
        mxGraphTransferHandler handler = ((mxGraphTransferHandler) INTERNAL_GRAPH.getAsComponent().getTransferHandler());
        Object[] cells = new Object[] { block };
        transfer = new mxGraphTransferable(cells, INTERNAL_GRAPH.getPaintBounds(cells), handler.createTransferableImage(INTERNAL_GRAPH.getAsComponent(), cells));
        transferable = new WeakReference<Transferable>(transfer);
        INTERNAL_GRAPH.removeCells();
    }
    return transfer;
}
#method_after
public Transferable getTransferable() {
    Transferable transfer;
    BasicBlock block;
    try {
        block = XcosCellFactory.createBlock(model.getName());
    } catch (ScilabInterpreterManagement.InterpreterException ex) {
        LOG.finest(String.format(UNABLE_TO_LOAD_BLOCK, model.getName()));
        getView().setEnabled(false);
        throw new InvalidDnDOperationException();
    }
    getView().setEnabled(true);
    /* Render it and export it */
    block.getGeometry().setX(BLOCK_DEFAULT_POSITION);
    block.getGeometry().setY(BLOCK_DEFAULT_POSITION);
    INTERNAL_GRAPH.addCell(block);
    INTERNAL_GRAPH.selectAll();
    BlockPositioning.updateBlockView(INTERNAL_GRAPH, block);
    mxGraphTransferHandler handler = ((mxGraphTransferHandler) INTERNAL_GRAPH.getAsComponent().getTransferHandler());
    Object[] cells = new Object[] { block };
    transfer = new mxGraphTransferable(cells, INTERNAL_GRAPH.getPaintBounds(cells), handler.createTransferableImage(INTERNAL_GRAPH.getAsComponent(), cells));
    INTERNAL_GRAPH.removeCells();
    return transfer;
}
#end_block

#method_before
@Override
public void actionPerformed(ActionEvent e) {
    // load only a limited set of blocks
    if (loadedBlocks <= 0) {
        Timer timer = (Timer) e.getSource();
        timer.stop();
    }
    // Look for a Preloaded palette
    while (stack.size() != 0) {
        TreeNode o = stack.pop();
        if (o instanceof PreLoaded) {
            // found it, create a dummy transferable from the first block
            List<PaletteBlock> blocks = ((PreLoaded) o).getBlock();
            if (!blocks.isEmpty()) {
                loadTransferable(blocks.get(0));
                break;
            }
        } else {
            for (int i = 0; i < o.getChildCount(); i++) {
                stack.push(o.getChildAt(i));
            }
        }
    }
}
#method_after
@Override
public void actionPerformed(ActionEvent e) {
    // load only a limited set of blocks
    if (loadedBlocks <= 0) {
        Timer timer = (Timer) e.getSource();
        timer.stop();
    }
    // consume a block
    if (blocksStack.size() != 0) {
        loadTransferable(blocksStack.pop());
        return;
    }
    // no block is available, look for a Preloaded palette
    while (nodeStack.size() != 0) {
        TreeNode o = nodeStack.pop();
        if (o instanceof PreLoaded) {
            // found it a palette, create a dummy transferable from the first block and store the others for later use.
            blocksStack.addAll(((PreLoaded) o).getBlock());
            if (blocksStack.size() != 0) {
                loadTransferable(blocksStack.pop());
                return;
            }
        } else {
            for (int i = 0; i < o.getChildCount(); i++) {
                nodeStack.push(o.getChildAt(i));
            }
        }
    }
}
#end_block

#method_before
public void performStartUpLayout() {
    JTree tree = (JTree) ((JScrollPane) getLeftComponent()).getViewport().getView();
    /* Tree layout */
    final Object root = tree.getModel().getRoot();
    final Object firstChild = tree.getModel().getChild(root, 0);
    final Object secondChild = tree.getModel().getChild(firstChild, 0);
    tree.setSelectionPath(new TreePath(new Object[] { root, firstChild, secondChild }));
    tree.setRootVisible(false);
    tree.setScrollsOnExpand(true);
    /* Global layout */
    setContinuousLayout(true);
    /* load a first block to pre-load all jars */
    Timer timer = new Timer(LOAD_DUMMY_BLOCK_DELAY, new LoadBlock(controller, NUMBER_OF_DUMMY_BLOCKS));
    timer.start();
}
#method_after
public void performStartUpLayout() {
    JTree tree = (JTree) ((JScrollPane) getLeftComponent()).getViewport().getView();
    /* Tree layout */
    final Object root = tree.getModel().getRoot();
    final Object firstChild = tree.getModel().getChild(root, 0);
    final Object secondChild = tree.getModel().getChild(firstChild, 0);
    tree.setSelectionPath(new TreePath(new Object[] { root, firstChild, secondChild }));
    tree.setRootVisible(false);
    tree.setScrollsOnExpand(true);
    /* Global layout */
    setContinuousLayout(true);
    // Delay-load some blocks to pre-load jars used on the rendering.
    // A timer is used to avoid busying EDT and add a small delay between blocks
    Timer timer = new Timer(LOAD_DUMMY_BLOCK_DELAY, new LoadBlock(controller, NUMBER_OF_DUMMY_BLOCKS));
    timer.start();
}
#end_block

#method_before
public void destroy(XcosDiagram graph) {
    JavaController controller = new JavaController();
    long[] rootDiagram = new long[1];
    controller.getObjectProperty(graph.getUID(), graph.getKind(), ObjectProperties.PARENT_DIAGRAM, rootDiagram);
    if (rootDiagram[0] == 0l) {
        rootDiagram[0] = graph.getUID();
    }
    final boolean wasLastOpenedForFile = openedDiagrams(rootDiagram[0]).size() <= 1;
    if (wasLastOpenedForFile) {
        diagrams.remove(rootDiagram[0]);
    } else {
        diagrams.get(rootDiagram[0]).remove(graph);
    }
    if (openedDiagrams().size() <= 0) {
        /* halt scicos (stop the simulation) */
        InterpreterManagement.requestScilabExec("if isdef('haltscicos'), haltscicos(), end;");
    }
}
#method_after
public void destroy(XcosDiagram graph) {
    JavaController controller = new JavaController();
    long[] rootDiagram = new long[1];
    controller.getObjectProperty(graph.getUID(), graph.getKind(), ObjectProperties.PARENT_DIAGRAM, rootDiagram);
    if (rootDiagram[0] == 0l) {
        rootDiagram[0] = graph.getUID();
    }
    final boolean wasLastOpenedForFile = openedDiagrams(rootDiagram[0]).size() <= 1;
    if (wasLastOpenedForFile) {
        diagrams.remove(rootDiagram[0]);
    } else {
        diagrams.get(rootDiagram[0]).remove(graph);
    }
    if (openedDiagrams().size() <= 0) {
        JavaController.end_simulation();
    }
}
#end_block

#method_before
public static synchronized void closeSession(final boolean ask) {
    if (!SwingUtilities.isEventDispatchThread()) {
        LOG.severe(CALLED_OUTSIDE_THE_EDT_THREAD);
    }
    /* Doesn't instantiate xcos on close operation */
    if (sharedInstance == null) {
        return;
    }
    /*
         * Try to close all opened files
         */
    final Xcos instance = sharedInstance;
    // get all tabs
    final List<SwingScilabDockablePanel> tabs = new ArrayList<SwingScilabDockablePanel>();
    for (final Collection<XcosDiagram> diags : instance.diagrams.values()) {
        for (final XcosDiagram diag : diags) {
            final SwingScilabDockablePanel tab = XcosTab.get(diag);
            if (tab != null) {
                tabs.add(tab);
            }
        }
    }
    // ask to close
    final boolean status = ClosingOperationsManager.startClosingOperation(tabs, ask, ask);
    // clear states
    if (status) {
        /* reset the shared instance state */
        instance.diagrams.keySet().clear();
        /* terminate any remaining simulation */
        InterpreterManagement.putCommandInScilabQueue("if isdef('haltscicos'), haltscicos(), end;");
        /* Saving modified data */
        instance.palette.saveConfig();
        instance.configuration.saveConfig();
    }
}
#method_after
public static synchronized void closeSession(final boolean ask) {
    if (!SwingUtilities.isEventDispatchThread()) {
        LOG.severe(CALLED_OUTSIDE_THE_EDT_THREAD);
    }
    /* Doesn't instantiate xcos on close operation */
    if (sharedInstance == null) {
        return;
    }
    /*
         * Try to close all opened files
         */
    final Xcos instance = sharedInstance;
    // get all tabs
    final List<SwingScilabDockablePanel> tabs = new ArrayList<SwingScilabDockablePanel>();
    for (final Collection<XcosDiagram> diags : instance.diagrams.values()) {
        for (final XcosDiagram diag : diags) {
            final SwingScilabDockablePanel tab = XcosTab.get(diag);
            if (tab != null) {
                tabs.add(tab);
            }
        }
    }
    // ask to close
    final boolean status = ClosingOperationsManager.startClosingOperation(tabs, ask, ask);
    // clear states
    if (status) {
        /* reset the shared instance state */
        instance.diagrams.keySet().clear();
        /* terminate any remaining simulation */
        JavaController.end_simulation();
        /* Saving modified data */
        instance.palette.saveConfig();
        instance.configuration.saveConfig();
    }
}
#end_block

#method_before
public void updateLabel(BasicBlock source) {
    /**
     * Get the input port children
     */
    final List<InputPort> ports = new ArrayList<InputPort>();
    for (int i = 0; i < source.getChildCount(); i++) {
        final mxICell port = source.getChildAt(i);
        if (port instanceof InputPort) {
            ports.add((InputPort) port);
        }
    }
    /**
     * Set the ports labels
     */
    JavaController controller = new JavaController();
    VectorOfDouble rpar = new VectorOfDouble();
    controller.getObjectProperty(source.getUID(), Kind.BLOCK, ObjectProperties.RPAR, rpar);
    for (int i = 0; i < ports.size(); i++) {
        final double gain;
        System.err.println(String.format("%d %d", rpar.size(), i));
        if (i < rpar.size()) {
            gain = rpar.get(i);
        } else {
            gain = 1;
        }
        ports.get(i).setValue(getLabel(gain));
    }
    /**
     * Check if all the values are equal to the default one.
     */
    if (!hasDefaultValue(ports)) {
        return;
    }
    /**
     * When all values are equal to the default one, set it to the block
     * and hide the children.
     */
    source.setValue(NOT_PRINTED_LABEL);
    for (InputPort port : ports) {
        port.setValue("");
    }
}
#method_after
public void updateLabel(BasicBlock source) {
    /**
     * Get the input port children
     */
    final List<InputPort> ports = new ArrayList<InputPort>();
    for (int i = 0; i < source.getChildCount(); i++) {
        final mxICell port = source.getChildAt(i);
        if (port instanceof InputPort) {
            ports.add((InputPort) port);
        }
    }
    /**
     * Set the ports labels
     */
    JavaController controller = new JavaController();
    VectorOfDouble rpar = new VectorOfDouble();
    controller.getObjectProperty(source.getUID(), Kind.BLOCK, ObjectProperties.RPAR, rpar);
    for (int i = 0; i < ports.size(); i++) {
        final double gain;
        if (i < rpar.size()) {
            gain = rpar.get(i);
        } else {
            gain = 1;
        }
        ports.get(i).setValue(getLabel(gain));
    }
    /**
     * Check if all the values are equal to the default one.
     */
    if (!hasDefaultValue(ports)) {
        return;
    }
    /**
     * When all values are equal to the default one, set it to the block
     * and hide the children.
     */
    source.setValue(NOT_PRINTED_LABEL);
    for (InputPort port : ports) {
        port.setValue("");
    }
}
#end_block

#method_before
public static void changeSplitBlocksPosition(XcosDiagram graph, Object[] cells) {
    Object[] all = graph.getChildCells(graph.getDefaultParent());
    for (Object o : cells) {
        if (o instanceof SplitBlock) {
            SplitBlock cell = (SplitBlock) o;
            changeSplitBlockPosition(cell, all, graph);
        }
    }
}
#method_after
public static void changeSplitBlocksPosition(XcosDiagram graph, Object[] cells) {
    Object[] all = graph.getChildCells(graph.getDefaultParent());
    Object[] selectedCells = selectRootSplitBlock(graph, cells);
    for (Object o : selectedCells) {
        if (o instanceof SplitBlock) {
            SplitBlock cell = (SplitBlock) o;
            if (getSplitBlockNumber(cell) == 1) {
                changeSplitBlockPosition(cell, all, graph);
            } else {
                changeSplitBlockPositionMulti(cell, all, graph);
            }
        }
    }
}
#end_block

#method_before
protected static void changeSplitBlockPosition(SplitBlock splitblock, Object[] all, XcosDiagram graph) {
    BasicPort out1 = splitblock.getOut1();
    BasicPort out2 = splitblock.getOut2();
    mxICell sourceCell = getSplitSource(splitblock);
    mxICell targetCell1 = getSplitTarget(splitblock, out1);
    mxICell targetCell2 = getSplitTarget(splitblock, out2);
    List<mxPoint> list1 = getRoute(sourceCell, targetCell1, all, graph);
    List<mxPoint> list2 = getRoute(sourceCell, targetCell2, all, graph);
    mxPoint point = getSplitPoint(list1, list2);
    mxGeometry splitGeo = (mxGeometry) graph.getModel().getGeometry(splitblock).clone();
    splitGeo.setX(point.getX() - splitGeo.getWidth() / 2);
    splitGeo.setY(point.getY() - splitGeo.getHeight() / 2);
    graph.getModel().setGeometry(splitblock, splitGeo);
    updateSplitLink(splitblock, all, graph);
}
#method_after
protected static void changeSplitBlockPosition(SplitBlock splitblock, Object[] all, XcosDiagram graph) {
    mxICell sourcePort = getSplitInLinkPort(splitblock);
    mxICell targetPort1 = getSplitLinkPort(splitblock, splitblock.getOut1());
    mxICell targetPort2 = getSplitLinkPort(splitblock, splitblock.getOut2());
    // get the optimal routes for 2 target ports.
    Object[] allObstacles = getObstacles(splitblock, all);
    List<mxPoint> list1 = getRoute(splitblock, sourcePort, targetPort1, allObstacles, graph);
    List<mxPoint> list2 = getRoute(splitblock, sourcePort, targetPort2, allObstacles, graph);
    // adjust the routes.
    List<mxICell> listPorts = new ArrayList<>(0);
    listPorts.add(sourcePort);
    listPorts.add(targetPort1);
    listPorts.add(targetPort2);
    adjustRoutes(list1, list2, allObstacles, listPorts);
    // get the position according to the routes.
    mxPoint point = getSplitPoint(list1, list2);
    if (point == null) {
        // keep it in the original position.
        return;
    }
    updatePortOrientation(splitblock, list1, list2, point);
    // update split block's position and update the corresponding link.
    mxGeometry splitGeo = (mxGeometry) graph.getModel().getGeometry(splitblock).clone();
    splitGeo.setX(point.getX() - splitGeo.getWidth() / 2);
    splitGeo.setY(point.getY() - splitGeo.getHeight() / 2);
    graph.getModel().setGeometry(splitblock, splitGeo);
    updateSplitLink(splitblock, allObstacles, graph);
}
#end_block

#method_before
private static List<mxPoint> getRoute(mxICell source, mxICell target, Object[] all, XcosDiagram graph) {
    XcosRoute util = new XcosRoute();
    Object[] allOtherCells = util.getAllOtherCells(all, source, target, source.getEdgeAt(0), target.getEdgeAt(0));
    List<mxPoint> list = new ArrayList<mxPoint>(0);
    if (source != null) {
        list.add(getPortPosition(source));
    }
    boolean flag = util.computeRoute(source, target, allOtherCells, graph);
    if (flag) {
        list.addAll(util.getNonRedundantPoints());
    }
    if (target != null) {
        list.add(getPortPosition(target));
    }
    return list;
}
#method_after
private static List<mxPoint> getRoute(SplitBlock splitblock, mxICell source, mxICell target, Object[] all, XcosDiagram graph) {
    XcosRoute util = new XcosRoute();
    // get all obstacles, excluding splitblock itself or its relative link.
    mxICell link1 = splitblock.getIn().getEdgeAt(0);
    mxICell link2 = splitblock.getOut1().getEdgeAt(0);
    mxICell link3 = splitblock.getOut2().getEdgeAt(0);
    Object[] allOtherCells = util.getAllOtherCells(all, source, target, source.getEdgeAt(0), target.getEdgeAt(0), link1, link2, link3);
    // get the route and add all points in the route including source and target.
    List<mxPoint> list = new ArrayList<mxPoint>(0);
    if (source != null) {
        list.add(getPortPosition(source));
    }
    if (util.computeRoute(source, target, allOtherCells, graph)) {
        for (mxPoint point : util.getNonRedundantPoints()) {
            list.add(new mxPoint(Math.round(point.getX()), Math.round(point.getY())));
        }
    }
    if (target != null) {
        list.add(getPortPosition(target));
    }
    return list;
}
#end_block

#method_before
private static mxPoint getPortPosition(mxICell port) {
    mxPoint point = new mxPoint();
    if (port == null) {
        return null;
    }
    if (port.getParent() instanceof SplitBlock) {
        SplitBlock cell = (SplitBlock) port.getParent();
        point.setX(cell.getGeometry().getCenterX());
        point.setY(cell.getGeometry().getCenterY());
    } else {
        mxGeometry portGeo = port.getGeometry();
        double portX = portGeo.getX();
        double portY = portGeo.getY();
        double portW = portGeo.getWidth();
        double portH = portGeo.getHeight();
        mxICell parent = port.getParent();
        mxGeometry parentGeo = parent.getGeometry();
        double blockX = parentGeo.getX();
        double blockY = parentGeo.getY();
        double blockW = parentGeo.getWidth();
        double blockH = parentGeo.getHeight();
        if (portGeo.isRelative()) {
            portX *= blockW;
            portY *= blockH;
        }
        point.setX(blockX + portX + portW / 2);
        point.setY(blockY + portY + portH / 2);
    }
    return point;
}
#method_after
private static mxPoint getPortPosition(mxICell port) {
    mxPoint point = new mxPoint();
    if (port == null) {
        return null;
    }
    if (port.getParent() instanceof SplitBlock) {
        // if the port belongs to a split block, position is the center of the split block,
        SplitBlock cell = (SplitBlock) port.getParent();
        point.setX(cell.getGeometry().getCenterX());
        point.setY(cell.getGeometry().getCenterY());
    } else {
        // if the port belongs to a normal block, the position is relative to its parent.
        mxGeometry portGeo = port.getGeometry();
        double portX = portGeo.getX();
        double portY = portGeo.getY();
        double portW = portGeo.getWidth();
        double portH = portGeo.getHeight();
        mxICell parent = port.getParent();
        mxGeometry parentGeo = parent.getGeometry();
        if (portGeo.isRelative()) {
            portX *= parentGeo.getWidth();
            portY *= parentGeo.getHeight();
        }
        point.setX(parentGeo.getX() + portX + portW / 2);
        point.setY(parentGeo.getY() + portY + portH / 2);
    }
    // update the point.
    point.setX(Math.round(point.getX()));
    point.setY(Math.round(point.getY()));
    return point;
}
#end_block

#method_before
private static mxPoint getSplitPoint(List<mxPoint> list1, List<mxPoint> list2) {
    mxPoint point = null;
    int num = Math.min(list1.size(), list2.size());
    if (num <= 1 || !list1.get(0).equals(list2.get(0))) {
        return null;
    }
    for (int i = 1; i < num; i++) {
        mxPoint p0 = list1.get(i - 1);
        mxPoint p1 = list1.get(i);
        mxPoint p2 = list2.get(i);
        if (p1.equals(p2)) {
            continue;
        }
        double x0 = p0.getX();
        double y0 = p0.getY();
        double x1 = p1.getX();
        double y1 = p1.getY();
        double x2 = p2.getX();
        double y2 = p2.getY();
        if (XcosRouteUtils.pointInLineSegment(x1, y1, x0, y0, x2, y2)) {
            // p1 in the line segment (p0,p2)
            point = (mxPoint) p1.clone();
            break;
        } else if (XcosRouteUtils.pointInLineSegment(x2, y2, x0, y0, x1, y1)) {
            // p2 in the line segment (p0,p1)
            point = (mxPoint) p2.clone();
            break;
        } else {
            point = (mxPoint) p0.clone();
            break;
        }
    }
    return point;
}
#method_after
private static mxPoint getSplitPoint(List<mxPoint> list1, List<mxPoint> list2) {
    mxPoint point = null;
    int num = Math.min(list1.size(), list2.size());
    if (num <= 1 || !list1.get(0).equals(list2.get(0))) {
        return null;
    }
    // check the last intersection of two links
    int iList1 = 1;
    int iList2 = 1;
    for (int i = iList1; i < list1.size(); i++) {
        for (int j = iList2; j < list2.size(); j++) {
            mxPoint p1 = list1.get(i - 1);
            mxPoint p2 = list1.get(i);
            mxPoint p3 = list2.get(j - 1);
            mxPoint p4 = list2.get(j);
            mxPoint p0 = XcosRouteUtils.getIntersection(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY(), p4.getX(), p4.getY());
            if (p0 != null) {
                iList1 = i;
                iList2 = j;
                point = (mxPoint) p0.clone();
            }
        }
    }
    return point;
}
#end_block

#method_before
private static mxPoint getSplitPoint(List<mxPoint> list1, List<mxPoint> list2) {
    mxPoint point = null;
    int num = Math.min(list1.size(), list2.size());
    if (num <= 1 || !list1.get(0).equals(list2.get(0))) {
        return null;
    }
    for (int i = 1; i < num; i++) {
        mxPoint p0 = list1.get(i - 1);
        mxPoint p1 = list1.get(i);
        mxPoint p2 = list2.get(i);
        if (p1.equals(p2)) {
            continue;
        }
        double x0 = p0.getX();
        double y0 = p0.getY();
        double x1 = p1.getX();
        double y1 = p1.getY();
        double x2 = p2.getX();
        double y2 = p2.getY();
        if (XcosRouteUtils.pointInLineSegment(x1, y1, x0, y0, x2, y2)) {
            // p1 in the line segment (p0,p2)
            point = (mxPoint) p1.clone();
            break;
        } else if (XcosRouteUtils.pointInLineSegment(x2, y2, x0, y0, x1, y1)) {
            // p2 in the line segment (p0,p1)
            point = (mxPoint) p2.clone();
            break;
        } else {
            point = (mxPoint) p0.clone();
            break;
        }
    }
    return point;
}
#method_after
private static mxPoint getSplitPoint(List<List<mxPoint>> listRoutes) {
    List<mxPoint> listAllSplitPoints = new ArrayList<>(0);
    // get all intersections of every 2 routes.
    for (int i = 0; i < listRoutes.size() - 1; i++) {
        List<mxPoint> list1 = listRoutes.get(i);
        for (int j = i + 1; j < listRoutes.size(); j++) {
            List<mxPoint> list2 = listRoutes.get(j);
            mxPoint point = getSplitPoint(list1, list2);
            if (point == null || listAllSplitPoints.contains(point)) {
                continue;
            }
            listAllSplitPoints.add(point);
        }
    }
    // choose the one point which every route will go through.
    mxPoint splitPoint = null;
    for (mxPoint point : listAllSplitPoints) {
        double x = point.getX();
        double y = point.getY();
        for (int i = 0; i < listRoutes.size(); i++) {
            if (!XcosRouteUtils.pointInLink(x, y, listRoutes.get(i))) {
                // if there is one route doesn't go through the point
                break;
            }
            if (i == listRoutes.size() - 1) {
                splitPoint = new mxPoint();
                splitPoint.setX(x);
                splitPoint.setY(y);
            }
        }
    }
    return splitPoint;
}
#end_block

#method_before
private static void updateSplitLink(SplitBlock split, Object[] all, XcosDiagram graph) {
    XcosRoute route = new XcosRoute();
    BasicLink link = (BasicLink) split.getIn().getEdgeAt(0);
    reset(graph, link);
    route.updateRoute(link, all, graph);
    link = (BasicLink) split.getOut1().getEdgeAt(0);
    reset(graph, link);
    route.updateRoute(link, all, graph);
    link = (BasicLink) split.getOut2().getEdgeAt(0);
    reset(graph, link);
    route.updateRoute(link, all, graph);
}
#method_after
private static void updateSplitLink(SplitBlock splitblock, Object[] all, XcosDiagram graph) {
    XcosRoute route = new XcosRoute();
    BasicLink linkIn = (BasicLink) splitblock.getIn().getEdgeAt(0);
    BasicLink linkOut1 = (BasicLink) splitblock.getOut1().getEdgeAt(0);
    BasicLink linkOut2 = (BasicLink) splitblock.getOut2().getEdgeAt(0);
    boolean lockPort = true;
    reset(graph, linkIn);
    reset(graph, linkOut1);
    reset(graph, linkOut2);
    graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE, "1", new BasicLink[] { linkIn, linkOut1, linkOut2 });
    route.updateRoute(linkIn, all, graph, lockPort);
    route.updateRoute(linkOut1, all, graph, lockPort);
    route.updateRoute(linkOut2, all, graph, lockPort);
}
#end_block

#method_before
// CSON: JavaNCSS
/**
 * @param graph
 *            parent graph
 * @return context menu
 */
public ContextMenu createContextMenu(ScilabGraph graph) {
    ContextMenu menu = ScilabContextMenu.createContextMenu();
    Map<Class<? extends DefaultAction>, Menu> menuList = new HashMap<>();
    MenuItem value = BlockParametersAction.createMenu(graph);
    menuList.put(BlockParametersAction.class, value);
    menu.add(value);
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    value = CutAction.cutMenu(graph);
    menuList.put(CutAction.class, value);
    menu.add(value);
    value = CopyAction.copyMenu(graph);
    menuList.put(CopyAction.class, value);
    menu.add(value);
    value = DeleteAction.createMenu(graph);
    menuList.put(DeleteAction.class, value);
    menu.add(value);
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    value = RegionToSuperblockAction.createMenu(graph);
    menuList.put(RegionToSuperblockAction.class, value);
    menu.add(value);
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    Menu format = ScilabMenu.createMenu();
    format.setText(XcosMessages.FORMAT);
    menu.add(format);
    value = RotateAction.createMenu(graph);
    menuList.put(RotateAction.class, value);
    format.add(value);
    value = MirrorAction.createMenu(graph);
    menuList.put(MirrorAction.class, value);
    format.add(value);
    value = FlipAction.createMenu(graph);
    menuList.put(FlipAction.class, value);
    format.add(value);
    value = ShowHideShadowAction.createMenu(graph);
    menuList.put(ShowHideShadowAction.class, value);
    format.add(value);
    /*--- */
    format.addSeparator();
    /*--- */
    Menu alignMenu = ScilabMenu.createMenu();
    alignMenu.setText(XcosMessages.ALIGN_BLOCKS);
    alignMenu.add(AlignBlockActionLeft.createMenu(graph));
    alignMenu.add(AlignBlockActionCenter.createMenu(graph));
    alignMenu.add(AlignBlockActionRight.createMenu(graph));
    alignMenu.addSeparator();
    alignMenu.add(AlignBlockActionTop.createMenu(graph));
    alignMenu.add(AlignBlockActionMiddle.createMenu(graph));
    alignMenu.add(AlignBlockActionBottom.createMenu(graph));
    menuList.put(AlignBlockAction.class, alignMenu);
    format.add(alignMenu);
    /*--- */
    format.addSeparator();
    /*--- */
    Menu autoPositionMenu = ScilabMenu.createMenu();
    autoPositionMenu.setText(XcosMessages.BLOCK_AUTO_POSITION);
    MenuItem sbapMenuItem = AutoPositionSplitBlockAction.createMenu(graph);
    sbapMenuItem.setEnabled(false);
    autoPositionMenu.add(sbapMenuItem);
    menuList.put(AutoPositionSplitBlockAction.class, sbapMenuItem);
    format.add(autoPositionMenu);
    /*--- */
    format.addSeparator();
    /*--- */
    if (graph.getSelectionCells().length > 1) {
        format.add(BorderColorAction.createMenu(graph));
        format.add(FilledColorAction.createMenu(graph));
    } else {
        format.add(EditFormatAction.createMenu(graph));
    }
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    menu.add(ViewDetailsAction.createMenu(graph));
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    menu.add(BlockDocumentationAction.createMenu(graph));
    ((SwingScilabContextMenu) menu.getAsSimpleContextMenu()).setLocation(MouseInfo.getPointerInfo().getLocation().x, MouseInfo.getPointerInfo().getLocation().y);
    customizeMenu(menuList);
    return menu;
}
#method_after
// CSON: JavaNCSS
/**
 * @param graph
 *            parent graph
 * @return context menu
 */
public ContextMenu createContextMenu(ScilabGraph graph) {
    ContextMenu menu = ScilabContextMenu.createContextMenu();
    Map<Class<? extends DefaultAction>, Menu> menuList = new HashMap<>();
    MenuItem value = BlockParametersAction.createMenu(graph);
    menuList.put(BlockParametersAction.class, value);
    menu.add(value);
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    value = CutAction.cutMenu(graph);
    menuList.put(CutAction.class, value);
    menu.add(value);
    value = CopyAction.copyMenu(graph);
    menuList.put(CopyAction.class, value);
    menu.add(value);
    value = DeleteAction.createMenu(graph);
    menuList.put(DeleteAction.class, value);
    menu.add(value);
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    value = RegionToSuperblockAction.createMenu(graph);
    menuList.put(RegionToSuperblockAction.class, value);
    menu.add(value);
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    Menu format = ScilabMenu.createMenu();
    format.setText(XcosMessages.FORMAT);
    menu.add(format);
    value = RotateAction.createMenu(graph);
    menuList.put(RotateAction.class, value);
    format.add(value);
    value = MirrorAction.createMenu(graph);
    menuList.put(MirrorAction.class, value);
    format.add(value);
    value = FlipAction.createMenu(graph);
    menuList.put(FlipAction.class, value);
    format.add(value);
    value = ShowHideShadowAction.createMenu(graph);
    menuList.put(ShowHideShadowAction.class, value);
    format.add(value);
    /*--- */
    format.addSeparator();
    /*--- */
    Menu alignMenu = ScilabMenu.createMenu();
    alignMenu.setText(XcosMessages.ALIGN_BLOCKS);
    alignMenu.add(AlignBlockActionLeft.createMenu(graph));
    alignMenu.add(AlignBlockActionCenter.createMenu(graph));
    alignMenu.add(AlignBlockActionRight.createMenu(graph));
    alignMenu.addSeparator();
    alignMenu.add(AlignBlockActionTop.createMenu(graph));
    alignMenu.add(AlignBlockActionMiddle.createMenu(graph));
    alignMenu.add(AlignBlockActionBottom.createMenu(graph));
    menuList.put(AlignBlockAction.class, alignMenu);
    format.add(alignMenu);
    /*--- */
    format.addSeparator();
    /*--- */
    MenuItem sbapMenuItem = AutoPositionSplitBlockAction.createMenu(graph);
    sbapMenuItem.setText(XcosMessages.BLOCK_AUTO_POSITION_SPLIT_BLOCK_CONTEXTUAL);
    sbapMenuItem.setEnabled(false);
    menuList.put(AutoPositionSplitBlockAction.class, sbapMenuItem);
    format.add(sbapMenuItem);
    /*--- */
    format.addSeparator();
    /*--- */
    if (graph.getSelectionCells().length > 1) {
        format.add(BorderColorAction.createMenu(graph));
        format.add(FilledColorAction.createMenu(graph));
    } else {
        format.add(EditFormatAction.createMenu(graph));
    }
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    menu.add(ViewDetailsAction.createMenu(graph));
    /*--- */
    menu.getAsSimpleContextMenu().addSeparator();
    /*--- */
    menu.add(BlockDocumentationAction.createMenu(graph));
    ((SwingScilabContextMenu) menu.getAsSimpleContextMenu()).setLocation(MouseInfo.getPointerInfo().getLocation().x, MouseInfo.getPointerInfo().getLocation().y);
    customizeMenu(menuList);
    return menu;
}
#end_block

#method_before
public static void restore(final XcosDiagram graph, final boolean visible) {
    String uuid = graph.getGraphTab();
    if (uuid == null) {
        uuid = UUID.randomUUID().toString();
    }
    // FIXME: fix a crash on DnD and Tab restore
    final XcosTab tab = new XcosTab(graph, uuid);
    ScilabTabFactory.getInstance().addToCache(tab);
    graph.setOpened(true);
    if (visible) {
        tab.createDefaultWindow().setVisible(true);
        graph.updateTabTitle();
        BarUpdater.updateBars(tab.getParentWindowId(), tab.getMenuBar(), tab.getToolBar(), tab.getInfoBar(), tab.getName(), tab.getWindowIcon());
    }
    ClosingOperationsManager.addDependencyWithRoot((SwingScilabDockablePanel) tab);
    ClosingOperationsManager.registerClosingOperation((SwingScilabDockablePanel) tab, new ClosingOperation(graph));
    WindowsConfigurationManager.registerEndedRestoration((SwingScilabDockablePanel) tab, new EndedRestoration(graph));
}
#method_after
public static void restore(final XcosDiagram graph, final boolean visible) {
    String uuid = graph.getGraphTab();
    if (uuid == null) {
        uuid = UUID.randomUUID().toString();
    }
    // FIXME: fix a crash on DnD and Tab restore
    final XcosTab tab = new XcosTab(graph, uuid);
    ScilabTabFactory.getInstance().addToCache(tab);
    graph.setOpened(true);
    if (visible) {
        tab.createDefaultWindow().setVisible(true);
        graph.updateTabTitle();
        BarUpdater.updateBars(tab.getParentWindowId(), tab.getMenuBar(), tab.getToolBar(), tab.getInfoBar(), tab.getName(), tab.getWindowIcon());
    }
    ClosingOperationsManager.addDependencyWithRoot(tab);
    ClosingOperationsManager.registerClosingOperation(tab, new ClosingOperation(graph));
    WindowsConfigurationManager.registerEndedRestoration(tab, new EndedRestoration(graph));
}
#end_block

#method_before
public void updateRoute(BasicLink link, Object[] allCells, XcosDiagram graph) {
    mxICell sourceCell = link.getSource();
    mxICell targetCell = link.getTarget();
    Object[] allOtherCells = getAllOtherCells(allCells, link, sourceCell, targetCell);
    if (sourceCell != null && targetCell != null) {
        boolean isGetRoute = this.computeRoute(sourceCell, targetCell, allOtherCells, graph);
        if (isGetRoute) {
            List<mxPoint> list = this.getNonRedundantPoints();
            mxGeometry geometry = new mxGeometry();
            geometry.setPoints(list);
            ((mxGraphModel) (graph.getModel())).setGeometry(link, geometry);
            listRoute.clear();
        } else {
        // if it cannot get the route, keep the same or change it to
        // straight or give a pop windows to inform user.
        }
    }
}
#method_after
public void updateRoute(BasicLink link, Object[] allCells, XcosDiagram graph) {
    this.lockPortPosition = false;
    this.updateRoute(link, allCells, graph, lockPortPosition);
}
#end_block

#method_before
public void updateRoute(BasicLink link, Object[] allCells, XcosDiagram graph) {
    mxICell sourceCell = link.getSource();
    mxICell targetCell = link.getTarget();
    Object[] allOtherCells = getAllOtherCells(allCells, link, sourceCell, targetCell);
    if (sourceCell != null && targetCell != null) {
        boolean isGetRoute = this.computeRoute(sourceCell, targetCell, allOtherCells, graph);
        if (isGetRoute) {
            List<mxPoint> list = this.getNonRedundantPoints();
            mxGeometry geometry = new mxGeometry();
            geometry.setPoints(list);
            ((mxGraphModel) (graph.getModel())).setGeometry(link, geometry);
            listRoute.clear();
        } else {
        // if it cannot get the route, keep the same or change it to
        // straight or give a pop windows to inform user.
        }
    }
}
#method_after
public void updateRoute(BasicLink link, Object[] allCells, XcosDiagram graph, boolean lockPort) {
    this.lockPortPosition = lockPort;
    mxICell sourceCell = link.getSource();
    mxICell targetCell = link.getTarget();
    Object[] allOtherCells = getAllOtherCells(allCells, link, sourceCell, targetCell);
    if (sourceCell != null && targetCell != null) {
        boolean isGetRoute = this.computeRoute(sourceCell, targetCell, allOtherCells, graph);
        if (isGetRoute) {
            List<mxPoint> list = this.getNonRedundantPoints();
            mxGeometry geometry = new mxGeometry();
            geometry.setPoints(list);
            ((mxGraphModel) (graph.getModel())).setGeometry(link, geometry);
            listRoute.clear();
        } else if (!lockPort) {
        // if it cannot get the route, change it to straight.
        }
    }
}
#end_block

#method_before
protected boolean computeRoute(mxICell sourceCell, mxICell targetCell, Object[] allCells, XcosDiagram graph) {
    listRoute.clear();
    // if the link is not connected with BasicPort.
    if (!(sourceCell instanceof BasicPort) || !(targetCell instanceof BasicPort)) {
        return false;
    }
    Orientation sourcePortOrien = null;
    Orientation targetPortOrien = null;
    double srcx = 0;
    double srcy = 0;
    double tgtx = 0;
    double tgty = 0;
    mxPoint sourcePoint = new mxPoint(srcx, srcy);
    mxPoint targetPoint = new mxPoint(tgtx, tgty);
    // if source is a port, get a new start point.
    if (sourceCell instanceof BasicPort) {
        mxCellState state = graph.getView().getState(sourceCell);
        if (state != null) {
            srcx = state.getCenterX();
            srcy = state.getCenterY();
            BasicPort sourcePort = (BasicPort) sourceCell;
            sourcePortOrien = getPortRelativeOrientation(sourcePort, graph);
        }
    }
    // if target is a port, get a new end point.
    if (targetCell instanceof BasicPort) {
        mxCellState state = graph.getView().getState(targetCell);
        if (state != null) {
            tgtx = state.getCenterX();
            tgty = state.getCenterY();
            BasicPort targetPort = (BasicPort) targetCell;
            targetPortOrien = getPortRelativeOrientation(targetPort, graph);
        }
    }
    // if source belongs to a SplitBlock
    if (sourceCell.getParent() instanceof SplitBlock) {
        srcx = sourceCell.getParent().getGeometry().getCenterX();
        srcy = sourceCell.getParent().getGeometry().getCenterY();
    }
    // if target is a SplitBlock
    if (targetCell.getParent() instanceof SplitBlock) {
        tgtx = targetCell.getParent().getGeometry().getCenterX();
        tgty = targetCell.getParent().getGeometry().getCenterY();
    }
    // use straight route.
    if ((XcosRouteUtils.isStrictlyAligned(srcx, srcy, tgtx, tgty)) && !XcosRouteUtils.checkObstacle(srcx, srcy, tgtx, tgty, allCells)) {
        return true;
    }
    // re-calculate the orientation for the SplitBlock.
    if (sourceCell.getParent() instanceof SplitBlock) {
        sourcePortOrien = this.getNewOrientation(sourceCell, srcx, srcy, targetCell, tgtx, tgty, graph);
    }
    if (targetCell.getParent() instanceof SplitBlock) {
        targetPortOrien = this.getNewOrientation(targetCell, tgtx, tgty, sourceCell, srcx, srcy, graph);
    }
    sourcePoint = getPointAwayPort(sourceCell, srcx, srcy, sourcePortOrien, allCells, graph);
    targetPoint = getPointAwayPort(targetCell, tgtx, tgty, targetPortOrien, allCells, graph);
    List<mxPoint> list = XcosRouteUtils.getSimpleRoute(sourcePoint, sourcePortOrien, targetPoint, targetPortOrien, allCells);
    if (list != null && list.size() > 0) {
        listRoute.addAll(list);
        return true;
    } else {
        list = XcosRouteUtils.getComplexRoute(sourcePoint, sourcePortOrien, targetPoint, targetPortOrien, allCells, XcosRouteUtils.TRY_TIMES);
        if (list != null && list.size() > 0) {
            listRoute.addAll(list);
            return true;
        }
    }
    return false;
}
#method_after
protected boolean computeRoute(mxICell sourceCell, mxICell targetCell, Object[] allCells, XcosDiagram graph) {
    listRoute.clear();
    // if the link is not connected with BasicPort.
    if (!(sourceCell instanceof BasicPort) || !(targetCell instanceof BasicPort)) {
        return false;
    }
    Orientation sourcePortOrien = null;
    Orientation targetPortOrien = null;
    double srcx = 0;
    double srcy = 0;
    double tgtx = 0;
    double tgty = 0;
    mxPoint sourcePoint = new mxPoint(srcx, srcy);
    mxPoint targetPoint = new mxPoint(tgtx, tgty);
    // if source is a port, get a new start point.
    if (sourceCell instanceof BasicPort) {
        mxCellState state = graph.getView().getState(sourceCell);
        if (state != null) {
            srcx = state.getCenterX();
            srcy = state.getCenterY();
            BasicPort sourcePort = (BasicPort) sourceCell;
            sourcePortOrien = getPortRelativeOrientation(sourcePort, graph);
        }
    }
    // if target is a port, get a new end point.
    if (targetCell instanceof BasicPort) {
        mxCellState state = graph.getView().getState(targetCell);
        if (state != null) {
            tgtx = state.getCenterX();
            tgty = state.getCenterY();
            BasicPort targetPort = (BasicPort) targetCell;
            targetPortOrien = getPortRelativeOrientation(targetPort, graph);
        }
    }
    // if source belongs to a SplitBlock
    if (sourceCell.getParent() instanceof SplitBlock) {
        srcx = sourceCell.getParent().getGeometry().getCenterX();
        srcy = sourceCell.getParent().getGeometry().getCenterY();
    }
    // if target is a SplitBlock
    if (targetCell.getParent() instanceof SplitBlock) {
        tgtx = targetCell.getParent().getGeometry().getCenterX();
        tgty = targetCell.getParent().getGeometry().getCenterY();
    }
    // if two points are coincident, use straignt route.
    boolean isSplitBlock = (sourceCell.getParent() instanceof SplitBlock) && (targetCell.getParent() instanceof SplitBlock);
    if (XcosRouteUtils.isPointCoincident(srcx, srcy, tgtx, tgty, isSplitBlock)) {
        return true;
    }
    // if two ports are aligned and there are no blocks between them, use straight route.
    if (XcosRouteUtils.isStrictlyAligned(srcx, srcy, tgtx, tgty) && !XcosRouteUtils.checkObstacle(srcx, srcy, tgtx, tgty, allCells) && !XcosRouteUtils.isOrientationParallel(srcx, srcy, tgtx, tgty, sourcePortOrien, targetPortOrien)) {
        return true;
    }
    // re-calculate the orientation for the SplitBlock.
    if (sourceCell.getParent() instanceof SplitBlock) {
        if (lockPortPosition) {
            // if it is locked, use the default orientation.
            sourcePortOrien = ((BasicPort) sourceCell).getOrientation();
        } else {
            sourcePortOrien = this.getNewOrientation(sourceCell, srcx, srcy, targetCell, tgtx, tgty, graph);
        }
    }
    if (targetCell.getParent() instanceof SplitBlock) {
        if (lockPortPosition) {
            // if it is locked, use the default orientation.
            targetPortOrien = ((BasicPort) targetCell).getOrientation();
        } else {
            targetPortOrien = this.getNewOrientation(targetCell, tgtx, tgty, sourceCell, srcx, srcy, graph);
        }
    }
    sourcePoint = getPointAwayPort(sourceCell, srcx, srcy, sourcePortOrien, allCells, graph);
    targetPoint = getPointAwayPort(targetCell, tgtx, tgty, targetPortOrien, allCells, graph);
    allCells = Arrays.copyOf(allCells, allCells.length + 2);
    allCells[allCells.length - 2] = sourceCell;
    allCells[allCells.length - 1] = targetCell;
    List<mxPoint> list = XcosRouteUtils.getSimpleRoute(sourcePoint, sourcePortOrien, targetPoint, targetPortOrien, allCells);
    if (list != null && list.size() > 0) {
        listRoute.addAll(list);
        return true;
    } else {
        list = XcosRouteUtils.getComplexRoute(sourcePoint, sourcePortOrien, targetPoint, targetPortOrien, allCells, XcosRouteUtils.TRY_TIMES);
        if (list != null && list.size() > 0) {
            listRoute.addAll(list);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected Object[] getAllOtherCells(Object[] all, Object... self) {
    List<Object> listNotObs = new ArrayList<Object>(0);
    listNotObs.addAll(Arrays.asList(self));
    for (Object obj : self) {
        // if self contains a link
        if (obj instanceof BasicLink) {
            BasicLink link = (BasicLink) obj;
            // remove it.
            if (link.getSource() != null && link.getSource().getParent() instanceof SplitBlock) {
                listNotObs.add(link.getSource().getParent());
            }
            if (link.getTarget() != null && link.getTarget().getParent() instanceof SplitBlock) {
                listNotObs.add(link.getTarget().getParent());
            }
        }
    }
    List<Object> listnew = new ArrayList<Object>(0);
    for (Object o : all) {
        // if it does not belongs to self,
        if (!listNotObs.contains(o) && !(o instanceof SplitBlock)) {
            // only add normal Blocks.
            listnew.add(o);
            // add the ports of the block.
            if (o instanceof BasicBlock) {
                BasicBlock block = (BasicBlock) o;
                for (int i = 0; i < block.getChildCount(); i++) {
                    if (!listNotObs.contains(block.getChildAt(i))) {
                        listnew.add(block.getChildAt(i));
                    }
                }
            }
        }
    }
    Object[] newAll = listnew.toArray();
    return newAll;
}
#method_after
protected Object[] getAllOtherCells(Object[] all, Object... self) {
    List<Object> listNotObs = new ArrayList<Object>(0);
    listNotObs.addAll(Arrays.asList(self));
    for (Object obj : self) {
        // if self contains a link
        if (obj instanceof BasicLink) {
            BasicLink link = (BasicLink) obj;
            // remove it.
            if (link.getSource() != null && link.getSource().getParent() instanceof SplitBlock) {
                listNotObs.add(link.getSource().getParent());
            }
            if (link.getTarget() != null && link.getTarget().getParent() instanceof SplitBlock) {
                listNotObs.add(link.getTarget().getParent());
            }
        }
    }
    List<Object> listnew = new ArrayList<Object>(0);
    for (Object o : all) {
        // if it does not belongs to self,
        if (!listNotObs.contains(o) && !(o instanceof SplitBlock)) {
            // only add normal Blocks excluding SplitBlock or TextBlock.
            if (!listnew.contains(o)) {
                listnew.add(o);
            }
            // add the ports of the block.
            if (o instanceof BasicBlock) {
                BasicBlock block = (BasicBlock) o;
                for (int i = 0; i < block.getChildCount(); i++) {
                    if (!listNotObs.contains(block.getChildAt(i))) {
                        listnew.add(block.getChildAt(i));
                    }
                }
            }
        }
    }
    Object[] newAll = listnew.toArray();
    return newAll;
}
#end_block

#method_before
private double calculateAxesDistance2(Double[] bounds, double x, double y) {
    double x2 = bounds[0] + bounds[2];
    double y2 = bounds[1] + bounds[3];
    double x1 = bounds[0];
    double y1 = bounds[1];
    boolean xbounded = (x >= x1) && (x <= x2);
    boolean ybounded = (y >= y1) && (y <= y2);
    if (xbounded && ybounded) {
        return 0.0;
    }
    y1 = y1 - y;
    y2 = y2 - y;
    y1 *= y1;
    y2 *= y2;
    if (xbounded) {
        return Math.min(y1, y2);
    }
    x1 = x1 - x;
    x2 = x2 - x;
    x1 *= x1;
    x2 *= x2;
    if (ybounded) {
        return Math.min(x1, x2);
    }
    return Math.min(Math.min(x1 + y1, x1 + y2), Math.min(x2 + y1, x2 + y2));
}
#method_after
private double calculateAxesDistance2(Double[] bounds, double x, double y) {
    double x2 = bounds[0] + bounds[2];
    double y2 = bounds[1] + bounds[3];
    double x1 = bounds[0];
    double y1 = bounds[1];
    boolean xbounded = (x >= x1) && (x <= x2);
    boolean ybounded = (y >= y1) && (y <= y2);
    if (xbounded && ybounded) {
        return 0.0;
    }
    y1 -= y;
    y2 -= y;
    y1 *= y1;
    y2 *= y2;
    if (xbounded) {
        return Math.min(y1, y2);
    }
    x1 -= x;
    x2 -= x;
    x1 *= x1;
    x2 *= x2;
    if (ybounded) {
        return Math.min(x1, x2);
    }
    return Math.min(Math.min(x1 + y1, x1 + y2), Math.min(x2 + y1, x2 + y2));
}
#end_block

#method_before
public void setEnabled(boolean status) {
    if (status)
        uiTable.setEnabled(true);
    else
        uiTable.setEnabled(false);
}
#method_after
public void setEnabled(boolean status) {
    uiTable.setEnabled(status);
}
#end_block

#method_before
public String handleTd(final Map<String, String> attributes, final String contents) throws SAXException {
    String align = attributes.get("align");
    String valign = attributes.get("valign");
    String bgcolor = attributes.get("bgcolor");
    String colspan = attributes.get("colspan");
    String nowrap = attributes.get("nowrap");
    /*  nowrap="nowrap" */
    String rowspan = attributes.get("rowspan");
    return encloseContents("td", new String[] { "align", align, "valign", valign, "bgcolor", bgcolor, "colspan", colspan, "nowrap", nowrap, "rowspan", rowspan }, contents);
}
#method_after
public String handleTd(final Map<String, String> attributes, final String contents) throws SAXException {
    String align = attributes.get("align");
    String valign = attributes.get("valign");
    String bgcolor = attributes.get("bgcolor");
    String colspan = attributes.get("colspan");
    String rowspan = attributes.get("rowspan");
    String style = attributes.get("style");
    return encloseContents("td", new String[] { "align", align, "valign", valign, "bgcolor", bgcolor, "colspan", colspan, "rowspan", rowspan, "style", style }, contents);
}
#end_block

#method_before
public String handleTh(final Map<String, String> attributes, final String contents) throws SAXException {
    String align = attributes.get("align");
    String valign = attributes.get("valign");
    String nowrap = attributes.get("nowrap");
    return encloseContents("th", new String[] { "align", align, "valign", valign, "nowrap", nowrap }, contents);
}
#method_after
public String handleTh(final Map<String, String> attributes, final String contents) throws SAXException {
    String align = attributes.get("align");
    String valign = attributes.get("valign");
    String style = attributes.get("style");
    return encloseContents("th", new String[] { "align", align, "valign", valign, "style", style }, contents);
}
#end_block

#method_before
public Object getPropertyFromName(int propertyName) {
    switch(propertyName) {
        case __GO_DATATIP_DATA__:
            return DatatipObjectProperty.TIP_DATA;
        case __GO_DATATIP_BOX_MODE__:
            return DatatipObjectProperty.TIP_BOX_MODE;
        case __GO_DATATIP_LABEL_MODE__:
            return DatatipObjectProperty.TIP_LABEL_MODE;
        case __GO_DATATIP_ORIENTATION__:
            return DatatipObjectProperty.TIP_ORIENTATION;
        case __GO_DATATIP_COMPONENT_DISPLAY__:
            return DatatipObjectProperty.TIP_COMPONENT_DISPLAY;
        case __GO_DATATIP_AUTOORIENTATION__:
            return DatatipObjectProperty.TIP_AUTOORIENTATION;
        case __GO_DATATIP_INTERP_MODE__:
            return DatatipObjectProperty.TIP_INTERP_MODE;
        case __GO_DATATIP_DISPLAY_FNC__:
            return DatatipObjectProperty.TIP_DISPLAY_FNC;
        case __GO_DATATIP_INDEXES__:
            return DatatipObjectProperty.TIP_INDEXES;
        default:
            return super.getPropertyFromName(propertyName);
    }
}
#method_after
public Object getPropertyFromName(int propertyName) {
    switch(propertyName) {
        case __GO_DATATIP_DATA__:
            return DatatipObjectProperty.TIP_DATA;
        case __GO_DATATIP_BOX_MODE__:
            return DatatipObjectProperty.TIP_BOX_MODE;
        case __GO_DATATIP_LABEL_MODE__:
            return DatatipObjectProperty.TIP_LABEL_MODE;
        case __GO_DATATIP_ORIENTATION__:
            return DatatipObjectProperty.TIP_ORIENTATION;
        case __GO_DATATIP_DISPLAY_COMPONENTS__:
            return DatatipObjectProperty.TIP_DISPLAY_COMPONENTS;
        case __GO_DATATIP_AUTOORIENTATION__:
            return DatatipObjectProperty.TIP_AUTOORIENTATION;
        case __GO_DATATIP_INTERP_MODE__:
            return DatatipObjectProperty.TIP_INTERP_MODE;
        case __GO_DATATIP_DISPLAY_FNC__:
            return DatatipObjectProperty.TIP_DISPLAY_FNC;
        case __GO_DATATIP_INDEXES__:
            return DatatipObjectProperty.TIP_INDEXES;
        default:
            return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getProperty(Object property) {
    if (property instanceof DatatipObjectProperty) {
        switch((DatatipObjectProperty) property) {
            case TIP_DATA:
                return getTipData();
            case TIP_BOX_MODE:
                return getTipBoxMode();
            case TIP_LABEL_MODE:
                return getTipLabelMode();
            case TIP_ORIENTATION:
                return getOrientation();
            case TIP_COMPONENT_DISPLAY:
                return getComponentDisplay();
            case TIP_AUTOORIENTATION:
                return isAutoOrientationEnabled();
            case TIP_INTERP_MODE:
                return getInterpMode();
            case TIP_DISPLAY_FNC:
                return getDisplayFunction();
            case TIP_INDEXES:
                return getIndexes();
        }
    }
    return super.getProperty(property);
}
#method_after
public Object getProperty(Object property) {
    if (property instanceof DatatipObjectProperty) {
        switch((DatatipObjectProperty) property) {
            case TIP_DATA:
                return getTipData();
            case TIP_BOX_MODE:
                return getTipBoxMode();
            case TIP_LABEL_MODE:
                return getTipLabelMode();
            case TIP_ORIENTATION:
                return getOrientation();
            case TIP_DISPLAY_COMPONENTS:
                return getDisplayComponents();
            case TIP_AUTOORIENTATION:
                return isAutoOrientationEnabled();
            case TIP_INTERP_MODE:
                return getInterpMode();
            case TIP_DISPLAY_FNC:
                return getDisplayFunction();
            case TIP_INDEXES:
                return getIndexes();
        }
    }
    return super.getProperty(property);
}
#end_block

#method_before
public UpdateStatus setProperty(Object property, Object value) {
    if (property instanceof DatatipObjectProperty) {
        switch((DatatipObjectProperty) property) {
            case TIP_BOX_MODE:
                return setTipBoxMode((Boolean) value);
            case TIP_LABEL_MODE:
                return setTipLabelMode((Boolean) value);
            case TIP_ORIENTATION:
                return setOrientation((Integer) value);
            case TIP_COMPONENT_DISPLAY:
                return setComponentDisplay((String) value);
            case TIP_AUTOORIENTATION:
                return setAutoOrientation((Boolean) value);
            case TIP_INTERP_MODE:
                return setInterpMode((Boolean) value);
            case TIP_DISPLAY_FNC:
                return setDisplayFunction((String) value);
            case TIP_INDEXES:
                return setIndexes((Double[]) value);
        }
    }
    return super.setProperty(property, value);
}
#method_after
public UpdateStatus setProperty(Object property, Object value) {
    if (property instanceof DatatipObjectProperty) {
        switch((DatatipObjectProperty) property) {
            case TIP_BOX_MODE:
                return setTipBoxMode((Boolean) value);
            case TIP_LABEL_MODE:
                return setTipLabelMode((Boolean) value);
            case TIP_ORIENTATION:
                return setOrientation((Integer) value);
            case TIP_DISPLAY_COMPONENTS:
                return setDisplayComponents((String) value);
            case TIP_AUTOORIENTATION:
                return setAutoOrientation((Boolean) value);
            case TIP_INTERP_MODE:
                return setInterpMode((Boolean) value);
            case TIP_DISPLAY_FNC:
                return setDisplayFunction((String) value);
            case TIP_INDEXES:
                return setIndexes((Double[]) value);
        }
    }
    return super.setProperty(property, value);
}
#end_block

#method_before
public Double[] getTipData() {
    final double[] dataX = (double[]) PolylineData.getDataX(getParent());
    final double[] dataY = (double[]) PolylineData.getDataY(getParent());
    // if (use3component) {
    final double[] dataZ = (double[]) PolylineData.getDataZ(getParent());
    if (dataX.length < dataIndex + 2 || dataY.length < dataIndex + 2 || dataZ.length < dataIndex + 2) {
        if (dataX.length >= 1 && dataY.length >= 1 && dataZ.length >= 1) {
            return new Double[] { dataX[dataX.length - 1], dataY[dataY.length - 1], dataZ[dataZ.length - 1] };
        } else {
            return new Double[] { 0., 0., 0. };
        }
    }
    // get pt0 and pt1 from polyline data
    final double[] pt0 = new double[] { dataX[dataIndex], dataY[dataIndex], dataZ[dataIndex] };
    final double[] pt1 = new double[] { dataX[dataIndex + 1], dataY[dataIndex + 1], dataZ[dataIndex + 1] };
    final double x = pt0[0] + (pt1[0] - pt0[0]) * ratio;
    final double y = pt0[1] + (pt1[1] - pt0[1]) * ratio;
    final double z = pt0[2] + (pt1[2] - pt0[2]) * ratio;
    return new Double[] { x, y, z };
/*} else {
            if (dataX.length < dataIndex + 2 || dataY.length < dataIndex + 2) {
                if (dataX.length >= 1 && dataY.length >= 1) {
                    return new Double[] {dataX[dataX.length - 1], dataY[dataY.length - 1], 0.};
                } else {
                    return new Double[] {0., 0., 0.};
                }
            }

            //get pt0 and pt1 from polyline data
            final double[] pt0 = new double[] {dataX[dataIndex], dataY[dataIndex]};
            final double[] pt1 = new double[] {dataX[dataIndex + 1], dataY[dataIndex + 1]};

            final double x = pt0[0] + (pt1[0] - pt0[0]) * ratio;
            final double y = pt0[1] + (pt1[1] - pt0[1]) * ratio;

            return new Double[] {x, y, 0.};
        }*/
}
#method_after
public Double[] getTipData() {
    return new Double[] { getTipDataX(), getTipDataY(), getTipDataZ() };
}
#end_block

#method_before
public void updateText() {
    // if display function is empty look in parent
    // if parent is empty too use default print
    String fnc = getDisplayFunction();
    if (fnc == null || fnc.equals("")) {
        // look in parent
        fnc = (String) GraphicController.getController().getProperty(getParent(), GraphicObjectProperties.__GO_DATATIP_DISPLAY_FNC__);
        if (fnc == null || fnc.equals("")) {
            int numCoords = componentDisplay.length();
            String[] textArray = new String[numCoords];
            Double[] tipData = getTipData();
            for (int i = 0; i < numCoords; ++i) {
                textArray[i] = componentName(i) + ":" + tipTextFormat.format(componentValue(i, tipData));
            }
            Integer[] dim = new Integer[2];
            dim[0] = numCoords;
            dim[1] = 1;
            setTextArrayDimensions(dim);
            setTextStrings(textArray);
            return;
        }
    }
    String errMsg = Messages.gettext("Wrong value for '%s' property: A valid function name expected.\n");
    errMsg = errMsg.replace("'", "''");
    errMsg = errMsg.replace("\n", "\\n");
    String updateCommand = "try;" + "GDZa786XBSq7899SHKp=getcallbackobject(" + getIdentifier() + ");" + "set(GDZa786XBSq7899SHKp,\"text\"," + fnc + "(GDZa786XBSq7899SHKp));" + "clear(\"GDZa786XBSq7899SHKp\");" + "catch;" + "set(GDZa786XBSq7899SHKp,\"display_function\",\"\");" + "set(GDZa786XBSq7899SHKp.parent,\"display_function\",\"\");" + "clear(\"GDZa786XBSq7899SHKp\");" + "error(msprintf(\"" + errMsg + "\", \"display_function\"));" + "end;";
    InterpreterManagement.requestScilabExec(updateCommand);
}
#method_after
public void updateText() {
    // if display function is empty look in parent
    // if parent is empty too use default print
    String fnc = getDisplayFunction();
    if (fnc == null || fnc.equals("")) {
        // look in parent
        fnc = (String) GraphicController.getController().getProperty(getParent(), GraphicObjectProperties.__GO_DATATIP_DISPLAY_FNC__);
        if (fnc == null || fnc.equals("")) {
            int numCoords = displayComponents.length();
            String[] textArray = new String[numCoords];
            for (int i = 0; i < numCoords; ++i) {
                textArray[i] = getComponentFormatedText(i);
            }
            Integer[] dim = new Integer[2];
            dim[0] = numCoords;
            dim[1] = 1;
            setTextArrayDimensions(dim);
            setTextStrings(textArray);
            return;
        }
    }
    String errMsg = Messages.gettext("Wrong value for '%s' property: A valid function name expected.\n");
    errMsg = errMsg.replace("'", "''");
    errMsg = errMsg.replace("\n", "\\n");
    String updateCommand = "try;" + "GDZa786XBSq7899SHKp=getcallbackobject(" + getIdentifier() + ");" + "set(GDZa786XBSq7899SHKp,\"text\"," + fnc + "(GDZa786XBSq7899SHKp));" + "clear(\"GDZa786XBSq7899SHKp\");" + "catch;" + "set(GDZa786XBSq7899SHKp,\"display_function\",\"\");" + "set(GDZa786XBSq7899SHKp.parent,\"display_function\",\"\");" + "clear(\"GDZa786XBSq7899SHKp\");" + "error(msprintf(\"" + errMsg + "\", \"display_function\"));" + "end;";
    InterpreterManagement.requestScilabExec(updateCommand);
}
#end_block

#method_before
@Override
public final void initComponents(Integer objectID) {
    int row = 0;
    // to inner components
    final int leftmargin = 0;
    // first column
    int column = 1;
    datatip.tipComponentDisplay(sectionPanel, row++, column, leftmargin, objectID);
    datatip.tipData(sectionPanel, row++, column, leftmargin, objectID);
    graphicObject.tag(sectionPanel, row++, column, leftmargin, objectID);
    graphicObject.userData(sectionPanel, row++, column, leftmargin);
}
#method_after
@Override
public final void initComponents(Integer objectID) {
    int row = 0;
    // to inner components
    final int leftmargin = 0;
    // first column
    int column = 1;
    datatip.tipDisplayComponents(sectionPanel, row++, column, leftmargin, objectID);
    datatip.tipData(sectionPanel, row++, column, leftmargin, objectID);
    graphicObject.tag(sectionPanel, row++, column, leftmargin, objectID);
    graphicObject.userData(sectionPanel, row++, column, leftmargin);
}
#end_block

#method_before
private static int datatipProperties(double[] coord, Integer polyline) {
    GraphicController controller = GraphicController.getController();
    Integer newDatatip = controller.askObject(GraphicObject.getTypeFromName(GraphicObjectProperties.__GO_DATATIP__));
    Double[] indexes = null;
    Integer axesUid = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_PARENT_AXES__);
    Integer viewInfo = (Integer) controller.getProperty(axesUid, __GO_VIEW__);
    Integer fg = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_LINE_COLOR__);
    Integer bg = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_BACKGROUND__);
    Integer style = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_DATATIP_MARK__);
    // do not set relationship, only set parent to be able to go up in hierarchy
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_PARENT__, polyline);
    // set dataIndex and ratio from polyline
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_DATATIP_INDEXES__, new Double[] { coord[0], coord[1] });
    // set colors
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_MARK_FOREGROUND__, fg);
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_MARK_BACKGROUND__, bg);
    // set style
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_MARK_STYLE__, style);
    // get current polyline datatips
    Integer[] tips = (Integer[]) controller.getProperty(polyline, GraphicObjectProperties.__GO_DATATIPS__);
    // insert new tip in children array
    List<Integer> l = new LinkedList<Integer>(Arrays.asList(tips));
    l.add(0, newDatatip);
    // set new datatips arry in polyline
    Integer[] var = new Integer[l.size()];
    l.toArray(var);
    controller.setProperty(polyline, GraphicObjectProperties.__GO_DATATIPS__, var);
    if (viewInfo == 1 && PolylineData.isZCoordSet(polyline) == 1) {
        controller.setProperty(newDatatip, GraphicObjectProperties.__GO_DATATIP_COMPONENT_DISPLAY__, "xyz");
        controller.setProperty(newDatatip, GraphicObjectProperties.__GO_CLIP_STATE__, 0);
    }
    if (DatatipManagerMode.getInstance() != null) {
        DatatipManagerMode.getInstance().setLastTip(axesUid, newDatatip);
    }
    return newDatatip;
}
#method_after
private static int datatipProperties(double[] coord, Integer polyline) {
    GraphicController controller = GraphicController.getController();
    Integer newDatatip = controller.askObject(GraphicObject.getTypeFromName(GraphicObjectProperties.__GO_DATATIP__));
    Double[] indexes = null;
    Integer axesUid = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_PARENT_AXES__);
    Integer viewInfo = (Integer) controller.getProperty(axesUid, __GO_VIEW__);
    Integer fg = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_LINE_COLOR__);
    Integer bg = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_BACKGROUND__);
    Integer style = (Integer) controller.getProperty(polyline, GraphicObjectProperties.__GO_DATATIP_MARK__);
    // do not set relationship, only set parent to be able to go up in hierarchy
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_PARENT__, polyline);
    // set dataIndex and ratio from polyline
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_DATATIP_INDEXES__, new Double[] { coord[0], coord[1] });
    // set colors
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_MARK_FOREGROUND__, fg);
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_MARK_BACKGROUND__, bg);
    // set style
    controller.setProperty(newDatatip, GraphicObjectProperties.__GO_MARK_STYLE__, style);
    // get current polyline datatips
    Integer[] tips = (Integer[]) controller.getProperty(polyline, GraphicObjectProperties.__GO_DATATIPS__);
    // insert new tip in children array
    List<Integer> l = new LinkedList<Integer>(Arrays.asList(tips));
    l.add(0, newDatatip);
    // set new datatips arry in polyline
    Integer[] var = new Integer[l.size()];
    l.toArray(var);
    controller.setProperty(polyline, GraphicObjectProperties.__GO_DATATIPS__, var);
    if (viewInfo == 1 && PolylineData.isZCoordSet(polyline) == 1) {
        controller.setProperty(newDatatip, GraphicObjectProperties.__GO_DATATIP_DISPLAY_COMPONENTS__, "xyz");
        controller.setProperty(newDatatip, GraphicObjectProperties.__GO_CLIP_STATE__, 0);
    }
    if (DatatipManagerMode.getInstance() != null) {
        DatatipManagerMode.getInstance().setLastTip(axesUid, newDatatip);
    }
    return newDatatip;
}
#end_block

#method_before
@Override
public void updateObject(Integer id, int property) {
    if (SwapObject.getLastType() == (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_TYPE__)) {
        boolean isValid = false;
        switch(property) {
            case GraphicObjectProperties.__GO_VISIBLE__:
                boolean c_visible = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_VISIBLE__);
                if (visible != c_visible) {
                    isValid = true;
                    visible = c_visible;
                }
                break;
            case GraphicObjectProperties.__GO_AUTORESIZE__:
                boolean c_autoresize = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_AUTORESIZE__);
                if (autoresize != c_autoresize) {
                    isValid = true;
                    autoresize = c_autoresize;
                }
                break;
            case GraphicObjectProperties.__GO_PIXEL_DRAWING_MODE__:
                Integer c_pixelDrawingMode = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_PIXEL_DRAWING_MODE__);
                if (pixelDrawingMode != c_pixelDrawingMode) {
                    isValid = true;
                    pixelDrawingMode = c_pixelDrawingMode;
                }
                break;
            case GraphicObjectProperties.__GO_ANTIALIASING__:
                Integer c_antialiasing = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_ANTIALIASING__);
                if (antialiasing != c_antialiasing) {
                    isValid = true;
                    antialiasing = c_antialiasing;
                }
                break;
            case GraphicObjectProperties.__GO_ROTATION_TYPE__:
                Integer c_rotationType = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_ROTATION_TYPE__);
                if (rotationType != c_rotationType) {
                    isValid = true;
                    rotationType = c_rotationType;
                }
                break;
            case GraphicObjectProperties.__GO_CLIP_STATE__:
                Integer c_clipState = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_CLIP_STATE__);
                if (clipState != c_clipState) {
                    isValid = true;
                    clipState = c_clipState;
                }
                break;
            case GraphicObjectProperties.__GO_LINE_MODE__:
                boolean c_lineMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_LINE_MODE__);
                if (lineMode != c_lineMode) {
                    isValid = true;
                    lineMode = c_lineMode;
                }
                break;
            case GraphicObjectProperties.__GO_LINE_STYLE__:
                Integer c_lineStyle = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_LINE_STYLE__);
                if (lineStyle != c_lineStyle) {
                    isValid = true;
                    lineStyle = c_lineStyle;
                }
                break;
            case GraphicObjectProperties.__GO_MARK_MODE__:
                boolean c_markMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_MARK_MODE__);
                if (markMode != c_markMode) {
                    isValid = true;
                    markMode = c_markMode;
                }
                break;
            case GraphicObjectProperties.__GO_MARK_SIZE_UNIT__:
                Integer c_markSizeUnit = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_MARK_SIZE_UNIT__);
                if (markSizeUnit != c_markSizeUnit) {
                    isValid = true;
                    markSizeUnit = c_markSizeUnit;
                }
                break;
            case GraphicObjectProperties.__GO_DATA_MAPPING__:
                Integer c_dataMapping = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATA_MAPPING__);
                if (dataMapping != c_dataMapping) {
                    isValid = true;
                    dataMapping = c_dataMapping;
                }
                break;
            case GraphicObjectProperties.__GO_CLOSED__:
                boolean c_closed = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_CLOSED__);
                if (closed != c_closed) {
                    isValid = true;
                    closed = c_closed;
                }
                break;
            case GraphicObjectProperties.__GO_SURFACE_MODE__:
                boolean c_surfaceMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_SURFACE_MODE__);
                if (surfaceMode != c_surfaceMode) {
                    isValid = true;
                    surfaceMode = c_surfaceMode;
                }
                break;
            case GraphicObjectProperties.__GO_COLORED__:
                boolean c_colored = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_COLORED__);
                if (colored != c_colored) {
                    isValid = true;
                    colored = c_colored;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_ORIENTATION__:
                Integer c_datatipOrientation = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_ORIENTATION__);
                if (datatipOrientation != c_datatipOrientation) {
                    isValid = true;
                    datatipOrientation = c_datatipOrientation;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_COMPONENT_DISPLAY__:
                String c_datatipComponentDisplay = (String) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_COMPONENT_DISPLAY__);
                if (datatipComponentDisplay != c_datatipComponentDisplay) {
                    isValid = true;
                    datatipComponentDisplay = c_datatipComponentDisplay;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_AUTOORIENTATION__:
                boolean c_datatipAutoOrientation = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_AUTOORIENTATION__);
                if (datatipAutoOrientation != c_datatipAutoOrientation) {
                    isValid = true;
                    datatipAutoOrientation = c_datatipAutoOrientation;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_BOX_MODE__:
                boolean c_datatipBoxMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_BOX_MODE__);
                if (datatipBoxMode != c_datatipBoxMode) {
                    isValid = true;
                    datatipBoxMode = c_datatipBoxMode;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_LABEL_MODE__:
                boolean c_datatipLabelMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_LABEL_MODE__);
                if (datatipLabelMode != c_datatipLabelMode) {
                    isValid = true;
                    datatipLabelMode = c_datatipLabelMode;
                }
                break;
            case GraphicObjectProperties.__GO_FONT_STYLE__:
                Integer c_fontStyle = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_FONT_STYLE__);
                if (fontStyle != c_fontStyle) {
                    isValid = true;
                    fontStyle = c_fontStyle;
                }
                break;
            case GraphicObjectProperties.__GO_FONT_FRACTIONAL__:
                boolean c_fontFractional = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_FONT_FRACTIONAL__);
                if (fontFractional != c_fontFractional) {
                    isValid = true;
                    fontFractional = c_fontFractional;
                }
                break;
            case GraphicObjectProperties.__GO_LEGEND_LOCATION__:
                Integer c_legendLocation = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_LEGEND_LOCATION__);
                if (legendLocation != c_legendLocation) {
                    isValid = true;
                    legendLocation = c_legendLocation;
                }
                break;
            case GraphicObjectProperties.__GO_AUTO_POSITION__:
                boolean c_autoPosition = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_AUTO_POSITION__);
                if (autoPosition != c_autoPosition) {
                    isValid = true;
                    autoPosition = c_autoPosition;
                }
                break;
            case GraphicObjectProperties.__GO_AUTO_ROTATION__:
                boolean c_autoRotation = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_AUTO_ROTATION__);
                if (autoRotation != c_autoRotation) {
                    isValid = true;
                    autoRotation = c_autoRotation;
                }
                break;
            default:
                isValid = true;
        }
        if (isValid) {
            Inspector.getInspector(id);
        }
    }
}
#method_after
@Override
public void updateObject(Integer id, int property) {
    if (SwapObject.getLastType() == (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_TYPE__)) {
        boolean isValid = false;
        switch(property) {
            case GraphicObjectProperties.__GO_VISIBLE__:
                boolean c_visible = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_VISIBLE__);
                if (visible != c_visible) {
                    isValid = true;
                    visible = c_visible;
                }
                break;
            case GraphicObjectProperties.__GO_AUTORESIZE__:
                boolean c_autoresize = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_AUTORESIZE__);
                if (autoresize != c_autoresize) {
                    isValid = true;
                    autoresize = c_autoresize;
                }
                break;
            case GraphicObjectProperties.__GO_PIXEL_DRAWING_MODE__:
                Integer c_pixelDrawingMode = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_PIXEL_DRAWING_MODE__);
                if (pixelDrawingMode != c_pixelDrawingMode) {
                    isValid = true;
                    pixelDrawingMode = c_pixelDrawingMode;
                }
                break;
            case GraphicObjectProperties.__GO_ANTIALIASING__:
                Integer c_antialiasing = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_ANTIALIASING__);
                if (antialiasing != c_antialiasing) {
                    isValid = true;
                    antialiasing = c_antialiasing;
                }
                break;
            case GraphicObjectProperties.__GO_ROTATION_TYPE__:
                Integer c_rotationType = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_ROTATION_TYPE__);
                if (rotationType != c_rotationType) {
                    isValid = true;
                    rotationType = c_rotationType;
                }
                break;
            case GraphicObjectProperties.__GO_CLIP_STATE__:
                Integer c_clipState = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_CLIP_STATE__);
                if (clipState != c_clipState) {
                    isValid = true;
                    clipState = c_clipState;
                }
                break;
            case GraphicObjectProperties.__GO_LINE_MODE__:
                boolean c_lineMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_LINE_MODE__);
                if (lineMode != c_lineMode) {
                    isValid = true;
                    lineMode = c_lineMode;
                }
                break;
            case GraphicObjectProperties.__GO_LINE_STYLE__:
                Integer c_lineStyle = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_LINE_STYLE__);
                if (lineStyle != c_lineStyle) {
                    isValid = true;
                    lineStyle = c_lineStyle;
                }
                break;
            case GraphicObjectProperties.__GO_MARK_MODE__:
                boolean c_markMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_MARK_MODE__);
                if (markMode != c_markMode) {
                    isValid = true;
                    markMode = c_markMode;
                }
                break;
            case GraphicObjectProperties.__GO_MARK_SIZE_UNIT__:
                Integer c_markSizeUnit = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_MARK_SIZE_UNIT__);
                if (markSizeUnit != c_markSizeUnit) {
                    isValid = true;
                    markSizeUnit = c_markSizeUnit;
                }
                break;
            case GraphicObjectProperties.__GO_DATA_MAPPING__:
                Integer c_dataMapping = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATA_MAPPING__);
                if (dataMapping != c_dataMapping) {
                    isValid = true;
                    dataMapping = c_dataMapping;
                }
                break;
            case GraphicObjectProperties.__GO_CLOSED__:
                boolean c_closed = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_CLOSED__);
                if (closed != c_closed) {
                    isValid = true;
                    closed = c_closed;
                }
                break;
            case GraphicObjectProperties.__GO_SURFACE_MODE__:
                boolean c_surfaceMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_SURFACE_MODE__);
                if (surfaceMode != c_surfaceMode) {
                    isValid = true;
                    surfaceMode = c_surfaceMode;
                }
                break;
            case GraphicObjectProperties.__GO_COLORED__:
                boolean c_colored = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_COLORED__);
                if (colored != c_colored) {
                    isValid = true;
                    colored = c_colored;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_ORIENTATION__:
                Integer c_datatipOrientation = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_ORIENTATION__);
                if (datatipOrientation != c_datatipOrientation) {
                    isValid = true;
                    datatipOrientation = c_datatipOrientation;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_DISPLAY_COMPONENTS__:
                String c_datatipDisplayComponents = (String) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_DISPLAY_COMPONENTS__);
                if (datatipDisplayComponents != c_datatipDisplayComponents) {
                    isValid = true;
                    datatipDisplayComponents = c_datatipDisplayComponents;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_AUTOORIENTATION__:
                boolean c_datatipAutoOrientation = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_AUTOORIENTATION__);
                if (datatipAutoOrientation != c_datatipAutoOrientation) {
                    isValid = true;
                    datatipAutoOrientation = c_datatipAutoOrientation;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_BOX_MODE__:
                boolean c_datatipBoxMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_BOX_MODE__);
                if (datatipBoxMode != c_datatipBoxMode) {
                    isValid = true;
                    datatipBoxMode = c_datatipBoxMode;
                }
                break;
            case GraphicObjectProperties.__GO_DATATIP_LABEL_MODE__:
                boolean c_datatipLabelMode = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_DATATIP_LABEL_MODE__);
                if (datatipLabelMode != c_datatipLabelMode) {
                    isValid = true;
                    datatipLabelMode = c_datatipLabelMode;
                }
                break;
            case GraphicObjectProperties.__GO_FONT_STYLE__:
                Integer c_fontStyle = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_FONT_STYLE__);
                if (fontStyle != c_fontStyle) {
                    isValid = true;
                    fontStyle = c_fontStyle;
                }
                break;
            case GraphicObjectProperties.__GO_FONT_FRACTIONAL__:
                boolean c_fontFractional = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_FONT_FRACTIONAL__);
                if (fontFractional != c_fontFractional) {
                    isValid = true;
                    fontFractional = c_fontFractional;
                }
                break;
            case GraphicObjectProperties.__GO_LEGEND_LOCATION__:
                Integer c_legendLocation = (Integer) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_LEGEND_LOCATION__);
                if (legendLocation != c_legendLocation) {
                    isValid = true;
                    legendLocation = c_legendLocation;
                }
                break;
            case GraphicObjectProperties.__GO_AUTO_POSITION__:
                boolean c_autoPosition = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_AUTO_POSITION__);
                if (autoPosition != c_autoPosition) {
                    isValid = true;
                    autoPosition = c_autoPosition;
                }
                break;
            case GraphicObjectProperties.__GO_AUTO_ROTATION__:
                boolean c_autoRotation = (Boolean) GraphicController.getController().getProperty(id, GraphicObjectProperties.__GO_AUTO_ROTATION__);
                if (autoRotation != c_autoRotation) {
                    isValid = true;
                    autoRotation = c_autoRotation;
                }
                break;
            default:
                isValid = true;
        }
        if (isValid) {
            Inspector.getInspector(id);
        }
    }
}
#end_block

#method_before
/**
 * Initialize the dialog components.
 *
 * As this method perform a complex initialization, It doesn't pass NCSS.
 */
private void initComponents() {
    JLabel integrationLabel = new JLabel(XcosMessages.FINAL_INTEGRATION_TIME);
    integration = new JFormattedTextField(CURRENT_FORMAT);
    integration.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    integration.setValue(new BigDecimal(parameters.getFinalIntegrationTime()));
    JLabel rtsLabel = new JLabel(XcosMessages.REAL_TIME_SCALING);
    rts = new JFormattedTextField(CURRENT_FORMAT);
    rts.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    rts.setValue(new BigDecimal(parameters.getRealTimeScaling()));
    JLabel integratorAbsLabel = new JLabel(XcosMessages.INTEGRATOR_ABSOLUTE_TOLERANCE);
    integrator = new JFormattedTextField(CURRENT_FORMAT);
    integrator.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    integrator.setValue(new BigDecimal(parameters.getIntegratorAbsoluteTolerance()));
    JLabel integratorRelLabel = new JLabel(XcosMessages.INTEGRATOR_RELATIVE_TOLERANCE);
    integratorRel = new JFormattedTextField(CURRENT_FORMAT);
    integratorRel.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    integratorRel.setValue(new BigDecimal(parameters.getIntegratorRelativeTolerance()));
    JLabel toleranceOnTimeLabel = new JLabel(XcosMessages.TOLERANCE_ON_TIME);
    toleranceOnTime = new JFormattedTextField(CURRENT_FORMAT);
    toleranceOnTime.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    toleranceOnTime.setValue(new BigDecimal(parameters.getToleranceOnTime()));
    JLabel maxIntegrationTimeLabel = new JLabel(XcosMessages.MAX_INTEGRATION_TIME_INTERVAL);
    maxIntegrationTime = new JFormattedTextField(CURRENT_FORMAT);
    maxIntegrationTime.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    maxIntegrationTime.setValue(new BigDecimal(parameters.getMaxIntegrationTimeInterval()));
    JLabel solverLabel = new JLabel(XcosMessages.SOLVER_CHOICE);
    solver = new JComboBox(AVAILABLE_SOLVERS);
    double solverValue = parameters.getSolver();
    final int currentIndex = Arrays.binarySearch(AVAILABLE_SOLVERS, new SolverDescriptor(solverValue));
    final SolverDescriptor current = AVAILABLE_SOLVERS[currentIndex];
    solver.setSelectedIndex(currentIndex);
    final class ComboboxToolTipRenderer extends DefaultListCellRenderer {

        @Override
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            JComponent comp = (JComponent) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
            if (-1 < index && null != value) {
                list.setToolTipText(AVAILABLE_SOLVERS[index].getTooltip());
            }
            return comp;
        }
    }
    solver.setRenderer(new ComboboxToolTipRenderer());
    solver.addItemListener(new ItemListener() {

        @Override
        public void itemStateChanged(ItemEvent e) {
            SolverDescriptor current = (SolverDescriptor) e.getItem();
            current.applyModifiers(integrator, integratorRel, toleranceOnTime, maxIntegrationTime, maxStepSize);
        }
    });
    JLabel maxStepSizeLabel = new JLabel(XcosMessages.MAXIMUN_STEP_SIZE);
    maxStepSize = new JFormattedTextField(CURRENT_FORMAT);
    maxStepSize.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    maxStepSize.setValue(new BigDecimal(parameters.getMaximumStepSize()));
    JButton cancelButton = new JButton(XcosMessages.CANCEL);
    JButton okButton = new JButton(XcosMessages.OK);
    JButton defaultButton = new JButton(XcosMessages.DEFAULT);
    JButton setContextButton = new JButton(XcosMessages.SET_CONTEXT);
    okButton.setPreferredSize(cancelButton.getPreferredSize());
    GridBagConstraints gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.insets = new Insets(0, 10, 0, 0);
    gbc.gridx = 0;
    gbc.gridy = 4;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.fill = GridBagConstraints.NONE;
    gbc.insets = new Insets(0, 10, 0, 0);
    add(integrationLabel, gbc);
    gbc.gridy = 5;
    add(rtsLabel, gbc);
    gbc.gridy = 6;
    add(integratorAbsLabel, gbc);
    gbc.gridy = 7;
    add(integratorRelLabel, gbc);
    gbc.gridy = 8;
    add(toleranceOnTimeLabel, gbc);
    gbc.gridy = 9;
    add(maxIntegrationTimeLabel, gbc);
    gbc.gridy = 10;
    add(solverLabel, gbc);
    gbc.gridy = 11;
    add(maxStepSizeLabel, gbc);
    gbc.gridy = 12;
    add(setContextButton, gbc);
    gbc.gridx = 1;
    gbc.gridy = 4;
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    gbc.insets = new Insets(5, 10, 0, 10);
    add(integration, gbc);
    gbc.gridy = 5;
    add(rts, gbc);
    gbc.gridy = 6;
    add(integrator, gbc);
    gbc.gridy = 7;
    add(integratorRel, gbc);
    gbc.gridy = 8;
    add(toleranceOnTime, gbc);
    gbc.gridy = 9;
    add(maxIntegrationTime, gbc);
    gbc.gridy = 10;
    add(solver, gbc);
    gbc.gridy = 11;
    add(maxStepSize, gbc);
    gbc.gridx = 1;
    gbc.gridy = 14;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.weightx = 1.;
    gbc.fill = GridBagConstraints.NONE;
    gbc.insets = new Insets(5, 0, 10, 5);
    add(okButton, gbc);
    gbc.gridx = 2;
    gbc.weightx = 0.;
    gbc.insets = new Insets(5, 0, 10, 10);
    add(cancelButton, gbc);
    gbc.gridx = 3;
    gbc.weightx = 0.;
    gbc.insets = new Insets(5, 0, 10, 10);
    add(defaultButton, gbc);
    installActionListeners(cancelButton, okButton, defaultButton, setContextButton);
    // at the end, update the enable status of some components
    current.applyModifiers(integrator, integratorRel, toleranceOnTime, maxIntegrationTime, maxStepSize);
}
#method_after
/**
 * Initialize the dialog components.
 *
 * As this method perform a complex initialization, It doesn't pass NCSS.
 */
private void initComponents() {
    JavaController controller = new JavaController();
    JLabel integrationLabel = new JLabel(XcosMessages.FINAL_INTEGRATION_TIME);
    integration = new JFormattedTextField(CURRENT_FORMAT);
    integration.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    integration.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.FINAL_INTEGRATION_TIME)));
    JLabel rtsLabel = new JLabel(XcosMessages.REAL_TIME_SCALING);
    rts = new JFormattedTextField(CURRENT_FORMAT);
    rts.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    rts.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.REAL_TIME_SCALING)));
    JLabel integratorAbsLabel = new JLabel(XcosMessages.INTEGRATOR_ABSOLUTE_TOLERANCE);
    integrator = new JFormattedTextField(CURRENT_FORMAT);
    integrator.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    integrator.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.INTEGRATOR_ABSOLUTE_TOLERANCE)));
    JLabel integratorRelLabel = new JLabel(XcosMessages.INTEGRATOR_RELATIVE_TOLERANCE);
    integratorRel = new JFormattedTextField(CURRENT_FORMAT);
    integratorRel.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    integratorRel.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.INTEGRATOR_RELATIVE_TOLERANCE)));
    JLabel toleranceOnTimeLabel = new JLabel(XcosMessages.TOLERANCE_ON_TIME);
    toleranceOnTime = new JFormattedTextField(CURRENT_FORMAT);
    toleranceOnTime.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    toleranceOnTime.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.TOLERANCE_ON_TIME)));
    JLabel maxIntegrationTimeLabel = new JLabel(XcosMessages.MAX_INTEGRATION_TIME_INTERVAL);
    maxIntegrationTime = new JFormattedTextField(CURRENT_FORMAT);
    maxIntegrationTime.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    maxIntegrationTime.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.MAX_INTEGRATION_TIME_INTERVAL)));
    JLabel solverLabel = new JLabel(XcosMessages.SOLVER_CHOICE);
    solver = new JComboBox<SolverDescriptor>(AVAILABLE_SOLVERS);
    double solverValue = parameters.getProperties(controller).get(ScicosParameters.SOLVER);
    final int currentIndex = Arrays.binarySearch(AVAILABLE_SOLVERS, new SolverDescriptor(solverValue));
    final SolverDescriptor current = AVAILABLE_SOLVERS[currentIndex];
    solver.setSelectedIndex(currentIndex);
    final class ComboboxToolTipRenderer extends DefaultListCellRenderer {

        @Override
        public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            JComponent comp = (JComponent) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
            if (-1 < index && null != value) {
                list.setToolTipText(AVAILABLE_SOLVERS[index].getToolTip());
            }
            return comp;
        }
    }
    solver.setRenderer(new ComboboxToolTipRenderer());
    solver.addItemListener(new ItemListener() {

        @Override
        public void itemStateChanged(ItemEvent e) {
            SolverDescriptor current = (SolverDescriptor) e.getItem();
            current.applyModifiers(integrator, integratorRel, toleranceOnTime, maxIntegrationTime, maxStepSize);
        }
    });
    JLabel maxStepSizeLabel = new JLabel(XcosMessages.MAXIMUN_STEP_SIZE);
    maxStepSize = new JFormattedTextField(CURRENT_FORMAT);
    maxStepSize.setInputVerifier(VALIDATE_POSITIVE_DOUBLE);
    maxStepSize.setValue(new BigDecimal(parameters.getProperties(controller).get(ScicosParameters.MAXIMUM_STEP_SIZE)));
    JButton cancelButton = new JButton(XcosMessages.CANCEL);
    JButton okButton = new JButton(XcosMessages.OK);
    JButton defaultButton = new JButton(XcosMessages.DEFAULT);
    JButton setContextButton = new JButton(XcosMessages.SET_CONTEXT);
    okButton.setPreferredSize(cancelButton.getPreferredSize());
    GridBagConstraints gbc = new GridBagConstraints();
    gbc.gridx = 0;
    gbc.gridy = 0;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.insets = new Insets(0, 10, 0, 0);
    gbc.gridx = 0;
    gbc.gridy = 4;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.fill = GridBagConstraints.NONE;
    gbc.insets = new Insets(0, 10, 0, 0);
    add(integrationLabel, gbc);
    gbc.gridy = 5;
    add(rtsLabel, gbc);
    gbc.gridy = 6;
    add(integratorAbsLabel, gbc);
    gbc.gridy = 7;
    add(integratorRelLabel, gbc);
    gbc.gridy = 8;
    add(toleranceOnTimeLabel, gbc);
    gbc.gridy = 9;
    add(maxIntegrationTimeLabel, gbc);
    gbc.gridy = 10;
    add(solverLabel, gbc);
    gbc.gridy = 11;
    add(maxStepSizeLabel, gbc);
    gbc.gridy = 12;
    add(setContextButton, gbc);
    gbc.gridx = 1;
    gbc.gridy = 4;
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    gbc.insets = new Insets(5, 10, 0, 10);
    add(integration, gbc);
    gbc.gridy = 5;
    add(rts, gbc);
    gbc.gridy = 6;
    add(integrator, gbc);
    gbc.gridy = 7;
    add(integratorRel, gbc);
    gbc.gridy = 8;
    add(toleranceOnTime, gbc);
    gbc.gridy = 9;
    add(maxIntegrationTime, gbc);
    gbc.gridy = 10;
    add(solver, gbc);
    gbc.gridy = 11;
    add(maxStepSize, gbc);
    gbc.gridx = 1;
    gbc.gridy = 14;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.weightx = 1.;
    gbc.fill = GridBagConstraints.NONE;
    gbc.insets = new Insets(5, 0, 10, 5);
    add(okButton, gbc);
    gbc.gridx = 2;
    gbc.weightx = 0.;
    gbc.insets = new Insets(5, 0, 10, 10);
    add(cancelButton, gbc);
    gbc.gridx = 3;
    gbc.weightx = 0.;
    gbc.insets = new Insets(5, 0, 10, 10);
    add(defaultButton, gbc);
    installActionListeners(cancelButton, okButton, defaultButton, setContextButton);
    // at the end, update the enable status of some components
    current.applyModifiers(integrator, integratorRel, toleranceOnTime, maxIntegrationTime, maxStepSize);
}
#end_block

#method_before
// CSON: JavaNCSS
private void installActionListeners(JButton cancelButton, JButton okButton, JButton defaultButton, JButton setContextButton) {
    cancelButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            dispose();
        }
    });
    defaultButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            integration.setValue(new BigDecimal(ScicosParameters.FINAL_INTEGRATION_TIME));
            rts.setValue(new BigDecimal(ScicosParameters.REAL_TIME_SCALING));
            integrator.setValue(new BigDecimal(ScicosParameters.INTEGRATOR_ABSOLUTE_TOLERANCE));
            integratorRel.setValue(new BigDecimal(ScicosParameters.INTEGRATOR_RELATIVE_TOLERANCE));
            toleranceOnTime.setValue(new BigDecimal(ScicosParameters.TOLERANCE_ON_TIME));
            maxIntegrationTime.setValue(new BigDecimal(ScicosParameters.MAX_INTEGRATION_TIME_INTERVAL));
            solver.setSelectedIndex((int) ScicosParameters.SOLVER);
            maxStepSize.setValue(new BigDecimal(ScicosParameters.MAXIMUM_STEP_SIZE));
        }
    });
    okButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            try {
                /*
                     * FIXME This logic must be deported to a vetoable
                     * handler
                     */
                int solverSelectedIndex = solver.getSelectedIndex();
                parameters.setSolver(AVAILABLE_SOLVERS[solverSelectedIndex].getNumber());
                parameters.setFinalIntegrationTime(((BigDecimal) integration.getValue()).doubleValue());
                parameters.setRealTimeScaling(((BigDecimal) rts.getValue()).doubleValue());
                parameters.setIntegratorAbsoluteTolerance(((BigDecimal) integrator.getValue()).doubleValue());
                parameters.setIntegratorRelativeTolerance(((BigDecimal) integratorRel.getValue()).doubleValue());
                parameters.setToleranceOnTime(((BigDecimal) toleranceOnTime.getValue()).doubleValue());
                parameters.setMaxIntegrationTimeInterval(((BigDecimal) maxIntegrationTime.getValue()).doubleValue());
                parameters.setMaximumStepSize(((BigDecimal) maxStepSize.getValue()).doubleValue());
                dispose();
            } catch (PropertyVetoException ex) {
                Logger.getLogger(SetupAction.class.getName()).severe(ex.toString());
            }
        }
    });
    setContextButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            final SetContextDialog dialog = new SetContextDialog(SetupDialog.this, rootGraph, parameters);
            dialog.pack();
            dialog.setVisible(true);
        }
    });
}
#method_after
// CSON: JavaNCSS
private void installActionListeners(JButton cancelButton, JButton okButton, JButton defaultButton, JButton setContextButton) {
    cancelButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            dispose();
        }
    });
    defaultButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            integration.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.FINAL_INTEGRATION_TIME)));
            integrator.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.INTEGRATOR_ABSOLUTE_TOLERANCE)));
            integratorRel.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.INTEGRATOR_RELATIVE_TOLERANCE)));
            toleranceOnTime.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.TOLERANCE_ON_TIME)));
            maxIntegrationTime.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.MAX_INTEGRATION_TIME_INTERVAL)));
            maxStepSize.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.MAXIMUM_STEP_SIZE)));
            rts.setValue(new BigDecimal(ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.REAL_TIME_SCALING)));
            solver.setSelectedIndex((int) ScicosParameters.DEFAULT_PARAMETERS.get(ScicosParameters.SOLVER));
        }
    });
    okButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            try {
                /*
                     * TODO This logic must be deported to a vetoable
                     * handler
                     */
                int solverSelectedIndex = solver.getSelectedIndex();
                VectorOfDouble v = new VectorOfDouble(8);
                v.set(ScicosParameters.FINAL_INTEGRATION_TIME, ((BigDecimal) integration.getValue()).doubleValue());
                v.set(ScicosParameters.INTEGRATOR_ABSOLUTE_TOLERANCE, ((BigDecimal) integrator.getValue()).doubleValue());
                v.set(ScicosParameters.INTEGRATOR_RELATIVE_TOLERANCE, ((BigDecimal) integratorRel.getValue()).doubleValue());
                v.set(ScicosParameters.TOLERANCE_ON_TIME, ((BigDecimal) toleranceOnTime.getValue()).doubleValue());
                v.set(ScicosParameters.MAX_INTEGRATION_TIME_INTERVAL, ((BigDecimal) maxIntegrationTime.getValue()).doubleValue());
                v.set(ScicosParameters.REAL_TIME_SCALING, ((BigDecimal) rts.getValue()).doubleValue());
                v.set(ScicosParameters.SOLVER, AVAILABLE_SOLVERS[solverSelectedIndex].getNumber());
                v.set(ScicosParameters.MAXIMUM_STEP_SIZE, ((BigDecimal) maxStepSize.getValue()).doubleValue());
                parameters.setProperties(new JavaController(), v);
                dispose();
            } catch (PropertyVetoException ex) {
                Logger.getLogger(SetupAction.class.getName()).severe(ex.toString());
            }
        }
    });
    setContextButton.addActionListener(new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
            final SetContextDialog dialog = new SetContextDialog(SetupDialog.this, rootGraph, parameters);
            dialog.pack();
            dialog.setVisible(true);
        }
    });
}
#end_block

#method_before
public SplitBlock addSplitEdge(final mxPoint splitPoint, final BasicLink link) {
    final BasicPort linkSource = (BasicPort) link.getSource();
    final BasicPort linkTarget = (BasicPort) link.getTarget();
    /*
         * Select the right split accordingly to the link klass
         */
    BlockInterFunction f;
    if (link instanceof CommandControlLink) {
        f = BlockInterFunction.CLKSPLIT_f;
    } else if (link instanceof ImplicitLink) {
        f = BlockInterFunction.IMPSPLIT_f;
    } else {
        f = BlockInterFunction.SPLIT_f;
    }
    final SplitBlock splitBlock;
    try {
        splitBlock = (SplitBlock) XcosCellFactory.createBlock(f);
    } catch (InterpreterException ex) {
        // something goes wrong
        throw new RuntimeException(ex);
    }
    // snap the center of the split block on the grid
    mxGeometry geom = splitBlock.getGeometry();
    double x = snap(splitPoint.getX());
    double y = snap(splitPoint.getY());
    geom.setX(x - (geom.getWidth() / 2.));
    geom.setY(y - (geom.getHeight() / 2.));
    splitBlock.setGeometry(geom);
    getModel().beginUpdate();
    try {
        // Origin of the parent, (0,0) as default may be different in case
        mxPoint orig = link.getParent().getGeometry();
        if (orig == null) {
            orig = new mxPoint();
        }
        addCell(splitBlock);
        // Update old link
        // get breaking segment and related point
        mxPoint splitTr = new mxPoint(splitPoint.getX() - orig.getX(), splitPoint.getY() - orig.getY());
        final int pos = link.findNearestSegment(splitTr);
        // save points after breaking point
        final List<mxPoint> saveStartPoints = link.getPoints(pos, true);
        final List<mxPoint> saveEndPoints = link.getPoints(pos, false);
        // position
        if (saveEndPoints.size() > 0) {
            final mxPoint p = saveEndPoints.get(0);
            final double dx = p.getX() - splitTr.getX();
            final double dy = p.getY() - splitTr.getY();
            if (!getAsComponent().isSignificant(dx, dy)) {
                saveEndPoints.remove(0);
            }
        }
        getModel().remove(link);
        connect(linkSource, splitBlock.getIn(), saveStartPoints, orig);
        connect(splitBlock.getOut1(), linkTarget, saveEndPoints, orig);
        refresh();
    } finally {
        getModel().endUpdate();
    }
    return splitBlock;
}
#method_after
public SplitBlock addSplitEdge(final mxPoint splitPoint, final BasicLink link) {
    final BasicPort linkSource = (BasicPort) link.getSource();
    final BasicPort linkTarget = (BasicPort) link.getTarget();
    /*
         * Select the right split accordingly to the link klass
         */
    BlockInterFunction f;
    if (link instanceof CommandControlLink) {
        f = BlockInterFunction.CLKSPLIT_f;
    } else if (link instanceof ImplicitLink) {
        f = BlockInterFunction.IMPSPLIT_f;
    } else {
        f = BlockInterFunction.SPLIT_f;
    }
    final SplitBlock splitBlock;
    try {
        splitBlock = (SplitBlock) XcosCellFactory.createBlock(f);
    } catch (InterpreterException ex) {
        // something goes wrong
        throw new RuntimeException(ex);
    }
    // snap the center of the split block on the grid
    mxGeometry geom = splitBlock.getGeometry();
    double x = snap(splitPoint.getX()) - (SplitBlock.DEFAULT_SIZE / 2.);
    double y = snap(splitPoint.getY()) - (SplitBlock.DEFAULT_SIZE / 2.);
    geom.setX(x);
    geom.setY(y);
    splitBlock.setGeometry(geom);
    getModel().beginUpdate();
    try {
        // Origin of the parent, (0,0) as default may be different in case
        mxPoint orig = link.getParent().getGeometry();
        if (orig == null) {
            orig = new mxPoint();
        }
        addCell(splitBlock);
        // Update old link
        // get breaking segment and related point
        mxPoint splitTr = new mxPoint(splitPoint.getX() - orig.getX(), splitPoint.getY() - orig.getY());
        final int pos = link.findNearestSegment(splitTr);
        // save points after breaking point
        final List<mxPoint> saveStartPoints = link.getPoints(pos, true);
        final List<mxPoint> saveEndPoints = link.getPoints(pos, false);
        // position
        if (saveEndPoints.size() > 0) {
            final mxPoint p = saveEndPoints.get(0);
            final double dx = p.getX() - splitTr.getX();
            final double dy = p.getY() - splitTr.getY();
            if (!getAsComponent().isSignificant(dx, dy)) {
                saveEndPoints.remove(0);
            }
        }
        getModel().remove(link);
        connect(linkSource, splitBlock.getIn(), saveStartPoints, orig);
        connect(splitBlock.getOut1(), linkTarget, saveEndPoints, orig);
        refresh();
    } finally {
        getModel().endUpdate();
    }
    return splitBlock;
}
#end_block

#method_before
private String getToolTipForCell(final BasicBlock o) {
    JavaController controller = new JavaController();
    String[] strValue = { "" };
    VectorOfDouble vecValue = new VectorOfDouble();
    StringBuilder result = new StringBuilder();
    result.append(ScilabGraphConstants.HTML_BEGIN);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.INTERFACE_FUNCTION, strValue);
    result.append("Block Name : ").append(strValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.SIM_FUNCTION_NAME, strValue);
    result.append("Simulation : ").append(strValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.UID, strValue);
    result.append("UID : ").append(strValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.STYLE, strValue);
    result.append("Style : ");
    appendReduced(result, strValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.RPAR, vecValue);
    result.append("RPar : ");
    appendReduced(result, ScilabTypeCoder.toString(vecValue)).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.IPAR, vecValue);
    result.append("IPar : ");
    appendReduced(result, ScilabTypeCoder.toString(vecValue)).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.OPAR, vecValue);
    result.append("OPar : ");
    appendReduced(result, ScilabTypeCoder.toString(vecValue)).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_END);
    return result.toString();
}
#method_after
private String getToolTipForCell(final BasicBlock o) {
    JavaController controller = new JavaController();
    String[] strValue = { "" };
    VectorOfDouble vecValue = new VectorOfDouble();
    StringBuilder result = new StringBuilder();
    result.append(ScilabGraphConstants.HTML_BEGIN);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.INTERFACE_FUNCTION, strValue);
    result.append(XcosMessages.TOOLTIP_BLOCK).append(ScilabGraphConstants.HTML_BEGIN_CODE).append(strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.SIM_FUNCTION_NAME, strValue);
    result.append(XcosMessages.TOOLTIP_BLOCK_SIMULATION).append(ScilabGraphConstants.HTML_BEGIN_CODE).append(strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.UID, strValue);
    result.append(XcosMessages.TOOLTIP_BLOCK_UID).append(ScilabGraphConstants.HTML_BEGIN_CODE).append(strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.STYLE, strValue);
    result.append(XcosMessages.TOOLTIP_BLOCK_STYLE).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    appendReduced(result, strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.RPAR, vecValue);
    result.append(XcosMessages.TOOLTIP_BLOCK_RPAR).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    appendReduced(result, ScilabTypeCoder.toString(vecValue)).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.IPAR, vecValue);
    result.append(XcosMessages.TOOLTIP_BLOCK_IPAR).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    appendReduced(result, ScilabTypeCoder.toString(vecValue)).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.OPAR, vecValue);
    result.append(XcosMessages.TOOLTIP_BLOCK_OPAR).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    appendReduced(result, ScilabTypeCoder.toString(vecValue)).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_END);
    return result.toString();
}
#end_block

#method_before
private String getToolTipForCell(final BasicPort o) {
    JavaController controller = new JavaController();
    boolean[] boolValue = { false };
    String[] strValue = { "" };
    VectorOfInt intVecValue = new VectorOfInt();
    StringBuilder result = new StringBuilder();
    result.append(ScilabGraphConstants.HTML_BEGIN);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.DATATYPE, intVecValue);
    result.append("Datatype : ");
    formatDatatype(result, intVecValue).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.IMPLICIT, boolValue);
    result.append("Implicit : ").append(boolValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.STYLE, strValue);
    result.append("Style : ");
    appendReduced(result, strValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_END);
    return result.toString();
}
#method_after
private String getToolTipForCell(final BasicPort o) {
    JavaController controller = new JavaController();
    boolean[] boolValue = { false };
    String[] strValue = { "" };
    VectorOfInt intVecValue = new VectorOfInt();
    StringBuilder result = new StringBuilder();
    result.append(ScilabGraphConstants.HTML_BEGIN);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.DATATYPE, intVecValue);
    result.append(XcosMessages.TOOLTIP_PORT_DATATYPE).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    formatDatatype(result, intVecValue).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.IMPLICIT, boolValue);
    result.append(XcosMessages.TOOLTIP_PORT_IMPLICIT).append(ScilabGraphConstants.HTML_BEGIN_CODE).append(boolValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.STYLE, strValue);
    result.append(XcosMessages.TOOLTIP_PORT_STYLE).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    appendReduced(result, strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_END);
    return result.toString();
}
#end_block

#method_before
private String getToolTipForCell(final BasicLink o) {
    JavaController controller = new JavaController();
    long[] longValue = { 0l };
    boolean[] boolValue = { false };
    String[] strValue = { "" };
    VectorOfInt intVecValue = new VectorOfInt();
    StringBuilder result = new StringBuilder();
    result.append(ScilabGraphConstants.HTML_BEGIN);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.SOURCE_PORT, longValue);
    if (longValue[0] != 0l) {
        controller.getObjectProperty(longValue[0], Kind.PORT, ObjectProperties.DATATYPE, intVecValue);
        result.append("Source datatype : ");
        formatDatatype(result, intVecValue).append(ScilabGraphConstants.HTML_NEWLINE);
    }
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.DESTINATION_PORT, longValue);
    if (longValue[0] != 0l) {
        controller.getObjectProperty(longValue[0], Kind.PORT, ObjectProperties.DATATYPE, intVecValue);
        result.append("Target datatype : ");
        formatDatatype(result, intVecValue).append(ScilabGraphConstants.HTML_NEWLINE);
    }
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.IMPLICIT, boolValue);
    result.append("Label : ").append(boolValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.STYLE, strValue);
    result.append("Style : ");
    appendReduced(result, strValue[0]).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_END);
    return result.toString();
}
#method_after
private String getToolTipForCell(final BasicLink o) {
    JavaController controller = new JavaController();
    long[] longValue = { 0l };
    boolean[] boolValue = { false };
    String[] strValue = { "" };
    VectorOfInt intVecValue = new VectorOfInt();
    StringBuilder result = new StringBuilder();
    result.append(ScilabGraphConstants.HTML_BEGIN);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.SOURCE_PORT, longValue);
    if (longValue[0] != 0l) {
        controller.getObjectProperty(longValue[0], Kind.PORT, ObjectProperties.DATATYPE, intVecValue);
        result.append(XcosMessages.TOOLTIP_LINK_SRC_DATATYPE).append(ScilabGraphConstants.HTML_BEGIN_CODE);
        formatDatatype(result, intVecValue).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    }
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.DESTINATION_PORT, longValue);
    if (longValue[0] != 0l) {
        controller.getObjectProperty(longValue[0], Kind.PORT, ObjectProperties.DATATYPE, intVecValue);
        result.append(XcosMessages.TOOLTIP_LINK_TRG_DATATYPE).append(ScilabGraphConstants.HTML_BEGIN_CODE);
        formatDatatype(result, intVecValue).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    }
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.LABEL, strValue);
    result.append(XcosMessages.TOOLTIP_LINK_LABEL).append(ScilabGraphConstants.HTML_BEGIN_CODE).append(strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    controller.getObjectProperty(o.getUID(), o.getKind(), ObjectProperties.STYLE, strValue);
    result.append(XcosMessages.TOOLTIP_LINK_STYLE).append(ScilabGraphConstants.HTML_BEGIN_CODE);
    appendReduced(result, strValue[0]).append(ScilabGraphConstants.HTML_END_CODE).append(ScilabGraphConstants.HTML_NEWLINE);
    result.append(ScilabGraphConstants.HTML_END);
    return result.toString();
}
#end_block

