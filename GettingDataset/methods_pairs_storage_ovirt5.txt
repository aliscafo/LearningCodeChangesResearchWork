890
#method_before
protected void updateCurrentCd(String cdPath) {
    cdPath = cdPath.isEmpty() ? null : cdPath;
    VmHandler.updateCurrentCd(getVdsId(), getVm(), cdPath);
}
#method_after
protected void updateCurrentCd(String cdPath) {
    cdPath = StringUtils.isEmpty(cdPath) ? null : cdPath;
    VmHandler.updateCurrentCd(getVdsId(), getVm(), cdPath);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setBoot(getParameters().getDiskInfo().isBoot());
    newDiskImage.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setvolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(() -> {
        if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
        } else {
            addDiskImageToDb(newDiskImage, null, Boolean.TRUE);
            getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
        }
        return null;
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setVolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(() -> {
        if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
        } else {
            addDiskImageToDb(newDiskImage, null, Boolean.TRUE);
            getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
        }
        return null;
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#end_block

#method_before
protected boolean processImageInIrs() {
    if (isDataCenterWithSpm()) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, getCreateImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
            getTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            return true;
        }
    } else {
        CreateVolumeParameters createVolumeParameters = new CreateVolumeParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getDestinationImageId(), Guid.Empty, Guid.Empty, getParameters().getDiskInfo().getSize(), getInitialSize().orElse(null), getParameters().getDiskInfo().getVolumeFormat(), getParameters().getDiskInfo().getVolumeType(), getJsonDiskDescription(getParameters().getDiskInfo()));
        createVolumeParameters.setParentCommand(getActionType());
        createVolumeParameters.setParentParameters(getParameters());
        createVolumeParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        runInternalAction(VdcActionType.CreateVolume, createVolumeParameters);
        return true;
    }
    return false;
}
#method_after
protected boolean processImageInIrs() {
    if (isDataCenterWithSpm()) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, getCreateImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
            getTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            return true;
        }
    } else {
        runInternalAction(VdcActionType.CreateVolume, getCreateVolumeParameters());
        return true;
    }
    return false;
}
#end_block

#method_before
private Optional<Long> getInitialSize() {
    DiskImage diskImage = getParameters().getDiskInfo();
    Long initialSize = null;
    if (getStorageDomain().getStorageType().isBlockDomain() && diskImage.getImage().getVolumeType().equals(VolumeType.Sparse) && diskImage.getActualSizeInBytes() != 0) {
        initialSize = diskImage.getActualSizeInBytes();
    }
    return Optional.ofNullable(initialSize);
}
#method_after
private Long getInitialSize() {
    DiskImage diskImage = getParameters().getDiskInfo();
    Long initialSize = null;
    if (getStorageDomain().getStorageType().isBlockDomain() && diskImage.getImage().getVolumeType().equals(VolumeType.Sparse) && diskImage.getActualSizeInBytes() != 0) {
        initialSize = diskImage.getActualSizeInBytes();
    }
    return initialSize;
}
#end_block

#method_before
private CreateImageVDSCommandParameters getCreateImageVDSCommandParameters() {
    CreateImageVDSCommandParameters parameters = new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription(getParameters().getDiskInfo()));
    parameters.setImageInitialSizeInBytes(getInitialSize().orElse(parameters.getImageInitialSizeInBytes()));
    return parameters;
}
#method_after
private CreateImageVDSCommandParameters getCreateImageVDSCommandParameters() {
    CreateImageVDSCommandParameters parameters = new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription(getParameters().getDiskInfo()));
    parameters.setImageInitialSizeInBytes(Optional.ofNullable(getInitialSize()).orElse(0L));
    return parameters;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.CreateVolumeContainer, new CreateVolumeVDSCommandParameters(getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getSize(), getParameters().getVolumeFormat(), getParameters().getImageId(), getParameters().getDescription(), getParameters().getSrcImageGroupId(), getParameters().getSrcImageId()), getParameters().getStoragePoolId(), this);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.CreateVolumeContainer, new CreateVolumeVDSCommandParameters(getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getSize(), getParameters().getVolumeFormat(), getParameters().getImageId(), getParameters().getDescription(), null, null), getParameters().getStoragePoolId(), this);
    setSucceeded(true);
}
#end_block

#method_before
private static HttpURLConnection create(URL url) throws IOException, GeneralSecurityException {
    return new HttpURLConnectionBuilder(url).setHttpsProtocol(EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_SERVICE_SSL_PROTOCOL")).setReadTimeout(0).setTrustManagerAlgorithm(TrustManagerFactory.getDefaultAlgorithm()).setTrustStore(EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_PKI_TRUST_STORE")).setTrustStorePassword(EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_PKI_TRUST_STORE_PASSWORD")).setTrustStoreType(EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_PKI_TRUST_STORE_TYPE")).setURL(url).setVerifyChain(EngineLocalConfig.getInstance().getBoolean("ENGINE_SSO_SERVICE_SSL_VERIFY_CHAIN")).setVerifyHost(EngineLocalConfig.getInstance().getBoolean("ENGINE_SSO_SERVICE_SSL_VERIFY_HOST")).create();
}
#method_after
private static HttpURLConnection create(URL url) throws IOException, GeneralSecurityException {
    return new HttpURLConnectionBuilder(url).setHttpsProtocol(EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_SERVICE_SSL_PROTOCOL")).setReadTimeout(0).setTrustManagerAlgorithm(TrustManagerFactory.getDefaultAlgorithm()).setTrustStore(EngineLocalConfig.getInstance().getProperty("ENGINE_HTTPS_PKI_TRUST_STORE")).setTrustStorePassword(EngineLocalConfig.getInstance().getProperty("ENGINE_HTTPS_PKI_TRUST_STORE_PASSWORD")).setTrustStoreType(EngineLocalConfig.getInstance().getProperty("ENGINE_HTTPS_PKI_TRUST_STORE_TYPE")).setURL(url).setVerifyChain(EngineLocalConfig.getInstance().getBoolean("ENGINE_SSO_SERVICE_SSL_VERIFY_CHAIN")).setVerifyHost(EngineLocalConfig.getInstance().getBoolean("ENGINE_SSO_SERVICE_SSL_VERIFY_HOST")).create();
}
#end_block

#method_before
private void fillSpice(ConsoleOptions options) {
    GraphicsInfo graphicsInfo = getCachedVm().getGraphicsInfos().get(options.getGraphicsType());
    options.setSmartcardEnabled(getCachedVm().isSmartcardEnabled());
    options.setNumberOfMonitors(getCachedVm().getNumOfMonitors());
    options.setGuestHostName(getCachedVm().getVmHost().split("[ ]", -1)[0]);
    if (graphicsInfo.getTlsPort() != null) {
        options.setSecurePort(graphicsInfo.getTlsPort());
    }
    if (this.<Boolean>getConfigValue(ConfigValues.SSLEnabled)) {
        String spiceSecureChannels = getConfigValue(ConfigValues.SpiceSecureChannels);
        if (!StringUtils.isBlank(spiceSecureChannels)) {
            options.setSslChanels(spiceSecureChannels);
        }
        String cipherSuite = getConfigValue(ConfigValues.CipherSuite);
        if (!StringUtils.isBlank(cipherSuite)) {
            options.setCipherSuite(cipherSuite);
        }
    }
    String certificateSubject = "";
    String caCertificate = "";
    if (this.<Boolean>getConfigValue(ConfigValues.EnableSpiceRootCertificateValidation)) {
        VdcQueryReturnValue certificate = getCACertificate();
        if (!certificate.getSucceeded()) {
            getQueryReturnValue().setExceptionString("Spice Root Certificate Validation enforced, but no CA found!");
            getQueryReturnValue().setSucceeded(false);
            return;
        }
        certificateSubject = getVdsCertificateSubject();
        caCertificate = certificate.getReturnValue();
    }
    boolean customHttpsCertificateUsed = Objects.equals(EngineLocalConfig.getInstance().getPKITrustStorePath(), EngineLocalConfig.getInstance().getHttpsPKITrustStorePath());
    options.setCustomHttpsCertificateUsed(!customHttpsCertificateUsed);
    options.setHostSubject(certificateSubject);
    options.setTrustStore(caCertificate);
    options.setSpiceProxy(determineSpiceProxy());
    // Update 'UsbListenPort' value
    boolean getIsUsbEnabled = getConfigValue(ConfigValues.EnableUSBAsDefault);
    options.setUsbListenPort(getIsUsbEnabled && getCachedVm().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? ConsoleOptions.SPICE_USB_DEFAULT_PORT : ConsoleOptions.SET_SPICE_DISABLE_USB_LISTEN_PORT);
}
#method_after
private void fillSpice(ConsoleOptions options) {
    GraphicsInfo graphicsInfo = getCachedVm().getGraphicsInfos().get(options.getGraphicsType());
    options.setSmartcardEnabled(getCachedVm().isSmartcardEnabled());
    options.setNumberOfMonitors(getCachedVm().getNumOfMonitors());
    options.setGuestHostName(getCachedVm().getVmHost().split("[ ]", -1)[0]);
    if (graphicsInfo.getTlsPort() != null) {
        options.setSecurePort(graphicsInfo.getTlsPort());
    }
    if (this.<Boolean>getConfigValue(ConfigValues.SSLEnabled)) {
        String spiceSecureChannels = getConfigValue(ConfigValues.SpiceSecureChannels);
        if (!StringUtils.isBlank(spiceSecureChannels)) {
            options.setSslChanels(spiceSecureChannels);
        }
        String cipherSuite = getConfigValue(ConfigValues.CipherSuite);
        if (!StringUtils.isBlank(cipherSuite)) {
            options.setCipherSuite(cipherSuite);
        }
    }
    String certificateSubject = "";
    String caCertificate = "";
    if (this.<Boolean>getConfigValue(ConfigValues.EnableSpiceRootCertificateValidation)) {
        VdcQueryReturnValue certificate = getCACertificate();
        if (!certificate.getSucceeded()) {
            getQueryReturnValue().setExceptionString("Spice Root Certificate Validation enforced, but no CA found!");
            getQueryReturnValue().setSucceeded(false);
            return;
        }
        certificateSubject = getVdsCertificateSubject();
        caCertificate = certificate.getReturnValue();
    }
    options.setCustomHttpsCertificateUsed(!Objects.equals(EngineLocalConfig.getInstance().getPKITrustStorePath(), EngineLocalConfig.getInstance().getHttpsPKITrustStorePath()));
    options.setHostSubject(certificateSubject);
    options.setTrustStore(caCertificate);
    options.setSpiceProxy(determineSpiceProxy());
    // Update 'UsbListenPort' value
    boolean getIsUsbEnabled = getConfigValue(ConfigValues.EnableUSBAsDefault);
    options.setUsbListenPort(getIsUsbEnabled && getCachedVm().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? ConsoleOptions.SPICE_USB_DEFAULT_PORT : ConsoleOptions.SET_SPICE_DISABLE_USB_LISTEN_PORT);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String bond = null;
    List<String> nics = new ArrayList<>();
    String baseNicName = NetworkUtils.stripVlan(iface);
    nics.add(baseNicName);
    Integer vlanId = iface.getVlanId();
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    // vlan with bond
    boolean isBond = NetworkUtils.isBondVlan(interfaces, iface);
    // or just a bond...
    isBond = isBond || (iface.getBonded() != null && iface.getBonded());
    // check if bond...
    if (isBond) {
        nics.clear();
        bond = baseNicName;
        for (VdsNetworkInterface i : interfaces) {
            if (StringUtils.equals(i.getBondName(), bond)) {
                nics.add(NetworkUtils.stripVlan(i));
            }
        }
    }
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(getParameters().getVdsId(), getParameters().getNetwork().getName(), vlanId, bond, nics.toArray(new String[] {}), getParameters().getNetwork().getAddr(), getParameters().getNetwork().getSubnet(), getParameters().getNetwork().getGateway(), getParameters().getNetwork().getStp(), getParameters().getBondingOptions(), getParameters().getBootProtocol());
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.RemoveNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = runVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds()));
        if (retVal.getSucceeded()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    String bond = null;
    List<String> nics = new ArrayList<>();
    String baseNicName = NetworkUtils.stripVlan(iface);
    nics.add(baseNicName);
    Integer vlanId = iface.getVlanId();
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    // vlan with bond
    boolean isBond = NetworkUtils.isBondVlan(interfaces, iface);
    // or just a bond...
    isBond = isBond || (iface.getBonded() != null && iface.getBonded());
    // check if bond...
    if (isBond) {
        nics.clear();
        bond = baseNicName;
        for (VdsNetworkInterface i : interfaces) {
            if (StringUtils.equals(i.getBondName(), bond)) {
                nics.add(NetworkUtils.stripVlan(i));
            }
        }
    }
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(getParameters().getVdsId(), getParameters().getNetwork().getName(), vlanId, bond, nics.toArray(new String[nics.size()]), getParameters().getNetwork().getAddr(), getParameters().getNetwork().getSubnet(), getParameters().getNetwork().getGateway(), getParameters().getNetwork().getStp(), getParameters().getBondingOptions(), getParameters().getBootProtocol());
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.RemoveNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = runVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds()));
        if (retVal.getSucceeded()) {
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    iface = interfaces.stream().filter(i -> i.getName().equals(getParameters().getInterface().getName())).findFirst().orElse(null);
    if (iface == null) {
        addValidationMessage(EngineMessage.NETWORK_INTERFACE_NOT_EXISTS);
        return false;
    }
    if (StringUtils.isEmpty(getParameters().getInterface().getNetworkName())) {
        getParameters().getInterface().setNetworkName(iface.getNetworkName());
    }
    // set the network object if we don't got in the parameters
    if (getParameters().getNetwork() == null || getParameters().getNetwork().getCluster() == null) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(getClusterId());
        for (Network n : networks) {
            if (n.getName().equals(iface.getNetworkName())) {
                getParameters().setNetwork(n);
                break;
            }
        }
    }
    if (StringUtils.isEmpty(iface.getNetworkName())) {
        if (iface.getBonded() != null && iface.getBonded() == true) {
            addValidationMessage(EngineMessage.NETWORK_BOND_NOT_ATTACH_TO_NETWORK);
        } else {
            addValidationMessage(EngineMessage.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        }
        return false;
    } else if (!StringUtils.equals(getParameters().getInterface().getNetworkName(), getParameters().getNetwork().getName())) {
        addValidationMessage(EngineMessage.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        return false;
    }
    VDS vds = getVdsDao().get(getParameters().getVdsId());
    // check if network in cluster and vds active
    if ((vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.Installing) && getParameters().getNetwork().getCluster() != null && getParameters().getNetwork().getCluster().getStatus() == NetworkStatus.OPERATIONAL) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(vds.getClusterId());
        if (networks.stream().anyMatch(network -> network.getName().equals(getParameters().getNetwork().getName()))) {
            addValidationMessage(EngineMessage.NETWORK_HOST_IS_BUSY);
            return false;
        }
    }
    List<String> vmNames = new VmInterfaceManager(getMacPool()).findActiveVmsUsingNetworks(vds.getId(), Collections.singletonList(getParameters().getNetwork().getName()));
    if (!vmNames.isEmpty()) {
        addValidationMessage(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS);
        addValidationMessageVariable("networkNames", getParameters().getNetwork().getName());
        addValidationMessageVariable(String.format("$%s_LIST", EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS.name()), StringUtils.join(vmNames, ","));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    iface = interfaces.stream().filter(i -> i.getName().equals(getParameters().getInterface().getName())).findFirst().orElse(null);
    if (iface == null) {
        addValidationMessage(EngineMessage.NETWORK_INTERFACE_NOT_EXISTS);
        return false;
    }
    if (StringUtils.isEmpty(getParameters().getInterface().getNetworkName())) {
        getParameters().getInterface().setNetworkName(iface.getNetworkName());
    }
    VDS vds = getVdsDao().get(getParameters().getVdsId());
    Guid clusterId = vds.getClusterId();
    setClusterId(clusterId);
    // set the network object if we don't got in the parameters
    if (getParameters().getNetwork() == null || getParameters().getNetwork().getCluster() == null) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(clusterId);
        for (Network n : networks) {
            if (n.getName().equals(iface.getNetworkName())) {
                getParameters().setNetwork(n);
                break;
            }
        }
    }
    String networkName = getParameters().getNetwork().getName();
    if (StringUtils.isEmpty(iface.getNetworkName())) {
        if (iface.getBonded() != null && iface.getBonded() == true) {
            addValidationMessage(EngineMessage.NETWORK_BOND_NOT_ATTACH_TO_NETWORK);
        } else {
            addValidationMessage(EngineMessage.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        }
        return false;
    } else if (!StringUtils.equals(getParameters().getInterface().getNetworkName(), networkName)) {
        addValidationMessage(EngineMessage.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        return false;
    }
    // check if network in cluster and vds active
    if ((vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.Installing) && getParameters().getNetwork().getCluster() != null && getParameters().getNetwork().getCluster().getStatus() == NetworkStatus.OPERATIONAL) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(vds.getClusterId());
        if (networks.stream().anyMatch(network -> network.getName().equals(networkName))) {
            addValidationMessage(EngineMessage.NETWORK_HOST_IS_BUSY);
            return false;
        }
    }
    List<String> vmNames = findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(vds.getId(), networkName);
    if (!vmNames.isEmpty()) {
        addValidationMessage(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS);
        addValidationMessageVariable("networkNames", networkName);
        addValidationMessageVariable(String.format("$%s_LIST", EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS.name()), StringUtils.join(vmNames, ","));
        return false;
    }
    return true;
}
#end_block

#method_before
protected void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool(vm.getClusterId()));
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getClusterId(), vm.getStoragePoolId(), vm.getClusterCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getClusterCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#method_after
protected void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user) {
    MacPoolManagerStrategy macPool = poolPerCluster.poolForCluster(vm.getClusterId());
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getClusterId(), vm.getStoragePoolId(), vm.getClusterCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getClusterCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#end_block

#method_before
public ValidationResult notRemovingUsedPool() {
    final ClusterDao clusterDao = getDbFacade().getClusterDao();
    final List<Cluster> clusters = clusterDao.getAllClustersByMacPoolId(macPool.getId());
    final Collection<String> replacements = ReplacementUtils.replaceWithNameable("DATACENTERS_USING_MAC_POOL", clusters);
    replacements.add(EngineMessage.VAR__ENTITIES__DATA_CENTERS.name());
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_STILL_USED_MAC_POOL, replacements.toArray(new String[replacements.size()])).when(clusters.size() != 0);
}
#method_after
public ValidationResult notRemovingUsedPool() {
    final ClusterDao clusterDao = getDbFacade().getClusterDao();
    final List<Cluster> clusters = clusterDao.getAllClustersByMacPoolId(macPool.getId());
    final Collection<String> replacements = ReplacementUtils.replaceWithNameable("CLUSTERS_USING_MAC_POOL", clusters);
    replacements.add(EngineMessage.VAR__ENTITIES__CLUSTERS.name());
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_STILL_USED_MAC_POOL, replacements.toArray(new String[replacements.size()])).when(clusters.size() != 0);
}
#end_block

#method_before
private Guid getNewMacPoolId() {
    final Cluster cluster = getParameters().getCluster();
    return cluster == null ? null : cluster.getMacPoolId();
}
#method_after
private Guid getNewMacPoolId() {
    final Cluster cluster = getCluster();
    return cluster == null ? null : cluster.getMacPoolId();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oldMacPoolId = oldGroup.getMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId());
    getCluster().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getClusterId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getCluster().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getCluster().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDao().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    getClusterDao().update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDao().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId());
    getCluster().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getClusterId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getCluster().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getCluster().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDao().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    getClusterDao().update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDao().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Cluster cluster = getCluster();
    cluster.setArchitecture(getArchitecture());
    checkMaxMemoryOverCommitValue();
    cluster.setDetectEmulatedMachine(true);
    cluster.setMacPoolId(calculateMacPoolIdToUse(cluster.getMacPoolId()));
    clusterDao.save(cluster);
    alertIfFencingDisabled();
    // add default network
    if (getParameters().getCluster().getStoragePoolId() != null) {
        attachManagementNetwork();
    }
    // create default CPU profile for supported clusters.
    if (FeatureSupported.cpuQoS(getParameters().getCluster().getCompatibilityVersion())) {
        getCpuProfileDao().save(CpuProfileHelper.createCpuProfile(getParameters().getCluster().getId(), getParameters().getCluster().getName()));
    }
    if (CollectionUtils.isNotEmpty(cluster.getAddtionalFeaturesSupported())) {
        for (SupportedAdditionalClusterFeature feature : cluster.getAddtionalFeaturesSupported()) {
            feature.setClusterId(cluster.getId());
        }
        clusterFeatureDao.addAllSupportedClusterFeature(cluster.getAddtionalFeaturesSupported());
    }
    setActionReturnValue(cluster.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Cluster cluster = getCluster();
    cluster.setArchitecture(getArchitecture());
    checkMaxMemoryOverCommitValue();
    cluster.setDetectEmulatedMachine(true);
    cluster.setMacPoolId(calculateMacPoolIdToUse());
    clusterDao.save(cluster);
    alertIfFencingDisabled();
    // add default network
    if (getParameters().getCluster().getStoragePoolId() != null) {
        attachManagementNetwork();
    }
    // create default CPU profile for supported clusters.
    if (FeatureSupported.cpuQoS(getParameters().getCluster().getCompatibilityVersion())) {
        getCpuProfileDao().save(CpuProfileHelper.createCpuProfile(getParameters().getCluster().getId(), getParameters().getCluster().getName()));
    }
    if (CollectionUtils.isNotEmpty(cluster.getAddtionalFeaturesSupported())) {
        for (SupportedAdditionalClusterFeature feature : cluster.getAddtionalFeaturesSupported()) {
            feature.setClusterId(cluster.getId());
        }
        clusterFeatureDao.addAllSupportedClusterFeature(cluster.getAddtionalFeaturesSupported());
    }
    setActionReturnValue(cluster.getId());
    setSucceeded(true);
}
#end_block

#method_before
private Guid calculateMacPoolIdToUse() {
    return calculateMacPoolIdToUse(null);
}
#method_after
private Guid calculateMacPoolIdToUse() {
    Cluster cluster = getCluster();
    Guid requestedMacPoolId = cluster == null ? null : cluster.getMacPoolId();
    return requestedMacPoolId == null ? macPoolDao.getDefaultPool().getId() : requestedMacPoolId;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Arrays.asList(new PermissionSubject(getCluster().getStoragePoolId(), VdcObjectType.StoragePool, getActionType().getActionGroup()), new PermissionSubject(calculateMacPoolIdToUse(null), VdcObjectType.MacPool, ActionGroup.CONFIGURE_MAC_POOL));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Arrays.asList(new PermissionSubject(getCluster().getStoragePoolId(), VdcObjectType.StoragePool, getActionType().getActionGroup()), new PermissionSubject(calculateMacPoolIdToUse(), VdcObjectType.MacPool, ActionGroup.CONFIGURE_MAC_POOL));
}
#end_block

#method_before
protected void setUpCommand() {
    command = createCommand();
    command.poolPerCluster = macPoolPerCluster;
    doReturn(true).when(command).areTemplateImagesInStorageReady(any(Guid.class));
    doReturn(true).when(command).verifyAddVM();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).setAndValidateCpuProfile();
}
#method_after
protected void setUpCommand() {
    command = createCommand();
    doReturn(true).when(command).areTemplateImagesInStorageReady(any(Guid.class));
    doReturn(true).when(command).verifyAddVM();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).setAndValidateCpuProfile();
}
#end_block

#method_before
protected MacPoolManagerStrategy getMacPool() {
    if (macPool == null) {
        macPool = poolPerCluster.poolForCluster(getStoragePoolId());
    }
    return macPool;
}
#method_after
protected MacPoolManagerStrategy getMacPool() {
    if (macPool == null) {
        macPool = poolPerCluster.poolForCluster(getClusterId());
    }
    return macPool;
}
#end_block

#method_before
// TODO MM: dear code reviewer. I don't want rely on subclasses to filling pool reference themselves to make sure,
// that future queries will not forget to fill it. Design around VdcQueryReturnValue.returnValue does not leave many
// options. I can rewrite this using two class hierarchies or two template methods+boolean flag. If you know about
private void setMacPoolReference(Object dataCenterQueryResult) {
    if (dataCenterQueryResult == null) {
        return;
    }
    if (dataCenterQueryResult instanceof StoragePool) {
        dataCenterQueryResult((StoragePool) dataCenterQueryResult);
        return;
    }
    if (dataCenterQueryResult instanceof Iterable) {
        try {
            // noinspection unchecked
            for (StoragePool storagePool : (Iterable<StoragePool>) dataCenterQueryResult) {
                dataCenterQueryResult(storagePool);
            }
        } catch (ClassCastException e) {
            unsupportedQueryResult();
        }
        return;
    }
    unsupportedQueryResult();
}
#method_after
// TODO MM: dear code reviewer. I don't want rely on subclasses to filling pool reference themselves to make sure,
// that future queries will not forget to fill it. Design around VdcQueryReturnValue.returnValue does not leave many
// options. I can rewrite this using two class hierarchies or two template methods+boolean flag. If you know about
private void setMacPoolReference(Object dataCenterQueryResult) {
    if (dataCenterQueryResult == null) {
        return;
    }
    if (dataCenterQueryResult instanceof StoragePool) {
        dataCenterQueryResult((StoragePool) dataCenterQueryResult);
        return;
    }
    if (dataCenterQueryResult instanceof Iterable) {
        // noinspection unchecked
        for (StoragePool storagePool : (Iterable<StoragePool>) dataCenterQueryResult) {
            dataCenterQueryResult(storagePool);
        }
        return;
    }
    throw new IllegalArgumentException("Unsupported query result");
}
#end_block

#method_before
protected MacPoolManagerStrategy getMacPool() {
    return poolPerCluster.poolForCluster(getClusterId());
}
#method_after
protected MacPoolManagerStrategy getMacPool(Guid clusterId) {
    return poolPerCluster.poolForCluster(clusterId);
}
#end_block

#method_before
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        MacPoolManagerStrategy macPool = getMacPool();
        for (VmNic iface : getInterfaces()) {
            macPool.freeMac(iface.getMacAddress());
        }
    }
}
#method_after
protected void removeVmNetwork(MacPoolManagerStrategy macPool) {
    if (getInterfaces() != null) {
        for (VmNic iface : getInterfaces()) {
            macPool.freeMac(iface.getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<String> macsToRemove = getVmNicDao().getAllMacsByDataCenter(getStoragePool().getId());
    removeNetworks();
    /**
     * Detach master storage domain last.
     */
    List<StorageDomain> storageDomains = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getStorageDomainType));
    if (storageDomains.size() > 0) {
        if (!getParameters().getForceDelete() && getAllRunningVdssInPool().size() > 0) {
            if (!regularRemoveStorageDomains(storageDomains)) {
                setSucceeded(false);
                return;
            }
        } else if (getParameters().getForceDelete()) {
            forceRemoveStorageDomains(storageDomains);
        } else {
            return;
        }
    }
    getMacPool().freeMacs(macsToRemove);
    removeDataCenter();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Map<Guid, List<String>> clusterIdToClusterMacsToRemove = getMacsToRemove();
    removeNetworks();
    /**
     * Detach master storage domain last.
     */
    List<StorageDomain> storageDomains = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getStorageDomainType));
    if (storageDomains.size() > 0) {
        if (!getParameters().getForceDelete() && getAllRunningVdssInPool().size() > 0) {
            if (!regularRemoveStorageDomains(storageDomains)) {
                setSucceeded(false);
                return;
            }
        } else if (getParameters().getForceDelete()) {
            forceRemoveStorageDomains(storageDomains);
        } else {
            return;
        }
    }
    for (Map.Entry<Guid, List<String>> entry : clusterIdToClusterMacsToRemove.entrySet()) {
        Guid clusterId = entry.getKey();
        List<String> macs = entry.getValue();
        poolPerCluster.poolForCluster(clusterId).freeMacs(macs);
    }
    removeDataCenter();
    setSucceeded(true);
}
#end_block

#method_before
public void onSave(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (!model.validate()) {
        return;
    }
    if (!model.getIsPm().getEntity()) {
        if (model.getCluster().getSelectedItem().supportsVirtService()) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().powerManagementConfigurationTitle());
            confirmModel.setHelpTag(HelpTag.power_management_configuration);
            // $NON-NLS-1$
            confirmModel.setHashName("power_management_configuration");
            confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youHavntConfigPmMsg());
            // $NON-NLS-1$ //$NON-NLS-2$
            UICommand approveCommand = UICommand.createDefaultOkUiCommand(approveInitiated ? "OnSaveInternalFromApprove" : "OnSaveInternalNotFromApprove", this);
            confirmModel.getCommands().add(approveCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = new UICommand("CancelConfirmFocusPM", this);
            cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().configurePowerManagement());
            cancelCommand.setIsCancel(true);
            confirmModel.getCommands().add(cancelCommand);
        } else {
            if (approveInitiated) {
                onSaveInternalFromApprove();
            } else {
                onSaveInternalNotFromApprove();
            }
        }
    } else {
        onSaveInternal(approveInitiated);
    }
}
#method_after
public void onSave(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (!model.validate()) {
        return;
    }
    if (!model.getIsPm().getEntity() && model.getFencingEnabled().getEntity()) {
        if (model.getCluster().getSelectedItem().supportsVirtService()) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().powerManagementConfigurationTitle());
            confirmModel.setHelpTag(HelpTag.power_management_configuration);
            // $NON-NLS-1$
            confirmModel.setHashName("power_management_configuration");
            confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youHavntConfigPmMsg());
            // $NON-NLS-1$ //$NON-NLS-2$
            UICommand approveCommand = UICommand.createDefaultOkUiCommand(approveInitiated ? "OnSaveInternalFromApprove" : "OnSaveInternalNotFromApprove", this);
            confirmModel.getCommands().add(approveCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = new UICommand("CancelConfirmFocusPM", this);
            cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().configurePowerManagement());
            cancelCommand.setIsCancel(true);
            confirmModel.getCommands().add(cancelCommand);
        } else {
            if (approveInitiated) {
                onSaveInternalFromApprove();
            } else {
                onSaveInternalNotFromApprove();
            }
        }
    } else {
        onSaveInternal(approveInitiated);
    }
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(model.getProtocol().getEntity() ? VdsProtocol.STOMP : VdsProtocol.XML);
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(model.getProtocol().getEntity() ? VdsProtocol.STOMP : VdsProtocol.XML);
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#end_block

#method_before
public void stop() {
    // $NON-NLS-1$
    restart("OnStop");
}
#method_after
public void stop() {
    // $NON-NLS-1$
    stop("OnStop");
}
#end_block

#method_before
public void sshStop() {
    // $NON-NLS-1$
    restart("OnSshStop");
}
#method_after
public void sshStop() {
    // $NON-NLS-1$
    stop("OnSshStop");
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // Create/Edit/Remove Host operations
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // Remote management via SSH drop down
    List<ActionButtonDefinition<VDS>> sshSubActions = new LinkedList<>();
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshRestartCommand();
        }
    });
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.sshManagement(), sshSubActions, CommandLocation.OnlyFromToolBar));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions, CommandLocation.OnlyFromToolBar));
    // Other operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions, CommandLocation.OnlyFromToolBar));
    // Assign tags
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // Approve
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // Create/Edit/Remove Host operations
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Confirm rebooted host
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // Remote management via SSH drop down
    List<ActionButtonDefinition<VDS>> sshSubActions = new LinkedList<>();
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshRestartCommand();
        }
    });
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions));
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.sshManagement(), sshSubActions));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions));
    // Installation operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions));
    // Assign tags
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    // NUMA support
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
    }
    // Approve
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // Create/Edit/Remove Host operations
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // Maintenance operations drop down
    List<ActionButtonDefinition<VDS>> maintenanceSubActions = new LinkedList<>();
    // Maintenance button
    maintenanceSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    maintenanceSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    maintenanceSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        maintenanceSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    // Add maintenance menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.maintenanceHost(), maintenanceSubActions, CommandLocation.OnlyFromToolBar));
    // Storage operations drop down
    List<ActionButtonDefinition<VDS>> storageSubActions = new LinkedList<>();
    // Select as SPM button
    storageSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    storageSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add storage menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.storage(), storageSubActions, CommandLocation.OnlyFromToolBar));
    // Other operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.more(), moreSubActions, CommandLocation.OnlyFromToolBar));
    // Assign tags
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    // Approve
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // Create/Edit/Remove Host operations
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Confirm rebooted host
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions));
    // Installation operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions));
    // Assign tags
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    // NUMA support
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
    }
    // Approve
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
}
#end_block

#method_before
private void postGetAttachedTags(HostListModel<Void> hostListModel, TagListModel tagListModel) {
    if (hostListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(hostListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : hostListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            hostListModel.attachedTagsToEntities.put(tag.gettag_id(), count == hostListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(hostListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(hostListModel.getLastExecutedCommand().getName())) {
        hostListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(HostListModel<Void> hostListModel, TagListModel tagListModel) {
    if (hostListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(hostListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : hostListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            hostListModel.attachedTagsToEntities.put(tag.gettag_id(), count == hostListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(hostListModel.attachedTagsToEntities);
    } else if ("OnAssignTags".equals(hostListModel.getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        hostListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void onManualFence() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        FenceVdsManualyParameters parameters = new FenceVdsManualyParameters(true);
        parameters.setStoragePoolId(vds.getStoragePoolId());
        parameters.setVdsId(vds.getId());
        list.add(parameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.FenceVdsManualy, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
public void onManualFence() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        FenceVdsManualyParameters parameters = new FenceVdsManualyParameters(true);
        parameters.setStoragePoolId(vds.getStoragePoolId());
        parameters.setVdsId(vds.getId());
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.FenceVdsManualy, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getCompatibilityVersion().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<VDSGroup> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                VDSGroup cluster = clusterModel.getSelectedItem();
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
                if (jsonSupported) {
                    hostModel.getProtocol().setEntity(true);
                    hostModel.getProtocol().setIsChangeable(true);
                } else {
                    hostModel.getProtocol().setEntity(false);
                    hostModel.getProtocol().setIsChangeable(false);
                }
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(cancelCommand);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<VDSGroup> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getCompatibilityVersion().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<VDSGroup> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                VDSGroup cluster = clusterModel.getSelectedItem();
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
                if (jsonSupported) {
                    hostModel.getProtocol().setEntity(true);
                    hostModel.getProtocol().setIsChangeable(true);
                } else {
                    hostModel.getProtocol().setEntity(false);
                    hostModel.getProtocol().setIsChangeable(false);
                }
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(cancelCommand);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
                hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            hostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            hostModel.getCommands().add(cancelCommand);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangeable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            final EditHostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setSelectedCluster(host);
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
                hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            hostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            hostModel.getCommands().add(cancelCommand);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangeable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(getFenceAgents(model));
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setDeployHostedEngineAgent(model.getDeployHostedEngineAgent().getEntity());
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(getFenceAgents(model));
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getDeployHostedEngineAgent().getEntity(), model.getHeAgentGateway().getEntity()));
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    boolean force = model.getForce().getEntity();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new RemoveVdsParameters(vds.getId(), force));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    boolean force = model.getForce().getEntity();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new RemoveVdsParameters(vds.getId(), force));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
public void onMaintenance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    ArrayList<Guid> vdss = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getId());
    }
    list.add(new MaintenanceNumberOfVdssParameters(vdss, false, model.getReason().getEntity()));
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.MaintenanceNumberOfVdss, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#method_after
public void onMaintenance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    ArrayList<Guid> vdss = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getId());
    }
    list.add(new MaintenanceNumberOfVdssParameters(vdss, false, model.getReason().getEntity()));
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.MaintenanceNumberOfVdss, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#end_block

#method_before
public void install() {
    final VDS host = getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangeable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    model.getActivateHostAfterInstall().setEntity(true);
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#method_after
public void install() {
    final VDS host = getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress();
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangeable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    model.getActivateHostAfterInstall().setEntity(true);
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtNode())) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    param.setFenceAgents(host.getFenceAgents());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtNode())) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    param.setFenceAgents(host.getFenceAgents());
    /*
        TODO undeploying hosted engine components is currently
         un-supported by host-deploy. Once its supported the check should be dropped.
         */
    if (model.getDeployHostedEngineAgent().getEntity()) {
        param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getDeployHostedEngineAgent().getEntity(), model.getHeAgentGateway().getEntity()));
    }
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
public void onRestart() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new FenceVdsActionParameters(vds.getId()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RestartVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#method_after
public void onRestart() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new FenceVdsActionParameters(vds.getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RestartVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#end_block

#method_before
public void onStop() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new FenceVdsActionParameters(vds.getId()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.StopVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#method_after
public void onStop() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new FenceVdsActionParameters(vds.getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.StopVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#end_block

#method_before
private void configureLocalStorage2(ConfigureLocalStorageModel model) {
    String prefix = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.RhevhLocalFSPath);
    if (!StringHelper.isNullOrEmpty(prefix)) {
        EntityModel pathModel = model.getStorage().getPath();
        pathModel.setEntity(prefix);
        pathModel.setIsChangeable(false);
    }
    configureLocalStorage3(model);
}
#method_after
private void configureLocalStorage2(ConfigureLocalStorageModel model) {
    String prefix = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.RhevhLocalFSPath);
    if (!StringUtils.isEmpty(prefix)) {
        EntityModel<String> pathModel = model.getStorage().getPath();
        pathModel.setEntity(prefix);
        pathModel.setIsChangeable(false);
    }
    configureLocalStorage3(model);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(HostGeneralModel.requestEditEventDefinition)) {
        getEditWithPMemphasisCommand().execute();
    }
    if (ev.matchesDefinition(HostGeneralModel.requestGOToEventsTabEventDefinition)) {
        goToEventsTab();
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(HostGeneralModel.requestEditEventDefinition)) {
        getEditWithPMemphasisCommand().execute();
    }
    if (ev.matchesDefinition(HostGeneralModel.requestGOToEventsTabEventDefinition)) {
        goToEventsTab();
    }
}
#end_block

#method_before
@Override
protected void itemsCollectionChanged(Object sender, NotifyCollectionChangedEventArgs e) {
    super.itemsCollectionChanged(sender, e);
    // Try to select an item corresponding to the system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
        VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
        setSelectedItem(Linq.firstOrDefault(Linq.<VDS>cast(getItems()), new Linq.HostPredicate(host.getId())));
    }
}
#method_after
@Override
protected void itemsCollectionChanged(Object sender, NotifyCollectionChangedEventArgs<VDS> e) {
    super.itemsCollectionChanged(sender, e);
    // Try to select an item corresponding to the system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
        VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
        setSelectedItem(Linq.firstOrDefault(Linq.<VDS>cast(getItems()), new Linq.HostPredicate(host.getId())));
    }
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("status") || e.propertyName.equals("pm_enabled")) {
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status") || e.propertyName.equals("pm_enabled")) {
        // $NON-NLS-1$ //$NON-NLS-2$
        updateActionAvailability();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).isOvirtNode()));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    boolean installAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        installAvailability = host.getStatus() == VDSStatus.InstallFailed || host.getStatus() == VDSStatus.Maintenance;
    }
    getInstallCommand().setIsExecutionAllowed(installAvailability);
    boolean upgradeAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        upgradeAvailability = canUpgradeHost(host);
    }
    getUpgradeCommand().setIsExecutionAllowed(upgradeAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
    boolean numaVisible = false;
    if (getSelectedItem() != null) {
        numaVisible = getSelectedItem().isNumaSupport();
    }
    getNumaSupportCommand().setIsVisible(numaVisible);
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).isOvirtNode()));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    boolean installAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        installAvailability = host.getStatus() == VDSStatus.InstallFailed || host.getStatus() == VDSStatus.Maintenance;
    }
    getInstallCommand().setIsExecutionAllowed(installAvailability);
    boolean upgradeAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        upgradeAvailability = canUpgradeHost(host);
    }
    getUpgradeCommand().setIsExecutionAllowed(upgradeAvailability);
    getEnrollCertificateCommand().setIsExecutionAllowed(installAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
    boolean numaVisible = false;
    if (getSelectedItem() != null) {
        numaVisible = getSelectedItem().isNumaSupport();
    }
    getNumaSupportCommand().setIsVisible(numaVisible);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSelectAsSpmCommand()) {
        selectAsSPM();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getInstallCommand()) {
        install();
    } else if (command == getUpgradeCommand()) {
        upgrade();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (command == getNumaSupportCommand()) {
        numaSupport();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "OnManualFence".equals(command.getName())) {
        onManualFence();
    } else if (// $NON-NLS-1$
    "OnSaveFalse".equals(command.getName())) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    "OnSaveInternalFromApprove".equals(command.getName())) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    "OnSaveInternalNotFromApprove".equals(command.getName())) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "CancelConfirmFocusPM".equals(command.getName())) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnMaintenance".equals(command.getName())) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    "OnApprove".equals(command.getName())) {
        onApprove();
    } else if (// $NON-NLS-1$
    "OnInstall".equals(command.getName())) {
        onInstall();
    } else if (// $NON-NLS-1$
    "OnRestart".equals(command.getName())) {
        onRestart();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnConfigureLocalStorage".equals(command.getName())) {
        onConfigureLocalStorage();
    } else if (NumaSupportModel.SUBMIT_NUMA_SUPPORT.equals(command.getName())) {
        onNumaSupport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSelectAsSpmCommand()) {
        selectAsSPM();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getInstallCommand()) {
        install();
    } else if (command == getUpgradeCommand()) {
        upgrade();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (command == getEnrollCertificateCommand()) {
        enrollCertificate();
    } else if (command == getNumaSupportCommand()) {
        numaSupport();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("OnManualFence".equals(command.getName())) {
        // $NON-NLS-1$
        onManualFence();
    } else if ("OnSaveFalse".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveFalse();
    } else if ("OnSaveInternalFromApprove".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveInternalFromApprove();
    } else if ("OnSaveInternalNotFromApprove".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveInternalNotFromApprove();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("CancelConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirm();
    } else if ("CancelConfirmFocusPM".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmFocusPM();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnMaintenance".equals(command.getName())) {
        // $NON-NLS-1$
        onMaintenance();
    } else if ("OnApprove".equals(command.getName())) {
        // $NON-NLS-1$
        onApprove();
    } else if ("OnInstall".equals(command.getName())) {
        // $NON-NLS-1$
        onInstall();
    } else if ("OnRestart".equals(command.getName())) {
        // $NON-NLS-1$
        onRestart();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnConfigureLocalStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onConfigureLocalStorage();
    } else if (NumaSupportModel.SUBMIT_NUMA_SUPPORT.equals(command.getName())) {
        onNumaSupport();
    }
}
#end_block

#method_before
public EntityModel getPkSection() {
    return privatePkSection;
}
#method_after
public EntityModel<Void> getPkSection() {
    return privatePkSection;
}
#end_block

#method_before
private void setPkSection(EntityModel value) {
    privatePkSection = value;
}
#method_after
private void setPkSection(EntityModel<Void> value) {
    privatePkSection = value;
}
#end_block

#method_before
public String getPmProxyPreferences() {
    // Return null if power management is not enabled.
    if (!getIsPm().getEntity()) {
        return null;
    }
    // Pack back proxy items to the comma delimited string.
    StringBuilder builder = new StringBuilder();
    if (getPmProxyPreferencesList().getItems() != null) {
        List items = (List) getPmProxyPreferencesList().getItems();
        for (Object item : items) {
            builder.append(item);
            if (items.indexOf(item) < items.size() - 1) {
                // $NON-NLS-1$
                builder.append(",");
            }
        }
    }
    return builder.toString();
}
#method_after
public String getPmProxyPreferences() {
    // Return null if power management is not enabled.
    if (!getIsPm().getEntity()) {
        return null;
    }
    // Translate the preferences back into a comma separated string.
    StringBuilder builder = new StringBuilder();
    if (getPmProxyPreferencesList().getItems() != null) {
        Collection<EntityModel<String>> items = getPmProxyPreferencesList().getItems();
        for (EntityModel<String> item : items) {
            if (builder.length() > 0) {
                // $NON-NLS-1$
                builder.append(",");
            }
            builder.append(item.getEntity());
        }
    }
    return builder.toString();
}
#end_block

#method_before
public void setPmProxyPreferences(String value) {
    // Create list from the provided comma delimited string.
    // $NON-NLS-1$
    String[] array = value.split(",");
    List<String> list = new ArrayList<String>();
    for (String item : array) {
        list.add(item);
    }
    getPmProxyPreferencesList().setItems(list);
}
#method_after
public void setPmProxyPreferences(String value) {
    // Create list from the provided comma delimited string.
    // $NON-NLS-1$
    String[] array = value.split(",");
    List<EntityModel<String>> list = new ArrayList<>();
    for (String item : array) {
        EntityModel<String> model = new EntityModel<>();
        model.setEntity(item);
        list.add(model);
    }
    getPmProxyPreferencesList().setItems(list);
}
#end_block

#method_before
public ListModel<String> getPmProxyPreferencesList() {
    return pmProxyPreferencesList;
}
#method_after
public ListModel<EntityModel<String>> getPmProxyPreferencesList() {
    return pmProxyPreferencesList;
}
#end_block

#method_before
private void setPmProxyPreferencesList(ListModel<String> value) {
    pmProxyPreferencesList = value;
}
#method_after
private void setPmProxyPreferencesList(ListModel<EntityModel<String>> value) {
    pmProxyPreferencesList = value;
}
#end_block

#method_before
public ListModel<Provider> getProviders() {
    return privateProviders;
}
#method_after
public ListModel<Provider<OpenstackNetworkProviderProperties>> getProviders() {
    return privateProviders;
}
#end_block

#method_before
protected void setProviders(ListModel<Provider> value) {
    privateProviders = value;
}
#method_after
protected void setProviders(ListModel<Provider<OpenstackNetworkProviderProperties>> value) {
    privateProviders = value;
}
#end_block

#method_before
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangeable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangeable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangeable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangeable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangeable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangeable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangeable(isPm);
    getPmOptions().setIsChangeable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangeable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getInstance().getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getCompatibilityVersion().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                    getPmEncryptOptions().setIsAvailable(pmOptions.contains(PmEncryptOptions));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangeable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangeable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangeable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangeable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangeable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangeable(isPm);
    getPmSecondaryOptions().setIsChangeable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangeable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangeable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                    getPmSecondaryEncryptOptions().setIsAvailable(pmOptions.contains(PmEncryptOptions));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangeable(isPm);
    getPmSecondaryConcurrent().setIsChangeable(isPm);
    getPmKdumpDetection().setIsChangeable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#method_after
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    getPmProxyPreferencesList().setIsChangeable(getIsPm().getEntity());
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangeable(isPm);
    getFenceAgentListModel().setIsChangeable(isPm);
    // Update other PM fields.
    getPmKdumpDetection().setIsChangeable(isPm);
    getFenceAgentListModel().setIsChangeable(isPm);
    getFenceAgentListModel().setHost(this);
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                @SuppressWarnings("unchecked")
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                if (hostModel.getIsNew()) {
                    updateClusterList(hostModel, clusters);
                } else {
                    AsyncQuery architectureQuery = new AsyncQuery();
                    architectureQuery.setModel(new Object[] { hostModel, clusters });
                    architectureQuery.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Object[] objArray = (Object[]) model;
                            HostModel hostModel = (HostModel) objArray[0];
                            @SuppressWarnings("unchecked")
                            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                            ArchitectureType architecture = (ArchitectureType) returnValue;
                            ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                            for (VDSGroup cluster : clusters) {
                                if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                    filteredClusters.add(cluster);
                                }
                            }
                            updateClusterList(hostModel, filteredClusters);
                        }
                    };
                    AsyncDataProvider.getInstance().getHostArchitecture(architectureQuery, hostModel.getHostId());
                }
            }
        };
        AsyncDataProvider.getInstance().getClusterList(_asyncQuery);
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                @SuppressWarnings("unchecked")
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                if (hostModel.getIsNew()) {
                    updateClusterList(hostModel, clusters);
                } else {
                    AsyncQuery architectureQuery = new AsyncQuery();
                    architectureQuery.setModel(new Object[] { hostModel, clusters });
                    architectureQuery.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Object[] objArray = (Object[]) model;
                            HostModel hostModel = (HostModel) objArray[0];
                            @SuppressWarnings("unchecked")
                            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                            ArchitectureType architecture = (ArchitectureType) returnValue;
                            ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                            for (VDSGroup cluster : clusters) {
                                if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                    filteredClusters.add(cluster);
                                }
                            }
                            updateClusterList(hostModel, filteredClusters);
                        }
                    };
                    AsyncDataProvider.getInstance().getHostArchitecture(architectureQuery, hostModel.getHostId());
                }
                updatePmModels();
            }
        };
        AsyncDataProvider.getInstance().getClusterList(_asyncQuery);
    }
}
#end_block

#method_before
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getCompatibilityVersion());
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        getProtocol().setEntity(jsonSupported);
        getProtocol().setIsChangeable(jsonSupported);
        // Match the appropriate selected data center to the selected cluster, don't fire update events.
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
}
#method_after
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes);
            }
        }), cluster.getCompatibilityVersion());
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        if (!jsonSupported) {
            getProtocol().setEntity(jsonSupported);
        } else {
            getProtocol().setEntity(vdsProtocol == null ? jsonSupported : VdsProtocol.STOMP == vdsProtocol);
        }
        getProtocol().setIsChangeable(jsonSupported);
        // Match the appropriate selected data center to the selected cluster, don't fire update events.
        if (getDataCenter() != null && getDataCenter().getItems() != null) {
            for (StoragePool datacenter : getDataCenter().getItems()) {
                if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                    getDataCenter().setSelectedItem(datacenter, false);
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
private void updatePmTypeList(List<String> pmTypes, ListModel<String> model) {
    String pmType = model.getSelectedItem();
    model.setItems(pmTypes);
    if (pmTypes.contains(pmType)) {
        model.setSelectedItem(pmType);
    }
}
#method_after
private void updatePmTypeList(List<String> pmTypes) {
    getFenceAgentListModel().setPmTypes(pmTypes);
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().setIsValid(getExternalComputeResource().getSelectedItem() != null);
        getExternalHostGroups().setIsValid(getExternalHostGroups().getSelectedItem() != null);
    } else {
        getExternalComputeResource().setIsValid(true);
        getExternalHostGroups().setIsValid(true);
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().setIsValid(getExternalComputeResource().getSelectedItem() != null);
        getExternalHostGroups().setIsValid(getExternalHostGroups().getSelectedItem() != null);
    } else {
        getExternalComputeResource().setIsValid(true);
        getExternalHostGroups().setIsValid(true);
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean fenceAgentsValid = true;
    if (getIsPm().getEntity()) {
        fenceAgentsValid = getFenceAgentListModel().validate();
    }
    if (getDeployHostedEngineAgent().getEntity()) {
        getHeAgentGateway().validateEntity(new IValidation[] { new HostAddressValidation(true) });
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid() && getHeAgentGateway().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, fenceAgentsValid);
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsChangeable(editTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        FenceAgent primaryAgent = vds.getFenceAgents().get(0);
        // Set primary PM parameters.
        getManagementIp().setEntity(primaryAgent.getIp());
        getPmUserName().setEntity(primaryAgent.getUser());
        getPmPassword().setEntity(primaryAgent.getPassword());
        getPmType().setSelectedItem(primaryAgent.getType());
        if (primaryAgent.getPort() != null) {
            getPmPort().setEntity(primaryAgent.getPort().toString());
        }
        getPmEncryptOptions().setEntity(primaryAgent.getEncryptOptions());
        setPmOptionsMap(VdsStatic.pmOptionsStringToMap(primaryAgent.getOptions()));
        if (vds.getFenceAgents().size() > 1) {
            FenceAgent secondaryAgent = vds.getFenceAgents().get(1);
            // Set secondary PM parameters.
            getPmSecondaryIp().setEntity(secondaryAgent.getIp());
            getPmSecondaryUserName().setEntity(secondaryAgent.getUser());
            getPmSecondaryPassword().setEntity(secondaryAgent.getPassword());
            getPmSecondaryType().setSelectedItem(secondaryAgent.getType());
            if (secondaryAgent.getPort() != null) {
                getPmSecondaryPort().setEntity(secondaryAgent.getPort().toString());
            }
            setPmSecondaryOptionsMap(secondaryAgent.getOptionsMap());
            getPmSecondaryConcurrent().setEntity(secondaryAgent.getOrder() == primaryAgent.getOrder());
            getPmSecondaryEncryptOptions().setEntity(secondaryAgent.getEncryptOptions());
        }
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangeable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangeable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangeable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangeable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    vdsProtocol = vds.getProtocol();
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsChangeable(editTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = new ArrayList<>();
        for (FenceAgent agent : vds.getFenceAgents()) {
            FenceAgentModel model = new FenceAgentModel();
            model.setHost(this);
            // Set primary PM parameters.
            model.getManagementIp().setEntity(agent.getIp());
            model.getPmUserName().setEntity(agent.getUser());
            model.getPmPassword().setEntity(agent.getPassword());
            model.getPmType().setSelectedItem(agent.getType());
            if (agent.getPort() != null) {
                model.getPmPort().setEntity(agent.getPort());
            }
            model.getPmEncryptOptions().setEntity(agent.getEncryptOptions());
            model.setPmOptionsMap(VdsStatic.pmOptionsStringToMap(agent.getOptions()));
            model.setOrder(agent.getOrder());
            boolean added = false;
            for (FenceAgentModel concurrentModel : agents) {
                if (model.getOrder().getEntity() != null && model.getOrder().getEntity().equals(concurrentModel.getOrder().getEntity())) {
                    concurrentModel.getConcurrentList().add(model);
                    added = true;
                    break;
                }
            }
            if (!added) {
                agents.add(model);
            }
        }
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangeable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangeable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangeable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangeable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void cleanHostParametersFields() {
    // $NON-NLS-1$
    getName().setEntity("");
    // $NON-NLS-1$
    getComment().setEntity("");
    getAuthSshPort().setEntity(Integer.parseInt(constants.defaultHostSSHPort()));
    // $NON-NLS-1$
    getHost().setEntity("");
    // $NON-NLS-1$
    getUserPassword().setEntity("");
    // $NON-NLS-1$
    getFetchSshFingerprint().setEntity("");
}
#method_after
public void cleanHostParametersFields() {
    // $NON-NLS-1$
    getName().setEntity("");
    // $NON-NLS-1$
    getComment().setEntity("");
    getAuthSshPort().setEntity(Integer.parseInt(constants.defaultHostSSHPort()));
    // $NON-NLS-1$
    getHost().setEntity("");
    // $NON-NLS-1$
    getUserPassword().setEntity("");
    // $NON-NLS-1$
    getFetchSshFingerprint().setEntity("");
    getDeployHostedEngineAgent().setEntity(false);
    getHeAgentGateway().setEntity(null);
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setVdsGroupId(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    if (host.isSetPowerManagement() && host.getPowerManagement().isSetAgents()) {
        List<FenceAgent> agents = new LinkedList<FenceAgent>();
        for (Agent agent : host.getPowerManagement().getAgents().getAgents()) {
            agents.add(FenceAgentMapper.map(agent, null));
        }
        addParams.setFenceAgents(agents);
    }
    if (host.isSetHostedEngineConfiguration()) {
        addParams.setHostedEngineDeployConfiguration(getMapper(HostedEngineConfiguration.class, HostedEngineDeployConfiguration.class).map(host.getHostedEngineConfiguration(), null));
    }
    addParams = (AddVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(host, (VdsOperationActionParameters) addParams);
    return performCreate(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setVdsGroupId(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetPowerManagement() && host.getPowerManagement().isSetAgents()) {
        List<FenceAgent> agents = new LinkedList<>();
        for (Agent agent : host.getPowerManagement().getAgents().getAgents()) {
            agents.add(FenceAgentMapper.map(agent, null));
        }
        addParams.setFenceAgents(agents);
    }
    if (QueryHelper.hasMatrixParam(getUriInfo(), QUERY_PARAM_DEPLOY_HOSTED_ENGINE)) {
        addParams.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(QueryHelper.getBooleanMatrixParameter(getUriInfo(), QUERY_PARAM_DEPLOY_HOSTED_ENGINE), QueryHelper.getMatrixConstraint(getUriInfo(), QUERY_PARAM_HOSTED_ENGINE_GW)));
    }
    addParams = (AddVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(host, addParams);
    return performCreate(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public Host get() {
    // the "refresh" action and removed in the future.
    if (isForce()) {
        performAction(VdcActionType.RefreshHost, new VdsActionParameters(guid));
    }
    Host host = performGet(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(guid));
    deprecatedAddLinksToAgents(host);
    return host;
}
#method_after
@Override
public Host get() {
    // the "refresh" action and removed in the future.
    if (isForce()) {
        performAction(VdcActionType.RefreshHost, new VdsActionParameters(guid));
    }
    Host host = getVdsByVdsId();
    deprecatedAddLinksToAgents(host);
    return host;
}
#end_block

#method_before
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    validateEnums(Action.class, action);
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    if (action.getHost() != null && action.getHost().isSetHostedEngineConfiguration()) {
        params.setHostedEngineDeployConfiguration(getMapper(HostedEngineConfiguration.class, HostedEngineDeployConfiguration.class).map(action.getHost().getHostedEngineConfiguration(), null));
    }
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    if (vds.isOvirtNode()) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#method_after
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    validateEnums(Action.class, action);
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    if (QueryHelper.hasMatrixParam(getUriInfo(), BackendHostsResource.QUERY_PARAM_DEPLOY_HOSTED_ENGINE)) {
        params.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(QueryHelper.getBooleanMatrixParameter(getUriInfo(), BackendHostsResource.QUERY_PARAM_DEPLOY_HOSTED_ENGINE), QueryHelper.getMatrixConstraint(getUriInfo(), BackendHostsResource.QUERY_PARAM_HOSTED_ENGINE_GW)));
    }
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    if (vds.isOvirtNode()) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, createOrUpdateBondBusinessEntityMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQosOverriddenInterfaces();
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : unmanagedNetworkValidator.validate(params, existingInterfaces, networkBusinessEntityMap);
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    return vr;
}
#end_block

#method_before
protected ValidationResult validateBondModeVsNetworksAttachedToIt(Collection<NetworkAttachment> attachmentsToConfigure) {
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = NetworkUtils.hostInterfacesByNetworkName(existingInterfaces);
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        if (!mustAttachementBeCheckedForBondMode(attachment, hostInterfacesByNetworkName)) {
            continue;
        }
        CreateOrUpdateBond bondToCheck = createOrUpdateBondBusinessEntityMap.get(attachment.getNicName());
        if (bondToCheck == null) {
            VdsNetworkInterface existingNetworkInterfaceForAttachement = existingInterfacesMap.get(attachment.getNicName());
            if (existingNetworkInterfaceForAttachement == null || !existingNetworkInterfaceForAttachement.isBond()) {
                continue;
            }
            bondToCheck = CreateOrUpdateBond.fromBond((Bond) existingNetworkInterfaceForAttachement);
        }
        String networkLabel = networkBusinessEntityMap.get(attachment.getNetworkName()).getLabel();
        ValidationResult validationResult = checkBondMode(bondToCheck, networkLabel, attachment.getNetworkName());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateBondModeVsNetworksAttachedToIt(Collection<NetworkAttachment> attachmentsToConfigure) {
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = NetworkUtils.hostInterfacesByNetworkName(existingInterfaces);
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        if (!mustAttachementBeCheckedForBondMode(attachment, hostInterfacesByNetworkName)) {
            continue;
        }
        Bond bondToCheck = bondsMap.get(attachment.getNicName());
        if (bondToCheck == null) {
            VdsNetworkInterface existingNetworkInterfaceForAttachement = existingInterfacesMap.get(attachment.getNicName());
            if (existingNetworkInterfaceForAttachement == null || !existingNetworkInterfaceForAttachement.isBond()) {
                continue;
            }
            bondToCheck = (Bond) existingNetworkInterfaceForAttachement;
        }
        String networkLabel = networkBusinessEntityMap.get(attachment.getNetworkName()).getLabel();
        ValidationResult validationResult = checkBondMode(bondToCheck, networkLabel, attachment.getNetworkName());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult checkBondMode(CreateOrUpdateBond createOrUpdateBond, String networkLabel, String networkName) {
    if (BondMode.isBondModeValidForVmNetwork(createOrUpdateBond.getBondOptions())) {
        return ValidationResult.VALID;
    }
    if (networkLabel != null && isNicToConfigureContainTheLabel(createOrUpdateBond.getName(), networkLabel)) {
        return new ValidationResult(EngineMessage.INVALID_BOND_MODE_FOR_BOND_WITH_LABELED_VM_NETWORK, ReplacementUtils.createSetVariableString(VAR_BOND_NAME, createOrUpdateBond.getName()), ReplacementUtils.createSetVariableString(VAR_LABEL, networkLabel), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName));
    }
    return new ValidationResult(EngineMessage.INVALID_BOND_MODE_FOR_BOND_WITH_VM_NETWORK, ReplacementUtils.createSetVariableString(VAR_BOND_NAME, createOrUpdateBond.getName()), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName));
}
#method_after
private ValidationResult checkBondMode(Bond bondTocheck, String networkLabel, String networkName) {
    if (BondMode.isBondModeValidForVmNetwork(bondTocheck.getBondOptions())) {
        return ValidationResult.VALID;
    }
    if (networkLabel != null && isNicToConfigureContainTheLabel(bondTocheck.getName(), networkLabel)) {
        return new ValidationResult(EngineMessage.INVALID_BOND_MODE_FOR_BOND_WITH_LABELED_VM_NETWORK, ReplacementUtils.createSetVariableString(VAR_BOND_NAME, bondTocheck.getName()), ReplacementUtils.createSetVariableString(VAR_LABEL, networkLabel), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName));
    }
    return new ValidationResult(EngineMessage.INVALID_BOND_MODE_FOR_BOND_WITH_VM_NETWORK, ReplacementUtils.createSetVariableString(VAR_BOND_NAME, bondTocheck.getName()), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName));
}
#end_block

#method_before
ValidationResult validateQosOverriddenInterfaces() {
    for (NetworkAttachment networkAttachment : params.getNetworkAttachments()) {
        if (networkAttachment.isQosOverridden()) {
            Network network = getNetworkRelatedToAttachment(networkAttachment);
            String networkName = network.getName();
            HostNetworkQos hostNetworkQos = networkAttachment.getHostNetworkQos();
            HostNetworkQosValidator qosValidator = createHostNetworkQosValidator(hostNetworkQos);
            ValidationResult requiredValuesPresent = qosValidator.requiredQosValuesPresentForOverriding(networkName);
            if (!requiredValuesPresent.isValid()) {
                return requiredValuesPresent;
            }
            ValidationResult valuesConsistent = qosValidator.valuesConsistent(networkName);
            if (!valuesConsistent.isValid()) {
                return valuesConsistent;
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateQosOverriddenInterfaces() {
    for (NetworkAttachment networkAttachment : params.getNetworkAttachments()) {
        if (networkAttachment.isQosOverridden()) {
            Network network = getNetworkRelatedToAttachment(networkAttachment);
            String networkName = network.getName();
            if (!hostNetworkQosSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName));
            }
            HostNetworkQos hostNetworkQos = networkAttachment.getHostNetworkQos();
            HostNetworkQosValidator qosValidator = createHostNetworkQosValidator(hostNetworkQos);
            ValidationResult requiredValuesPresent = qosValidator.requiredQosValuesPresentForOverriding(networkName);
            if (!requiredValuesPresent.isValid()) {
                return requiredValuesPresent;
            }
            ValidationResult valuesConsistent = qosValidator.valuesConsistent(networkName);
            if (!valuesConsistent.isValid()) {
                return valuesConsistent;
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            EngineMessage engineMessage = EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            return new ValidationResult(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms(String removedNetworkName) {
    final List<String> removedNetworkNames = Collections.singletonList(removedNetworkName);
    final List<String> vmsNames = findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(host.getId(), removedNetworkNames);
    DetachNetworkUsedByVmValidator detachNetworkUsedByVmValidator = new DetachNetworkUsedByVmValidator(vmsNames, removedNetworkNames);
    return detachNetworkUsedByVmValidator.validate();
}
#method_after
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmsNames = findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(host.getId(), removedNetworks);
    final List<String> removedNetworksList = new ArrayList<>(removedNetworks);
    DetachNetworkUsedByVmValidator detachNetworkUsedByVmValidator = new DetachNetworkUsedByVmValidator(vmsNames, removedNetworksList);
    return detachNetworkUsedByVmValidator.validate();
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(engineMessage, replacements);
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.createSetVariableString(VAR_BOND_NAME, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (CreateOrUpdateBond modifiedOrNewBond : params.getCreateOrUpdateBonds()) {
        String bondName = modifiedOrNewBond.getName();
        Guid bondId = modifiedOrNewBond.getId();
        /*
             * bondId is provided, but bondName not. This means that user attempted update, but bond of such ID does not
             * exit, thus completors did not complete name.
             */
        if (bondId != null && bondName == null) {
            return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, bondId));
        }
        /*
             * user did not provide neither bondId nor bondName. That means he probably attempted new bond creation
             * but forgot to provide bondName.
             */
        if (bondId == null && bondName == null) {
            return new ValidationResult(EngineMessage.BOND_DOES_NOT_HAVE_NEITHER_ID_NOR_NAME_SPECIFIED);
        }
        /*
             * if (bondId == null && bondName != null) …
             * User provided only bondName, and completors failed to find existing bonds id for that name.
             * We cannot tell, what user wanted to do(create/update). We have to assume, it's new record creation, which
             * is valid scenario.
             */
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        boolean validBondName = bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            EngineMessage engineMessage = EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(CreateOrUpdateBond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists(slaveName);
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /*
             * definition of currently processed bond references this slave, but this slave already 'slaves' for
             * another bond. This is ok only when this bond will be removed as a part of this request
             * or the slave will be removed from its former bond, as a part of this request.
             */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /*
                         * we're creating new bond, and it's definition contains reference to slave already assigned
                         * to a different bond.
                         */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // … but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    for (VdsNetworkInterface iface : existingInterfaces) {
        if (slaveName.equals(NetworkCommonUtils.stripVlan(iface))) {
            if (iface.getNetworkImplementationDetails() != null && !iface.getNetworkImplementationDetails().isManaged()) {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_WITH_UNMANAGED_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, iface.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, slaveName));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private boolean slaveUsedMultipleTimesInDifferentBonds(String potentiallyDuplicateSlaveName) {
    int count = 0;
    for (CreateOrUpdateBond createOrUpdateBond : params.getCreateOrUpdateBonds()) {
        for (String slaveName : createOrUpdateBond.getSlaves()) {
            if (slaveName.equals(potentiallyDuplicateSlaveName)) {
                count++;
            }
        }
    }
    return count >= 2;
}
#method_after
private boolean slaveUsedMultipleTimesInDifferentBonds(String potentiallyDuplicateSlaveName) {
    int count = 0;
    for (Bond bond : params.getBonds()) {
        for (String slaveName : bond.getSlaves()) {
            if (slaveName.equals(potentiallyDuplicateSlaveName)) {
                count++;
            }
        }
    }
    return count >= 2;
}
#end_block

#method_before
private boolean bondIsUpdatedAndDoesNotContainCertainSlave(String slaveName, String bondName) {
    CreateOrUpdateBond createOrUpdateBond = this.createOrUpdateBondBusinessEntityMap.get(bondName);
    return createOrUpdateBond != null && !createOrUpdateBond.getSlaves().contains(slaveName);
}
#method_after
private boolean bondIsUpdatedAndDoesNotContainCertainSlave(String slaveName, String bondName) {
    Bond bond = this.bondsMap.get(bondName);
    return bond != null && !bond.getSlaves().contains(slaveName);
}
#end_block

#method_before
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validator.existingAttachmentIsReused(existingAttachmentsByNetworkId);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(existingAttachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : networkIdIsSet(attachment);
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    String id = networkAttachmentId.toString();
    String replacement = ReplacementUtils.getVariableAssignmentString(engineMessage, id);
    return new ValidationResult(engineMessage, replacement);
}
#method_after
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(CreateOrUpdateBond createOrUpdateBond) {
    Guid nicId = createOrUpdateBond.getId();
    String nicName = createOrUpdateBond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(nicName, nicId, nicName, message, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(bond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String nicName = attachment.getNicName();
    Guid nicId = attachment.getNicId();
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(nicName, nicId);
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_OR_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, nicId), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, nicName)).when(!nicActuallyExistsOrReferencesNewBond);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(attachment.getNicName(), attachment.getNicId());
    if (nicActuallyExistsOrReferencesNewBond) {
        return ValidationResult.VALID;
    }
    // Duplicate message / fix other code as well?
    return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#end_block

#method_before
private boolean isNicActuallyExistsOrReferencesNewBond(String nicName, Guid nicId) {
    return hostSetupNetworksValidatorHelper.isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, createOrUpdateBondBusinessEntityMap, nicName, nicId);
}
#method_after
private boolean isNicActuallyExistsOrReferencesNewBond(String nicName, Guid nicId) {
    return hostSetupNetworksValidatorHelper.isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms(attachment.getNetworkName());
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#end_block

#method_before
private NetworkAttachmentValidator createNetworkAttachmentValidator(NetworkAttachment attachmentToValidate) {
    return new NetworkAttachmentValidator(attachmentToValidate, host, networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, vmDao);
}
#method_after
private NetworkAttachmentValidator createNetworkAttachmentValidator(NetworkAttachment attachmentToValidate) {
    return new NetworkAttachmentValidator(attachmentToValidate, host, managementNetworkUtil, networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, vmDao);
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment newOrModifedAttachmet) {
    Network movedNetwork = existingNetworkRelatedToAttachment(newOrModifedAttachmet);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = existingAttachmentsById.get(newOrModifedAttachmet.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(newOrModifedAttachmet.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#method_after
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment attachment) {
    Network movedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = attachmentsById.get(attachment.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(attachment.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult validateAttachmentAndNicReferenceSameLabelNotConflict(NetworkAttachment attachment) {
    Network network = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(network)) {
        return ValidationResult.VALID;
    }
    String label = network.getLabel();
    String nicThatShouldHaveTheLabel = nicLabelByLabel.containsKey(label) ? nicLabelByLabel.get(label).getNicName() : null;
    EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName()), ReplacementUtils.createSetVariableString(VAR_LABELED_NIC_NAME, nicThatShouldHaveTheLabel)).unless(nicThatShouldHaveTheLabel == null || nicThatShouldHaveTheLabel.equals(attachment.getNicName()));
}
#method_after
ValidationResult validateAttachmentAndNicReferenceSameLabelNotConflict(NetworkAttachment attachment) {
    Network network = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(network)) {
        return ValidationResult.VALID;
    }
    String label = network.getLabel();
    String nicThatShouldHaveTheLabel = nicLabelByLabel.containsKey(label) ? nicLabelByLabel.get(label).getNicName() : null;
    EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString(VAR_INTERFACE_NAME, attachment.getNicName()), ReplacementUtils.createSetVariableString(VAR_LABELED_INTERFACE_NAME, nicThatShouldHaveTheLabel)).unless(nicThatShouldHaveTheLabel == null || nicThatShouldHaveTheLabel.equals(attachment.getNicName()));
}
#end_block

#method_before
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateAttachmentNotReferenceVlanDevice(NetworkAttachment attachment) {
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    EngineMessage engineMessage = EngineMessage.ATTACHMENT_REFERENCE_VLAN_DEVICE;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName())).when(nic != null && NetworkCommonUtils.isVlan(nic));
}
#method_after
private ValidationResult validateAttachmentNotReferenceVlanDevice(NetworkAttachment attachment) {
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    EngineMessage engineMessage = EngineMessage.ATTACHMENT_REFERENCE_VLAN_DEVICE;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName())).when(nic != null && NetworkUtils.isVlan(nic));
}
#end_block

#method_before
private NetworkAttachmentValidator createNetworkAttachmentValidator(NetworkAttachment attachment) {
    return new NetworkAttachmentValidator(attachment, host, networkClusterDaoMock, networkDaoMock, vdsDaoMock, findActiveVmsUsingNetwork, vmDao);
}
#method_after
private NetworkAttachmentValidator createNetworkAttachmentValidator(NetworkAttachment attachment) {
    return new NetworkAttachmentValidator(attachment, host, managementNetworkUtilMock, networkClusterDaoMock, networkDaoMock, vdsDaoMock, findActiveVmsUsingNetwork, vmDao);
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() {
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    assertThat(createNetworkAttachmentValidator(null).networkAttachmentIsSet(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, null)));
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() {
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    assertThat(createNetworkAttachmentValidator(null).networkAttachmentIsSet(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "null")));
}
#end_block

#method_before
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() {
    Network externalNetwork = new Network();
    externalNetwork.setId(Guid.newGuid());
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(eq(externalNetwork.getId()))).thenReturn(externalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(externalNetwork.getId());
    assertThat(createNetworkAttachmentValidator(attachment).notExternalNetwork(), failsWith(EngineMessage.EXTERNAL_NETWORK_HAVING_NAME_CANNOT_BE_PROVISIONED));
}
#method_after
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() {
    Network externalNetwork = new Network();
    externalNetwork.setId(Guid.newGuid());
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(eq(externalNetwork.getId()))).thenReturn(externalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(externalNetwork.getId());
    assertThat(createNetworkAttachmentValidator(attachment).notExternalNetwork(), failsWith(EngineMessage.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#end_block

#method_before
@Test
public void testNotRemovingManagementNetwork() {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(createNetworkAttachmentValidator(new NetworkAttachment()));
    doReturn(networkValidatorMock).when(networkAttachmentValidatorSpy).getNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    when(networkValidatorMock.notRemovingManagementNetwork()).thenReturn(propagatedResult);
    assertThat("ValidationResult is not propagated correctly", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), is(propagatedResult));
}
#method_after
@Test
public void testNotRemovingManagementNetwork() {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(createNetworkAttachmentValidator(new NetworkAttachment()));
    doReturn(networkValidatorMock).when(networkAttachmentValidatorSpy).getNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    when(networkValidatorMock.notRemovingManagementNetwork()).thenReturn(propagatedResult);
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenNotAttached() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName(NETWORK_NAME);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(network.getName());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getClusterId(), network.getId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(null);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    EngineMessage engineMessage = EngineMessage.NETWORK_OF_GIVEN_NAME_NOT_EXISTS_IN_CLUSTER;
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName())));
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenNotAttached() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getClusterId(), network.getId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(null);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), failsWith(EngineMessage.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#end_block

#method_before
@Test
public void testBootProtocolSetForRoleNetworkWhenIpConfigurationIsNull() {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpv4Configuration(Ipv4BootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForRoleNetworkWhenNullValuedIpConfiguration(true, true, false, failsWith(EngineMessage.ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL_ENTITY, network.getName())), network, attachment);
}
#method_after
@Test
public void testBootProtocolSetForRoleNetworkWhenIpConfigurationIsNull() {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForRoleNetworkWhenNullValuedIpConfiguration(true, true, false, failsWith(EngineMessage.ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL_ENTITY, network.getName())), network, attachment);
}
#end_block

#method_before
private Network createNetwork() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName(NETWORK_NAME);
    return network;
}
#method_after
private Network createNetwork() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("networkName");
    return network;
}
#end_block

#method_before
@Test
public void testBootProtocolSetForRoleNetworkWhenBootProtocolIsNone() {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpv4Configuration(Ipv4BootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForRoleNetworkWhenNullValuedIpConfiguration(false, true, true, failsWith(EngineMessage.ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL_ENTITY, network.getName())), network, attachment);
}
#method_after
@Test
public void testBootProtocolSetForRoleNetworkWhenBootProtocolIsNone() {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForRoleNetworkWhenNullValuedIpConfiguration(false, true, true, failsWith(EngineMessage.ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL_ENTITY, network.getName())), network, attachment);
}
#end_block

#method_before
@Test
public void testBootProtocolSetForRoleNetworkWhenBootProtocolIsDhcp() {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpv4Configuration(Ipv4BootProtocol.DHCP, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForRoleNetworkWhenNullValuedIpConfiguration(true, false, false, isValid(), network, attachment);
}
#method_after
@Test
public void testBootProtocolSetForRoleNetworkWhenBootProtocolIsDhcp() {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.DHCP, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForRoleNetworkWhenNullValuedIpConfiguration(true, false, false, isValid(), network, attachment);
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(createNetworkAttachmentValidator(attachment).nicNameIsSet(), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET));
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(createNetworkAttachmentValidator(attachment).nicExists(), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNotNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(createNetworkAttachmentValidator(attachment).nicNameIsSet(), isValid());
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNotNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(createNetworkAttachmentValidator(attachment).nicExists(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsDhcp() {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(Ipv4BootProtocol.DHCP);
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsDhcp() {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol.DHCP);
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNone() {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(Ipv4BootProtocol.NONE);
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNone() {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol.NONE);
}
#end_block

#method_before
private void doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(Ipv4BootProtocol bootProtocol) {
    NetworkAttachment attachment = createNetworkAttachmentWithIpv4Configuration(bootProtocol, null, null);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    ValidationResult actual = validator.networkIpAddressWasSameAsHostnameAndChanged(EMPTY_NICS_MAP);
    assertThat(actual, isValid());
}
#method_after
private void doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol bootProtocol) {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(bootProtocol, null, null);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    ValidationResult actual = validator.networkIpAddressWasSameAsHostnameAndChanged(null);
    assertThat(actual, isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() {
    NetworkAttachment attachment = createNetworkAttachmentWithIpv4Configuration(Ipv4BootProtocol.STATIC_IP, null, null);
    attachment.setNicName(NIC_NAME);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(EMPTY_NICS_MAP), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHost() {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.emptyList());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), isValid());
}
#method_after
@Test
public void testNetworkNotAttachedToHost() {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.<VDS>emptyList());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHostWhenAttached() {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.singletonList(host));
    String networkName = NETWORK_NAME;
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(networkName);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), failsWith(EngineMessage.NETWORK_ALREADY_ATTACHED_TO_HOST, ReplacementUtils.createSetVariableString(NETWORK_NAME, networkName), ReplacementUtils.createSetVariableString(HOST_NAME, host.getName())));
}
#method_after
@Test
public void testNetworkNotAttachedToHostWhenAttached() {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.singletonList(host));
    String networkName = "networkName";
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(networkName);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), failsWith(EngineMessage.NETWORK_ALREADY_ATTACHED_TO_HOST, ReplacementUtils.createSetVariableString("networkName", networkName), ReplacementUtils.createSetVariableString("hostName", host.getName())));
}
#end_block

#method_before
@Override
protected boolean validate() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    completeMissingDataInParameters();
    boolean requestValid = validateEntitiesFromRequest(getParameters().getNetworkAttachments()) && validateEntitiesFromRequest(getParameters().getCreateOrUpdateBonds());
    if (!requestValid) {
        return requestValid;
    }
    fillInUnsetBondingOptions();
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    VdcQueryReturnValue existingBondsResponse = runInternalQuery(VdcQueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    removeUnchangedAttachments();
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean validate() {
    VDS host = getVds();
    boolean requestValid = validateEntitiesFromRequest(getParameters().getNetworkAttachments()) && validateEntitiesFromRequest(getParameters().getBonds());
    if (!requestValid) {
        return requestValid;
    }
    fillInUnsetBondingOptions();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    completeMissingDataInParameters();
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    VdcQueryReturnValue existingBondsResponse = runInternalQuery(VdcQueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    removeUnchangedAttachments(networkAttachmentDao.getAllForHost(getVdsId()));
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getCreateOrUpdateBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    fillInUnsetIpConfigs();
}
#method_after
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator);
    return validator.validate();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock("Host setup networks")) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private void removeUnchangedBonds(List<VdsNetworkInterface> existingNics) {
    Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(existingNics);
    List<CreateOrUpdateBond> createOrUpdateBonds = getParameters().getCreateOrUpdateBonds();
    for (Iterator<CreateOrUpdateBond> iterator = createOrUpdateBonds.iterator(); iterator.hasNext(); ) {
        CreateOrUpdateBond bondFromRequest = iterator.next();
        Guid idOfBondFromRequest = bondFromRequest.getId();
        boolean bondFromRequestIsNewBond = idOfBondFromRequest == null;
        if (!bondFromRequestIsNewBond) {
            if (bondFromRequest.equalToBond((Bond) nicsById.get(idOfBondFromRequest))) {
                iterator.remove();
            }
        }
    }
}
#method_after
private void removeUnchangedBonds(List<VdsNetworkInterface> existingNics) {
    Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(existingNics);
    for (Iterator<Bond> iterator = getParameters().getBonds().iterator(); iterator.hasNext(); ) {
        Bond bondFromRequest = iterator.next();
        Guid idOfBondFromRequest = bondFromRequest.getId();
        boolean bondFromRequestIsNewBond = idOfBondFromRequest == null;
        if (!bondFromRequestIsNewBond) {
            if (bondFromRequestIsEqualToAlreadyExistingNic(bondFromRequest, nicsById.get(idOfBondFromRequest))) {
                iterator.remove();
            }
        }
    }
}
#end_block

#method_before
private void removeUnchangedAttachments() {
    Map<Guid, NetworkAttachment> existingAttachmentsById = Entities.businessEntitiesById(getExistingAttachments());
    for (Iterator<NetworkAttachment> iterator = getParameters().getNetworkAttachments().iterator(); iterator.hasNext(); ) {
        NetworkAttachment attachmentFromRequest = iterator.next();
        Guid idOfAttachmentFromRequest = attachmentFromRequest.getId();
        boolean attachmentFromRequestIsNewAttachment = idOfAttachmentFromRequest == null;
        // when flag 'isOverrideConfiguration' is set, NetworkAttachment from request cannot be ignored.
        boolean overridingConfiguration = attachmentFromRequest.isOverrideConfiguration();
        if (!attachmentFromRequestIsNewAttachment && !overridingConfiguration) {
            NetworkAttachment existingAttachment = existingAttachmentsById.get(idOfAttachmentFromRequest);
            if (attachmentFromRequestIsEqualToAlreadyExistingOne(attachmentFromRequest, existingAttachment)) {
                iterator.remove();
            }
        }
    }
}
#method_after
private void removeUnchangedAttachments(List<NetworkAttachment> existingAttachments) {
    Map<Guid, NetworkAttachment> existingAttachmentsById = Entities.businessEntitiesById(existingAttachments);
    for (Iterator<NetworkAttachment> iterator = getParameters().getNetworkAttachments().iterator(); iterator.hasNext(); ) {
        NetworkAttachment attachmentFromRequest = iterator.next();
        Guid idOfAttachmentFromRequest = attachmentFromRequest.getId();
        boolean attachmentFromRequestIsNewAttachment = idOfAttachmentFromRequest == null;
        // when flag 'isOverrideConfiguration' is set, NetworkAttachment from request cannot be ignored.
        boolean overridingConfiguration = attachmentFromRequest.isOverrideConfiguration();
        if (!attachmentFromRequestIsNewAttachment && !overridingConfiguration) {
            NetworkAttachment existingAttachment = existingAttachmentsById.get(idOfAttachmentFromRequest);
            if (attachmentFromRequestIsEqualToAlreadyExistingOne(attachmentFromRequest, existingAttachment)) {
                iterator.remove();
            }
        }
    }
}
#end_block

#method_before
private void fillInUnsetBondingOptions() {
    for (CreateOrUpdateBond createOrUpdateBond : getParameters().getCreateOrUpdateBonds()) {
        if (StringUtils.isEmpty(createOrUpdateBond.getBondOptions())) {
            createOrUpdateBond.setBondOptions(DEFAULT_BOND_OPTIONS);
        }
    }
}
#method_after
private void fillInUnsetBondingOptions() {
    for (Bond bond : getParameters().getBonds()) {
        if (StringUtils.isEmpty(bond.getBondOptions())) {
            bond.setBondOptions(DEFAULT_BOND_OPTIONS);
        }
    }
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getCreateOrUpdateBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConnectivityTimeout(timeout);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged());
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getClusterCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged());
    return hostCmdParams;
}
#end_block

#method_before
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getClusterId()) && ipConfiguration != null && (isIpv4GatewaySet(ipConfiguration) || isIpv6GatewaySet(ipConfiguration));
}
#method_after
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getClusterId()) && ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && (ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#end_block

#method_before
private List<NetworkAttachment> getExistingAttachments() {
    if (existingAttachments == null) {
        existingAttachments = networkAttachmentDao.getAllForHost(getVdsId());
    }
    return existingAttachments;
}
#method_after
private List<NetworkAttachment> getExistingAttachments() {
    if (existingAttachments == null) {
        existingAttachments = getDbFacade().getNetworkAttachmentDao().getAllForHost(getVdsId());
    }
    return existingAttachments;
}
#end_block

#method_before
private List<HostNetwork> getNetworksToConfigure() {
    if (networksToConfigure == null) {
        networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
        BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
        for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            HostNetwork networkToConfigure = new HostNetwork(network, attachment);
            networkToConfigure.setBonding(isBonding(attachment, nics));
            if (defaultRouteSupported() && defaultRouteRequired(network, attachment.getIpConfiguration())) {
                // TODO: YZ - should default route be set separately for IPv4 and IPv6
                networkToConfigure.setDefaultRoute(true);
            }
            if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
                networkToConfigure.setQosConfiguredOnInterface(true);
                HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
                networkToConfigure.setQos(hostNetworkQos);
            }
            networksToConfigure.add(networkToConfigure);
        }
    }
    return networksToConfigure;
}
#method_after
private List<HostNetwork> getNetworksToConfigure() {
    if (networksToConfigure == null) {
        networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
        BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
        for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            HostNetwork networkToConfigure = new HostNetwork(network, attachment);
            networkToConfigure.setBonding(isBonding(attachment, nics));
            if (defaultRouteSupported() && defaultRouteRequired(network, attachment.getIpConfiguration())) {
                networkToConfigure.setDefaultRoute(true);
            }
            if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
                networkToConfigure.setQosConfiguredOnInterface(true);
                HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
                networkToConfigure.setQos(hostNetworkQos);
            }
            networksToConfigure.add(networkToConfigure);
        }
    }
    return networksToConfigure;
}
#end_block

#method_before
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#method_after
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet))) {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#end_block

#method_before
private boolean isBonding(NetworkAttachment attachment, BusinessEntityMap<VdsNetworkInterface> nics) {
    for (CreateOrUpdateBond bond : getParameters().getCreateOrUpdateBonds()) {
        if (bond.getName() != null && bond.getName().equals(attachment.getNicName())) {
            return true;
        }
    }
    VdsNetworkInterface attachedNic = nics.get(attachment.getNicId(), attachment.getNicName());
    Validate.notNull(attachedNic, "NicId/NicName must refer to a resolvable interface");
    return Boolean.TRUE.equals(attachedNic.getBonded());
}
#method_after
private boolean isBonding(NetworkAttachment attachment, BusinessEntityMap<VdsNetworkInterface> nics) {
    for (Bond bond : getParameters().getBonds()) {
        if (bond.getName() != null && bond.getName().equals(attachment.getNicName())) {
            return true;
        }
    }
    VdsNetworkInterface attachedNic = nics.get(attachment.getNicId(), attachment.getNicName());
    Validate.notNull(attachedNic, "NicId/NicName must refer to a resolvable interface");
    return Boolean.TRUE.equals(attachedNic.getBonded());
}
#end_block

#method_before
private Map<String, UserOverriddenNicValues> applyUserConfiguredNics() {
    List<VdsNetworkInterface> nicsToConfigure = getExistingInterfacesAndNewlyCreatedBonds();
    updateLabelsOnNicsToConfigure(nicsToConfigure);
    return nicsToConfigure.stream().collect(Collectors.toMap(VdsNetworkInterface::getName, nic -> new UserOverriddenNicValues(nic.getLabels())));
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> nicsToConfigure = getNicsToConfigureWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigure);
    return nicsToConfigure;
}
#end_block

#method_before
private void updateAddedModifiedLabelsOnNics(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    Map<String, VdsNetworkInterface> labelToExistingNic = getLabelToNic(nicsToConfigureByName.values());
    for (NicLabel nicLabel : getParameters().getLabels()) {
        VdsNetworkInterface currentLabelNic = labelToExistingNic.get(nicLabel.getLabel());
        VdsNetworkInterface newLabelNic = nicsToConfigureByName.get(nicLabel.getNicName());
        moveLabel(nicLabel.getLabel(), currentLabelNic, newLabelNic);
    }
}
#method_after
private void updateAddedModifiedLabelsOnNics(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    Map<String, VdsNetworkInterface> labelToExistingNic = getLabelToNic(nicsToConfigureByName);
    for (NicLabel nicLabel : getParameters().getLabels()) {
        VdsNetworkInterface currentLabelNic = labelToExistingNic.get(nicLabel.getLabel());
        VdsNetworkInterface newLabelNic = nicsToConfigureByName.get(nicLabel.getNicName());
        moveLabel(nicLabel.getLabel(), currentLabelNic, newLabelNic);
    }
}
#end_block

#method_before
private Map<String, VdsNetworkInterface> getLabelToNic(Collection<VdsNetworkInterface> nics) {
    Map<String, VdsNetworkInterface> labelToNic = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (NetworkUtils.isLabeled(nic)) {
            for (String label : nic.getLabels()) {
                labelToNic.put(label, nic);
            }
        }
    }
    return labelToNic;
}
#method_after
private Map<String, VdsNetworkInterface> getLabelToNic(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    Map<String, VdsNetworkInterface> labelToExistingNic = new HashMap<>();
    for (VdsNetworkInterface nic : nicsToConfigureByName.values()) {
        if (NetworkUtils.isLabeled(nic)) {
            for (String label : nic.getLabels()) {
                labelToExistingNic.put(label, nic);
            }
        }
    }
    return labelToExistingNic;
}
#end_block

#method_before
private Map<String, VdsNetworkInterface> getLabelToNic(Collection<VdsNetworkInterface> nics) {
    Map<String, VdsNetworkInterface> labelToNic = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (NetworkUtils.isLabeled(nic)) {
            for (String label : nic.getLabels()) {
                labelToNic.put(label, nic);
            }
        }
    }
    return labelToNic;
}
#method_after
private Map<String, VdsNetworkInterface> getLabelToNic(Collection<VdsNetworkInterface> nics) {
    Map<String, VdsNetworkInterface> labelToNic = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (nic.getLabels() != null) {
            for (String label : nic.getLabels()) {
                labelToNic.put(label, nic);
            }
        }
    }
    return labelToNic;
}
#end_block

#method_before
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(() -> {
        UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), getParameters().getRemovedNetworkAttachments(), applyUserConfiguredNics());
        // save the new network topology to DB
        hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
        getVdsDynamicDao().updateNetConfigDirty(updatedHost.getId(), updatedHost.getNetConfigDirty());
        // Update cluster networks (i.e. check if need to activate each new network)
        for (Network net : getModifiedNetworks()) {
            NetworkClusterHelper.setStatus(getClusterId(), net);
        }
        return null;
    });
}
#method_after
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(() -> {
        UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
        // save the new network topology to DB
        hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
        getVdsDynamicDao().updateNetConfigDirty(updatedHost.getId(), updatedHost.getNetConfigDirty());
        // Update cluster networks (i.e. check if need to activate each new network)
        for (Network net : getModifiedNetworks()) {
            NetworkClusterHelper.setStatus(getClusterId(), net);
        }
        return null;
    });
}
#end_block

#method_before
private boolean isManagementNetworkChanged() {
    String mgmtNetworkName = managementNetworkUtil.getManagementNetwork(getVds().getClusterId()).getName();
    for (HostNetwork network : getNetworksToConfigure()) {
        if (mgmtNetworkName.equals(network.getNetworkName())) {
            return true;
        }
    }
    for (CreateOrUpdateBond createOrUpdateBond : getParameters().getCreateOrUpdateBonds()) {
        // We are only interested in existing bonds, whose bonding options/slave have changed, so it
        // enough to check existing bonds. New bonds which have the management network
        // are covered by network attachments
        VdsNetworkInterface bondNic = getExistingNicsBusinessEntityMap().get(createOrUpdateBond.getId());
        if (bondNic != null && mgmtNetworkName.equals(bondNic.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isManagementNetworkChanged() {
    String mgmtNetworkName = managementNetworkUtil.getManagementNetwork(getVds().getClusterId()).getName();
    for (HostNetwork network : getNetworksToConfigure()) {
        if (mgmtNetworkName.equals(network.getNetworkName())) {
            return true;
        }
    }
    for (Bond bond : getParameters().getBonds()) {
        // We are only interested in existing bonds, whose bonding options/slave have changed, so it
        // enough to check existing bonds. New bonds which have the management network
        // are covered by network attachments
        VdsNetworkInterface bondNic = getExistingNicsBusinessEntityMap().get(bond.getId());
        if (bondNic != null && mgmtNetworkName.equals(bondNic.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public void add(final VmNic iface, CompensationContext compensationContext, boolean reserveExistingMac, int osId, Version clusterCompatibilityVersion) {
    if (reserveExistingMac) {
        if (getOsRepository().hasNicHotplugSupport(osId, clusterCompatibilityVersion)) {
            macPool.forceAddMac(iface.getMacAddress());
        } else if (!macPool.addMac(iface.getMacAddress())) {
            auditLogMacInUse(iface);
            throw new EngineException(EngineError.MAC_ADDRESS_IS_IN_USE);
        }
    }
    getVmNicDao().save(iface);
    getVmNetworkStatisticsDao().save(iface.getStatistics());
    compensationContext.snapshotNewEntity(iface);
    compensationContext.snapshotNewEntity(iface.getStatistics());
}
#method_after
public void add(final VmNic iface, CompensationContext compensationContext, boolean reserveExistingMac, int osId, Version clusterCompatibilityVersion) {
    if (reserveExistingMac) {
        if (FeatureSupported.hotPlug(clusterCompatibilityVersion) && getOsRepository().hasNicHotplugSupport(osId, clusterCompatibilityVersion)) {
            macPool.forceAddMac(iface.getMacAddress());
        } else if (!macPool.addMac(iface.getMacAddress())) {
            auditLogMacInUse(iface);
            throw new EngineException(EngineError.MAC_ADDRESS_IS_IN_USE);
        }
    }
    getVmNicDao().save(iface);
    getVmNetworkStatisticsDao().save(iface.getStatistics());
    compensationContext.snapshotNewEntity(iface);
    compensationContext.snapshotNewEntity(iface.getStatistics());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    final VdsDynamic vdsDynamic = new VdsDynamic();
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator()).thenReturn(mockNetworkExclusivenessValidator);
    when(mockNetworkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(any())).thenReturn(ValidationResult.VALID);
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setClusterCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
    when(mockNetworkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(any())).thenReturn(ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, labeledNetwork.getName())));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, labeledNetwork.getName())));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
    replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(engineMessage, replacements));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    replacements.add(ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().build());
    when(findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms("removedNet"), isValid());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().build());
    when(findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), isValid());
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBondWithNameAndId();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, createOrUpdateBond.getName()));
    doTestValidModifiedBonds(createOrUpdateBond, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBondWithNameAndId();
    doTestValidModifiedBonds(createOrUpdateBond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, createOrUpdateBond.getName())), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBondWithNameAndId();
    createOrUpdateBond.setSlaves(Stream.of("slaveA", "slaveB").collect(toSet()));
    doTestValidModifiedBonds(createOrUpdateBond, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(null, "bond1", "slaveA", "slaveB");
    doTestValidModifiedBonds(createOrUpdateBond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidModifiedBonds(CreateOrUpdateBond createOrUpdateBond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(Guid.newGuid(), "bond1", "slaveA", "slaveB");
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(Guid.newGuid(), "bond1", "slaveA", "slaveB");
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_NIC_NAME, createOrUpdateBond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_INTERFACE_NAME, bond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces(bond, differentBond, slaveA, slaveB).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveB.getName())));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces(bond, differentBond, slaveA, slaveB).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveB.getName())));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondButItsDetachedFromItAsAPartOfRequest() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    VdsNetworkInterface slaveC = createBondSlave(differentBond, "slaveC");
    VdsNetworkInterface slaveD = createBondSlave(differentBond, "slaveD");
    setBondSlaves(bond, slaveA, slaveB);
    setBondSlaves(differentBond, slaveC, slaveD);
    HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond), CreateOrUpdateBond.fromBond(differentBond))).addExistingInterfaces(bond, differentBond, slaveA, slaveB, slaveC, slaveD).build();
    doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondButItsDetachedFromItAsAPartOfRequest() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    VdsNetworkInterface slaveC = createBondSlave(differentBond, "slaveC");
    VdsNetworkInterface slaveD = createBondSlave(differentBond, "slaveD");
    setBondSlaves(bond, slaveA, slaveB);
    setBondSlaves(differentBond, slaveC, slaveD);
    HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond, differentBond)).addExistingInterfaces(bond, differentBond, slaveA, slaveB, slaveC, slaveD).build();
    doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#end_block

#method_before
public Bond createBond(String bondName) {
    return createBond(bondName, null, Guid.newGuid());
}
#method_after
public Bond createBond(String bondName) {
    Bond bond = new Bond();
    bond.setName(bondName);
    bond.setId(Guid.newGuid());
    return bond;
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    NetworkAttachment attachmentOfNetworkToSlaveA = createNetworkAttachment(networkBeingRemoved, slaveA);
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    final HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces(bond, slaveA, slaveB).addExistingAttachments(attachmentOfNetworkToSlaveA).addNetworks(networkBeingRemoved).build();
    doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkBeingRemoved.getName())));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    NetworkAttachment attachmentOfNetworkToSlaveA = createNetworkAttachment(networkBeingRemoved, slaveA);
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    final HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces(bond, slaveA, slaveB).addExistingAttachments(attachmentOfNetworkToSlaveA).addNetworks(networkBeingRemoved).build();
    doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkBeingRemoved.getName())));
}
#end_block

#method_before
private void doTestValidateModifiedBondSlaves(HostSetupNetworksValidator validator, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, Matcher<ValidationResult> matcher) {
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists(anyString())).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceHasNameSet()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validNewOrModifiedBonds(), matcher);
}
#method_after
private void doTestValidateModifiedBondSlaves(HostSetupNetworksValidator validator, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, Matcher<ValidationResult> matcher) {
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validNewOrModifiedBonds(), matcher);
}
#end_block

#method_before
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(Guid.newGuid(), "bond1", nicA.getName(), nicB.getName());
    addNetworkIdToNetworkDaoMock(networkA);
    addNetworkToClusterDaoMock(networkA.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(createOrUpdateBond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#method_after
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    setBondSlaves(bond, nicA, nicB);
    addNetworkIdToNetworkDaoMock(networkA);
    addNetworkToClusterDaoMock(networkA.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(bond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
@Test
public void testValidateBondModeForVmNetwork() {
    validateBondModes(true);
}
#method_after
@Test
public void testValidateBondModeForVmNetwork() {
    validateBondMode(true);
}
#end_block

#method_before
@Test
public void testValidateBondModeForNonVmNetwork() {
    validateBondModes(false);
}
#method_after
@Test
public void testValidateBondModeForNonVmNetwork() {
    validateBondMode(false);
}
#end_block

#method_before
private void validateBondMode(boolean isVmNetwork, BondMode bondMode) {
    String networkName = "networkName";
    String bondName = "bondName";
    Bond bond = createBond(bondName, networkName, null);
    bond.setBondOptions(bondMode.getConfigurationValue());
    Network network = createNetworkWithName(networkName);
    network.setVmNetwork(isVmNetwork);
    NetworkAttachment vmNetworkNetworkAttachment = createNetworkAttachment(network, bond);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addNetworks(network).addExistingInterfaces(bond).build();
    List<NetworkAttachment> attachmentsToConfigure = Collections.singletonList(vmNetworkNetworkAttachment);
    ValidationResult result = validator.validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    if (!isVmNetwork || bondMode.isBondModeValidForVmNetwork()) {
        collector.checkThat(result, isValid());
    } else {
        collector.checkThat(result, failsWith(EngineMessage.INVALID_BOND_MODE_FOR_BOND_WITH_VM_NETWORK, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, bondName), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkName)));
    }
}
#method_after
private void validateBondMode(boolean isVmNetwork) {
    Bond bond = new Bond();
    bond.setNetworkName(null);
    bond.setName("bondName");
    bond.setNetworkName("networkName");
    Network network = createNetworkWithName("networkName");
    network.setVmNetwork(isVmNetwork);
    NetworkAttachment vmNetworkNetworkAttachment = createNetworkAttachment(network, bond);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(new Bond[] { bond })).addNetworks(network).addExistingInterfaces(bond).build();
    for (BondMode bondMode : BondMode.values()) {
        bond.setBondOptions(bondMode.getConfigurationValue());
        ValidationResult result = validator.validateBondModeVsNetworksAttachedToIt(Arrays.asList(vmNetworkNetworkAttachment));
        if (!isVmNetwork || bondMode.isBondModeValidForVmNetwork()) {
            assertThat(result, isValid());
        } else {
            assertThat(result, failsWith(EngineMessage.INVALID_BOND_MODE_FOR_BOND_WITH_VM_NETWORK, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, "bondName"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName")));
        }
    }
}
#end_block

#method_before
@Test
public void testValidateBondOptionsForNewAttachementWithVmNetwork() {
    validateValidBondsForAllBondModes(false, true, true, false);
}
#method_after
@Test
public void testValidateBondOptionsForNewAttachementWithVmNetwork() {
    validateValidBonds(false, true, true, false);
}
#end_block

#method_before
@Test
public void testValidateBondOptionsForNewAttachementWithNonVmNetwork() {
    validateValidBondsForAllBondModes(true, false, true, false);
}
#method_after
@Test
public void testValidateBondOptionsForNewAttachementWithNonVmNetwork() {
    validateValidBonds(true, false, true, false);
}
#end_block

#method_before
@Test
public void validateBondOptionsForNewAttachementWithOutOfSyncVmNetworkNotOverridden() {
    validateValidBondsForAllBondModes(true, true, false, false);
}
#method_after
@Test
public void validateBondOptionsForNewAttachementWithOutOfSyncVmNetworkNotOverridden() {
    validateValidBonds(true, true, false, false);
}
#end_block

#method_before
@Test
public void validateBondOptionsForNewAttachementWithOutOfSyncVmNetworOverridden() {
    validateValidBondsForAllBondModes(false, true, false, true);
}
#method_after
@Test
public void validateBondOptionsForNewAttachementWithOutOfSyncVmNetworOverridden() {
    validateValidBonds(false, true, false, true);
}
#end_block

#method_before
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString("nicName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledNicName", nicLabel.getNicName())));
    }
}
#method_after
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC_ENTITY", network.getName()), ReplacementUtils.createSetVariableString("interfaceName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledInterfaceName", nicLabel.getNicName())));
    }
}
#end_block

#method_before
public ParametersBuilder addBonds(CreateOrUpdateBond... createOrUpdateBonds) {
    if (nullParameters(createOrUpdateBonds)) {
        return this;
    }
    if (parameters.getCreateOrUpdateBonds() == null) {
        parameters.setCreateOrUpdateBonds(new ArrayList<>());
    }
    parameters.getCreateOrUpdateBonds().addAll(Arrays.asList(createOrUpdateBonds));
    return this;
}
#method_after
public ParametersBuilder addBonds(Bond... bonds) {
    if (nullParameters(bonds)) {
        return this;
    }
    if (parameters.getBonds() == null) {
        parameters.setBonds(new ArrayList<>());
    }
    parameters.getBonds().addAll(Arrays.asList(bonds));
    return this;
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), networkClusterDaoMock, networkDaoMock, vdsDaoMock, findActiveVmsUsingNetwork, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator, new UnmanagedNetworkValidator());
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, findActiveVmsUsingNetwork, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator);
}
#end_block

#method_before
public ValidationResult networkAttachmentIsSet() {
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, null)).when(attachment == null);
}
#method_after
public ValidationResult networkAttachmentIsSet() {
    // TODO MM: what to do with this? this actually does not mean, that the attachment does not exist, we just did not get one, and we don't even know how one searched for it, so we also don't know what to complain about.
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, null)).when(attachment == null);
}
#end_block

#method_before
public ValidationResult networkExists() {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    // User did not specify neither id nor name.
    if (networkId == null && networkName == null) {
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NETWORK_ID_OR_NAME_IS_NOT_SET);
    }
    // User specified id, for which completors did not find Network record.
    if (networkId != null && networkName == null) {
        EngineMessage engineMessage = EngineMessage.NETWORK_HAVING_ID_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, networkId.toString()));
    }
    // User specified name, for which completors did not find Network record.
    if (networkId == null && networkName != null) {
        EngineMessage engineMessage = EngineMessage.NETWORK_HAVING_NAME_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, networkName));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkExists() {
    return getNetworkValidator().networkIsSet();
}
#end_block

#method_before
public ValidationResult notExternalNetwork() {
    EngineMessage engineMessage = EngineMessage.EXTERNAL_NETWORK_HAVING_NAME_CANNOT_BE_PROVISIONED;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, getNetwork().getName())).when(getNetwork().isExternal());
}
#method_after
public ValidationResult notExternalNetwork() {
    // TODO MM: already used elsewhere, how to fix?
    return ValidationResult.failWith(EngineMessage.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED).when(getNetwork().isExternal());
}
#end_block

#method_before
public ValidationResult networkAttachedToCluster() {
    EngineMessage engineMessage = EngineMessage.NETWORK_OF_GIVEN_NAME_NOT_EXISTS_IN_CLUSTER;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, this.attachment.getNetworkName())).when(getNetworkCluster() == null);
}
#method_after
public ValidationResult networkAttachedToCluster() {
    return ValidationResult.failWith(EngineMessage.NETWORK_NOT_EXISTS_IN_CLUSTER).when(getNetworkCluster() == null);
}
#end_block

#method_before
public ValidationResult bootProtocolSetForRoleNetwork() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = isRoleNetwork() && (ipConfiguration == null || !ipConfiguration.hasIpv4PrimaryAddressSet() || ipConfiguration.getIpv4PrimaryAddress().getBootProtocol() == Ipv4BootProtocol.NONE);
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL_ENTITY, getNetwork().getName())).when(failWhen);
}
#method_after
public ValidationResult bootProtocolSetForRoleNetwork() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = (isRoleNetwork() && (ipConfiguration == null || !ipConfiguration.hasPrimaryAddressSet() || ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.NONE));
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_ROLE_NETWORK_HAS_NO_BOOT_PROTOCOL_ENTITY, getNetwork().getName())).when(failWhen);
}
#end_block

#method_before
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(BusinessEntityMap<VdsNetworkInterface> existingInterfaces) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null) {
        VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
        if (existingIface != null) {
            final Predicate<String> isManagementIpPredicate = new IpAddressPredicate(host.getHostName());
            if (ipConfiguration.hasIpv4PrimaryAddressSet() && ipConfiguration.getIpv4PrimaryAddress().getBootProtocol() == Ipv4BootProtocol.STATIC_IP) {
                String oldIpv4Address = existingIface.getIpv4Address();
                return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(isManagementIpPredicate.test(oldIpv4Address) && !new IpAddressPredicate(oldIpv4Address).test(ipConfiguration.getIpv4PrimaryAddress().getAddress()));
            }
            if (ipConfiguration.hasIpv6PrimaryAddressSet() && ipConfiguration.getIpv6PrimaryAddress().getBootProtocol() == Ipv6BootProtocol.STATIC_IP) {
                String oldIpv6Address = existingIface.getIpv6Address();
                return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(isManagementIpPredicate.test(oldIpv6Address) && !new IpAddressPredicate(oldIpv6Address).test(ipConfiguration.getIpv6PrimaryAddress().getAddress()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(BusinessEntityMap<VdsNetworkInterface> existingInterfaces) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getPrimaryAddress().getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    vmInterfaceManager = Mockito.spy(new VmInterfaceManager(macPool));
    doReturn(vmNetworkStatisticsDao).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDao).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDao).when(vmInterfaceManager).getVmDao();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#method_after
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    vmInterfaceManager = Mockito.spy(new VmInterfaceManager(macPoolManagerStrategy));
    doReturn(vmNetworkStatisticsDao).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDao).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDao).when(vmInterfaceManager).getVmDao();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#end_block

#method_before
@Test
public void add() {
    runAddAndVerify(createNewInterface(), false, times(0), OS_ID);
}
#method_after
@Test
public void add() {
    runAddAndVerify(createNewInterface(), false, times(0), OS_ID, VERSION_3_2);
}
#end_block

#method_before
@Test
public void addWithExistingMacAddressSucceed() {
    VmNic iface = createNewInterface();
    runAddAndVerify(iface, true, times(1), OS_ID);
}
#method_after
@Test
public void addWithExistingMacAddressSucceed() {
    VmNic iface = createNewInterface();
    runAddAndVerify(iface, true, times(1), OS_ID, VERSION_3_2);
}
#end_block

#method_before
protected void runAddAndVerify(VmNic iface, boolean reserveExistingMac, VerificationMode addMacVerification, int osId) {
    OsRepository osRepository = mock(OsRepository.class);
    when(vmInterfaceManager.getOsRepository()).thenReturn(osRepository);
    when(osRepository.hasNicHotplugSupport(any(Integer.class), any(Version.class))).thenReturn(true);
    vmInterfaceManager.add(iface, NoOpCompensationContext.getInstance(), reserveExistingMac, osId, version);
    if (reserveExistingMac) {
        verify(macPool, times(1)).forceAddMac(iface.getMacAddress());
    } else {
        verifyZeroInteractions(macPool);
    }
    verifyAddDelegatedCorrectly(iface, addMacVerification);
}
#method_after
protected void runAddAndVerify(VmNic iface, boolean reserveExistingMac, VerificationMode addMacVerification, int osId, Version version) {
    OsRepository osRepository = mock(OsRepository.class);
    when(vmInterfaceManager.getOsRepository()).thenReturn(osRepository);
    when(osRepository.hasNicHotplugSupport(any(Integer.class), any(Version.class))).thenReturn(true);
    vmInterfaceManager.add(iface, NoOpCompensationContext.getInstance(), reserveExistingMac, osId, version);
    if (reserveExistingMac) {
        verify(macPoolManagerStrategy, times(1)).forceAddMac((iface.getMacAddress()));
    } else {
        verifyZeroInteractions(macPoolManagerStrategy);
    }
    verifyAddDelegatedCorrectly(iface, addMacVerification);
}
#end_block

#method_before
protected void verifyAddDelegatedCorrectly(VmNic iface, VerificationMode addMacVerification) {
    verify(macPool, addMacVerification).forceAddMac(iface.getMacAddress());
    verify(vmNicDao).save(iface);
    verify(vmNetworkStatisticsDao).save(iface.getStatistics());
}
#method_after
protected void verifyAddDelegatedCorrectly(VmNic iface, VerificationMode addMacVerification) {
    verify(macPoolManagerStrategy, addMacVerification).forceAddMac(iface.getMacAddress());
    verify(vmNicDao).save(iface);
    verify(vmNetworkStatisticsDao).save(iface.getStatistics());
}
#end_block

#method_before
protected void verifyRemoveAllDelegatedCorrectly(VmNic iface) {
    verify(macPool, times(1)).freeMac(iface.getMacAddress());
    verify(vmNicDao).remove(iface.getId());
    verify(vmNetworkStatisticsDao).remove(iface.getId());
}
#method_after
protected void verifyRemoveAllDelegatedCorrectly(VmNic iface) {
    verify(macPoolManagerStrategy, times(1)).freeMac(iface.getMacAddress());
    verify(vmNicDao).remove(iface.getId());
    verify(vmNetworkStatisticsDao).remove(iface.getId());
}
#end_block

#method_before
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL).unless(hostStatus == host.getStatus());
}
#method_after
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, ReplacementUtils.createSetVariableString("hostStatus", hostStatus.name())).unless(hostStatus == host.getStatus());
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy installer = new VdsDeploy(getVds())) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        installer.setCorrelationId(getCorrelationId());
        boolean configureNetworkUsingHostDeploy = !FeatureSupported.setupManagementNetwork(getVds().getVdsGroupCompatibilityVersion());
        installer.setReboot(parameters.isRebootAfterInstallation() && configureNetworkUsingHostDeploy);
        if (configureNetworkUsingHostDeploy) {
            final Network managementNetwork = managementNetworkUtil.getManagementNetwork(getVdsGroupId());
            installer.setManagementNetwork(managementNetwork.getName());
        }
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                installer.setOpenStackAgentProperties(agentProperties);
            }
        }
        installer.setHostedEngine(parameters.getHostedEngineConfiguration());
        switch(getVds().getVdsType()) {
            case VDS:
                installer.setFirewall(parameters.getOverrideFirewall());
                break;
            case oVirtNode:
                if (parameters.getOverrideFirewall()) {
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                }
                break;
            default:
                throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
        }
        installer.setVMConsole(parameters.getEnableSerialConsole());
        switch(getParameters().getAuthMethod()) {
            case Password:
                installer.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                installer.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        installer.execute();
        switch(installer.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                if (checkProtocolTofallback(getVds())) {
                    // we need to check whether we are connecting to vdsm which supports xmlrpc only
                    ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager);
                    if (!detector.attemptConnection()) {
                        detector.stopConnection();
                        if (detector.attemptFallbackProtocol()) {
                            detector.setFallbackProtocol();
                        } else {
                            throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                        }
                    }
                }
                if (!configureNetworkUsingHostDeploy) {
                    configureManagementNetwork();
                }
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                    deploy.addUnit(new VdsDeployIptablesUnit());
                    break;
                case oVirtNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            /* in 3.6.0 we always enable serial console without user intervention. */
            if (FeatureSupported.virtioSerialConsole(getVds().getVdsGroupCompatibilityVersion())) {
                deploy.addUnit(new VdsDeployVmconsoleUnit());
            } else {
                log.warn("Installation of Host {} will skip Virtio Serial Console, because it is not supported for clusterLevel {}", getVds().getName(), getVds().getVdsGroupCompatibilityVersion());
            }
        }
        if (parameters.getHostedEngineConfiguration() != null) {
            deploy.addUnit(new VdsDeployHostedEngineUnit(parameters.getHostedEngineConfiguration()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                if (checkProtocolTofallback(getVds())) {
                    // we need to check whether we are connecting to vdsm which supports xmlrpc only
                    ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager);
                    if (!detector.attemptConnection()) {
                        detector.stopConnection();
                        if (detector.attemptFallbackProtocol()) {
                            detector.setFallbackProtocol();
                        } else {
                            throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                        }
                    }
                }
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (getVdsDao().get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        if (getParameters().getHostedEngineDeployConfiguration() != null && getParameters().getHostedEngineDeployConfiguration().isDeployHostedEngineAgent()) {
            tempVar.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVds().getHostName(), getParameters().getHostedEngineDeployConfiguration().getHeAgentGateway()));
        }
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    if (oldHost.getProtocol() != getParameters().getVdsStaticData().getProtocol()) {
        ResourceManager.getInstance().reestablishConnection(oldHost.getId());
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(oldHost.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(oldHost.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(oldHost.getVdsGroupId(), net);
                }
            }
        }
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (getVdsDao().get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        if (getParameters().getHostedEngineDeployConfiguration() != null && getParameters().getHostedEngineDeployConfiguration().isDeployHostedEngineAgent()) {
            tempVar.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVds().getHostName(), getParameters().getHostedEngineDeployConfiguration().getHeAgentGateway()));
        }
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    if (oldHost.getProtocol() != getParameters().getVdsStaticData().getProtocol()) {
        ResourceManager.getInstance().reestablishConnection(oldHost.getId());
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(oldHost.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(oldHost.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(oldHost.getVdsGroupId(), net);
                }
            }
        }
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null && getParameters().getHostedEngineDeployConfiguration().isDeployHostedEngineAgent()) {
            installVdsParameters.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVds().getHostName(), getParameters().getHostedEngineDeployConfiguration().getHeAgentGateway()));
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null && getParameters().getHostedEngineDeployConfiguration().isDeployHostedEngineAgent()) {
            installVdsParameters.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVds().getHostName(), getParameters().getHostedEngineDeployConfiguration().getHeAgentGateway()));
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Test
public void heVmUnManaged() {
    when(hostedEngineHelper.isVmManaged()).thenReturn(false);
    assertThat(validator.isHeVmManaged(new HostedEngineDeployConfiguration(true, "")), ValidationResultMatchers.failsWith(EngineMessage.HOSTED_ENGINE_VM_IS_UNMANAGED));
}
#method_after
@Test
public void heVmUnManaged() {
    when(hostedEngineHelper.isVmManaged()).thenReturn(false);
    assertThat(validator.isHeVmManaged(new HostedEngineDeployConfiguration(true, "")), failsWith(EngineMessage.HOSTED_ENGINE_VM_IS_UNMANAGED));
}
#end_block

#method_before
public Map<String, ByteBuffer> unTar() throws IOException {
    Map<String, ByteBuffer> fileContent = new HashMap<>();
    for (TarArchiveEntry tarEntry = tarInputStream.getNextTarEntry(); tarEntry != null; tarEntry = tarInputStream.getNextTarEntry()) {
        // Get Size of the file and create a byte array for the size.
        byte[] content = new byte[(int) tarEntry.getSize()];
        // FIXME not clear why content.length = 0 is an unsupported entry (i.e empty files)
        if (tarInputStream.read(content) == -1) {
            log.error("File '{}' could not be read.", tarEntry.getFile());
            continue;
        }
        fileContent.put(tarEntry.getName(), ByteBuffer.wrap(content));
    }
    return fileContent;
}
#method_after
public Map<String, ByteBuffer> unTar() throws IOException {
    Map<String, ByteBuffer> fileContent = new HashMap<>();
    for (TarArchiveEntry tarEntry = tarInputStream.getNextTarEntry(); tarEntry != null; tarEntry = tarInputStream.getNextTarEntry()) {
        // Get Size of the file and create a byte array for the size.
        byte[] content = new byte[(int) tarEntry.getSize()];
        // Read file from the archive into byte array.
        if (tarInputStream.read(content) == -1) {
            log.warn("File '{}' could not be read.", tarEntry.getFile());
        }
        fileContent.put(tarEntry.getName(), ByteBuffer.wrap(content));
    }
    return fileContent;
}
#end_block

#method_before
@Test
public void untarAndSkipBadEntries() throws IOException {
    byte[] mixedContentArchive = load("mixed-content.tar");
    try (TarInMemoryExport tar = new TarInMemoryExport(new ByteArrayInputStream(mixedContentArchive))) {
        Map<String, ByteBuffer> emptyTarEntries = tar.unTar();
        assertThat(emptyTarEntries.entrySet(), not(empty()));
        assertThat(emptyTarEntries, hasKey("file.conf"));
        assertThat(emptyTarEntries.get("file.conf"), notNullValue());
        // apparently empty files in an archive are not listed as entries.
        assertThat(emptyTarEntries, not(hasKey("empty.file")));
    }
}
#method_after
@Test
public void untarAndSkipBadEntries() throws IOException {
    byte[] mixedContentArchive = load("mixed-content.tar");
    try (TarInMemoryExport tar = new TarInMemoryExport(new ByteArrayInputStream(mixedContentArchive))) {
        Map<String, ByteBuffer> entries = tar.unTar();
        assertThat(entries.entrySet(), not(empty()));
        assertThat(entries, hasKey("file.conf"));
        assertThat(entries.get("file.conf"), notNullValue());
        assertThat(entries, hasKey("empty.file"));
    }
}
#end_block

#method_before
@Override
public void idle() {
    if (lastSendInterval++ >= sendIntervals) {
        lastSendInterval = 0;
        Iterator<DispatchAttempt> iterator = sendQueue.iterator();
        while (iterator.hasNext()) {
            DispatchAttempt attempt = iterator.next();
            try {
                EventMessageContent message = new EventMessageContent();
                message.prepareMessage(hostName, attempt.event, isBodyHtml);
                log.info("Sending mail subject='{}' to='{}'", message.getMessageSubject(), attempt.address);
                log.debug("Send mail body='{}'", message.getMessageBody());
                sendMail(attempt.address, message.getMessageSubject(), message.getMessageBody());
                log.info("E-mail sent successfully");
                notifyObservers(DispatchResult.success(attempt.event, attempt.address, EventNotificationMethod.SMTP));
                iterator.remove();
            } catch (Exception ex) {
                attempt.retries++;
                if (attempt.retries >= retries) {
                    notifyObservers(DispatchResult.failure(attempt.event, attempt.address, EventNotificationMethod.SMTP, ex.getMessage()));
                    iterator.remove();
                }
            }
        }
    }
}
#method_after
@Override
public void idle() {
    if (lastSendInterval++ >= sendIntervals) {
        lastSendInterval = 0;
        Iterator<DispatchAttempt> iterator = sendQueue.iterator();
        while (iterator.hasNext()) {
            DispatchAttempt attempt = iterator.next();
            try {
                EventMessageContent message = new EventMessageContent();
                message.prepareMessage(hostName, attempt.event, isBodyHtml);
                log.info("Send mail subject='{}' to='{}'", message.getMessageSubject(), attempt.address);
                log.debug("Send mail body='{}'", message.getMessageBody());
                sendMail(attempt.address, message.getMessageSubject(), message.getMessageBody());
                log.info("Mail subject='{}' to='{}' sent successfully", message.getMessageSubject(), attempt.address);
                notifyObservers(DispatchResult.success(attempt.event, attempt.address, EventNotificationMethod.SMTP));
                iterator.remove();
            } catch (Exception ex) {
                attempt.retries++;
                if (attempt.retries >= retries) {
                    notifyObservers(DispatchResult.failure(attempt.event, attempt.address, EventNotificationMethod.SMTP, ex.getMessage()));
                    iterator.remove();
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    Version newClusterVersion = (Version) value;
    if (value == null || (isActiveVm && !newClusterVersion.equalsMajorMinor(oldClusterVersion))) {
        result.setSuccess(false);
        result.getReasons().add(ConstantsManager.getInstance().getConstants().cannotClusterVersionChangeWithActiveVm());
    }
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    Version newClusterVersion = (Version) value;
    if (value == null || (hasActiveVm && !newClusterVersion.equals(oldClusterVersion))) {
        result.setSuccess(false);
        result.getReasons().add(ConstantsManager.getInstance().getConstants().cannotClusterVersionChangeWithActiveVm());
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getClusterDao().get(getCluster().getId());
    if (oldGroup == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldGroup.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    if (result && !getCluster().getCompatibilityVersion().equalsMajorMinor(oldGroup.getCompatibilityVersion())) {
        // all VMs must be in Down state when major.minor cluster version change
        for (VM vm : vmList) {
            if (vm.getStatus() != VMStatus.Down) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_VERSION_CANNOT_UPDATE_WHEN_ACTIVE_VM);
                break;
            }
        }
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldGroup);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getClusterDao().get(getCluster().getId());
    if (oldGroup == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldGroup.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    if (result && !getCluster().getCompatibilityVersion().equals(oldGroup.getCompatibilityVersion())) {
        // all VMs must be in Down state when major.minor cluster version change
        for (VM vm : vmList) {
            if (!vm.isDown()) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_VERSION_CANNOT_UPDATE_WHEN_ACTIVE_VM);
                break;
            }
        }
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldGroup);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<>(false));
    setEnableHaReservation(new EntityModel<>(false));
    setEnableOptionalReason(new EntityModel<>(false));
    setMigrationPolicies(new ListModel<MigrationPolicy>());
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    setGlusterTunedProfile(new ListModel<String>());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setAdditionalClusterFeatures(new ListModel<List<AdditionalFeature>>());
    List<List<AdditionalFeature>> additionalFeatures = new ArrayList<>();
    additionalFeatures.add(Collections.<AdditionalFeature>emptyList());
    getAdditionalClusterFeatures().setItems(additionalFeatures, null);
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangeable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangeable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            } else {
                getEnableTrustedService().setIsChangeable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangeable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            }
            getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
            if (getEnableGlusterService().getEntity()) {
                initTunedProfiles();
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangeable(false);
            } else {
                getEnableGlusterService().setIsChangeable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // KSM feature
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    getKsmPolicyForNumaSelection().setIsChangeable(false);
    getEnableKsm().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableKsm().getEntity() == null) {
                return;
            }
            if (getEnableKsm().getEntity() == true) {
                getKsmPolicyForNumaSelection().setIsChangeable(true);
            }
            if (getEnableKsm().getEntity() == false) {
                getKsmPolicyForNumaSelection().setIsChangeable(false);
            }
        }
    });
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangeable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangeable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangeable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangeable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    if (isEdit) {
        Guid clusterId = getEntity().getId();
        Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInClusterByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                Integer numOfActiveVms = ((VdcQueryReturnValue) returnValue).getReturnValue();
                isActiveVm = numOfActiveVms != 0;
            }
        }));
    }
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setMigrationTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
    setCustomMigrationNetworkBandwidth(new EntityModel<Integer>());
    setMigrationBandwidthLimitType(new ListModel<MigrationBandwidthLimitType>());
    List<MigrationPolicy> policies = AsyncDataProvider.getInstance().getMigrationPolicies();
    getMigrationPolicies().setItems(policies);
    if (isEdit) {
        for (MigrationPolicy policy : policies) {
            if (Objects.equals(policy.getId(), getEntity().getMigrationPolicyId())) {
                getMigrationPolicies().setSelectedItem(policy);
                break;
            }
        }
    }
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<>(false));
    setEnableHaReservation(new EntityModel<>(false));
    setEnableOptionalReason(new EntityModel<>(false));
    setMigrationPolicies(new ListModel<MigrationPolicy>());
    getMigrationPolicies().getSelectedItemChangedEvent().addListener(this);
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    setGlusterTunedProfile(new ListModel<String>());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setAdditionalClusterFeatures(new ListModel<List<AdditionalFeature>>());
    List<List<AdditionalFeature>> additionalFeatures = new ArrayList<>();
    additionalFeatures.add(Collections.<AdditionalFeature>emptyList());
    getAdditionalClusterFeatures().setItems(additionalFeatures, null);
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangeable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangeable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            } else {
                getEnableTrustedService().setIsChangeable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangeable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            }
            getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
            if (getEnableGlusterService().getEntity()) {
                initTunedProfiles();
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangeable(false);
            } else {
                getEnableGlusterService().setIsChangeable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // KSM feature
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    getKsmPolicyForNumaSelection().setIsChangeable(false);
    getEnableKsm().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableKsm().getEntity() == null) {
                return;
            }
            if (getEnableKsm().getEntity() == true) {
                getKsmPolicyForNumaSelection().setIsChangeable(true);
            }
            if (getEnableKsm().getEntity() == false) {
                getKsmPolicyForNumaSelection().setIsChangeable(false);
            }
        }
    });
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangeable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangeable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangeable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangeable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    if (isEdit) {
        Guid clusterId = getEntity().getId();
        Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInClusterByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                Integer numOfActiveVms = ((VdcQueryReturnValue) returnValue).getReturnValue();
                hasActiveVm = numOfActiveVms != 0;
            }
        }));
    }
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setMigrationTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
    setCustomMigrationNetworkBandwidth(new EntityModel<Integer>());
    setMigrationBandwidthLimitType(new ListModel<MigrationBandwidthLimitType>());
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        } else if (sender == getArchitecture()) {
            architectureSelectedItemChanged(args);
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangeable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        } else if (sender == getArchitecture()) {
            architectureSelectedItemChanged(args);
        } else if (sender == getMigrationPolicies()) {
            migrationPoliciesChanged();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangeable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getCompatibilityVersion();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    getVersionSupportsCpuThreads().setEntity(true);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangeable(true);
    setRngSourcesCheckboxes(version);
    updateFencingPolicyContent(version);
    updateKSMPolicy();
    updateMigrateOnError();
    updateMigrationOptions();
    getMigrationPolicies().updateChangeability(ConfigurationValues.MigrationPoliciesSupported, version);
    refreshAdditionalClusterFeaturesList();
    if (getEnableGlusterService().getEntity()) {
        initTunedProfiles();
    }
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getCompatibilityVersion();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    getVersionSupportsCpuThreads().setEntity(true);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangeable(true);
    setRngSourcesCheckboxes(version);
    updateFencingPolicyContent(version);
    updateKSMPolicy();
    updateMigrateOnError();
    getMigrationPolicies().updateChangeability(ConfigurationValues.MigrationPoliciesSupported, version);
    refreshAdditionalClusterFeaturesList();
    if (getEnableGlusterService().getEntity()) {
        initTunedProfiles();
    }
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new ClusterVersionChangeValidation(isActiveVm, getEntity().getCompatibilityVersion()) });
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new ClusterVersionChangeValidation(hasActiveVm, getEntity().getCompatibilityVersion()) });
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#end_block

#method_before
private void executeNewAndEdit(final VM vm) {
    if (getItems() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Iterator<InstanceImageLineModel> lineModelIterator = orderedDisksIterator((List<Disk>) returnValue);
            storeNextDisk(lineModelIterator, vm);
        }
    }), vm.getId());
}
#method_after
private void executeNewAndEdit(final VM vm) {
    if (getItems() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Iterator<InstanceImageLineModel> lineModelIterator = orderedDisksIterator((List<Disk>) returnValue, vm);
            storeNextDisk(lineModelIterator, vm);
        }
    }), vm.getId());
}
#end_block

#method_before
private Iterator<InstanceImageLineModel> orderedDisksIterator(List<Disk> disks) {
    if (disks.size() == 0) {
        return getItems().iterator();
    }
    Disk previouslyBootDisk = findBoot(disks);
    if (previouslyBootDisk == null) {
        return getItems().iterator();
    }
    InstanceImageLineModel fromBootToNonBoot = findBecomeNonBoot(previouslyBootDisk);
    if (fromBootToNonBoot == null) {
        return getItems().iterator();
    }
    // now we know that the disk changed from boot to non boot so this command has to be executed as first
    Set<InstanceImageLineModel> res = new LinkedHashSet<>();
    res.add(fromBootToNonBoot);
    res.addAll(getItems());
    return res.iterator();
}
#method_after
private Iterator<InstanceImageLineModel> orderedDisksIterator(List<Disk> disks, VM vm) {
    if (disks.size() == 0) {
        return getItems().iterator();
    }
    Disk previouslyBootDisk = findBoot(disks, vm);
    if (previouslyBootDisk == null) {
        return getItems().iterator();
    }
    InstanceImageLineModel fromBootToNonBoot = findBecomeNonBoot(previouslyBootDisk);
    if (fromBootToNonBoot == null) {
        return getItems().iterator();
    }
    // now we know that the disk changed from boot to non boot so this command has to be executed as first
    Set<InstanceImageLineModel> res = new LinkedHashSet<>();
    res.add(fromBootToNonBoot);
    res.addAll(getItems());
    return res.iterator();
}
#end_block

#method_before
private Disk findBoot(List<Disk> disks) {
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(getVm().getId());
        if (dve != null && dve.isBoot()) {
            return disk;
        }
    }
    return null;
}
#method_after
private Disk findBoot(List<Disk> disks, VM vm) {
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve != null && dve.isBoot()) {
            return disk;
        }
    }
    return null;
}
#end_block

#method_before
protected void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
        // updateBootableFrom(disks);
        }
    }), getVm().getId());
}
#method_after
protected void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            updateCanSetBoot(disks);
        }
    }), getVm().getId());
}
#end_block

#method_before
public void updateBootableFrom(List<DiskModel> vmDisks) {
    getIsBootable().setEntity(true);
    getIsBootable().setIsChangeable(true);
    if (getDisk() == null || !getDisk().isDiskSnapshot()) {
        for (DiskModel disk : vmDisks) {
            if (disk.getDiskVmElement().isBoot() && !disk.getDisk().equals(getDisk())) {
                getIsBootable().setEntity(false);
                if (!disk.getDisk().isDiskSnapshot()) {
                    getIsBootable().setChangeProhibitionReason(constants.onlyOneBootableDisk());
                    getIsBootable().setIsChangeable(false);
                    break;
                }
            }
        }
    }
}
#method_after
public void updateBootableFrom(List<DiskModel> vmDisks) {
    getIsBootable().setIsChangeable(true);
    if (getDisk() == null || !getDisk().isDiskSnapshot()) {
        for (DiskModel disk : vmDisks) {
            if (disk.getDiskVmElement().isBoot() && !disk.getDisk().equals(getDisk())) {
                getIsBootable().setEntity(false);
                if (!disk.getDisk().isDiskSnapshot()) {
                    getIsBootable().setChangeProhibitionReason(constants.onlyOneBootableDisk());
                    getIsBootable().setIsChangeable(false);
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
private void fillData() {
    if (diskModel.getEntity() == null) {
        return;
    }
    if (diskModel.getEntity() instanceof InstanceImagesAttachDiskModel) {
        List<EntityModel<DiskModel>> disks = ((InstanceImagesAttachDiskModel) diskModel.getEntity()).getSelectedDisks();
        if (disks.size() != 0) {
            updateName(disks.get(0).getEntity().getDisk());
        }
    } else {
        updateName(diskModel.getEntity().getDisk());
    }
}
#method_after
private void fillData() {
    if (diskModel.getEntity() == null) {
        return;
    }
    if (diskModel.getEntity() instanceof InstanceImagesAttachDiskModel) {
        List<EntityModel<DiskModel>> disks = ((InstanceImagesAttachDiskModel) diskModel.getEntity()).getSelectedDisks();
        if (disks.size() != 0) {
            updateName(disks.get(0).getEntity());
        }
    } else {
        updateName(diskModel.getEntity());
    }
}
#end_block

#method_before
private void updateName(Disk disk) {
    if (disk == null) {
        return;
    }
    String diskName = disk.getDiskAlias();
    String size = Long.toString(disk.getSize());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
        size = Long.toString(((DiskImage) disk).getSizeInGigabytes());
    }
    String type;
    if (diskExists) {
        type = constants.existingDisk();
    } else if (getDiskModel().getEntity() instanceof InstanceImagesAttachDiskModel) {
        type = constants.attachingDisk();
    } else {
        type = constants.creatingDisk();
    }
    name.setEntity(messages.vmDialogDisk(diskName, size, type, ""));
}
#method_after
private void updateName(DiskModel diskModel) {
    Disk disk = diskModel.getDisk();
    if (disk == null) {
        return;
    }
    String diskName = disk.getDiskAlias();
    String size = Long.toString(disk.getSize());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
        size = Long.toString(((DiskImage) disk).getSizeInGigabytes());
    }
    String type;
    if (diskExists) {
        type = constants.existingDisk();
    } else if (getDiskModel().getEntity() instanceof InstanceImagesAttachDiskModel) {
        type = constants.attachingDisk();
    } else {
        type = constants.creatingDisk();
    }
    name.setEntity(messages.vmDialogDisk(diskName, size, type, diskModel.getIsBootable().getEntity() ? constants.bootDisk() : ""));
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
private void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(CommandBase.this, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        getCompensationContext().afterCompensationCleanup();
        return null;
    });
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            try {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            logMissingPermission(permSubject);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            setCommandStatus(CommandStatus.FAILED);
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            setCommandStatus(CommandStatus.FAILED);
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            logMissingPermission(permSubject);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
public void loadVmFromOva() {
    clearProblem();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmFromOva(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) returnValue;
            if (queryReturnValue.getSucceeded()) {
                VM vm = queryReturnValue.getReturnValue();
                updateVms(Collections.singletonList(vm));
            } else {
                setError(messages.failedToLoadOva(getOvaPath().getEntity()));
            }
            stopProgress();
        }
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#method_after
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmFromOva(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) returnValue;
            if (queryReturnValue.getSucceeded()) {
                VM vm = queryReturnValue.getReturnValue();
                updateVms(Collections.singletonList(vm));
            } else {
                setError(messages.failedToLoadOva(getOvaPath().getEntity()));
            }
            stopProgress();
        }
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#end_block

#method_before
public void loadVmsFromVmware() {
    clearProblem();
    clearVms();
    if (!validateVmwareConfiguration()) {
        return;
    }
    Guid proxyId = getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.VMWARE, getUrl(), getUsername().getEntity(), getPassword().getEntity(), proxyId);
}
#method_after
public void loadVmsFromVmware() {
    clearForLoad();
    if (!validateVmwareConfiguration()) {
        return;
    }
    Guid proxyId = getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.VMWARE, getUrl(), getUsername().getEntity(), getPassword().getEntity(), proxyId);
}
#end_block

#method_before
public void loadVmsFromXen() {
    clearProblem();
    if (!validateXenConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    // $NON-NLS-1$ //$NON-NLS-2$
    loadVMsFromExternalProvider(OriginType.XEN, getXenUri().getEntity(), "", "", proxyId);
}
#method_after
public void loadVmsFromXen() {
    clearForLoad();
    if (!validateXenConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    // $NON-NLS-1$ //$NON-NLS-2$
    loadVMsFromExternalProvider(OriginType.XEN, getXenUri().getEntity(), "", "", proxyId);
}
#end_block

#method_before
public void loadVmsFromKvm() {
    clearProblem();
    if (!validateKvmConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.KVM, getKvmUri().getEntity(), getKvmUsername().getEntity(), getKvmPassword().getEntity(), proxyId);
}
#method_after
public void loadVmsFromKvm() {
    clearForLoad();
    if (!validateKvmConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.KVM, getKvmUri().getEntity(), getKvmUsername().getEntity(), getKvmPassword().getEntity(), proxyId);
}
#end_block

#method_before
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        VmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), false, true, true);
        disks.addAll(ImagesHandler.getCinderLeafImages(getDiskDao().getAllForVm(vm.getId()), false));
    }
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().exportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        VmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), false, true, true);
        disks.addAll(ImagesHandler.getCinderLeafImages(getDiskDao().getAllForVm(vm.getId()), false));
    }
    populateDisksWithVmData(disks, vm.getId());
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().exportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
protected void synchronizeDisksFromSnapshot(Guid vmId, Guid snapshotId, Guid activeSnapshotId, List<DiskImage> disksFromSnapshot, String vmName) {
    List<Guid> diskIdsFromSnapshot = new ArrayList<>();
    // Sync disks that exist or existed in the snapshot.
    int count = 1;
    for (DiskImage diskImage : disksFromSnapshot) {
        diskIdsFromSnapshot.add(diskImage.getId());
        if (getBaseDiskDao().exists(diskImage.getId())) {
            getBaseDiskDao().update(diskImage);
        } else {
            // If can't find the image, insert it as illegal so that it can't be used and make the device unplugged.
            if (getDiskImageDao().getSnapshotById(diskImage.getImageId()) == null) {
                diskImage.setImageStatus(ImageStatus.ILLEGAL);
                diskImage.setVmSnapshotId(activeSnapshotId);
                ImagesHandler.addImage(diskImage, true, (diskImage.getStorageIds() == null) ? null : new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId()));
            }
            ImagesHandler.addDiskToVm(diskImage, vmId);
        }
        diskImage.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(diskImage, vmName, count));
        count++;
    }
    removeDisksNotInSnapshot(vmId, diskIdsFromSnapshot);
}
#method_after
protected void synchronizeDisksFromSnapshot(Guid vmId, Guid snapshotId, Guid activeSnapshotId, List<DiskImage> disksFromSnapshot, String vmName) {
    List<Guid> diskIdsFromSnapshot = new ArrayList<>();
    // Sync disks that exist or existed in the snapshot.
    int count = 1;
    for (DiskImage diskImage : disksFromSnapshot) {
        diskIdsFromSnapshot.add(diskImage.getId());
        if (getBaseDiskDao().exists(diskImage.getId())) {
            getBaseDiskDao().update(diskImage);
            DiskVmElement dve = getDiskVmElementDao().get(diskImage.getDiskVmElementForVm(vmId).getId());
            if (dve != null && !dve.equals(diskImage.getDiskVmElementForVm(vmId))) {
                getDiskVmElementDao().update(diskImage.getDiskVmElementForVm(vmId));
            }
        } else {
            // If can't find the image, insert it as illegal so that it can't be used and make the device unplugged.
            if (getDiskImageDao().getSnapshotById(diskImage.getImageId()) == null) {
                diskImage.setImageStatus(ImageStatus.ILLEGAL);
                diskImage.setVmSnapshotId(activeSnapshotId);
                ImagesHandler.addImage(diskImage, true, (diskImage.getStorageIds() == null) ? null : new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId()));
            }
            ImagesHandler.addDiskToVm(diskImage, vmId);
        }
        diskImage.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(diskImage, vmName, count));
        count++;
    }
    removeDisksNotInSnapshot(vmId, diskIdsFromSnapshot);
}
#end_block

#method_before
public static <T extends Disk> boolean checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<? extends VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    if (pciInUse > maxPciSlots) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    } else if (MAX_VIRTIO_SCSI_DISKS < disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS.name());
    } else if (MAX_SPAPR_SCSI_DISKS < disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS.name());
    }
    return result;
}
#method_after
public static boolean checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<? extends VmNic> interfaces, List<DiskVmElement> diskVmElements, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += diskVmElements.stream().filter(dve -> dve.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    if (pciInUse > maxPciSlots) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    } else if (MAX_VIRTIO_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS.name());
    } else if (MAX_SPAPR_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS.name());
    }
    return result;
}
#end_block

#method_before
protected boolean isDiskSupportedForPlugUnPlug(Disk disk) {
    if (disk.getDiskInterface() == DiskInterface.IDE) {
        addValidationMessageVariable("diskAlias", disk.getDiskAlias());
        addValidationMessageVariable("vmName", getVm().getName());
        return failValidation(EngineMessage.HOT_PLUG_IDE_DISK_IS_NOT_SUPPORTED);
    }
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(disk.getDiskInterface().name())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
protected boolean isDiskSupportedForPlugUnPlug(DiskVmElement diskVmElement, String diskAlias) {
    if (diskVmElement.getDiskInterface() == DiskInterface.IDE) {
        addValidationMessageVariable("diskAlias", diskAlias);
        addValidationMessageVariable("vmName", getVm().getName());
        return failValidation(EngineMessage.HOT_PLUG_IDE_DISK_IS_NOT_SUPPORTED);
    }
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(diskVmElement.getDiskInterface().name())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
/* Tests for alias generation in addVmImagesAndSnapshots() */
@Test
public void testAliasGenerationByAddVmImagesAndSnapshotsWithCollapse() {
    ImportVmParameters params = createParameters();
    params.setCopyCollapse(true);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommandStub(params, this.macPoolPerDc));
    cmd.init();
    DiskImage collapsedDisk = params.getVm().getImages().get(1);
    doNothing().when(cmd).saveImage(collapsedDisk);
    doNothing().when(cmd).saveBaseDisk(collapsedDisk);
    doNothing().when(cmd).saveDiskImageDynamic(collapsedDisk);
    doReturn(new Snapshot()).when(cmd).addActiveSnapshot(any(Guid.class));
    cmd.addVmImagesAndSnapshots();
    assertEquals("Disk alias not generated", "testVm_Disk1", collapsedDisk.getDiskAlias());
}
#method_after
/* Tests for alias generation in addVmImagesAndSnapshots() */
@Test
public void testAliasGenerationByAddVmImagesAndSnapshotsWithCollapse() {
    ImportVmParameters params = createParameters();
    params.setCopyCollapse(true);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommandStub(params, this.macPoolPerDc));
    cmd.init();
    DiskImage collapsedDisk = params.getVm().getImages().get(1);
    doNothing().when(cmd).saveImage(collapsedDisk);
    doNothing().when(cmd).saveBaseDisk(collapsedDisk);
    doNothing().when(cmd).saveDiskImageDynamic(collapsedDisk);
    doNothing().when(cmd).saveDiskVmElement(any(Guid.class), any(Guid.class), any(DiskVmElement.class));
    doReturn(new Snapshot()).when(cmd).addActiveSnapshot(any(Guid.class));
    cmd.addVmImagesAndSnapshots();
    assertEquals("Disk alias not generated", "testVm_Disk1", collapsedDisk.getDiskAlias());
}
#end_block

#method_before
@Test
public void testCDANoCollapseNoSnapshots() {
    final VM v = createVmWithNoSnapshots();
    v.setName("testVm");
    ImportVmParameters params = new ImportVmParameters(v, Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid());
    params.setCopyCollapse(false);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommandStub(params, this.macPoolPerDc));
    cmd.init();
    DiskImage activeDisk = params.getVm().getImages().get(0);
    doNothing().when(cmd).saveImage(activeDisk);
    doNothing().when(cmd).saveDiskImageDynamic(activeDisk);
    doNothing().when(cmd).saveBaseDisk(activeDisk);
    doReturn(new Snapshot()).when(cmd).addActiveSnapshot(any(Guid.class));
    cmd.addVmImagesAndSnapshots();
    assertEquals("Disk alias not generated", "testVm_Disk1", activeDisk.getDiskAlias());
}
#method_after
@Test
public void testCDANoCollapseNoSnapshots() {
    final VM v = createVmWithNoSnapshots();
    v.setName("testVm");
    ImportVmParameters params = new ImportVmParameters(v, Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid());
    params.setCopyCollapse(false);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommandStub(params, this.macPoolPerDc));
    cmd.init();
    DiskImage activeDisk = params.getVm().getImages().get(0);
    doNothing().when(cmd).saveImage(activeDisk);
    doNothing().when(cmd).saveDiskImageDynamic(activeDisk);
    doNothing().when(cmd).saveBaseDisk(activeDisk);
    doNothing().when(cmd).saveDiskVmElement(any(Guid.class), any(Guid.class), any(DiskVmElement.class));
    doReturn(new Snapshot()).when(cmd).addActiveSnapshot(any(Guid.class));
    cmd.addVmImagesAndSnapshots();
    assertEquals("Disk alias not generated", "testVm_Disk1", activeDisk.getDiskAlias());
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            logMissingPermission(permSubject);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
public ValidationResult verifyDisks(Iterable<DiskImage> imageList, Map<Guid, Guid> imageToDestinationDomainMap) {
    if (!params.isImportAsNewEntity() && !params.isImagesExistOnTargetStorageDomain()) {
        return checkIfDisksExist(imageList, imageToDestinationDomainMap);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult verifyDisks(Iterable<DiskImage> imageList, Map<Guid, Guid> imageToDestinationDomainMap) {
    if (!params.isImportAsNewEntity() && !params.isImagesExistOnTargetStorageDomain()) {
        return new DiskImagesValidator(imageList).diskImagesOnStorage(imageToDestinationDomainMap);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
public final void afterCompensationCleanup() {
    listeners.forEach(CompensationListener::afterCompensation);
    doAfterCompensationCleanup();
}
#method_after
@Override
public final void afterCompensationCleanup() {
    processListenersInReverseOrder(CompensationListener::afterCompensation);
    doAfterCompensationCleanup();
}
#end_block

#method_before
@Override
public final void cleanupCompensationDataAfterSuccessfulCommand() {
    listeners.forEach(CompensationListener::cleaningCompensationDataAfterSuccess);
    doCleanupCompensationDataAfterSuccessfulCommand();
}
#method_after
@Override
public final void cleanupCompensationDataAfterSuccessfulCommand() {
    processListenersInReverseOrder(CompensationListener::cleaningCompensationDataAfterSuccess);
    doCleanupCompensationDataAfterSuccessfulCommand();
}
#end_block

#method_before
private CommandContext createContextForStatelessSnapshotCreation() {
    Map<String, String> values = getVmValuesForMsgResolving();
    // Creating snapshots as sub step of run stateless
    Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
    // Add the step as the first step of the new context
    ExecutionContext createSnapshotsCtx = new ExecutionContext();
    createSnapshotsCtx.setMonitored(true);
    createSnapshotsCtx.setStep(createSnapshotsStep);
    getContext().withExecutionContext(createSnapshotsCtx);
    persistCommandIfNeeded();
    return getContext().clone().withExecutionContext(createSnapshotsCtx).withoutCompensationContext();
}
#method_after
private CommandContext createContextForStatelessSnapshotCreation() {
    Map<String, String> values = getVmValuesForMsgResolving();
    // Creating snapshots as sub step of run stateless
    Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
    // Add the step as the first step of the new context
    ExecutionContext createSnapshotsCtx = new ExecutionContext();
    createSnapshotsCtx.setMonitored(true);
    createSnapshotsCtx.setStep(createSnapshotsStep);
    getContext().withExecutionContext(createSnapshotsCtx);
    persistCommandIfNeeded();
    return getContext().clone().withoutCompensationContext();
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    this.addCustomValue("DiskAlias", getDiskImage().getDiskAlias());
    return getSucceeded() ? AuditLogType.USER_REGISTER_DISK_FINISHED_SUCCESS : AuditLogType.USER_REGISTER_DISK_FINISHED_FAILURE;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("DiskAlias", getDiskImage().getDiskAlias());
    return getSucceeded() ? AuditLogType.USER_REGISTER_DISK_FINISHED_SUCCESS : AuditLogType.USER_REGISTER_DISK_FINISHED_FAILURE;
}
#end_block

#method_before
public static void updateBootOrder(Guid vmId) {
    VM vm = dbFacade.getVmDao().get(vmId);
    if (vm != null) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmId);
        // Reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VmHandler.updateDisksForVm(vm, dbFacade.getDiskDao().getAllForVm(vmId));
        VmHandler.updateNetworkInterfacesFromDb(vm);
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices);
        dao.updateBootOrderInBatch(devices);
    }
}
#method_after
public static void updateBootOrder(Guid vmId) {
    VM vm = dbFacade.getVmDao().get(vmId);
    if (vm != null) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmId);
        // Reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VmHandler.updateDisksForVm(vm, dbFacade.getDiskDao().getAllForVm(vmId));
        VmHandler.updateDisksVmDataForVm(vm);
        VmHandler.updateNetworkInterfacesFromDb(vm);
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices);
        dao.updateBootOrderInBatch(devices);
    }
}
#end_block

#method_before
private static int setDiskBootOrder(VM vm, List<VmDevice> devices, int bootOrder) {
    LinkedList<VmDevice> diskDevices = new LinkedList<>();
    for (VmDevice device : devices) {
        if (isDisk(device)) {
            Guid id = device.getDeviceId();
            if (id != null && !id.equals(Guid.Empty)) {
                if (device.getSnapshotId() == null) {
                    diskDevices.addFirst(device);
                } else {
                    diskDevices.addLast(device);
                }
            }
        }
    }
    for (VmDevice device : diskDevices) {
        BaseDisk disk = getDisk(vm, device.getDeviceId());
        if (disk != null && disk.isBoot()) {
            device.setBootOrder(++bootOrder);
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(VM vm, List<VmDevice> devices, int bootOrder) {
    LinkedList<VmDevice> diskDevices = new LinkedList<>();
    for (VmDevice device : devices) {
        if (isDisk(device)) {
            Guid id = device.getDeviceId();
            if (id != null && !id.equals(Guid.Empty)) {
                if (device.getSnapshotId() == null) {
                    diskDevices.addFirst(device);
                } else {
                    diskDevices.addLast(device);
                }
            }
        }
    }
    for (VmDevice device : diskDevices) {
        DiskVmElement dve = getDiskVmElement(vm, device.getDeviceId());
        if (dve != null && dve.isBoot()) {
            device.setBootOrder(++bootOrder);
        }
    }
    return bootOrder;
}
#end_block

#method_before
public static int getCdDeviceIndex(String cdInterface) {
    if ("scsi".equals(cdInterface)) {
        return 0;
    } else if ("ide".equals(cdInterface)) {
        return 2;
    } else if ("sata".equals(cdInterface)) {
        return 0;
    }
    return -1;
}
#method_after
public static int getCdDeviceIndex(String cdInterface) {
    switch(cdInterface) {
        case "scsi":
            return 0;
        case "ide":
            return 2;
        case "sata":
            return 0;
        default:
            return -1;
    }
}
#end_block

#method_before
public static int getCdPayloadDeviceIndex(String cdInterface) {
    if ("scsi".equals(cdInterface)) {
        return 1;
    } else if ("ide".equals(cdInterface)) {
        return 3;
    } else if ("sata".equals(cdInterface)) {
        return 1;
    }
    return -1;
}
#method_after
public static int getCdPayloadDeviceIndex(String cdInterface) {
    switch(cdInterface) {
        case "scsi":
            return 1;
        case "ide":
            return 3;
        case "sata":
            return 1;
        default:
            return -1;
    }
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String iface, int index, String imageLocation) {
    try {
        Map<String, Object> xmlRpcReturnValue;
        if (iface != null) {
            Map<String, Object> driveSpec = new HashMap<>();
            driveSpec.put(VdsProperties.INTERFACE, iface);
            driveSpec.put(VdsProperties.Index, index);
            driveSpec.put(VdsProperties.Path, imageLocation);
            xmlRpcReturnValue = vdsServer.changeCD(vmId, driveSpec);
        } else {
            xmlRpcReturnValue = vdsServer.changeCD(vmId, imageLocation);
        }
        OneVmReturnForXmlRpc wrapper = new OneVmReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.changeCD(vmId, imageLocation);
        OneVmReturnForXmlRpc wrapper = new OneVmReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), loadStorageQos(diskImage));
                    }
                    handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), loadStorageQos(diskImage));
                    }
                    handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
public static Map<VmDevice, Integer> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        if (disk.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstTwoLuns);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
public static Map<VmDevice, Integer> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstTwoLuns);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    vmReturn = getBroker().changeDisk(vmId.toString(), getParameters().getIface(), getParameters().getIndex(), getParameters().getDiskPath());
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(vmReturn.vm, getVds()).getStatus());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    if (getParameters().getIface() != null) {
        Map<String, Object> driveSpec = new HashMap<>();
        driveSpec.put(VdsProperties.INTERFACE, getParameters().getIface());
        driveSpec.put(VdsProperties.Index, Integer.toString(getParameters().getIndex()));
        driveSpec.put(VdsProperties.Path, getParameters().getDiskPath());
        vmReturn = getBroker().changeDisk(vmId.toString(), driveSpec);
    } else {
        vmReturn = getBroker().changeDisk(vmId.toString(), getParameters().getDiskPath());
    }
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(vmReturn.vm, getVds()).getStatus());
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String iface, int index, String imageLocation) {
    RequestBuilder builder = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId);
    if (iface != null) {
        Map<String, String> driveSpec = new HashMap<>();
        driveSpec.put(VdsProperties.INTERFACE, iface);
        driveSpec.put(VdsProperties.Index, Integer.toString(index));
        driveSpec.put(VdsProperties.Path, imageLocation);
        builder = builder.withParameter("driveSpec", driveSpec);
    } else {
        builder = builder.withParameter("driveSpec", imageLocation);
    }
    JsonRpcRequest request = builder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
private void createVmStatelessImages() {
    warnIfNotAllDisksPermitSnapshots();
    log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(vdcReturnValue.getSucceeded());
    if (vdcReturnValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
    } else {
        if (areDisksLocked(vdcReturnValue)) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        getReturnValue().setFault(vdcReturnValue.getFault());
        log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    }
}
#method_after
private void createVmStatelessImages() {
    warnIfNotAllDisksPermitSnapshots();
    log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(vdcReturnValue.getSucceeded());
    if (!vdcReturnValue.getSucceeded()) {
        if (areDisksLocked(vdcReturnValue)) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        getReturnValue().setFault(vdcReturnValue.getFault());
        log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    }
}
#end_block

#method_before
private void sendTicket() {
    // Send the ticket to the virtual machine:
    final DbUser user = getCurrentUser();
    final boolean sent = runVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(getVdsId(), getVmId(), ticket, getParameters().getValidTime(), user.getLoginName(), user.getId(), getParameters().getGraphicsType(), getVm().getConsoleDisconnectAction(), getVm().getClusterCompatibilityVersion())).getSucceeded();
    // Return the ticket only if sending it to the virtual machine succeeded:
    if (sent) {
        setActionReturnValue(ticket);
    }
    setSucceeded(sent);
}
#method_after
private void sendTicket() {
    // Send the ticket to the virtual machine:
    final DbUser user = getCurrentUser();
    final boolean sent = runVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(getVdsId(), getVmId(), ticket, getParameters().getValidTime(), user.getLoginName(), user.getId(), getParameters().getGraphicsType(), getVm().getConsoleDisconnectAction(), getVm().getCompatibilityVersion())).getSucceeded();
    // Return the ticket only if sending it to the virtual machine succeeded:
    if (sent) {
        setActionReturnValue(ticket);
    }
    setSucceeded(sent);
}
#end_block

#method_before
private void setTicketUsingUpdateDevice() {
    Map<String, Object> devStruct = new HashMap<>();
    devStruct.put("deviceType", "graphics");
    devStruct.put("graphicsType", getParameters().getGraphicsType().name().toLowerCase());
    devStruct.put("password", getParameters().getTicket());
    devStruct.put("ttl", getParameters().getValidTime());
    if (getParameters().getClusterCompatibilityVersion().less(new Version(4, 0))) {
        // Older Vdsm versions crash when this parameter is not present.
        devStruct.put("existingConnAction", connectionAction);
    }
    devStruct.put("disconnectAction", getParameters().getDisconnectAction());
    devStruct.put("params", getUidParams());
    status = getBroker().vmUpdateDevice(getParameters().getVmId().toString(), devStruct);
}
#method_after
private void setTicketUsingUpdateDevice() {
    Map<String, Object> devStruct = new HashMap<>();
    devStruct.put("deviceType", "graphics");
    devStruct.put("graphicsType", getParameters().getGraphicsType().name().toLowerCase());
    devStruct.put("password", getParameters().getTicket());
    devStruct.put("ttl", getParameters().getValidTime());
    if (getParameters().getCompatibilityVersion().less(Version.v4_0)) {
        // Older Vdsm versions crash when this parameter is not present.
        devStruct.put("existingConnAction", connectionAction);
    }
    devStruct.put("disconnectAction", getParameters().getDisconnectAction());
    devStruct.put("params", getUidParams());
    status = getBroker().vmUpdateDevice(getParameters().getVmId().toString(), devStruct);
}
#end_block

#method_before
protected Response add(VnicProfile vnicProfile) {
    validateParameters(vnicProfile);
    AddVnicProfileParameters addVnicProfileParameters = vnicProfile.isSetNetworkFilter() ? new AddVnicProfileParameters(map(vnicProfile)) : new AddVnicProfileParameters(map(vnicProfile), true);
    return performCreate(VdcActionType.AddVnicProfile, addVnicProfileParameters, new QueryIdResolver<Guid>(VdcQueryType.GetVnicProfileById, IdQueryParameters.class));
}
#method_after
protected Response add(VnicProfile vnicProfile) {
    validateParameters(vnicProfile);
    AddVnicProfileParameters addVnicProfileParameters = new AddVnicProfileParameters(map(vnicProfile), !vnicProfile.isSetNetworkFilter());
    return performCreate(VdcActionType.AddVnicProfile, addVnicProfileParameters, new QueryIdResolver<Guid>(VdcQueryType.GetVnicProfileById, IdQueryParameters.class));
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.VnicProfile.class, to = VnicProfile.class)
public static VnicProfile map(org.ovirt.engine.core.common.businessentities.network.VnicProfile entity, VnicProfile template) {
    VnicProfile model = template != null ? template : new VnicProfile();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getNetworkId() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setId(entity.getNetworkId().toString());
    }
    model.setPortMirroring(entity.isPortMirroring());
    if (entity.getCustomProperties() != null && !entity.getCustomProperties().isEmpty()) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperties().addAll(CustomPropertiesParser.parse(DevicePropertiesUtils.getInstance().convertProperties(entity.getCustomProperties()), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getNetworkQosId() != null) {
        model.setQos(new Qos());
        model.getQos().setId(entity.getNetworkQosId().toString());
    }
    final VnicPassThrough vnicPassThrough = new VnicPassThrough();
    vnicPassThrough.setMode(map(entity.isPassthrough()).value());
    model.setPassThrough(vnicPassThrough);
    if (entity.getNetworkFilterId() != null) {
        model.setNetworkFilter(new NetworkFilter());
        model.getNetworkFilter().setId(entity.getNetworkFilterId().toString());
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.VnicProfile.class, to = VnicProfile.class)
public static VnicProfile map(org.ovirt.engine.core.common.businessentities.network.VnicProfile entity, VnicProfile template) {
    VnicProfile model = template != null ? template : new VnicProfile();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getNetworkId() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setId(entity.getNetworkId().toString());
    }
    model.setPortMirroring(entity.isPortMirroring());
    if (entity.getCustomProperties() != null && !entity.getCustomProperties().isEmpty()) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperties().addAll(CustomPropertiesParser.parse(DevicePropertiesUtils.getInstance().convertProperties(entity.getCustomProperties()), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getNetworkQosId() != null) {
        model.setQos(new Qos());
        model.getQos().setId(entity.getNetworkQosId().toString());
    }
    final VnicPassThrough vnicPassThrough = new VnicPassThrough();
    vnicPassThrough.setMode(map(entity.isPassthrough()));
    model.setPassThrough(vnicPassThrough);
    if (entity.getNetworkFilterId() != null) {
        model.setNetworkFilter(new NetworkFilter());
        model.getNetworkFilter().setId(entity.getNetworkFilterId().toString());
    }
    return model;
}
#end_block

#method_before
private static VnicPassThroughMode map(boolean value) {
    return value ? VnicPassThroughMode.ENABLED : VnicPassThroughMode.DISABLED;
}
#method_after
private static boolean map(VnicPassThroughMode vnicPassThroughMode) {
    return VnicPassThroughMode.ENABLED == vnicPassThroughMode;
}
#end_block

#method_before
private Clusters listVirtOnly() {
    if (isFiltered()) {
        return mapVirtOnlyCollection(getBackendCollection(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase()));
    } else {
        return mapVirtOnlyCollection(getBackendCollection(SearchType.Cluster));
    }
}
#method_after
private Clusters listVirtOnly() {
    if (isFiltered()) {
        return mapVirtOnlyCollection(getBackendCollection(VdcQueryType.GetAllClusters, new VdcQueryParametersBase()));
    } else {
        return mapVirtOnlyCollection(getBackendCollection(SearchType.Cluster));
    }
}
#end_block

#method_before
private Clusters listAll() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Cluster));
    }
}
#method_after
private Clusters listAll() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllClusters, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Cluster));
    }
}
#end_block

#method_before
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, getMandatoryParameters());
    validateEnums(Cluster.class, cluster);
    StoragePool dataCenter = getDataCenter(cluster);
    return performCreate(VdcActionType.AddVdsGroup, createAddCommandParams(cluster, dataCenter), new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(org.ovirt.engine.api.model.Cluster cluster) {
    validateParameters(cluster, getMandatoryParameters());
    StoragePool dataCenter = getDataCenter(cluster);
    return performCreate(VdcActionType.AddCluster, createAddCommandParams(cluster, dataCenter), new QueryIdResolver<Guid>(VdcQueryType.GetClusterById, IdQueryParameters.class));
}
#end_block

#method_before
protected StoragePool getDataCenter(Cluster cluster) {
    return getStoragePool(cluster.getDataCenter(), this);
}
#method_after
protected StoragePool getDataCenter(org.ovirt.engine.api.model.Cluster cluster) {
    return getStoragePool(cluster.getDataCenter(), this);
}
#end_block

#method_before
private ManagementNetworkOnClusterOperationParameters createAddCommandParams(Cluster cluster, StoragePool dataCenter) {
    VDSGroup clusterEntity = map(cluster, map(dataCenter));
    if (!(cluster.isSetErrorHandling() && cluster.getErrorHandling().isSetOnError())) {
        clusterEntity.setMigrateOnError(null);
    }
    final Guid managementNetworkId = managementNetworkFinder.getManagementNetworkId(cluster, dataCenter.getId());
    return new ManagementNetworkOnClusterOperationParameters(clusterEntity, managementNetworkId);
}
#method_after
private ManagementNetworkOnClusterOperationParameters createAddCommandParams(org.ovirt.engine.api.model.Cluster cluster, StoragePool dataCenter) {
    Cluster clusterEntity = map(cluster, map(dataCenter));
    if (!(cluster.isSetErrorHandling() && cluster.getErrorHandling().isSetOnError())) {
        clusterEntity.setMigrateOnError(null);
    }
    final Guid managementNetworkId = managementNetworkFinder.getManagementNetworkId(cluster, dataCenter.getId());
    return new ManagementNetworkOnClusterOperationParameters(clusterEntity, managementNetworkId);
}
#end_block

#method_before
protected Clusters mapCollection(List<VDSGroup> entities) {
    Clusters collection = new Clusters();
    for (org.ovirt.engine.core.common.businessentities.VDSGroup entity : entities) {
        collection.getClusters().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#method_after
protected Clusters mapCollection(List<Cluster> entities) {
    Clusters collection = new Clusters();
    for (Cluster entity : entities) {
        collection.getClusters().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#end_block

#method_before
private Clusters mapVirtOnlyCollection(List<VDSGroup> entities) {
    Clusters collection = new Clusters();
    for (org.ovirt.engine.core.common.businessentities.VDSGroup entity : entities) {
        collection.getClusters().add(addLinks(map(entity), VIRT_ONLY_MODE_COLLECTIONS_TO_HIDE));
    }
    return collection;
}
#method_after
private Clusters mapVirtOnlyCollection(List<Cluster> entities) {
    Clusters collection = new Clusters();
    for (Cluster entity : entities) {
        collection.getClusters().add(addLinks(map(entity), VIRT_ONLY_MODE_COLLECTIONS_TO_HIDE));
    }
    return collection;
}
#end_block

#method_before
protected VDSGroup map(StoragePool pool) {
    return getMapper(StoragePool.class, VDSGroup.class).map(pool, null);
}
#method_after
protected Cluster map(StoragePool pool) {
    return getMapper(StoragePool.class, Cluster.class).map(pool, null);
}
#end_block

#method_before
@Override
protected Cluster doPopulate(Cluster cluster, VDSGroup entity) {
    final Guid clusterId = entity.getId();
    final org.ovirt.engine.core.common.businessentities.network.Network network = getOptionalEntity(org.ovirt.engine.core.common.businessentities.network.Network.class, VdcQueryType.GetManagementNetwork, new IdQueryParameters(clusterId), clusterId.toString(), false);
    if (network != null) {
        final Network managementNetwork = new Network();
        managementNetwork.setCluster(cluster);
        managementNetwork.setId(network.getId().toString());
        cluster.setManagementNetwork(managementNetwork);
    }
    return cluster;
}
#method_after
@Override
protected org.ovirt.engine.api.model.Cluster doPopulate(org.ovirt.engine.api.model.Cluster cluster, Cluster entity) {
    final Guid clusterId = entity.getId();
    final org.ovirt.engine.core.common.businessentities.network.Network network = getOptionalEntity(org.ovirt.engine.core.common.businessentities.network.Network.class, VdcQueryType.GetManagementNetwork, new IdQueryParameters(clusterId), clusterId.toString(), false);
    if (network != null) {
        final Network managementNetwork = new Network();
        managementNetwork.setCluster(cluster);
        managementNetwork.setId(network.getId().toString());
        cluster.setManagementNetwork(managementNetwork);
    }
    return cluster;
}
#end_block

#method_before
// @Mapping(from = NetworkFilter.class, to =
// org.ovirt.engine.core.common.businessentities.network.NetworkFilter.class)
// public static org.ovirt.engine.core.common.businessentities.network.NetworkFilter map(NetworkFilter model,
// org.ovirt.engine.core.common.businessentities.network.NetworkFilter template) {
// org.ovirt.engine.core.common.businessentities.network.NetworkFilter networkFilter =
// (template != null) ? template : new org.ovirt.engine.core.common.businessentities.network.NetworkFilter();
// networkFilter.setVersion(convertVersion(model.getVersion()));
// networkFilter.setName(model.getName());
// networkFilter.setId(new Guid(model.getId()));
// return networkFilter;
// }
private static Version convertVersion(org.ovirt.engine.core.compat.Version from) {
    Version output = VersionMapper.map(from, null);
    return output;
}
#method_after
private static Version convertVersion(org.ovirt.engine.core.compat.Version from) {
    Version output = VersionMapper.map(from, null);
    return output;
}
#end_block

#method_before
@Override
public Cluster get() {
    return performGet(VdcQueryType.GetVdsGroupById, new IdQueryParameters(guid));
}
#method_after
@Override
public org.ovirt.engine.api.model.Cluster get() {
    return performGet(VdcQueryType.GetClusterById, new IdQueryParameters(guid));
}
#end_block

#method_before
@Override
public Cluster update(Cluster incoming) {
    validateEnums(Cluster.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetVdsGroupById, IdQueryParameters.class), VdcActionType.UpdateVdsGroup, new UpdateParametersProvider());
}
#method_after
@Override
public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) {
    return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class), VdcActionType.UpdateCluster, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public AssignedPermissionsResource getPermissionsResource() {
    return inject(new BackendAssignedPermissionsResource(guid, VdcQueryType.GetPermissionsForObject, new GetPermissionsForObjectParameters(guid), Cluster.class, VdcObjectType.VdsGroups));
}
#method_after
@Override
public AssignedPermissionsResource getPermissionsResource() {
    return inject(new BackendAssignedPermissionsResource(guid, VdcQueryType.GetPermissionsForObject, new GetPermissionsForObjectParameters(guid), org.ovirt.engine.api.model.Cluster.class, VdcObjectType.Cluster));
}
#end_block

#method_before
@Override
public NetworkFiltersResource getNetworkFiltersResource() {
    return inject(new BackendNetworkFiltersResource(guid));
}
#method_after
public NetworkFiltersResource getNetworkFiltersResource() {
    return inject(new BackendNetworkFiltersResource(guid));
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Cluster incoming, VDSGroup entity) {
    final VDSGroup cluster = map(incoming, entity);
    final ManagementNetworkOnClusterOperationParameters managementNetworkOnClusterOperationParameters;
    final Guid dcId = getDataCenterId(cluster);
    if (dcId == null) {
        managementNetworkOnClusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster);
    } else {
        final Guid managementNetworkId = managementNetworkFinder.getManagementNetworkId(incoming, dcId);
        managementNetworkOnClusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetworkId);
    }
    return managementNetworkOnClusterOperationParameters;
}
#method_after
@Override
public VdcActionParametersBase getParameters(org.ovirt.engine.api.model.Cluster incoming, Cluster entity) {
    final Cluster cluster = map(incoming, entity);
    final ManagementNetworkOnClusterOperationParameters managementNetworkOnClusterOperationParameters;
    final Guid dcId = getDataCenterId(cluster);
    if (dcId == null) {
        managementNetworkOnClusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster);
    } else {
        final Guid managementNetworkId = managementNetworkFinder.getManagementNetworkId(incoming, dcId);
        managementNetworkOnClusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetworkId);
    }
    return managementNetworkOnClusterOperationParameters;
}
#end_block

#method_before
@Override
protected Cluster doPopulate(Cluster cluster, VDSGroup entity) {
    return parent.doPopulate(cluster, entity);
}
#method_after
@Override
protected org.ovirt.engine.api.model.Cluster doPopulate(org.ovirt.engine.api.model.Cluster cluster, Cluster entity) {
    return parent.doPopulate(cluster, entity);
}
#end_block

#method_before
protected Guid getDataCenterId(VDSGroup cluster) {
    return cluster.getStoragePoolId();
}
#method_after
protected Guid getDataCenterId(Cluster cluster) {
    return cluster.getStoragePoolId();
}
#end_block

#method_before
@Override
public Response resetEmulatedMachine(Action action) {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(guid));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        ManagementNetworkOnClusterOperationParameters param = new ManagementNetworkOnClusterOperationParameters((VDSGroup) result.getReturnValue());
        param.setForceResetEmulatedMachine(true);
        return doAction(VdcActionType.UpdateVdsGroup, param, action);
    } else {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    }
}
#method_after
@Override
public Response resetEmulatedMachine(Action action) {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(guid));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        ManagementNetworkOnClusterOperationParameters param = new ManagementNetworkOnClusterOperationParameters(result.getReturnValue());
        param.setForceResetEmulatedMachine(true);
        return doAction(VdcActionType.UpdateCluster, param, action);
    } else {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    }
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVdsGroup, new VdsGroupParametersBase(asGuid(id)));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveCluster, new ClusterParametersBase(asGuid(id)));
}
#end_block

#method_before
@Override
public NetworkFilter get() {
    return performGet(VdcQueryType.GetNetworkFilterById, new IdQueryParameters(asGuid(id)));
}
#method_after
@Override
public NetworkFilter get() {
    return performGet(VdcQueryType.GetNetworkFilterById, new IdQueryParameters(guid));
}
#end_block

#method_before
@Override
public NetworkFilters list() {
    Version version = clusterVersion();
    return mapCollection(getBackendCollection(VdcQueryType.GetSupportedNetworkFiltersByVersion, new VersionQueryParameters(version)));
}
#method_after
@Override
public NetworkFilters list() {
    Version version = clusterVersion();
    return mapCollection(getBackendCollection(VdcQueryType.GetAllSupportedNetworkFiltersByVersion, new VersionQueryParameters(version)));
}
#end_block

#method_before
private Version clusterVersion() {
    VDSGroup cluster = loadCluster();
    final Version version = cluster == null ? new Version() : cluster.getCompatibilityVersion();
    return version;
}
#method_after
private Version clusterVersion() {
    Cluster cluster = loadCluster();
    final Version version = cluster == null ? new Version() : cluster.getCompatibilityVersion();
    return version;
}
#end_block

#method_before
private VDSGroup loadCluster() {
    VDSGroup cluster = null;
    try {
        VdcQueryReturnValue returnValue = runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(guid));
        if (!returnValue.getSucceeded()) {
            backendFailure(returnValue.getExceptionString());
        }
        cluster = returnValue.getReturnValue();
    } catch (Exception e) {
        handleError(e, false);
    }
    return cluster;
}
#method_after
private Cluster loadCluster() {
    try {
        VdcQueryReturnValue returnValue = runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(clusterId));
        if (!returnValue.getSucceeded()) {
            backendFailure(returnValue.getExceptionString());
        }
        Cluster cluster = returnValue.getReturnValue();
        return cluster;
    } catch (Exception e) {
        handleError(e, false);
        return null;
    }
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit(), new VdsDeployKernelUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                case oVirtNode:
                    deploy.addUnit(new VdsDeployIptablesUnit());
                    break;
                case oVirtVintageNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            deploy.addUnit(new VdsDeployVmconsoleUnit());
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                try (ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager, getVdsStaticDao(), auditLogDirector)) {
                    if (detector.shouldCheckProtocolTofallback()) {
                        // we need to check whether we are connecting to vdsm which supports xmlrpc only
                        if (!detector.attemptConnection()) {
                            detector.stopConnection();
                            if (detector.attemptFallbackProtocol()) {
                                detector.setFallbackProtocol();
                            } else {
                                throw new VdsInstallException(VDSStatus.InstallFailed, "Host is not reachable");
                            }
                        }
                    }
                }
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit(), new VdsDeployKernelUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                case oVirtNode:
                    deploy.addUnit(new VdsDeployIptablesUnit());
                    break;
                case oVirtVintageNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            deploy.addUnit(new VdsDeployVmconsoleUnit());
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                markCurrentCmdlineAsStored();
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                markCurrentCmdlineAsStored();
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                markCurrentCmdlineAsStored();
                try (ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager, getVdsStaticDao(), auditLogDirector)) {
                    if (detector.shouldCheckProtocolTofallback()) {
                        // we need to check whether we are connecting to vdsm which supports xmlrpc only
                        if (!detector.attemptConnection()) {
                            detector.stopConnection();
                            if (detector.attemptFallbackProtocol()) {
                                detector.setFallbackProtocol();
                            } else {
                                throw new VdsInstallException(VDSStatus.InstallFailed, "Host is not reachable");
                            }
                        }
                    }
                }
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
private void updateDeviceAddresses() {
    if (isEmulatedMachineChanged()) {
        log.info("Emulated machine changed for VM: {}. Clearing device addresses.", getVm().getName());
        getVmDeviceDao().clearAllDeviceAddressesByVmId(getVmId());
        VmDevicesMonitoring.Change change = VmDevicesMonitoring.getInstance().createChange(System.nanoTime());
        change.updateVm(getVmId(), VmDevicesMonitoring.EMPTY_HASH);
        change.flush();
    }
}
#method_after
private void updateDeviceAddresses() {
    if (isEmulatedMachineChanged()) {
        log.info("Emulated machine changed for VM: {} ({}). Clearing device addresses.", getVm().getName(), getVm().getId());
        getVmDeviceDao().clearAllDeviceAddressesByVmId(getVmId());
        VmDevicesMonitoring.Change change = vmDevicesMonitoring.createChange(System.nanoTime());
        change.updateVm(getVmId(), VmDevicesMonitoring.EMPTY_HASH);
        change.flush();
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
private boolean isEmulatedMachineChanged() {
    return !StringUtils.equals(getParameters().getVm().getCustomEmulatedMachine(), getVm().getCustomEmulatedMachine());
}
#method_after
private boolean isEmulatedMachineChanged() {
    return !Objects.equals(getParameters().getVm().getCustomEmulatedMachine(), getVm().getCustomEmulatedMachine());
}
#end_block

#method_before
@Before
public void setUp() {
    injectorRule.bind(ManagementNetworkUtil.class, managementNetworkUtil);
    nic.setNetworkName(NETWORK_NAME);
    VDS vds = new VDS();
    vds.getInterfaces().add(nic);
    underTest = new NetworkConfigurator(vds, COMMAND_CONTEXT);
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(ManagementNetworkUtil.class, managementNetworkUtil);
    nic.setNetworkName(NETWORK_NAME1);
    VDS vds = new VDS();
    vds.getInterfaces().add(nic);
    underTest = new NetworkConfigurator(vds, COMMAND_CONTEXT);
}
#end_block

#method_before
@Test
public void getIpv4AddressOfNetwork() {
    nic.setIpv4Address(IPV4_ADDRESS);
    assertThat(underTest.getIpv4AddressOfNetwork(NETWORK_NAME), is(IPV4_ADDRESS));
}
#method_after
@Test
public void getIpv4AddressOfNetwork() {
    nic.setIpv4Address(IPV4_ADDRESS);
    assertThat(underTest.getIpv4AddressOfNetwork(NETWORK_NAME1), is(IPV4_ADDRESS));
}
#end_block

#method_before
@Test
public void getIpv6AddressOfNetwork() {
    nic.setIpv6Address(IPV6_ADDRESS);
    assertThat(underTest.getIpv6AddressOfNetwork(NETWORK_NAME), is(IPV6_ADDRESS));
}
#method_after
@Test
public void getIpv6AddressOfNetwork() {
    nic.setIpv6Address(IPV6_ADDRESS);
    assertThat(underTest.getIpv6AddressOfNetwork(NETWORK_NAME1), is(IPV6_ADDRESS));
}
#end_block

#method_before
@Test
public void getIpv4AddressOfNetworkReturnsNullWhenThereIsNoIpSet() {
    assertThat(underTest.getIpv4AddressOfNetwork(NETWORK_NAME), nullValue(null));
}
#method_after
@Test
public void getIpv4AddressOfNetworkReturnsNullWhenThereIsNoIpSet() {
    assertThat(underTest.getIpv4AddressOfNetwork(NETWORK_NAME1), nullValue());
}
#end_block

#method_before
@Test
public void getIpv6AddressOfNetworkReturnsNullWhenThereIsNoIpSet() {
    assertThat(underTest.getIpv6AddressOfNetwork(NETWORK_NAME), nullValue(null));
}
#method_after
@Test
public void getIpv6AddressOfNetworkReturnsNullWhenThereIsNoIpSet() {
    assertThat(underTest.getIpv6AddressOfNetwork(NETWORK_NAME1), nullValue());
}
#end_block

#method_before
@Test
public void getIpv4AddressOfNetworkReturnsNullWhenThereIsNoNetworkOfGivenName() {
    nic.setIpv4Address(IPV4_ADDRESS);
    assertThat(underTest.getIpv4AddressOfNetwork("not" + NETWORK_NAME), nullValue(null));
}
#method_after
@Test
public void getIpv4AddressOfNetworkReturnsNullWhenThereIsNoNetworkOfGivenName() {
    nic.setIpv4Address(IPV4_ADDRESS);
    assertThat(underTest.getIpv4AddressOfNetwork(NETWORK_NAME2), nullValue());
}
#end_block

#method_before
@Test
public void getIpv6AddressOfNetworkReturnsNullWhenThereIsNoNetworkOfGivenName() {
    nic.setIpv6Address(IPV6_ADDRESS);
    assertThat(underTest.getIpv6AddressOfNetwork("not" + NETWORK_NAME), nullValue(null));
}
#method_after
@Test
public void getIpv6AddressOfNetworkReturnsNullWhenThereIsNoNetworkOfGivenName() {
    nic.setIpv6Address(IPV6_ADDRESS);
    assertThat(underTest.getIpv6AddressOfNetwork(NETWORK_NAME2), nullValue());
}
#end_block

#method_before
private void updateVms(List<VM> vms) {
    clearVms();
    List<EntityModel<VM>> externalVms = new ArrayList<>();
    for (VM vm : vms) {
        externalVms.add(new EntityModel<>(vm));
    }
    externalVmModels.setItems(externalVms);
    stopProgress();
}
#method_after
private void updateVms(List<VM> vms) {
    clearVms();
    List<EntityModel<VM>> externalVms = new ArrayList<>();
    // VMs sorting
    Collections.sort(vms, new LexoNumericNameableComparator<>());
    for (VM vm : vms) {
        externalVms.add(new EntityModel<>(vm));
    }
    externalVmModels.setItems(externalVms);
    stopProgress();
}
#end_block

#method_before
private boolean validateClusterExistsForArchitecture(ArchitectureType architecture, StoragePool dataCenter) {
    if (!clusterArchitecturesInDataCenters.get(dataCenter.getId()).contains(architecture)) {
        showErrorPopup(constants.noClusterSupportingArchitectureInDC());
        return false;
    }
    return true;
}
#method_after
private boolean validateClusterExistsForArchitecture(ArchitectureType architecture, StoragePool dataCenter) {
    if (// we want validation to fail if map initialization failed
    clusterArchitecturesInDataCenters == null || clusterArchitecturesInDataCenters.get(dataCenter.getId()) == null || !clusterArchitecturesInDataCenters.get(dataCenter.getId()).contains(architecture)) {
        showErrorPopup(constants.noClusterSupportingArchitectureInDC());
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean validateSameArchitecture(List<VM> vmsToImport) {
    for (VM vm : vmsToImport) {
        if (!Objects.equals(vmsToImport.get(0).getClusterArch(), vm.getClusterArch())) {
            showErrorPopup(constants.sameArchitectureRequired());
            return false;
        }
    }
    return true;
}
#method_after
private boolean validateSameArchitecture(List<VM> vmsToImport) {
    final ArchitectureType architectureOfFirst = vmsToImport.get(0).getClusterArch();
    for (VM vm : vmsToImport) {
        if (!Objects.equals(architectureOfFirst, vm.getClusterArch())) {
            showErrorPopup(constants.sameArchitectureRequired());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
protected boolean validateMemoryAlignment(VmStatic vmStaticData) {
    if (getCluster().getArchitecture().getFamily() == ArchitectureType.ppc && vmStaticData.getMemSizeMb() % 256 != 0) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.MEMORY_SIZE_NOT_MULTIPLE_OF_256_ON_PPC);
    }
    return true;
}
#method_after
protected boolean validateMemoryAlignment(VmStatic vmStaticData) {
    if (getCluster().getArchitecture().getFamily() == ArchitectureType.ppc && vmStaticData.getMemSizeMb() % 256 != 0) {
        return failValidation(EngineMessage.MEMORY_SIZE_NOT_MULTIPLE_OF_256_ON_PPC, String.format("$%s %s", "clusterArch", getCluster().getArchitecture()));
    }
    return true;
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceRandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getOverrideMigrationPolicy().setIsChangeable(false);
        getMigrationPolicies().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceRandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        }
    }
}
#end_block

#method_before
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
    }
}
#method_after
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
    }
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private boolean equals(Class<?> class1, Class<?> class2) {
    if (class1 == null) {
        return class2 == null;
    }
    if (class2 == null) {
        return class1 == null;
    }
    return class1.equals(class2);
}
#method_after
private boolean equals(Class<?> class1, Class<?> class2) {
    return Objects.equals(class1, class2);
}
#end_block

#method_before
@Override
public int hashCode() {
    if (service == null && parentService == null) {
        return 0;
    }
    if (service == null) {
        return parentService.hashCode();
    }
    if (parentService == null) {
        return service.hashCode();
    }
    // large primes!
    return 997 * ((int) service.hashCode()) ^ 991 * ((int) parentService.hashCode());
}
#method_after
@Override
public int hashCode() {
    if (service == null && parentService == null) {
        return 0;
    }
    if (service == null) {
        return parentService.hashCode();
    }
    if (parentService == null) {
        return service.hashCode();
    }
    // large primes!
    return 997 * (service.hashCode()) ^ 991 * (parentService.hashCode());
}
#end_block

#method_before
private static String getRelativePath(Class<?> service, Class<?> parentService) {
    PathKey key = new PathKey(service, parentService);
    if (pathCache.containsKey(key)) {
        return pathCache.get(key);
    } else {
        for (Method method : parentService.getMethods()) {
            if (method.getName().startsWith("get") && method.getReturnType() == service) {
                Path pathAnnotation = method.getAnnotation(Path.class);
                if (pathAnnotation != null) {
                    pathCache.put(key, pathAnnotation.value());
                    return pathAnnotation.value();
                }
            }
        }
    }
    log.error("Can't find relative path for class \"" + service.getName() + "\", will return null");
    return null;
}
#method_after
private static String getRelativePath(Class<?> service, Class<?> parentService) {
    PathKey key = new PathKey(service, parentService);
    String path = pathCache.get(key);
    if (path != null) {
        return path;
    } else {
        for (Method method : parentService.getMethods()) {
            if (method.getName().startsWith("get") && method.getReturnType() == service) {
                Path pathAnnotation = method.getAnnotation(Path.class);
                if (pathAnnotation != null) {
                    pathCache.put(key, pathAnnotation.value());
                    return pathAnnotation.value();
                }
            }
        }
    }
    log.error("Can't find relative path for class \"" + service.getName() + "\", will return null");
    return null;
}
#end_block

#method_before
private static <R extends BaseResource> BaseResource getParent(R model, Class<?> parentType) {
    for (Method method : getRelevantMethods(model.getClass())) {
        try {
            Object potentialParent = method.invoke(model);
            if (potentialParent != null && parentType.isAssignableFrom(potentialParent.getClass())) {
                return (BaseResource) potentialParent;
            }
        } catch (Exception e) {
            continue;
        }
    }
    return null;
}
#method_after
private static <R extends BaseResource> BaseResource getParent(R model, Class<?> parentType) {
    for (Method method : getRelevantMethods(model.getClass())) {
        try {
            Object potentialParent = method.invoke(model);
            if (potentialParent != null && parentType.isAssignableFrom(potentialParent.getClass())) {
                return (BaseResource) potentialParent;
            }
        } catch (Exception e) {
            log.error("Error invoking method when adding links to an API entity", e);
            continue;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, hostName, consoleAddress, name, otpValidity, pmEnabled, pmKdumpDetection, port, protocol, sshPort, sshUsername, serverSslEnabled, uniqueId, clusterId, vdsStrength, vdsType, disablePowerManagementPolicy, hostProviderId, hostProviderId, currentKernelCmdline, kernelCmdlineParsable, lastStoredKernelCmdline, kernelCmdlineIommu, kernelCmdlineKvmNested, kernelCmdlinePciRealloc, kernelCmdlineUnsafeInterrupts);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, hostName, consoleAddress, name, otpValidity, pmEnabled, pmKdumpDetection, port, protocol, sshPort, sshUsername, serverSslEnabled, uniqueId, clusterId, vdsStrength, vdsType, disablePowerManagementPolicy, hostProviderId, openstackNetworkProviderId, currentKernelCmdline, kernelCmdlineParsable, lastStoredKernelCmdline, kernelCmdlineIommu, kernelCmdlineKvmNested, kernelCmdlinePciRealloc, kernelCmdlineUnsafeInterrupts);
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#end_block

#method_before
private void initMigrationPolicies() {
    AsyncQuery aQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationPolicies = (List<MigrationPolicy>) returnValue;
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<MigrationPolicy>();
            }
            Collections.sort((List<MigrationPolicy>) returnValue, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
    initCpuMap();
}
#method_after
private void initMigrationPolicies() {
    AsyncQuery aQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationPolicies = (List<MigrationPolicy>) returnValue;
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<MigrationPolicy>();
            }
            Collections.sort((List<MigrationPolicy>) returnValue, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void approve() {
    // TODO jakub: check where are data filled in
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnApprove", hostListModel);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnApprove", hostListModel);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    param.setFenceAgents(host.getFenceAgents());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#end_block

#method_before
private void configureLocalStorage() {
    VDS host = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ConfigureLocalStorageModel model = new ConfigureLocalStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().configureLocalStorageTitle());
    model.setHelpTag(HelpTag.configure_local_storage);
    // $NON-NLS-1$
    model.setHashName("configure_local_storage");
    if (host.isOvirtNode()) {
        configureLocalStorage2(model);
    } else {
        configureLocalStorage3(model);
    }
}
#method_after
private void configureLocalStorage() {
    VDS host = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ConfigureLocalStorageModel model = new ConfigureLocalStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().configureLocalStorageTitle());
    model.setHelpTag(HelpTag.configure_local_storage);
    // $NON-NLS-1$
    model.setHashName("configure_local_storage");
    if (host.isOvirtVintageNode()) {
        configureLocalStorage2(model);
    } else {
        configureLocalStorage3(model);
    }
}
#end_block

#method_before
private void updateAvailableOvirtNodeUpgrades() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    if (!host.isOvirtNode()) {
        return;
    }
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
        }
    }), host.getId());
}
#method_after
private void updateAvailableOvirtNodeUpgrades() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    if (!host.isOvirtVintageNode()) {
        return;
    }
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
        }
    }), host.getId());
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).isOvirtNode()));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    boolean installAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        installAvailability = host.getStatus() == VDSStatus.InstallFailed || host.getStatus() == VDSStatus.Maintenance;
    }
    getInstallCommand().setIsExecutionAllowed(installAvailability);
    boolean upgradeAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        upgradeAvailability = canUpgradeHost(host);
    }
    getUpgradeCommand().setIsExecutionAllowed(upgradeAvailability);
    getEnrollCertificateCommand().setIsExecutionAllowed(installAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
    boolean numaVisible = false;
    if (getSelectedItem() != null) {
        numaVisible = getSelectedItem().isNumaSupport();
    }
    getNumaSupportCommand().setIsVisible(numaVisible);
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).isOvirtVintageNode()));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    boolean installAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        installAvailability = host.getStatus() == VDSStatus.InstallFailed || host.getStatus() == VDSStatus.Maintenance;
    }
    getInstallCommand().setIsExecutionAllowed(installAvailability);
    boolean upgradeAvailability = false;
    if (singleHostSelected(items)) {
        VDS host = items.get(0);
        upgradeAvailability = canUpgradeHost(host);
    }
    getUpgradeCommand().setIsExecutionAllowed(upgradeAvailability);
    getEnrollCertificateCommand().setIsExecutionAllowed(installAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
    boolean numaVisible = false;
    if (getSelectedItem() != null) {
        numaVisible = getSelectedItem().isNumaSupport();
    }
    getNumaSupportCommand().setIsVisible(numaVisible);
}
#end_block

#method_before
private static VmPool cloneVmPool(VmPool instance) {
    VmPool obj = new VmPool();
    obj.setVmPoolId(instance.getVmPoolId());
    obj.setName(instance.getName());
    obj.setVmPoolType(instance.getVmPoolType());
    obj.setClusterId(instance.getClusterId());
    obj.setVmPoolType(instance.getVmPoolType());
    obj.setParameters(instance.getParameters());
    obj.setDefaultEndTime(instance.getDefaultEndTime());
    obj.setDefaultStartTime(instance.getDefaultStartTime());
    obj.setDefaultTimeInDays(instance.getDefaultTimeInDays());
    obj.setClusterName(instance.getClusterName());
    obj.setAssignedVmsCount(instance.getAssignedVmsCount());
    obj.setVmPoolDescription(instance.getVmPoolDescription());
    obj.setComment(instance.getComment());
    obj.setRunningVmsCount(instance.getRunningVmsCount());
    obj.setPrestartedVms(instance.getPrestartedVms());
    obj.setBeingDestroyed(instance.isBeingDestroyed());
    return obj;
}
#method_after
private static VmPool cloneVmPool(VmPool instance) {
    VmPool obj = new VmPool();
    obj.setVmPoolId(instance.getVmPoolId());
    obj.setName(instance.getName());
    obj.setVmPoolType(instance.getVmPoolType());
    obj.setStateful(instance.isStateful());
    obj.setClusterId(instance.getClusterId());
    obj.setParameters(instance.getParameters());
    obj.setDefaultEndTime(instance.getDefaultEndTime());
    obj.setDefaultStartTime(instance.getDefaultStartTime());
    obj.setDefaultTimeInDays(instance.getDefaultTimeInDays());
    obj.setClusterName(instance.getClusterName());
    obj.setAssignedVmsCount(instance.getAssignedVmsCount());
    obj.setVmPoolDescription(instance.getVmPoolDescription());
    obj.setComment(instance.getComment());
    obj.setRunningVmsCount(instance.getRunningVmsCount());
    obj.setPrestartedVms(instance.getPrestartedVms());
    obj.setBeingDestroyed(instance.isBeingDestroyed());
    return obj;
}
#end_block

#method_before
public static String getDefaultProfile(SsoExtensionsManager extensionsManager) {
    Optional<ExtensionProxy> defaultExtension = extensionsManager.getExtensionsByService(Authn.class.getName()).stream().filter(ExtensionProxy::isDefault).findFirst();
    return defaultExtension.isPresent() ? getProfileName(defaultExtension.get()) : null;
}
#method_after
public static String getDefaultProfile(SsoExtensionsManager extensionsManager) {
    Optional<ExtensionProxy> defaultExtension = extensionsManager.getExtensionsByService(Authn.class.getName()).stream().filter(a -> Boolean.valueOf(a.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.DEFAULT_PROFILE))).findFirst();
    return defaultExtension.isPresent() ? getProfileName(defaultExtension.get()) : null;
}
#end_block

#method_before
@Mapping(from = HasMigrationOptions.class, to = MigrationOptions.class)
public static MigrationOptions map(HasMigrationOptions entity, MigrationOptions template) {
    if (template == null) {
        template = new MigrationOptions();
    }
    template.setAutoConverge(mapToInheritableBoolean(entity.getAutoConverge()));
    template.setCompressed(mapToInheritableBoolean(entity.getMigrateCompressed()));
    if (entity.getMigrationPolicyId() != null) {
        MigrationPolicy policy = new MigrationPolicy();
        policy.setId(entity.getMigrationPolicyId().toString());
        template.setPolicy(policy);
    }
    return template;
}
#method_after
@Mapping(from = HasMigrationOptions.class, to = MigrationOptions.class)
public static MigrationOptions map(HasMigrationOptions entity, MigrationOptions template) {
    if (template == null) {
        template = new MigrationOptions();
    }
    template.setAutoConverge(mapToInheritableBoolean(entity.getAutoConverge()));
    template.setCompressed(mapToInheritableBoolean(entity.getMigrateCompressed()));
    if (entity.getMigrationPolicyId() != null) {
        MigrationPolicy policy = template.getPolicy();
        if (policy == null) {
            policy = new MigrationPolicy();
            template.setPolicy(policy);
        }
        policy.setId(entity.getMigrationPolicyId().toString());
    }
    return template;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    GraphicsInfo spice = vm.getGraphicsInfos().get(GraphicsType.SPICE);
    GraphicsInfo vnc = vm.getGraphicsInfos().get(GraphicsType.VNC);
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("guest_agent_status", vm.getGuestAgentStatus().getValue()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason()).addValue("exit_reason", vm.getExitReason().getValue()).addValue("guest_cpu_count", vm.getGuestCpuCount()).addValue("emulated_machine", vm.getEmulatedMachine()).addValue("spice_port", spice != null ? spice.getPort() : null).addValue("spice_tls_port", spice != null ? spice.getTlsPort() : null).addValue("spice_ip", spice != null ? spice.getIp() : null).addValue("vnc_port", vnc != null ? vnc.getPort() : null).addValue("vnc_ip", vnc != null ? vnc.getIp() : null).addValue("guest_mem_buffered", vm.getGuestMemoryBuffered()).addValue("guest_mem_cached", vm.getGuestMemoryCached()).addValue("guest_mem_free", vm.getGuestMemoryFree()).addValue("guest_timezone_name", vm.getGuestOsTimezoneName()).addValue("guest_timezone_offset", vm.getGuestOsTimezoneOffset()).addValue("guestos_arch", vm.getGuestOsArch().getValue()).addValue("guestos_codename", vm.getGuestOsCodename()).addValue("guestos_distribution", vm.getGuestOsDistribution()).addValue("guestos_kernel_version", vm.getGuestOsKernelVersion()).addValue("guestos_type", vm.getGuestOsType().name()).addValue("guestos_version", vm.getGuestOsVersion()).addValue("guest_container_list", toGuestContainerListString(vm));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    GraphicsInfo spice = vm.getGraphicsInfos().get(GraphicsType.SPICE);
    GraphicsInfo vnc = vm.getGraphicsInfos().get(GraphicsType.VNC);
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("guest_agent_status", vm.getGuestAgentStatus().getValue()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason()).addValue("exit_reason", vm.getExitReason().getValue()).addValue("guest_cpu_count", vm.getGuestCpuCount()).addValue("emulated_machine", vm.getEmulatedMachine()).addValue("spice_port", spice != null ? spice.getPort() : null).addValue("spice_tls_port", spice != null ? spice.getTlsPort() : null).addValue("spice_ip", spice != null ? spice.getIp() : null).addValue("vnc_port", vnc != null ? vnc.getPort() : null).addValue("vnc_ip", vnc != null ? vnc.getIp() : null).addValue("guest_mem_buffered", vm.getGuestMemoryBuffered()).addValue("guest_mem_cached", vm.getGuestMemoryCached()).addValue("guest_mem_free", vm.getGuestMemoryFree()).addValue("guest_timezone_name", vm.getGuestOsTimezoneName()).addValue("guest_timezone_offset", vm.getGuestOsTimezoneOffset()).addValue("guestos_arch", vm.getGuestOsArch().getValue()).addValue("guestos_codename", vm.getGuestOsCodename()).addValue("guestos_distribution", vm.getGuestOsDistribution()).addValue("guestos_kernel_version", vm.getGuestOsKernelVersion()).addValue("guestos_type", vm.getGuestOsType().name()).addValue("guestos_version", vm.getGuestOsVersion()).addValue("guest_containers", toGuestContainersString(vm));
}
#end_block

#method_before
@Override
public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDynamic entity = new VmDynamic();
    entity.setAppList(rs.getString("app_list"));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setPauseStatus(pauseStatus);
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setGuestAgentStatus(GuestAgentStatus.forValue(rs.getInt("guest_agent_status")));
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setStopReason(rs.getString("reason"));
    VmExitReason exitReason = VmExitReason.forValue(rs.getInt("exit_reason"));
    entity.setExitReason(exitReason);
    entity.setGuestCpuCount(rs.getInt("guest_cpu_count"));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    setGraphicsToEntity(rs, entity);
    entity.setGuestMemoryBuffered(getLong(rs, "guest_mem_buffered"));
    entity.setGuestMemoryCached(getLong(rs, "guest_mem_cached"));
    entity.setGuestMemoryFree(getLong(rs, "guest_mem_free"));
    entity.setGuestOsTimezoneOffset(rs.getInt("guest_timezone_offset"));
    entity.setGuestOsTimezoneName(rs.getString("guest_timezone_name"));
    entity.setGuestOsArch(rs.getInt("guestos_arch"));
    entity.setGuestOsCodename(rs.getString("guestos_codename"));
    entity.setGuestOsDistribution(rs.getString("guestos_distribution"));
    entity.setGuestOsKernelVersion(rs.getString("guestos_kernel_version"));
    entity.setGuestOsType(rs.getString("guestos_type"));
    entity.setGuestOsVersion(rs.getString("guestos_version"));
    entity.setGuestContainerList(VmDynamicDaoImpl.fromContainerListString(rs.getString("guest_container_list")));
    return entity;
}
#method_after
@Override
public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDynamic entity = new VmDynamic();
    entity.setAppList(rs.getString("app_list"));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setPauseStatus(pauseStatus);
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setGuestAgentStatus(GuestAgentStatus.forValue(rs.getInt("guest_agent_status")));
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setStopReason(rs.getString("reason"));
    VmExitReason exitReason = VmExitReason.forValue(rs.getInt("exit_reason"));
    entity.setExitReason(exitReason);
    entity.setGuestCpuCount(rs.getInt("guest_cpu_count"));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    setGraphicsToEntity(rs, entity);
    entity.setGuestMemoryBuffered(getLong(rs, "guest_mem_buffered"));
    entity.setGuestMemoryCached(getLong(rs, "guest_mem_cached"));
    entity.setGuestMemoryFree(getLong(rs, "guest_mem_free"));
    entity.setGuestOsTimezoneOffset(rs.getInt("guest_timezone_offset"));
    entity.setGuestOsTimezoneName(rs.getString("guest_timezone_name"));
    entity.setGuestOsArch(rs.getInt("guestos_arch"));
    entity.setGuestOsCodename(rs.getString("guestos_codename"));
    entity.setGuestOsDistribution(rs.getString("guestos_distribution"));
    entity.setGuestOsKernelVersion(rs.getString("guestos_kernel_version"));
    entity.setGuestOsType(rs.getString("guestos_type"));
    entity.setGuestOsVersion(rs.getString("guestos_version"));
    entity.setGuestContainers(fromContainersString(rs.getString("guest_containers")));
    return entity;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, acpiEnabled, appList, bootSequence, clientIp, vncKeyboardLayout, consoleCurrentUserName, guestCurUserName, consoleUserId, guestOs, guestRequestedMemory, kvmEnable, lastVdsRunOn, disks, exitMessage, exitStatus, win2kHackEnabled, migratingToVds, pauseStatus, runOnVds, session, status, utcDiff, vmHost, vmIp, vmFQDN, lastStartTime, lastStopTime, vmPid, lastWatchdogEvent, lastWatchdogAction, runOnce, cpuName, guestAgentStatus, currentCd, stopReason, exitReason, emulatedMachine, graphicsInfos, guestMemoryFree, guestMemoryBuffered, guestMemoryCached, guestOsTimezoneName, guestOsTimezoneOffset, guestOsArch, guestOsCodename, guestOsDistribution, guestOsKernelVersion, guestOsVersion, guestOsType, guestContainerList);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, acpiEnabled, appList, bootSequence, clientIp, vncKeyboardLayout, consoleCurrentUserName, guestCurUserName, consoleUserId, guestOs, guestRequestedMemory, kvmEnable, lastVdsRunOn, disks, exitMessage, exitStatus, win2kHackEnabled, migratingToVds, pauseStatus, runOnVds, session, status, utcDiff, vmHost, vmIp, vmFQDN, lastStartTime, lastStopTime, vmPid, lastWatchdogEvent, lastWatchdogAction, runOnce, cpuName, guestAgentStatus, currentCd, stopReason, exitReason, emulatedMachine, graphicsInfos, guestMemoryFree, guestMemoryBuffered, guestMemoryCached, guestOsTimezoneName, guestOsTimezoneOffset, guestOsArch, guestOsCodename, guestOsDistribution, guestOsKernelVersion, guestOsVersion, guestOsType, guestContainers);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmDynamic)) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(acpiEnabled, other.acpiEnabled) && Objects.equals(appList, other.appList) && bootSequence == other.bootSequence && Objects.equals(clientIp, other.clientIp) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(consoleCurrentUserName, other.consoleCurrentUserName) && Objects.equals(guestCurUserName, other.guestCurUserName) && Objects.equals(consoleUserId, other.consoleUserId) && Objects.equals(guestOs, other.guestOs) && Objects.equals(guestRequestedMemory, other.guestRequestedMemory) && Objects.equals(kvmEnable, other.kvmEnable) && Objects.equals(lastVdsRunOn, other.lastVdsRunOn) && Objects.equals(disks, other.disks) && Objects.equals(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && Objects.equals(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && Objects.equals(runOnVds, other.runOnVds) && session == other.session && status == other.status && Objects.equals(utcDiff, other.utcDiff) && Objects.equals(vmHost, other.vmHost) && Objects.equals(vmIp, other.vmIp) && Objects.equals(vmFQDN, other.vmFQDN) && Objects.equals(lastStartTime, other.lastStartTime) && Objects.equals(lastStopTime, other.lastStopTime) && Objects.equals(vmPid, other.vmPid) && Objects.equals(lastWatchdogEvent, other.lastWatchdogEvent) && Objects.equals(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && Objects.equals(cpuName, other.cpuName) && Objects.equals(guestAgentStatus, other.guestAgentStatus) && Objects.equals(currentCd, other.currentCd) && Objects.equals(stopReason, other.stopReason) && exitReason == other.exitReason && Objects.equals(emulatedMachine, other.emulatedMachine) && Objects.equals(graphicsInfos, other.getGraphicsInfos()) && Objects.equals(guestMemoryBuffered, other.guestMemoryBuffered) && Objects.equals(guestMemoryCached, other.guestMemoryCached) && Objects.equals(guestMemoryFree, other.guestMemoryFree) && Objects.equals(guestOsTimezoneName, other.guestOsTimezoneName) && guestOsTimezoneOffset == other.guestOsTimezoneOffset && Objects.equals(guestOsVersion, other.guestOsVersion) && Objects.equals(guestOsDistribution, other.guestOsDistribution) && Objects.equals(guestOsCodename, other.guestOsCodename) && Objects.equals(guestOsKernelVersion, other.guestOsKernelVersion) && Objects.equals(guestOsArch, other.guestOsArch) && Objects.equals(guestOsType, other.guestOsType) && Objects.equals(guestContainerList, other.guestContainerList);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmDynamic)) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(acpiEnabled, other.acpiEnabled) && Objects.equals(appList, other.appList) && bootSequence == other.bootSequence && Objects.equals(clientIp, other.clientIp) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(consoleCurrentUserName, other.consoleCurrentUserName) && Objects.equals(guestCurUserName, other.guestCurUserName) && Objects.equals(consoleUserId, other.consoleUserId) && Objects.equals(guestOs, other.guestOs) && Objects.equals(guestRequestedMemory, other.guestRequestedMemory) && Objects.equals(kvmEnable, other.kvmEnable) && Objects.equals(lastVdsRunOn, other.lastVdsRunOn) && Objects.equals(disks, other.disks) && Objects.equals(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && Objects.equals(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && Objects.equals(runOnVds, other.runOnVds) && session == other.session && status == other.status && Objects.equals(utcDiff, other.utcDiff) && Objects.equals(vmHost, other.vmHost) && Objects.equals(vmIp, other.vmIp) && Objects.equals(vmFQDN, other.vmFQDN) && Objects.equals(lastStartTime, other.lastStartTime) && Objects.equals(lastStopTime, other.lastStopTime) && Objects.equals(vmPid, other.vmPid) && Objects.equals(lastWatchdogEvent, other.lastWatchdogEvent) && Objects.equals(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && Objects.equals(cpuName, other.cpuName) && Objects.equals(guestAgentStatus, other.guestAgentStatus) && Objects.equals(currentCd, other.currentCd) && Objects.equals(stopReason, other.stopReason) && exitReason == other.exitReason && Objects.equals(emulatedMachine, other.emulatedMachine) && Objects.equals(graphicsInfos, other.getGraphicsInfos()) && Objects.equals(guestMemoryBuffered, other.guestMemoryBuffered) && Objects.equals(guestMemoryCached, other.guestMemoryCached) && Objects.equals(guestMemoryFree, other.guestMemoryFree) && Objects.equals(guestOsTimezoneName, other.guestOsTimezoneName) && guestOsTimezoneOffset == other.guestOsTimezoneOffset && Objects.equals(guestOsVersion, other.guestOsVersion) && Objects.equals(guestOsDistribution, other.guestOsDistribution) && Objects.equals(guestOsCodename, other.guestOsCodename) && Objects.equals(guestOsKernelVersion, other.guestOsKernelVersion) && Objects.equals(guestOsArch, other.guestOsArch) && Objects.equals(guestOsType, other.guestOsType) && Objects.equals(guestContainers, other.guestContainers);
}
#end_block

#method_before
public void updateRuntimeData(VmDynamic vm, Guid vdsId) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(new HashMap<>(vm.getGraphicsInfos()));
    setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    setGuestMemoryCached(vm.getGuestMemoryCached());
    setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
    setGuestContainerList(vm.getGuestContainerList());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRuntimeData(VmDynamic vm, Guid vdsId) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(new HashMap<>(vm.getGraphicsInfos()));
    setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    setGuestMemoryCached(vm.getGuestMemoryCached());
    setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
    setGuestContainers(vm.getGuestContainers());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    initGuestContainerList(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setVmIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    initGuestContainers(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setVmIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
@Override
public void render(Context context, GlusterBrickEntity brick, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no brick is provided:
    if (brick == null) {
        return;
    }
    // Find the image corresponding to the status of the brick:
    GlusterStatus status = brick.getStatus();
    ImageResource statusImage = null;
    switch(status) {
        case DOWN:
            statusImage = resources.downImage();
            break;
        case UP:
            statusImage = resources.upImage();
            break;
        case UNKNOWN:
            statusImage = resources.questionMarkImage();
            break;
        default:
            statusImage = resources.downImage();
    }
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    if (brick.getUnSyncedEntries() != null && brick.getUnSyncedEntries() > 0) {
        SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.alertImage()).getHTML());
        sb.append(templates.statusWithAlertTemplate(statusImageHtml, alertImageHtml, id, status.toString()));
    } else {
        sb.append(templates.statusTemplate(statusImageHtml, id, status.toString()));
    }
}
#method_after
@Override
public void render(Context context, GlusterBrickEntity brick, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no brick is provided:
    if (brick == null) {
        return;
    }
    // Find the image corresponding to the status of the brick:
    GlusterStatus status = brick.getStatus();
    ImageResource statusImage = null;
    switch(status) {
        case DOWN:
            statusImage = resources.downImage();
            break;
        case UP:
            statusImage = resources.upImage();
            break;
        case UNKNOWN:
            statusImage = resources.questionMarkImage();
            break;
        default:
            statusImage = resources.downImage();
    }
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    if (brick.getUnSyncedEntries() > 0) {
        SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.alertImage()).getHTML());
        sb.append(templates.statusWithAlertTemplate(statusImageHtml, alertImageHtml, id, status.toString()));
    } else {
        sb.append(templates.statusTemplate(statusImageHtml, id, status.toString()));
    }
}
#end_block

#method_before
public static boolean isHealingRequired(GlusterVolumeEntity volume) {
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getUnSyncedEntries() != null && brick.getUnSyncedEntries() > 0) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean isHealingRequired(GlusterVolumeEntity volume) {
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getUnSyncedEntries() > 0) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    BrickStatusColumn brickStatusColumn = new BrickStatusColumn();
    brickStatusColumn.setContextMenuTitle(constants.statusVolumeBrick());
    brickStatusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(brickStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterBrickEntity> serverColumn = new AbstractTextColumn<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getServerName();
        }
    };
    serverColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(serverColumn, constants.serverVolumeBrick(), "300px");
    AbstractTextColumn<GlusterBrickEntity> directoryColumn = new AbstractTextColumn<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getQualifiedName();
        }
    };
    directoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(directoryColumn, constants.brickDirectoryVolumeBrick(), "400px");
    getTable().addColumn(new Column<GlusterBrickEntity, BrickProperties>(new BrickCapacityCell()) {

        @Override
        public BrickProperties getValue(GlusterBrickEntity object) {
            return object.getBrickProperties();
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterBrickEntity> healInfoColumn = new AbstractUptimeColumn<GlusterBrickEntity>() {

        @Override
        protected Double getRawValue(GlusterBrickEntity object) {
            return object.getSelfHealEta();
        }

        @Override
        public String getValue(GlusterBrickEntity object) {
            if (object.getSelfHealEta() > 0) {
                return super.getValue(object);
            } else {
                return object.getUnSyncedEntries() == null ? constants.notAvailableLabel() : object.getUnSyncedEntries() > 0 ? object.getUnSyncedEntries().toString() + constants.unSyncedEntriesPresent() : constants.GlusterSelfHealOk();
            }
        }

        @Override
        public SafeHtml getTooltip(GlusterBrickEntity object) {
            if (object.getSelfHealEta() > 0) {
                String toolTip = object.getUnSyncedEntries().toString() + constants.unSyncedEntriesPresent();
                // $NON-NLS-1$
                return SafeHtmlUtils.fromString(toolTip);
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(healInfoColumn, constants.healInfo(), "110px");
    getTable().addColumn(new VolumeActivityColumn<GlusterBrickEntity>(getActivityCell()), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.addBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.removeBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.replaceBrickBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getReplaceBrickCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.advancedDetailsBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBrickAdvancedDetailsCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    BrickStatusColumn brickStatusColumn = new BrickStatusColumn();
    brickStatusColumn.setContextMenuTitle(constants.statusVolumeBrick());
    brickStatusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(brickStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterBrickEntity> serverColumn = new AbstractTextColumn<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getServerName();
        }
    };
    serverColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(serverColumn, constants.serverVolumeBrick(), "300px");
    AbstractTextColumn<GlusterBrickEntity> directoryColumn = new AbstractTextColumn<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getQualifiedName();
        }
    };
    directoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(directoryColumn, constants.brickDirectoryVolumeBrick(), "400px");
    getTable().addColumn(new Column<GlusterBrickEntity, BrickProperties>(new BrickCapacityCell()) {

        @Override
        public BrickProperties getValue(GlusterBrickEntity object) {
            return object.getBrickProperties();
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterBrickEntity> healInfoColumn = new AbstractUptimeColumn<GlusterBrickEntity>() {

        @Override
        protected Double getRawValue(GlusterBrickEntity object) {
            return object.getSelfHealEta();
        }

        @Override
        public String getValue(GlusterBrickEntity object) {
            if (object.getSelfHealEta() > 0) {
                return super.getValue(object);
            } else {
                return object.getUnSyncedEntries() == null ? constants.notAvailableLabel() : object.getUnSyncedEntries() > 0 ? messages.unSyncedEntriesPresent(object.getUnSyncedEntries()) : constants.GlusterSelfHealOk();
            }
        }

        @Override
        public SafeHtml getTooltip(GlusterBrickEntity object) {
            if (object.getSelfHealEta() > 0) {
                String toolTip = messages.unSyncedEntriesPresent(object.getUnSyncedEntries());
                return SafeHtmlUtils.fromString(toolTip);
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(healInfoColumn, constants.healInfo(), "110px");
    getTable().addColumn(new VolumeActivityColumn<GlusterBrickEntity>(getActivityCell()), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.addBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.removeBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.replaceBrickBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getReplaceBrickCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.advancedDetailsBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBrickAdvancedDetailsCommand();
        }
    });
}
#end_block

#method_before
@Override
public SafeHtml getTooltip(GlusterBrickEntity brick) {
    GlusterStatus status = brick.getStatus();
    String tooltip = null;
    switch(status) {
        case DOWN:
            tooltip = constants.down();
            break;
        case UP:
            tooltip = constants.up();
            break;
        case UNKNOWN:
            tooltip = constants.unknown();
            break;
        default:
            tooltip = constants.down();
    }
    if (brick.getStatus() != GlusterStatus.DOWN && brick.getUnSyncedEntries() != null && brick.getUnSyncedEntries() > 0) {
        // $NON-NLS-1$
        tooltip += ", " + brick.getUnSyncedEntries() + constants.unSyncedEntriesPresent();
    }
    return SafeHtmlUtils.fromSafeConstant(tooltip);
}
#method_after
@Override
public SafeHtml getTooltip(GlusterBrickEntity brick) {
    GlusterStatus status = brick.getStatus();
    String tooltip = null;
    switch(status) {
        case DOWN:
            tooltip = constants.down();
            break;
        case UP:
            tooltip = constants.up();
            break;
        case UNKNOWN:
            tooltip = constants.unknown();
            break;
        default:
            tooltip = constants.down();
    }
    if (brick.getStatus() != GlusterStatus.DOWN && brick.getUnSyncedEntries() > 0) {
        tooltip = messages.brickStatusWithUnSyncedEntriesPresent(tooltip, brick.getUnSyncedEntries());
    }
    return SafeHtmlUtils.fromSafeConstant(tooltip);
}
#end_block

#method_before
@Override
public SafeHtml getTooltip(GlusterVolumeEntity volume) {
    if (volume == null) {
        return null;
    }
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    String tooltip = null;
    switch(status) {
        case DOWN:
            tooltip = constants.down();
            break;
        case UP:
            tooltip = constants.up();
            break;
        case SOME_BRICKS_DOWN:
            tooltip = constants.volumeBricksDown();
            break;
        case ALL_BRICKS_DOWN:
            tooltip = constants.volumeAllBricksDown();
            break;
        default:
            tooltip = constants.down();
    }
    if ((status == VolumeStatus.UP || status == VolumeStatus.SOME_BRICKS_DOWN) && GlusterVolumeUtils.isHealingRequired(volume)) {
        // $NON-NLS-1$
        tooltip += ", " + constants.needsGlusterHealing();
    }
    return SafeHtmlUtils.fromSafeConstant(tooltip);
}
#method_after
@Override
public SafeHtml getTooltip(GlusterVolumeEntity volume) {
    if (volume == null) {
        return null;
    }
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    String tooltip = null;
    switch(status) {
        case DOWN:
            tooltip = constants.down();
            break;
        case UP:
            tooltip = constants.up();
            break;
        case SOME_BRICKS_DOWN:
            tooltip = constants.volumeBricksDown();
            break;
        case ALL_BRICKS_DOWN:
            tooltip = constants.volumeAllBricksDown();
            break;
        default:
            tooltip = constants.down();
    }
    if ((status == VolumeStatus.UP || status == VolumeStatus.SOME_BRICKS_DOWN) && GlusterVolumeUtils.isHealingRequired(volume)) {
        tooltip = messages.needsGlusterHealingWithVolumeStatus(tooltip);
    }
    return SafeHtmlUtils.fromSafeConstant(tooltip);
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.propertyName.equals("guestContainerList")) {
        // $NON-NLS-1$
        updateGuestContainerList();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.propertyName.equals("guestContainers")) {
        // $NON-NLS-1$
        updateGuestContainers();
    }
}
#end_block

#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    updateGuestContainerList();
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    updateGuestContainers();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    updateGuestContainerList();
    setIsQueryFirstTime(false);
}
#method_after
@Override
protected void syncSearch() {
    updateGuestContainers();
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(ManagementNetworkAttachmentPopupPresenterWidget.class, ManagementNetworkAttachmentPopupPresenterWidget.ViewDef.class, ManagementNetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#end_block

#method_before
@Override
public void initTable() {
    AbstractTextColumn<GuestContainer> idColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            if (row != null) {
                return row.getId();
            }
            return constants.empty();
        }
    };
    AbstractTextColumn<GuestContainer> namesColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            if (row != null && row.getNames() != null) {
                // $NON-NLS-1$
                return StringUtils.join(row.getNames(), ", ");
            }
            return constants.empty();
        }
    };
    AbstractTextColumn<GuestContainer> imageColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            if (row != null) {
                return row.getImage();
            }
            return constants.empty();
        }
    };
    AbstractTextColumn<GuestContainer> commandColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            if (row != null) {
                return row.getCommand();
            }
            return constants.empty();
        }
    };
    AbstractTextColumn<GuestContainer> statusColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            if (row != null) {
                return row.getStatus();
            }
            return constants.empty();
        }
    };
    getTable().addColumn(idColumn, constants.idContainer());
    getTable().addColumn(namesColumn, constants.namesContainer());
    getTable().addColumn(imageColumn, constants.imageContainer());
    getTable().addColumn(commandColumn, constants.commandContainer());
    getTable().addColumn(statusColumn, constants.statusContainer());
}
#method_after
@Override
public void initTable() {
    getTable().addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            if (row != null) {
                return row.getId();
            }
            return constants.empty();
        }
    }, constants.idContainer());
    getTable().addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            // $NON-NLS-1$
            return StringUtils.join(row.getNames(), ", ");
        }
    }, constants.namesContainer());
    getTable().addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getImage();
        }
    }, constants.imageContainer());
    getTable().addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getCommand();
        }
    }, constants.commandContainer());
    getTable().addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getStatus();
        }
    }, constants.statusContainer());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmImportGeneralModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmGuestContainerListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmHostDeviceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmDevicesListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmErrataCountModel.class).in(Singleton.class);
    bind(VmErrataListModel.class).in(Singleton.class);
    bind(VirtualMachineMainTabSelectedItems.class).asEagerSingleton();
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<GuestContainer, VmListModel<Void>, VmGuestContainerListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<GuestContainer, VmListModel<Void>, VmGuestContainerListModel<VM>>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmImportGeneralModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmGuestContainerListModel.class).in(Singleton.class);
    bind(VmHostDeviceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmDevicesListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmErrataCountModel.class).in(Singleton.class);
    bind(VmErrataListModel.class).in(Singleton.class);
    bind(VirtualMachineMainTabSelectedItems.class).asEagerSingleton();
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<GuestContainer, VmListModel<Void>, VmGuestContainerListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<GuestContainer, VmListModel<Void>, VmGuestContainerListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
void bindModels() {
    bind(AdElementListModel.class).to(UserPortalAdElementListModel.class);
    // Basic tab
    bind(UserPortalBasicListModel.class).in(Singleton.class);
    bind(VmBasicDiskListModel.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(PoolDiskListModel.class).in(Singleton.class);
    bind(UserPortalVmSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>() {
    }).in(Singleton.class);
    bind(UserPortalVmEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmGuestContainerListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmMonitorModel.class).in(Singleton.class);
    bind(PoolInterfaceListModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    bind(UserPortalTemplateDiskListModel.class).in(Singleton.class);
    bind(UserPortalTemplateEventListModel.class).in(Singleton.class);
    // Extended tab: Resources
    bind(ResourcesModel.class).in(Singleton.class);
}
#method_after
void bindModels() {
    bind(AdElementListModel.class).to(UserPortalAdElementListModel.class);
    // Basic tab
    bind(UserPortalBasicListModel.class).in(Singleton.class);
    bind(VmBasicDiskListModel.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(PoolDiskListModel.class).in(Singleton.class);
    bind(UserPortalVmSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>() {
    }).in(Singleton.class);
    bind(UserPortalVmEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmGuestContainerListModel.class).in(Singleton.class);
    bind(VmMonitorModel.class).in(Singleton.class);
    bind(PoolInterfaceListModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    bind(UserPortalTemplateDiskListModel.class).in(Singleton.class);
    bind(UserPortalTemplateEventListModel.class).in(Singleton.class);
    // Extended tab: Resources
    bind(ResourcesModel.class).in(Singleton.class);
}
#end_block

#method_before
void bindModelProviders() {
    // Basic tab
    bind(UserPortalBasicListProvider.class).in(Singleton.class);
    // Options
    bind(OptionsProvider.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    bind(VmInterfaceListModelProvider.class).in(Singleton.class);
    bind(VmDiskListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<Disk, UserPortalListModel, PoolDiskListModel>>() {
    }).in(Singleton.class);
    bind(VmSnapshotListModelProvider.class).in(Singleton.class);
    bind(VmPermissionListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalListModel, UserPortalVmEventListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<String, UserPortalListModel, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<GuestContainer, UserPortalListModel, VmGuestContainerListModel<VM>>>() {
    }).in(Singleton.class);
    bind(VmMonitorModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<VmNetworkInterface, UserPortalListModel, PoolInterfaceListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalTemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    bind(TemplateInterfaceListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<DiskImage, UserPortalTemplateListModel, UserPortalTemplateDiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalTemplateListModel, UserPortalTemplateEventListModel>>() {
    }).in(Singleton.class);
    bind(TemplatePermissionListModelProvider.class).in(Singleton.class);
    // Extended tab: Resources
    bind(new TypeLiteral<UserPortalDataBoundModelProvider<VM, ResourcesModel>>() {
    }).in(Singleton.class);
}
#method_after
void bindModelProviders() {
    // Basic tab
    bind(UserPortalBasicListProvider.class).in(Singleton.class);
    // Options
    bind(OptionsProvider.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    bind(VmInterfaceListModelProvider.class).in(Singleton.class);
    bind(VmDiskListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<Disk, UserPortalListModel, PoolDiskListModel>>() {
    }).in(Singleton.class);
    bind(VmSnapshotListModelProvider.class).in(Singleton.class);
    bind(VmPermissionListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalListModel, UserPortalVmEventListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<String, UserPortalListModel, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<GuestContainer, UserPortalListModel, VmGuestContainerListModel>>() {
    }).in(Singleton.class);
    bind(VmMonitorModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<VmNetworkInterface, UserPortalListModel, PoolInterfaceListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalTemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    bind(TemplateInterfaceListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<DiskImage, UserPortalTemplateListModel, UserPortalTemplateDiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalTemplateListModel, UserPortalTemplateEventListModel>>() {
    }).in(Singleton.class);
    bind(TemplatePermissionListModelProvider.class).in(Singleton.class);
    // Extended tab: Resources
    bind(new TypeLiteral<UserPortalDataBoundModelProvider<VM, ResourcesModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestContainerPresenter.class, SubTabExtendedVmGuestContainerPresenter.ViewDef.class, SubTabExtendedVmGuestContainerView.class, SubTabExtendedVmGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestInfoPresenter.class, SubTabExtendedVmGuestInfoPresenter.ViewDef.class, SubTabExtendedVmGuestInfoView.class, SubTabExtendedVmGuestInfoPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateEditPopupPresenterWidget.class, TemplateEditPopupPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestContainerPresenter.class, SubTabExtendedVmGuestContainerPresenter.ViewDef.class, SubTabExtendedVmGuestContainerView.class, SubTabExtendedVmGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestInfoPresenter.class, SubTabExtendedVmGuestInfoPresenter.ViewDef.class, SubTabExtendedVmGuestInfoView.class, SubTabExtendedVmGuestInfoPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateEditPopupPresenterWidget.class, TemplateEditPopupPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
}
#end_block

#method_before
protected void initContainersTable() {
    containersTable = new EntityModelCellTable<>(false, true);
    AbstractTextColumn<GuestContainer> idColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getId().toString();
        }
    };
    AbstractTextColumn<GuestContainer> namesColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            // $NON-NLS-1$
            return StringUtils.join(row.getNames(), ", ");
        }
    };
    AbstractTextColumn<GuestContainer> imageColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getImage();
        }
    };
    AbstractTextColumn<GuestContainer> commandColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getCommand();
        }
    };
    AbstractTextColumn<GuestContainer> statusColumn = new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getStatus();
        }
    };
    containersTable.addColumn(idColumn, constants.idContainer());
    containersTable.addColumn(namesColumn, constants.namesContainer());
    containersTable.addColumn(imageColumn, constants.imageContainer());
    containersTable.addColumn(commandColumn, constants.commandContainer());
    containersTable.addColumn(statusColumn, constants.statusContainer());
    containersTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    containersTable.setWidth("100%", true);
    containersTable.setSelectionModel(new NoSelectionModel());
}
#method_after
protected void initContainersTable() {
    containersTable = new EntityModelCellTable<>(false, true);
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getId().toString();
        }
    }, constants.idContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            // $NON-NLS-1$
            return StringUtils.join(row.getNames(), ", ");
        }
    }, constants.namesContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getImage();
        }
    }, constants.imageContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getCommand();
        }
    }, constants.commandContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getStatus();
        }
    }, constants.statusContainer());
    containersTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    containersTable.setWidth("100%", true);
    containersTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
@TabInfo(container = VirtualMachineSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<GuestContainer, VmListModel<Void>, VmGuestContainerListModel<VM>> modelProvider) {
    return new ModelBoundTabData(constants.virtualMachineContainerSubTabLabel(), 4, modelProvider);
}
#method_after
@TabInfo(container = VirtualMachineSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<GuestContainer, VmListModel<Void>, VmGuestContainerListModel> modelProvider) {
    return new ModelBoundTabData(constants.virtualMachineContainerSubTabLabel(), 4, modelProvider);
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    vmModel.fireValidationCompleteEvent();
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder(), new CpuSharesVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder(), new CpuSharesVmBaseToVmBaseBuilder(), new DedicatedVmForVdsVmBaseToVmBaseBuilder());
    return tempVar;
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                unitModel.fireValidationCompleteEvent();
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        // currentl only hot plug memory is supported here (no hot unplug)
                        confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < gettempVm().getMemSizeMb());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, gettempVm()));
                        boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(gettempVm());
                        confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, gettempVm(), isMemoryHotUnplugSupported));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshSelfHealInfo")
public void refreshSelfHealInfo() {
    log.debug("Refreshing Gluster Self Heal Data");
    for (Cluster cluster : getClusterDao().getAll()) {
        if (supportsGlusterSelfHealMonitoring(cluster)) {
            try {
                refreshSelfHealData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster self heal data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshSelfHealInfo")
public void refreshSelfHealInfo() {
    log.debug("Refreshing Gluster Self Heal Data");
    for (Cluster cluster : getClusterDao().getAll()) {
        if (supportsGlusterSelfHealMonitoring(cluster)) {
            try {
                refreshSelfHealData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster self heal data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
    log.debug("Refreshing Gluster Self Heal data is completed");
}
#end_block

#method_before
public void refreshSelfHealData(Cluster cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh self heal data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debug("Refreshing self heal status for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshSelfHealData(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#method_after
public void refreshSelfHealData(Cluster cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh self heal data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debug("Refreshing self heal status for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // self heal info can be fetched only for started volumes
        if (volume.isOnline()) {
            try {
                refreshSelfHealData(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
private void refreshSelfHealData(VDS upServer, GlusterVolumeEntity volume) {
    Integer usageHistoryLimit = Config.getValue(ConfigValues.UsageHistoryLimit);
    Map<Guid, Integer> healInfo = getGlusterVolumeHealInfo(upServer, volume.getName());
    for (GlusterBrickEntity brick : volume.getBricks()) {
        brick.setUnsycnedEntries(healInfo.get(brick.getId()));
        brick.setUnSyncedEntiresTrend(addToHistory(brick.getUnSyncedEntiresTrend(), healInfo.get(brick.getId()), usageHistoryLimit));
    }
    getBrickDao().updateUnSyncedEntries(volume.getBricks());
}
#method_after
private void refreshSelfHealData(VDS upServer, GlusterVolumeEntity volume) {
    Integer usageHistoryLimit = Config.getValue(ConfigValues.GlusterUnSyncedEntriesHistoryLimit);
    Map<Guid, Integer> healInfo = getGlusterVolumeHealInfo(upServer, volume.getName());
    for (GlusterBrickEntity brick : volume.getBricks()) {
        brick.setUnSyncedEntries(healInfo.get(brick.getId()));
        brick.setUnSyncedEntriesTrend(addToHistory(brick.getUnSyncedEntriesTrend(), healInfo.get(brick.getId()), usageHistoryLimit));
    }
    getBrickDao().updateUnSyncedEntries(volume.getBricks());
}
#end_block

#method_before
List<Integer> addToHistory(List<Integer> current, Integer newValue, int limit) {
    if (newValue == null) {
        return current;
    }
    if (current == null || current.isEmpty()) {
        return Arrays.asList(newValue);
    }
    if (limit == 0) {
        return Collections.emptyList();
    }
    List<Integer> res = new ArrayList<>(current);
    res.add(newValue);
    if (limit >= res.size()) {
        return res;
    }
    return res.subList(res.size() - limit, res.size());
}
#method_after
private List<Integer> addToHistory(List<Integer> current, Integer newValue, int limit) {
    if (newValue == null) {
        // Store -1 instead of Null so that we can maintain the fixed time interval between each entries.
        newValue = -1;
    }
    if (current == null || current.isEmpty()) {
        return Arrays.asList(newValue);
    }
    if (limit == 0) {
        return Collections.emptyList();
    }
    List<Integer> res = new ArrayList<>(current);
    res.add(newValue);
    if (limit >= res.size()) {
        return res;
    }
    return res.subList(res.size() - limit, res.size());
}
#end_block

#method_before
protected Map<Guid, Integer> getGlusterVolumeHealInfo(VDS upServer, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeHealInfo, new GlusterVolumeVDSParameters(upServer.getId(), volumeName));
    // TODO Error handling.
    return (Map<Guid, Integer>) result.getReturnValue();
}
#method_after
private Map<Guid, Integer> getGlusterVolumeHealInfo(VDS upServer, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeHealInfo, new GlusterVolumeVDSParameters(upServer.getId(), volumeName));
    if (result.getSucceeded()) {
        return (Map<Guid, Integer>) result.getReturnValue();
    } else {
        return Collections.emptyMap();
    }
}
#end_block

#method_before
@Override
public void setEnabled(boolean enabled) {
    contentWidget.setEnabled(enabled);
    if (enabled) {
        getFormLabel().getElement().replaceClassName(OvirtCss.LABEL_DISABLED, OvirtCss.LABEL_ENABLED);
    } else {
        getFormLabel().getElement().replaceClassName(OvirtCss.LABEL_ENABLED, OvirtCss.LABEL_DISABLED);
    }
}
#method_after
@Override
public void setEnabled(boolean enabled) {
    contentWidget.setEnabled(enabled);
    if (enabled) {
        getFormLabel().getElement().replaceClassName(OvirtCss.LABEL_DISABLED, OvirtCss.LABEL_ENABLED);
        setWidgetTooltip("");
    } else {
        getFormLabel().getElement().replaceClassName(OvirtCss.LABEL_ENABLED, OvirtCss.LABEL_DISABLED);
    }
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    initThreadsPerCore();
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.timeZoneVm());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor.hideLabel();
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.asListBox().setVisibleItemCount(3);
    defaultHostEditor.hideLabel();
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    migrationModeEditor.hideLabel();
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    overrideMigrationDowntimeEditor.hideLabel();
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor.hideLabel();
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    initThreadsPerCore();
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.timeZoneVm());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor.hideLabel();
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.asListBox().setVisibleItemCount(3);
    defaultHostEditor.hideLabel();
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    migrationModeEditor.hideLabel();
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    overrideMigrationDowntimeEditor.hideLabel();
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    overrideMigrationPolicyEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor.hideLabel();
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
public void setUsePatternFly(boolean usePatternFly) {
    this.usePatternFly = usePatternFly;
    getWidget().addStyleName(style.listBox());
    if (usePatternFly) {
        container.addStyleName(Styles.FORM_CONTROL);
        container.addStyleName(style.container());
        container.removeStyleName(style.container_legacy());
        getWidget().addStyleName(style.listBoxPatternfly());
        groupLabelContainer.addStyleName(style.labelContainer());
    } else {
        container.addStyleName(style.container_legacy());
    }
}
#method_after
public void setUsePatternFly(boolean usePatternFly) {
    getWidget().addStyleName(style.listBox());
    if (usePatternFly) {
        container.addStyleName(Styles.FORM_CONTROL);
        container.addStyleName(style.container());
        container.removeStyleName(style.container_legacy());
        getWidget().addStyleName(style.listBoxPatternfly());
        groupLabelContainer.addStyleName(style.labelContainer());
    } else {
        container.addStyleName(style.container_legacy());
    }
}
#end_block

#method_before
private void setSearchEnabled(boolean value) {
    if (searchEnabled != value) {
        searchEnabled = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("EnableSearchBar"));
    }
}
#method_after
private void setSearchEnabled(boolean value) {
    if (searchEnabled != value) {
        searchEnabled = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchEnabled"));
    }
}
#end_block

#method_before
public DynamicUrlContentTabProxy create(Type<RequestTabsHandler> requestTabsEventType, Type<ChangeTabHandler> changeTabEventType, Type<RevealContentHandler<?>> slot, String label, float priority, String historyToken, boolean isMainTab, String contentUrl, Align align, String searchPrefix) {
    if (isMainTab) {
        if (searchPrefix == null) {
            searchPrefix = label;
        }
        commonModelProvider.get().addUiPluginListModel(searchPrefix, historyToken);
    }
    return new DynamicUrlContentTabProxy(placeManager, eventBus, gatekeeper, requestTabsEventType, changeTabEventType, slot, viewProvider, label, priority, historyToken, isMainTab, contentUrl, align, commonModelProvider);
}
#method_after
public DynamicUrlContentTabProxy create(Type<RequestTabsHandler> requestTabsEventType, Type<ChangeTabHandler> changeTabEventType, Type<RevealContentHandler<?>> slot, String label, float priority, String historyToken, boolean isMainTab, String contentUrl, Align align, String searchPrefix) {
    if (isMainTab) {
        commonModelProvider.get().addPluginModel(historyToken, // $NON-NLS-1$ //$NON-NLS-2$
        searchPrefix != null ? searchPrefix : label.replace(":", ""));
    }
    return new DynamicUrlContentTabProxy(placeManager, eventBus, gatekeeper, requestTabsEventType, changeTabEventType, slot, viewProvider, label, priority, historyToken, isMainTab, contentUrl, align, commonModelProvider);
}
#end_block

#method_before
void addCommonModelListeners() {
    commonModel.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            // Update search string when 'SearchString' property changes
            if ("SearchString".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewSearchString();
            } else // Update search string prefix when 'SearchStringPrefix' property changes
            if ("SearchStringPrefix".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewSearchStringPrefix();
            } else // Update search string prefix visibility when 'HasSearchStringPrefix' property changes
            if ("HasSearchStringPrefix".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewHasSearchStringPrefix();
            } else if ("HasSelectedTags".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewHasSelectedTags();
            } else if ("EnableSearchBar".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateSearchBarEnabled();
            }
        }
    });
}
#method_after
void addCommonModelListeners() {
    commonModel.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            // Update search string when 'SearchString' property changes
            if ("SearchString".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewSearchString();
            } else // Update search string prefix when 'SearchStringPrefix' property changes
            if ("SearchStringPrefix".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewSearchStringPrefix();
            } else // Update search string prefix visibility when 'HasSearchStringPrefix' property changes
            if ("HasSearchStringPrefix".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewHasSearchStringPrefix();
            } else if ("HasSelectedTags".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewHasSelectedTags();
            } else if ("SearchEnabled".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateViewSearchEnabled();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    commonModelProvider.get().setUiPluginTabSelected(this.getProxy().getNameToken());
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    commonModelProvider.get().setPluginTabSelected(getProxy().getTargetHistoryToken());
}
#end_block

#method_before
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    addReportedIpv4Configuration(result);
    // Reporting out-of-sync IPv6 configuration is disabled temporary.
    // It's planned to be re-enabled after v4.0-beta is released.
    // addReportedIpv6Configuration(result);
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    return result;
}
#method_after
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    addReportedIpv4Configuration(result);
    /**
     * TODO: YZ - uncomment the method call after v4.0 is branched out.
     *
     * Reporting out-of-sync IPv6 configuration is disabled temporary.
     * It's planned to be re-enabled after v4.0-beta is released.
     *
     * addReportedIpv6Configuration(result);
     */
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    return result;
}
#end_block

#method_before
/*

    @Test
    public void testIsNetworkInSyncWhenIpv6BootProtocolDifferent() {
        initIpv6ConfigurationBootProtocol(false);
        iface.setIpv6BootProtocol(Ipv6BootProtocol.forValue(
                (IPV6_BOOT_PROTOCOL.getValue() + 1) % Ipv6BootProtocol.values().length));
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testIsNetworkInSyncWhenIpv6StaticBootProtocolAddressDifferent() throws Exception {
        initIpv6ConfigurationBootProtocolAddress(IPV6_BOOT_PROTOCOL, false);
        iface.setIpv6BootProtocol(Ipv6BootProtocol.forValue(
                (IPV6_BOOT_PROTOCOL.getValue() + 1) % Ipv6BootProtocol.values().length));
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testIsNetworkInSyncWhenIpv6StaticBootProtocolPrefixDifferent() throws Exception {
        initIpv6ConfigurationBootProtocolPrefix(IPV6_BOOT_PROTOCOL, false);
        iface.setIpv6BootProtocol(Ipv6BootProtocol.forValue(
                (IPV6_BOOT_PROTOCOL.getValue() + 1) % Ipv6BootProtocol.values().length));
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testIsNetworkInSyncWhenIpv6GatewayDifferent(){
        initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.STATIC_IP, false);
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testReportConfigurationsOnHostWhenIpv6BootProtocolNotStatic() {
        initIpv6ConfigurationBootProtocolAddress(Ipv6BootProtocol.NONE, false);
        initIpv6ConfigurationBootProtocolPrefix(Ipv6BootProtocol.NONE, false);
        initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.NONE, false);
        NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues =
                createTestedInstanceWithSameNonQosValues();
        List<ReportedConfiguration> reportedConfigurationList =
                testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
        List<ReportedConfiguration> expectedReportedConfigurations = createDefaultExpectedReportedConfigurations();
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_BOOT_PROTOCOL,
                iface.getIpv6BootProtocol().name(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getBootProtocol().name(),
                true));
        assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
        assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
    }

    @Test
    public void testReportConfigurationsOnHostWhenIpv6BootProtocolStatic() {
        boolean syncIpv6Address = RandomUtils.instance().nextBoolean();
        boolean syncIpv6Prefix = RandomUtils.instance().nextBoolean();
        boolean syncIpv6Gateway = RandomUtils.instance().nextBoolean();
        initIpv6ConfigurationBootProtocolAddress(Ipv6BootProtocol.STATIC_IP, syncIpv6Address);
        initIpv6ConfigurationBootProtocolPrefix(Ipv6BootProtocol.STATIC_IP, syncIpv6Prefix);
        initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.STATIC_IP, syncIpv6Gateway);
        NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues =
                createTestedInstanceWithSameNonQosValues();
        List<ReportedConfiguration> reportedConfigurationList =
                testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
        List<ReportedConfiguration> expectedReportedConfigurations = createDefaultExpectedReportedConfigurations();
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_BOOT_PROTOCOL,
                iface.getIpv6BootProtocol().name(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getBootProtocol().name(),
                true));
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_PREFIX,
                Objects.toString(iface.getIpv6Prefix(), null),
                Objects.toString(mockedIpConfiguration.getIpv6PrimaryAddress().getPrefix(), null),
                syncIpv6Prefix));
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_ADDRESS,
                iface.getIpv6Address(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getAddress(),
                syncIpv6Address));
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_GATEWAY,
                iface.getIpv6Gateway(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getGateway(),
                syncIpv6Gateway));

        for (ReportedConfiguration expectedReportedConfiguration : expectedReportedConfigurations) {
            assertThat(reportedConfigurationList, hasItem(expectedReportedConfiguration));
        }
        assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
    }
*/
private void initIpv4Configuration() {
    when(mockedIpConfiguration.hasIpv4PrimaryAddressSet()).thenReturn(true);
    when(mockedIpConfiguration.getIpv4PrimaryAddress()).thenReturn(ipv4Address);
}
#method_after
/*
    TODO: YZ - uncomment the tests after v4.0 is branched out.

    Reporting out-of-sync IPv6 configuration is disabled temporary.
    It's planned to be re-enabled after v4.0-beta is released.

    @Test
    public void testIsNetworkInSyncWhenIpv6BootProtocolDifferent() {
        initIpv6ConfigurationBootProtocol(false);
        iface.setIpv6BootProtocol(Ipv6BootProtocol.forValue(
                (IPV6_BOOT_PROTOCOL.getValue() + 1) % Ipv6BootProtocol.values().length));
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testIsNetworkInSyncWhenIpv6StaticBootProtocolAddressDifferent() throws Exception {
        initIpv6ConfigurationBootProtocolAddress(IPV6_BOOT_PROTOCOL, false);
        iface.setIpv6BootProtocol(Ipv6BootProtocol.forValue(
                (IPV6_BOOT_PROTOCOL.getValue() + 1) % Ipv6BootProtocol.values().length));
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testIsNetworkInSyncWhenIpv6StaticBootProtocolPrefixDifferent() throws Exception {
        initIpv6ConfigurationBootProtocolPrefix(IPV6_BOOT_PROTOCOL, false);
        iface.setIpv6BootProtocol(Ipv6BootProtocol.forValue(
                (IPV6_BOOT_PROTOCOL.getValue() + 1) % Ipv6BootProtocol.values().length));
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testIsNetworkInSyncWhenIpv6GatewayDifferent(){
        initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.STATIC_IP, false);
        assertThat(createTestedInstance().isNetworkInSync(), is(false));
    }

    @Test
    public void testReportConfigurationsOnHostWhenIpv6BootProtocolNotStatic() {
        initIpv6ConfigurationBootProtocolAddress(Ipv6BootProtocol.NONE, false);
        initIpv6ConfigurationBootProtocolPrefix(Ipv6BootProtocol.NONE, false);
        initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.NONE, false);
        NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues =
                createTestedInstanceWithSameNonQosValues();
        List<ReportedConfiguration> reportedConfigurationList =
                testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
        List<ReportedConfiguration> expectedReportedConfigurations = createDefaultExpectedReportedConfigurations();
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_BOOT_PROTOCOL,
                iface.getIpv6BootProtocol().name(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getBootProtocol().name(),
                true));
        assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
        assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
    }

    @Test
    public void testReportConfigurationsOnHostWhenIpv6BootProtocolStatic() {
        boolean syncIpv6Address = RandomUtils.instance().nextBoolean();
        boolean syncIpv6Prefix = RandomUtils.instance().nextBoolean();
        boolean syncIpv6Gateway = RandomUtils.instance().nextBoolean();
        initIpv6ConfigurationBootProtocolAddress(Ipv6BootProtocol.STATIC_IP, syncIpv6Address);
        initIpv6ConfigurationBootProtocolPrefix(Ipv6BootProtocol.STATIC_IP, syncIpv6Prefix);
        initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.STATIC_IP, syncIpv6Gateway);
        NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues =
                createTestedInstanceWithSameNonQosValues();
        List<ReportedConfiguration> reportedConfigurationList =
                testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
        List<ReportedConfiguration> expectedReportedConfigurations = createDefaultExpectedReportedConfigurations();
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_BOOT_PROTOCOL,
                iface.getIpv6BootProtocol().name(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getBootProtocol().name(),
                true));
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_PREFIX,
                Objects.toString(iface.getIpv6Prefix(), null),
                Objects.toString(mockedIpConfiguration.getIpv6PrimaryAddress().getPrefix(), null),
                syncIpv6Prefix));
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_ADDRESS,
                iface.getIpv6Address(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getAddress(),
                syncIpv6Address));
        expectedReportedConfigurations.add(new ReportedConfiguration(ReportedConfigurationType.IPV6_GATEWAY,
                iface.getIpv6Gateway(),
                mockedIpConfiguration.getIpv6PrimaryAddress().getGateway(),
                syncIpv6Gateway));

        for (ReportedConfiguration expectedReportedConfiguration : expectedReportedConfigurations) {
            assertThat(reportedConfigurationList, hasItem(expectedReportedConfiguration));
        }
        assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
    }
*/
private void initIpv4Configuration() {
    when(mockedIpConfiguration.hasIpv4PrimaryAddressSet()).thenReturn(true);
    when(mockedIpConfiguration.getIpv4PrimaryAddress()).thenReturn(ipv4Address);
}
#end_block

#method_before
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(getSnapshotActionType());
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#method_after
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(getSnapshotActionType());
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setEndProcedure(getVm().isQualifiedForLiveSnapshotMerge() ? EndProcedure.COMMAND_MANAGED : EndProcedure.PARENT_MANAGED);
    return parameters;
}
#end_block

#method_before
protected boolean validateImages() {
    List<DiskImage> imagesToValidate = getDiskImagesToValidate();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(imagesToValidate);
    boolean isVmQualifiedForLMOrImagesNotIllegal = getVm().isQualifiedForLiveSnapshotMerge() || validate(diskImagesValidator.diskImagesNotIllegal());
    return getParameters().isNeedsLocking() ? isVmQualifiedForLMOrImagesNotIllegal && validate(diskImagesValidator.diskImagesNotLocked()) : isVmQualifiedForLMOrImagesNotIllegal;
}
#method_after
protected boolean validateImages() {
    List<DiskImage> imagesToValidate = getDiskImagesToValidate();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(imagesToValidate);
    return validateImagesNotLocked(diskImagesValidator) && (getVm().isQualifiedForLiveSnapshotMerge() || validate(diskImagesValidator.diskImagesNotIllegal()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ImagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext()));
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    ImagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext()));
    getParameters().setAutoGeneratedSnapshotId(vdcReturnValue.getActionReturnValue());
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!vdcReturnValue.getSucceeded()) {
                ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!vdcReturnValue.getSucceeded()) {
                ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    if (getParameters().getStage() == LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED) {
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_START);
        removeAutogeneratedSnapshot();
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END);
        return true;
    }
    return false;
}
#end_block

#method_before
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), StorageConstants.LSM_AUTO_GENERATED_SNAPSHOT_DESCRIPTION);
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#method_after
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), "Auto-generated for Live Storage Migration");
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    brick.setVolumeName(rs.getString("volume_name"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    brick.setServerName(rs.getString("vds_name"));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuid(rs, "task_id"));
    brick.setNetworkId(getGuid(rs, "network_id"));
    brick.setNetworkAddress(rs.getString("interface_address"));
    brick.setUnsycnedEntries(rs.getInt("unsynced_entries"));
    brick.setUnSyncedEntiresTrend(asIntList((String) rs.getObject("unsynced_entires_history")));
    return brick;
}
#method_after
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    brick.setVolumeName(rs.getString("volume_name"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    brick.setServerName(rs.getString("vds_name"));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuid(rs, "task_id"));
    brick.setNetworkId(getGuid(rs, "network_id"));
    brick.setNetworkAddress(rs.getString("interface_address"));
    brick.setUnSyncedEntries((rs.getObject("unsynced_entries") != null) ? rs.getInt("unsynced_entries") : null);
    brick.setUnSyncedEntriesTrend(asIntList((String) rs.getObject("unsynced_entries_history")));
    return brick;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    return new MapSqlParameterMapper<GlusterBrickEntity>() {

        @Override
        public MapSqlParameterSource map(GlusterBrickEntity entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("volume_id", entity.getVolumeId()).addValue("server_id", entity.getServerId()).addValue("brick_dir", entity.getBrickDirectory()).addValue("status", entity.getStatus().name()).addValue("id", entity.getId().toString()).addValue("brick_order", entity.getBrickOrder()).addValue("network_id", entity.getNetworkId()).addValue("task_id", entity.getAsyncTask().getTaskId() != null ? entity.getAsyncTask().getTaskId().toString() : "").addValue("unsynced_entries", entity.getUnsycnedEntries()).addValue("unsynced_entires_history", StringUtils.join(entity.getUnSyncedEntiresTrend(), ","));
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    return new MapSqlParameterMapper<GlusterBrickEntity>() {

        @Override
        public MapSqlParameterSource map(GlusterBrickEntity entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("volume_id", entity.getVolumeId()).addValue("server_id", entity.getServerId()).addValue("brick_dir", entity.getBrickDirectory()).addValue("status", entity.getStatus().name()).addValue("id", entity.getId().toString()).addValue("brick_order", entity.getBrickOrder()).addValue("network_id", entity.getNetworkId()).addValue("task_id", entity.getAsyncTask().getTaskId() != null ? entity.getAsyncTask().getTaskId().toString() : "").addValue("unsynced_entries", entity.getUnSyncedEntries()).addValue("unsynced_entries_history", StringUtils.join(entity.getUnSyncedEntriesTrend(), ","));
            return paramValue;
        }
    };
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, volumeId, serverId, brickDirectory, brickOrder, status, asyncTask, unSycnedEntries, unSyncedEntiresTrend);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, volumeId, serverId, brickDirectory, brickOrder, status, asyncTask, unSyncedEntries, unSyncedEntriesTrend, selfHealEta);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity other = (GlusterBrickEntity) obj;
    return Objects.equals(id, other.id) && Objects.equals(volumeId, other.volumeId) && Objects.equals(serverId, other.serverId) && Objects.equals(brickDirectory, other.brickDirectory) && Objects.equals(brickOrder, other.brickOrder) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(unSycnedEntries, other.unSycnedEntries) && Objects.equals(unSyncedEntiresTrend, other.unSyncedEntiresTrend) && status == other.status;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity other = (GlusterBrickEntity) obj;
    return Objects.equals(id, other.id) && Objects.equals(volumeId, other.volumeId) && Objects.equals(serverId, other.serverId) && Objects.equals(brickDirectory, other.brickDirectory) && Objects.equals(brickOrder, other.brickOrder) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(unSyncedEntries, other.unSyncedEntries) && Objects.equals(unSyncedEntriesTrend, other.unSyncedEntriesTrend) && Objects.equals(selfHealEta, other.selfHealEta) && status == other.status;
}
#end_block

#method_before
public void copyFrom(GlusterBrickEntity brick) {
    setId(brick.getId());
    setVolumeId(brick.getVolumeId());
    setServerId(brick.getServerId());
    setServerName(brick.getServerName());
    setBrickDirectory(brick.getBrickDirectory());
    setBrickOrder(brick.getBrickOrder());
    setUnsycnedEntries(brick.unSycnedEntries);
    setUnSyncedEntiresTrend(brick.getUnSyncedEntiresTrend());
    setStatus(brick.getStatus());
}
#method_after
public void copyFrom(GlusterBrickEntity brick) {
    setId(brick.getId());
    setVolumeId(brick.getVolumeId());
    setServerId(brick.getServerId());
    setServerName(brick.getServerName());
    setBrickDirectory(brick.getBrickDirectory());
    setBrickOrder(brick.getBrickOrder());
    setUnSyncedEntries(brick.unSyncedEntries);
    setUnSyncedEntriesTrend(brick.getUnSyncedEntriesTrend());
    setStatus(brick.getStatus());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void getUnSyncedEntries(Map<String, Object> map) {
    Object[] healInfos = (Object[]) map.get(BRICKS);
    for (Object healInfoObj : healInfos) {
        Map<String, String> healInfo = (Map<String, String>) healInfoObj;
        String hostUuid = (String) healInfo.get(HOST_UUID);
        GlusterServer glusterServer = dbUtils.getServerByUuid(Guid.createGuidFromString(hostUuid));
        String brickName = (String) healInfo.get(NAME);
        String[] brickParts = brickName.split(":", -1);
        if (brickParts.length != 2) {
            throw new RuntimeException("Invalid brick representation [" + brickName + "]");
        }
        if (glusterServer == null) {
            log.warn("Could not fetch heal info for brick '{}' - server uuid '{}' not found", brickName, hostUuid);
            return;
        }
        GlusterBrickEntity brick = dbUtils.getGlusterBrickByServerUuidAndBrickDir(glusterServer.getId(), brickParts[1]);
        String status = (String) healInfo.get(STATUS);
        Integer entries = null;
        if ("Connected".equals(status)) {
            entries = Integer.valueOf((String) healInfo.get(NO_OF_ENTRIES));
        }
        unSyncedEntries.put(brick.getId(), entries);
    }
}
#method_after
@SuppressWarnings("unchecked")
private void getUnSyncedEntries(Map<String, Object> map) {
    Object[] healInfos = (Object[]) map.get(BRICKS);
    for (Object healInfoObj : healInfos) {
        Map<String, String> healInfo = (Map<String, String>) healInfoObj;
        String status = (String) healInfo.get(STATUS);
        Integer entries = null;
        if (BRICK_STATUS_CONNECTED.equals(status)) {
            String hostUuid = (String) healInfo.get(HOST_UUID);
            GlusterServer glusterServer = dbUtils.getServerByUuid(Guid.createGuidFromString(hostUuid));
            String brickName = (String) healInfo.get(NAME);
            String[] brickParts = brickName.split(":", -1);
            if (brickParts.length != 2) {
                log.warn("Invalid brick representation [{}] in volume volume {}", brickName);
                continue;
            }
            if (glusterServer == null) {
                log.warn("Could not fetch heal info for brick '{}' - server uuid '{}' not found", brickName, hostUuid);
                continue;
            }
            GlusterBrickEntity brick = dbUtils.getGlusterBrickByServerUuidAndBrickDir(glusterServer.getId(), brickParts[1]);
            entries = Integer.valueOf((String) healInfo.get(NO_OF_ENTRIES));
            unSyncedEntries.put(brick.getId(), entries);
        }
    }
}
#end_block

#method_before
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setCurrentPool(model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem()));
    final String name = model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.getInstance().isPoolNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isUnique = (Boolean) returnValue;
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(getCurrentPool().getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                return;
            }
            String selectedCpu = model.getCustomCpu().getSelectedItem();
            if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                ConfirmationModel confirmModel = new ConfirmationModel();
                confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                // $NON-NLS-1$
                confirmModel.setHashName("edit_unsupported_cpu");
                confirmModel.getCommands().add(// $NON-NLS-1$
                new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                confirmModel.getCommands().add(// $NON-NLS-1$
                UICommand.createCancelUiCommand(// $NON-NLS-1$
                "CancelConfirmation", PoolListModel.this));
                setConfirmWindow(confirmModel);
            } else {
                savePoolPostValidation();
            }
        }
    }), name);
}
#method_after
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setCurrentPool(model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem()));
    final String name = model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.getInstance().isPoolNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isUnique = (Boolean) returnValue;
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(getCurrentPool().getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                model.fireValidationCompleteEvent();
                return;
            }
            String selectedCpu = model.getCustomCpu().getSelectedItem();
            if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                ConfirmationModel confirmModel = new ConfirmationModel();
                confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                // $NON-NLS-1$
                confirmModel.setHashName("edit_unsupported_cpu");
                confirmModel.getCommands().add(// $NON-NLS-1$
                new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                confirmModel.getCommands().add(// $NON-NLS-1$
                UICommand.createCancelUiCommand(// $NON-NLS-1$
                "CancelConfirmation", PoolListModel.this));
                setConfirmWindow(confirmModel);
            } else {
                savePoolPostValidation();
            }
        }
    }), name);
}
#end_block

#method_before
protected static boolean canAttachPrestartedVmToUser(Guid vmId, boolean isStatefulPool, List<String> messages) {
    // and make sure the Vm is running stateless
    return !vmAssignedToUser(vmId, messages) && (isStatefulPool || vmIsRunningStateless(vmId));
}
#method_after
protected static boolean canAttachPrestartedVmToUser(Guid vmId, boolean isStatefulPool, List<String> messages) {
    // and make sure the Vm is running stateless
    return !vmAssignedToUser(vmId, messages) && (isStatefulPool && !vmIsStartedByRunOnce(vmId) || vmIsRunningStateless(vmId));
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceRandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getOverrideMigrationPolicy().setIsChangeable(false);
        getMigrationPolicies().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceRandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        }
    }
}
#end_block

#method_before
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
    }
}
#method_after
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    Cluster cluster = dataCenterWithCluster.getCluster();
    Version version = getCompatibilityVersion();
    // test migration support for VM/cluster level along with the cluster architecture
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), version);
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
    autoConverge.updateChangeability(ConfigurationValues.AutoConvergenceSupported, version);
    migrateCompressed.updateChangeability(ConfigurationValues.MigrationCompressionSupported, version);
}
#method_after
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    Cluster cluster = dataCenterWithCluster.getCluster();
    Version version = getCompatibilityVersion();
    // test migration support for VM/cluster level along with the cluster architecture
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), version);
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
    autoConverge.setIsChangeable(true);
    migrateCompressed.setIsChangeable(true);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType().getSelectedItem() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.getInstance().isSpiceFileTransferToggleSupported(getCompatibilityVersion().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangeable(spiceFileTransferToggle);
        GraphicsTypes selectedGraphics = getGraphicsType().getSelectedItem();
        boolean spiceCopyPasteToggle = selectedGraphics != null && selectedGraphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE);
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangeable(spiceCopyPasteToggle);
    }
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType().getSelectedItem() == DisplayType.qxl;
        if (!isQxl) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getCompatibilityVersion().toString(), false);
        }
        getSpiceFileTransferEnabled().setIsChangeable(isQxl);
        GraphicsTypes selectedGraphics = getGraphicsType().getSelectedItem();
        boolean spiceCopyPasteToggle = selectedGraphics != null && selectedGraphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE);
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangeable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
protected void initGraphicsConsoles(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        if (AsyncDataProvider.getInstance().supportedForUnitVmModel(ConfigurationValues.MultipleGraphicsSupported, this)) {
            graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
        }
    }
    GraphicsTypes prevSelected = getGraphicsType().getSelectedItem();
    if (prevSelected != null && graphicsTypes.contains(prevSelected)) {
        getGraphicsType().setItems(graphicsTypes, prevSelected);
    } else {
        getGraphicsType().setItems(graphicsTypes);
    }
    upgradeGraphicsRelatedModels();
}
#method_after
protected void initGraphicsConsoles(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
    }
    GraphicsTypes prevSelected = getGraphicsType().getSelectedItem();
    if (prevSelected != null && graphicsTypes.contains(prevSelected)) {
        getGraphicsType().setItems(graphicsTypes, prevSelected);
    } else {
        getGraphicsType().setItems(graphicsTypes);
    }
    upgradeGraphicsRelatedModels();
}
#end_block

#method_before
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!getBehavior().isBlankTemplateBehavior()) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.INITIAL_RUN_TAB, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#method_after
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!getBehavior().isBlankTemplateBehavior()) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.INITIAL_RUN_TAB, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    fireValidationCompleteEvent();
    return isValid;
}
#end_block

#method_before
private Guid getPrestartedVmToAttach(Guid vmPoolId) {
    VmPool vmPool = getVmPoolDao().get(vmPoolId);
    List<VmPoolMap> vmPoolMaps = getVmPoolDao().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Up);
    if (vmPoolMaps != null) {
        for (VmPoolMap map : vmPoolMaps) {
            if (canAttachPrestartedVmToUser(map.getVmId(), vmPool.isStateful(), getReturnValue().getValidationMessages())) {
                return map.getVmId();
            }
        }
    }
    return Guid.Empty;
}
#method_after
private Guid getPrestartedVmToAttach(Guid vmPoolId) {
    List<VmPoolMap> vmPoolMaps = getVmPoolDao().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Up);
    if (vmPoolMaps != null) {
        for (VmPoolMap map : vmPoolMaps) {
            if (canAttachPrestartedVmToUser(map.getVmId(), getVmPool().isStateful(), getReturnValue().getValidationMessages())) {
                return map.getVmId();
            }
        }
    }
    return Guid.Empty;
}
#end_block

#method_before
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof Cluster) {
        return cloneCluster((Cluster) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStoragePool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    if (instance instanceof ClusterPolicy) {
        return cloneClusterPolicy((ClusterPolicy) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#method_after
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof Cluster) {
        return cloneCluster((Cluster) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStoragePool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    if (instance instanceof ClusterPolicy) {
        return cloneClusterPolicy((ClusterPolicy) instance);
    }
    // Throw exception to determine development needs.
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@OnTimerMethodAnnotation("managePrestartedVmsInAllVmPools")
public void managePrestartedVmsInAllVmPools() {
    List<VmPool> vmPools = DbFacade.getInstance().getVmPoolDao().getAll();
    for (VmPool vmPool : vmPools) {
        managePrestartedVmsInPool(vmPool);
    }
}
#method_after
@OnTimerMethodAnnotation("managePrestartedVmsInAllVmPools")
public void managePrestartedVmsInAllVmPools() {
    getAllVmPools().stream().filter(pool -> pool.getPrestartedVms() > 0).forEach(this::managePrestartedVmsInPool);
}
#end_block

#method_before
private void initDetachableFields() {
    detachableInstanceTypesEditor = new EntityModelDetachableWidgetWithLabel(instanceTypesEditor);
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    EnableableFormLabel rnglabel = new EnableableFormLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#method_after
private void initDetachableFields() {
    detachableInstanceTypesEditor = new EntityModelDetachableWidgetWithLabel(instanceTypesEditor);
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationPolicyEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationPolicyEditor, Align.IGNORE);
    overrideMigrationPolicyEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    EnableableFormLabel rnglabel = new EnableableFormLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    initThreadsPerCore();
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.timeZoneVm());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.asListBox().setVisibleItemCount(3);
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    initThreadsPerCore();
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.timeZoneVm());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.asListBox().setVisibleItemCount(3);
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    overrideMigrationPolicyEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationPolicyEditor = new ListModelListBoxOnlyEditor<>(new NameRenderer<MigrationPolicy>(), new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
    cpuPinningLabel.setStyleName(model.getCpuPinning().getIsChangable() ? style.labelToCoupleLabel() : style.labelToCoupleLabelDisabled());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            changeApplicationLevelVisibility(serialNumberPolicyEditor, true);
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            changeApplicationLevelVisibility(serialNumberPolicyEditor, true);
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
    object.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsChangable".equals(args.propertyName)) {
                // $NON-NLS-1$
                cpuPinningLabel.setStyleName(object.getCpuPinning().getIsChangable() ? style.labelToCoupleLabel() : style.labelToCoupleLabelDisabled());
            }
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, threadsPerCoreEditorWithInfoIcon, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, ioThreadsLabel, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, threadsPerCoreEditorWithInfoIcon, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, ioThreadsLabel, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable, overrideMigrationPolicyEditorWithDetachable);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__MOVE);
    addValidationMessage(EngineMessage.VAR__TYPE__VM_DISK);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__MOVE);
    addValidationMessage(EngineMessage.VAR__TYPE__DISK);
}
#end_block

#method_before
public void build() {
    Guid memoryDiskId = addMemoryDisk();
    Guid metadataDiskId = addMetadataDisk();
    // Have to query for the disks in order to get its imageId
    memoryDisk = getDisk(memoryDiskId);
    metadataDisk = getDisk(metadataDiskId);
}
#method_after
@Override
public void build() {
    Guid memoryDiskId = addMemoryDisk();
    Guid metadataDiskId = addMetadataDisk();
    // Have to query for the disks in order to get its imageId
    memoryDisk = getDisk(memoryDiskId);
    metadataDisk = getDisk(metadataDiskId);
}
#end_block

#method_before
private AddDiskParameters buildAddDiskParameters(DiskImage disk) {
    AddDiskParameters parameters = new AddDiskParameters(Guid.Empty, disk);
    parameters.setStorageDomainId(storageDomainId);
    parameters.setParentCommand(enclosingCommand.getActionType());
    parameters.setParentParameters(enclosingCommand.getParameters());
    parameters.setShouldBeLogged(false);
    return parameters;
}
#method_after
private AddDiskParameters buildAddDiskParameters(DiskImage disk) {
    AddDiskParameters parameters = new AddDiskParameters(disk);
    parameters.setStorageDomainId(storageDomainId);
    parameters.setParentCommand(enclosingCommand.getActionType());
    parameters.setParentParameters(enclosingCommand.getParameters());
    parameters.setShouldBeLogged(false);
    return parameters;
}
#end_block

#method_before
public String getVolumeStringRepresentation() {
    return MemoryUtils.createMemoryStateString(storageDomainId, storagePool.getId(), memoryDisk.getId(), memoryDisk.getImageId(), metadataDisk.getId(), metadataDisk.getImageId());
}
#method_after
@Override
public String getVolumeStringRepresentation() {
    return MemoryUtils.createMemoryStateString(storageDomainId, storagePool.getId(), memoryDisk.getId(), memoryDisk.getImageId(), metadataDisk.getId(), metadataDisk.getImageId());
}
#end_block

#method_before
public boolean isCreateTasks() {
    return true;
}
#method_after
@Override
public boolean isCreateTasks() {
    return true;
}
#end_block

#method_before
private CreateImagePlaceholderCommandParameters buildCreateImagePlacerholderParams() {
    CreateImagePlaceholderCommandParameters p = new CreateImagePlaceholderCommandParameters(getParameters().getStoragePoolId(), getParameters().getImageGroupID(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId());
    p.setParentCommand(getActionType());
    p.setParentParameters(getParameters());
    p.setShouldBeEndedByParent(false);
    return p;
}
#method_after
private CreateImagePlaceholderCommandParameters buildCreateImagePlacerholderParams() {
    CreateImagePlaceholderCommandParameters p = new CreateImagePlaceholderCommandParameters(getParameters().getStoragePoolId(), getParameters().getImageGroupID(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId());
    p.setParentCommand(getActionType());
    p.setParentParameters(getParameters());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return p;
}
#end_block

#method_before
public CommandCallback getCallback() {
    return new ConcurrentChildCommandsExecutionCallback();
}
#method_after
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    runInternalAction(VdcActionType.CreateImagePlaceholder, buildCreateImagePlacerholderParams(), ExecutionHandler.createInternalJobContext(getContext()));
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    runInternalAction(VdcActionType.CreateImagePlaceholder, buildCreateImagePlacerholderParams(), createStepsContext(StepEnum.CLONE_IMAGE_STRUCTURE));
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_PLACEHOLDER_CREATION) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_START);
        replicateDiskStart();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_START);
        syncImageData();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END);
        return true;
    }
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END) {
        completeLiveMigration();
        updateStage(LiveDiskMigrateStage.SOURCE_IMAGE_DELETION);
        removeImage(getParameters().getSourceStorageDomainId());
        return false;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_PLACEHOLDER_CREATION) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_DISK_START);
        replicateDiskStart();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_START);
        syncImageData();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END);
        return true;
    }
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_DISK_FINISH);
        completeLiveMigration();
        updateStage(LiveDiskMigrateStage.SOURCE_IMAGE_DELETION);
        LiveStorageMigrationHelper.removeImage(this, getParameters().getSourceStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE);
        return false;
    }
    return false;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // operation as successful.
    if (isConsiderSuccessful()) {
        auditLog(this, AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE);
        this.endSuccessfully();
        return;
    }
    super.endWithFailure();
    unlockDisk();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // operation as successful.
    if (isConsiderSuccessful()) {
        auditLog(this, AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE);
        this.endSuccessfully();
        return;
    }
    super.endWithFailure();
    handleDestDisk();
    unlockDisk();
    setSucceeded(true);
}
#end_block

#method_before
private void replicateDiskFinish(Guid srcDomain, Guid dstDomain) {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        log.error("VM '{}' is not running on any VDS, skipping VmReplicateDiskFinish", getParameters().getVmId());
        return;
    }
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), srcDomain, dstDomain, getParameters().getImageGroupID(), getParameters().getDestinationImageId());
    VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.VmReplicateDiskFinish, migrationStartParams);
    if (!ret.getSucceeded()) {
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#method_after
private void replicateDiskFinish(Guid srcDomain, Guid dstDomain) {
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), srcDomain, dstDomain, getParameters().getImageGroupID(), getParameters().getDestinationImageId());
    VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.VmReplicateDiskFinish, migrationStartParams);
    if (!ret.getSucceeded()) {
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#end_block

#method_before
private void syncImageData() {
    SyncImageGroupDataCommandParameters parameters = new SyncImageGroupDataCommandParameters(getParameters().getStoragePoolId(), getParameters().getImageGroupID(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId());
    parameters.setShouldBeEndedByParent(false);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    runInternalAction(VdcActionType.SyncImageGroupData, parameters);
}
#method_after
private void syncImageData() {
    SyncImageGroupDataCommandParameters parameters = new SyncImageGroupDataCommandParameters(getParameters().getStoragePoolId(), getParameters().getImageGroupID(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    runInternalAction(VdcActionType.SyncImageGroupData, parameters, createStepsContext(StepEnum.SYNC_IMAGE_DATA));
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    removeImage();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    setSucceeded(true);
}
#end_block

#method_before
private void initCommandBase() {
    initUser();
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext.getJob() != null) {
        setJobId(executionContext.getJob().getId());
    } else if (executionContext.getStep() != null) {
        setJobId(executionContext.getStep().getJobId());
    }
    setCorrelationId(_parameters.getCorrelationId());
}
#method_after
private void initCommandBase() {
    initUser();
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext.getJob() != null) {
        setJobId(executionContext.getJob().getId());
    } else if (executionContext.getStep() != null) {
        setJobId(executionContext.getStep().getJobId());
    }
    setCorrelationId(parameters.getCorrelationId());
}
#end_block

#method_before
public VdcReturnValueBase validateOnly() {
    setActionMessageParameters();
    getReturnValue().setValid(internalValidate());
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    return _returnValue;
}
#method_after
public VdcReturnValueBase validateOnly() {
    setActionMessageParameters();
    getReturnValue().setValid(internalValidate());
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    return returnValue;
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand(), getCallback() != null);
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#end_block

#method_before
private void cleanUpCompensationData() {
    if (!(getCompensationContext() instanceof NoOpCompensationContext)) {
        getBusinessEntitySnapshotDao().removeAllForCommandId(commandId);
    }
}
#method_after
private void cleanUpCompensationData() {
    getCompensationContext().resetCompensation();
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
private void setActionState() {
    // Currently it was decided that ROLLBACK_FLOW will cause endWithFailure
    if (isEndSuccessfully()) {
        _actionState = CommandActionState.END_SUCCESS;
    } else {
        _actionState = CommandActionState.END_FAILURE;
    }
}
#method_after
private void setActionState() {
    // Currently it was decided that ROLLBACK_FLOW will cause endWithFailure
    if (isEndSuccessfully()) {
        actionState = CommandActionState.END_SUCCESS;
    } else {
        actionState = CommandActionState.END_FAILURE;
    }
}
#end_block

#method_before
public void handleChildCommands() {
    if (getCallback() != null) {
        List<Guid> childCommands = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
        List<VdcActionParametersBase> parameters = new LinkedList<>();
        for (Guid id : childCommands) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(id);
            if (command.getParameters().getShouldBeEndedByParent()) {
                command.getParameters().setShouldBeEndedByParent(false);
                command.getParameters().setCommandType(command.getActionType());
                parameters.add(command.getParameters());
            }
        }
        getParameters().setImagesParameters(parameters);
    }
}
#method_after
public void handleChildCommands() {
    if (getCallback() != null) {
        List<Guid> childCommands = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
        List<VdcActionParametersBase> parameters = new LinkedList<>();
        for (Guid id : childCommands) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(id);
            if (command.getParameters().getEndProcedure() == EndProcedure.PARENT_MANAGED || command.getParameters().getEndProcedure() == EndProcedure.FLOW_MANAGED) {
                command.getParameters().setEndProcedure(EndProcedure.FLOW_MANAGED);
                command.getParameters().setCommandType(command.getActionType());
                parameters.add(command.getParameters());
            }
        }
        getParameters().setImagesParameters(parameters);
    }
}
#end_block

#method_before
private boolean handleCommandExecutionEnded() {
    boolean shouldEndAction = parentHasCallback() ? !getParameters().getShouldBeEndedByParent() : true;
    CommandStatus newStatus = isEndSuccessfully() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED;
    if (getCallback() == null) {
        setCommandStatus(newStatus);
        if (!shouldEndAction) {
            logEndWillBeExecutedByParent(newStatus);
        }
    }
    return shouldEndAction;
}
#method_after
private boolean handleCommandExecutionEnded() {
    boolean shouldEndAction = parentHasCallback() ? isEndProcedureApplicableToEndAction() : true;
    CommandStatus newStatus = isEndSuccessfully() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED;
    if (getCallback() == null) {
        setCommandStatus(newStatus);
        if (!shouldEndAction) {
            logEndWillBeExecutedByParent(newStatus);
        }
    }
    return shouldEndAction;
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
        persistCommandIfNeeded();
    }
}
#end_block

#method_before
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            _actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#method_after
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#end_block

#method_before
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#method_after
protected void logRollbackedTask() {
    String type = getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name();
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#end_block

#method_before
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
final public boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
public final boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : consumptionParameters) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, EngineMessage.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            consumptionParameters.stream().filter(parameter -> parameter.getQuotaGuid() != null).filter(parameter -> !Guid.Empty.equals(parameter.getQuotaGuid())).filter(parameter -> QuotaConsumptionParameter.QuotaAction.RELEASE != parameter.getQuotaAction()).map(parameter -> new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, EngineMessage.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA)).forEach(quotaPermissionList::add);
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            setCommandStatus(CommandStatus.FAILED);
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group ").append(permSubject.getActionGroup().name()).append(" with role type ").append(permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#method_after
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    permissionSubjects.stream().filter(permSubject -> permSubject.getObjectId() != null).forEach(permSubject -> {
        // Add comma when there are more than one entity affected.
        if (builder.length() != 0) {
            builder.append(", ");
        }
        builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
        if (permSubject.getActionGroup() != null) {
            builder.append("Action group ").append(permSubject.getActionGroup().name()).append(" with role type ").append(permSubject.getActionGroup().getRoleType().name());
        }
    });
    return builder;
}
#end_block

#method_before
@Override
public T getParameters() {
    return _parameters;
}
#method_after
@Override
public T getParameters() {
    return parameters;
}
#end_block

#method_before
public VdcReturnValueBase getReturnValue() {
    if (_returnValue == null) {
        _returnValue = createReturnValue();
    }
    return _returnValue;
}
#method_after
public VdcReturnValueBase getReturnValue() {
    if (returnValue == null) {
        returnValue = createReturnValue();
    }
    return returnValue;
}
#end_block

#method_before
public void setReturnValue(VdcReturnValueBase returnValue) {
    _returnValue = returnValue;
}
#method_after
public void setReturnValue(VdcReturnValueBase returnValue) {
    this.returnValue = returnValue;
}
#end_block

#method_before
protected String getDescription() {
    return _description;
}
#method_after
protected String getDescription() {
    return description;
}
#end_block

#method_before
protected void setDescription(String value) {
    _description = value;
}
#method_after
protected void setDescription(String value) {
    description = value;
}
#end_block

#method_before
private void processExceptionToClient(EngineFault fault) {
    fault.setSessionID(getParameters().getSessionId());
    _returnValue.getExecuteFailedMessages().add(fault.getError().name());
    _returnValue.setFault(fault);
}
#method_after
private void processExceptionToClient(EngineFault fault) {
    fault.setSessionID(getParameters().getSessionId());
    returnValue.getExecuteFailedMessages().add(fault.getError().name());
    returnValue.setFault(fault);
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        CommandCoordinatorUtil.startPollingTask(taskID);
    }
}
#method_after
public void startPollingAsyncTasks(Collection<Guid> taskIds) {
    taskIds.forEach(CommandCoordinatorUtil::startPollingTask);
}
#end_block

#method_before
protected LockProperties getLockProperties() {
    LockProperties lockProperties = _parameters.getLockProperties();
    if (lockProperties == null) {
        lockProperties = applyLockProperties(getLockingPropertiesSettings());
        _parameters.setLockProperties(lockProperties);
    }
    return lockProperties;
}
#method_after
protected LockProperties getLockProperties() {
    LockProperties lockProperties = parameters.getLockProperties();
    if (lockProperties == null) {
        lockProperties = applyLockProperties(getLockingPropertiesSettings());
        parameters.setLockProperties(lockProperties);
    }
    return lockProperties;
}
#end_block

#method_before
@Override
public Object runInTransaction() {
    if (_actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
    } else {
        endActionInTransactionScope();
    }
    return null;
}
#method_after
@Override
public Object runInTransaction() {
    if (actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
    } else {
        endActionInTransactionScope();
    }
    return null;
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addValidationMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        validationResult.getVariableReplacements().forEach(this::addValidationMessage);
    }
    return validationResult.isValid();
}
#end_block

#method_before
@Override
public void setCorrelationId(String correlationId) {
    // correlation ID thread local variable is set for non multi-action
    if (!_parameters.getMultipleAction()) {
        CorrelationIdTracker.setCorrelationId(correlationId);
    }
    super.setCorrelationId(correlationId);
}
#method_after
@Override
public void setCorrelationId(String correlationId) {
    // correlation ID thread local variable is set for non multi-action
    if (!parameters.getMultipleAction()) {
        CorrelationIdTracker.setCorrelationId(correlationId);
    }
    super.setCorrelationId(correlationId);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), false);
}
#method_after
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), getCallback() != null, callbackTriggeredByEvent());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback);
}
#method_after
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback, callbackTriggeredByEvent());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback, boolean callbackWaitingForEvent) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        commandEntity.setWaitingForEvent(callbackWaitingForEvent);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue());
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getSessionSeqId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandCoordinatorUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled()), getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandEntity executedCmdEntity = buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled());
            executedCmdEntity.setWaitingForEvent(cmdEntity.isCallbackEnabled() ? callbackTriggeredByEvent() : false);
            CommandCoordinatorUtil.persistCommand(executedCmdEntity, getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
protected VdcReturnValueBase runInternalActionWithTasksContext(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runInternalActionWithTasksContext(actionType, parameters, null);
}
#method_after
public VdcReturnValueBase runInternalActionWithTasksContext(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runInternalActionWithTasksContext(actionType, parameters, null);
}
#end_block

#method_before
protected CommandActionState getActionState() {
    return _actionState;
}
#method_after
protected CommandActionState getActionState() {
    return actionState;
}
#end_block

#method_before
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#method_after
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(VmUtils.getSnapshotMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getParameters().setSnapshotType(determineSnapshotType());
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    memoryImageBuilder.build();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    memoryImageBuilder.build();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
private CreateCinderSnapshotParameters buildChildCommandParameters(DiskImage cinderDisk) {
    CreateCinderSnapshotParameters createParams = new CreateCinderSnapshotParameters(((CinderDisk) getDiskDao().get(cinderDisk.getId())).getImageId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDescription(getParameters().getDescription());
    createParams.setSnapshotType(getParameters().getSnapshotType());
    return withRootCommandInfo(createParams);
}
#method_after
private CreateCinderSnapshotParameters buildChildCommandParameters(DiskImage cinderDisk) {
    CreateCinderSnapshotParameters createParams = new CreateCinderSnapshotParameters(((CinderDisk) getDiskDao().get(cinderDisk.getId())).getImageId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDescription(getParameters().getDescription());
    createParams.setSnapshotType(getParameters().getSnapshotType());
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    return createParams;
}
#end_block

#method_before
private boolean isMemorySnapshotSupported() {
    return FeatureSupported.memorySnapshot(getVm().getClusterCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getClusterCompatibilityVersion());
}
#method_after
private boolean isMemorySnapshotSupported() {
    return FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion());
}
#end_block

#method_before
protected boolean validateVM(VmValidator vmValidator) {
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getCompatibilityVersion(), getVds());
    return (getVm().isDown() || validate(validator.validateSnapshot())) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#method_after
protected boolean validateVM(VmValidator vmValidator) {
    return validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            CommandContext commandContext = ExecutionHandler.createInternalJobContext(cloneContextAndDetachFromParent());
            ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setShouldBeEndedByParent(false);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
            if (!vdcReturnValue.getSucceeded()) {
                ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
            }
            if (!parameters.getTaskGroupSuccess()) {
                ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                log.error("Failed LiveMigrateDisk (Disk '{}' , VM '{}')", parameters.getImageGroupID(), parameters.getVmId());
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!vdcReturnValue.getSucceeded()) {
                ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    return false;
}
#end_block

#method_before
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), "Auto-generated for Live Storage Migration");
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setShouldBeEndedByParent(false);
    return params;
}
#method_after
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), "Auto-generated for Live Storage Migration");
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__MOVE);
    addValidationMessage(EngineMessage.VAR__TYPE__VM_DISK);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__MOVE);
    addValidationMessage(EngineMessage.VAR__TYPE__DISK);
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
}
#end_block

#method_before
@Override
protected boolean validate() {
    setStoragePoolId(getVm().getStoragePoolId());
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getCompatibilityVersion(), getVds());
    if (!validate(validator.validateSnapshot())) {
        return false;
    }
    if (!isValidParametersList() || !checkImagesStatus() || !validateSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setValid(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().isValid()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !validateSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setValid(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().isValid()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean performStorageDomainsChecks(LiveMigrateDiskParameters parameters) {
    StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
    StorageDomain destDomain = getStorageDomainById(parameters.getTargetStorageDomainId(), getStoragePoolId());
    return validateSourceStorageDomain(sourceDomain) && validateDestStorage(destDomain) && (liveStorageMigrationSupportedBetweenDifferentStorageTypes() || validateDestStorageAndSourceStorageOfSameTypes(destDomain, sourceDomain));
}
#method_after
private boolean performStorageDomainsChecks(LiveMigrateDiskParameters parameters) {
    StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
    StorageDomain destDomain = getStorageDomainById(parameters.getTargetStorageDomainId(), getStoragePoolId());
    return validateSourceStorageDomain(sourceDomain) && validateDestStorage(destDomain);
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(final Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    Objects.requireNonNull(hosts);
    Objects.requireNonNull(cluster);
    if (hosts.size() < 2) {
        log.debug("No balancing for cluster '{}', contains only {} host(s)", cluster.getName(), hosts.size());
        return null;
    }
    final List<VDS> overUtilizedPrimaryHosts = getPrimarySources(cluster, hosts, parameters);
    final List<VDS> overUtilizedSecondaryHosts = getSecondarySources(cluster, hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if ((overUtilizedPrimaryHosts == null || overUtilizedPrimaryHosts.size() == 0) && (overUtilizedSecondaryHosts == null || overUtilizedSecondaryHosts.size() == 0)) {
        log.debug("There is no over-utilized host in cluster '{}'", cluster.getName());
        return null;
    }
    List<VDS> destinationHosts = null;
    VM vmToMigrate = null;
    FindVmAndDestinations findVmAndDestinations = getFindVmAndDestinations(cluster, parameters);
    // try balancing based on CPU first
    if (overUtilizedPrimaryHosts != null && overUtilizedPrimaryHosts.size() > 0) {
        // returns hosts with utilization lower than the specified threshold
        List<VDS> underUtilizedHosts = getPrimaryDestinations(cluster, hosts, parameters);
        /* if no host has a spare power, then there is nothing we can do to balance it here, try
               the secondary aporoach */
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All hosts are over-utilized, can't balance the cluster '{}' using the primary method", cluster.getName());
        } else {
            FindVmAndDestinations.Result result = findVmAndDestinations.invoke(overUtilizedPrimaryHosts, underUtilizedHosts, getVmDao());
            if (result != null) {
                destinationHosts = result.getDestinationHosts();
                vmToMigrate = result.getVmToMigrate();
            }
        }
    }
    // if it is not possible (or necessary) to balance based on CPU, try with memory
    if ((destinationHosts == null || destinationHosts.size() == 0 || vmToMigrate == null) && (overUtilizedSecondaryHosts != null && overUtilizedSecondaryHosts.size() > 0)) {
        // returns hosts with more free memory than the specified threshold
        List<VDS> underUtilizedHosts = getSecondaryDestinations(cluster, hosts, parameters);
        // if no host has memory to spare, then there is nothing we can do to balance it..
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All hosts are over-utilized, can't balance the cluster '{}' using the secondary method", cluster.getName());
            return null;
        }
        FindVmAndDestinations.Result result = findVmAndDestinations.invoke(overUtilizedSecondaryHosts, underUtilizedHosts, getVmDao());
        if (result != null) {
            destinationHosts = result.getDestinationHosts();
            vmToMigrate = result.getVmToMigrate();
        }
    }
    if (destinationHosts == null || destinationHosts.size() == 0 || vmToMigrate == null) {
        return null;
    }
    List<Guid> destinationHostsKeys = Entities.getIds(destinationHosts);
    return new Pair<>(destinationHostsKeys, vmToMigrate.getId());
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(final Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    Objects.requireNonNull(hosts);
    Objects.requireNonNull(cluster);
    if (hosts.size() < 2) {
        log.debug("No balancing for cluster '{}', contains only {} host(s)", cluster.getName(), hosts.size());
        return null;
    }
    final List<VDS> overUtilizedPrimaryHosts = getPrimarySources(cluster, hosts, parameters);
    final List<VDS> overUtilizedSecondaryHosts = getSecondarySources(cluster, hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if ((overUtilizedPrimaryHosts == null || overUtilizedPrimaryHosts.size() == 0) && (overUtilizedSecondaryHosts == null || overUtilizedSecondaryHosts.size() == 0)) {
        log.debug("There is no over-utilized host in cluster '{}'", cluster.getName());
        return null;
    }
    List<VDS> destinationHosts = null;
    VM vmToMigrate = null;
    FindVmAndDestinations findVmAndDestinations = getFindVmAndDestinations(cluster, parameters);
    // try balancing based on CPU first
    if (overUtilizedPrimaryHosts != null && overUtilizedPrimaryHosts.size() > 0) {
        // returns hosts with utilization lower than the specified threshold
        List<VDS> underUtilizedHosts = getPrimaryDestinations(cluster, hosts, parameters);
        /* if no host has a spare power, then there is nothing we can do to balance it here, try
               the secondary aporoach */
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All hosts are over-utilized, can't balance the cluster '{}' using the primary method", cluster.getName());
        } else {
            FindVmAndDestinations.Result result = findVmAndDestinations.invoke(overUtilizedPrimaryHosts, underUtilizedHosts, getVmDao());
            if (result != null) {
                destinationHosts = result.getDestinationHosts();
                vmToMigrate = result.getVmToMigrate();
            }
        }
    }
    // if it is not possible (or necessary) to balance based on CPU, try with memory
    if ((destinationHosts == null || destinationHosts.size() == 0 || vmToMigrate == null) && (overUtilizedSecondaryHosts != null && overUtilizedSecondaryHosts.size() > 0)) {
        // returns hosts with more free memory than the specified threshold
        List<VDS> underUtilizedHosts = getSecondaryDestinations(cluster, hosts, parameters);
        // if no host has memory to spare, then there is nothing we can do to balance it..
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All hosts are over-utilized, can't balance the cluster '{}' using the secondary method", cluster.getName());
            return null;
        }
        FindVmAndDestinations.Result result = findVmAndDestinations.invoke(overUtilizedSecondaryHosts, underUtilizedHosts, getVmDao());
        if (result != null) {
            destinationHosts = result.getDestinationHosts();
            vmToMigrate = result.getVmToMigrate();
        }
    }
    if (destinationHosts == null || destinationHosts.size() == 0 || vmToMigrate == null) {
        return null;
    }
    List<Guid> destinationHostsKeys = destinationHosts.stream().map(VDS::getId).collect(Collectors.toList());
    return new Pair<>(destinationHostsKeys, vmToMigrate.getId());
}
#end_block

#method_before
private List<Guid> findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, List<Guid>> hostCount = new HashMap<>();
    // Prepare affinity group related host counts
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        // Ignore stopped VMs
        if (host == null) {
            continue;
        }
        if (hostCount.containsKey(host)) {
            hostCount.get(host).add(vm);
        } else {
            hostCount.put(host, new ArrayList<>());
            hostCount.get(host).add(vm);
        }
    }
    // Select the host with the least amount of VMs
    Guid host = chooseCandidateHostForMigration(hostCount);
    if (host == null) {
        return null;
    }
    return hostCount.get(host);
}
#method_after
private List<Guid> findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, List<Guid>> hostCount = new HashMap<>();
    // Prepare affinity group related host counts
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        // Ignore stopped VMs
        if (host == null) {
            continue;
        }
        if (hostCount.containsKey(host)) {
            hostCount.get(host).add(vm);
        } else {
            hostCount.put(host, new ArrayList<>());
            hostCount.get(host).add(vm);
        }
    }
    // Select the host with the least amount of VMs
    Guid host = chooseCandidateHostForMigration(hostCount);
    if (host == null) {
        return Collections.emptyList();
    }
    return hostCount.get(host);
}
#end_block

#method_before
@Override
public void init() {
    super.init();
    OsTypeMockUtils.mockOsTypes();
    osRepository = control.createMock(OsRepository.class);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    Config.setConfigUtils(new VmMapperMockConfigUtils());
}
#method_after
@Override
public void init() {
    super.init();
    OsTypeMockUtils.mockOsTypes();
    osRepository = control.createMock(OsRepository.class);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Vm model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 0);
    Vm created = (Vm) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(0);
    setUpGetVirtioScsiExpectations(0);
    setUpGetSoundcardExpectations(0);
    setUpGetRngDeviceExpectations(0);
    setUpGetVmOvfExpectations(0);
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getClusterEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Vm model = getModel(0);
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 0);
    Vm created = (Vm) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Vm model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 0);
    assertNull(((Vm) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(0, 0);
    setUpGetVmOvfExpectations(0, 0);
    setUpGetVirtioScsiExpectations(0, 0);
    setUpGetSoundcardExpectations(0, 0);
    setUpGetRngDeviceExpectations(0, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getClusterEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Vm model = getModel(0);
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 0);
    assertNull(((Vm) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Vm model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 0);
}
#method_after
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(0, 0);
    setUpGetVmOvfExpectations(0, 0);
    setUpGetVirtioScsiExpectations(0, 0);
    setUpGetSoundcardExpectations(0, 0);
    setUpGetRngDeviceExpectations(0, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpCluster(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Vm model = getModel(0);
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 0);
}
#end_block

#method_before
private void doTestBadAddFromScratch(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    expect(osRepository.isBalloonEnabled(anyInt(), anyObject(Version.class))).andReturn(false).anyTimes();
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, canDo, success));
    Vm model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAddFromScratch(boolean valid, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    expect(osRepository.isBalloonEnabled(anyInt(), anyObject(Version.class))).andReturn(false).anyTimes();
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getClusterEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, valid, success));
    Vm model = getModel(0);
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(addMatrixParameterExpectations(setUpBasicUriExpectations(), BackendVmsResource.CLONE, "true"));
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(addMatrixParameterExpectations(setUpBasicUriExpectations(), BackendVmsResource.CLONE, "true"));
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(addMatrixParameterExpectations(setUpBasicUriExpectations(), BackendVmsResource.CLONE, "true"));
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(addMatrixParameterExpectations(setUpBasicUriExpectations(), BackendVmsResource.CLONE, "true"));
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    Vm returnValueVM = (Vm) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#method_after
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(2, 1);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    Vm returnValueVM = (Vm) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#end_block

#method_before
@Test
public void testAddPassTemplateByName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name", "DataCenterId" }, new Object[] { NAMES[1], GUIDS[3] }, getTemplateEntity(1));
    setupAddExpectations();
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Vm model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setName(NAMES[1].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testAddPassTemplateByName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name", "DataCenterId" }, new Object[] { NAMES[1], GUIDS[3] }, getTemplateEntity(1));
    setupAddExpectations();
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Vm model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
private void setupAddExpectations() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
}
#method_after
private void setupAddExpectations() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetVmOvfExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
}
#end_block

#method_before
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    setUpGetSoundcardExpectations(new int[] { 3 });
    setUpGetRngDeviceExpectations(new int[] { 3 });
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    Vm queriedVm = (Vm) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(3);
    setUpGetVmOvfExpectations(3);
    setUpGetVirtioScsiExpectations(3);
    setUpGetSoundcardExpectations(3);
    setUpGetRngDeviceExpectations(3);
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType(org.ovirt.engine.api.model.ConfigurationType.OVF);
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "ClusterId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    Vm queriedVm = (Vm) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2);
    setUpGetRngDeviceExpectations(2);
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType(org.ovirt.engine.api.model.ConfigurationType.OVF);
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "ClusterId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2);
    setUpGetRngDeviceExpectations(2);
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType(org.ovirt.engine.api.model.ConfigurationType.OVF);
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpCluster(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "ClusterId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
private void testBadAddFromConfiguration(boolean canDo, boolean success, String detail) throws Exception {
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUriInfo(setUpActionExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()) }, canDo, success));
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void testBadAddFromConfiguration(boolean valid, boolean success, String detail) throws Exception {
    Vm model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType(org.ovirt.engine.api.model.ConfigurationType.OVF);
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUriInfo(setUpActionExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "ClusterId" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()) }, valid, success));
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicyHostsNames() throws Exception {
    setUpAddVm();
    for (int i = 0; i < NAMES.length; i++) {
        setUpGetHostByNameExpectations(i);
    }
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Vm model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    Hosts hosts = new Hosts();
    for (int i = 0; i < NAMES.length; i++) {
        Host newHost = new Host();
        newHost.setName(NAMES[i].toString());
        hosts.getHosts().add(newHost);
    }
    model.getPlacementPolicy().setHosts(hosts);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicyHostsNames() throws Exception {
    setUpAddVm();
    for (int i = 0; i < NAMES.length; i++) {
        setUpGetHostByNameExpectations(i);
    }
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Vm model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    Hosts hosts = new Hosts();
    for (int i = 0; i < NAMES.length; i++) {
        Host newHost = new Host();
        newHost.setName(NAMES[i]);
        hosts.getHosts().add(newHost);
    }
    model.getPlacementPolicy().setHosts(hosts);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
private void setUpAddVm() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
}
#method_after
private void setUpAddVm() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Vm model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpCluster(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Vm model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(Vm model, boolean copy) throws Exception {
    UriInfo uriInfo = setUpBasicUriExpectations();
    uriInfo = addMatrixParameterExpectations(uriInfo, BackendVmsResource.CLONE_PERMISSIONS, Boolean.toString(copy));
    setUriInfo(uriInfo);
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(Vm model, boolean copy) throws Exception {
    UriInfo uriInfo = setUpBasicUriExpectations();
    uriInfo = addMatrixParameterExpectations(uriInfo, BackendVmsResource.CLONE_PERMISSIONS, Boolean.toString(copy));
    setUriInfo(uriInfo);
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(Vm model, boolean copy) throws Exception {
    UriInfo uriInfo = setUpBasicUriExpectations();
    Map<String, String> matrixParameters = new HashMap<>();
    matrixParameters.put(BackendVmsResource.CLONE, Boolean.toString(true));
    matrixParameters.put(BackendVmsResource.CLONE_PERMISSIONS, Boolean.toString(copy));
    uriInfo = addMatrixParameterExpectations(uriInfo, matrixParameters);
    setUriInfo(uriInfo);
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(Vm model, boolean copy) throws Exception {
    UriInfo uriInfo = setUpBasicUriExpectations();
    Map<String, String> matrixParameters = new HashMap<>();
    matrixParameters.put(BackendVmsResource.CLONE, Boolean.toString(true));
    matrixParameters.put(BackendVmsResource.CLONE_PERMISSIONS, Boolean.toString(copy));
    uriInfo = addMatrixParameterExpectations(uriInfo, matrixParameters);
    setUriInfo(uriInfo);
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Vm);
    verifyModel((Vm) response.getEntity(), 2);
}
#end_block

#method_before
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    setUpGetGraphicsMultipleExpectations(3);
    if (allContent) {
        List<String> populates = new ArrayList<>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    setUpGetGraphicsMultipleExpectations(3);
    if (allContent) {
        List<String> populates = new ArrayList<>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(0, 1, 2);
        setUpGetVmOvfExpectations(0, 1, 2);
        setUpGetVirtioScsiExpectations(0, 1, 2);
        setUpGetSoundcardExpectations(0, 1, 2);
        setUpGetRngDeviceExpectations(0, 1, 2);
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetGraphicsMultipleExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetGraphicsMultipleExpectations(3);
    setUpGetConsoleExpectations(0, 1, 2);
    setUpGetVmOvfExpectations(0, 1, 2);
    setUpGetVirtioScsiExpectations(0, 1, 2);
    setUpGetSoundcardExpectations(0, 1, 2);
    setUpGetRngDeviceExpectations(0, 1, 2);
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpGetSoundcardExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAdd(boolean valid, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpGetSoundcardExpectations(1);
    setUpGetRngDeviceExpectations(1);
    setUpEntityQueryExpectations(VdcQueryType.GetClusterByClusterId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getClusterEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, valid, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
// @Test
// public void testIsConsoleAddedInList() {
// 
// }
@Test
public void testAddIncompleteParameters() throws Exception {
    Vm model = new Vm();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Vm", "add", "cluster.id|name");
    }
}
#method_after
@Test
public void testAddIncompleteParameters() throws Exception {
    Vm model = new Vm();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Vm", "add", "cluster.id|name");
    }
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    entity.setId(vmId);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setVmDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setUsageMemPercent(20);
    entity.getGraphicsInfos().put(GraphicsType.VNC, new GraphicsInfo());
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    entity.setRunOnVdsName(NAMES[NAMES.length - 1]);
    entity.setOrigin(index == 0 ? OriginType.HOSTED_ENGINE : OriginType.OVIRT);
    entity.setBootSequence(null);
    entity.getStaticData().setSmallIconId(GUIDS[2]);
    entity.getStaticData().setLargeIconId(GUIDS[3]);
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    entity.setId(vmId);
    entity.setClusterId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setVmDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setUsageMemPercent(20);
    entity.getGraphicsInfos().put(GraphicsType.VNC, new GraphicsInfo());
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    entity.setRunOnVdsName(NAMES[NAMES.length - 1]);
    entity.setOrigin(index == 0 ? OriginType.HOSTED_ENGINE : OriginType.OVIRT);
    entity.setBootSequence(null);
    entity.getStaticData().setSmallIconId(GUIDS[2]);
    entity.getStaticData().setLargeIconId(GUIDS[3]);
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    entity.setId(GUIDS[index]);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setDefaultDisplayType(DisplayType.cirrus);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    entity.setId(GUIDS[index]);
    entity.setClusterId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setDefaultDisplayType(DisplayType.cirrus);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    return entity;
}
#end_block

#method_before
static Vm getModel(int index) {
    Vm model = new Vm();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[index].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#method_after
static Vm getModel(int index) {
    Vm model = new Vm();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[index].toString());
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#end_block

#method_before
@Override
protected void verifyModel(Vm model, int index) {
    super.verifyModel(model, index);
    verifyModelSpecific(model, index);
}
#method_after
@Override
protected void verifyModel(Vm model, int index) {
    super.verifyModel(model, index);
    verifyModelSpecific(model);
}
#end_block

#method_before
static void verifyModelSpecific(Vm model, int index) {
    assertNotNull(model.getCluster());
    assertNotNull(model.getCluster().getId());
    assertNotNull(model.getCpu());
    assertNotNull(model.getCpu().getTopology());
    assertEquals(4, model.getCpu().getTopology().getCores().intValue());
    assertEquals(2, model.getCpu().getTopology().getSockets().intValue());
    assertEquals(GUIDS[2].toString(), model.getSmallIcon().getId());
    assertEquals(GUIDS[3].toString(), model.getLargeIcon().getId());
}
#method_after
static void verifyModelSpecific(Vm model) {
    assertNotNull(model.getCluster());
    assertNotNull(model.getCluster().getId());
    assertNotNull(model.getCpu());
    assertNotNull(model.getCpu().getTopology());
    assertEquals(4, model.getCpu().getTopology().getCores().intValue());
    assertEquals(2, model.getCpu().getTopology().getSockets().intValue());
    assertEquals(GUIDS[2].toString(), model.getSmallIcon().getId());
    assertEquals(GUIDS[3].toString(), model.getLargeIcon().getId());
}
#end_block

#method_before
private Vm createModel(Disks disks) {
    Vm model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    if (disks != null) {
        model.setDisks(disks);
    }
    return model;
}
#method_after
private Vm createModel(Disks disks) {
    Vm model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new org.ovirt.engine.api.model.Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    if (disks != null) {
        model.setDisks(disks);
    }
    return model;
}
#end_block

#method_before
protected void setUpGetGraphicsMultipleExpectations(int times) throws Exception {
    Map<Guid, List<GraphicsDevice>> vmDevices = new HashMap<>();
    List<Guid> vmIds = new ArrayList<>();
    for (int i = 0; i < times; i++) {
        vmDevices.put(GUIDS[i], Arrays.asList(new GraphicsDevice(VmDeviceType.SPICE)));
        vmIds.add(GUIDS[i]);
    }
    setUpGetEntityExpectations(VdcQueryType.GetGraphicsDevicesMultiple, IdsQueryParameters.class, new String[] { "Ids" }, new Object[] { vmIds }, vmDevices);
}
#method_after
protected void setUpGetGraphicsMultipleExpectations(int times) throws Exception {
    Map<Guid, List<GraphicsDevice>> vmDevices = new HashMap<>();
    for (int i = 0; i < times; i++) {
        vmDevices.put(GUIDS[i], Arrays.asList(new GraphicsDevice(VmDeviceType.SPICE)));
    }
    setUpGetEntityExpectations(VdcQueryType.GetGraphicsDevicesMultiple, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, vmDevices);
}
#end_block

#method_before
protected void setUpGetGraphicsExpectations(int times) throws Exception {
    for (int i = 0; i < times; i++) {
        setUpGetEntityExpectations(VdcQueryType.GetGraphicsDevices, IdQueryParameters.class, new String[] {}, new Object[] {}, Arrays.asList(new GraphicsDevice(VmDeviceType.SPICE)));
    }
}
#method_after
protected void setUpGetGraphicsExpectations(int times) throws Exception {
    for (int i = 0; i < times; i++) {
        setUpGetEntityExpectations(VdcQueryType.GetGraphicsDevices, IdQueryParameters.class, new String[] {}, new Object[] {}, Collections.singletonList(new GraphicsDevice(VmDeviceType.SPICE)));
    }
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("is_using_scsi_reservation", entity.isUsingScsiReservation());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("is_using_scsi_reservation", entity.isUsingScsiReservation()).addValue("host_device", entity.getHostDevice());
}
#end_block

#method_before
@Override
public List<VmDevice> getVmDeviceByType(VmDeviceGeneralType type) {
    return getVmDeviceByType(type, null, false);
}
#method_after
@Override
public List<VmDevice> getVmDeviceByType(VmDeviceGeneralType type) {
    return getCallsHandler().executeReadList("GetVmDeviceByType", createEntityRowMapper(), getCustomMapSqlParameterSource().addValue("type", type.getValue()));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    vmDevice.setUsingScsiReservation(rs.getBoolean("is_using_scsi_reservation"));
    return vmDevice;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    vmDevice.setUsingScsiReservation(rs.getBoolean("is_using_scsi_reservation"));
    vmDevice.setHostDevice(rs.getString("host_device"));
    return vmDevice;
}
#end_block

#method_before
public static Map<Guid, List<GraphicsDevice>> getGraphicsDevicesForMultipleEntities(BackendResource backendResource, List<Guid> vmIds) {
    Map<Guid, List<GraphicsDevice>> graphicsDevices = backendResource.getEntity(Map.class, VdcQueryType.GetGraphicsDevicesMultiple, new IdsQueryParameters(vmIds), String.valueOf(vmIds.size()), true);
    return graphicsDevices;
}
#method_after
public static Map<Guid, List<GraphicsDevice>> getGraphicsDevicesForMultipleEntities(BackendResource backendResource, List<Guid> vmIds) {
    Map<Guid, List<GraphicsDevice>> graphicsDevices = backendResource.getEntity(Map.class, VdcQueryType.GetGraphicsDevicesMultiple, new IdsQueryParameters(vmIds), "GetGraphicsDevicesMultiple", true);
    return graphicsDevices;
}
#end_block

#method_before
public static void setGraphicsToParams(Display display, HasGraphicsDevices params) {
    if (display != null && display.isSetType()) {
        DisplayType newDisplayType = DisplayType.fromValue(display.getType());
        if (newDisplayType != null) {
            for (GraphicsType graphicsType : GraphicsType.values()) {
                // reset graphics devices
                params.getGraphicsDevices().put(graphicsType, null);
            }
            GraphicsType newGraphicsType = DisplayMapper.map(newDisplayType, null);
            params.getGraphicsDevices().put(newGraphicsType, new GraphicsDevice(newGraphicsType.getCorrespondingDeviceType()));
        }
    }
}
#method_after
public static void setGraphicsToParams(Display display, HasGraphicsDevices params) {
    if (display != null && display.isSetType()) {
        DisplayType newDisplayType = display.getType();
        if (newDisplayType != null) {
            for (GraphicsType graphicsType : GraphicsType.values()) {
                // reset graphics devices
                params.getGraphicsDevices().put(graphicsType, null);
            }
            GraphicsType newGraphicsType = DisplayMapper.map(newDisplayType, null);
            params.getGraphicsDevices().put(newGraphicsType, new GraphicsDevice(newGraphicsType.getCorrespondingDeviceType()));
        }
    }
}
#end_block

#method_before
private static void adjustDisplayDataInternal(BackendResource backendResource, BaseResource res, Map<Guid, List<GraphicsDevice>> vmsGraphicsDevices) {
    Display display = extractDisplayFromResource(res);
    if (display != null && !display.isSetType()) {
        List<GraphicsType> graphicsTypes = getGraphicsTypesForEntity(backendResource, new Guid(res.getId()), vmsGraphicsDevices);
        if (graphicsTypes.contains(GraphicsType.SPICE)) {
            display.setType(DisplayType.SPICE.value());
        } else if (graphicsTypes.contains(GraphicsType.VNC)) {
            display.setType(DisplayType.VNC.value());
        } else {
            resetDisplay(res);
        }
    }
}
#method_after
private static void adjustDisplayDataInternal(BackendResource backendResource, BaseResource res, Map<Guid, List<GraphicsDevice>> vmsGraphicsDevices) {
    Display display = extractDisplayFromResource(res);
    if (display != null && !display.isSetType()) {
        List<GraphicsType> graphicsTypes = getGraphicsTypesForEntity(backendResource, new Guid(res.getId()), vmsGraphicsDevices);
        if (graphicsTypes.contains(GraphicsType.SPICE)) {
            display.setType(DisplayType.SPICE);
        } else if (graphicsTypes.contains(GraphicsType.VNC)) {
            display.setType(DisplayType.VNC);
        } else {
            resetDisplay(res);
        }
    }
}
#end_block

#method_before
@Override
public Vms list() {
    if (isFiltered())
        return mapCollection(getBackendCollection(VdcQueryType.GetAllVms, new VdcQueryParametersBase(), SearchType.VM), true);
    else
        return mapCollection(getBackendCollection(SearchType.VM), false);
}
#method_after
@Override
public Vms list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllVms, new VdcQueryParametersBase(), SearchType.VM), true);
    } else {
        return mapCollection(getBackendCollection(SearchType.VM), false);
    }
}
#end_block

#method_before
@Override
public Response add(Vm vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(Vm.class, vm);
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            VDSGroup cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !Objects.equals(Objects.toString(template.getVdsGroupId(), null), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(Vm.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            boolean clone = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE, true, false);
            if (clone) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    Vm result = (Vm) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#method_after
@Override
public Response add(Vm vm) {
    validateParameters(vm, "cluster.id|name");
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Cluster cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !Objects.equals(Objects.toString(template.getClusterId(), null), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(Vm.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setClusterId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            boolean clone = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE, true, false);
            if (clone) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    Vm result = (Vm) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
public Response importVmFromConfiguration(Vm vm) {
    Initialization initialization = vm.getInitialization();
    Configuration config = initialization.getConfiguration();
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(ConfigurationType.fromValue(config.getType()), null), config.getData().trim()), "");
    VmMapper.map(vm, vmConfiguration.getStaticData());
    Guid clusterId = namedCluster(vm) ? getCluster(vm).getId() : asGuid(vm.getCluster().getId());
    ImportVmParameters parameters = new ImportVmParameters();
    parameters.setVm(vmConfiguration);
    parameters.setVdsGroupId(clusterId);
    if (initialization.isSetRegenerateIds()) {
        parameters.setImportAsNewEntity(initialization.isRegenerateIds());
    }
    return performCreate(VdcActionType.ImportVmFromConfiguration, parameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
public Response importVmFromConfiguration(Vm vm) {
    Initialization initialization = vm.getInitialization();
    Configuration config = initialization.getConfiguration();
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(config.getType(), null), config.getData().trim()), "");
    VmMapper.map(vm, vmConfiguration.getStaticData());
    Guid clusterId = namedCluster(vm) ? getCluster(vm).getId() : asGuid(vm.getCluster().getId());
    ImportVmParameters parameters = new ImportVmParameters();
    parameters.setVm(vmConfiguration);
    parameters.setClusterId(clusterId);
    if (initialization.isSetRegenerateIds()) {
        parameters.setImportAsNewEntity(initialization.isRegenerateIds());
    }
    return performCreate(VdcActionType.ImportVmFromConfiguration, parameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
private HashMap<Guid, DiskImage> getDiskImagesByIdMap(Collection<org.ovirt.engine.core.common.businessentities.storage.Disk> values) {
    HashMap<Guid, DiskImage> result = new HashMap<>();
    for (org.ovirt.engine.core.common.businessentities.storage.Disk diskImage : values) {
        result.put(((DiskImage) diskImage).getId(), (DiskImage) diskImage);
    }
    return result;
}
#method_after
private HashMap<Guid, DiskImage> getDiskImagesByIdMap(Collection<org.ovirt.engine.core.common.businessentities.storage.Disk> values) {
    HashMap<Guid, DiskImage> result = new HashMap<>();
    for (org.ovirt.engine.core.common.businessentities.storage.Disk diskImage : values) {
        result.put(diskImage.getId(), (DiskImage) diskImage);
    }
    return result;
}
#end_block

#method_before
private Response cloneVmFromTemplate(VmStatic staticVm, Vm vm, VmTemplate template, InstanceType instanceType, VDSGroup cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), template.getId()));
    params.setVmPayload(getPayload(vm));
    addDevicesToParams(params, vm, template, instanceType, staticVm.getOsId(), cluster);
    IconHelper.setIconToParams(vm, params);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
private Response cloneVmFromTemplate(VmStatic staticVm, Vm vm, VmTemplate template, InstanceType instanceType, Cluster cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), template.getId()));
    params.setVmPayload(getPayload(vm));
    addDevicesToParams(params, vm, template, instanceType, staticVm.getOsId(), cluster);
    IconHelper.setIconToParams(vm, params);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, int osId, VDSGroup cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(osId, cluster.getCompatibilityVersion()), templateId, instanceTypeId)) {
        // it is not defined on the template
        params.setBalloonEnabled(instanceTypeId != null ? !VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId) : null);
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setConsoleEnabled(instanceTypeId != null ? !getConsoleDevicesForEntity(instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        List<VmRngDevice> devices = VmHelper.getRngDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId);
        if (devices != null && !devices.isEmpty()) {
            boolean supported = cluster.getRequiredRngSources().contains(devices.get(0).getSource()) && FeatureSupported.virtIoRngSupported(cluster.getCompatibilityVersion());
            if (shouldCopyDevice(supported, templateId, instanceTypeId)) {
                params.setUpdateRngDevice(true);
                params.setRngDevice(!devices.isEmpty() ? devices.iterator().next() : null);
            }
        }
    }
}
#method_after
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, int osId, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(osId, cluster.getCompatibilityVersion()), templateId, instanceTypeId)) {
        // it is not defined on the template
        params.setBalloonEnabled(instanceTypeId != null ? !VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId) : null);
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setConsoleEnabled(instanceTypeId != null ? !getConsoleDevicesForEntity(instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        List<VmRngDevice> devices = VmHelper.getRngDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId);
        if (devices != null && !devices.isEmpty()) {
            boolean supported = cluster.getRequiredRngSources().contains(devices.get(0).getSource());
            if (shouldCopyDevice(supported, templateId, instanceTypeId)) {
                params.setUpdateRngDevice(true);
                params.setRngDevice(!devices.isEmpty() ? devices.iterator().next() : null);
            }
        }
    }
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, Vm vm, Guid storageDomainId, VmTemplate template, InstanceType instanceType, VDSGroup cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setVmPayload(getPayload(vm));
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), template.getId()));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(params);
    addDevicesToParams(params, vm, template, instanceType, staticVm.getOsId(), cluster);
    IconHelper.setIconToParams(vm, params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, Vm vm, Guid storageDomainId, VmTemplate template, InstanceType instanceType, Cluster cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setVmPayload(getPayload(vm));
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), template.getId()));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(params);
    addDevicesToParams(params, vm, template, instanceType, staticVm.getOsId(), cluster);
    IconHelper.setIconToParams(vm, params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
void setupCloneTemplatePermissions(VmManagementParametersBase params) {
    boolean clonePermissions = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyTemplatePermissions(clonePermissions);
    }
}
#method_after
void setupCloneTemplatePermissions(VmManagementParametersBase params) {
    boolean clonePermissions = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyTemplatePermissions(clonePermissions);
    }
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, Vm vm, InstanceType instanceType, VDSGroup cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setVmPayload(getPayload(vm));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    addDevicesToParams(params, vm, null, instanceType, staticVm.getOsId(), cluster);
    IconHelper.setIconToParams(vm, params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, Vm vm, InstanceType instanceType, Cluster cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setVmPayload(getPayload(vm));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    addDevicesToParams(params, vm, null, instanceType, staticVm.getOsId(), cluster);
    IconHelper.setIconToParams(vm, params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected Vms mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    boolean includeData = details.contains(DetailHelper.MAIN);
    boolean includeSize = details.contains("size");
    if (includeData) {
        // Fill VmInit for entities - the search query no join the VmInit to Vm
        IdsQueryParameters params = new IdsQueryParameters();
        List<Guid> ids = Entities.getIds(entities);
        params.setId(ids);
        VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
        if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
            List<VmInit> vmInits = queryReturnValue.getReturnValue();
            Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
            for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
                vm.setVmInit(initMap.get(vm.getId()));
            }
        }
    }
    Vms collection = new Vms();
    if (includeData) {
        // optimization of DB access: retrieve GraphicsDevices for all VMs at once
        Map<Guid, List<GraphicsDevice>> vmsGraphicsDevices = DisplayHelper.getGraphicsDevicesForMultipleEntities(this, Entities.getIds(entities));
        for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
            Vm vm = map(entity);
            DisplayHelper.adjustDisplayData(this, vm, vmsGraphicsDevices);
            removeRestrictedInfo(vm);
            collection.getVms().add(addLinks(populate(vm, entity)));
        }
    }
    if (includeSize) {
        collection.setSize((long) entities.size());
    }
    return collection;
}
#method_after
protected Vms mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    boolean includeData = details.contains(DetailHelper.MAIN);
    boolean includeSize = details.contains("size");
    List<Guid> vmIds = entities.stream().map(VM::getId).collect(Collectors.toList());
    if (includeData) {
        // Fill VmInit for entities - the search query no join the VmInit to Vm
        IdsQueryParameters params = new IdsQueryParameters();
        params.setId(vmIds);
        VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
        if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
            List<VmInit> vmInits = queryReturnValue.getReturnValue();
            Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
            for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
                vm.setVmInit(initMap.get(vm.getId()));
            }
        }
    }
    Vms collection = new Vms();
    if (includeData) {
        // optimization of DB access: retrieve GraphicsDevices for all VMs at once
        Map<Guid, List<GraphicsDevice>> vmsGraphicsDevices = DisplayHelper.getGraphicsDevicesForMultipleEntities(this, vmIds);
        for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
            Vm vm = map(entity);
            DisplayHelper.adjustDisplayData(this, vm, vmsGraphicsDevices);
            removeRestrictedInfo(vm);
            collection.getVms().add(addLinks(populate(vm, entity)));
        }
    }
    if (includeSize) {
        collection.setSize((long) entities.size());
    }
    return collection;
}
#end_block

#method_before
private VDSGroup lookupCluster(Guid id) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByVdsGroupId, new IdQueryParameters(id), "GetVdsGroupByVdsGroupId");
}
#method_after
private Cluster lookupCluster(Guid id) {
    return getEntity(Cluster.class, VdcQueryType.GetClusterByClusterId, new IdQueryParameters(id), "GetClusterByClusterId");
}
#end_block

#method_before
protected VDSGroup getCluster(Vm vm) {
    if (namedCluster(vm)) {
        return isFiltered() ? lookupClusterByName(vm.getCluster().getName()) : getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(vm.getCluster().getName()), "Cluster: name=" + vm.getCluster().getName());
    }
    return lookupCluster(asGuid(vm.getCluster().getId()));
}
#method_after
protected Cluster getCluster(Vm vm) {
    if (namedCluster(vm)) {
        return isFiltered() ? lookupClusterByName(vm.getCluster().getName()) : getEntity(Cluster.class, VdcQueryType.GetClusterByName, new NameQueryParameters(vm.getCluster().getName()), "Cluster: name=" + vm.getCluster().getName());
    }
    return lookupCluster(asGuid(vm.getCluster().getId()));
}
#end_block

#method_before
public VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "GetVdsGroupByName");
}
#method_after
public Cluster lookupClusterByName(String name) {
    return getEntity(Cluster.class, VdcQueryType.GetClusterByName, new NameQueryParameters(name), "GetClusterByName");
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Map<Guid, List<GraphicsDevice>> result = new HashMap<>();
    for (Guid id : getParameters().getIds()) {
        result.put(id, new ArrayList<GraphicsDevice>());
    }
    mapDevices(result, VmDeviceType.SPICE, getParameters().getIds());
    mapDevices(result, VmDeviceType.VNC, getParameters().getIds());
    setReturnValue(result);
}
#method_after
@Override
protected void executeQueryCommand() {
    Map<Guid, List<GraphicsDevice>> result = new HashMap<>();
    mapDevices(result, VmDeviceType.SPICE, getParameters().getIds());
    mapDevices(result, VmDeviceType.VNC, getParameters().getIds());
    setReturnValue(result);
}
#end_block

#method_before
private void mapDevices(Map<Guid, List<GraphicsDevice>> result, VmDeviceType type, List<Guid> vmIds) {
    log.debug("Retrieving graphics devices '{}' for '{}' vms", type.getName(), vmIds.size());
    List<VmDevice> devicesList = getDbFacade().getVmDeviceDao().getVmDeviceByType(VmDeviceGeneralType.GRAPHICS, getUserID(), getParameters().isFiltered());
    devicesList.stream().filter(device -> type.getName().equals(device.getDevice()) && vmIds.contains(device.getVmId())).forEach(device -> result.get(device.getVmId()).add(new GraphicsDevice(device)));
}
#method_after
private void mapDevices(Map<Guid, List<GraphicsDevice>> result, VmDeviceType type, List<Guid> vmsIds) {
    log.debug("Retrieving graphics devices '{}' for '{}' vms", type.getName(), vmsIds.size());
    List<VmDevice> devicesList = getDbFacade().getVmDeviceDao().getVmDeviceByTypeAndDevice(vmsIds, VmDeviceGeneralType.GRAPHICS, type.getName(), getUserID(), getParameters().isFiltered());
    for (VmDevice device : devicesList) {
        result.computeIfAbsent(device.getVmId(), guid -> new ArrayList<>()).add(new GraphicsDevice(device));
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    pollingRate = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds);
    schedulerUtil.scheduleAFixedDelayJob(this, "invokeCallbackMethods", new Class[] {}, new Object[] {}, pollingRate, pollingRate, TimeUnit.SECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    pollingRate = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds);
    initCommandExecutor();
    schedulerUtil.scheduleAFixedDelayJob(this, "invokeCallbackMethods", new Class[] {}, new Object[] {}, pollingRate, pollingRate, TimeUnit.SECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
private boolean endCallback(Guid cmdId, CommandCallback callback, CommandStatus status) {
    try {
        if (status == CommandStatus.FAILED) {
            callback.onFailed(cmdId, getChildCommandIds(cmdId));
        } else {
            callback.onSucceeded(cmdId, getChildCommandIds(cmdId));
        }
    } catch (Exception ex) {
        if (callback.repeatEndMethodsOnFail(cmdId)) {
            log.error("Failed invoking callback end method '{}' for command '{}' with exception '{}', the callback" + " is marked for end method retries", getCallbackMethod(status), cmdId, ex.getMessage());
            return true;
        } else {
            log.error("Failed invoking callback end method '{}' for command '{}' with exception '{}'", getCallbackMethod(status), cmdId, ex.getMessage());
        }
    }
    return false;
}
#method_after
private boolean endCallback(Guid cmdId, CommandCallback callback, CommandStatus status) {
    try {
        if (status == CommandStatus.FAILED) {
            callback.onFailed(cmdId, getChildCommandIds(cmdId));
        } else {
            callback.onSucceeded(cmdId, getChildCommandIds(cmdId));
        }
    } catch (Exception ex) {
        if (callback.shouldRepeatEndMethodsOnFail(cmdId)) {
            log.error("Failed invoking callback end method '{}' for command '{}' with exception '{}', the callback" + " is marked for end method retries", getCallbackMethod(status), cmdId, ex.getMessage());
            log.debug("Exception", ex);
            return true;
        }
        throw ex;
    }
    return false;
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    Iterator<Entry<Guid, CommandContainer>> iterator = commandsRepository.getCommandContainers().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandContainer> entry = iterator.next();
        // Decrement counter; execute if it reaches 0
        CommandContainer commandContainer = entry.getValue();
        commandContainer.setRemainingDelay(commandContainer.getRemainingDelay() - pollingRate);
        if (commandContainer.getRemainingDelay() > 0) {
            continue;
        }
        Guid cmdId = entry.getKey();
        CommandCallback callback = commandContainer.getCallback();
        CommandStatus status = commandsRepository.getCommandStatus(cmdId);
        boolean runCallbackAgain = false;
        try {
            switch(status) {
                case FAILED:
                case SUCCEEDED:
                    runCallbackAgain = endCallback(cmdId, callback, status);
                    break;
                case ACTIVE:
                    if (commandsRepository.getCommandEntity(cmdId).isExecuted()) {
                        pollCallback(cmdId, callback, status);
                    }
                    break;
                default:
                    break;
            }
        } finally {
            if (runCallbackAgain) {
                return;
            }
            if (CommandStatus.FAILED == status || CommandStatus.SUCCEEDED == status) {
                commandsRepository.updateCallbackNotified(cmdId);
                iterator.remove();
                CommandEntity cmdEntity = commandsRepository.getCommandEntity(entry.getKey());
                if (cmdEntity != null) {
                    // When a child finishes, its parent's callback should execute shortly thereafter
                    CommandContainer rootCmdContainer = commandsRepository.getCommandCallbackContainer(cmdEntity.getRootCommandId());
                    if (rootCmdContainer != null) {
                        rootCmdContainer.setInitialDelay(pollingRate);
                        rootCmdContainer.setRemainingDelay(pollingRate);
                    }
                }
            } else if (status != commandsRepository.getCommandStatus(cmdId)) {
                commandContainer.setInitialDelay(pollingRate);
                commandContainer.setRemainingDelay(pollingRate);
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                commandContainer.setInitialDelay(Math.min(maxDelay, commandContainer.getInitialDelay() * 2));
                commandContainer.setRemainingDelay(commandContainer.getInitialDelay());
            }
        }
    }
    commandsRepository.markExpiredCommandsAsFailure();
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    Iterator<Entry<Guid, CallbackTiming>> iterator = commandsRepository.getCallbacksTiming().entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CallbackTiming> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CallbackTiming callbackTiming = entry.getValue();
        CommandEntity commandEntity = commandsRepository.getCommandEntity(cmdId);
        if (commandEntity != null && updateCommandWaitingForEvent(commandEntity, callbackTiming)) {
            continue;
        } else {
            // Decrement counter; execute if it reaches 0
            callbackTiming.setRemainingDelay(callbackTiming.getRemainingDelay() - pollingRate);
            if (callbackTiming.getRemainingDelay() > 0) {
                continue;
            }
        }
        CommandCallback callback = callbackTiming.getCallback();
        CommandStatus status = commandsRepository.getCommandStatus(cmdId);
        boolean runCallbackAgain = false;
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                case SUCCEEDED:
                    runCallbackAgain = endCallback(cmdId, callback, status);
                    break;
                case ACTIVE:
                    if (commandEntity != null && commandEntity.isExecuted()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                case EXECUTION_FAILED:
                    if (callback.pollOnExecutionFailed()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if ((CommandStatus.FAILED == status || (CommandStatus.SUCCEEDED == status && !errorInCallback)) && !runCallbackAgain) {
                commandsRepository.updateCallbackNotified(cmdId);
                iterator.remove();
                CommandEntity cmdEntity = commandsRepository.getCommandEntity(entry.getKey());
                if (cmdEntity != null) {
                    // When a child finishes, its parent's callback should execute shortly thereafter
                    CallbackTiming rootCmdContainer = commandsRepository.getCallbackTiming(cmdEntity.getRootCommandId());
                    if (rootCmdContainer != null) {
                        rootCmdContainer.setInitialDelay(pollingRate);
                        rootCmdContainer.setRemainingDelay(pollingRate);
                    }
                }
            } else if (status != commandsRepository.getCommandStatus(cmdId)) {
                callbackTiming.setInitialDelay(pollingRate);
                callbackTiming.setRemainingDelay(pollingRate);
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                callbackTiming.setInitialDelay(Math.min(maxDelay, callbackTiming.getInitialDelay() * 2));
                callbackTiming.setRemainingDelay(callbackTiming.getInitialDelay());
            }
        }
    }
    commandsRepository.markExpiredCommandsAsFailure();
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : commandsRepository.getCommands(true)) {
            if (!cmdEntity.isExecuted() && cmdEntity.getCommandStatus() != CommandStatus.FAILED && cmdEntity.getCommandStatus() != CommandStatus.EXECUTION_FAILED) {
                commandsRepository.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.EXECUTION_FAILED);
            }
            if (!cmdEntity.isCallbackNotified()) {
                commandsRepository.addToCallbackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#method_after
private void initCommandExecutor() {
    for (CommandEntity cmdEntity : commandsRepository.getCommands(true)) {
        if (!cmdEntity.isExecuted() && cmdEntity.getCommandStatus() != CommandStatus.FAILED && cmdEntity.getCommandStatus() != CommandStatus.EXECUTION_FAILED) {
            CommandBase<?> failedCommand = commandsRepository.retrieveCommand(cmdEntity.getId());
            failedCommand.setCommandStatus(CommandStatus.EXECUTION_FAILED);
        }
        if (!cmdEntity.isCallbackNotified()) {
            commandsRepository.addToCallbackMap(cmdEntity);
        }
    }
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    // only.
    if (status != CommandExecutionStatus.EXECUTED && CommandCoordinatorUtil.getCommandStatus(cmdId) == CommandStatus.ACTIVE) {
        return;
    }
    boolean anyFailed = false;
    int completedChildren = 0;
    CommandBase<?> command = getCommand(cmdId);
    for (Guid childCmdId : childCmdIds) {
        CommandBase<?> child = getCommand(childCmdId);
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case NOT_STARTED:
            case ACTIVE:
                logWaitingForChildCommand(child, command);
                return;
            case FAILED:
            case EXECUTION_FAILED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
                anyFailed = true;
                break;
            case ENDED_WITH_FAILURE:
            case UNKNOWN:
                anyFailed = true;
                break;
            case SUCCEEDED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
            default:
                ++completedChildren;
        }
    }
    childCommandsExecutionEnded(command, anyFailed, childCmdIds, status, completedChildren);
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    // only.
    if (status != CommandExecutionStatus.EXECUTED && CommandCoordinatorUtil.getCommandStatus(cmdId) == CommandStatus.ACTIVE) {
        return;
    }
    boolean anyFailed = false;
    int completedChildren = 0;
    CommandBase<?> command = getCommand(cmdId);
    for (Guid childCmdId : childCmdIds) {
        CommandBase<?> child = getCommand(childCmdId);
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case NOT_STARTED:
            case ACTIVE:
            case EXECUTION_FAILED:
                logWaitingForChildCommand(child, command);
                return;
            case FAILED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
                anyFailed = true;
                break;
            case ENDED_WITH_FAILURE:
            case UNKNOWN:
                anyFailed = true;
                break;
            case SUCCEEDED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
            default:
                ++completedChildren;
        }
    }
    childCommandsExecutionEnded(command, anyFailed, childCmdIds, status, completedChildren);
}
#end_block

#method_before
private boolean shouldCommandEndOnAsyncOpEnd(CommandBase<?> cmd) {
    return cmd.getParameters().getEndProcedure() == EndProcedure.ASYNC_OPERATIONS_END;
}
#method_after
private boolean shouldCommandEndOnAsyncOpEnd(CommandBase<?> cmd) {
    return cmd.getParameters().getEndProcedure() == EndProcedure.COMMAND_MANAGED;
}
#end_block

#method_before
private void endAction(CommandBase<?> commandBase, List<Guid> childCmdIds, boolean succeeded) {
    if (shouldExecuteEndMethod(commandBase)) {
        VdcReturnValueBase returnVal = commandBase.endAction();
        if (!commandBase.getReturnValue().getSucceeded() && repeatEndMethodsOnFail(returnVal)) {
            if (repeatEndMethodsOnFail(returnVal)) {
                throw new EngineException(EngineError.ENGINE, String.format("Command %1$s id: '%2$s' endAction() " + "didn't complete successfully", commandBase.getActionType(), commandBase.getCommandId()));
            } else {
                log.info("Command '{}' id: '{}' end method execution failed, as the command isn't marked for " + "endAction() retries silently ignoring", commandBase.getActionType(), commandBase.getCommandId());
            }
        }
        if (commandBase.getParameters().getParentCommand() == VdcActionType.Unknown) {
            CommandCoordinatorUtil.removeAllCommandsInHierarchy(commandBase.getCommandId());
        }
        ExecutionHandler.endJob(commandBase.getExecutionContext(), succeeded);
    }
}
#method_after
private void endAction(CommandBase<?> commandBase, List<Guid> childCmdIds, boolean succeeded) {
    if (shouldExecuteEndMethod(commandBase)) {
        VdcReturnValueBase returnVal = commandBase.endAction();
        if (!returnVal.getSucceeded() && shouldRepeatEndMethodsOnFail(returnVal)) {
            if (shouldRepeatEndMethodsOnFail(returnVal)) {
                throw new EngineException(EngineError.ENGINE, String.format("Command %1$s id: '%2$s' endAction() " + "didn't complete successfully", commandBase.getActionType(), commandBase.getCommandId()));
            } else {
                log.warn("Command '{}' id: '{}' end method execution failed, as the command isn't marked for " + "endAction() retries silently ignoring", commandBase.getActionType(), commandBase.getCommandId());
            }
        }
        if (commandBase.getParameters().getParentCommand() == VdcActionType.Unknown) {
            CommandCoordinatorUtil.removeAllCommandsInHierarchy(commandBase.getCommandId());
        }
        ExecutionHandler.endJob(commandBase.getExecutionContext(), succeeded);
    }
}
#end_block

#method_before
protected RunVmFlow getFlow() {
    if (cachedFlow != null) {
        return cachedFlow;
    }
    switch(getVm().getStatus()) {
        case Paused:
            return setFlow(RunVmFlow.RESUME_PAUSE);
        case Suspended:
            return setFlow(RunVmFlow.RESUME_HIBERNATE);
        default:
    }
    if (isRunAsStateless()) {
        fetchVmDisksFromDb();
        if (getVm().getDiskList().isEmpty()) {
            // If there are no snappable disks, there is no meaning for
            // running as stateless, log a warning and run normally
            warnIfNotAllDisksPermitSnapshots();
            return setFlow(RunVmFlow.RUN);
        }
        return setFlow(RunVmFlow.CREATE_STATELESS_IMAGES);
    }
    if (!isInternalExecution() && isStatelessSnapshotExistsForVm() && !isVmPartOfManualPool()) {
        return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
    }
    return setFlow(RunVmFlow.RUN);
}
#method_after
protected RunVmFlow getFlow() {
    if (cachedFlow != null) {
        return cachedFlow;
    }
    switch(getVm().getStatus()) {
        case Paused:
            return setFlow(RunVmFlow.RESUME_PAUSE);
        case Suspended:
            return setFlow(RunVmFlow.RESUME_HIBERNATE);
        default:
    }
    if (isRunAsStateless()) {
        fetchVmDisksFromDb();
        if (getVm().getDiskList().isEmpty()) {
            // If there are no snappable disks, there is no meaning for
            // running as stateless, log a warning and run normally
            warnIfNotAllDisksPermitSnapshots();
            return setFlow(RunVmFlow.RUN);
        }
        if (isStatelessSnapshotExistsForVm()) {
            log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
            return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
        }
        return setFlow(RunVmFlow.CREATE_STATELESS_IMAGES);
    }
    if (!isInternalExecution() && isStatelessSnapshotExistsForVm() && !isVmPartOfManualPool()) {
        return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
    }
    return setFlow(RunVmFlow.RUN);
}
#end_block

#method_before
protected void perform() {
    switch(getFlow()) {
        case RESUME_PAUSE:
            resumeVm();
            break;
        case REMOVE_STATELESS_IMAGES:
            removeVmStatlessImages();
            break;
        case CREATE_STATELESS_IMAGES:
            statelessVmTreatment();
            break;
        case RESUME_HIBERNATE:
        case RUN:
        default:
            runVm();
    }
}
#method_after
protected void perform() {
    switch(getFlow()) {
        case RESUME_PAUSE:
            resumeVm();
            break;
        case REMOVE_STATELESS_IMAGES:
            removeVmStatlessImages();
            break;
        case CREATE_STATELESS_IMAGES:
            createVmStatelessImages();
            break;
        case RESUME_HIBERNATE:
        case RUN:
        default:
            runVm();
    }
}
#end_block

#method_before
private CreateAllSnapshotsFromVmParameters buildCreateSnapshotParametersForEndAction() {
    CreateAllSnapshotsFromVmParameters parameters = buildCreateSnapshotParameters();
    parameters.setImagesParameters(getParameters().getImagesParameters());
    if (getParameters().isUseCinderCommandCallback()) {
        parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
        parameters.setCommandId(getParametersForChildCommand().get(0).getCommandId());
    }
    return parameters;
}
#method_after
private CreateAllSnapshotsFromVmParameters buildCreateSnapshotParametersForEndAction() {
    CreateAllSnapshotsFromVmParameters parameters = buildCreateSnapshotParameters();
    parameters.setImagesParameters(getParameters().getImagesParameters());
    if (getParameters().isUseCinderCommandCallback()) {
        parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        parameters.setCommandId(getParametersForChildCommand().get(0).getCommandId());
    }
    return parameters;
}
#end_block

#method_before
private ImagesContainterParametersBase getCinderDiskSnapshotParameter(CinderDisk cinderDisk) {
    ImagesContainterParametersBase removeCinderSnapshotParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    removeCinderSnapshotParams.setDestinationImageId(cinderDisk.getImageId());
    removeCinderSnapshotParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    removeCinderSnapshotParams.setParentCommand(getActionType());
    removeCinderSnapshotParams.setParentParameters(getParameters());
    removeCinderSnapshotParams.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return removeCinderSnapshotParams;
}
#method_after
private ImagesContainterParametersBase getCinderDiskSnapshotParameter(CinderDisk cinderDisk) {
    ImagesContainterParametersBase removeCinderSnapshotParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    removeCinderSnapshotParams.setDestinationImageId(cinderDisk.getImageId());
    removeCinderSnapshotParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    removeCinderSnapshotParams.setParentCommand(getActionType());
    removeCinderSnapshotParams.setParentParameters(getParameters());
    removeCinderSnapshotParams.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return removeCinderSnapshotParams;
}
#end_block

#method_before
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = getCinderDisks();
        if (cinderDisks.isEmpty()) {
            return Collections.emptyList();
        }
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#method_after
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = getCinderDisks();
        if (cinderDisks.isEmpty()) {
            return Collections.emptyList();
        }
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#end_block

#method_before
private boolean isHostInSupportedClusterForProxyHost(VDS host) {
    return FeatureSupported.importVmFromExternalProvider(host.getClusterCompatibilityVersion()) && getClusterDao().get(host.getClusterId()).getArchitecture() != ArchitectureType.ppc64;
}
#method_after
private boolean isHostInSupportedClusterForProxyHost(VDS host) {
    return getClusterDao().get(host.getClusterId()).getArchitecture() != ArchitectureType.ppc64;
}
#end_block

#method_before
@Override
protected void processImages() {
    ArrayList<Guid> diskIds = new ArrayList<>();
    for (DiskImage image : getVm().getImages()) {
        Guid diskId = createDisk(image);
        diskIds.add(diskId);
    }
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#method_after
@Override
protected void processImages() {
    if (getVm().getOrigin() == OriginType.KVM && !getVm().getImages().isEmpty()) {
        getVm().getImages().get(0).setBoot(true);
    }
    ArrayList<Guid> diskIds = new ArrayList<>();
    for (DiskImage image : getVm().getImages()) {
        Guid diskId = createDisk(image);
        diskIds.add(diskId);
    }
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#end_block

#method_before
private Guid createDisk(DiskImage image) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    image.setDiskInterface(DiskInterface.VirtIO);
    AddDiskParameters diskParameters = new AddDiskParameters(getVmId(), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new EngineException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#method_after
private Guid createDisk(DiskImage image) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    image.setDiskInterface(DiskInterface.VirtIO);
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new EngineException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#end_block

#method_before
private ConvertVmParameters buildConvertVmParameters() {
    ConvertVmParameters parameters = new ConvertVmParameters(getVmId());
    parameters.setUrl(getParameters().getUrl());
    parameters.setUsername(getParameters().getUsername());
    parameters.setPassword(getParameters().getPassword());
    parameters.setVmName(getVmName());
    parameters.setOriginType(getVm().getOrigin());
    parameters.setDisks(getDisks());
    parameters.setStoragePoolId(getStoragePoolId());
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setProxyHostId(getParameters().getProxyHostId());
    parameters.setClusterId(getClusterId());
    parameters.setVirtioIsoName(getParameters().getVirtioIsoName());
    parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return parameters;
}
#method_after
private ConvertVmParameters buildConvertVmParameters() {
    ConvertVmParameters parameters = new ConvertVmParameters(getVmId());
    parameters.setUrl(getParameters().getUrl());
    parameters.setUsername(getParameters().getUsername());
    parameters.setPassword(getParameters().getPassword());
    parameters.setVmName(getVmName());
    parameters.setOriginType(getVm().getOrigin());
    parameters.setDisks(getDisks());
    parameters.setStoragePoolId(getStoragePoolId());
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setProxyHostId(getParameters().getProxyHostId());
    parameters.setClusterId(getClusterId());
    parameters.setVirtioIsoName(getParameters().getVirtioIsoName());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    for (CinderDisk cinderDisk : getParameters().getCinderDisksToRestore()) {
        ImagesContainterParametersBase params = getRestoreFromSnapshotParams(cinderDisk);
        restoreCinderDisk(cinderDisk, params);
        // In case we want to undo the previewed snapshot.
        if (getParameters().getSnapshot().getType() == Snapshot.SnapshotType.STATELESS) {
            Guid activeSnapshotId = getSnapshotDao().get(getParameters().getVmId(), Snapshot.SnapshotType.ACTIVE).getId();
            updateCinderDiskSnapshot(cinderDisk.getId(), activeSnapshotId, cinderDisk.getVmSnapshotId());
        } else if (getParameters().getSnapshot().getType() != Snapshot.SnapshotType.REGULAR) {
            updateCinderDiskSnapshot(cinderDisk.getId(), getParameters().getSnapshot().getId(), null);
        }
    }
    List<CinderDisk> cinderDisksToRemove = getParameters().getCinderDisksToRemove();
    for (CinderDisk cinderDisk : cinderDisksToRemove) {
        RemoveCinderDiskParameters removeDiskParam = new RemoveCinderDiskParameters(cinderDisk.getImageId());
        removeDiskParam.setRemovedVolume(cinderDisk);
        removeDiskParam.setParentCommand(getActionType());
        removeDiskParam.setStorageDomainId(cinderDisk.getStorageIds().get(0));
        removeDiskParam.setParentParameters(getParameters());
        removeDiskParam.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, removeDiskParam, cloneContextAndDetachFromParent());
        try {
            future.get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
            log.error("Error removing Cinder disk");
        }
    }
    List<CinderDisk> cinderVolumesToRemove = getParameters().getCinderVolumesToRemove();
    for (CinderDisk cinderVolume : cinderVolumesToRemove) {
        RemoveCinderDiskVolumeParameters removeDiskVolumeParam = new RemoveCinderDiskVolumeParameters(cinderVolume);
        removeDiskVolumeParam.setParentCommand(getActionType());
        removeDiskVolumeParam.setParentParameters(getParameters());
        removeDiskVolumeParam.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDiskVolume, removeDiskVolumeParam, cloneContextAndDetachFromParent());
        try {
            future.get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
            log.error("Error removing Cinder disk");
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    for (CinderDisk cinderDisk : getParameters().getCinderDisksToRestore()) {
        ImagesContainterParametersBase params = getRestoreFromSnapshotParams(cinderDisk);
        restoreCinderDisk(cinderDisk, params);
        // In case we want to undo the previewed snapshot.
        if (getParameters().getSnapshot().getType() == Snapshot.SnapshotType.STATELESS) {
            Guid activeSnapshotId = getSnapshotDao().get(getParameters().getVmId(), Snapshot.SnapshotType.ACTIVE).getId();
            updateCinderDiskSnapshot(cinderDisk.getId(), activeSnapshotId, cinderDisk.getVmSnapshotId());
        } else if (getParameters().getSnapshot().getType() != Snapshot.SnapshotType.REGULAR) {
            updateCinderDiskSnapshot(cinderDisk.getId(), getParameters().getSnapshot().getId(), null);
        }
    }
    List<CinderDisk> cinderDisksToRemove = getParameters().getCinderDisksToRemove();
    for (CinderDisk cinderDisk : cinderDisksToRemove) {
        RemoveCinderDiskParameters removeDiskParam = new RemoveCinderDiskParameters(cinderDisk.getImageId());
        removeDiskParam.setRemovedVolume(cinderDisk);
        removeDiskParam.setParentCommand(getActionType());
        removeDiskParam.setStorageDomainId(cinderDisk.getStorageIds().get(0));
        removeDiskParam.setParentParameters(getParameters());
        removeDiskParam.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, removeDiskParam, cloneContextAndDetachFromParent());
        try {
            future.get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
            log.error("Error removing Cinder disk");
        }
    }
    List<CinderDisk> cinderVolumesToRemove = getParameters().getCinderVolumesToRemove();
    for (CinderDisk cinderVolume : cinderVolumesToRemove) {
        RemoveCinderDiskVolumeParameters removeDiskVolumeParam = new RemoveCinderDiskVolumeParameters(cinderVolume);
        removeDiskVolumeParam.setParentCommand(getActionType());
        removeDiskVolumeParam.setParentParameters(getParameters());
        removeDiskVolumeParam.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDiskVolume, removeDiskVolumeParam, cloneContextAndDetachFromParent());
        try {
            future.get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
            log.error("Error removing Cinder disk");
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private ProcessOvfUpdateForStorageDomainCommandParameters createProcessOvfUpdateForDomainParams() {
    ProcessOvfUpdateForStorageDomainCommandParameters params = new ProcessOvfUpdateForStorageDomainCommandParameters(getStoragePoolId(), getStorageDomainId());
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSkipDomainChecks(true);
    params.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return params;
}
#method_after
private ProcessOvfUpdateForStorageDomainCommandParameters createProcessOvfUpdateForDomainParams() {
    ProcessOvfUpdateForStorageDomainCommandParameters params = new ProcessOvfUpdateForStorageDomainCommandParameters(getStoragePoolId(), getStorageDomainId());
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSkipDomainChecks(true);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        uploadStreamParameters.setParentCommand(getActionType());
        uploadStreamParameters.setParentParameters(getParameters());
        uploadStreamParameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            return true;
        }
    } catch (EngineException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#method_after
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        uploadStreamParameters.setParentCommand(getActionType());
        uploadStreamParameters.setParentParameters(getParameters());
        uploadStreamParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            return true;
        }
    } catch (EngineException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#end_block

#method_before
public CreateOvfVolumeForStorageDomainCommandParameters createCreateOvfVolumeForStorageDomainParams() {
    CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return parameters;
}
#method_after
public CreateOvfVolumeForStorageDomainCommandParameters createCreateOvfVolumeForStorageDomainParams() {
    CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    DiskSnapshotsValidator diskSnapshotsValidator = createDiskSnapshotsValidator(getImages());
    if (!validate(diskSnapshotsValidator.diskSnapshotsNotExist(getParameters().getImageIds())) || !validate(diskSnapshotsValidator.diskImagesBelongToSameImageGroup()) || !validate(diskSnapshotsValidator.imagesAreSnapshots())) {
        return false;
    }
    // Validate all chain of images in the disk
    if (!validateAllDiskImages()) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(getImages());
    if (!validate(diskImagesValidator.diskImagesSnapshotsNotAttachedToOtherVms(false))) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (isDiskPlugged()) {
        VmValidator vmValidator = createVmValidator(getVm());
        if (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) {
            return false;
        }
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateStorageDomainActive()) {
        return false;
    }
    if (!validateStorageDomainAvailableSpace()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    DiskSnapshotsValidator diskSnapshotsValidator = createDiskSnapshotsValidator(getImages());
    if (!validate(diskSnapshotsValidator.diskSnapshotsNotExist(getParameters().getImageIds())) || !validate(diskSnapshotsValidator.diskImagesBelongToSameImageGroup()) || !validate(diskSnapshotsValidator.imagesAreSnapshots())) {
        return false;
    }
    // Validate all chain of images in the disk
    if (!validateAllDiskImages()) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(getImages());
    if (!validate(diskImagesValidator.diskImagesSnapshotsNotAttachedToOtherVms(false))) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (isDiskPlugged()) {
        VmValidator vmValidator = createVmValidator(getVm());
        if (!validate(vmValidator.vmQualifiedForSnapshotMerge())) {
            return false;
        }
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateStorageDomainActive()) {
        return false;
    }
    if (!validateStorageDomainAvailableSpace()) {
        return false;
    }
    return true;
}
#end_block

#method_before
public void startNextLiveMerge(int completedChildren) {
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
}
#method_after
public void startNextLiveMerge(int completedChildren) {
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
}
#end_block

#method_before
private RemoveAllVmCinderDisksParameters buildRemoveCinderSnapshotDiskParameters(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = new RemoveAllVmCinderDisksParameters();
    params.setCinderDisks(cinderDisks);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSessionId(getParameters().getSessionId());
    params.setInvokeEndActionOnParent(false);
    params.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return params;
}
#method_after
private RemoveAllVmCinderDisksParameters buildRemoveCinderSnapshotDiskParameters(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = new RemoveAllVmCinderDisksParameters();
    params.setCinderDisks(cinderDisks);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSessionId(getParameters().getSessionId());
    params.setInvokeEndActionOnParent(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
protected MacPoolManagerStrategy getMacPool() {
    if (macPool == null) {
        macPool = poolPerDc.poolForDataCenter(getStoragePoolId());
    }
    return macPool;
}
#method_after
protected MacPool getMacPool() {
    if (macPool == null) {
        macPool = poolPerDc.poolForDataCenter(getStoragePoolId());
    }
    return macPool;
}
#end_block

#method_before
private void addVmsToPool(Guid poolId) {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddVmAndAttachToPool, buildAddVmAndAttachToPoolParameters(poolId, currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getValidationMessages().isEmpty()) {
            for (String msg : returnValue.getValidationMessages()) {
                if (!getReturnValue().getValidationMessages().contains(msg)) {
                    getReturnValue().getValidationMessages().add(msg);
                }
            }
            addVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that , reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
            vmsAdded = true;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            AuditLogableBase logable = new AuditLogableBase();
            auditLogDirector.log(logable, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#method_after
private void addVmsToPool(Guid poolId) {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddVm, buildAddVmParameters(poolId, currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getValidationMessages().isEmpty()) {
            for (String msg : returnValue.getValidationMessages()) {
                if (!getReturnValue().getValidationMessages().contains(msg)) {
                    getReturnValue().getValidationMessages().add(msg);
                }
            }
            addVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that , reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
            vmsAdded = true;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            AuditLogableBase logable = new AuditLogableBase();
            auditLogDirector.log(logable, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator(Collections.singletonList((DiskImage) getOldDisk())).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validate(diskValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk())) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator(Collections.singletonList((DiskImage) getOldDisk())).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validate(diskValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) disk;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk disk = getDiskDao().get(getParameters().getDiskInfo().getId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) disk;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#end_block

#method_before
private VdcActionParametersBase buildExtendCinderDiskParameters(CinderDisk newCinderDisk) {
    UpdateVmDiskParameters parameters = new UpdateVmDiskParameters(getVmId(), newCinderDisk.getId(), newCinderDisk);
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return parameters;
}
#method_after
private VdcActionParametersBase buildExtendCinderDiskParameters(CinderDisk newCinderDisk) {
    VmDiskOperationParameterBase parameters = new VmDiskOperationParameterBase(new DiskVmElement(newCinderDisk.getId(), getVmId()), newCinderDisk);
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
protected Disk getOldDisk() {
    if (oldDisk == null) {
        oldDisk = getDiskDao().get(getParameters().getDiskId());
    }
    return oldDisk;
}
#method_after
protected Disk getOldDisk() {
    if (oldDisk == null && getParameters().getDiskInfo() != null) {
        oldDisk = getDiskDao().get(getParameters().getDiskInfo().getId());
    }
    return oldDisk;
}
#end_block

#method_before
private RestoreAllCinderSnapshotsParameters buildCinderChildCommandParameters(List<CinderDisk> cinderDisksToRestore, List<CinderDisk> cinderDisksToRemove, List<CinderDisk> cinderVolumesToRemove, Guid removedSnapshotId) {
    RestoreAllCinderSnapshotsParameters restoreParams = new RestoreAllCinderSnapshotsParameters(getVmId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove);
    restoreParams.setRemovedSnapshotId(removedSnapshotId);
    restoreParams.setSnapshot(getSnapshot());
    restoreParams.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    restoreParams.setParentCommand(getActionType());
    restoreParams.setParentParameters(getParameters());
    restoreParams.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return withRootCommandInfo(restoreParams);
}
#method_after
private RestoreAllCinderSnapshotsParameters buildCinderChildCommandParameters(List<CinderDisk> cinderDisksToRestore, List<CinderDisk> cinderDisksToRemove, List<CinderDisk> cinderVolumesToRemove, Guid removedSnapshotId) {
    RestoreAllCinderSnapshotsParameters restoreParams = new RestoreAllCinderSnapshotsParameters(getVmId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove);
    restoreParams.setRemovedSnapshotId(removedSnapshotId);
    restoreParams.setSnapshot(getSnapshot());
    restoreParams.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    restoreParams.setParentCommand(getActionType());
    restoreParams.setParentParameters(getParameters());
    restoreParams.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return withRootCommandInfo(restoreParams);
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand(), getCallback() != null);
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void endStepsAndJobIfNeeded() {
    // TODO: getEndActionTryAgain() isn't supported currently by the coco infrastructure
    boolean endActionWillRunAgain = !getSucceeded() && getReturnValue().getEndActionTryAgain();
    if (endActionWillRunAgain) {
        return;
    }
    boolean succeeded = getSucceeded() && getParameters().getTaskGroupSuccess();
    // TODO: We should support also Commands with callbacks that has steps
    if (getCallback() == null) {
        ExecutionHandler.endFinalizingStepAndCurrentStep(getContext().getExecutionContext(), succeeded);
    }
    if (!parentHasCallback()) {
        ExecutionHandler.endTaskJobIfNeeded(getContext().getExecutionContext(), getSucceeded() && getParameters().getTaskGroupSuccess());
    }
}
#method_after
private void endStepsAndJobIfNeeded() {
    // TODO: getEndActionTryAgain() isn't supported currently by the coco infrastructure
    boolean endActionWillRunAgain = !getSucceeded() && getReturnValue().getEndActionTryAgain();
    if (endActionWillRunAgain) {
        return;
    }
    boolean succeeded = getSucceeded() && getParameters().getTaskGroupSuccess();
    ExecutionHandler.endFinalizingStepAndCurrentStep(getContext().getExecutionContext(), succeeded);
    if (!parentHasCallback()) {
        ExecutionHandler.endTaskJobIfNeeded(getContext().getExecutionContext(), getSucceeded() && getParameters().getTaskGroupSuccess());
    }
}
#end_block

#method_before
public void handleChildCommands() {
    if (getCallback() != null) {
        List<Guid> childCommands = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
        List<VdcActionParametersBase> parameters = new LinkedList<>();
        for (Guid id : childCommands) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(id);
            if (command.getParameters().getEndProcedure() == EndProcedure.BY_PARENT || command.getParameters().getEndProcedure() == EndProcedure.PARENT_MANAGED) {
                command.getParameters().setEndProcedure(EndProcedure.PARENT_MANAGED);
                command.getParameters().setCommandType(command.getActionType());
                parameters.add(command.getParameters());
            }
        }
        getParameters().setImagesParameters(parameters);
    }
}
#method_after
public void handleChildCommands() {
    if (getCallback() != null) {
        List<Guid> childCommands = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
        List<VdcActionParametersBase> parameters = new LinkedList<>();
        for (Guid id : childCommands) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(id);
            if (command.getParameters().getEndProcedure() == EndProcedure.PARENT_MANAGED || command.getParameters().getEndProcedure() == EndProcedure.FLOW_MANAGED) {
                command.getParameters().setEndProcedure(EndProcedure.FLOW_MANAGED);
                command.getParameters().setCommandType(command.getActionType());
                parameters.add(command.getParameters());
            }
        }
        getParameters().setImagesParameters(parameters);
    }
}
#end_block

#method_before
private boolean isEndProcedureApplicableToEndAction() {
    return getParameters().getEndProcedure() == EndProcedure.PARENT_MANAGED || getParameters().getEndProcedure() == EndProcedure.ASYNC_OPERATIONS_END;
}
#method_after
private boolean isEndProcedureApplicableToEndAction() {
    return getParameters().getEndProcedure() == EndProcedure.FLOW_MANAGED || getParameters().getEndProcedure() == EndProcedure.COMMAND_MANAGED;
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), false);
}
#method_after
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), getCallback() != null, callbackTriggeredByEvent());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback);
}
#method_after
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback, callbackTriggeredByEvent());
}
#end_block

#method_before
private void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand(), getContext(), getCallback() != null);
    }
}
#method_after
private void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback, boolean callbackWaitingForEvent) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        commandEntity.setWaitingForEvent(callbackWaitingForEvent);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getSessionSeqId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandCoordinatorUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled()), getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandEntity executedCmdEntity = buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled());
            executedCmdEntity.setWaitingForEvent(cmdEntity.isCallbackEnabled() ? callbackTriggeredByEvent() : false);
            CommandCoordinatorUtil.persistCommand(executedCmdEntity, getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    // only.
    if (status != CommandExecutionStatus.EXECUTED && CommandCoordinatorUtil.getCommandStatus(cmdId) == CommandStatus.ACTIVE) {
        return;
    }
    boolean anyFailed = false;
    int completedChildren = 0;
    CommandBase<?> command = getCommand(cmdId);
    for (Guid childCmdId : childCmdIds) {
        CommandBase<?> child = getCommand(childCmdId);
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case NOT_STARTED:
            case ACTIVE:
                logWaitingForChildCommand(child, command);
                return;
            case FAILED:
            case EXECUTION_FAILED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
                anyFailed = true;
                break;
            case ENDED_WITH_FAILURE:
            case UNKNOWN:
                anyFailed = true;
                break;
            case SUCCEEDED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
            default:
                ++completedChildren;
        }
    }
    childCommandsExecutionEnded(command, anyFailed, childCmdIds, status, completedChildren);
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    // only.
    if (status != CommandExecutionStatus.EXECUTED && CommandCoordinatorUtil.getCommandStatus(cmdId) == CommandStatus.ACTIVE) {
        return;
    }
    boolean anyFailed = false;
    int completedChildren = 0;
    CommandBase<?> command = getCommand(cmdId);
    for (Guid childCmdId : childCmdIds) {
        CommandBase<?> child = getCommand(childCmdId);
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case NOT_STARTED:
            case ACTIVE:
            case EXECUTION_FAILED:
                logWaitingForChildCommand(child, command);
                return;
            case FAILED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
                anyFailed = true;
                break;
            case ENDED_WITH_FAILURE:
            case UNKNOWN:
                anyFailed = true;
                break;
            case SUCCEEDED:
                if (shouldWaitForEndMethodsCompletion(child, command)) {
                    return;
                }
            default:
                ++completedChildren;
        }
    }
    childCommandsExecutionEnded(command, anyFailed, childCmdIds, status, completedChildren);
}
#end_block

#method_before
private boolean shouldCommandEndOnAsyncOpEnd(CommandBase<?> cmd) {
    return cmd.getParameters().getEndProcedure() == EndProcedure.ASYNC_OPERATIONS_END;
}
#method_after
private boolean shouldCommandEndOnAsyncOpEnd(CommandBase<?> cmd) {
    return cmd.getParameters().getEndProcedure() == EndProcedure.COMMAND_MANAGED;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (vdcReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            params.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent());
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#method_after
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (vdcReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent());
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#end_block

#method_before
private RemoveCinderDiskParameters buildChildCommandParameters(CinderDisk cinderDisk) {
    RemoveCinderDiskParameters removeDiskParams = new RemoveCinderDiskParameters(cinderDisk.getId());
    removeDiskParams.setParentCommand(getActionType());
    removeDiskParams.setParentParameters(getParameters());
    removeDiskParams.setShouldBeLogged(false);
    removeDiskParams.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return removeDiskParams;
}
#method_after
private RemoveCinderDiskParameters buildChildCommandParameters(CinderDisk cinderDisk) {
    RemoveCinderDiskParameters removeDiskParams = new RemoveCinderDiskParameters(cinderDisk.getId());
    removeDiskParams.setParentCommand(getActionType());
    removeDiskParams.setParentParameters(getParameters());
    removeDiskParams.setShouldBeLogged(false);
    removeDiskParams.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return removeDiskParams;
}
#end_block

#method_before
private RemoveCinderDiskVolumeParameters createChildParams(CinderDisk cinderDiskVolume) {
    RemoveCinderDiskVolumeParameters childParam = new RemoveCinderDiskVolumeParameters(cinderDiskVolume);
    childParam.setParentCommand(getActionType());
    childParam.setParentParameters(getParameters());
    childParam.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return childParam;
}
#method_after
private RemoveCinderDiskVolumeParameters createChildParams(CinderDisk cinderDiskVolume) {
    RemoveCinderDiskVolumeParameters childParam = new RemoveCinderDiskVolumeParameters(cinderDiskVolume);
    childParam.setParentCommand(getActionType());
    childParam.setParentParameters(getParameters());
    childParam.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return childParam;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!getVm().isDown()) {
        if (!getVm().isQualifiedForSnapshotMerge()) {
            log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
            throw new EngineException(EngineError.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
        } else if (getVm().getRunOnVds() == null || !getVdsDao().get(getVm().getRunOnVds()).getLiveMergeSupport()) {
            log.error("Cannot remove VM snapshot. The host on which VM is running does not support Live Merge");
            throw new EngineException(EngineError.VM_HOST_CANNOT_LIVE_MERGE);
        }
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
        if (!snapshotHasImages) {
            // no async tasks - ending command manually
            endVmCommand();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!getVm().isDown() && !getVm().isQualifiedForSnapshotMerge()) {
        log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
        throw new EngineException(EngineError.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
        if (!snapshotHasImages) {
            // no async tasks - ending command manually
            endVmCommand();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private void handleCinderSnapshotDisks(List<CinderDisk> cinderDisks) {
    for (CinderDisk cinderDisk : cinderDisks) {
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderSnapshotDisk, buildRemoveCinderSnapshotDiskParameters(cinderDisk), cloneContextAndDetachFromParent());
        try {
            VdcReturnValueBase vdcReturnValueBase = future.get();
            if (!vdcReturnValueBase.getSucceeded()) {
                log.error("Error removing snapshots for Cinder disk");
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error removing snapshots for Cinder disk");
        }
    }
}
#method_after
private void handleCinderSnapshotDisks(List<CinderDisk> cinderDisks) {
    for (CinderDisk cinderDisk : cinderDisks) {
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.RemoveCinderSnapshotDisk, buildRemoveCinderSnapshotDiskParameters(cinderDisk), cloneContextAndDetachFromParent());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error removing snapshots for Cinder disk");
        }
    }
}
#end_block

#method_before
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(getSnapshotActionType());
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    return parameters;
}
#method_after
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(getSnapshotActionType());
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setEndProcedure(getVm().isQualifiedForLiveSnapshotMerge() ? EndProcedure.COMMAND_MANAGED : EndProcedure.PARENT_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge())) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateStorageDomains() {
    List<DiskImage> disksList = getSnapshotsDummiesForStorageAllocations();
    MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), getStorageDomainsIds());
    return validate(storageDomainsValidator.allDomainsExistAndActive()) && validate(storageDomainsValidator.allDomainsWithinThresholds()) && validate(storageDomainsValidator.allDomainsHaveSpaceForClonedDisks(disksList));
}
#method_after
protected boolean validateStorageDomains() {
    List<DiskImage> disksList = getDisksListForStorageAllocations();
    MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), getStorageDomainsIds());
    return validate(storageDomainsValidator.allDomainsExistAndActive()) && validate(storageDomainsValidator.allDomainsWithinThresholds()) && validate(storageDomainsValidator.allDomainsHaveSpaceForClonedDisks(disksList));
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    if (getVm().isQualifiedForLiveSnapshotMerge()) {
        return new RemoveSnapshotCommandCallback();
    } else if (getParameters().isUseCinderCommandCallback()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#method_after
@Override
public CommandCallback getCallback() {
    if (getVm().isQualifiedForLiveSnapshotMerge() || getParameters().isUseCinderCommandCallback()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && !validate(new VmValidator(getVm()).isVmExists()) && !validateDiskVmData()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = (LunDisk) getParameters().getDiskInfo();
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = (LunDisk) getParameters().getDiskInfo();
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(validate(new VmValidator(getVm()).vmNotLocked()) && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected LUNs getLunDisk(final LUNs lun, VDS vds) {
    List<LUNs> luns = executeGetDeviceList(vds.getId(), lun.getLunType(), lun.getLUNId());
    // Retrieve LUN from the device list.
    return luns.stream().filter(o -> o.getId().equals(lun.getId())).findFirst().orElse(null);
}
#method_after
protected LUNs getLunDisk(final LUNs lun, VDS vds) {
    return executeGetDeviceList(vds.getId(), lun.getLunType(), lun.getLUNId()).stream().findFirst().orElse(null);
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = (getParameters().isSkipDomainCheck() || validate(storageDomainValidator.isDomainExistAndActive())) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = (getParameters().isSkipDomainCheck() || validate(storageDomainValidator.isDomainExistAndActive())) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && validate(new VmValidator(getVm()).vmNotLocked()) && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects;
    if (getParameters().getVmId() == null || Guid.Empty.equals(getParameters().getVmId())) {
        listPermissionSubjects = new ArrayList<>();
    } else {
        listPermissionSubjects = super.getPermissionCheckSubjects();
    }
    // In order to do that we need CREATE_DISK permissions on System level
    if (getParameters().getStorageDomainId() == null || Guid.Empty.equals(getParameters().getStorageDomainId())) {
        listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CREATE_DISK));
        if (getParameters().getDiskInfo().getSgio() == ScsiGenericIO.UNFILTERED) {
            listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CONFIGURE_SCSI_GENERIC_IO));
        }
    } else {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return listPermissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects;
    if (isFloatingDisk()) {
        listPermissionSubjects = new ArrayList<>();
    } else {
        listPermissionSubjects = super.getPermissionCheckSubjects();
    }
    // In order to do that we need CREATE_DISK permissions on System level
    if (getParameters().getStorageDomainId() == null || Guid.Empty.equals(getParameters().getStorageDomainId())) {
        listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CREATE_DISK));
        if (getParameters().getDiskInfo().getSgio() == ScsiGenericIO.UNFILTERED) {
            listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CONFIGURE_SCSI_GENERIC_IO));
        }
    } else {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return listPermissionSubjects;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getParameters().getDiskInfo().setId(Guid.newGuid());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
    }
}
#method_after
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
    }
}
#end_block

#method_before
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters();
    parameters.setDiskInfo(getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setVmId(getParameters().getVmId());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.ASYNC_OPERATIONS_END);
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
    }
    return parameters;
}
#method_after
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
    }
    return parameters;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getDiskInfo().isBoot() && getParameters().getVmId() != null && !Guid.Empty.equals(getParameters().getVmId())) {
        return Collections.singletonMap(getParameters().getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_DISK_BOOT, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getDiskInfo().isBoot() && !isFloatingDisk()) {
        return Collections.singletonMap(getParameters().getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_DISK_BOOT, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#end_block

#method_before
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(getVmId(), getParameters().getDiskInfo().getId());
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#method_after
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        VmDiskOperationParameterBase params = new VmDiskOperationParameterBase(new DiskVmElement(getParameters().getDiskInfo().getId(), getVmId()));
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = getOsRepository().getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    } else if ("sata".equals(cdInterface)) {
        // SATA slot 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        } else if ("sata".equals(cdInterface)) {
            // SATA slot 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, false, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    // translate error enums to text
                    result.setExceptionMessage(getAppErrorsTranslator().translateErrorTextSingle(result.getExceptionString()));
                    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                    logger.log(Level.WARNING, "Failure while invoking runQuery [" + result.getExceptionString() + ", " + result.getExceptionMessage() + "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        handleNotLoggedInEvent(result.getExceptionString());
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                fireAsyncQuerySucceededEvent(callback.getModel());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                fireAsyncQueryFailedEvent(callback.getModel());
            }
        }
    });
    // raise the query started event.
    fireAsyncOperationStartedEvent(callback.getModel());
    getOperationManager().addOperation(operation);
}
#method_after
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<>(queryType, parameters, isPublic, false, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    // translate error enums to text
                    result.setExceptionMessage(getAppErrorsTranslator().translateErrorTextSingle(result.getExceptionString()));
                    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                    logger.log(Level.WARNING, "Failure while invoking runQuery [" + result.getExceptionString() + ", " + result.getExceptionMessage() + "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<>();
                        failedResult.add(result);
                        handleNotLoggedInEvent(result.getExceptionString());
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                fireAsyncQuerySucceededEvent(callback.getModel());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                fireAsyncQueryFailedEvent(callback.getModel());
            }
        }
    });
    // raise the query started event.
    fireAsyncOperationStartedEvent(callback.getModel());
    getOperationManager().addOperation(operation);
}
#end_block

#method_before
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            fireAsyncQuerySucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                fireAsyncQueryFailedEvent(state);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, true, multiCallback));
    }
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            fireAsyncQuerySucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                fireAsyncQueryFailedEvent(state);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, true, multiCallback));
    }
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperationList(operationList);
}
#end_block

#method_before
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed runAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
            fireAsyncActionSucceededEvent(state);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
            fireAsyncActionFailedEvent(state);
        }
    });
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperation(operation);
}
#method_after
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed runAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
            fireAsyncActionSucceededEvent(state);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
            fireAsyncActionFailedEvent(state);
        }
    });
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperation(operation);
}
#end_block

#method_before
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    runMultipleAction(actionType, parameters, isRunOnlyIfAllCanDoPass, callback, state, true, false);
}
#method_after
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllValidationPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    runMultipleAction(actionType, parameters, isRunOnlyIfAllValidationPass, callback, state, true, false);
}
#end_block

#method_before
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state, final boolean showErrorDialog, final boolean waitForResult) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (showErrorDialog && !failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
            fireAsyncActionSucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
            fireAsyncActionFailedEvent(state);
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, !waitForResult, multiCallback);
        operationList.add(operation);
    }
    fireAsyncOperationStartedEvent(state);
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (callback != null) {
                    List<VdcReturnValueBase> emptyResult = new ArrayList<VdcReturnValueBase>();
                    callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
                }
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#method_after
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllValidationPass, final IFrontendMultipleActionAsyncCallback callback, final Object state, final boolean showErrorDialog, final boolean waitForResult) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.isValid()) {
                    failed.add(v);
                }
            }
            if (showErrorDialog && !failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
            fireAsyncActionSucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
            fireAsyncActionFailedEvent(state);
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<>(actionType, parameter, !waitForResult, multiCallback);
        operationList.add(operation);
    }
    fireAsyncOperationStartedEvent(state);
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (callback != null) {
                    List<VdcReturnValueBase> emptyResult = new ArrayList<>();
                    callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
                }
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#end_block

#method_before
private void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final boolean aggregateErrors, final List<VdcActionType> failedActions, final List<VdcReturnValueBase> failedReturnValues) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        if (aggregateErrors && failedReturnValues != null && !failedReturnValues.isEmpty()) {
            getEventsHandler().runMultipleActionsFailed(failedActions, failedReturnValues);
        }
        return;
    }
    runAction(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                if (aggregateErrors && returnValue != null && (!returnValue.getCanDoAction() || !returnValue.getSucceeded())) {
                    failedActions.add(actionTypes.get(0));
                    failedReturnValues.add(returnValue);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, failedActions, failedReturnValues);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, !aggregateErrors || failureCallback != null);
}
#method_after
private void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final boolean aggregateErrors, final List<VdcActionType> failedActions, final List<VdcReturnValueBase> failedReturnValues) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        if (aggregateErrors && failedReturnValues != null && !failedReturnValues.isEmpty()) {
            getEventsHandler().runMultipleActionsFailed(failedActions, failedReturnValues);
        }
        return;
    }
    runAction(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                if (aggregateErrors && returnValue != null && (!returnValue.isValid() || !returnValue.getSucceeded())) {
                    failedActions.add(actionTypes.get(0));
                    failedReturnValues.add(returnValue);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, failedActions, failedReturnValues);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, !aggregateErrors || failureCallback != null);
}
#end_block

#method_before
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean failedOnCanDoAction = !result.getCanDoAction();
    if (failedOnCanDoAction) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
    } else if (!result.getSucceeded()) {
        EngineFault fault = result.getFault();
        String message = result.getExecuteFailedMessages().size() > 1 ? translateExecuteFailedMessages(result.getExecuteFailedMessages()) : translateEngineFault(fault);
        fault.setMessage(message);
        if (showErrorDialog && result.getIsSyncronious() && getEventsHandler() != null) {
            getEventsHandler().runActionExecutionFailed(actionType, fault);
        }
    }
    callback.executed(f);
    // only needed for canDoAction failure
    if (showErrorDialog && failedOnCanDoAction && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        ArrayList<String> messages = result.getCanDoActionMessages();
        failureEventHandler(result.getDescription(), // $NON-NLS-1$
        messages.isEmpty() ? Collections.singletonList(getConstants().noCanDoActionMessage()) : messages);
    }
}
#method_after
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean failedOnValidate = !result.isValid();
    if (failedOnValidate) {
        result.setValidationMessages((ArrayList<String>) translateError(result));
    } else if (!result.getSucceeded()) {
        EngineFault fault = result.getFault();
        String message = result.getExecuteFailedMessages().size() > 1 ? translateExecuteFailedMessages(result.getExecuteFailedMessages()) : translateEngineFault(fault);
        fault.setMessage(message);
        if (showErrorDialog && result.getIsSyncronious() && getEventsHandler() != null) {
            getEventsHandler().runActionExecutionFailed(actionType, fault);
        }
    }
    callback.executed(f);
    // only needed for validate failure
    if (showErrorDialog && failedOnValidate && (getEventsHandler() != null) && getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault())) {
        ArrayList<String> messages = result.getValidationMessages();
        failureEventHandler(result.getDescription(), // $NON-NLS-1$
        messages.isEmpty() ? Collections.singletonList(getConstants().noValidateMessage()) : messages);
    }
}
#end_block

#method_before
public ErrorTranslator getAppErrorsTranslator() {
    return canDoActionErrorsTranslator;
}
#method_after
public ErrorTranslator getAppErrorsTranslator() {
    return validateErrorsTranslator;
}
#end_block

#method_before
private void translateErrors(final Collection<VdcReturnValueBase> errors) {
    for (VdcReturnValueBase retVal : errors) {
        if (!retVal.getCanDoAction()) {
            retVal.setCanDoActionMessages((ArrayList<String>) translateError(retVal));
        } else if (!retVal.getSucceeded()) {
            EngineFault fault = retVal.getFault();
            fault.setMessage(translateEngineFault(fault));
        }
    }
}
#method_after
private void translateErrors(final Collection<VdcReturnValueBase> errors) {
    for (VdcReturnValueBase retVal : errors) {
        if (!retVal.isValid()) {
            retVal.setValidationMessages((ArrayList<String>) translateError(retVal));
        } else if (!retVal.getSucceeded()) {
            EngineFault fault = retVal.getFault();
            fault.setMessage(translateEngineFault(fault));
        }
    }
}
#end_block

#method_before
private List<String> translateError(final VdcReturnValueBase error) {
    return getAppErrorsTranslator().translateErrorText(error.getCanDoActionMessages());
}
#method_after
private List<String> translateError(final VdcReturnValueBase error) {
    return getAppErrorsTranslator().translateErrorText(error.getValidationMessages());
}
#end_block

#method_before
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        handleNotLoggedInEvent(errorMessage);
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#method_after
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<>();
    for (String errorMessage : errorMessages) {
        handleNotLoggedInEvent(errorMessage);
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#end_block

#method_before
public static Map<String, Object> getPayloadForAuthCode(String authCode, String scope, String redirectUri) throws Exception {
    Map<String, Object> response = SSOOAuthServiceUtils.getToken("authorization_code", authCode, scope, redirectUri);
    FiltersHelper.isStatusOk(response);
    return getPayloadForToken((String) response.get("access_token"));
}
#method_after
public static Map<String, Object> getPayloadForAuthCode(String authCode, String scope, String redirectUri) throws Exception {
    Map<String, Object> response = SsoOAuthServiceUtils.getToken("authorization_code", authCode, scope, redirectUri);
    FiltersHelper.isStatusOk(response);
    return getPayloadForToken((String) response.get("access_token"));
}
#end_block

#method_before
public static Map<String, Object> getPayloadForToken(String token) throws Exception {
    Map<String, Object> response = SSOOAuthServiceUtils.getTokenInfo(token);
    FiltersHelper.isStatusOk(response);
    response.put(SessionConstants.SSO_TOKEN_KEY, token);
    return response;
}
#method_after
public static Map<String, Object> getPayloadForToken(String token) throws Exception {
    Map<String, Object> response = SsoOAuthServiceUtils.getTokenInfo(token);
    FiltersHelper.isStatusOk(response);
    response.put(SessionConstants.SSO_TOKEN_KEY, token);
    return response;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(// $NON-NLS-1$
    StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), ",")));
    // Set attributes for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser, getEngineSessionId(request), getSsoToken(request)));
    }
    // Set attribute for engineRpmVersion object
    String engineRpmVersion = getEngineRpmVersion(getEngineSessionId(request));
    request.setAttribute(MD5Attributes.ATTR_ENGINE_RPM_VERSION.getKey(), getValueObject(engineRpmVersion));
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    final String engineSessionId = getEngineSessionId(request);
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(// $NON-NLS-1$
    StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), ",")));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_UNCAUGHT_UI_EXCEPTIONS.getKey(), getDisplayUncaughtUIExceptions() ? BooleanNode.TRUE : BooleanNode.FALSE);
    // Set attributes for userInfo object
    DbUser loggedInUser = getLoggedInUser(engineSessionId);
    if (loggedInUser != null) {
        String ssoToken = getSsoToken(engineSessionId);
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser, engineSessionId, ssoToken));
    }
    // Set attribute for engineRpmVersion object
    String engineRpmVersion = getEngineRpmVersion(engineSessionId);
    request.setAttribute(MD5Attributes.ATTR_ENGINE_RPM_VERSION.getKey(), getValueObject(engineRpmVersion));
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
private String getSsoToken(final HttpServletRequest request) {
    return (String) request.getSession().getAttribute(SessionConstants.SSO_TOKEN_KEY);
}
#method_after
private String getSsoToken(final String engineSessionId) {
    return (String) runQuery(VdcQueryType.GetEngineSessionIdToken, new VdcQueryParametersBase(), engineSessionId);
}
#end_block

#method_before
private String getValueObject(final String value) {
    ObjectNode node = mapper.createObjectNode();
    // $NON-NLS-1$
    node.put("value", value);
    return node.toString();
}
#method_after
protected String getValueObject(final String value) {
    ObjectNode node = mapper.createObjectNode();
    // $NON-NLS-1$
    node.put("value", value);
    return node.toString();
}
#end_block

#method_before
protected void initQueryParams(VdcQueryParametersBase queryParams, String sessionId) {
    queryParams.setSessionId(sessionId);
    queryParams.setHttpSessionId(sessionId);
    queryParams.setFiltered(filterQueries());
}
#method_after
protected void initQueryParams(VdcQueryParametersBase queryParams, String sessionId) {
    queryParams.setSessionId(sessionId);
    queryParams.setFiltered(filterQueries());
}
#end_block

#method_before
protected ObjectNode getUserInfoObject(DbUser loggedInUser, String engineSessionId, String ssoToken) {
    ObjectNode obj = createObjectNode();
    // $NON-NLS-1$
    obj.put("id", loggedInUser.getId().toString());
    // $NON-NLS-1$
    obj.put("userName", loggedInUser.getLoginName());
    // $NON-NLS-1$
    obj.put("domain", loggedInUser.getDomain());
    // $NON-NLS-1$
    obj.put("engineSessionId", engineSessionId);
    // $NON-NLS-1$
    obj.put("ssoToken", ssoToken);
    return obj;
}
#method_after
protected ObjectNode getUserInfoObject(DbUser loggedInUser, String engineSessionId, String ssoToken) {
    ObjectNode obj = createObjectNode();
    // $NON-NLS-1$
    obj.put("id", loggedInUser.getId().toString());
    // $NON-NLS-1$
    obj.put("userName", loggedInUser.getLoginName());
    // $NON-NLS-1$
    obj.put("domain", loggedInUser.getDomain());
    // $NON-NLS-1$
    obj.put("isAdmin", loggedInUser.isAdmin());
    // $NON-NLS-1$
    obj.put("engineSessionId", engineSessionId);
    // $NON-NLS-1$
    obj.put("ssoToken", ssoToken);
    return obj;
}
#end_block

#method_before
protected String getMd5Sum(HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    return (new HexBinaryAdapter()).marshal(getMd5Digest(request).digest());
}
#method_after
protected String getMd5Sum(HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    return new HexBinaryAdapter().marshal(getMd5Digest(request).digest());
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Object resolve(Class type) {
    if (type == Configurator.class) {
        return configurator;
    } else if (type == ILogger.class) {
        return logger;
    } else if (type == ITimer.class) {
        return new TimerImpl();
    } else if (type == ISpicePlugin.class) {
        return spicePluginProvider.get();
    } else if (type == ISpiceNative.class) {
        return withSessionId(spiceNativeProvider.get());
    } else if (type == ISpiceHtml5.class) {
        return spiceHtml5Provider.get();
    } else if (type == IRdpPlugin.class) {
        return rdpPluginProvider.get();
    } else if (type == IRdpNative.class) {
        return rdpNativeProvider.get();
    } else if (type == INoVnc.class) {
        return noVncProvider.get();
    } else if (type == IVncNative.class) {
        return withSessionId(vncNativeProvider.get());
    } else if (type == ConsoleOptionsFrontendPersister.class) {
        return consoleOptionsFrontendPersister;
    } else if (type == ConsoleUtils.class) {
        return consoleUtils;
    } else if (type == ErrorPopupManager.class) {
        return errorPopupManager;
    } else if (type == CurrentUserRole.class) {
        return currentUserRole;
    } else if (type == DynamicMessages.class) {
        return dynamicMessages;
    }
    // $NON-NLS-1$
    throw new RuntimeException("UiCommon Resolver cannot resolve type: " + type);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Object resolve(Class type) {
    if (type == Configurator.class) {
        return configurator;
    } else if (type == ILogger.class) {
        return logger;
    } else if (type == ITimer.class) {
        return new TimerImpl();
    } else if (type == ISpicePlugin.class) {
        // deprecated in 4.0
        return spicePluginProvider.get();
    } else if (type == ISpiceNative.class) {
        return withSsoToken(spiceNativeProvider.get());
    } else if (type == ISpiceHtml5.class) {
        return spiceHtml5Provider.get();
    } else if (type == IRdpPlugin.class) {
        return rdpPluginProvider.get();
    } else if (type == IRdpNative.class) {
        return rdpNativeProvider.get();
    } else if (type == INoVnc.class) {
        return noVncProvider.get();
    } else if (type == IVncNative.class) {
        return withSsoToken(vncNativeProvider.get());
    } else if (type == ConsoleOptionsFrontendPersister.class) {
        return consoleOptionsFrontendPersister;
    } else if (type == ConsoleUtils.class) {
        return consoleUtils;
    } else if (type == ErrorPopupManager.class) {
        return errorPopupManager;
    } else if (type == CurrentUserRole.class) {
        return currentUserRole;
    } else if (type == DynamicMessages.class) {
        return dynamicMessages;
    }
    // $NON-NLS-1$
    throw new RuntimeException("UiCommon Resolver cannot resolve type: " + type);
}
#end_block

#method_before
private void initState() {
    reportsEnabled = false;
    xmlInitialized = false;
    reportsWebappDeployed = false;
    scheduledStatusCheckInProgress = false;
    initEventRaised = false;
    // $NON-NLS-1$
    reportBaseUrl = "";
    // $NON-NLS-1$
    reportRightClickUrl = "";
    isCommunityEdition = false;
    resourceMap = new HashMap<String, Resource>();
    dashboardMap = new HashMap<String, Dashboard>();
    // $NON-NLS-1$
    reportsInitEvent = new Event<EventArgs>("ReportsInitialize", ReportInit.class);
    retryCount = 0;
}
#method_after
private void initState() {
    reportsEnabled = false;
    xmlInitialized = false;
    reportsWebappDeployed = false;
    scheduledStatusCheckInProgress = false;
    initEventRaised = false;
    // $NON-NLS-1$
    reportBaseUrl = "";
    // $NON-NLS-1$
    reportRightClickUrl = "";
    isCommunityEdition = false;
    resourceMap = new HashMap<>();
    dashboardMap = new HashMap<>();
    // $NON-NLS-1$
    reportsInitEvent = new Event<>("ReportsInitialize", ReportInit.class);
    retryCount = 0;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    fakeScheduler = new FakeGWTScheduler();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService, mockXsrfRpcRequestBuilder);
    // $NON-NLS-1$
    when(mockXsrfRpcRequestBuilder.getXsrfToken()).thenReturn(new XsrfToken("Something"));
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(mockEventBus, operationProcessor);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
    when(mockConstants.noCanDoActionMessage()).thenReturn(NO_MESSAGE);
}
#method_after
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    fakeScheduler = new FakeGWTScheduler();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService, mockXsrfRpcRequestBuilder);
    // $NON-NLS-1$
    when(mockXsrfRpcRequestBuilder.getXsrfToken()).thenReturn(new XsrfToken("Something"));
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(mockEventBus, operationProcessor);
    frontend = new Frontend(operationsManager, mockValidateErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
    when(mockConstants.noValidateMessage()).thenReturn(NO_MESSAGE);
}
#end_block

#method_before
@Test
public void testrunMultipleActions_ignored_failure_multiple() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    parameters.add(new VdcActionParametersBase());
    testState = null;
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(0, "0 status code");
    callbackMultipleActions.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    verify(mockMultipleActionCallback, never()).executed(callbackMultipleParam.capture());
    verifyAsyncActionStartedButNotCompleted();
}
#method_after
@Test
public void testrunMultipleActions_ignored_failure_multiple() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    parameters.add(new VdcActionParametersBase());
    testState = null;
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(0, "0 status code");
    callbackMultipleActions.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    verify(mockMultipleActionCallback, never()).executed(callbackMultipleParam.capture());
    verifyAsyncActionStartedButNotCompleted();
}
#end_block

#method_before
@Test
public void testrunMultipleActions_404_failure_multiple() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    parameters.add(new VdcActionParametersBase());
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackMultipleActions.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "ActionType should be 'AddLocalStorageDomain'", // $NON-NLS-1$
    VdcActionType.AddLocalStorageDomain, callbackMultipleParam.getValue().getActionType());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    // $NON-NLS-1$
    assertNull("There should be no result", callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndFailed();
}
#method_after
@Test
public void testrunMultipleActions_404_failure_multiple() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    parameters.add(new VdcActionParametersBase());
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackMultipleActions.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "ActionType should be 'AddLocalStorageDomain'", // $NON-NLS-1$
    VdcActionType.AddLocalStorageDomain, callbackMultipleParam.getValue().getActionType());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    // $NON-NLS-1$
    assertNull("There should be no result", callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndFailed();
}
#end_block

#method_before
@Test
public void testrunMultipleActionsMultipleSuccess() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    parameters.add(new VdcActionParametersBase());
    parameters.get(0).setCommandId(Guid.Empty);
    parameters.add(new VdcActionParametersBase());
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.get(0).setCanDoAction(true);
    returnValues.get(1).setCanDoAction(true);
    callbackMultipleActions.getValue().onSuccess(returnValues);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    assertEquals(// $NON-NLS-1$
    "Result should match", // $NON-NLS-1$
    returnValues, callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@Test
public void testrunMultipleActionsMultipleSuccess() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    parameters.add(new VdcActionParametersBase());
    parameters.get(0).setCommandId(Guid.Empty);
    parameters.add(new VdcActionParametersBase());
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<>();
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.get(0).setValid(true);
    returnValues.get(1).setValid(true);
    callbackMultipleActions.getValue().onSuccess(returnValues);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    assertEquals(// $NON-NLS-1$
    "Result should match", // $NON-NLS-1$
    returnValues, callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testrunMultipleActionsMultipleSuccess_oneFailure() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.get(0).setCommandId(Guid.Empty);
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.get(0).setCanDoAction(true);
    returnValues.get(1).setCanDoAction(false);
    callbackMultipleActions.getValue().onSuccess(returnValues);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    @SuppressWarnings("rawtypes")
    ArgumentCaptor<ArrayList> failedCaptor = ArgumentCaptor.forClass(ArrayList.class);
    verify(mockEventsHandler).runMultipleActionFailed(eq(VdcActionType.AddLocalStorageDomain), failedCaptor.capture());
    // $NON-NLS-1$
    assertEquals("There is one failure", 1, failedCaptor.getValue().size());
    // $NON-NLS-1$
    assertEquals("Failures should match", returnValues.get(1), failedCaptor.getValue().get(0));
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    assertEquals(// $NON-NLS-1$
    "Result should match", // $NON-NLS-1$
    returnValues, callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testrunMultipleActionsMultipleSuccess_oneFailure() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.get(0).setCommandId(Guid.Empty);
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<>();
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.get(0).setValid(true);
    returnValues.get(1).setValid(false);
    callbackMultipleActions.getValue().onSuccess(returnValues);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    @SuppressWarnings("rawtypes")
    ArgumentCaptor<ArrayList> failedCaptor = ArgumentCaptor.forClass(ArrayList.class);
    verify(mockEventsHandler).runMultipleActionFailed(eq(VdcActionType.AddLocalStorageDomain), failedCaptor.capture());
    // $NON-NLS-1$
    assertEquals("There is one failure", 1, failedCaptor.getValue().size());
    // $NON-NLS-1$
    assertEquals("Failures should match", returnValues.get(1), failedCaptor.getValue().get(0));
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    assertEquals(// $NON-NLS-1$
    "Result should match", // $NON-NLS-1$
    returnValues, callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testrunMultipleActionsMultipleSuccess_multipleFailure() {
    // Don't immediately call process until all queries are in the queue.
    fakeScheduler.setThreshold(4);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.get(0).setCommandId(Guid.Empty);
    parameters.get(1).setCommandId(Guid.EVERYONE);
    parameters.get(2).setCommandId(Guid.SYSTEM);
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.get(0).setCanDoAction(true);
    returnValues.get(1).setCanDoAction(false);
    returnValues.get(2).setCanDoAction(true);
    returnValues.get(3).setCanDoAction(false);
    callbackMultipleActions.getValue().onSuccess(returnValues);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    @SuppressWarnings("rawtypes")
    ArgumentCaptor<ArrayList> failedCaptor = ArgumentCaptor.forClass(ArrayList.class);
    verify(mockEventsHandler).runMultipleActionFailed(eq(VdcActionType.AddLocalStorageDomain), failedCaptor.capture());
    // $NON-NLS-1$
    assertEquals("There are two failures", 2, failedCaptor.getValue().size());
    // $NON-NLS-1$
    assertEquals("Failures should match", returnValues.get(1), failedCaptor.getValue().get(0));
    // $NON-NLS-1$
    assertEquals("Failures should match", returnValues.get(3), failedCaptor.getValue().get(1));
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    assertEquals(// $NON-NLS-1$
    "Result should match", // $NON-NLS-1$
    returnValues, callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testrunMultipleActionsMultipleSuccess_multipleFailure() {
    // Don't immediately call process until all queries are in the queue.
    fakeScheduler.setThreshold(4);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.add(new VdcActionParametersBase());
    parameters.get(0).setCommandId(Guid.Empty);
    parameters.get(1).setCommandId(Guid.EVERYONE);
    parameters.get(2).setCommandId(Guid.SYSTEM);
    frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, testState);
    verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture());
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<>();
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.add(new VdcReturnValueBase());
    returnValues.get(0).setValid(true);
    returnValues.get(1).setValid(false);
    returnValues.get(2).setValid(true);
    returnValues.get(3).setValid(false);
    callbackMultipleActions.getValue().onSuccess(returnValues);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any());
    @SuppressWarnings("rawtypes")
    ArgumentCaptor<ArrayList> failedCaptor = ArgumentCaptor.forClass(ArrayList.class);
    verify(mockEventsHandler).runMultipleActionFailed(eq(VdcActionType.AddLocalStorageDomain), failedCaptor.capture());
    // $NON-NLS-1$
    assertEquals("There are two failures", 2, failedCaptor.getValue().size());
    // $NON-NLS-1$
    assertEquals("Failures should match", returnValues.get(1), failedCaptor.getValue().get(0));
    // $NON-NLS-1$
    assertEquals("Failures should match", returnValues.get(3), failedCaptor.getValue().get(1));
    verify(mockMultipleActionCallback).executed(callbackMultipleParam.capture());
    assertEquals(// $NON-NLS-1$
    "Parameters should match", // $NON-NLS-1$
    parameters, callbackMultipleParam.getValue().getParameters());
    assertEquals(// $NON-NLS-1$
    "Result should match", // $NON-NLS-1$
    returnValues, callbackMultipleParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackMultipleParam.getValue().getState());
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@Test
public void testHandleActionResult() {
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
}
#method_after
@Test
public void testHandleActionResult() {
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes this is the default, but to make sure.
    returnValue.setValid(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
}
#end_block

#method_before
@Test
public void testHandleActionResult_SucceededFalse() {
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(true);
    returnValue.setIsSyncronious(true);
    // Yes this is the default, but to make sure.
    returnValue.setSucceeded(false);
    EngineFault testFault = new EngineFault();
    returnValue.setFault(testFault);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    verify(mockEventsHandler).runActionExecutionFailed(VdcActionType.AddDisk, testFault);
}
#method_after
@Test
public void testHandleActionResult_SucceededFalse() {
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setValid(true);
    returnValue.setIsSyncronious(true);
    // Yes this is the default, but to make sure.
    returnValue.setSucceeded(false);
    EngineFault testFault = new EngineFault();
    returnValue.setFault(testFault);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    verify(mockEventsHandler).runActionExecutionFailed(VdcActionType.AddDisk, testFault);
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_actionMessageSize_1_or_less() {
    EngineFault testFault = new EngineFault();
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    NO_MESSAGE, failureCaptor.getValue().getMessages().get(0).getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_actionMessageSize_1_or_less() {
    EngineFault testFault = new EngineFault();
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // Yes this is the default, but to make sure.
    returnValue.setValid(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    NO_MESSAGE, failureCaptor.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSize1() {
    EngineFault testFault = new EngineFault();
    // $NON-NLS-1$
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match translation", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSize1() {
    EngineFault testFault = new EngineFault();
    // $NON-NLS-1$
    ArrayList<String> translatedErrors = new ArrayList<>(Arrays.asList("Translated Message 1"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockValidateErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getValidationMessages().add("Message 1");
    // Yes this is the default, but to make sure.
    returnValue.setValid(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match translation", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSizeGreaterThan1() {
    EngineFault testFault = new EngineFault();
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 2");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2", failureCaptor.getValue().getMessages().get(1).getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSizeGreaterThan1() {
    EngineFault testFault = new EngineFault();
    ArrayList<String> translatedErrors = new ArrayList<>(Arrays.asList("Translated Message 1", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockValidateErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getValidationMessages().add("Message 1");
    // $NON-NLS-1$
    returnValue.getValidationMessages().add("Message 2");
    // Yes this is the default, but to make sure.
    returnValue.setValid(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2", failureCaptor.getValue().getMessages().get(1).getText());
}
#end_block

#method_before
@Test
public void testrunMultipleActions_1action() {
    List<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    actionTypes.add(VdcActionType.AddDisk);
    List<VdcActionParametersBase> testParameters = new ArrayList<VdcActionParametersBase>();
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // $NON-NLS-1$
    assertEquals("List size should be 0", 0, actionTypes.size());
    // $NON-NLS-1$
    assertEquals("List size should be 0", 0, testParameters.size());
    // $NON-NLS-1$
    assertEquals("List size should be 0", 0, callbacks.size());
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@Test
public void testrunMultipleActions_1action() {
    List<VdcActionType> actionTypes = new ArrayList<>();
    actionTypes.add(VdcActionType.AddDisk);
    List<VdcActionParametersBase> testParameters = new ArrayList<>();
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<>();
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setValid(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // $NON-NLS-1$
    assertEquals("List size should be 0", 0, actionTypes.size());
    // $NON-NLS-1$
    assertEquals("List size should be 0", 0, testParameters.size());
    // $NON-NLS-1$
    assertEquals("List size should be 0", 0, callbacks.size());
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@Test
public void testrunMultipleActions_multipleaction_success_all() {
    List<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    actionTypes.add(VdcActionType.AddDisk);
    actionTypes.add(VdcActionType.AddBricksToGlusterVolume);
    List<VdcActionParametersBase> testParameters = new ArrayList<VdcActionParametersBase>();
    testParameters.add(new VdcActionParametersBase());
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    callbacks.add(mockActionCallback);
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // Second call to runAction, the size of the parameters should have decreased
    verify(mockService).runAction(eq(VdcActionType.AddBricksToGlusterVolume), eq(testParameters.get(0)), callbackAction.capture());
    returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback, times(2)).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@Test
public void testrunMultipleActions_multipleaction_success_all() {
    List<VdcActionType> actionTypes = new ArrayList<>();
    actionTypes.add(VdcActionType.AddDisk);
    actionTypes.add(VdcActionType.AddBricksToGlusterVolume);
    List<VdcActionParametersBase> testParameters = new ArrayList<>();
    testParameters.add(new VdcActionParametersBase());
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<>();
    callbacks.add(mockActionCallback);
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setValid(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // Second call to runAction, the size of the parameters should have decreased
    verify(mockService).runAction(eq(VdcActionType.AddBricksToGlusterVolume), eq(testParameters.get(0)), callbackAction.capture());
    returnValue = new VdcReturnValueBase();
    returnValue.setValid(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback, times(2)).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@Test
public void testrunMultipleActions_multipleaction_success_first_success_second_failure() {
    List<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    actionTypes.add(VdcActionType.AddDisk);
    actionTypes.add(VdcActionType.AddBricksToGlusterVolume);
    List<VdcActionParametersBase> testParameters = new ArrayList<VdcActionParametersBase>();
    testParameters.add(new VdcActionParametersBase());
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    callbacks.add(mockActionCallback);
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // Second call to runAction
    verify(mockService).runAction(eq(VdcActionType.AddBricksToGlusterVolume), eq(testParameters.get(0)), callbackAction.capture());
    returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionFailureCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@Test
public void testrunMultipleActions_multipleaction_success_first_success_second_failure() {
    List<VdcActionType> actionTypes = new ArrayList<>();
    actionTypes.add(VdcActionType.AddDisk);
    actionTypes.add(VdcActionType.AddBricksToGlusterVolume);
    List<VdcActionParametersBase> testParameters = new ArrayList<>();
    testParameters.add(new VdcActionParametersBase());
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<>();
    callbacks.add(mockActionCallback);
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setValid(true);
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // Second call to runAction
    verify(mockService).runAction(eq(VdcActionType.AddBricksToGlusterVolume), eq(testParameters.get(0)), callbackAction.capture());
    returnValue = new VdcReturnValueBase();
    returnValue.setValid(false);
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionFailureCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@Test
public void testrunMultipleActions_multipleaction_success_first_failure_second_success() {
    List<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    actionTypes.add(VdcActionType.AddDisk);
    actionTypes.add(VdcActionType.AddBricksToGlusterVolume);
    List<VdcActionParametersBase> testParameters = new ArrayList<VdcActionParametersBase>();
    testParameters.add(new VdcActionParametersBase());
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    callbacks.add(mockActionCallback);
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionFailureCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // Second call to runAction, the size of the parameters should have decreased
    verify(mockService, never()).runAction(eq(VdcActionType.AddBricksToGlusterVolume), eq(testParameters.get(0)), callbackAction.capture());
    verifyAsyncActionStartedAndSucceeded();
}
#method_after
@Test
public void testrunMultipleActions_multipleaction_success_first_failure_second_success() {
    List<VdcActionType> actionTypes = new ArrayList<>();
    actionTypes.add(VdcActionType.AddDisk);
    actionTypes.add(VdcActionType.AddBricksToGlusterVolume);
    List<VdcActionParametersBase> testParameters = new ArrayList<>();
    testParameters.add(new VdcActionParametersBase());
    testParameters.add(new VdcActionParametersBase());
    List<IFrontendActionAsyncCallback> callbacks = new ArrayList<>();
    callbacks.add(mockActionCallback);
    callbacks.add(mockActionCallback);
    frontend.runMultipleActions(actionTypes, testParameters, callbacks, mockActionFailureCallback, testState);
    verify(mockService).runAction(eq(VdcActionType.AddDisk), eq(testParameters.get(0)), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setValid(false);
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockActionFailureCallback).executed(callbackParam.capture());
    assertEquals(callbackParam.getValue().getReturnValue(), returnValue);
    // Second call to runAction, the size of the parameters should have decreased
    verify(mockService, never()).runAction(eq(VdcActionType.AddBricksToGlusterVolume), eq(testParameters.get(0)), callbackAction.capture());
    verifyAsyncActionStartedAndSucceeded();
}
#end_block

#method_before
@Override
public final void onBootstrap() {
    // $NON-NLS-1$
    Logger rootLogger = Logger.getLogger("");
    initLocalStorageLogHandler(rootLogger);
    initUncaughtExceptionHandler(rootLogger);
    // Perform actual bootstrap via deferred command to ensure that
    // UncaughtExceptionHandler is effective during the bootstrap
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            performBootstrap();
        }
    });
}
#method_after
@Override
public final void onBootstrap() {
    // $NON-NLS-1$
    Logger rootLogger = Logger.getLogger("");
    initLocalStorageLogHandler(rootLogger);
    // $NON-NLS-1$
    Logger remoteLogger = Logger.getLogger("remote");
    remoteLogger.addHandler(new SimpleRemoteLogHandler());
    initUncaughtExceptionHandler(rootLogger, remoteLogger);
    // Perform actual bootstrap via deferred command to ensure that
    // UncaughtExceptionHandler is effective during the bootstrap
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            performBootstrap();
        }
    });
}
#end_block

#method_before
void initUncaughtExceptionHandler(final Logger rootLogger) {
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            alertManager.showUncaughtExceptionAlert(t);
        }
    });
}
#method_after
void initUncaughtExceptionHandler(final Logger rootLogger, final Logger remoteLogger) {
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            // $NON-NLS-1$
            remoteLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            if (DisplayUncaughtUIExceptions.getValue()) {
                alertManager.showUncaughtExceptionAlert(t);
            }
        }
    });
}
#end_block

#method_before
public void enablePluginInvocation() {
    canInvokePlugins = true;
    // Try to initialize all plugins after the browser event loop returns
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            for (Plugin plugin : getPlugins()) {
                initPlugin(plugin);
            }
        }
    });
}
#method_after
public void enablePluginInvocation() {
    canInvokePlugins = true;
    // Try to initialize all plugins after the browser event loop returns
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            initAllPlugins();
        }
    });
}
#end_block

#method_before
@Test
public void testGetMd5Digest_WithExtraObjects_WithoutUserInfoObject() throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest result = testServlet.getMd5Digest(mockRequest);
    assertEquals(result, mockDigest);
    verify(mockDigest, atLeast(4)).update(byteArrayCaptor.capture());
    assertArrayEquals(SELECTOR_SCRIPT.getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(0));
    assertArrayEquals(APPLICATION_MODE.getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(1));
    assertArrayEquals(mockPluginDefinitionsArray.toString().getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(2));
}
#method_after
@Test
public void testGetMd5Digest_WithExtraObjects_WithoutUserInfoObject() throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest result = testServlet.getMd5Digest(mockRequest);
    assertEquals(result, mockDigest);
    verify(mockDigest, atLeast(3)).update(byteArrayCaptor.capture());
    assertArrayEquals(SELECTOR_SCRIPT.getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(0));
    assertArrayEquals(APPLICATION_MODE.getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(1));
    assertArrayEquals(mockPluginDefinitionsArray.toString().getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(2));
}
#end_block

#method_before
@Test
public void testGetPluginDefinitionsArray() {
    int mockDataCount = 10;
    List<PluginData> pluginData = new ArrayList<PluginData>();
    for (int i = 0; i < mockDataCount; i++) {
        PluginData mockData = mock(PluginData.class);
        // $NON-NLS-1$
        when(mockData.getName()).thenReturn("name" + i);
        // $NON-NLS-1$
        when(mockData.getUrl()).thenReturn("url" + i);
        when(mockData.mergeConfiguration()).thenReturn(mock(ObjectNode.class));
        when(mockData.isEnabled()).thenReturn(true);
        pluginData.add(mockData);
    }
    ArrayNode result = testServlet.getPluginDefinitionsArray(pluginData);
    assertEquals(result.size(), mockDataCount);
    for (int i = 0; i < mockDataCount; i++) {
        JsonNode item = result.get(i);
        // $NON-NLS-1$ //$NON-NLS-2$
        assertEquals(item.get("name").asText(), "name" + i);
        // $NON-NLS-1$ //$NON-NLS-2$
        assertEquals(item.get("url").asText(), "url" + i);
        // $NON-NLS-1$
        assertTrue(item.get("config") instanceof ObjectNode);
        // $NON-NLS-1$
        assertEquals(item.get("enabled").asBoolean(), true);
    }
}
#method_after
@Test
public void testGetPluginDefinitionsArray() {
    int mockDataCount = 10;
    List<PluginData> pluginData = new ArrayList<>();
    for (int i = 0; i < mockDataCount; i++) {
        PluginData mockData = mock(PluginData.class);
        // $NON-NLS-1$
        when(mockData.getName()).thenReturn("name" + i);
        // $NON-NLS-1$
        when(mockData.getUrl()).thenReturn("url" + i);
        when(mockData.mergeConfiguration()).thenReturn(mock(ObjectNode.class));
        when(mockData.isEnabled()).thenReturn(true);
        pluginData.add(mockData);
    }
    ArrayNode result = testServlet.getPluginDefinitionsArray(pluginData);
    assertEquals(result.size(), mockDataCount);
    for (int i = 0; i < mockDataCount; i++) {
        JsonNode item = result.get(i);
        // $NON-NLS-1$ //$NON-NLS-2$
        assertEquals(item.get("name").asText(), "name" + i);
        // $NON-NLS-1$ //$NON-NLS-2$
        assertEquals(item.get("url").asText(), "url" + i);
        // $NON-NLS-1$
        assertTrue(item.get("config") instanceof ObjectNode);
        // $NON-NLS-1$
        assertEquals(item.get("enabled").asBoolean(), true);
    }
}
#end_block

#method_before
@Test
public void testInitQueryParams() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    testServlet.initQueryParams(mockQueryParams, sessionId);
    verify(mockQueryParams).setSessionId(sessionId);
    verify(mockQueryParams).setHttpSessionId(sessionId);
    verify(mockQueryParams).setFiltered(testServlet.filterQueries());
}
#method_after
@Test
public void testInitQueryParams() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    testServlet.initQueryParams(mockQueryParams, sessionId);
    verify(mockQueryParams).setSessionId(sessionId);
    verify(mockQueryParams).setFiltered(testServlet.filterQueries());
}
#end_block

#method_before
@Test
public void testRunQuery_GetUserBySessionId() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    VdcQueryType queryType = VdcQueryType.GetUserBySessionId;
    Object result = testServlet.runQuery(queryType, mockQueryParams, sessionId);
    assertEquals(result, mockUser);
    verify(mockQueryParams).setSessionId(sessionId);
    verify(mockQueryParams).setHttpSessionId(sessionId);
    verify(mockQueryParams).setFiltered(testServlet.filterQueries());
    verify(mockBackend).runQuery(queryType, mockQueryParams);
}
#method_after
@Test
public void testRunQuery_GetUserBySessionId() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    VdcQueryType queryType = VdcQueryType.GetUserBySessionId;
    Object result = testServlet.runQuery(queryType, mockQueryParams, sessionId);
    assertEquals(result, mockUser);
    verify(mockQueryParams).setSessionId(sessionId);
    verify(mockQueryParams).setFiltered(testServlet.filterQueries());
    verify(mockBackend).runQuery(queryType, mockQueryParams);
}
#end_block

#method_before
@Test
public void testRunPublicQuery_GetConfigurationValue() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    VdcQueryType queryType = VdcQueryType.GetConfigurationValue;
    VdcQueryReturnValue returnIntValue = new VdcQueryReturnValue();
    returnIntValue.setSucceeded(true);
    returnIntValue.setReturnValue(Integer.valueOf(255));
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(mockConfigQueryParams))).thenReturn(returnIntValue);
    Object result = testServlet.runPublicQuery(queryType, mockConfigQueryParams, sessionId);
    assertThat(result, is(instanceOf(Integer.class)));
    verify(mockConfigQueryParams).setSessionId(sessionId);
    verify(mockConfigQueryParams).setHttpSessionId(sessionId);
    verify(mockConfigQueryParams).setFiltered(testServlet.filterQueries());
    verify(mockBackend).runPublicQuery(queryType, mockConfigQueryParams);
}
#method_after
@Test
public void testRunPublicQuery_GetConfigurationValue() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    VdcQueryType queryType = VdcQueryType.GetConfigurationValue;
    VdcQueryReturnValue returnIntValue = new VdcQueryReturnValue();
    returnIntValue.setSucceeded(true);
    returnIntValue.setReturnValue(Integer.valueOf(255));
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(mockConfigQueryParams))).thenReturn(returnIntValue);
    Object result = testServlet.runPublicQuery(queryType, mockConfigQueryParams, sessionId);
    assertThat(result, is(instanceOf(Integer.class)));
    verify(mockConfigQueryParams).setSessionId(sessionId);
    verify(mockConfigQueryParams).setFiltered(testServlet.filterQueries());
    verify(mockBackend).runPublicQuery(queryType, mockConfigQueryParams);
}
#end_block

#method_before
public DbUser getDbUser() {
    DbUser user = new DbUser();
    user.setId(Guid.createGuidFromStringDefaultEmpty(getId()));
    user.setDomain(getDomain());
    user.setLoginName(getUserName());
    return user;
}
#method_after
public DbUser getDbUser() {
    DbUser user = new DbUser();
    user.setId(Guid.createGuidFromStringDefaultEmpty(getId()));
    user.setDomain(getDomain());
    user.setLoginName(getUserName());
    user.setAdmin(isAdmin());
    return user;
}
#end_block

#method_before
@Override
public Guid getStorageDomainId() {
    if (cachedStorageDomainId == null) {
        List<DiskImage> diskDummiesForMemSize = MemoryUtils.createDiskDummies(VmDeviceUtils.getTotalMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getStoragePoolId(), diskDummiesForMemSize, ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(getVmId()), false, false, false), getVm());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#method_after
@Override
public Guid getStorageDomainId() {
    if (cachedStorageDomainId == null) {
        List<DiskImage> diskDummiesForMemSize = MemoryUtils.createDiskDummies(VmUtils.getSnapshotMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getStoragePoolId(), diskDummiesForMemSize, ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(getVmId()), false, false, false), getVm());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#end_block

#method_before
private AddDiskParameters buildAddDiskParameters(DiskImage disk) {
    AddDiskParameters parameters = new AddDiskParameters(Guid.Empty, disk);
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldBeLogged(false);
    return parameters;
}
#method_after
private AddDiskParameters buildAddDiskParameters(DiskImage disk) {
    AddDiskParameters parameters = new AddDiskParameters(disk);
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldBeLogged(false);
    return parameters;
}
#end_block

#method_before
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(VmDeviceUtils.getTotalMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#method_after
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(VmUtils.getSnapshotMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#end_block

#method_before
public static DiskImage createMemoryDisk(VM vm, StorageType storageType) {
    DiskImage image = new DiskImage();
    image.setSize(VmDeviceUtils.getTotalMemorySizeInBytes(vm));
    image.setVolumeType(storageTypeToMemoryVolumeType(storageType));
    image.setvolumeFormat(VolumeFormat.RAW);
    image.setDiskInterface(DiskInterface.VirtIO);
    return image;
}
#method_after
public static DiskImage createMemoryDisk(VM vm, StorageType storageType) {
    DiskImage image = new DiskImage();
    image.setSize(VmUtils.getSnapshotMemorySizeInBytes(vm));
    image.setVolumeType(storageTypeToMemoryVolumeType(storageType));
    image.setvolumeFormat(VolumeFormat.RAW);
    image.setDiskInterface(DiskInterface.VirtIO);
    return image;
}
#end_block

#method_before
private List<DiskImage> getMemoryVolumes() {
    int numOfSnapshots = snapshotsWithMemory.size();
    long memorySize = numOfSnapshots * VmDeviceUtils.getTotalMemorySizeInBytes(getVm());
    long metadataSize = numOfSnapshots * MemoryUtils.METADATA_SIZE_IN_BYTES;
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(memorySize, metadataSize);
    // Set target domain in memory disks
    ArrayList<Guid> sdId = new ArrayList<>(Collections.singletonList(getStorageDomainId()));
    for (DiskImage diskImage : memoryDisksList) {
        diskImage.setStorageIds(sdId);
    }
    return memoryDisksList;
}
#method_after
private List<DiskImage> getMemoryVolumes() {
    int numOfSnapshots = snapshotsWithMemory.size();
    long memorySize = numOfSnapshots * VmUtils.getSnapshotMemorySizeInBytes(getVm());
    long metadataSize = numOfSnapshots * MemoryUtils.METADATA_SIZE_IN_BYTES;
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(memorySize, metadataSize);
    // Set target domain in memory disks
    ArrayList<Guid> sdId = new ArrayList<>(Collections.singletonList(getStorageDomainId()));
    for (DiskImage diskImage : memoryDisksList) {
        diskImage.setStorageIds(sdId);
    }
    return memoryDisksList;
}
#end_block

#method_before
private StorageDomain updateStorageDomainInMemoryVolumes(List<DiskImage> disksList) {
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(VmDeviceUtils.getTotalMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
    StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getParameters().getStoragePoolId(), memoryDisksList, getVmDisksDummies(), getVm());
    disksList.addAll(memoryDisksList);
    return storageDomain;
}
#method_after
private StorageDomain updateStorageDomainInMemoryVolumes(List<DiskImage> disksList) {
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(VmUtils.getSnapshotMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
    StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getParameters().getStoragePoolId(), memoryDisksList, getVmDisksDummies(), getVm());
    disksList.addAll(memoryDisksList);
    return storageDomain;
}
#end_block

#method_before
public static Map<String, Object> getVideoDeviceSpecParams(VmBase vmBase) {
    Map<String, Object> specParams = new HashMap<>();
    getVideoDeviceParams(vmBase).forEach((k, v) -> specParams.put(k, String.valueOf(v)));
    return specParams;
}
#method_after
public static Map<String, Object> getVideoDeviceSpecParams(VmBase vmBase) {
    return getVideoDeviceSettings(vmBase).entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> String.valueOf(e.getValue())));
}
#end_block

#method_before
public static int totalVideoRAMSizeMb(VM vm) {
    Map<String, Integer> params = getVideoDeviceParams(vm.getStaticData());
    return (params.getOrDefault(VdsProperties.VIDEO_RAM, 0) + params.getOrDefault(VdsProperties.VIDEO_VRAM, 0) + 1023) / 1024;
}
#method_after
public static int totalVideoRAMSizeMb(VM vm) {
    Map<String, Integer> settings = getVideoDeviceSettings(vm.getStaticData());
    return (settings.getOrDefault(VdsProperties.VIDEO_RAM, 0) + settings.getOrDefault(VdsProperties.VIDEO_VRAM, 0) + 1023) / 1024;
}
#end_block

#method_before
public void enablePluginInvocation() {
    canInvokePlugins = true;
    // Try to initialize all plugins after the browser event loop returns
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            for (Plugin plugin : getPlugins()) {
                initPlugin(plugin);
            }
            UiPluginsInitializedEvent.fire(PluginManager.this);
        }
    });
}
#method_after
public void enablePluginInvocation() {
    canInvokePlugins = true;
    // Try to initialize all plugins after the browser event loop returns
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            initAllPlugins();
        }
    });
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        MigrationBandwidthLimitType migrationBandwidthLimitType = getCluster().getMigrationBandwidthLimitType();
        if (migrationBandwidthLimitType == MigrationBandwidthLimitType.CUSTOM) {
            maxBandwidth = getCluster().getCustomMigrationNetworkBandwidth() / clusterMigrationPolicy.getMaxMigrations();
        }
        autoConverge = effectiveMigrationPolicy.isAutoConvergence();
        migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        autoConverge = effectiveMigrationPolicy.isAutoConvergence();
        migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVmDynamicDao().get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getClusterCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.profileValid(vm.getClusterId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked())) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (macPool.getAvailableMacsCount() <= 0) {
        addValidationMessage(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    macPool = getMacPool();
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVmDynamicDao().get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getClusterCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked())) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (macPool.getAvailableMacsCount() <= 0) {
        addValidationMessage(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    this.setVmName(getVmStaticDao().get(getParameters().getVmId()).getName());
    VmNic iface = getVmNicDao().get(getParameters().getInterfaceId());
    if (iface != null) {
        interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getDescription();
        if (interType != null) {
            addCustomValue("InterfaceType", interType);
        }
        new ExternalNetworkManager(iface).deallocateIfExternal();
        // return mac to pool
        getMacPool().freeMac(iface.getMacAddress());
    }
    // remove from db
    TransactionSupport.executeInNewTransaction(() -> {
        vmStaticDao.incrementDbGeneration(getVm().getId());
        getVmNicDao().remove(getParameters().getInterfaceId());
        getDbFacade().getVmNetworkStatisticsDao().remove(getParameters().getInterfaceId());
        getDbFacade().getVmDeviceDao().remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
        setSucceeded(true);
        return null;
    });
}
#method_after
@Override
protected void executeVmCommand() {
    this.setVmName(getVmStaticDao().get(getParameters().getVmId()).getName());
    VmNic iface = getVmNicDao().get(getParameters().getInterfaceId());
    if (iface != null) {
        interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getDescription();
        if (interType != null) {
            addCustomValue("InterfaceType", interType);
        }
        new ExternalNetworkManager(iface).deallocateIfExternal();
        // return mac to pool
        getMacPool().freeMac(iface.getMacAddress());
    }
    // remove from db
    TransactionSupport.executeInNewTransaction(() -> {
        vmStaticDao.incrementDbGeneration(getParameters().getVmId());
        getVmNicDao().remove(getParameters().getInterfaceId());
        getDbFacade().getVmNetworkStatisticsDao().remove(getParameters().getInterfaceId());
        getDbFacade().getVmDeviceDao().remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
        setSucceeded(true);
        return null;
    });
}
#end_block

#method_before
private void initCommandBase() {
    initUser();
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext.getJob() != null) {
        setJobId(executionContext.getJob().getId());
    } else if (executionContext.getStep() != null) {
        setJobId(executionContext.getStep().getJobId());
    }
    setCorrelationId(_parameters.getCorrelationId());
}
#method_after
private void initCommandBase() {
    initUser();
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext.getJob() != null) {
        setJobId(executionContext.getJob().getId());
    } else if (executionContext.getStep() != null) {
        setJobId(executionContext.getStep().getJobId());
    }
    setCorrelationId(parameters.getCorrelationId());
}
#end_block

#method_before
public VdcReturnValueBase validateOnly() {
    setActionMessageParameters();
    getReturnValue().setValid(internalValidate());
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    return _returnValue;
}
#method_after
public VdcReturnValueBase validateOnly() {
    setActionMessageParameters();
    getReturnValue().setValid(internalValidate());
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    return returnValue;
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand(), getCallback() != null);
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void cleanUpCompensationData() {
    if (!(getCompensationContext() instanceof NoOpCompensationContext)) {
        getBusinessEntitySnapshotDao().removeAllForCommandId(commandId);
    }
}
#method_after
private void cleanUpCompensationData() {
    getCompensationContext().resetCompensation();
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
private void setActionState() {
    // Currently it was decided that ROLLBACK_FLOW will cause endWithFailure
    if (isEndSuccessfully()) {
        _actionState = CommandActionState.END_SUCCESS;
    } else {
        _actionState = CommandActionState.END_FAILURE;
    }
}
#method_after
private void setActionState() {
    // Currently it was decided that ROLLBACK_FLOW will cause endWithFailure
    if (isEndSuccessfully()) {
        actionState = CommandActionState.END_SUCCESS;
    } else {
        actionState = CommandActionState.END_FAILURE;
    }
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
        persistCommandIfNeeded();
    }
}
#end_block

#method_before
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            _actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#method_after
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#end_block

#method_before
void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#method_after
protected void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : consumptionParameters) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, EngineMessage.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            consumptionParameters.stream().filter(parameter -> parameter.getQuotaGuid() != null).filter(parameter -> !Guid.Empty.equals(parameter.getQuotaGuid())).filter(parameter -> QuotaConsumptionParameter.QuotaAction.RELEASE != parameter.getQuotaAction()).map(parameter -> new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, EngineMessage.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA)).forEach(quotaPermissionList::add);
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            setCommandStatus(CommandStatus.FAILED);
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group ").append(permSubject.getActionGroup().name()).append(" with role type ").append(permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#method_after
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    permissionSubjects.stream().filter(permSubject -> permSubject.getObjectId() != null).forEach(permSubject -> {
        // Add comma when there are more than one entity affected.
        if (builder.length() != 0) {
            builder.append(", ");
        }
        builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
        if (permSubject.getActionGroup() != null) {
            builder.append("Action group ").append(permSubject.getActionGroup().name()).append(" with role type ").append(permSubject.getActionGroup().getRoleType().name());
        }
    });
    return builder;
}
#end_block

#method_before
@Override
public T getParameters() {
    return _parameters;
}
#method_after
@Override
public T getParameters() {
    return parameters;
}
#end_block

#method_before
public VdcReturnValueBase getReturnValue() {
    if (_returnValue == null) {
        _returnValue = createReturnValue();
    }
    return _returnValue;
}
#method_after
public VdcReturnValueBase getReturnValue() {
    if (returnValue == null) {
        returnValue = createReturnValue();
    }
    return returnValue;
}
#end_block

#method_before
public void setReturnValue(VdcReturnValueBase returnValue) {
    _returnValue = returnValue;
}
#method_after
public void setReturnValue(VdcReturnValueBase returnValue) {
    this.returnValue = returnValue;
}
#end_block

#method_before
protected String getDescription() {
    return _description;
}
#method_after
protected String getDescription() {
    return description;
}
#end_block

#method_before
protected void setDescription(String value) {
    _description = value;
}
#method_after
protected void setDescription(String value) {
    description = value;
}
#end_block

#method_before
private void processExceptionToClient(EngineFault fault) {
    fault.setSessionID(getParameters().getSessionId());
    _returnValue.getExecuteFailedMessages().add(fault.getError().name());
    _returnValue.setFault(fault);
}
#method_after
private void processExceptionToClient(EngineFault fault) {
    fault.setSessionID(getParameters().getSessionId());
    returnValue.getExecuteFailedMessages().add(fault.getError().name());
    returnValue.setFault(fault);
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        CommandCoordinatorUtil.startPollingTask(taskID);
    }
}
#method_after
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    taskIds.forEach(CommandCoordinatorUtil::startPollingTask);
}
#end_block

#method_before
protected ArrayList<Guid> getTaskIdList() {
    return getParameters().getParentCommand() != VdcActionType.Unknown ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
}
#method_after
protected ArrayList<Guid> getTaskIdList() {
    return (getParameters().getParentCommand() != VdcActionType.Unknown && !parentHasCallback()) ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
}
#end_block

#method_before
protected LockProperties getLockProperties() {
    LockProperties lockProperties = _parameters.getLockProperties();
    if (lockProperties == null) {
        lockProperties = applyLockProperties(getLockingPropertiesSettings());
        _parameters.setLockProperties(lockProperties);
    }
    return lockProperties;
}
#method_after
protected LockProperties getLockProperties() {
    LockProperties lockProperties = parameters.getLockProperties();
    if (lockProperties == null) {
        lockProperties = applyLockProperties(getLockingPropertiesSettings());
        parameters.setLockProperties(lockProperties);
    }
    return lockProperties;
}
#end_block

#method_before
@Override
public Object runInTransaction() {
    if (_actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
    } else {
        endActionInTransactionScope();
    }
    return null;
}
#method_after
@Override
public Object runInTransaction() {
    if (actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
    } else {
        endActionInTransactionScope();
    }
    return null;
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addValidationMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        validationResult.getVariableReplacements().forEach(this::addValidationMessage);
    }
    return validationResult.isValid();
}
#end_block

#method_before
@Override
public void setCorrelationId(String correlationId) {
    // correlation ID thread local variable is set for non multi-action
    if (!_parameters.getMultipleAction()) {
        CorrelationIdTracker.setCorrelationId(correlationId);
    }
    super.setCorrelationId(correlationId);
}
#method_after
@Override
public void setCorrelationId(String correlationId) {
    // correlation ID thread local variable is set for non multi-action
    if (!parameters.getMultipleAction()) {
        CorrelationIdTracker.setCorrelationId(correlationId);
    }
    super.setCorrelationId(correlationId);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), false);
}
#method_after
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), getCallback() != null, callbackTriggeredByEvent());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback);
}
#method_after
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback, callbackTriggeredByEvent());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback, boolean callbackWaitingForEvent) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        commandEntity.setWaitingForEvent(callbackWaitingForEvent);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getSessionSeqId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandCoordinatorUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled()), getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandEntity executedCmdEntity = buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled());
            executedCmdEntity.setWaitingForEvent(cmdEntity.isCallbackEnabled() ? callbackTriggeredByEvent() : false);
            CommandCoordinatorUtil.persistCommand(executedCmdEntity, getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
protected CommandActionState getActionState() {
    return _actionState;
}
#method_after
protected CommandActionState getActionState() {
    return actionState;
}
#end_block

#method_before
protected void subscribe(String eventKey) {
    CommandEntity commandEntity = buildCommandEntity(getCommandId(), false);
    CommandCoordinatorUtil.subscribe(eventKey, commandEntity);
}
#method_after
protected void subscribe(String eventKey) {
    CommandEntity commandEntity = buildCommandEntity(getCommandId(), true);
    commandEntity.setWaitingForEvent(true);
    CommandCoordinatorUtil.subscribe(eventKey, commandEntity);
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    initChildHierarchy();
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    persistCommand(cmdEntity);
    saveCommandContext(cmdEntity.getId(), cmdContext);
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    commandsRepository.persistCommand(cmdEntity, cmdContext);
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallbackNotified(existingCmdEntity.isCallbackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallbackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && commandsCache.get(cmdEntity.getParentCommandId()) != null && commandsCache.get(cmdEntity.getParentCommandId()).isCallbackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallbackNotified()) {
            cmdExecutor.addToCallbackMap(cmdEntity);
        }
    }
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity) {
    commandsRepository.persistCommand(cmdEntity);
}
#end_block

#method_before
@Override
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    commandsCache.persistCommandAssociatedEntities(cmdAssociatedEntities);
}
#method_after
@Override
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    commandsRepository.persistCommandAssociatedEntities(cmdAssociatedEntities);
}
#end_block

#method_before
@Override
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return commandsCache.getCommandIdsByEntityId(entityId);
}
#method_after
@Override
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return commandsRepository.getCommandIdsByEntityId(entityId);
}
#end_block

#method_before
@Override
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return commandsCache.getCommandAssociatedEntities(cmdId);
}
#method_after
@Override
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return commandsRepository.getCommandAssociatedEntities(cmdId);
}
#end_block

#method_before
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, SubjectEntity... subjectEntities) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters, cmdContext, subjectEntities);
}
#method_after
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallback callBack = command.getCallback();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null, false);
    if (callBack != null) {
        commandsRepository.addToCallbackMap(command.getCommandId(), new CallbackTiming(callBack, Config.<Integer>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds)));
    }
    return cmdExecutor.executeAsyncCommand(command, cmdContext);
}
#end_block

#method_before
@Override
public CommandEntity getCommandEntity(Guid commandId) {
    return Guid.isNullOrEmpty(commandId) ? null : commandsCache.get(commandId);
}
#method_after
@Override
public CommandEntity getCommandEntity(Guid commandId) {
    return commandsRepository.getCommandEntity(commandId);
}
#end_block

#method_before
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    return buildCommand(commandsCache.get(commandId), contextsCache.get(commandId));
}
#method_after
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    return commandsRepository.retrieveCommand(commandId);
}
#end_block

#method_before
@Override
public CommandStatus getCommandStatus(final Guid commandId) {
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        return cmdEntity.getCommandStatus();
    }
    return CommandStatus.UNKNOWN;
}
#method_after
@Override
public CommandStatus getCommandStatus(final Guid commandId) {
    return commandsRepository.getCommandStatus(commandId);
}
#end_block

#method_before
@Override
public void removeCommand(final Guid commandId) {
    commandsCache.remove(commandId);
    contextsCache.remove(commandId);
    updateCmdHierarchy(commandId);
}
#method_after
@Override
public void removeCommand(final Guid commandId) {
    commandsRepository.removeCommand(commandId);
}
#end_block

#method_before
@Override
public void removeAllCommandsBeforeDate(final DateTime cutoff) {
    commandsCache.removeAllCommandsBeforeDate(cutoff);
    synchronized (LOCK) {
        childHierarchyInitialized = false;
    }
}
#method_after
@Override
public void removeAllCommandsBeforeDate(final DateTime cutoff) {
    commandsRepository.removeAllCommandsBeforeDate(cutoff);
}
#end_block

#method_before
@Override
public void updateCommandData(final Guid commandId, final Map<String, Serializable> data) {
    commandsCache.updateCommandData(commandId, data);
}
#method_after
@Override
public void updateCommandData(final Guid commandId, final Map<String, Serializable> data) {
    commandsRepository.updateCommandData(commandId, data);
}
#end_block

#method_before
@Override
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsCache.updateCommandStatus(commandId, status);
}
#method_after
@Override
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsRepository.updateCommandStatus(commandId, status);
}
#end_block

#method_before
@Override
public void updateCommandExecuted(Guid commandId) {
    commandsCache.updateCommandExecuted(commandId);
}
#method_after
@Override
public void updateCommandExecuted(Guid commandId) {
    commandsRepository.updateCommandExecuted(commandId);
}
#end_block

#method_before
@Override
public boolean hasCommandEntitiesWithRootCommandId(Guid rootCommandId) {
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.keySet()) {
        cmdEntity = commandsCache.get(cmdId);
        if (cmdEntity != null && !Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && !cmdEntity.getRootCommandId().equals(cmdId) && cmdEntity.getRootCommandId().equals(rootCommandId)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean hasCommandEntitiesWithRootCommandId(Guid rootCommandId) {
    return commandsRepository.hasCommandEntitiesWithRootCommandId(rootCommandId);
}
#end_block

#method_before
@Override
public List<Guid> getChildCommandIds(Guid cmdId) {
    initChildHierarchy();
    if (childHierarchy.containsKey(cmdId)) {
        return childHierarchy.get(cmdId);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<Guid> getChildCommandIds(Guid cmdId) {
    return commandsRepository.getChildCommandIds(cmdId);
}
#end_block

#method_before
@Override
public List<CommandEntity> getChildCmdsByRootCmdId(Guid cmdId) {
    return commandsCache.getChildCmdsByParentCmdId(cmdId);
}
#method_after
@Override
public List<CommandEntity> getChildCmdsByRootCmdId(Guid cmdId) {
    return commandsRepository.getChildCmdsByParentCmdId(cmdId);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public ArrayList<AsyncTaskCreationInfo> getAllTasksInfo(Guid storagePoolID) {
    return (ArrayList<AsyncTaskCreationInfo>) runVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#method_after
@Override
public ArrayList<AsyncTaskCreationInfo> getAllTasksInfo(Guid storagePoolID) {
    return (ArrayList<AsyncTaskCreationInfo>) runVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<Guid, AsyncTaskStatus> getAllTasksStatuses(Guid storagePoolID) {
    return (Map<Guid, AsyncTaskStatus>) runVdsCommand(VDSCommandType.SPMGetAllTasksStatuses, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#method_after
@Override
public Map<Guid, AsyncTaskStatus> getAllTasksStatuses(Guid storagePoolID) {
    return (Map<Guid, AsyncTaskStatus>) runVdsCommand(VDSCommandType.SPMGetAllTasksStatuses, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#end_block

#method_before
@Override
public void subscribe(String eventKey, CommandEntity commandEntity) {
    getResourceManager().subscribe(new CoCoEventSubscriber(eventKey, commandEntity));
}
#method_after
@Override
public void subscribe(String eventKey, CommandEntity commandEntity) {
    commandsRepository.persistCommand(commandEntity);
    CoCoEventSubscriber subscriber = new CoCoEventSubscriber(eventKey, commandEntity, commandsRepository);
    getResourceManager().subscribe(subscriber);
    commandsRepository.addEventSubscription(commandEntity, subscriber);
}
#end_block

#method_before
public static Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, SubjectEntity... subjectEntities) {
    return coco.executeAsyncCommand(actionType, parameters, cmdContext, subjectEntities);
}
#method_after
public static Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext) {
    return coco.executeAsyncCommand(actionType, parameters, cmdContext);
}
#end_block

#method_before
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    params.setFenceAgents(vds.getFenceAgents());
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, params);
    if (vds.isOvirtNode()) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
            return doAction(VdcActionType.UpgradeOvirtNode, params, action);
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#method_after
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    // Explicitly set null, to be clear we don't want to update fence agents.
    params.setFenceAgents(null);
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, params);
    if (vds.isOvirtNode()) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
            return doAction(VdcActionType.UpgradeOvirtNode, params, action);
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#end_block

#method_before
@Mapping(from = OpenStackNetworkProvider.class, to = Provider.class)
public static Provider<OpenstackNetworkProviderProperties> map(OpenStackNetworkProvider model, Provider<OpenstackNetworkProviderProperties> template) {
    Provider<OpenstackNetworkProviderProperties> entity = template != null ? template : new Provider<>();
    if (model.isSetType()) {
        entity.setType(map(model.getType()));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetUrl()) {
        entity.setUrl(model.getUrl());
    }
    if (model.isSetRequiresAuthentication()) {
        entity.setRequiringAuthentication(model.isRequiresAuthentication());
    }
    if (model.isSetUsername()) {
        entity.setUsername(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setPassword(model.getPassword());
    }
    if (model.isSetAuthenticationUrl()) {
        entity.setAuthUrl(model.getAuthenticationUrl());
    }
    if (model.isSetProperties()) {
        Map<String, String> map = new HashMap<>();
        for (Property property : model.getProperties().getProperties()) {
            map.put(property.getName(), property.getValue());
        }
        entity.setCustomProperties(map);
    }
    OpenstackNetworkProviderProperties additionalProperties = new OpenstackNetworkProviderProperties();
    if (model.isSetTenantName()) {
        additionalProperties.setTenantName(model.getTenantName());
    }
    if (model.isSetPluginType()) {
        additionalProperties.setPluginType(map(model.getPluginType()));
    }
    if (model.isSetAgentConfiguration()) {
        additionalProperties.setAgentConfiguration(map(model.getAgentConfiguration(), null));
    }
    entity.setAdditionalProperties(additionalProperties);
    return entity;
}
#method_after
@Mapping(from = OpenStackNetworkProvider.class, to = Provider.class)
public static Provider<OpenstackNetworkProviderProperties> map(OpenStackNetworkProvider model, Provider<OpenstackNetworkProviderProperties> template) {
    Provider<OpenstackNetworkProviderProperties> entity = template != null ? template : new Provider<>();
    if (model.isSetType()) {
        entity.setType(mapProviderType(model.getType()));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetUrl()) {
        entity.setUrl(model.getUrl());
    }
    if (model.isSetRequiresAuthentication()) {
        entity.setRequiringAuthentication(model.isRequiresAuthentication());
    }
    if (model.isSetUsername()) {
        entity.setUsername(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setPassword(model.getPassword());
    }
    if (model.isSetAuthenticationUrl()) {
        entity.setAuthUrl(model.getAuthenticationUrl());
    }
    if (model.isSetProperties()) {
        Map<String, String> map = new HashMap<>();
        for (Property property : model.getProperties().getProperties()) {
            map.put(property.getName(), property.getValue());
        }
        entity.setCustomProperties(map);
    }
    OpenstackNetworkProviderProperties additionalProperties = new OpenstackNetworkProviderProperties();
    if (model.isSetTenantName()) {
        additionalProperties.setTenantName(model.getTenantName());
    }
    if (model.isSetPluginType()) {
        additionalProperties.setPluginType(map(model.getPluginType()));
    }
    if (model.isSetAgentConfiguration()) {
        additionalProperties.setAgentConfiguration(map(model.getAgentConfiguration(), null));
    }
    if (model.isSetReadOnly()) {
        additionalProperties.setReadOnly(model.isReadOnly());
    }
    entity.setAdditionalProperties(additionalProperties);
    return entity;
}
#end_block

#method_before
@Mapping(from = Provider.class, to = OpenStackNetworkProvider.class)
public static OpenStackNetworkProvider map(Provider<OpenstackNetworkProviderProperties> entity, OpenStackNetworkProvider template) {
    OpenStackNetworkProvider model = template != null ? template : new OpenStackNetworkProvider();
    model.setType(map(entity.getType()));
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getUrl() != null) {
        model.setUrl(entity.getUrl());
    }
    if (entity.getAuthUrl() != null) {
        model.setAuthenticationUrl(entity.getAuthUrl());
    }
    model.setRequiresAuthentication(entity.isRequiringAuthentication());
    if (entity.getUsername() != null) {
        model.setUsername(entity.getUsername());
    }
    // The password isn't mapped for security reasons.
    // if (entity.getPassword() != null) {
    // model.setPassword(entity.getPassword());
    // }
    Map<String, String> customProperties = entity.getCustomProperties();
    if (customProperties != null) {
        Properties properties = new Properties();
        for (Map.Entry<String, String> entry : customProperties.entrySet()) {
            Property property = new Property();
            property.setName(entry.getKey());
            property.setValue(entry.getValue());
            properties.getProperties().add(property);
        }
        model.setProperties(properties);
    }
    OpenstackNetworkProviderProperties additionalProperties = entity.getAdditionalProperties();
    if (additionalProperties != null) {
        if (additionalProperties.getTenantName() != null) {
            model.setTenantName(additionalProperties.getTenantName());
        }
        if (additionalProperties.getPluginType() != null) {
            model.setPluginType(map(additionalProperties.getPluginType()));
        }
        if (additionalProperties.getAgentConfiguration() != null) {
            model.setAgentConfiguration(map(additionalProperties.getAgentConfiguration(), null));
        }
    }
    return model;
}
#method_after
@Mapping(from = Provider.class, to = OpenStackNetworkProvider.class)
public static OpenStackNetworkProvider map(Provider<OpenstackNetworkProviderProperties> entity, OpenStackNetworkProvider template) {
    OpenStackNetworkProvider model = template != null ? template : new OpenStackNetworkProvider();
    model.setType(mapProviderType(entity.getType()));
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getUrl() != null) {
        model.setUrl(entity.getUrl());
    }
    if (entity.getAuthUrl() != null) {
        model.setAuthenticationUrl(entity.getAuthUrl());
    }
    model.setRequiresAuthentication(entity.isRequiringAuthentication());
    if (entity.getUsername() != null) {
        model.setUsername(entity.getUsername());
    }
    // The password isn't mapped for security reasons.
    // if (entity.getPassword() != null) {
    // model.setPassword(entity.getPassword());
    // }
    Map<String, String> customProperties = entity.getCustomProperties();
    if (customProperties != null) {
        Properties properties = new Properties();
        for (Map.Entry<String, String> entry : customProperties.entrySet()) {
            Property property = new Property();
            property.setName(entry.getKey());
            property.setValue(entry.getValue());
            properties.getProperties().add(property);
        }
        model.setProperties(properties);
    }
    OpenstackNetworkProviderProperties additionalProperties = entity.getAdditionalProperties();
    if (additionalProperties != null) {
        if (additionalProperties.getTenantName() != null) {
            model.setTenantName(additionalProperties.getTenantName());
        }
        if (additionalProperties.getPluginType() != null) {
            model.setPluginType(map(additionalProperties.getPluginType()));
        }
        if (additionalProperties.getAgentConfiguration() != null) {
            model.setAgentConfiguration(map(additionalProperties.getAgentConfiguration(), null));
        }
    }
    return model;
}
#end_block

#method_before
@Override
protected void buildVmGraphicsDevices() {
    boolean graphicsOverriden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = buildVmGraphicsSpecParamsFromVm(infos);
    if (graphicsOverriden) {
        buildVmGraphicsDevicesOverriden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#method_after
@Override
protected void buildVmGraphicsDevices() {
    boolean graphicsOverriden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = null;
    if (infos != null) {
        specParamsFromVm = new HashMap();
        addVmGraphicsOptions(infos, specParamsFromVm);
    }
    if (graphicsOverriden) {
        buildVmGraphicsDevicesOverriden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    addNetworkFiltersToNic(struct);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    addNetworkFiltersToNic(struct, vmInterface);
}
#end_block

#method_before
public static void addNetworkFiltersToNic(Map<String, Object> struct) {
    if (Config.<Boolean>getValue(ConfigValues.EnableMACAntiSpoofingFilterRules)) {
        struct.put(VdsProperties.NW_FILTER, NetworkFilters.NO_MAC_SPOOFING.getFilterName());
    }
}
#method_after
public static void addNetworkFiltersToNic(Map<String, Object> struct, VmNic vmNic) {
    final NetworkFilter networkFilter = fetchVnicProfileNetworkFilter(vmNic);
    if (networkFilter != null) {
        final String networkFilterName = networkFilter.getName();
        struct.put(VdsProperties.NW_FILTER, networkFilterName);
    }
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion());
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = getOsRepository().getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    } else if ("sata".equals(cdInterface)) {
        // SATA slot 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion());
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        } else if ("sata".equals(cdInterface)) {
            // SATA slot 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        if (osRepository.get64bitOss().contains(vm.getOs())) {
            ConfigValues config = vm.getClusterArch() == ArchitectureType.ppc64 ? ConfigValues.VMPpc64BitMaxMemorySizeInMB : ConfigValues.VM64BitMaxMemorySizeInMB;
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(config, vm.getCompatibilityVersion().getValue()));
        } else {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB));
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    // ensure compatibility with VDSM <= 4.16
    addVmGraphicsOptions(vm.getGraphicsInfos(), createInfo, true);
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        if (osRepository.get64bitOss().contains(vm.getOs())) {
            ConfigValues config = vm.getClusterArch() == ArchitectureType.ppc64 ? ConfigValues.VMPpc64BitMaxMemorySizeInMB : ConfigValues.VM64BitMaxMemorySizeInMB;
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(config, vm.getCompatibilityVersion().getValue()));
        } else {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB));
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
protected void addVmGraphicsOptions(Map<GraphicsType, GraphicsInfo> infos, Map<String, Object> params, boolean legacyNames) {
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        params.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        params.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
        if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
            params.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
            params.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString()));
        }
    }
    if (infos != null && infos.containsKey(GraphicsType.VNC)) {
        String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = vm.getDefaultVncKeyboardLayout();
            if (keyboardLayout == null) {
                keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
            }
        }
        if (legacyNames) {
            params.put(VdsProperties.KeyboardLayout, keyboardLayout);
        } else {
            params.put(VdsProperties.KeyboardMap, keyboardLayout);
        }
        params.put(VdsProperties.TabletEnable, "true");
    }
}
#method_after
protected void addVmGraphicsOptions(Map<GraphicsType, GraphicsInfo> infos, Map<String, Object> params) {
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        params.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        params.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
        if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
            params.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
            params.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString()));
        }
    }
    if (infos != null && infos.containsKey(GraphicsType.VNC)) {
        String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = vm.getDefaultVncKeyboardLayout();
            if (keyboardLayout == null) {
                keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
            }
        }
        params.put(VdsProperties.KeyboardMap, keyboardLayout);
    }
}
#end_block

#method_before
private void vmwareProviderChanged() {
    Provider<VmwareVmProviderProperties> provider = getVmwareProviders().getSelectedItem();
    if (provider == null) {
        provider = new Provider<>();
        provider.setAdditionalProperties(new VmwareVmProviderProperties());
    }
    getUsername().setEntity(provider.getUsername());
    getPassword().setEntity(provider.getPassword());
    VmwareVmProviderProperties properties = (VmwareVmProviderProperties) provider.getAdditionalProperties();
    getvCenter().setEntity(properties.getvCenter());
    getEsx().setEntity(properties.getEsx());
    Pair<String, String> dcAndCluster = splitToDcAndCluster(properties.getDataCenter());
    getVmwareDatacenter().setEntity(dcAndCluster.getFirst());
    getVmwareCluster().setEntity(dcAndCluster.getSecond());
    getVerify().setEntity(properties.isVerifySSL());
    if (properties.getProxyHostId() == null) {
        getProxyHosts().setSelectedItem(null);
    } else {
        for (VDS host : getProxyHosts().getItems()) {
            if (host != null && host.getId().equals(properties.getProxyHostId())) {
                getProxyHosts().setSelectedItem(host);
                break;
            }
        }
    }
}
#method_after
private void vmwareProviderChanged() {
    Provider<VmwareVmProviderProperties> provider = getVmwareProviders().getSelectedItem();
    if (provider == null) {
        provider = new Provider<>();
        provider.setAdditionalProperties(new VmwareVmProviderProperties());
    }
    getUsername().setEntity(provider.getUsername());
    getPassword().setEntity(provider.getPassword());
    VmwareVmProviderProperties properties = provider.getAdditionalProperties();
    getvCenter().setEntity(properties.getvCenter());
    getEsx().setEntity(properties.getEsx());
    Pair<String, String> dcAndCluster = splitToDcAndCluster(properties.getDataCenter());
    getVmwareDatacenter().setEntity(dcAndCluster.getFirst());
    getVmwareCluster().setEntity(dcAndCluster.getSecond());
    getVerify().setEntity(properties.isVerifySSL());
    if (properties.getProxyHostId() == null) {
        getProxyHosts().setSelectedItem(null);
    } else {
        for (VDS host : getProxyHosts().getItems()) {
            if (host != null && host.getId().equals(properties.getProxyHostId())) {
                getProxyHosts().setSelectedItem(host);
                break;
            }
        }
    }
}
#end_block

#method_before
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters == null || dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#method_after
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#end_block

#method_before
public void loadVmsFromVmware() {
    clearProblem();
    if (!validateVmwareConfiguration()) {
        return;
    }
    loadVMsFromExternalProvider(OriginType.VMWARE, getUrl(), getUsername().getEntity(), getPassword().getEntity());
}
#method_after
public void loadVmsFromVmware() {
    clearProblem();
    if (!validateVmwareConfiguration()) {
        return;
    }
    Guid proxyId = getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.VMWARE, getUrl(), getUsername().getEntity(), getPassword().getEntity(), proxyId);
}
#end_block

#method_before
public void loadVmsFromXen() {
    clearProblem();
    if (!validateXenConfiguration()) {
        return;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    loadVMsFromExternalProvider(OriginType.XEN, getXenUri().getEntity(), "", "");
}
#method_after
public void loadVmsFromXen() {
    clearProblem();
    if (!validateXenConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    // $NON-NLS-1$ //$NON-NLS-2$
    loadVMsFromExternalProvider(OriginType.XEN, getXenUri().getEntity(), "", "", proxyId);
}
#end_block

#method_before
public void loadVmsFromKvm() {
    clearProblem();
    if (!validateKvmConfiguration()) {
        return;
    }
    loadVMsFromExternalProvider(OriginType.KVM, getKvmUri().getEntity(), getKvmUsername().getEntity(), getKvmPassword().getEntity());
}
#method_after
public void loadVmsFromKvm() {
    clearProblem();
    if (!validateKvmConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.KVM, getKvmUri().getEntity(), getKvmUsername().getEntity(), getKvmPassword().getEntity(), proxyId);
}
#end_block

#method_before
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password) {
    startProgress();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        vm.setOrigin(type);
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    Guid proxyId = null;
    switch(type) {
        case XEN:
            proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
            break;
        case KVM:
            proxyId = getKvmProxyHosts().getSelectedItem() != null ? getKvmProxyHosts().getSelectedItem().getId() : null;
            break;
        case VMWARE:
        default:
            proxyId = getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null;
            break;
    }
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type);
}
#method_after
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password, Guid proxyId) {
    startProgress();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type);
}
#end_block

#method_before
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    addGraphicsDeviceFromExternalProvider(vmStatic, xmlRpcStruct.get(VdsProperties.GRAPHICS_DEVICE), xmlRpcStruct.get(VdsProperties.VIDEO_DEVICE));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            nic.setVmId(vmStatic.getId());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#method_after
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    addGraphicsDeviceFromExternalProvider(vmStatic, xmlRpcStruct);
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            nic.setVmId(vmStatic.getId());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#end_block

#method_before
private static void addGraphicsDeviceFromExternalProvider(VmStatic vmStatic, Object graphicsName, Object videoName) {
    // try to add the displaytype and graphics if ovirt support the channels
    if (graphicsName != null && videoName != null) {
        try {
            vmStatic.setDefaultDisplayType(DisplayType.valueOf(videoName.toString()));
        } catch (IllegalArgumentException ex) {
            return;
        }
        GraphicsType gt = GraphicsType.fromString(graphicsName.toString());
        if (gt == null) {
            return;
        }
        GraphicsDevice gr = new GraphicsDevice(gt.getCorrespondingDeviceType());
        gr.setId(new VmDeviceId(Guid.newGuid(), vmStatic.getId()));
        vmStatic.getManagedDeviceMap().put(gr.getDeviceId(), gr);
        VmDevice vmDevice = new VmDevice();
        vmDevice.setId(new VmDeviceId(Guid.newGuid(), vmStatic.getId()));
        vmDevice.setType(VmDeviceGeneralType.VIDEO);
        vmDevice.setDevice(vmStatic.getDefaultDisplayType().getDefaultVmDeviceType().getName());
        vmDevice.setIsManaged(true);
        vmDevice.setIsPlugged(true);
        vmDevice.setIsReadOnly(false);
        vmDevice.setAddress("");
        vmStatic.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    }
}
#method_after
private static void addGraphicsDeviceFromExternalProvider(VmStatic vmStatic, Map<String, Object> xmlRpcStruct) {
    Object graphicsName = xmlRpcStruct.get(VdsProperties.GRAPHICS_DEVICE);
    Object videoName = xmlRpcStruct.get(VdsProperties.VIDEO_DEVICE);
    if (graphicsName == null || videoName == null) {
        return;
    }
    try {
        vmStatic.setDefaultDisplayType(DisplayType.valueOf(videoName.toString()));
    } catch (IllegalArgumentException ex) {
        log.error("Illegal video name '{}'.", videoName.toString());
        return;
    }
    GraphicsType graphicsType = GraphicsType.fromString(graphicsName.toString());
    if (graphicsType == null) {
        log.error("Illegal graphics name '{}'.", graphicsName.toString());
        return;
    }
    VmDeviceCommonUtils.addGraphicsDevice(vmStatic, graphicsType.getCorrespondingDeviceType());
    VmDeviceCommonUtils.addVideoDevice(vmStatic);
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void processImages() {
    if (getVm().getOrigin() == OriginType.KVM) {
        DiskImage disk = getVm().getImages().get(0);
        if (disk != null) {
            disk.setBoot(true);
        }
    }
    ArrayList<Guid> diskIds = new ArrayList<>();
    for (DiskImage image : getVm().getImages()) {
        Guid diskId = createDisk(image);
        diskIds.add(diskId);
    }
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#method_after
@Override
protected void processImages() {
    if (getVm().getOrigin() == OriginType.KVM && !getVm().getImages().isEmpty()) {
        getVm().getImages().get(0).setBoot(true);
    }
    ArrayList<Guid> diskIds = new ArrayList<>();
    for (DiskImage image : getVm().getImages()) {
        Guid diskId = createDisk(image);
        diskIds.add(diskId);
    }
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void addVmToDb() {
    super.addVmToDb();
    if (getVm().getOrigin() == OriginType.KVM) {
        ImportUtils.updateGraphicsDevices(getVm().getStaticData(), getStoragePool().getCompatibilityVersion());
        VmDeviceDao dao = DbFacade.getInstance().getVmDeviceDao();
        dao.saveAll(getVm().getStaticData().getManagedDeviceMap().values());
    }
}
#method_after
@Override
protected void addVmToDb() {
    super.addVmToDb();
    if (getVm().getOrigin() == OriginType.KVM) {
        ImportUtils.updateGraphicsDevices(getVm().getStaticData(), getStoragePool().getCompatibilityVersion());
        getVmDeviceDao().saveAll(getVm().getStaticData().getManagedDeviceMap().values());
    }
}
#end_block

#method_before
public static void refreshVmsToolsVersion(Guid poolId, Set<String> isoList) {
    String latestVersion = getLatestGuestToolsVersion(isoList);
    if (latestVersion == null) {
        return;
    }
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllForStoragePool(poolId);
    for (VM vm : vms) {
        if (vm.getAppList() != null && vm.getAppList().toLowerCase().contains("rhev-tools")) {
            Matcher m = TOOLS_PATTERN.matcher(vm.getAppList().toLowerCase());
            if (m.matches() && m.groupCount() > 0) {
                String toolsVersion = m.group(1);
                if (toolsVersion.compareTo(latestVersion) < 0 && vm.getGuestAgentStatus() != GuestAgentStatus.UpdateNeeded) {
                    updateGetsAgentStatus(vm, GuestAgentStatus.UpdateNeeded);
                } else {
                    updateGetsAgentStatus(vm, GuestAgentStatus.Exists);
                }
            }
        } else {
            updateGetsAgentStatus(vm, GuestAgentStatus.DoesntExist);
        }
    }
}
#method_after
public static void refreshVmsToolsVersion(Guid poolId, Set<String> isoList) {
    String latestVersion = getLatestGuestToolsVersion(isoList);
    if (latestVersion == null) {
        return;
    }
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllForStoragePool(poolId);
    for (VM vm : vms) {
        if (vm.getAppList() != null && vm.getAppList().toLowerCase().contains("rhev-tools")) {
            Matcher m = TOOLS_PATTERN.matcher(vm.getAppList().toLowerCase());
            if (m.matches() && m.groupCount() > 0) {
                String toolsVersion = m.group(1);
                if (toolsVersion.compareTo(latestVersion) < 0) {
                    updateGuestAgentStatus(vm, GuestAgentStatus.UpdateNeeded);
                } else {
                    updateGuestAgentStatus(vm, GuestAgentStatus.Exists);
                }
            }
        } else {
            updateGuestAgentStatus(vm, GuestAgentStatus.DoesntExist);
        }
    }
}
#end_block

#method_before
public Boolean getReadOnly() {
    return readOnly == null ? false : readOnly;
}
#method_after
public boolean getReadOnly() {
    return readOnly;
}
#end_block

#method_before
public void setReadOnly(Boolean entity) {
    this.readOnly = entity;
}
#method_after
public void setReadOnly(boolean entity) {
    this.readOnly = entity;
}
#end_block

#method_before
@Mapping(from = OpenStackNetworkProvider.class, to = Provider.class)
public static Provider<OpenstackNetworkProviderProperties> map(OpenStackNetworkProvider model, Provider<OpenstackNetworkProviderProperties> template) {
    Provider<OpenstackNetworkProviderProperties> entity = template != null ? template : new Provider<>();
    entity.setType(ProviderType.OPENSTACK_NETWORK);
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetUrl()) {
        entity.setUrl(model.getUrl());
    }
    if (model.isSetRequiresAuthentication()) {
        entity.setRequiringAuthentication(model.isRequiresAuthentication());
    }
    if (model.isSetUsername()) {
        entity.setUsername(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setPassword(model.getPassword());
    }
    if (model.isSetAuthenticationUrl()) {
        entity.setAuthUrl(model.getAuthenticationUrl());
    }
    if (model.isSetProperties()) {
        Map<String, String> map = new HashMap<>();
        for (Property property : model.getProperties().getProperties()) {
            map.put(property.getName(), property.getValue());
        }
        entity.setCustomProperties(map);
    }
    OpenstackNetworkProviderProperties additionalProperties = new OpenstackNetworkProviderProperties();
    if (model.isSetTenantName()) {
        additionalProperties.setTenantName(model.getTenantName());
    }
    if (model.isSetPluginType()) {
        additionalProperties.setPluginType(map(model.getPluginType()));
    }
    if (model.isSetAgentConfiguration()) {
        additionalProperties.setAgentConfiguration(map(model.getAgentConfiguration(), null));
    }
    additionalProperties.setReadOnly(!model.isSetReadOnly() || model.isReadOnly());
    entity.setAdditionalProperties(additionalProperties);
    return entity;
}
#method_after
@Mapping(from = OpenStackNetworkProvider.class, to = Provider.class)
public static Provider<OpenstackNetworkProviderProperties> map(OpenStackNetworkProvider model, Provider<OpenstackNetworkProviderProperties> template) {
    Provider<OpenstackNetworkProviderProperties> entity = template != null ? template : new Provider<>();
    entity.setType(ProviderType.OPENSTACK_NETWORK);
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetUrl()) {
        entity.setUrl(model.getUrl());
    }
    if (model.isSetRequiresAuthentication()) {
        entity.setRequiringAuthentication(model.isRequiresAuthentication());
    }
    if (model.isSetUsername()) {
        entity.setUsername(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setPassword(model.getPassword());
    }
    if (model.isSetAuthenticationUrl()) {
        entity.setAuthUrl(model.getAuthenticationUrl());
    }
    if (model.isSetProperties()) {
        Map<String, String> map = new HashMap<>();
        for (Property property : model.getProperties().getProperties()) {
            map.put(property.getName(), property.getValue());
        }
        entity.setCustomProperties(map);
    }
    OpenstackNetworkProviderProperties additionalProperties = new OpenstackNetworkProviderProperties();
    if (model.isSetTenantName()) {
        additionalProperties.setTenantName(model.getTenantName());
    }
    if (model.isSetPluginType()) {
        additionalProperties.setPluginType(map(model.getPluginType()));
    }
    if (model.isSetAgentConfiguration()) {
        additionalProperties.setAgentConfiguration(map(model.getAgentConfiguration(), null));
    }
    if (model.isSetReadOnly()) {
        additionalProperties.setReadOnly(model.isReadOnly());
    }
    entity.setAdditionalProperties(additionalProperties);
    return entity;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    ProviderType providerType = getParameters().getProviderType();
    List<ProviderType> providerTypes = getParameters().getProviderTypes();
    if (providerType == null) {
        setReturnValue(getDbFacade().getProviderDao().getAll());
    } else if (providerTypes != null) {
        setReturnValue(getDbFacade().getProviderDao().getAllByTypes(providerTypes));
    } else {
        setReturnValue(getDbFacade().getProviderDao().getAllByType(providerType));
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    ProviderType[] providerTypes = getParameters().getProviderTypes();
    if (providerTypes == null) {
        setReturnValue(getDbFacade().getProviderDao().getAll());
    } else {
        setReturnValue(getDbFacade().getProviderDao().getAllByTypes(providerTypes));
    }
}
#end_block

#method_before
public List<ProviderType> getProviderTypes() {
    return providerTypes;
}
#method_after
public ProviderType[] getProviderTypes() {
    return providerTypes;
}
#end_block

#method_before
@Override
public List<Provider<?>> getAllByTypes(List<ProviderType> providerTypes) {
    return getCallsHandler().executeReadList("GetAllFromProvidersByTypes", ProviderRowMapper.INSTANCE, getCustomMapSqlParameterSource().addValue("provider_type", createArrayOf("character", providerTypes.stream().map(ProviderType::name).toArray())));
}
#method_after
@Override
public List<Provider<?>> getAllByTypes(ProviderType... providerTypes) {
    if (providerTypes == null) {
        return Collections.emptyList();
    }
    return getCallsHandler().executeReadList("GetAllFromProvidersByTypes", ProviderRowMapper.INSTANCE, getCustomMapSqlParameterSource().addValue("provider_types", createArrayOf("varchar", Arrays.stream(providerTypes).map(ProviderType::name).toArray())));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, hostName, consoleAddress, name, otpValidity, pmEnabled, pmKdumpDetection, port, protocol, sshPort, sshUsername, serverSslEnabled, uniqueId, clusterId, vdsStrength, vdsType, disablePowerManagementPolicy, hostProviderId);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, hostName, consoleAddress, name, otpValidity, pmEnabled, pmKdumpDetection, port, protocol, sshPort, sshUsername, serverSslEnabled, uniqueId, clusterId, vdsStrength, vdsType, disablePowerManagementPolicy, hostProviderId, openstackNetworkProviderId);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsStatic)) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && protocol == other.protocol && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsStatic)) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && protocol == other.protocol && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId);
}
#end_block

#method_before
private Network findCurrentNetwork(Map<Network, Set<Guid>> networks) {
    Network result = networks == null ? null : networks.keySet().stream().filter(network -> Objects.equals(network.getProvidedBy().getExternalId(), id)).findFirst().orElse(null);
    if (result == null) {
        // This will never return but always throw a WebApplicationException
        notFound();
    }
    return result;
}
#method_after
private Network findCurrentNetwork(Map<Network, Set<Guid>> networks) {
    final Network result;
    if (networks == null) {
        result = null;
    } else {
        result = networks.keySet().stream().filter(network -> Objects.equals(network.getProvidedBy().getExternalId(), id)).findFirst().orElse(null);
    }
    if (result == null) {
        // This will never return but always throw a WebApplicationException
        notFound();
    }
    return result;
}
#end_block

#method_before
public static ArrayList<VmNetworkInterface> buildVmNetworkInterfacesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<VmNetworkInterface> nics = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.VM_INTERFACE_DEVICE_TYPE.equals(deviceMap.get(VdsProperties.Type))) {
                VmNetworkInterface nic = new VmNetworkInterface();
                nic.setMacAddress((String) deviceMap.get(VdsProperties.MAC_ADDR));
                nic.setName((String) deviceMap.get(VdsProperties.Name));
                // FIXME we can't deduce the network profile by the network name. its many to many.
                nic.setNetworkName((String) deviceMap.get(VdsProperties.NETWORK));
                nic.setType(VmInterfaceType.valueOf((String) deviceMap.get(VdsProperties.NIC_TYPE)).getValue());
                if (deviceMap.containsKey(VdsProperties.Model)) {
                    String model = (String) deviceMap.get(VdsProperties.Model);
                    for (VmInterfaceType type : VmInterfaceType.values()) {
                        if (model.equals(type.getInternalName())) {
                            nic.setType(type.getValue());
                            break;
                        }
                    }
                }
                nics.add(nic);
            }
        }
    }
    return nics;
}
#method_after
public static ArrayList<VmNetworkInterface> buildVmNetworkInterfacesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<VmNetworkInterface> nics = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get(VdsProperties.Devices);
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.VM_INTERFACE_DEVICE_TYPE.equals(deviceMap.get(VdsProperties.Type))) {
                VmNetworkInterface nic = new VmNetworkInterface();
                nic.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                nic.setMacAddress((String) deviceMap.get(VdsProperties.MAC_ADDR));
                nic.setName((String) deviceMap.get(VdsProperties.Name));
                // FIXME we can't deduce the network profile by the network name. its many to many.
                nic.setNetworkName((String) deviceMap.get(VdsProperties.NETWORK));
                nic.setType(VmInterfaceType.valueOf((String) deviceMap.get(VdsProperties.NIC_TYPE)).getValue());
                if (deviceMap.containsKey(VdsProperties.Model)) {
                    String model = (String) deviceMap.get(VdsProperties.Model);
                    for (VmInterfaceType type : VmInterfaceType.values()) {
                        if (model.equals(type.getInternalName())) {
                            nic.setType(type.getValue());
                            break;
                        }
                    }
                }
                nics.add(nic);
            }
        }
    }
    return nics;
}
#end_block

#method_before
private static VmBalloonInfo getBalloonInfo(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> balloonInfo = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_balloonInfo);
    VmBalloonInfo vmBalloonInfo = new VmBalloonInfo();
    if (balloonInfo != null && balloonInfo.size() > 0) {
        vmBalloonInfo.setCurrentMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_cur));
        vmBalloonInfo.setBalloonMaxMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_max));
        vmBalloonInfo.setBalloonTargetMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_target));
        vmBalloonInfo.setBalloonMinMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_min));
        if (balloonInfo.size() >= 4) {
            // only if all 4 properties are found the balloon is considered enabled (available from 3.3)
            vmBalloonInfo.setBalloonDeviceEnabled(true);
        }
    } else {
        vmBalloonInfo.setBalloonDeviceEnabled(false);
    }
    return vmBalloonInfo;
}
#method_after
private static VmBalloonInfo getBalloonInfo(Map<String, Object> xmlRpcStruct) {
    VmBalloonInfo vmBalloonInfo = new VmBalloonInfo();
    Map<String, Object> balloonInfo = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_balloonInfo);
    if (balloonInfo != null && !balloonInfo.isEmpty()) {
        vmBalloonInfo.setCurrentMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_cur));
        vmBalloonInfo.setBalloonMaxMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_max));
        vmBalloonInfo.setBalloonTargetMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_target));
        vmBalloonInfo.setBalloonMinMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_min));
        // only if all 4 properties are found the balloon is considered enabled (available from 3.3)
        vmBalloonInfo.setBalloonDeviceEnabled(balloonInfo.size() >= 4);
    }
    return vmBalloonInfo;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getClusterCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(assignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(assignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(assignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(assignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(assignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(assignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(assignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(assignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(assignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(assignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(assignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = assignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(assignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(assignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = assignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = assignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = assignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = assignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = haScore > 0;
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(assignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkCommonUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(assignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(assignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(assignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(assignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(assignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(assignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(assignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(assignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(assignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(assignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = assignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(assignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(assignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = assignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = assignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = assignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = assignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = haScore > 0;
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#end_block

#method_before
private static Double computeInterfaceUsage(VdsNetworkInterface iface, boolean totalStatsReported) {
    Double receiveRate = iface.getStatistics().getReceiveRate();
    Double transmitRate = iface.getStatistics().getTransmitRate();
    /**
     * TODO: only needed if rate reported by vdsm (in which case can't be null) - remove in 4.0 and turn
     * NetworkStatisticsBuilder.truncatePercentage() private
     */
    if (!totalStatsReported) {
        receiveRate = NetworkStatisticsBuilder.truncatePercentage(receiveRate);
        transmitRate = NetworkStatisticsBuilder.truncatePercentage(transmitRate);
    }
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = iface.getStatistics().getReceiveRate();
    Double transmitRate = iface.getStatistics().getTransmitRate();
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    final String managementAddress = hostIp;
    VdsNetworkInterface activeIface = host.getInterfaces().stream().filter(new InterfaceByAddressPredicate(managementAddress)).findFirst().orElse(null);
    return activeIface;
}
#method_after
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    VdsNetworkInterface activeIface = host.getInterfaces().stream().filter(new InterfaceByAddressPredicate(hostIp)).findFirst().orElse(null);
    return activeIface;
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(host.getClusterCompatibilityVersion());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, host, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, host, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = (String) effectiveProperties.get(VdsProperties.IPV6_GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    iface.setIpv4Gateway(v4gateway);
                    iface.setIpv6Gateway(v6gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
private static String findActiveNicName(VDS vds, Map<String, Map<String, Object>> bridges) {
    final String hostIp = NetworkUtils.getHostByIp(vds);
    final String activeBridge = findActiveBridge(hostIp, bridges);
    if (activeBridge != null) {
        return activeBridge;
    }
    // by now, if the host is communicating with engine over a valid interface,
    // the interface will have the host's engine IP
    final VdsNetworkInterface activeIface = resolveActiveNic(vds, hostIp);
    String hostActiveNic = (activeIface == null) ? null : activeIface.getName();
    return hostActiveNic;
}
#method_after
private static String findActiveNicName(VDS vds, Map<String, Map<String, Object>> bridges) {
    final String hostIp = NetworkUtils.getHostIp(vds);
    final String activeBridge = findActiveBridge(hostIp, bridges);
    if (activeBridge != null) {
        return activeBridge;
    }
    // by now, if the host is communicating with engine over a valid interface,
    // the interface will have the host's engine IP
    final VdsNetworkInterface activeIface = resolveActiveNic(vds, hostIp);
    String hostActiveNic = (activeIface == null) ? null : activeIface.getName();
    return hostActiveNic;
}
#end_block

#method_before
private static String findActiveBridge(String ipAddress, Map<String, Map<String, Object>> bridges) {
    String activeBridge = null;
    if (bridges != null) {
        for (Entry<String, Map<String, Object>> entry : bridges.entrySet()) {
            Map<String, Object> bridgeProperties = entry.getValue();
            String bridgeName = entry.getKey();
            if (bridgeProperties != null) {
                String bridgeAddress = (String) bridgeProperties.get("addr");
                // in case host is communicating with engine over a bridge
                if (bridgeAddress != null && bridgeAddress.equals(ipAddress)) {
                    activeBridge = bridgeName;
                }
            }
        }
    }
    return activeBridge;
}
#method_after
private static String findActiveBridge(String ipAddress, Map<String, Map<String, Object>> bridges) {
    if (bridges != null) {
        final Predicate<String> ipAddressPredicate = new IpAddressPredicate(ipAddress);
        for (Entry<String, Map<String, Object>> entry : bridges.entrySet()) {
            Map<String, Object> bridgeProperties = entry.getValue();
            String bridgeName = entry.getKey();
            if (bridgeProperties != null) {
                String bridgeIpv4Address = (String) bridgeProperties.get("addr");
                String bridgeIpv6Address = extractIpv6Address(getIpv6Address(bridgeProperties));
                // in case host is communicating with engine over a bridge
                if (ipAddressPredicate.test(bridgeIpv4Address) || ipAddressPredicate.test(bridgeIpv6Address)) {
                    return bridgeName;
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getClusterCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    Map<String, Object> bondOptionsMap = new HashMap<>();
                    Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                    if (bondOpts != null) {
                        bondOptionsMap.putAll(bondOpts);
                    }
                    String bondOptionsString = "";
                    String mode = (String) bondOptionsMap.get("mode");
                    String miimon = (String) bondOptionsMap.get("miimon");
                    if (mode != null && miimon != null) {
                        bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                        bondOptionsMap.remove("mode");
                        bondOptionsMap.remove("miimon");
                    }
                    for (Map.Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                        bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                    }
                    bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
            }
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setAddress(extractAddress(nicProperties));
        iface.setSubnet(extractSubnet(nicProperties));
        final Integer mtu = assignIntValue(nicProperties, VdsProperties.MTU);
        if (mtu != null) {
            iface.setMtu(mtu);
        }
        addBootProtocol(nicProperties, host, iface);
    }
}
#method_after
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setIpv4Address(extractAddress(nicProperties));
        iface.setIpv4Subnet(extractSubnet(nicProperties));
        final String ipv6Address = getIpv6Address(nicProperties);
        iface.setIpv6Address(extractIpv6Address(ipv6Address));
        iface.setIpv6Prefix(extractIpv6Prefix(ipv6Address));
        final Integer mtu = assignIntValue(nicProperties, VdsProperties.MTU);
        if (mtu != null) {
            iface.setMtu(mtu);
        }
        addBootProtocol(nicProperties, iface);
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> entry, VDS host, VdsNetworkInterface iface) {
    BootProtocolResolver resolver = FeatureSupported.cfgEntriesDeprecated(host.getClusterCompatibilityVersion()) ? new NoCfgBootProtocolResolver(entry, iface, host) : new CfgBootProtocolResolver(entry, iface, host);
    resolver.resolve();
}
#method_after
private static void addBootProtocol(Map<String, Object> nicProperties, VdsNetworkInterface iface) {
    if (nicProperties == null) {
        return;
    }
    setBootProtocolAndGateway(getIpv4BootProtocolResolver(), new NoCfgIpv4InfoFetcher(nicProperties, iface.getIpv4Address()), bootProtocol -> Ipv4BootProtocol.STATIC_IP == bootProtocol, iface::setIpv4BootProtocol, iface::setIpv4Gateway);
    setBootProtocolAndGateway(getIpv6BootProtocolResolver(), new NoCfgIpv6InfoFetcher(nicProperties, iface.getIpv6Address()), bootProtocol -> Ipv6BootProtocol.STATIC_IP == bootProtocol, iface::setIpv6BootProtocol, iface::setIpv6Gateway);
}
#end_block

#method_before
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        if (VdsProperties.ROOT_HOST_DEVICE.equals(deviceName)) {
            // set parent to self, for DB integrity
            device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE);
        } else {
            device.setParentDeviceName(params.get(VdsProperties.PARENT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        devices.add(device);
    }
    return devices;
}
#method_after
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        if (VdsProperties.ROOT_HOST_DEVICE.equals(deviceName)) {
            // set parent to self, for DB integrity
            device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE);
        } else {
            device.setParentDeviceName(params.get(VdsProperties.PARENT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        if (params.containsKey(VdsProperties.DRIVER)) {
            device.setDriver(params.get(VdsProperties.DRIVER).toString());
        }
        if (params.containsKey(VdsProperties.IS_ASSIGNABLE)) {
            device.setAssignable(assignBoolValue(params, VdsProperties.IS_ASSIGNABLE));
        }
        devices.add(device);
    }
    return devices;
}
#end_block

#method_before
private void checkTimeout() throws TimeoutException {
    String message = getReturnStatus().message;
    if ("Internal timeout occured".equals(message)) {
        throw new TimeoutException(message);
    }
}
#method_after
private void checkTimeout() throws TimeoutException {
    String message = getReturnStatus().message;
    if (TIMEOUT_MESSAGE.equals(message)) {
        throw new TimeoutException(message);
    }
}
#end_block

#method_before
@Override
protected void build(UnitVmModel model, VmBase vm) {
    vm.setMigrationSupport(model.getMigrationMode().getSelectedItem());
    vm.setMigrationDowntime(model.getSelectedMigrationDowntime());
    if (model.getOverrideMigrationPolicy().getEntity()) {
        vm.setMigrationPolicyId(model.getMigrationPolicies().getSelectedItem().getId());
    } else {
        vm.setMigrationPolicyId(null);
    }
}
#method_after
@Override
protected void build(UnitVmModel model, VmBase vm) {
    vm.setMigrationSupport(model.getMigrationMode().getSelectedItem());
    vm.setMigrationDowntime(model.getSelectedMigrationDowntime());
    vm.setMigrationPolicyId(model.getSelectedMigrationPolicy());
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
    cpuPinningLabel.setStyleName(model.getCpuPinning().getIsChangable() ? style.labelToCoupleLabel() : style.labelToCoupleLabelDisabled());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            changeApplicationLevelVisibility(serialNumberPolicyEditor, true);
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            changeApplicationLevelVisibility(serialNumberPolicyEditor, true);
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
    object.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsChangable".equals(args.propertyName)) {
                // $NON-NLS-1$
                cpuPinningLabel.setStyleName(object.getCpuPinning().getIsChangable() ? style.labelToCoupleLabel() : style.labelToCoupleLabelDisabled());
            }
        }
    });
}
#end_block

#method_before
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    getModel().getIsRngEnabled().setIsChangeable(true);
    setRngAvailability();
    postDataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
}
#method_after
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    getModel().getIsRngEnabled().setIsChangeable(true);
    setRngAvailability();
    postDataCenterWithClusterSelectedItemChanged();
}
#end_block

#method_before
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null;
    boolean nonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    if (clusterSupportsHostCpu && nonMigratable) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangeable(false);
    }
}
#method_after
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null;
    boolean nonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    if (clusterSupportsHostCpu && nonMigratable && !clusterHasPpcArchitecture()) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangeable(false);
    }
}
#end_block

#method_before
public void updateNumOfIoThreads() {
    Version compatibilityVersion = getCompatibilityVersion();
    if (compatibilityVersion == null) {
        return;
    }
    getModel().getIoThreadsEnabled().updateChangeability(ConfigurationValues.IoThreadsSupported, compatibilityVersion);
    getModel().getNumOfIoThreads().updateChangeability(ConfigurationValues.IoThreadsSupported, compatibilityVersion);
    if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.IoThreadsSupported, compatibilityVersion.getValue())) {
        getModel().getNumOfIoThreads().setIsAvailable(getModel().getIoThreadsEnabled().getEntity());
        if (getModel().getIoThreadsEnabled().getEntity() && getModel().getNumOfIoThreads().getEntity() == 0) {
            getModel().getNumOfIoThreads().setEntity(DEFAULT_NUM_OF_IOTHREADS);
        }
    }
}
#method_after
public void updateNumOfIoThreads() {
    getModel().getIoThreadsEnabled().setIsChangeable(true);
    getModel().getNumOfIoThreads().setIsChangeable(true);
    getModel().getNumOfIoThreads().setIsAvailable(getModel().getIoThreadsEnabled().getEntity());
    if (getModel().getIoThreadsEnabled().getEntity() && getModel().getNumOfIoThreads().getEntity() == 0) {
        getModel().getNumOfIoThreads().setEntity(DEFAULT_NUM_OF_IOTHREADS);
    }
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<>(false));
    setEnableHaReservation(new EntityModel<>(false));
    setEnableOptionalReason(new EntityModel<>(false));
    setMigrationPolicies(new ListModel<MigrationPolicy>());
    setEnableTrustedService(new EntityModel<>(false));
    setEnableHaReservation(new EntityModel<>(false));
    setEnableOptionalReason(new EntityModel<>(false));
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    setGlusterTunedProfile(new ListModel<String>());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setAdditionalClusterFeatures(new ListModel<List<AdditionalFeature>>());
    List<List<AdditionalFeature>> additionalFeatures = new ArrayList<>();
    additionalFeatures.add(Collections.<AdditionalFeature>emptyList());
    getAdditionalClusterFeatures().setItems(additionalFeatures, null);
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangeable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangeable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            } else {
                getEnableTrustedService().setIsChangeable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangeable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            }
            getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
            if (getEnableGlusterService().getEntity()) {
                initTunedProfiles();
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangeable(false);
            } else {
                getEnableGlusterService().setIsChangeable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // KSM feature
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    getKsmPolicyForNumaSelection().setIsChangeable(false);
    getEnableKsm().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableKsm().getEntity() == null) {
                return;
            }
            if (getEnableKsm().getEntity() == true) {
                getKsmPolicyForNumaSelection().setIsChangeable(true);
            }
            if (getEnableKsm().getEntity() == false) {
                getKsmPolicyForNumaSelection().setIsChangeable(false);
            }
        }
    });
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangeable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangeable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangeable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangeable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setMigrationTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
    setCustomMigrationNetworkBandwidth(new EntityModel<Integer>());
    setMigrationBandwidthLimitType(new ListModel<MigrationBandwidthLimitType>());
    List<MigrationPolicy> policies = AsyncDataProvider.getInstance().getMigrationPolicies();
    getMigrationPolicies().setItems(policies);
    if (isEdit) {
        for (MigrationPolicy policy : policies) {
            if (Objects.equals(policy.getId(), getEntity().getMigrationPolicyId())) {
                getMigrationPolicies().setSelectedItem(policy);
                break;
            }
        }
    }
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<>(false));
    setEnableHaReservation(new EntityModel<>(false));
    setEnableOptionalReason(new EntityModel<>(false));
    setMigrationPolicies(new ListModel<MigrationPolicy>());
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    setGlusterTunedProfile(new ListModel<String>());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setAdditionalClusterFeatures(new ListModel<List<AdditionalFeature>>());
    List<List<AdditionalFeature>> additionalFeatures = new ArrayList<>();
    additionalFeatures.add(Collections.<AdditionalFeature>emptyList());
    getAdditionalClusterFeatures().setItems(additionalFeatures, null);
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangeable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangeable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            } else {
                getEnableTrustedService().setIsChangeable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangeable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            }
            getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
            if (getEnableGlusterService().getEntity()) {
                initTunedProfiles();
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangeable(false);
            } else {
                getEnableGlusterService().setIsChangeable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // KSM feature
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    getKsmPolicyForNumaSelection().setIsChangeable(false);
    getEnableKsm().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableKsm().getEntity() == null) {
                return;
            }
            if (getEnableKsm().getEntity() == true) {
                getKsmPolicyForNumaSelection().setIsChangeable(true);
            }
            if (getEnableKsm().getEntity() == false) {
                getKsmPolicyForNumaSelection().setIsChangeable(false);
            }
        }
    });
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangeable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangeable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangeable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangeable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setMigrationTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
    setCustomMigrationNetworkBandwidth(new EntityModel<Integer>());
    setMigrationBandwidthLimitType(new ListModel<MigrationBandwidthLimitType>());
    List<MigrationPolicy> policies = AsyncDataProvider.getInstance().getMigrationPolicies();
    getMigrationPolicies().setItems(policies);
    if (isEdit) {
        for (MigrationPolicy policy : policies) {
            if (Objects.equals(policy.getId(), getEntity().getMigrationPolicyId())) {
                getMigrationPolicies().setSelectedItem(policy);
                break;
            }
        }
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    Version version = getVersion().getSelectedItem();
    if (version == null) {
        return;
    }
    autoConverge.updateChangeability(ConfigurationValues.AutoConvergenceSupported, version);
    migrateCompressed.updateChangeability(ConfigurationValues.MigrationCompressionSupported, version);
}
#method_after
private void updateMigrationOptions() {
    Version version = getVersion().getSelectedItem();
    if (version == null) {
        return;
    }
    autoConverge.setIsChangeable(true);
    migrateCompressed.setIsChangeable(true);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            behavior.updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        }
    }
}
#end_block

#method_before
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
    }
}
#method_after
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    Cluster cluster = dataCenterWithCluster.getCluster();
    Version version = getCompatibilityVersion();
    // test migration support for VM/cluster level along with the cluster architecture
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), version);
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
    autoConverge.updateChangeability(ConfigurationValues.AutoConvergenceSupported, version);
    migrateCompressed.updateChangeability(ConfigurationValues.MigrationCompressionSupported, version);
}
#method_after
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    Cluster cluster = dataCenterWithCluster.getCluster();
    Version version = getCompatibilityVersion();
    // test migration support for VM/cluster level along with the cluster architecture
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), version);
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
    autoConverge.setIsChangeable(true);
    migrateCompressed.setIsChangeable(true);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType().getSelectedItem() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.getInstance().isSpiceFileTransferToggleSupported(getCompatibilityVersion().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangeable(spiceFileTransferToggle);
        GraphicsTypes selectedGraphics = getGraphicsType().getSelectedItem();
        boolean spiceCopyPasteToggle = selectedGraphics != null && selectedGraphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE);
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangeable(spiceCopyPasteToggle);
    }
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType().getSelectedItem() == DisplayType.qxl;
        if (!isQxl) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getCompatibilityVersion().toString(), false);
        }
        getSpiceFileTransferEnabled().setIsChangeable(isQxl);
        GraphicsTypes selectedGraphics = getGraphicsType().getSelectedItem();
        boolean spiceCopyPasteToggle = selectedGraphics != null && selectedGraphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE);
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangeable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
private void overrideMigrationPolicyChanged() {
    boolean override = Boolean.TRUE.equals(getOverrideMigrationPolicy().getEntity());
    getMigrationPolicies().setIsChangeable(override);
    getBehavior().updateMigrationRelatedFields();
}
#method_after
private void overrideMigrationPolicyChanged() {
    boolean override = Boolean.TRUE.equals(getOverrideMigrationPolicy().getEntity());
    getMigrationPolicies().setIsChangeable(override);
    updateMigrationRelatedFields();
}
#end_block

#method_before
protected void initGraphicsConsoles(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        if (AsyncDataProvider.getInstance().supportedForUnitVmModel(ConfigurationValues.MultipleGraphicsSupported, this)) {
            graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
        }
    }
    GraphicsTypes prevSelected = getGraphicsType().getSelectedItem();
    if (prevSelected != null && graphicsTypes.contains(prevSelected)) {
        getGraphicsType().setItems(graphicsTypes, prevSelected);
    } else {
        getGraphicsType().setItems(graphicsTypes);
    }
    upgradeGraphicsRelatedModels();
}
#method_after
protected void initGraphicsConsoles(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
    }
    GraphicsTypes prevSelected = getGraphicsType().getSelectedItem();
    if (prevSelected != null && graphicsTypes.contains(prevSelected)) {
        getGraphicsType().setItems(graphicsTypes, prevSelected);
    } else {
        getGraphicsType().setItems(graphicsTypes);
    }
    upgradeGraphicsRelatedModels();
}
#end_block

#method_before
@Override
protected void build(VmBase vm, UnitVmModel model) {
    model.getMemSize().setEntity(vm.getMemSizeMb());
    if (supported(ConfigurationValues.IoThreadsSupported, model)) {
        model.getIoThreadsEnabled().setEntity(vm.getNumOfIoThreads() != 0);
        model.getNumOfIoThreads().setEntity(vm.getNumOfIoThreads());
    }
    model.getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    model.getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    model.getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    model.getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    model.setBootSequence(vm.getDefaultBootSequence());
    model.getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    model.getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    model.getCoresPerSocket().setSelectedItem(vm.getCpuPerSocket());
    model.getThreadsPerCore().setSelectedItem(vm.getThreadsPerCpu());
    model.getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    model.setSelectedMigrationDowntime(vm.getMigrationDowntime());
    model.selectMigrationPolicy(vm.getMigrationPolicyId());
    model.getEmulatedMachine().setSelectedItem(vm.getCustomEmulatedMachine());
    model.getCustomCpu().setSelectedItem(vm.getCustomCpuName());
}
#method_after
@Override
protected void build(VmBase vm, UnitVmModel model) {
    model.getMemSize().setEntity(vm.getMemSizeMb());
    model.getIoThreadsEnabled().setEntity(vm.getNumOfIoThreads() != 0);
    model.getNumOfIoThreads().setEntity(vm.getNumOfIoThreads());
    model.getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    model.getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    model.getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    model.getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    model.setBootSequence(vm.getDefaultBootSequence());
    model.getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    model.getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    model.getCoresPerSocket().setSelectedItem(vm.getCpuPerSocket());
    model.getThreadsPerCore().setSelectedItem(vm.getThreadsPerCpu());
    model.getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    model.setSelectedMigrationDowntime(vm.getMigrationDowntime());
    model.selectMigrationPolicy(vm.getMigrationPolicyId());
    model.getEmulatedMachine().setSelectedItem(vm.getCustomEmulatedMachine());
    model.getCustomCpu().setSelectedItem(vm.getCustomCpuName());
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
}
#end_block

#method_before
private void initMigrationPolicies() {
    AsyncQuery aQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationPolicies = (List<MigrationPolicy>) returnValue;
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<MigrationPolicy>();
            }
            Collections.sort((List<MigrationPolicy>) returnValue, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (m1.getId() == NoMigrationPolicy.ID) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void initMigrationPolicies() {
    AsyncQuery aQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationPolicies = (List<MigrationPolicy>) returnValue;
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<MigrationPolicy>();
            }
            Collections.sort((List<MigrationPolicy>) returnValue, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getCluster() == null ? null : getCluster().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (getParameters().getMasterVm().getDedicatedVmForVdsList().size() > 0 || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getCluster() == null ? null : getCluster().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (!new HashSet<>(getParameters().getMasterVm().getDedicatedVmForVdsList()).equals(new HashSet<>(getVm().getDedicatedVmForVdsList())) || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        if (FeatureSupported.isIoThreadsSupported(getEffectiveCompatibilityVersion())) {
            vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        }
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        Guid overriddenPolicyId = getVm().getMigrationPolicyId();
        MigrationPolicy migrationPolicy;
        if (overriddenPolicyId != null) {
            migrationPolicy = convergenceConfigProvider.getMigrationPolicy(overriddenPolicyId);
        } else {
            migrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        }
        convergenceSchedule = ConvergenceSchedule.from(migrationPolicy.getConfig()).asMap();
        MigrationBandwidthLimitType migrationBandwidthLimitType = getCluster().getMigrationBandwidthLimitType();
        if (migrationBandwidthLimitType == MigrationBandwidthLimitType.CUSTOM) {
            maxBandwidth = getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations();
        }
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), getAutoConverge(), getMigrateCompressed(), getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule);
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        convergenceSchedule = ConvergenceSchedule.from(findEffectiveConvergenceConfig(clusterMigrationPolicy)).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), getAutoConverge(), getMigrateCompressed(), getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule);
}
#end_block

#method_before
protected void getDowntime() {
    if (FeatureSupported.migrateDowntime(getVm().getCompatibilityVersion())) {
        try {
            VDSReturnValue retVal = runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getDestinationVdsId(), getVmId()));
            if (retVal != null) {
                actualDowntime = (Integer) retVal.getReturnValue();
            }
        } catch (EngineException e) {
            migrationErrorCode = e.getErrorCode();
        }
    }
}
#method_after
protected void getDowntime() {
    try {
        VDSReturnValue retVal = runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getDestinationVdsId(), getVmId()));
        if (retVal != null) {
            actualDowntime = (Integer) retVal.getReturnValue();
        }
    } catch (EngineException e) {
        migrationErrorCode = e.getErrorCode();
    }
}
#end_block

#method_before
private Boolean getAutoConverge() {
    if (FeatureSupported.autoConvergence(getVm().getCompatibilityVersion())) {
        if (getVm().getAutoConverge() != null) {
            return getVm().getAutoConverge();
        }
        if (getCluster().getAutoConverge() != null) {
            return getCluster().getAutoConverge();
        }
        return Config.getValue(ConfigValues.DefaultAutoConvergence);
    }
    return null;
}
#method_after
private Boolean getAutoConverge() {
    if (getVm().getAutoConverge() != null) {
        return getVm().getAutoConverge();
    }
    if (getCluster().getAutoConverge() != null) {
        return getCluster().getAutoConverge();
    }
    return Config.getValue(ConfigValues.DefaultAutoConvergence);
}
#end_block

#method_before
private Boolean getMigrateCompressed() {
    if (FeatureSupported.migrationCompression(getVm().getCompatibilityVersion())) {
        if (getVm().getMigrateCompressed() != null) {
            return getVm().getMigrateCompressed();
        }
        if (getCluster().getMigrateCompressed() != null) {
            return getCluster().getMigrateCompressed();
        }
        return Config.getValue(ConfigValues.DefaultMigrationCompression);
    }
    return null;
}
#method_after
private Boolean getMigrateCompressed() {
    if (getVm().getMigrateCompressed() != null) {
        return getVm().getMigrateCompressed();
    }
    if (getCluster().getMigrateCompressed() != null) {
        return getCluster().getMigrateCompressed();
    }
    return Config.getValue(ConfigValues.DefaultMigrationCompression);
}
#end_block

#method_before
private String getMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        // assure migration network is active on source host
        if (getMigrationNetworkAddress(getVds().getId(), migrationNetwork.getName()) == null) {
            return null;
        }
        // find migration IP address on destination host
        return getMigrationNetworkAddress(getDestinationVds().getId(), migrationNetwork.getName());
    }
    return null;
}
#method_after
private String getMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return migrationDestinationIpv6Address;
        }
    }
    return null;
}
#end_block

#method_before
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return nic.getIpv4Address();
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName, Function<VdsNetworkInterface, String> ipAddressGetter) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return ipAddressGetter.apply(nic);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVm() != null && !Objects.equals(getParameters().getTargetClusterId(), getVm().getClusterId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetClusterId()));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getTargetClusterId() != null && getVm() != null && !Objects.equals(getParameters().getTargetClusterId(), getVm().getClusterId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetClusterId()));
    }
    return permissionList;
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_POLICY_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationPolicyId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_POLICY_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationPolicyId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
@Override
protected boolean validate() {
    // TODO elevi add network filter validator
    VnicProfileValidator validator = new VnicProfileValidator(vmDao, getVnicProfile());
    return validate(validator.vnicProfileIsSet()) && validate(validator.networkExists()) && validate(validator.networkQosExistsOrNull()) && validate(validator.vnicProfileForVmNetworkOnly()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughProfileContainsSupportedProperties());
}
#method_after
@Override
protected boolean validate() {
    VnicProfileValidator validator = createVnicProfileValidator();
    return validate(validator.vnicProfileIsSet()) && validate(validator.networkExists()) && validate(validator.networkQosExistsOrNull()) && validate(validator.vnicProfileForVmNetworkOnly()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughProfileContainsSupportedProperties()) && validate(validator.validUseDefaultNetworkFilterFlag(getParameters().isUseDefaultNetworkFiterId())) && validate(validator.validNetworkFilterId());
}
#end_block

#method_before
private void updateDefaultNetworkFilterIfRequired() {
    Guid networkFilterId = getNetworkFilterId();
    if (networkFilterId == null) {
        final NetworkFilter networkFilter = resolveVnicProfileDefaultNetworkFilter();
        networkFilterId = networkFilter.getId();
        getVnicProfile().setNetworkFilterId(networkFilterId);
    }
}
#method_after
private void updateDefaultNetworkFilterIfRequired() {
    if (getParameters().isUseDefaultNetworkFiterId()) {
        final NetworkFilter networkFilter = resolveVnicProfileDefaultNetworkFilter();
        if (networkFilter != null) {
            final Guid networkFilterId = networkFilter.getId();
            setNetworkFilterId(networkFilterId);
        }
    }
}
#end_block

#method_before
private NetworkFilter resolveVnicProfileDefaultNetworkFilter() {
    final Version dataCenterVersion = resolveDataCenterVersion();
    final String networkFilterName = FeatureSupported.antiMacSpoofing(dataCenterVersion) && Config.<Boolean>getValue(ConfigValues.EnableMACAntiSpoofingFilterRules) ? NetworkFilter.VDSM_NO_MAC_SPOOFING : NetworkFilter.NON_CONFIGURABLE_NETWORK_FILTER;
    NetworkFilter networkFilter = networkFilterDao.getNetworkFilterByName(networkFilterName);
    return networkFilter;
}
#method_after
private NetworkFilter resolveVnicProfileDefaultNetworkFilter() {
    if (Config.<Boolean>getValue(ConfigValues.EnableMACAntiSpoofingFilterRules)) {
        return networkFilterDao.getNetworkFilterByName(NetworkFilter.VDSM_NO_MAC_SPOOFING);
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    VnicProfileValidator validator = new VnicProfileValidator(vmDao, getVnicProfile());
    // TODO elevi add network filter validator
    return validate(validator.vnicProfileIsSet()) && validate(validator.vnicProfileExists()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.networkNotChanged()) && validate(validator.networkQosExistsOrNull()) && validate(validator.portMirroringNotChangedIfUsedByVms()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughNotChangedIfUsedByVms()) && validate(validator.passthroughProfileContainsSupportedProperties());
}
#method_after
@Override
protected boolean validate() {
    VnicProfileValidator validator = createVnicProfileValidator();
    return validate(validator.vnicProfileIsSet()) && validate(validator.vnicProfileExists()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.networkNotChanged()) && validate(validator.networkQosExistsOrNull()) && validate(validator.portMirroringNotChangedIfUsedByVms()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughNotChangedIfUsedByVms()) && validate(validator.passthroughProfileContainsSupportedProperties()) && validate(validator.validNetworkFilterId());
}
#end_block

#method_before
public String getDataCenterName() {
    return getStoragePoolDao().get(getNetwork().getDataCenterId()).getName();
}
#method_after
public String getDataCenterName() {
    return dcDao.get(getNetwork().getDataCenterId()).getName();
}
#end_block

#method_before
public ValidationResult networkExists() {
    return new NetworkValidator(vmDao, getNetwork()).networkIsSet();
}
#method_after
public ValidationResult networkExists() {
    return new NetworkValidator(vmDao, getNetwork()).networkIsSet(vnicProfile.getNetworkId());
}
#end_block

#method_before
public boolean validateCustomProperties(List<String> messages) {
    StoragePool dataCenter = getDbFacade().getStoragePoolDao().get(getNetwork().getDataCenterId());
    List<ValidationError> errors = DevicePropertiesUtils.getInstance().validateProperties(dataCenter.getCompatibilityVersion(), VmDeviceGeneralType.INTERFACE, vnicProfile.getCustomProperties());
    if (!errors.isEmpty()) {
        DevicePropertiesUtils.getInstance().handleCustomPropertiesError(errors, messages);
        return false;
    }
    return true;
}
#method_after
public boolean validateCustomProperties(List<String> messages) {
    StoragePool dataCenter = dcDao.get(getNetwork().getDataCenterId());
    List<ValidationError> errors = DevicePropertiesUtils.getInstance().validateProperties(dataCenter.getCompatibilityVersion(), VmDeviceGeneralType.INTERFACE, vnicProfile.getCustomProperties());
    if (!errors.isEmpty()) {
        DevicePropertiesUtils.getInstance().handleCustomPropertiesError(errors, messages);
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult validUseDefaultNetworkFilterFlag(boolean useDefaultNetworkFilterId) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_INVALID_VNIC_PROFILE_NETWORK_ID_CONFIGURATION, ReplacementUtils.createSetVariableString(VAR_VNIC_PROFILE_NAME, vnicProfile.getName()), ReplacementUtils.createSetVariableString(VAR_NETWORK_FILTER_ID, vnicProfile.getNetworkFilterId())).when(useDefaultNetworkFilterId & vnicProfile.getNetworkFilterId() != null);
}
#method_after
public ValidationResult validUseDefaultNetworkFilterFlag(boolean useDefaultNetworkFilterId) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_INVALID_VNIC_PROFILE_NETWORK_ID_CONFIGURATION, ReplacementUtils.createSetVariableString(VAR_VNIC_PROFILE_NAME, vnicProfile.getName()), ReplacementUtils.createSetVariableString(VAR_NETWORK_FILTER_ID, vnicProfile.getNetworkFilterId())).when(useDefaultNetworkFilterId && vnicProfile.getNetworkFilterId() != null);
}
#end_block

#method_before
@Before
public void setup() {
    // spy on attempts to access the database
    validator = spy(new VnicProfileValidator(vmDao, networkFilterDao, vnicProfile));
    doReturn(dbFacade).when(validator).getDbFacade();
    // mock some commonly used Daos
    when(dbFacade.getVnicProfileDao()).thenReturn(vnicProfileDao);
    when(dbFacade.getNetworkDao()).thenReturn(networkDao);
    when(dbFacade.getNetworkQosDao()).thenReturn(networkQosDao);
    when(dbFacade.getVmDao()).thenReturn(vmDao);
    initNetworkFilterDao();
    // mock their getters
    when(vnicProfileDao.get(any(Guid.class))).thenReturn(vnicProfile);
    when(vnicProfileDao.getAllForNetwork(any(Guid.class))).thenReturn(vnicProfiles);
}
#method_after
@Before
public void setup() {
    // spy on attempts to access the database
    validator = spy(new VnicProfileValidator(vnicProfile, vmDao, dcDao, networkFilterDao));
    doReturn(dbFacade).when(validator).getDbFacade();
    // mock some commonly used Daos
    when(dbFacade.getVnicProfileDao()).thenReturn(vnicProfileDao);
    when(dbFacade.getNetworkDao()).thenReturn(networkDao);
    when(dbFacade.getNetworkQosDao()).thenReturn(networkQosDao);
    when(dbFacade.getVmDao()).thenReturn(vmDao);
    initNetworkFilterDao();
    // mock their getters
    when(vnicProfileDao.get(any(Guid.class))).thenReturn(vnicProfile);
    when(vnicProfileDao.getAllForNetwork(any(Guid.class))).thenReturn(vnicProfiles);
}
#end_block

#method_before
private void initNetworkFilterDao() {
    when(dbFacade.getNetworkFilterDao()).thenReturn(networkFilterDao);
    when(networkFilterDao.getNetworkFilterById(INVALID_NETWORK_FILTER_ID)).thenReturn(null);
    when(networkFilterDao.getNetworkFilterById(VALID_NETWORK_FILTER_ID)).thenReturn(new NetworkFilter(VALID_NETWORK_FILTER_ID));
}
#method_after
private void initNetworkFilterDao() {
    when(networkFilterDao.getNetworkFilterById(INVALID_NETWORK_FILTER_ID)).thenReturn(null);
    when(networkFilterDao.getNetworkFilterById(VALID_NETWORK_FILTER_ID)).thenReturn(new NetworkFilter(VALID_NETWORK_FILTER_ID));
}
#end_block

#method_before
@Test
public void vnicProfileNull() throws Exception {
    validator = new VnicProfileValidator(vmDao, null);
    assertThat(validator.vnicProfileIsSet(), failsWith(EngineMessage.ACTION_TYPE_FAILED_VNIC_PROFILE_NOT_EXISTS));
}
#method_after
@Test
public void vnicProfileNull() throws Exception {
    validator = new VnicProfileValidator(null, vmDao, dcDao, networkFilterDao);
    assertThat(validator.vnicProfileIsSet(), failsWith(EngineMessage.ACTION_TYPE_FAILED_VNIC_PROFILE_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void networkDoesntExist() throws Exception {
    when(networkDao.get(any(Guid.class))).thenReturn(null);
    assertThat(validator.networkExists(), failsWith(EngineMessage.NETWORK_NOT_EXISTS));
}
#method_after
@Test
public void networkDoesntExist() throws Exception {
    when(networkDao.get(any(Guid.class))).thenReturn(null);
    assertThat(validator.networkExists(), failsWith(EngineMessage.NETWORK_HAVING_ID_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void validVnicProfileNullNetworkFilterId() {
    when(vnicProfile.getNetworkFilterId()).thenReturn(null);
    assertThat(validator.validateVnicProfileNetworkFilter(), isValid());
}
#method_after
@Test
public void validVnicProfileNullNetworkFilterId() {
    when(vnicProfile.getNetworkFilterId()).thenReturn(null);
    assertThat(validator.validNetworkFilterId(), isValid());
}
#end_block

#method_before
@Test
public void validVnicProfileNetworkFilterId() {
    when(vnicProfile.getNetworkFilterId()).thenReturn(VALID_NETWORK_FILTER_ID);
    assertThat(validator.validateVnicProfileNetworkFilter(), isValid());
}
#method_after
@Test
public void validVnicProfileNetworkFilterId() {
    when(vnicProfile.getNetworkFilterId()).thenReturn(VALID_NETWORK_FILTER_ID);
    assertThat(validator.validNetworkFilterId(), isValid());
}
#end_block

#method_before
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        Version clusterVersion = getParameters().getVm().getVdsGroupCompatibilityVersion();
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        if (FeatureSupported.networkLinking(clusterVersion)) {
            map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        }
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, VmInfoBuilder.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        VmInfoBuilder.addProfileDataToNic(map, vm, vmDevice, nic);
        VmInfoBuilder.addNetworkFiltersToNic(map, nic);
    } else {
        VmInfoBuilder.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#method_after
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, VmInfoBuilder.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        VmInfoBuilder.addProfileDataToNic(map, vm, vmDevice, nic);
        VmInfoBuilder.addNetworkFiltersToNic(map, nic);
    } else {
        VmInfoBuilder.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#end_block

#method_before
@Override
protected void buildVmGraphicsDevices() {
    boolean graphicsOverriden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    boolean usesGraphicsAsDevice = FeatureSupported.graphicsDeviceEnabled(vm.getVdsGroupCompatibilityVersion());
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = buildVmGraphicsSpecParamsFromVm(infos);
    if (graphicsOverriden) {
        buildVmGraphicsDevicesOverriden(infos, usesGraphicsAsDevice, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(usesGraphicsAsDevice, specParamsFromVm);
    }
}
#method_after
@Override
protected void buildVmGraphicsDevices() {
    boolean graphicsOverriden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = buildVmGraphicsSpecParamsFromVm(infos);
    if (graphicsOverriden) {
        buildVmGraphicsDevicesOverriden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#end_block

#method_before
private void buildVmGraphicsDevicesOverriden(Map<GraphicsType, GraphicsInfo> graphicsInfos, boolean usesGraphicsAsDevice, Map<String, Object> extraSpecParams) {
    if (usesGraphicsAsDevice) {
        for (Entry<GraphicsType, GraphicsInfo> graphicsInfo : graphicsInfos.entrySet()) {
            Map struct = new HashMap();
            struct.put(VdsProperties.Type, VmDeviceGeneralType.GRAPHICS.getValue());
            struct.put(VdsProperties.Device, graphicsInfo.getKey().name().toLowerCase());
            struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
            if (extraSpecParams != null) {
                struct.put(VdsProperties.SpecParams, extraSpecParams);
            }
            devices.add(struct);
        }
    }
    if (!graphicsInfos.isEmpty()) {
        String legacyGraphicsType = (graphicsInfos.size() == 2) ? VdsProperties.QXL : graphicsTypeToLegacyDisplayType(graphicsInfos.keySet().iterator().next());
        createInfo.put(VdsProperties.display, legacyGraphicsType);
    }
}
#method_after
private void buildVmGraphicsDevicesOverriden(Map<GraphicsType, GraphicsInfo> graphicsInfos, Map<String, Object> extraSpecParams) {
    for (Entry<GraphicsType, GraphicsInfo> graphicsInfo : graphicsInfos.entrySet()) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.GRAPHICS.getValue());
        struct.put(VdsProperties.Device, graphicsInfo.getKey().name().toLowerCase());
        struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
        if (extraSpecParams != null) {
            struct.put(VdsProperties.SpecParams, extraSpecParams);
        }
        devices.add(struct);
    }
    if (!graphicsInfos.isEmpty()) {
        String legacyGraphicsType = (graphicsInfos.size() == 2) ? VdsProperties.QXL : graphicsTypeToLegacyDisplayType(graphicsInfos.keySet().iterator().next());
        createInfo.put(VdsProperties.display, legacyGraphicsType);
    }
}
#end_block

#method_before
private void buildVmGraphicsDevicesFromDb(boolean usesGraphicsAsDevice, Map<String, Object> extraSpecParams) {
    if (usesGraphicsAsDevice) {
        buildVmDevicesFromDb(VmDeviceGeneralType.GRAPHICS, false, extraSpecParams);
    }
    String legacyDisplay = deriveDisplayTypeLegacy();
    if (legacyDisplay != null) {
        createInfo.put(VdsProperties.display, legacyDisplay);
    }
}
#method_after
private void buildVmGraphicsDevicesFromDb(Map<String, Object> extraSpecParams) {
    buildVmDevicesFromDb(VmDeviceGeneralType.GRAPHICS, false, extraSpecParams);
    String legacyDisplay = deriveDisplayTypeLegacy();
    if (legacyDisplay != null) {
        createInfo.put(VdsProperties.display, legacyDisplay);
    }
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Long>> storageQosIoTuneMap = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    handleIoTune(vm, vmDevice, diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), loadStorageQos(diskImage));
                    }
                    handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
static void handleIoTune(VM vm, VmDevice vmDevice, DiskImage diskImage, Map<Guid, Guid> diskProfileStorageQosMap, Map<Guid, Map<String, Long>> storageQosIoTuneMap) {
    if (FeatureSupported.storageQoS(vm.getVdsGroupCompatibilityVersion())) {
        Map<String, Long> ioTune = buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
        if (ioTune != null) {
            if (vmDevice.getSpecParams() == null) {
                vmDevice.setSpecParams(new HashMap<>());
            }
            vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
        }
    }
}
#method_after
public static void handleIoTune(VmDevice vmDevice, StorageQos storageQos) {
    if (storageQos != null) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        vmDevice.getSpecParams().put(VdsProperties.Iotune, IoTuneUtils.ioTuneMapFrom(storageQos));
    }
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInfoBuilder.evaluateInterfaceType(ifaceType, vm.getHasAgent()), vm.getVdsGroupCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInfoBuilder.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
public static String evaluateInterfaceType(VmInterfaceType ifaceType, boolean vmHasAgent) {
    return ifaceType == VmInterfaceType.rtl8139_pv ? (vmHasAgent ? VmInterfaceType.pv.name() : VmInterfaceType.rtl8139.name()) : ifaceType.getInternalName();
}
#method_after
public static String evaluateInterfaceType(VmInterfaceType ifaceType, boolean vmHasAgent) {
    return ifaceType == VmInterfaceType.rtl8139_pv ? vmHasAgent ? VmInterfaceType.pv.name() : VmInterfaceType.rtl8139.name() : ifaceType.getInternalName();
}
#end_block

#method_before
@Override
protected void buildUnmanagedDevices() {
    Map<String, String> customMap = (createInfo.containsKey(VdsProperties.Custom)) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map struct = new HashMap();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#method_after
@Override
protected void buildUnmanagedDevices() {
    Map<String, String> customMap = createInfo.containsKey(VdsProperties.Custom) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map struct = new HashMap();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (Map struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), managedDevices);
        for (VmDevice vmDevice : managedDevices) {
            for (Map struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getVdsGroupCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel, Version clusterVersion) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    if (FeatureSupported.networkLinking(clusterVersion)) {
        struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    }
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    addNetworkFiltersToNic(struct, vmInterface);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    addNetworkFiltersToNic(struct, vmInterface);
}
#end_block

#method_before
static void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmInterface.getVnicProfileId());
    Network network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#method_after
static void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmInterface.getVnicProfileId());
    Network network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getClusterCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VnicProfileProperties> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VnicProfileProperties.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VnicProfileProperties.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VnicProfileProperties.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VnicProfileProperties> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            addQosForDevice(struct, vnicProfile);
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    addPortMirroringToVmInterface(struct, vnicProfile, network);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#end_block

#method_before
private static boolean addPortMirroringToVmInterface(Map<String, Object> struct, VnicProfile vnicProfile, Version version, Network network) {
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        if (FeatureSupported.portMirroring(version)) {
            struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(network.getName()));
        } else {
            return false;
        }
    }
    return true;
}
#method_after
private static void addPortMirroringToVmInterface(Map<String, Object> struct, VnicProfile vnicProfile, Network network) {
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(network.getName()));
    }
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#method_after
private static void addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile) {
    Guid qosId = vnicProfile.getNetworkQosId();
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
}
#end_block

#method_before
public static boolean addCustomPropertiesForDevice(Map<String, Object> struct, VM vm, VmDevice vmDevice, Version clusterVersion, Map<String, String> customProperties) {
    if (customProperties == null) {
        customProperties = new HashMap<>();
    }
    customProperties.putAll(vmDevice.getCustomProperties());
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(vmDevice.getId());
    if (runtimeCustomProperties != null) {
        customProperties.putAll(runtimeCustomProperties);
    }
    if (!customProperties.isEmpty()) {
        if (FeatureSupported.deviceCustomProperties(clusterVersion)) {
            struct.put(VdsProperties.Custom, customProperties);
        } else {
            return false;
        }
    }
    return true;
}
#method_after
public static void addCustomPropertiesForDevice(Map<String, Object> struct, VM vm, VmDevice vmDevice, Version clusterVersion, Map<String, String> customProperties) {
    if (customProperties == null) {
        customProperties = new HashMap<>();
    }
    customProperties.putAll(vmDevice.getCustomProperties());
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(vmDevice.getId());
    if (runtimeCustomProperties != null) {
        customProperties.putAll(runtimeCustomProperties);
    }
    if (!customProperties.isEmpty()) {
        struct.put(VdsProperties.Custom, customProperties);
    }
}
#end_block

#method_before
public static void addNetworkFiltersToNic(Map<String, Object> struct, VmNic vmNic) {
    final NetworkFilter networkFilter = fetchVnicProfileNetworkFilter(vmNic);
    if (networkFilter.isConfigurable()) {
        final String networkFilterName = networkFilter.getName();
        struct.put(VdsProperties.NW_FILTER, networkFilterName);
    }
}
#method_after
public static void addNetworkFiltersToNic(Map<String, Object> struct, VmNic vmNic) {
    final NetworkFilter networkFilter = fetchVnicProfileNetworkFilter(vmNic);
    if (networkFilter != null) {
        final String networkFilterName = networkFilter.getName();
        struct.put(VdsProperties.NW_FILTER, networkFilterName);
    }
}
#end_block

#method_before
private static NetworkFilter fetchVnicProfileNetworkFilter(VmNic vmNic) {
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmNic.getVnicProfileId());
    final Guid networkFilterId = vnicProfile.getNetworkFilterId();
    return DbFacade.getInstance().getNetworkFilterDao().getNetworkFilterById(networkFilterId);
}
#method_after
private static NetworkFilter fetchVnicProfileNetworkFilter(VmNic vmNic) {
    if (vmNic.getVnicProfileId() != null) {
        VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmNic.getVnicProfileId());
        if (vnicProfile != null) {
            final Guid networkFilterId = vnicProfile.getNetworkFilterId();
            return networkFilterId == null ? null : DbFacade.getInstance().getNetworkFilterDao().getNetworkFilterById(networkFilterId);
        }
    }
    return null;
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = getOsRepository().getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    } else if ("sata".equals(cdInterface)) {
        // SATA slot 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = (VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName()));
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, (isPayload) ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        } else if ("sata".equals(cdInterface)) {
            // SATA slot 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
protected void buildVmNumaProperties() {
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addNumaSetting(compatibilityVersion);
}
#method_after
protected void buildVmNumaProperties() {
    final String compatibilityVersion = vm.getCompatibilityVersion().toString();
    addNumaSetting(compatibilityVersion);
}
#end_block

#method_before
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDao().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
        if (totalVdsNumaNodes.isEmpty()) {
            log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
            return;
        }
        // create a default one with one guest numa node
        if (vmNumaNodes.isEmpty()) {
            if (FeatureSupported.hotPlugMemory(vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
                VmNumaNode vmNode = new VmNumaNode();
                vmNode.setIndex(0);
                vmNode.setMemTotal(vm.getMemSizeMb());
                for (int i = 0; i < vm.getNumOfCpus(); i++) {
                    vmNode.getCpuIds().add(i);
                }
                vmNumaNodes.add(vmNode);
            } else {
                // no need to send numa if memory hotplug not supported
                return;
            }
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#method_after
private void addNumaSetting(final String compatibilityVersion) {
    List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDao().getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#end_block

#method_before
public Integer getSystemStatisticsValue(String entity, String status) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("entity", entity).addValue("status", status);
    RowMapper<Integer> mapper = new RowMapper<Integer>() {

        @Override
        public Integer mapRow(ResultSet rs, int rowNum) throws SQLException {
            return rs.getInt("val");
        }
    };
    Map<String, Object> dbResults = dbEngineDialect.createJdbcCallForQuery(jdbcTemplate).withProcedureName("Getsystem_statistics").returningResultSet("RETURN_VALUE", mapper).execute(parameterSource);
    return (Integer) DbFacadeUtils.asSingleResult((List<?>) (dbResults.get("RETURN_VALUE")));
}
#method_after
public Integer getSystemStatisticsValue(String entity, String status) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("entity", entity).addValue("status", status);
    RowMapper<Integer> mapper = new RowMapper<Integer>() {

        @Override
        public Integer mapRow(ResultSet rs, int rowNum) throws SQLException {
            return rs.getInt("val");
        }
    };
    Map<String, Object> dbResults = dbEngineDialect.createJdbcCallForQuery(jdbcTemplate).withProcedureName("Getsystem_statistics").returningResultSet("RETURN_VALUE", mapper).execute(parameterSource);
    return (Integer) DbFacadeUtils.asSingleResult((List<?>) dbResults.get("RETURN_VALUE"));
}
#end_block

#method_before
public boolean checkDBConnection() {
    return (new SimpleJdbcCall(jdbcTemplate).withProcedureName("CheckDBConnection").execute() != null);
}
#method_after
public boolean checkDBConnection() {
    return new SimpleJdbcCall(jdbcTemplate).withProcedureName("CheckDBConnection").execute() != null;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_BRICK);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__GLUSTER_BRICK);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ReplaceGlusterVolumeBrick, new ReplaceGlusterVolumeBrickActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getAction(), getParameters().getExistingBrick().getQualifiedName(), getParameters().getNewBrick().getQualifiedName(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        if (getParameters().getAction() == GlusterTaskOperation.COMMIT) {
            getParameters().getNewBrick().setStatus(getParameters().getExistingBrick().getStatus());
            getGlusterBrickDao().replaceBrick(getParameters().getExistingBrick(), getParameters().getNewBrick());
        }
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ReplaceGlusterVolumeBrick, new ReplaceGlusterVolumeBrickActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getExistingBrick().getQualifiedName(), getParameters().getNewBrick().getQualifiedName()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        getParameters().getNewBrick().setStatus(getParameters().getExistingBrick().getStatus());
        getGlusterBrickDao().replaceBrick(getParameters().getExistingBrick(), getParameters().getNewBrick());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, String> migrationInfo) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.migrate(migrationInfo);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, Object> migrationInfo) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.migrate(migrationInfo);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    try {
        Map<String, Object> xmlRpcReturnValue = null;
        if (devicesList != null) {
            xmlRpcReturnValue = vdsServer.getDeviceList(storageType, devicesList);
        } else {
            xmlRpcReturnValue = vdsServer.getDeviceList(storageType);
        }
        LUNListReturnForXmlRpc wrapper = new LUNListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    try {
        String[] idsList = devicesList == null ? new String[] {} : devicesList;
        Map<String, Object> xmlRpcReturnValue = vdsServer.getDeviceList(storageType, idsList, checkStatus);
        LUNListReturnForXmlRpc wrapper = new LUNListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonds, Map options) {
    return vdsServer.futureSetupNetworks(networks, bonds, options);
}
#method_after
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonds, Map options, boolean isPolicyReset) {
    return vdsServer.futureSetupNetworks(networks, bonds, options);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, disks, memory);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, disks, memory, frozen);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.registerSecrets(libvirtSecrets, clearUnusedSecrets);
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.registerSecrets(libvirtSecrets, clearUnusedSecrets);
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<String>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturnForXmlRpc list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc list(String isFull, String[] vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", new ArrayList<String>(Arrays.asList(vmIds))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturnForXmlRpc list(String isFull, String[] vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(vmIds))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, String> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<String>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<String>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<String>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final ClientPolicy policy = client.getClientRetryPolicy();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(policy.clone(), false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(policy, true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            int connectionId = client.getConnectionId();
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed() && client.getConnectionId() == connectionId) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<String>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<String>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<String>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> timeBoundPoll(final long timeout, final TimeUnit unit) {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request, timeout, unit);
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> timeBoundPoll(final long timeout, final TimeUnit unit) {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(() -> new FutureMap(client, request, timeout, unit));
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<String>(Arrays.asList(transportList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<String>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturnForXmlRpc glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<String>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturnForXmlRpc glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#end_block

#method_before
private void prepareMocks(ReplaceGlusterVolumeBrickCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(vdsStaticDao).when(command).getVdsStaticDao();
    doReturn(networkDao).when(command).getNetworkDao();
    doReturn(interfaceDao).when(command).getInterfaceDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getDistributedVolume(volumeId1)).when(volumeDao).getById(volumeId1);
    doReturn(getDistributedVolume(volumeId2)).when(volumeDao).getById(volumeId2);
    doReturn(getReplicatedVolume(volumeId3, 2)).when(volumeDao).getById(volumeId3);
    doReturn(getReplicatedVolume(volumeId4, 4)).when(volumeDao).getById(volumeId4);
    doReturn(null).when(volumeDao).getById(null);
    doReturn(getVdsStatic()).when(vdsStaticDao).get(serverId);
    doReturn(getVDsGroup()).when(command).getVdsGroup();
}
#method_after
private void prepareMocks(ReplaceGlusterVolumeBrickCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(vdsStaticDao).when(command).getVdsStaticDao();
    doReturn(networkDao).when(command).getNetworkDao();
    doReturn(interfaceDao).when(command).getInterfaceDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getDistributedVolume(volumeId1)).when(volumeDao).getById(volumeId1);
    doReturn(getDistributedVolume(volumeId2)).when(volumeDao).getById(volumeId2);
    doReturn(getReplicatedVolume(volumeId3, 2)).when(volumeDao).getById(volumeId3);
    doReturn(getReplicatedVolume(volumeId4, 4)).when(volumeDao).getById(volumeId4);
    doReturn(null).when(volumeDao).getById(null);
    doReturn(getVdsStatic()).when(vdsStaticDao).get(serverId);
    doReturn(getCluster()).when(command).getCluster();
}
#end_block

#method_before
private VDS getVds(VDSStatus status) {
    VDS vds = new VDS();
    vds.setId(Guid.newGuid());
    vds.setVdsName("gfs1");
    vds.setVdsGroupId(clusterId);
    vds.setStatus(status);
    return vds;
}
#method_after
private VDS getVds(VDSStatus status) {
    VDS vds = new VDS();
    vds.setId(Guid.newGuid());
    vds.setVdsName("gfs1");
    vds.setClusterId(clusterId);
    vds.setStatus(status);
    return vds;
}
#end_block

#method_before
private VdsStatic getVdsStatic() {
    VdsStatic vds = new VdsStatic();
    vds.setVdsGroupId(clusterId);
    vds.setHostName(serverName);
    return vds;
}
#method_after
private VdsStatic getVdsStatic() {
    VdsStatic vds = new VdsStatic();
    vds.setClusterId(clusterId);
    vds.setHostName(serverName);
    return vds;
}
#end_block

#method_before
private GlusterVolumeEntity getDistributedVolume(Guid volumeId) {
    GlusterVolumeEntity volume = getVolume(volumeId);
    volume.setStatus((volumeId == volumeId1) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volume.setBricks(getBricks(volumeId, "distrib", 2));
    volume.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volume.setClusterId(clusterId);
    return volume;
}
#method_after
private GlusterVolumeEntity getDistributedVolume(Guid volumeId) {
    GlusterVolumeEntity volume = getVolume(volumeId);
    volume.setStatus((volumeId == volumeId1) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volume.setBricks(getBricks(volumeId, "distrib", 2));
    volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    volume.setClusterId(clusterId);
    return volume;
}
#end_block

#method_before
private List<GlusterBrickEntity> getBricks(Guid volumeId, String dirPrefix, int n) {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    GlusterBrickEntity brick;
    for (Integer i = 0; i < n; i++) {
        brick = new GlusterBrickEntity();
        brick.setVolumeId(volumeId);
        brick.setServerId(serverId);
        brick.setServerName(serverName);
        brick.setBrickDirectory("/tmp/" + dirPrefix + i.toString());
        brick.setStatus(GlusterStatus.UP);
        bricks.add(brick);
    }
    return bricks;
}
#method_after
private List<GlusterBrickEntity> getBricks(Guid volumeId, String dirPrefix, int n) {
    List<GlusterBrickEntity> bricks = new ArrayList<>();
    GlusterBrickEntity brick;
    for (Integer i = 0; i < n; i++) {
        brick = new GlusterBrickEntity();
        brick.setVolumeId(volumeId);
        brick.setServerId(serverId);
        brick.setServerName(serverName);
        brick.setBrickDirectory("/tmp/" + dirPrefix + i.toString());
        brick.setStatus(GlusterStatus.UP);
        bricks.add(brick);
    }
    return bricks;
}
#end_block

#method_before
private ReplaceGlusterVolumeBrickCommand createTestCommand1(Guid volumeId) {
    return new ReplaceGlusterVolumeBrickCommand(new GlusterVolumeReplaceBrickActionParameters(volumeId, GlusterTaskOperation.COMMIT, getBricks(volumeId, "distrib", 1).get(0), getBricks(volumeId, "new", 1).get(0), true));
}
#method_after
private ReplaceGlusterVolumeBrickCommand createTestCommand1(Guid volumeId) {
    return new ReplaceGlusterVolumeBrickCommand(new GlusterVolumeReplaceBrickActionParameters(volumeId, getBricks(volumeId, "distrib", 1).get(0), getBricks(volumeId, "new", 1).get(0)), null);
}
#end_block

#method_before
private ReplaceGlusterVolumeBrickCommand createTestCommand2(Guid volumeId) {
    return new ReplaceGlusterVolumeBrickCommand(new GlusterVolumeReplaceBrickActionParameters(volumeId, GlusterTaskOperation.COMMIT, null, getBricks(volumeId, "", 1).get(0), true));
}
#method_after
private ReplaceGlusterVolumeBrickCommand createTestCommand2(Guid volumeId) {
    return new ReplaceGlusterVolumeBrickCommand(new GlusterVolumeReplaceBrickActionParameters(volumeId, null, getBricks(volumeId, "", 1).get(0)), null);
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || volumeEntity.getVolumeType().isDispersedType()) {
        allowRemove = false;
        allowAdd = false;
    }
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || volumeEntity.getVolumeType().isDispersedType() || !volumeEntity.getVolumeType().isSupported()) {
        allowRemove = false;
        allowAdd = false;
    }
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
            allowReplace = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#end_block

#method_before
private void checkUpServerAndAddBricks() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    AsyncDataProvider.getInstance().isAnyHostUpInCluster(new AsyncQuery(volumeEntity, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object entity, Object returnValue) {
            boolean clusterHasUpHost = (Boolean) returnValue;
            if (clusterHasUpHost) {
                addBricks((GlusterVolumeEntity) entity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().cannotAddBricksNoUpServerFound());
                model.setHelpTag(HelpTag.cannot_add_bricks);
                // $NON-NLS-1$
                model.setHashName("cannot_add_bricks");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
                return;
            }
        }
    }), volumeEntity.getVdsGroupName());
}
#method_after
private void checkUpServerAndAddBricks() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    AsyncDataProvider.getInstance().isAnyHostUpInCluster(new AsyncQuery(volumeEntity, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object entity, Object returnValue) {
            boolean clusterHasUpHost = (Boolean) returnValue;
            if (clusterHasUpHost) {
                addBricks((GlusterVolumeEntity) entity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().cannotAddBricksNoUpServerFound());
                model.setHelpTag(HelpTag.cannot_add_bricks);
                // $NON-NLS-1$
                model.setHashName("cannot_add_bricks");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
                return;
            }
        }
    }), volumeEntity.getClusterName());
}
#end_block

#method_before
private void addBricks(GlusterVolumeEntity volumeEntity) {
    final VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangeable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangeable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    volumeBrickModel.setHelpTag(HelpTag.add_bricks);
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            volumeBrickModel.getForce().setIsAvailable(GlusterFeaturesUtil.isGlusterForceAddBricksSupported(cluster.getCompatibilityVersion()));
            volumeBrickModel.setIsBrickProvisioningSupported(GlusterFeaturesUtil.isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion()));
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.setHostList(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel<GlusterBrickEntity>>());
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnAddBricks", this);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    volumeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void addBricks(GlusterVolumeEntity volumeEntity) {
    final VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangeable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangeable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    volumeBrickModel.setHelpTag(HelpTag.add_bricks);
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Cluster cluster = (Cluster) result;
            volumeBrickModel.getForce().setIsAvailable(true);
            volumeBrickModel.setIsBrickProvisioningSupported();
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.setHostList(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel<GlusterBrickEntity>>());
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnAddBricks", this);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    volumeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void onAddBricks() {
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    if (volumeBrickModel == null) {
        return;
    }
    if (!volumeBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeBrickModel.getBricks().getItems()) {
        GlusterBrickEntity brickEntity = (GlusterBrickEntity) ((EntityModel) model).getEntity();
        brickEntity.setVolumeId(volumeEntity.getId());
        brickList.add(brickEntity);
    }
    volumeBrickModel.setMessage(null);
    if (!validateReplicaStripeCount(volumeEntity, volumeBrickModel)) {
        return;
    }
    if (brickList.size() == 0) {
        volumeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().emptyAddBricksMsg());
        return;
    }
    if (!VolumeBrickModel.validateBrickCount(volumeEntity.getVolumeType(), volumeEntity.getBricks().size() + brickList.size(), volumeBrickModel.getReplicaCountValue(), volumeBrickModel.getStripeCountValue(), false)) {
        volumeBrickModel.setMessage(VolumeBrickModel.getValidationFailedMsg(volumeEntity.getVolumeType(), false));
        return;
    }
    if ((volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE || volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) && !volumeBrickModel.validateReplicateBricks(volumeEntity.getReplicaCount(), volumeEntity.getBricks())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksReplicateConfirmationTitle());
        confirmModel.setHelpTag(HelpTag.add_bricks_confirmation);
        // $NON-NLS-1$
        confirmModel.setHashName("add_bricks_confirmation");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().addBricksToReplicateVolumeFromSameServerMsg());
        // $NON-NLS-1$
        UICommand okCommand = new UICommand("OnAddBricksInternal", this);
        okCommand.setTitle(ConstantsManager.getInstance().getConstants().yes());
        okCommand.setIsDefault(true);
        getConfirmWindow().getCommands().add(okCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = new UICommand("CancelConfirmation", this);
        cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().no());
        cancelCommand.setIsCancel(true);
        getConfirmWindow().getCommands().add(cancelCommand);
    } else {
        onAddBricksInternal();
    }
}
#method_after
private void onAddBricks() {
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    if (volumeBrickModel == null) {
        return;
    }
    if (!volumeBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<>();
    for (Object model : volumeBrickModel.getBricks().getItems()) {
        GlusterBrickEntity brickEntity = (GlusterBrickEntity) ((EntityModel) model).getEntity();
        brickEntity.setVolumeId(volumeEntity.getId());
        brickList.add(brickEntity);
    }
    volumeBrickModel.setMessage(null);
    if (!validateReplicaStripeCount(volumeEntity, volumeBrickModel)) {
        return;
    }
    if (brickList.size() == 0) {
        volumeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().emptyAddBricksMsg());
        return;
    }
    if (!VolumeBrickModel.validateBrickCount(volumeEntity.getVolumeType(), volumeEntity.getBricks().size() + brickList.size(), volumeBrickModel.getReplicaCountValue(), volumeBrickModel.getStripeCountValue(), false)) {
        volumeBrickModel.setMessage(VolumeBrickModel.getValidationFailedMsg(volumeEntity.getVolumeType(), false));
        return;
    }
    if ((volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE || volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) && !volumeBrickModel.validateReplicateBricks(volumeEntity.getReplicaCount(), volumeEntity.getBricks())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksReplicateConfirmationTitle());
        confirmModel.setHelpTag(HelpTag.add_bricks_confirmation);
        // $NON-NLS-1$
        confirmModel.setHashName("add_bricks_confirmation");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().addBricksToReplicateVolumeFromSameServerMsg());
        // $NON-NLS-1$
        UICommand okCommand = new UICommand("OnAddBricksInternal", this);
        okCommand.setTitle(ConstantsManager.getInstance().getConstants().yes());
        okCommand.setIsDefault(true);
        getConfirmWindow().getCommands().add(okCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = new UICommand("CancelConfirmation", this);
        cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().no());
        cancelCommand.setIsCancel(true);
        getConfirmWindow().getCommands().add(cancelCommand);
    } else {
        onAddBricksInternal();
    }
}
#end_block

#method_before
private void onAddBricksInternal() {
    cancelConfirmation();
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    GlusterVolumeEntity volumeEntity = getEntity();
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeBrickModel.getBricks().getItems()) {
        GlusterBrickEntity brickEntity = (GlusterBrickEntity) ((EntityModel) model).getEntity();
        brickEntity.setVolumeId(volumeEntity.getId());
        brickList.add(brickEntity);
    }
    volumeBrickModel.startProgress(null);
    GlusterVolumeBricksActionParameters parameter = new GlusterVolumeBricksActionParameters(volumeEntity.getId(), brickList, volumeBrickModel.getReplicaCountValue(), volumeBrickModel.getStripeCountValue(), volumeBrickModel.getForce().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddBricksToGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeBrickListModel localModel = (VolumeBrickListModel) result.getState();
            localModel.postOnAddBricks(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onAddBricksInternal() {
    cancelConfirmation();
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    GlusterVolumeEntity volumeEntity = getEntity();
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<>();
    for (Object model : volumeBrickModel.getBricks().getItems()) {
        GlusterBrickEntity brickEntity = (GlusterBrickEntity) ((EntityModel) model).getEntity();
        brickEntity.setVolumeId(volumeEntity.getId());
        brickList.add(brickEntity);
    }
    volumeBrickModel.startProgress();
    GlusterVolumeBricksActionParameters parameter = new GlusterVolumeBricksActionParameters(volumeEntity.getId(), brickList, volumeBrickModel.getReplicaCountValue(), volumeBrickModel.getStripeCountValue(), volumeBrickModel.getForce().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddBricksToGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeBrickListModel localModel = (VolumeBrickListModel) result.getState();
            localModel.postOnAddBricks(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void removeBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    RemoveBrickModel removeBrickModel = new RemoveBrickModel();
    removeBrickModel.setHelpTag(HelpTag.volume_remove_bricks);
    // $NON-NLS-1$
    removeBrickModel.setHashName("volume_remove_bricks");
    removeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksTitle());
    setWindow(removeBrickModel);
    removeBrickModel.setReplicaCount(volumeEntity.getReplicaCount());
    removeBrickModel.setStripeCount(volumeEntity.getStripeCount());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity item : Linq.<GlusterBrickEntity>cast(getSelectedItems())) {
        list.add(item.getQualifiedName());
    }
    removeBrickModel.setItems(list);
    if (!validateRemoveBricks(volumeEntity.getVolumeType(), Linq.<GlusterBrickEntity>cast(getSelectedItems()), volumeEntity.getBricks(), removeBrickModel)) {
        removeBrickModel.setMigrationSupported(false);
        removeBrickModel.setMessage(removeBrickModel.getValidationMessage());
    } else {
        removeBrickModel.setMigrationSupported(volumeEntity.getVolumeType().isDistributedType());
        removeBrickModel.getMigrateData().setEntity(removeBrickModel.isMigrationSupported());
        if (removeBrickModel.isReduceReplica()) {
            if (volumeEntity.getName().equals(glusterMetaVolumeName) && volumeEntity.getReplicaCount() <= 3) {
                removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksMessage());
                removeBrickModel.setNote(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksWarning());
            } else {
                removeBrickModel.setMessage(ConstantsManager.getInstance().getMessages().removeBricksReplicateVolumeMessage(volumeEntity.getReplicaCount(), volumeEntity.getReplicaCount() - 1));
                removeBrickModel.setMigrationSupported(false);
                removeBrickModel.getMigrateData().setEntity(false);
            }
        } else {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeBricksMessage());
        }
        // $NON-NLS-1$
        UICommand command = UICommand.createDefaultOkUiCommand("OnRemove", this);
        removeBrickModel.getCommands().add(command);
    }
    // $NON-NLS-1$
    removeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void removeBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    RemoveBrickModel removeBrickModel = new RemoveBrickModel();
    removeBrickModel.setHelpTag(HelpTag.volume_remove_bricks);
    // $NON-NLS-1$
    removeBrickModel.setHashName("volume_remove_bricks");
    removeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksTitle());
    setWindow(removeBrickModel);
    removeBrickModel.setReplicaCount(volumeEntity.getReplicaCount());
    removeBrickModel.setStripeCount(volumeEntity.getStripeCount());
    ArrayList<String> list = new ArrayList<>();
    for (GlusterBrickEntity item : Linq.<GlusterBrickEntity>cast(getSelectedItems())) {
        list.add(item.getQualifiedName());
    }
    removeBrickModel.setItems(list);
    if (!validateRemoveBricks(volumeEntity.getVolumeType(), Linq.<GlusterBrickEntity>cast(getSelectedItems()), volumeEntity.getBricks(), removeBrickModel)) {
        removeBrickModel.setMigrationSupported(false);
        removeBrickModel.setMessage(removeBrickModel.getValidationMessage());
    } else {
        removeBrickModel.setMigrationSupported(volumeEntity.getVolumeType().isDistributedType());
        removeBrickModel.getMigrateData().setEntity(removeBrickModel.isMigrationSupported());
        if (removeBrickModel.isReduceReplica()) {
            if (volumeEntity.getName().equals(glusterMetaVolumeName) && volumeEntity.getReplicaCount() <= 3) {
                removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksMessage());
                removeBrickModel.setNote(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksWarning());
            } else {
                removeBrickModel.setMessage(ConstantsManager.getInstance().getMessages().removeBricksReplicateVolumeMessage(volumeEntity.getReplicaCount(), volumeEntity.getReplicaCount() - 1));
                removeBrickModel.setMigrationSupported(false);
                removeBrickModel.getMigrateData().setEntity(false);
            }
        } else {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeBricksMessage());
        }
        // $NON-NLS-1$
        UICommand command = UICommand.createDefaultOkUiCommand("OnRemove", this);
        removeBrickModel.getCommands().add(command);
    }
    // $NON-NLS-1$
    removeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
public boolean validateDistriputedReplicateRemove(GlusterVolumeType volumeType, List<GlusterBrickEntity> selectedBricks, List<GlusterBrickEntity> brickList, RemoveBrickModel removeBrickModel) {
    int replicaCount = removeBrickModel.getReplicaCount();
    int distributions = brickList.size() / replicaCount;
    // Key - No.of.bricks selected in sub-volume
    // Value - No.of sub-volumes which has 'Key' no.of bricks selected
    Map<Integer, Integer> selectedBricksToSubVolumesMap = new HashMap<Integer, Integer>();
    for (int distIndex = 0; distIndex < distributions; distIndex++) {
        List<GlusterBrickEntity> bricksInSubVolumeList = brickList.subList((distIndex * replicaCount), (distIndex * replicaCount) + replicaCount);
        int selectedBricksInSubVolume = 0;
        for (GlusterBrickEntity brick : bricksInSubVolumeList) {
            if (selectedBricks.contains(brick)) {
                selectedBricksInSubVolume++;
            }
        }
        if (selectedBricksInSubVolume > 0) {
            if (!selectedBricksToSubVolumesMap.containsKey(selectedBricksInSubVolume)) {
                selectedBricksToSubVolumesMap.put(selectedBricksInSubVolume, 0);
            }
            selectedBricksToSubVolumesMap.put(selectedBricksInSubVolume, selectedBricksToSubVolumesMap.get(selectedBricksInSubVolume) + 1);
        }
    }
    // sub-volumes, hence not valid for removal.
    if (selectedBricksToSubVolumesMap.size() == 1) {
        // If the user has selected once brick from each sub-volume, then replica count needs to be reduced
        if (selectedBricksToSubVolumesMap.containsKey(1) && selectedBricksToSubVolumesMap.get(1) == distributions) {
            removeBrickModel.setReplicaCount(removeBrickModel.getReplicaCount() - 1);
            removeBrickModel.setReduceReplica(true);
            return true;
        } else if (selectedBricksToSubVolumesMap.containsKey(replicaCount)) {
            return true;
        }
        return false;
    }
    return false;
}
#method_after
public boolean validateDistriputedReplicateRemove(GlusterVolumeType volumeType, List<GlusterBrickEntity> selectedBricks, List<GlusterBrickEntity> brickList, RemoveBrickModel removeBrickModel) {
    int replicaCount = removeBrickModel.getReplicaCount();
    int distributions = brickList.size() / replicaCount;
    // Key - No.of.bricks selected in sub-volume
    // Value - No.of sub-volumes which has 'Key' no.of bricks selected
    Map<Integer, Integer> selectedBricksToSubVolumesMap = new HashMap<>();
    for (int distIndex = 0; distIndex < distributions; distIndex++) {
        List<GlusterBrickEntity> bricksInSubVolumeList = brickList.subList(distIndex * replicaCount, (distIndex * replicaCount) + replicaCount);
        int selectedBricksInSubVolume = 0;
        for (GlusterBrickEntity brick : bricksInSubVolumeList) {
            if (selectedBricks.contains(brick)) {
                selectedBricksInSubVolume++;
            }
        }
        if (selectedBricksInSubVolume > 0) {
            if (!selectedBricksToSubVolumesMap.containsKey(selectedBricksInSubVolume)) {
                selectedBricksToSubVolumesMap.put(selectedBricksInSubVolume, 0);
            }
            selectedBricksToSubVolumesMap.put(selectedBricksInSubVolume, selectedBricksToSubVolumesMap.get(selectedBricksInSubVolume) + 1);
        }
    }
    // sub-volumes, hence not valid for removal.
    if (selectedBricksToSubVolumesMap.size() == 1) {
        // If the user has selected once brick from each sub-volume, then replica count needs to be reduced
        if (selectedBricksToSubVolumesMap.containsKey(1) && selectedBricksToSubVolumesMap.get(1) == distributions) {
            removeBrickModel.setReplicaCount(removeBrickModel.getReplicaCount() - 1);
            removeBrickModel.setReduceReplica(true);
            return true;
        } else if (selectedBricksToSubVolumesMap.containsKey(replicaCount)) {
            return true;
        }
        return false;
    }
    return false;
}
#end_block

#method_before
public boolean validateDistriputedStripeRemove(GlusterVolumeType volumeType, List<GlusterBrickEntity> selectedBricks, List<GlusterBrickEntity> brickList, RemoveBrickModel removeBrickModel) {
    int stripeCount = removeBrickModel.getStripeCount();
    int distributions = brickList.size() / stripeCount;
    if (selectedBricks.size() != stripeCount) {
        return false;
    }
    for (int i = 0; i < distributions; i++) {
        List<GlusterBrickEntity> subBrickList = brickList.subList((i * stripeCount), (i * stripeCount) + stripeCount);
        if (subBrickList.containsAll(selectedBricks)) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean validateDistriputedStripeRemove(GlusterVolumeType volumeType, List<GlusterBrickEntity> selectedBricks, List<GlusterBrickEntity> brickList, RemoveBrickModel removeBrickModel) {
    int stripeCount = removeBrickModel.getStripeCount();
    int distributions = brickList.size() / stripeCount;
    if (selectedBricks.size() != stripeCount) {
        return false;
    }
    for (int i = 0; i < distributions; i++) {
        List<GlusterBrickEntity> subBrickList = brickList.subList(i * stripeCount, (i * stripeCount) + stripeCount);
        if (subBrickList.containsAll(selectedBricks)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void onRemoveBricks() {
    if (getWindow() == null) {
        return;
    }
    RemoveBrickModel model = (RemoveBrickModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), getSelectedItems());
    if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE) {
        parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (model.isReduceReplica()) {
            parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
        } else {
            parameter.setReplicaCount(volumeEntity.getReplicaCount());
        }
    }
    model.startProgress(null);
    boolean isMigrate = model.getMigrateData().getEntity();
    Frontend.getInstance().runAction(isMigrate ? VdcActionType.StartRemoveGlusterVolumeBricks : VdcActionType.GlusterVolumeRemoveBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, model);
}
#method_after
private void onRemoveBricks() {
    if (getWindow() == null) {
        return;
    }
    RemoveBrickModel model = (RemoveBrickModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), getSelectedItems());
    if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE) {
        parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (model.isReduceReplica()) {
            parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
        } else {
            parameter.setReplicaCount(volumeEntity.getReplicaCount());
        }
    }
    model.startProgress();
    boolean isMigrate = model.getMigrateData().getEntity();
    Frontend.getInstance().runAction(isMigrate ? VdcActionType.StartRemoveGlusterVolumeBricks : VdcActionType.GlusterVolumeRemoveBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, model);
}
#end_block

#method_before
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    model.setHelpTag(HelpTag.volume_remove_bricks_stop);
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnStopRemoveBricks", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    model.setHelpTag(HelpTag.volume_remove_bricks_stop);
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnStopRemoveBricks", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
            }
        }
    }, model);
}
#method_after
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
            }
        }
    }, model);
}
#end_block

#method_before
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    model.setHelpTag(HelpTag.volume_remove_bricks_commit);
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnCommitRemoveBricks", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("CancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    model.setHelpTag(HelpTag.volume_remove_bricks_commit);
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnCommitRemoveBricks", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("CancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onCommitRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.CommitRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                disableRemoveBrickStatusPopUpActions();
            }
        }
    }, model);
}
#method_after
private void onCommitRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.CommitRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                disableRemoveBrickStatusPopUpActions();
            }
        }
    }, model);
}
#end_block

#method_before
private void showRemoveBricksStatus() {
    final GlusterVolumeEntity volumeEntity = getVolumeEntity();
    final ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    cModel.setHelpTag(HelpTag.volume_remove_bricks_status);
    // //$NON-NLS-1$
    cModel.setHashName("volume_remove_bricks_status");
    // $NON-NLS-1$
    UICommand removeBrickStatusOk = new UICommand("CancelConfirmation", VolumeBrickListModel.this);
    removeBrickStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    removeBrickStatusOk.setIsCancel(true);
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.getCommands().add(removeBrickStatusOk);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setConfirmWindow(cModel);
    // $NON-NLS-1$
    final UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    AsyncDataProvider.getInstance().getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            if (vdcValue.getSucceeded() && vdcValue.getReturnValue() != null) {
                cancelConfirmation();
                RemoveBrickStatusModel removeBrickStatusModel;
                GlusterVolumeTaskStatusEntity removeBrickStatusEntity = vdcValue.getReturnValue();
                if (getWindow() == null) {
                    removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
                    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
                    removeBrickStatusModel.setHelpTag(HelpTag.volume_remove_bricks_status);
                    // //$NON-NLS-1$
                    removeBrickStatusModel.setHashName("volume_remove_bricks_status");
                    setWindow(removeBrickStatusModel);
                    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
                    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
                    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
                    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
                    removeBrickStatusModel.getCommands().add(cancelCommand);
                } else {
                    removeBrickStatusModel = (RemoveBrickStatusModel) getWindow();
                }
                removeBrickStatusModel.showStatus(removeBrickStatusEntity);
            } else {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().removeBrickStatusFailed(volumeEntity.getName()));
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
}
#method_after
private void showRemoveBricksStatus() {
    final GlusterVolumeEntity volumeEntity = getVolumeEntity();
    final ArrayList<GlusterBrickEntity> bricks = new ArrayList<>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    cModel.setHelpTag(HelpTag.volume_remove_bricks_status);
    // //$NON-NLS-1$
    cModel.setHashName("volume_remove_bricks_status");
    // $NON-NLS-1$
    UICommand removeBrickStatusOk = new UICommand("CancelConfirmation", VolumeBrickListModel.this);
    removeBrickStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    removeBrickStatusOk.setIsCancel(true);
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.getCommands().add(removeBrickStatusOk);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setConfirmWindow(cModel);
    // $NON-NLS-1$
    final UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    AsyncDataProvider.getInstance().getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            if (vdcValue.getSucceeded() && vdcValue.getReturnValue() != null) {
                cancelConfirmation();
                RemoveBrickStatusModel removeBrickStatusModel;
                GlusterVolumeTaskStatusEntity removeBrickStatusEntity = vdcValue.getReturnValue();
                if (getWindow() == null) {
                    removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
                    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
                    removeBrickStatusModel.setHelpTag(HelpTag.volume_remove_bricks_status);
                    // //$NON-NLS-1$
                    removeBrickStatusModel.setHashName("volume_remove_bricks_status");
                    setWindow(removeBrickStatusModel);
                    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
                    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getClusterName());
                    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
                    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
                    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
                    removeBrickStatusModel.getCommands().add(cancelCommand);
                } else {
                    removeBrickStatusModel = (RemoveBrickStatusModel) getWindow();
                }
                removeBrickStatusModel.showStatus(removeBrickStatusEntity);
            } else {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().removeBrickStatusFailed(volumeEntity.getName()));
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
}
#end_block

#method_before
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    model.setHelpTag(HelpTag.volume_retain_brick);
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnRetainBricks", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    model.setHelpTag(HelpTag.volume_retain_brick);
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnRetainBricks", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onRetainBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
                disableRemoveBrickStatusPopUpActions();
            }
        }
    }, model);
}
#method_after
private void onRetainBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
                disableRemoveBrickStatusPopUpActions();
            }
        }
    }, model);
}
#end_block

#method_before
private void replaceBrick() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    ReplaceBrickModel brickModel = new ReplaceBrickModel();
    setWindow(brickModel);
    brickModel.setTitle(ConstantsManager.getInstance().getConstants().replaceBrickTitle());
    brickModel.setHelpTag(HelpTag.replace_brick);
    // $NON-NLS-1$
    brickModel.setHashName("replace_brick");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(brickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    ReplaceBrickModel brickModel = (ReplaceBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    brickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnReplace", this);
    brickModel.getCommands().add(command);
    // $NON-NLS-1$
    brickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void replaceBrick() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    ReplaceBrickModel brickModel = new ReplaceBrickModel();
    setWindow(brickModel);
    brickModel.setTitle(ConstantsManager.getInstance().getConstants().replaceBrickTitle());
    brickModel.setHelpTag(HelpTag.replace_brick);
    // $NON-NLS-1$
    brickModel.setHashName("replace_brick");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(brickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Cluster cluster = (Cluster) result;
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    ReplaceBrickModel brickModel = (ReplaceBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    brickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnReplace", this);
    brickModel.getCommands().add(command);
    // $NON-NLS-1$
    brickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void onReplaceBrick() {
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    if (replaceBrickModel == null) {
        return;
    }
    if (!replaceBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    GlusterBrickEntity existingBrick = getSelectedItem();
    if (existingBrick == null) {
        return;
    }
    VDS server = replaceBrickModel.getServers().getSelectedItem();
    GlusterBrickEntity newBrick = new GlusterBrickEntity();
    newBrick.setVolumeId(volumeEntity.getId());
    newBrick.setServerId(server.getId());
    newBrick.setServerName(server.getHostName());
    newBrick.setBrickDirectory(replaceBrickModel.getBrickDirectory().getEntity());
    replaceBrickModel.startProgress(null);
    GlusterVolumeReplaceBrickActionParameters parameter = new GlusterVolumeReplaceBrickActionParameters(volumeEntity.getId(), GlusterTaskOperation.COMMIT, existingBrick, newBrick, true);
    Frontend.getInstance().runAction(VdcActionType.ReplaceGlusterVolumeBrick, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ReplaceBrickModel localModel = (ReplaceBrickModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, replaceBrickModel);
}
#method_after
private void onReplaceBrick() {
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    if (replaceBrickModel == null) {
        return;
    }
    if (!replaceBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    GlusterBrickEntity existingBrick = getSelectedItem();
    if (existingBrick == null) {
        return;
    }
    VDS server = replaceBrickModel.getServers().getSelectedItem();
    GlusterBrickEntity newBrick = new GlusterBrickEntity();
    newBrick.setVolumeId(volumeEntity.getId());
    newBrick.setServerId(server.getId());
    newBrick.setServerName(server.getHostName());
    newBrick.setBrickDirectory(replaceBrickModel.getBrickDirectory().getEntity());
    replaceBrickModel.startProgress();
    GlusterVolumeReplaceBrickActionParameters parameter = new GlusterVolumeReplaceBrickActionParameters(volumeEntity.getId(), existingBrick, newBrick);
    Frontend.getInstance().runAction(VdcActionType.ReplaceGlusterVolumeBrick, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ReplaceBrickModel localModel = (ReplaceBrickModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, replaceBrickModel);
}
#end_block

#method_before
private void showBrickAdvancedDetails() {
    final GlusterVolumeEntity volumeEntity = getEntity();
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VDSGroup vdsGroup = (VDSGroup) returnValue;
            if (Version.v3_2.compareTo(vdsGroup.getCompatibilityVersion()) <= 0) {
                onShowBrickAdvancedDetails(volumeEntity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().advancedDetailsBrickTitle());
                model.setMessage(ConstantsManager.getInstance().getMessages().brickDetailsNotSupportedInClusterCompatibilityVersion(vdsGroup.getCompatibilityVersion() != null ? vdsGroup.getCompatibilityVersion().toString() : // $NON-NLS-1$
                ""));
                model.setHelpTag(HelpTag.brick_details_not_supported);
                // $NON-NLS-1$
                model.setHashName("brick_details_not_supported");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
            }
        }
    }), volumeEntity.getClusterId());
}
#method_after
private void showBrickAdvancedDetails() {
    final GlusterVolumeEntity volumeEntity = getEntity();
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            onShowBrickAdvancedDetails(volumeEntity);
        }
    }), volumeEntity.getClusterId());
}
#end_block

#method_before
private void onShowBrickAdvancedDetails(GlusterVolumeEntity volumeEntity) {
    final GlusterBrickEntity brickEntity = getSelectedItem();
    final BrickAdvancedDetailsModel brickModel = new BrickAdvancedDetailsModel();
    setWindow(brickModel);
    brickModel.setTitle(ConstantsManager.getInstance().getConstants().advancedDetailsBrickTitle());
    brickModel.setHelpTag(HelpTag.brick_advanced);
    // $NON-NLS-1$
    brickModel.setHashName("brick_advanced");
    brickModel.startProgress(null);
    AsyncDataProvider.getInstance().getGlusterVolumeBrickDetails(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            brickModel.stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null || !returnValue.getSucceeded()) {
                brickModel.setMessage(ConstantsManager.getInstance().getConstants().errorInFetchingBrickAdvancedDetails());
                return;
            }
            GlusterVolumeAdvancedDetails advDetails = returnValue.getReturnValue();
            brickModel.getBrick().setEntity(brickEntity.getQualifiedName());
            if (advDetails != null && advDetails.getBrickDetails() != null && advDetails.getBrickDetails().size() == 1) {
                BrickDetails brickDetails = advDetails.getBrickDetails().get(0);
                brickModel.getBrickProperties().setProperties(brickDetails.getBrickProperties());
                ArrayList<EntityModel<GlusterClientInfo>> clients = new ArrayList<EntityModel<GlusterClientInfo>>();
                for (GlusterClientInfo client : brickDetails.getClients()) {
                    clients.add(new EntityModel<GlusterClientInfo>(client));
                }
                brickModel.getClients().setItems(clients);
                brickModel.getMemoryStatistics().updateMemoryStatistics(brickDetails.getMemoryStatus().getMallInfo());
                ArrayList<EntityModel<Mempool>> memoryPools = new ArrayList<EntityModel<Mempool>>();
                for (Mempool mempool : brickDetails.getMemoryStatus().getMemPools()) {
                    memoryPools.add(new EntityModel<Mempool>(mempool));
                }
                brickModel.getMemoryPools().setItems(memoryPools);
            }
        }
    }, true), volumeEntity.getClusterId(), volumeEntity.getId(), brickEntity.getId());
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsCancel(true);
    brickModel.getCommands().add(command);
}
#method_after
private void onShowBrickAdvancedDetails(GlusterVolumeEntity volumeEntity) {
    final GlusterBrickEntity brickEntity = getSelectedItem();
    final BrickAdvancedDetailsModel brickModel = new BrickAdvancedDetailsModel();
    setWindow(brickModel);
    brickModel.setTitle(ConstantsManager.getInstance().getConstants().advancedDetailsBrickTitle());
    brickModel.setHelpTag(HelpTag.brick_advanced);
    // $NON-NLS-1$
    brickModel.setHashName("brick_advanced");
    brickModel.startProgress();
    AsyncDataProvider.getInstance().getGlusterVolumeBrickDetails(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            brickModel.stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null || !returnValue.getSucceeded()) {
                brickModel.setMessage(ConstantsManager.getInstance().getConstants().errorInFetchingBrickAdvancedDetails());
                return;
            }
            GlusterVolumeAdvancedDetails advDetails = returnValue.getReturnValue();
            brickModel.getBrick().setEntity(brickEntity.getQualifiedName());
            if (advDetails != null && advDetails.getBrickDetails() != null && advDetails.getBrickDetails().size() == 1) {
                BrickDetails brickDetails = advDetails.getBrickDetails().get(0);
                brickModel.getBrickProperties().setProperties(brickDetails.getBrickProperties());
                ArrayList<EntityModel<GlusterClientInfo>> clients = new ArrayList<>();
                for (GlusterClientInfo client : brickDetails.getClients()) {
                    clients.add(new EntityModel<>(client));
                }
                brickModel.getClients().setItems(clients);
                brickModel.getMemoryStatistics().updateMemoryStatistics(brickDetails.getMemoryStatus().getMallInfo());
                ArrayList<EntityModel<Mempool>> memoryPools = new ArrayList<>();
                for (Mempool mempool : brickDetails.getMemoryStatus().getMemPools()) {
                    memoryPools.add(new EntityModel<>(mempool));
                }
                brickModel.getMemoryPools().setItems(memoryPools);
            }
        }
    }, true), volumeEntity.getClusterId(), volumeEntity.getId(), brickEntity.getId());
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsCancel(true);
    brickModel.getCommands().add(command);
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    unLockImage();
    stopImageTransferSession(context.entity);
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    // If stopping the session did not succeed, don't change the upload state.
    if (stopImageTransferSession(context.entity)) {
        // We want to use the transferring vds for image actions for having a coherent log when uploading.
        Guid transferingVdsId = context.entity.getVdsId();
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
    }
}
#end_block

#method_before
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed upload to {}", getUploadDescription());
    setImageStatus(ImageStatus.ILLEGAL);
    stopImageTransferSession(context.entity);
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#method_after
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed upload to {}", getUploadDescription());
    stopImageTransferSession(context.entity);
    setImageStatus(ImageStatus.ILLEGAL);
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#end_block

#method_before
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
private void stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        return;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setClearResourceId(true);
    updateEntity(updates);
    tearDownImage(entity.getVdsId());
}
#method_after
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        log.warn("Failed to stop image transfer session. Ticket does not exist for image '{}'", entity.getDiskId());
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setClearResourceId(true);
    updateEntity(updates);
    tearDownImage(entity.getVdsId());
    return true;
}
#end_block

#method_before
private String getProxyUri() {
    String scheme = Config.<Boolean>getValue(ConfigValues.ImageProxySSLEnabled) ? "https" : "http";
    String address = Config.getValue(ConfigValues.ImageProxyAddress);
    return scheme + "://" + address + "/images";
}
#method_after
private String getProxyUri() {
    String scheme = Config.<Boolean>getValue(ConfigValues.ImageProxySSLEnabled) ? HTTPS_SCHEME : HTTP_SCHEME;
    String address = Config.getValue(ConfigValues.ImageProxyAddress);
    return scheme + address + IMAGES_PATH;
}
#end_block

#method_before
private String getImageDaemonUri(String daemonHostname) {
    String scheme = Config.<Boolean>getValue(ConfigValues.ImageDaemonSSLEnabled) ? "https" : "http";
    String port = Config.getValue(ConfigValues.ImageDaemonPort);
    return scheme + "://" + daemonHostname + ":" + port;
}
#method_after
private String getImageDaemonUri(String daemonHostname) {
    String port = Config.getValue(ConfigValues.ImageDaemonPort);
    return HTTPS_SCHEME + daemonHostname + ":" + port;
}
#end_block

#method_before
@Override
protected HttpClient createHttpClient() throws Error {
    int port = getPort();
    Credentials credentials = null;
    AuthSchemeRegistry schemeRegistry = new AuthSchemeRegistry();
    AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);
    // Set request timeout:
    if (timeout != -1) {
        HttpParams httpParams = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
        DefaultHttpClient.setDefaultHttpParams(httpParams);
    }
    // Create credentials:
    if (user != null && user.length() > 0) {
        schemeRegistry.register(AuthPolicy.BASIC, new BasicSchemeFactory());
        credentials = new UsernamePasswordCredentials(user, password);
    } else if (kerberos) {
        schemeRegistry.register(AuthPolicy.SPNEGO, new SPNegoSchemeFactory(true));
        credentials = new Credentials() {

            @Override
            public Principal getUserPrincipal() {
                return null;
            }

            @Override
            public String getPassword() {
                return null;
            }
        };
    }
    // Create http client:
    DefaultHttpClient client = new DefaultHttpClient(new BasicClientConnectionManager(createConnectionSocketFactoryRegistry()));
    client.setAuthSchemes(schemeRegistry);
    client.getCredentialsProvider().setCredentials(authScope, credentials);
    client.getParams().setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.IGNORE_COOKIES);
    if (compress) {
        return new HttpClient42(new DecompressingHttpClient(client));
    }
    return new HttpClient42(client);
}
#method_after
@Override
protected HttpClient createHttpClient() {
    int port = getPort();
    Credentials credentials = null;
    AuthSchemeRegistry schemeRegistry = new AuthSchemeRegistry();
    AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);
    // Set request timeout:
    if (timeout != -1) {
        HttpParams httpParams = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
        DefaultHttpClient.setDefaultHttpParams(httpParams);
    }
    // Create credentials:
    if (user != null && user.length() > 0) {
        schemeRegistry.register(AuthPolicy.BASIC, new BasicSchemeFactory());
        credentials = new UsernamePasswordCredentials(user, password);
    } else if (kerberos) {
        schemeRegistry.register(AuthPolicy.SPNEGO, new SPNegoSchemeFactory(true));
        credentials = new Credentials() {

            @Override
            public Principal getUserPrincipal() {
                return null;
            }

            @Override
            public String getPassword() {
                return null;
            }
        };
    }
    // Create http client:
    DefaultHttpClient client = new DefaultHttpClient(new BasicClientConnectionManager(createConnectionSocketFactoryRegistry()));
    client.setAuthSchemes(schemeRegistry);
    client.getCredentialsProvider().setCredentials(authScope, credentials);
    client.getParams().setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.IGNORE_COOKIES);
    if (compress) {
        return new HttpClient42(new DecompressingHttpClient(client));
    }
    return new HttpClient42(client);
}
#end_block

#method_before
private SchemeRegistry createConnectionSocketFactoryRegistry() throws Error {
    SchemeRegistry schemeRegistry = new SchemeRegistry();
    SSLSocketFactory sf;
    // Create SSL/TLS or plain connection:
    if (HTTP_PROTOCOL.equals(getProtocol())) {
        schemeRegistry.register(new Scheme(HTTP_PROTOCOL, getPort(), PlainSocketFactory.getSocketFactory()));
    } else if (HTTPS_PROTOCOL.equals(getProtocol())) {
        try {
            if (this.insecure) {
                SSLContext sslcontext = SSLContext.getInstance("TLS");
                sslcontext.init(null, new TrustManager[] { noCaTrustManager }, null);
                sf = new SSLSocketFactory(sslcontext, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            } else {
                KeyStore truststore = null;
                InputStream in = null;
                if (this.trustStoreFile != null) {
                    truststore = KeyStore.getInstance(KeyStore.getDefaultType());
                    try {
                        in = new FileInputStream(this.trustStoreFile);
                        truststore.load(in, this.trustStorePassword != null ? this.trustStorePassword.toCharArray() : null);
                    } finally {
                        if (in != null) {
                            in.close();
                        }
                    }
                }
                sf = new SSLSocketFactory(SSLSocketFactory.TLS, null, null, truststore, null, null, SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
            }
            schemeRegistry.register(new Scheme(HTTPS_PROTOCOL, getPort(), sf));
        } catch (NoSuchAlgorithmException e) {
            throw new Error(NO_TLS_ERROR, e);
        } catch (KeyManagementException e) {
            throw new Error(BAD_KEY_ERROR, e);
        } catch (KeyStoreException e) {
            throw new Error(KEY_STORE_ERROR, e);
        } catch (FileNotFoundException e) {
            throw new Error(KEY_STORE_FILE_NOT_FOUND_ERROR, e);
        } catch (CertificateException e) {
            throw new Error(CERTIFICATE_ERROR, e);
        } catch (IOException e) {
            throw new Error(IO_ERROR, e);
        } catch (UnrecoverableKeyException e) {
            throw new Error(UNRECOVERABLE_KEY_ERROR, e);
        }
    }
    return schemeRegistry;
}
#method_after
private SchemeRegistry createConnectionSocketFactoryRegistry() {
    SchemeRegistry schemeRegistry = new SchemeRegistry();
    SSLSocketFactory sf;
    // Create SSL/TLS or plain connection:
    if (HTTP_PROTOCOL.equals(getProtocol())) {
        schemeRegistry.register(new Scheme(HTTP_PROTOCOL, getPort(), PlainSocketFactory.getSocketFactory()));
    } else if (HTTPS_PROTOCOL.equals(getProtocol())) {
        try {
            if (this.insecure) {
                SSLContext sslcontext = SSLContext.getInstance("TLS");
                sslcontext.init(null, new TrustManager[] { noCaTrustManager }, null);
                sf = new SSLSocketFactory(sslcontext, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            } else {
                KeyStore truststore = null;
                InputStream in = null;
                if (this.trustStoreFile != null) {
                    truststore = KeyStore.getInstance(KeyStore.getDefaultType());
                    try {
                        in = new FileInputStream(this.trustStoreFile);
                        truststore.load(in, this.trustStorePassword != null ? this.trustStorePassword.toCharArray() : null);
                    } finally {
                        if (in != null) {
                            in.close();
                        }
                    }
                }
                sf = new SSLSocketFactory(SSLSocketFactory.TLS, null, null, truststore, null, null, SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
            }
            schemeRegistry.register(new Scheme(HTTPS_PROTOCOL, getPort(), sf));
        } catch (NoSuchAlgorithmException e) {
            throw new Error(NO_TLS_ERROR, e);
        } catch (KeyManagementException e) {
            throw new Error(BAD_KEY_ERROR, e);
        } catch (KeyStoreException e) {
            throw new Error(KEY_STORE_ERROR, e);
        } catch (FileNotFoundException e) {
            throw new Error(KEY_STORE_FILE_NOT_FOUND_ERROR, e);
        } catch (CertificateException e) {
            throw new Error(CERTIFICATE_ERROR, e);
        } catch (IOException e) {
            throw new Error(IO_ERROR, e);
        } catch (UnrecoverableKeyException e) {
            throw new Error(UNRECOVERABLE_KEY_ERROR, e);
        }
    }
    return schemeRegistry;
}
#end_block

#method_before
@Override
public <TYPE> TYPE followLink(TYPE object) {
    if (!isLink(object)) {
        throw new Error("Can't follow link because object don't have any");
    }
    try {
        String href = ((Identified) object).href();
        if (href == null) {
            throw new Error("Can't follow link because the 'href' attribute does't have a value");
        }
        URL url = new URL(getUrl());
        String prefix = url.getPath();
        if (!prefix.endsWith("/")) {
            prefix += "/";
        }
        if (!href.startsWith(prefix)) {
            throw new Error("The URL '" + href + "' isn't compatible with the base URL of the connection");
        }
        // Get service based on path
        String path = href.substring(prefix.length());
        Service service = systemService().service(path);
        // Obtain method which provides result object and invoke it:
        Method get = service.getClass().getMethod("get");
        Object getRequest = get.invoke(service);
        Method send = getRequest.getClass().getMethod("send");
        send.setAccessible(true);
        Object getResponse = send.invoke(getRequest);
        Method obtainObject = getResponse.getClass().getDeclaredMethods()[0];
        obtainObject.setAccessible(true);
        return (TYPE) obtainObject.invoke(getResponse);
    } catch (NoSuchMethodException ex) {
        throw new Error(ex);
    } catch (IllegalAccessException ex) {
        throw new Error(ex);
    } catch (InvocationTargetException ex) {
        throw new Error(ex);
    } catch (MalformedURLException ex) {
        throw new Error(ex);
    }
}
#method_after
@Override
public <TYPE> TYPE followLink(TYPE object) {
    if (!isLink(object)) {
        throw new Error("Can't follow link because object don't have any");
    }
    String href = ((Identified) object).href();
    if (href == null) {
        throw new Error("Can't follow link because the 'href' attribute does't have a value");
    }
    try {
        URL url = new URL(getUrl());
        String prefix = url.getPath();
        if (!prefix.endsWith("/")) {
            prefix += "/";
        }
        if (!href.startsWith(prefix)) {
            throw new Error("The URL '" + href + "' isn't compatible with the base URL of the connection");
        }
        // Get service based on path
        String path = href.substring(prefix.length());
        Service service = systemService().service(path);
        // Obtain method which provides result object and invoke it:
        Method get = service.getClass().getMethod("get");
        Object getRequest = get.invoke(service);
        Method send = getRequest.getClass().getMethod("send");
        send.setAccessible(true);
        Object getResponse = send.invoke(getRequest);
        Method obtainObject = getResponse.getClass().getDeclaredMethods()[0];
        obtainObject.setAccessible(true);
        return (TYPE) obtainObject.invoke(getResponse);
    } catch (NoSuchMethodException ex) {
        throw new Error(String.format("Unexpected error while following link \"%1$s\"", href), ex);
    } catch (IllegalAccessException ex) {
        throw new Error(String.format("Unexpected error while following link \"%1$s\"", href), ex);
    } catch (InvocationTargetException ex) {
        throw new Error(String.format("Unexpected error while following link \"%1$s\"", href), ex);
    } catch (MalformedURLException ex) {
        throw new Error(String.format("Error while creating URL \"%1$s\"", getUrl()), ex);
    }
}
#end_block

#method_before
@Override
protected HttpClient createHttpClient() throws Error {
    int port = getPort();
    Lookup<AuthSchemeProvider> authSchemeProvider = null;
    CredentialsProvider credsProvider = new BasicCredentialsProvider();
    AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);
    if (user != null && user.length() > 0) {
        credsProvider.setCredentials(authScope, new UsernamePasswordCredentials(user, password));
    } else if (kerberos) {
        authSchemeProvider = RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory(true)).build();
        credsProvider.setCredentials(authScope, new Credentials() {

            @Override
            public Principal getUserPrincipal() {
                return null;
            }

            @Override
            public String getPassword() {
                return null;
            }
        });
    }
    RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.IGNORE_COOKIES).setConnectTimeout(timeout).build();
    HttpClientBuilder clientBuilder = HttpClientBuilder.create().setConnectionManager(new BasicHttpClientConnectionManager(createConnectionSocketFactoryRegistry())).setDefaultRequestConfig(globalConfig).setDefaultCredentialsProvider(credsProvider).setDefaultAuthSchemeRegistry(authSchemeProvider);
    if (!compress) {
        clientBuilder.disableContentCompression();
    }
    return new HttpClient45(clientBuilder.build());
}
#method_after
@Override
protected HttpClient createHttpClient() {
    int port = getPort();
    Lookup<AuthSchemeProvider> authSchemeProvider = null;
    CredentialsProvider credsProvider = new BasicCredentialsProvider();
    AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);
    if (user != null && user.length() > 0) {
        credsProvider.setCredentials(authScope, new UsernamePasswordCredentials(user, password));
    } else if (kerberos) {
        authSchemeProvider = RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory(true)).build();
        credsProvider.setCredentials(authScope, new Credentials() {

            @Override
            public Principal getUserPrincipal() {
                return null;
            }

            @Override
            public String getPassword() {
                return null;
            }
        });
    }
    RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.IGNORE_COOKIES).setConnectTimeout(timeout).build();
    HttpClientBuilder clientBuilder = HttpClientBuilder.create().setConnectionManager(new BasicHttpClientConnectionManager(createConnectionSocketFactoryRegistry())).setDefaultRequestConfig(globalConfig).setDefaultCredentialsProvider(credsProvider).setDefaultAuthSchemeRegistry(authSchemeProvider);
    if (!compress) {
        clientBuilder.disableContentCompression();
    }
    return new HttpClient45(clientBuilder.build());
}
#end_block

#method_before
private Registry createConnectionSocketFactoryRegistry() throws Error {
    String protocol = getProtocol();
    Registry registry = null;
    // Create SSL/TLS or plain connection:
    if (HTTP_PROTOCOL.equals(protocol)) {
        ConnectionSocketFactory plainsf = PlainConnectionSocketFactory.getSocketFactory();
        registry = RegistryBuilder.<ConnectionSocketFactory>create().register(HTTP_PROTOCOL, plainsf).build();
    } else if (HTTPS_PROTOCOL.equals(protocol)) {
        try {
            LayeredConnectionSocketFactory sslsf = null;
            if (this.insecure) {
                SSLContext sslcontext = SSLContext.getInstance("TLS");
                sslcontext.init(null, new TrustManager[] { noCaTrustManager }, null);
                sslsf = new SSLConnectionSocketFactory(sslcontext, NoopHostnameVerifier.INSTANCE);
            } else {
                SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(new File(trustStoreFile), this.trustStorePassword != null ? this.trustStorePassword.toCharArray() : null).build();
                sslsf = new SSLConnectionSocketFactory(sslContext, new DefaultHostnameVerifier());
            }
            registry = RegistryBuilder.<ConnectionSocketFactory>create().register(HTTPS_PROTOCOL, sslsf).build();
        } catch (NoSuchAlgorithmException e) {
            throw new Error(NO_TLS_ERROR, e);
        } catch (KeyManagementException e) {
            throw new Error(BAD_KEY_ERROR, e);
        } catch (KeyStoreException e) {
            throw new Error(KEY_STORE_ERROR, e);
        } catch (FileNotFoundException e) {
            throw new Error(KEY_STORE_FILE_NOT_FOUND_ERROR, e);
        } catch (CertificateException e) {
            throw new Error(CERTIFICATE_ERROR, e);
        } catch (IOException e) {
            throw new Error(IO_ERROR, e);
        }
    } else {
        throw new Error(BAD_PROTOCOL_ERROR + protocol);
    }
    return registry;
}
#method_after
private Registry createConnectionSocketFactoryRegistry() {
    String protocol = getProtocol();
    Registry registry = null;
    // Create SSL/TLS or plain connection:
    if (HTTP_PROTOCOL.equals(protocol)) {
        ConnectionSocketFactory plainsf = PlainConnectionSocketFactory.getSocketFactory();
        registry = RegistryBuilder.<ConnectionSocketFactory>create().register(HTTP_PROTOCOL, plainsf).build();
    } else if (HTTPS_PROTOCOL.equals(protocol)) {
        try {
            LayeredConnectionSocketFactory sslsf = null;
            if (this.insecure) {
                SSLContext sslcontext = SSLContext.getInstance("TLS");
                sslcontext.init(null, new TrustManager[] { noCaTrustManager }, null);
                sslsf = new SSLConnectionSocketFactory(sslcontext, NoopHostnameVerifier.INSTANCE);
            } else {
                SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(new File(trustStoreFile), this.trustStorePassword != null ? this.trustStorePassword.toCharArray() : null).build();
                sslsf = new SSLConnectionSocketFactory(sslContext, new DefaultHostnameVerifier());
            }
            registry = RegistryBuilder.<ConnectionSocketFactory>create().register(HTTPS_PROTOCOL, sslsf).build();
        } catch (NoSuchAlgorithmException e) {
            throw new Error(NO_TLS_ERROR, e);
        } catch (KeyManagementException e) {
            throw new Error(BAD_KEY_ERROR, e);
        } catch (KeyStoreException e) {
            throw new Error(KEY_STORE_ERROR, e);
        } catch (FileNotFoundException e) {
            throw new Error(KEY_STORE_FILE_NOT_FOUND_ERROR, e);
        } catch (CertificateException e) {
            throw new Error(CERTIFICATE_ERROR, e);
        } catch (IOException e) {
            throw new Error(IO_ERROR, e);
        }
    } else {
        throw new Error(BAD_PROTOCOL_ERROR + protocol);
    }
    return registry;
}
#end_block

#method_before
public void disableAutoSetHostname() {
    canAutoSetHostname = disableOnHostnameChanged ? canAutoSetHostname : false;
}
#method_after
public void disableAutoSetHostname() {
    if (!disableOnHostnameChanged) {
        canAutoSetHostname = false;
    }
}
#end_block

#method_before
private Integer getMaxBandwidth(MigrationPolicy migrationPolicy) {
    switch(getCluster().getMigrationBandwidthLimitType()) {
        case AUTO:
            return Optional.ofNullable(getAutoMaxBandwidth()).map(bandwidth -> bandwidth / migrationPolicy.getMaxMigrations()).orElse(null);
        case VDSM_CONFIG:
            return null;
        case CUSTOM:
            return getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations();
        default:
            throw new IllegalStateException("Unexpected enum item.");
    }
}
#method_after
private Integer getMaxBandwidth(MigrationPolicy migrationPolicy) {
    switch(getCluster().getMigrationBandwidthLimitType()) {
        case AUTO:
            return Optional.ofNullable(getAutoMaxBandwidth()).map(bandwidth -> bandwidth / migrationPolicy.getMaxMigrations()).orElse(null);
        case VDSM_CONFIG:
            return null;
        case CUSTOM:
            return getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations();
        default:
            throw new IllegalStateException("Unexpected enum item: " + getCluster().getMigrationBandwidthLimitType());
    }
}
#end_block

#method_before
private Integer getAutoMaxBandwidth() {
    if (getSourceClusterId().equals(getDestinationClusterId())) {
        return getAutoMaxBandwidthForCluster(getSourceClusterId());
    }
    return minIfExists(getAutoMaxBandwidthForCluster(getSourceClusterId()), getAutoMaxBandwidthForCluster(getDestinationClusterId()));
}
#method_after
private Integer getAutoMaxBandwidth() {
    final Guid sourceClusterId = getVm().getClusterId();
    final Guid destinationClusterId = getClusterId();
    final Guid sourceHostId = getVm().getRunOnVds();
    final Guid destinationHostId = getDestinationVdsId();
    return ObjectUtils.minIfExists(getAutoMaxBandwidth(sourceClusterId, sourceHostId), getAutoMaxBandwidth(destinationClusterId, destinationHostId));
}
#end_block

#method_before
private Integer getAutoMaxBandwidth() {
    if (getSourceClusterId().equals(getDestinationClusterId())) {
        return getAutoMaxBandwidthForCluster(getSourceClusterId());
    }
    return minIfExists(getAutoMaxBandwidthForCluster(getSourceClusterId()), getAutoMaxBandwidthForCluster(getDestinationClusterId()));
}
#method_after
private Integer getAutoMaxBandwidth(Guid clusterId, Guid hostId) {
    Integer qosBandwidth = getQosBandwidth(clusterId);
    if (qosBandwidth != null) {
        return qosBandwidth;
    }
    return getLinkSpeedBandwidth(hostId);
}
#end_block

#method_before
private Integer getQosBandwidth(Guid clusterId) {
    final HostNetworkQos migrationalHostNetworkQos = getDbFacade().getHostNetworkQosDao().getHostNetworkQosOfMigrationNetworkByClusterId(clusterId);
    if (migrationalHostNetworkQos == null) {
        return null;
    }
    if (migrationalHostNetworkQos.getOutAverageRealtime() != null) {
        return migrationalHostNetworkQos.getOutAverageRealtime();
    }
    return migrationalHostNetworkQos.getOutAverageUpperlimit();
}
#method_after
private Integer getQosBandwidth(Guid clusterId) {
    final HostNetworkQos migrationHostNetworkQos = getDbFacade().getHostNetworkQosDao().getHostNetworkQosOfMigrationNetworkByClusterId(clusterId);
    if (migrationHostNetworkQos == null) {
        return null;
    }
    if (migrationHostNetworkQos.getOutAverageRealtime() != null) {
        return migrationHostNetworkQos.getOutAverageRealtime();
    }
    return migrationHostNetworkQos.getOutAverageUpperlimit();
}
#end_block

#method_before
private Integer getLinkSpeedBandwidth(Guid clusterId) {
    final List<VdsNetworkInterface> migrationalClusterNics = getDbFacade().getInterfaceDao().getAllMigrationNetworkInterfacesInCluster(clusterId);
    // speed 0.
    return migrationalClusterNics.stream().map(VdsNetworkInterface::getSpeed).reduce(MigrateVmCommand::minIfExists).map(speed -> speed == 0 ? null : speed).orElse(null);
}
#method_after
private Integer getLinkSpeedBandwidth(Guid hostId) {
    return getInterfaceDao().getActiveMigrationNetworkInterfaceForHost(hostId).map(NetworkInterface::getSpeed).map(speed -> speed > 0 ? speed : null).orElse(null);
}
#end_block

#method_before
protected void getDowntime() {
    if (FeatureSupported.migrateDowntime(getVm().getCompatibilityVersion())) {
        try {
            VDSReturnValue retVal = runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getDestinationVdsId(), getVmId()));
            if (retVal != null) {
                actualDowntime = (Integer) retVal.getReturnValue();
            }
        } catch (EngineException e) {
            migrationErrorCode = e.getErrorCode();
        }
    }
}
#method_after
protected void getDowntime() {
    try {
        VDSReturnValue retVal = runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getDestinationVdsId(), getVmId()));
        if (retVal != null) {
            actualDowntime = (Integer) retVal.getReturnValue();
        }
    } catch (EngineException e) {
        migrationErrorCode = e.getErrorCode();
    }
}
#end_block

#method_before
private Boolean getAutoConverge() {
    if (FeatureSupported.autoConvergence(getVm().getCompatibilityVersion())) {
        if (getVm().getAutoConverge() != null) {
            return getVm().getAutoConverge();
        }
        if (getCluster().getAutoConverge() != null) {
            return getCluster().getAutoConverge();
        }
        return Config.getValue(ConfigValues.DefaultAutoConvergence);
    }
    return null;
}
#method_after
private Boolean getAutoConverge() {
    if (getVm().getAutoConverge() != null) {
        return getVm().getAutoConverge();
    }
    if (getCluster().getAutoConverge() != null) {
        return getCluster().getAutoConverge();
    }
    return Config.getValue(ConfigValues.DefaultAutoConvergence);
}
#end_block

#method_before
private Boolean getMigrateCompressed() {
    if (FeatureSupported.migrationCompression(getVm().getCompatibilityVersion())) {
        if (getVm().getMigrateCompressed() != null) {
            return getVm().getMigrateCompressed();
        }
        if (getCluster().getMigrateCompressed() != null) {
            return getCluster().getMigrateCompressed();
        }
        return Config.getValue(ConfigValues.DefaultMigrationCompression);
    }
    return null;
}
#method_after
private Boolean getMigrateCompressed() {
    if (getVm().getMigrateCompressed() != null) {
        return getVm().getMigrateCompressed();
    }
    if (getCluster().getMigrateCompressed() != null) {
        return getCluster().getMigrateCompressed();
    }
    return Config.getValue(ConfigValues.DefaultMigrationCompression);
}
#end_block

#method_before
private String getMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        // assure migration network is active on source host
        if (getMigrationNetworkAddress(getVds().getId(), migrationNetwork.getName()) == null) {
            return null;
        }
        // find migration IP address on destination host
        return getMigrationNetworkAddress(getDestinationVds().getId(), migrationNetwork.getName());
    }
    return null;
}
#method_after
private String getMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return migrationDestinationIpv6Address;
        }
    }
    return null;
}
#end_block

#method_before
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return nic.getAddress();
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName, Function<VdsNetworkInterface, String> ipAddressGetter) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return ipAddressGetter.apply(nic);
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#method_after
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVm() != null && !Objects.equals(getParameters().getTargetClusterId(), getVm().getClusterId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetClusterId()));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getTargetClusterId() != null && getVm() != null && !Objects.equals(getParameters().getTargetClusterId(), getVm().getClusterId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetClusterId()));
    }
    return permissionList;
}
#end_block

#method_before
private Object toPrintableResult(JsonNode result) {
    Class<Map<String, String>> clazz = (Class) Map.class;
    Map<String, String> resultMap = null;
    try {
        resultMap = MAPPER.convertValue(result, clazz);
    } catch (IllegalArgumentException e) {
        // types so it is safe to return them as is
        return result;
    }
    if (resultMap.containsKey("password")) {
        resultMap.put("password", "*****");
    }
    return resultMap;
}
#method_after
private Object toPrintableResult(JsonNode result) {
    if (result.isArray()) {
        // currently passwords do not appear in arrays
        return result;
    }
    Class<Map<String, String>> clazz = (Class) Map.class;
    Map<String, String> resultMap = MAPPER.convertValue(result, clazz);
    if (resultMap.containsKey("password")) {
        resultMap.put("password", "*****");
    }
    return resultMap;
}
#end_block

#method_before
public String getVmName() {
    return VmName;
}
#method_after
public String getVmName() {
    return vmName;
}
#end_block

#method_before
public void setVmName(String VmName) {
    this.VmName = VmName;
}
#method_after
public void setVmName(String vmName) {
    this.vmName = vmName;
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    // reuse filter functionality with soft constraint
    List<VDS> acceptableHostsList = VmAffinityFilterPolicyUnit.getAcceptableHosts(false, hosts, vm, new PerHostMessages());
    Map<Guid, VDS> acceptableHostsMap = new HashMap<Guid, VDS>();
    if (acceptableHostsList != null) {
        for (VDS acceptableHost : acceptableHostsList) {
            acceptableHostsMap.put(acceptableHost.getId(), acceptableHost);
        }
    }
    List<Pair<Guid, Integer>> retList = new ArrayList<Pair<Guid, Integer>>();
    int score;
    for (VDS host : hosts) {
        score = DEFAULT_SCORE;
        if (!acceptableHostsMap.containsKey(host.getId())) {
            score = MaxSchedulerWeight;
        }
        retList.add(new Pair<Guid, Integer>(host.getId(), score));
    }
    return retList;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    // reuse filter functionality with soft constraint
    List<VDS> acceptableHostsList = VmAffinityFilterPolicyUnit.getAcceptableHosts(false, hosts, vm, new PerHostMessages(), getPendingResourceManager());
    Map<Guid, VDS> acceptableHostsMap = new HashMap<>();
    if (acceptableHostsList != null) {
        for (VDS acceptableHost : acceptableHostsList) {
            acceptableHostsMap.put(acceptableHost.getId(), acceptableHost);
        }
    }
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    int score;
    for (VDS host : hosts) {
        score = DEFAULT_SCORE;
        if (!acceptableHostsMap.containsKey(host.getId())) {
            score = MaxSchedulerWeight;
        }
        retList.add(new Pair<>(host.getId(), score));
    }
    return retList;
}
#end_block

#method_before
private void addUpdatedVm() {
    VdcActionType action = getParameters().getVmPoolId() == null ? VdcActionType.AddVm : VdcActionType.AddVmAndAttachToPool;
    runInternalAction(action, buildAddVmParameters(action), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
}
#method_after
private void addUpdatedVm() {
    runInternalAction(VdcActionType.AddVm, buildAddVmParameters(), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
}
#end_block

#method_before
private AddVmParameters buildAddVmParameters(VdcActionType action) {
    AddVmParameters addVmParams;
    if (action == VdcActionType.AddVmAndAttachToPool) {
        addVmParams = new AddVmAndAttachToPoolParameters(getParameters().getVmStaticData(), getParameters().getVmPoolId(), getParameters().getVmStaticData().getName(), new HashMap<>());
    } else {
        addVmParams = new AddVmParameters(getParameters().getVmStaticData());
    }
    addVmParams.setDiskInfoDestinationMap(new HashMap<>());
    addVmParams.setConsoleEnabled(deviceExists(VmDeviceGeneralType.CONSOLE));
    addVmParams.setBalloonEnabled(deviceExists(VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON));
    addVmParams.setSoundDeviceEnabled(deviceExists(VmDeviceGeneralType.SOUND));
    addVmParams.setVirtioScsiEnabled(deviceExists(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI));
    List<VmWatchdog> watchdogs = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVmTemplateId())).getReturnValue();
    if (!watchdogs.isEmpty()) {
        addVmParams.setWatchdog(watchdogs.get(0));
    }
    loadVmPayload(addVmParams);
    // then there is no session, so using the current user.
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        addVmParams.setParametersCurrentUser(getCurrentUser());
    } else {
        addVmParams.setSessionId(getParameters().getSessionId());
    }
    addVmParams.setDiskOperatorAuthzPrincipalDbId(getParameters().getPreviousDiskOperatorAuthzPrincipalDbId());
    // reset vm to not initialized
    addVmParams.getVmStaticData().setInitialized(false);
    return addVmParams;
}
#method_after
private AddVmParameters buildAddVmParameters() {
    AddVmParameters addVmParams = new AddVmParameters(getParameters().getVmStaticData());
    addVmParams.setPoolId(getParameters().getVmPoolId());
    addVmParams.setDiskInfoDestinationMap(new HashMap<>());
    addVmParams.setConsoleEnabled(deviceExists(VmDeviceGeneralType.CONSOLE));
    addVmParams.setBalloonEnabled(deviceExists(VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON));
    addVmParams.setSoundDeviceEnabled(deviceExists(VmDeviceGeneralType.SOUND));
    addVmParams.setVirtioScsiEnabled(deviceExists(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI));
    List<VmWatchdog> watchdogs = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVmTemplateId())).getReturnValue();
    if (!watchdogs.isEmpty()) {
        addVmParams.setWatchdog(watchdogs.get(0));
    }
    loadVmPayload(addVmParams);
    // then there is no session, so using the current user.
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        addVmParams.setParametersCurrentUser(getCurrentUser());
    } else {
        addVmParams.setSessionId(getParameters().getSessionId());
    }
    addVmParams.setDiskOperatorAuthzPrincipalDbId(getParameters().getPreviousDiskOperatorAuthzPrincipalDbId());
    // reset vm to not initialized
    addVmParams.getVmStaticData().setInitialized(false);
    return addVmParams;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmPoolId() != null) {
        getVmPoolDao().removeVmFromVmPool(getVmId());
        updateVmPoolPrestartedVms();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmPoolId() != null) {
        getVmPoolDao().removeVmFromVmPool(getVmId());
        if (getParameters().isUpdatePrestartedVms()) {
            getVmPoolDao().boundVmPoolPrestartedVms(getVmPoolId());
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
private RunVmOnceParams createRunVmOnceParams(Vm vm) {
    RunVmOnceParams params = map(vm, map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new Vm()), new RunVmOnceParams(guid)));
    if (vm.isSetPlacementPolicy()) {
        Set<Guid> hostsGuidsSet = parent.validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
        if (hostsGuidsSet.size() > 0) {
            // take the arbitrary first host for run destination
            params.setDestinationVdsId(hostsGuidsSet.iterator().next());
        }
    }
    if (vm.isSetInitialization()) {
        if (vm.getInitialization().isSetCloudInit()) {
            params.setInitializationType(InitializationType.CloudInit);
        }
        params.setVmInit(InitializationMapper.map(vm.getInitialization(), new VmInit()));
    }
    return params;
}
#method_after
private RunVmOnceParams createRunVmOnceParams(Vm vm) {
    VM entity = getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true);
    RunVmOnceParams params = map(vm, map(map(entity, new Vm()), new RunVmOnceParams(guid)));
    if (vm.isSetPlacementPolicy()) {
        Set<Guid> hostsGuidsSet = parent.validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
        if (hostsGuidsSet.size() > 0) {
            // take the arbitrary first host for run destination
            params.setDestinationVdsId(hostsGuidsSet.iterator().next());
        }
    }
    if (vm.isSetInitialization()) {
        if (vm.getInitialization().isSetCloudInit()) {
            params.setInitializationType(InitializationType.CloudInit);
        }
        params.setVmInit(InitializationMapper.map(vm.getInitialization(), entity.getVmInit()));
    }
    return params;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid id) {
    return getCustomMapSqlParameterSource().addValue("filter_id", id);
}
#method_after
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid id) {
    return getCustomMapSqlParameterSource().addValue(FILTER_ID, id);
}
#end_block

#method_before
@Override
public NetworkFilter mapRow(ResultSet rs, int rowNum) throws SQLException {
    NetworkFilter entity = new NetworkFilter();
    entity.setId(getGuid(rs, "filter_id"));
    entity.setName(rs.getString("filter_name"));
    Version version = new Version(rs.getString("version"));
    entity.setVersion(version);
    return entity;
}
#method_after
@Override
public NetworkFilter mapRow(ResultSet rs, int rowNum) throws SQLException {
    NetworkFilter entity = new NetworkFilter();
    entity.setId(getGuid(rs, FILTER_ID));
    entity.setName(rs.getString(FILTER_NAME));
    final VersionRowMapper versionRowMapper = new VersionRowMapper(FILTER_VERSION);
    Version version = versionRowMapper.mapRow(rs, rowNum);
    entity.setVersion(version);
    return entity;
}
#end_block

#method_before
private NetworkFilter expectedNetworkFilter() {
    NetworkFilter networkFilter = new NetworkFilter();
    networkFilter.setName(FixturesTool.NETWORK_FILTER_NAME);
    networkFilter.setVersion(new Version("4.0"));
    networkFilter.setId(FixturesTool.NETWORK_FILTER);
    return networkFilter;
}
#method_after
private NetworkFilter expectedNetworkFilter() {
    NetworkFilter networkFilter = new NetworkFilter();
    networkFilter.setName(FixturesTool.NETWORK_FILTER_NAME);
    networkFilter.setVersion(FixturesTool.NETWORK_FILTER_VERSION);
    networkFilter.setId(FixturesTool.NETWORK_FILTER);
    return networkFilter;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NetworkFilter that = (NetworkFilter) o;
    return Objects.equals(name, that.name) && Objects.equals(version, that.version) && Objects.equals(id, that.id);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    NetworkFilter that = (NetworkFilter) o;
    return Objects.equals(name, that.name) && Objects.equals(version, that.version) && Objects.equals(id, that.id);
}
#end_block

#method_before
private List<Guid> findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, List<Guid>> hostCount = new HashMap<>();
    // Prepare affinity group related host counts
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        // Ignore stopped VMs
        if (host == null) {
            continue;
        }
        if (hostCount.containsKey(host)) {
            hostCount.get(host).add(vm);
        } else {
            hostCount.put(host, new ArrayList<>());
            hostCount.get(host).add(vm);
        }
    }
    // Select the host with the least amount of VMs
    Guid host = chooseCandidateHostForMigration(hostCount);
    if (host == null) {
        return Collections.EMPTY_LIST;
    }
    return hostCount.get(host);
}
#method_after
private List<Guid> findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, List<Guid>> hostCount = new HashMap<>();
    // Prepare affinity group related host counts
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        // Ignore stopped VMs
        if (host == null) {
            continue;
        }
        if (hostCount.containsKey(host)) {
            hostCount.get(host).add(vm);
        } else {
            hostCount.put(host, new ArrayList<>());
            hostCount.get(host).add(vm);
        }
    }
    // Select the host with the least amount of VMs
    Guid host = chooseCandidateHostForMigration(hostCount);
    if (host == null) {
        return Collections.emptyList();
    }
    return hostCount.get(host);
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    if (anyFailed) {
        setCommandEndStatus(command, anyFailed, status, childCmdIds);
        return;
    } else {
        RemoveVmPoolCommand<? extends VmPoolParametersBase> removeVmPoolCommand = (RemoveVmPoolCommand) command;
        VmPool pool = DbFacade.getInstance().getVmPoolDao().get(removeVmPoolCommand.getVmPoolId());
        if (pool == null || pool.getRunningVmsCount() == 0) {
            setCommandEndStatus(command, false, status, childCmdIds);
            return;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    if (anyFailed) {
        setCommandEndStatus(command, true, status, childCmdIds);
    } else {
        RemoveVmPoolCommand<? extends VmPoolParametersBase> removeVmPoolCommand = (RemoveVmPoolCommand<? extends VmPoolParametersBase>) command;
        VmPool pool = DbFacade.getInstance().getVmPoolDao().get(removeVmPoolCommand.getVmPoolId());
        if (pool == null || pool.getRunningVmsCount() == 0) {
            setCommandEndStatus(command, false, status, childCmdIds);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            int connectionId = client.getConnectionId();
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed() && client.getConnectionId() == connectionId) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
            if (!client.isClosed() && client.getConnectionId() != connectionId) {
                waitUntilCheck(client -> !client.isClosed(), "Waiting on opening connection for {}", "Done reconnecting for {}!");
            }
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            int connectionId = client.getConnectionId();
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed() && client.getConnectionId() == connectionId) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public PrepareImageReturnForXmlRpc prepareImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturnForXmlRpc(response);
}
#method_after
@Override
public PrepareImageReturnForXmlRpc prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturnForXmlRpc(response);
}
#end_block

#method_before
public static void populateCpuUtilizationHosts(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    HostDwhDAO dao = new HostDwhDAO(dwhDataSource);
    List<TrendResources> resourceUsage = dao.getCpuUtilizationHosts();
    for (TrendResources usage : resourceUsage) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        entity.setUsed(usage.getUsed() * usage.getTotal() / 100);
        entity.setTotal(usage.getTotal());
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addResource(entity);
    }
}
#method_after
public static void populateCpuUtilizationHosts(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    HostDwhDao dao = new HostDwhDao(dwhDataSource);
    List<TrendResources> resourceUsage = dao.getCpuUtilizationHosts();
    for (TrendResources usage : resourceUsage) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        entity.setUsed(usage.getUsed() * usage.getTotal() / 100);
        entity.setTotal(usage.getTotal());
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addResource(entity);
    }
}
#end_block

#method_before
public static void populateCpuUtilizationVms(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDAO dao = new VmDwhDAO(dwhDataSource);
    List<TrendResources> usageList = dao.getCpuUtilizationVms();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        entity.setUsed(usage.getUsed());
        entity.setTotal(usage.getTotal());
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addVm(entity);
    }
}
#method_after
public static void populateCpuUtilizationVms(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDao dao = new VmDwhDao(dwhDataSource);
    List<TrendResources> usageList = dao.getCpuUtilizationVms();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        entity.setUsed(usage.getUsed());
        entity.setTotal(usage.getTotal());
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addVm(entity);
    }
}
#end_block

#method_before
public static void populateMemoryUtilizationHosts(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    HostDwhDAO dao = new HostDwhDAO(dwhDataSource);
    List<TrendResources> usageList = dao.getMemoryUtilizationHosts();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Transform to GB
        entity.setUsed(usage.getUsed() / 1024);
        // Transform to GB
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addResource(entity);
    }
}
#method_after
public static void populateMemoryUtilizationHosts(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    HostDwhDao dao = new HostDwhDao(dwhDataSource);
    List<TrendResources> usageList = dao.getMemoryUtilizationHosts();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Transform to GB
        entity.setUsed(usage.getUsed() / 1024);
        // Transform to GB
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addResource(entity);
    }
}
#end_block

#method_before
public static void populateMemoryUtilizationVms(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDAO dao = new VmDwhDAO(dwhDataSource);
    List<TrendResources> usageList = dao.getMemoryUtilizationVms();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Transform to GB
        entity.setUsed(usage.getUsed() / 1024);
        // Transform to GB
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addVm(entity);
    }
}
#method_after
public static void populateMemoryUtilizationVms(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDao dao = new VmDwhDao(dwhDataSource);
    List<TrendResources> usageList = dao.getMemoryUtilizationVms();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Transform to GB
        entity.setUsed(usage.getUsed() / 1024);
        // Transform to GB
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addVm(entity);
    }
}
#end_block

#method_before
public static void populateStorageUtilizationDomains(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDAO dao = new StorageDomainDwhDAO(dwhDataSource);
    List<TrendResources> usageList = dao.getStorageDomainUtilization();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Dividing by 1024 to report TB instead of GB
        entity.setUsed(usage.getUsed() / 1024);
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addResource(entity);
    }
}
#method_after
public static void populateStorageUtilizationDomains(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDao dao = new StorageDomainDwhDao(dwhDataSource);
    List<TrendResources> usageList = dao.getStorageDomainUtilization();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Dividing by 1024 to report TB instead of GB
        entity.setUsed(usage.getUsed() / 1024);
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed(), usage.getPreviousUsed()));
        utilization.addResource(entity);
    }
}
#end_block

#method_before
public static void populateStorageUtilizationVms(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDAO dao = new StorageDomainDwhDAO(dwhDataSource);
    List<TrendResources> usageList = dao.getStorageUtilizationVms();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Transform GB to TB
        entity.setUsed(usage.getUsed() / 1024);
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed() / usage.getTotal() * 100, usage.getPreviousUsed()));
        utilization.addVm(entity);
    }
}
#method_after
public static void populateStorageUtilizationVms(Utilization utilization, DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDao dao = new StorageDomainDwhDao(dwhDataSource);
    List<TrendResources> usageList = dao.getStorageUtilizationVms();
    for (TrendResources usage : usageList) {
        UtilizedEntity entity = new UtilizedEntity();
        entity.setName(usage.getName());
        // Transform GB to TB
        entity.setUsed(usage.getUsed() / 1024);
        entity.setTotal(usage.getTotal() / 1024);
        entity.setTrend(calculateTrend(usage.getUsed() / usage.getTotal() * 100, usage.getPreviousUsed()));
        utilization.addVm(entity);
    }
}
#end_block

#method_before
private static void getVirtualCpuMemCount(GlobalUtilizationResourceSummary cpuSummary, GlobalUtilizationResourceSummary memSummary, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDAO dao = new VmDwhDAO(dwhDataSource);
    ResourcesTotal resourcesTotal = dao.getVirtualCpuMemCount();
    cpuSummary.setVirtualTotal(resourcesTotal.getCpuTotal());
    cpuSummary.setVirtualUsed(resourcesTotal.getCpuUsed());
    memSummary.setVirtualTotal(resourcesTotal.getMemTotal());
    memSummary.setVirtualUsed(resourcesTotal.getMemUsed());
}
#method_after
private static void getVirtualCpuMemCount(GlobalUtilizationResourceSummary cpuSummary, GlobalUtilizationResourceSummary memSummary, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDao dao = new VmDwhDao(dwhDataSource);
    ResourcesTotal resourcesTotal = dao.getVirtualCpuMemCount();
    cpuSummary.setVirtualTotal(resourcesTotal.getCpuTotal());
    cpuSummary.setVirtualUsed(resourcesTotal.getCpuUsed());
    memSummary.setVirtualTotal(resourcesTotal.getMemTotal());
    memSummary.setVirtualUsed(resourcesTotal.getMemUsed());
}
#end_block

#method_before
private static void getTotalCpuMemCount(GlobalUtilizationResourceSummary cpuSummary, GlobalUtilizationResourceSummary memSummary, DataSource dwhDataSource) throws DashboardDataException {
    HostDwhDAO dao = new HostDwhDAO(dwhDataSource);
    ResourcesTotal total = dao.getTotalCpuMemCount();
    cpuSummary.setPhysicalTotal(total.getCpuTotal());
    // Transform MB to GB.
    memSummary.setPhysicalTotal(total.getMemTotal() / 1024);
}
#method_after
private static void getTotalCpuMemCount(GlobalUtilizationResourceSummary cpuSummary, GlobalUtilizationResourceSummary memSummary, DataSource dwhDataSource) throws DashboardDataException {
    HostDwhDao dao = new HostDwhDao(dwhDataSource);
    ResourcesTotal total = dao.getTotalCpuMemCount();
    cpuSummary.setPhysicalTotal(total.getCpuTotal());
    // Transform MB to GB.
    memSummary.setPhysicalTotal(total.getMemTotal() / 1024);
}
#end_block

#method_before
private static void getHourlyCpuMemUsage(GlobalUtilizationResourceSummary cpuSummary, GlobalUtilizationResourceSummary memSummary, DataSource dataSource) throws DashboardDataException {
    List<HistoryNode> cpuHistory = new ArrayList<>();
    List<HistoryNode> memHistory = new ArrayList<>();
    HostDwhDAO dao = new HostDwhDAO(dataSource);
    List<ResourceUsage> history = dao.getHourlyCpuMemUsage();
    for (ResourceUsage item : history) {
        cpuHistory.add(new HistoryNode(item.getEpoch(), item.getCpuValue()));
        memHistory.add(new HistoryNode(item.getEpoch(), item.getMemValue() * memSummary.getTotal() / 100));
    }
    ResourceUsage last5minUsage = dao.getLast5MinCpuMemUsage();
    cpuSummary.setUsed(last5minUsage.getCpuValue());
    memSummary.setUsed(last5minUsage.getMemValue() * memSummary.getTotal() / 100);
    cpuSummary.setHistory(cpuHistory);
    memSummary.setHistory(memHistory);
}
#method_after
private static void getHourlyCpuMemUsage(GlobalUtilizationResourceSummary cpuSummary, GlobalUtilizationResourceSummary memSummary, DataSource dataSource) throws DashboardDataException {
    List<HistoryNode> cpuHistory = new ArrayList<>();
    List<HistoryNode> memHistory = new ArrayList<>();
    HostDwhDao dao = new HostDwhDao(dataSource);
    List<ResourceUsage> history = dao.getHourlyCpuMemUsage();
    for (ResourceUsage item : history) {
        cpuHistory.add(new HistoryNode(item.getEpoch(), item.getCpuValue()));
        memHistory.add(new HistoryNode(item.getEpoch(), item.getMemValue() * memSummary.getTotal() / 100));
    }
    ResourceUsage last5minUsage = dao.getLast5MinCpuMemUsage();
    cpuSummary.setUsed(last5minUsage.getCpuValue());
    memSummary.setUsed(last5minUsage.getMemValue() * memSummary.getTotal() / 100);
    cpuSummary.setHistory(cpuHistory);
    memSummary.setHistory(memHistory);
}
#end_block

#method_before
private static List<HistoryNode> getHourlyStorageHistory(DataSource dwhDataSource) throws DashboardDataException {
    List<HistoryNode> history = new ArrayList<>();
    StorageDomainDwhDAO dao = new StorageDomainDwhDAO(dwhDataSource);
    List<ResourceUsage> usageList = dao.getHourlyStorageHistory();
    for (ResourceUsage usage : usageList) {
        // Transform GB to TB.
        history.add(new HistoryNode(usage.getEpoch(), usage.getStorageValue() / 1024));
    }
    return history;
}
#method_after
private static List<HistoryNode> getHourlyStorageHistory(DataSource dwhDataSource) throws DashboardDataException {
    List<HistoryNode> history = new ArrayList<>();
    StorageDomainDwhDao dao = new StorageDomainDwhDao(dwhDataSource);
    List<ResourceUsage> usageList = dao.getHourlyStorageHistory();
    for (ResourceUsage usage : usageList) {
        // Transform GB to TB.
        history.add(new HistoryNode(usage.getEpoch(), usage.getStorageValue() / 1024));
    }
    return history;
}
#end_block

#method_before
private static double getLast5MinutesStorageAverage(DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDAO dao = new StorageDomainDwhDAO(dwhDataSource);
    // Transform GB to TB.
    return dao.getLast5MinutesStorageAverage() / 1024;
}
#method_after
private static double getLast5MinutesStorageAverage(DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDao dao = new StorageDomainDwhDao(dwhDataSource);
    // Transform GB to TB.
    return dao.getLast5MinutesStorageAverage() / 1024;
}
#end_block

#method_before
private static Double getTotalStorageCount(DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDAO dao = new StorageDomainDwhDAO(dwhDataSource);
    // Transform GB to TB.
    return dao.getTotalStorageCount() / 1024;
}
#method_after
private static Double getTotalStorageCount(DataSource dwhDataSource) throws DashboardDataException {
    StorageDomainDwhDao dao = new StorageDomainDwhDao(dwhDataSource);
    // Transform GB to TB.
    return dao.getTotalStorageCount() / 1024;
}
#end_block

#method_before
private static void getVirtualStorageCount(GlobalUtilizationResourceSummary storageSummary, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDAO dao = new VmDwhDAO(dwhDataSource);
    VmStorage storageCount = dao.getVirtualStorageCount();
    storageSummary.setVirtualUsed(storageCount.getUsed());
    storageSummary.setVirtualTotal(storageCount.getTotal());
}
#method_after
private static void getVirtualStorageCount(GlobalUtilizationResourceSummary storageSummary, DataSource dwhDataSource) throws DashboardDataException {
    VmDwhDao dao = new VmDwhDao(dwhDataSource);
    VmStorage storageCount = dao.getVirtualStorageCount();
    storageSummary.setVirtualUsed(storageCount.getUsed());
    storageSummary.setVirtualTotal(storageCount.getTotal());
}
#end_block

#method_before
public static InventoryStatus getEventStatus(DataSource dataSource) throws DashboardDataException {
    InventoryStatus result = new InventoryStatus();
    EventDAO dao = new EventDAO(dataSource);
    Map<AuditLogSeverity, Integer> data = dao.getEventStatusCount();
    for (Map.Entry<AuditLogSeverity, Integer> entry : data.entrySet()) {
        switch(entry.getKey()) {
            case ALERT:
                result.setStatusCount(AuditLogSeverity.ALERT.name().toLowerCase(), entry.getValue());
                result.setTotalCount(result.getTotalCount() + entry.getValue());
                break;
            case ERROR:
                result.setStatusCount(AuditLogSeverity.ERROR.name().toLowerCase(), entry.getValue());
                result.setTotalCount(result.getTotalCount() + entry.getValue());
                break;
            case NORMAL:
                // Do nothing
                break;
            case WARNING:
                result.setStatusCount(AuditLogSeverity.WARNING.name().toLowerCase(), entry.getValue());
                result.setTotalCount(result.getTotalCount() + entry.getValue());
                break;
            default:
                // Do nothing
                break;
        }
    }
    return result;
}
#method_after
public static InventoryStatus getEventStatus(DataSource dataSource) throws DashboardDataException {
    InventoryStatus result = new InventoryStatus();
    EventDao dao = new EventDao(dataSource);
    Map<AuditLogSeverity, Integer> data = dao.getEventStatusCount();
    for (Map.Entry<AuditLogSeverity, Integer> entry : data.entrySet()) {
        switch(entry.getKey()) {
            case ALERT:
                result.setStatusCount(AuditLogSeverity.ALERT.name().toLowerCase(), entry.getValue());
                result.setTotalCount(result.getTotalCount() + entry.getValue());
                break;
            case ERROR:
                result.setStatusCount(AuditLogSeverity.ERROR.name().toLowerCase(), entry.getValue());
                result.setTotalCount(result.getTotalCount() + entry.getValue());
                break;
            case NORMAL:
                // Do nothing
                break;
            case WARNING:
                result.setStatusCount(AuditLogSeverity.WARNING.name().toLowerCase(), entry.getValue());
                result.setTotalCount(result.getTotalCount() + entry.getValue());
                break;
            default:
                // Do nothing
                break;
        }
    }
    return result;
}
#end_block

#method_before
public static void getCpuAndMemory(HeatMapData utilization, DataSource dataSource) throws DashboardDataException {
    ClusterDwhDAO dao = new ClusterDwhDAO(dataSource);
    List<ClusterResourceAverage> averages = dao.getClusterCpuAndMemoryAverage();
    List<HeatMapBlock> cpu = new ArrayList<>();
    List<HeatMapBlock> memory = new ArrayList<>();
    for (ClusterResourceAverage data : averages) {
        cpu.add(new HeatMapBlock(data.getName(), data.getCpuAverage()));
        memory.add(new HeatMapBlock(data.getName(), data.getMemoryAverage()));
    }
    utilization.setCpu(cpu);
    utilization.setMemory(memory);
}
#method_after
public static void getCpuAndMemory(HeatMapData utilization, DataSource dataSource) throws DashboardDataException {
    ClusterDwhDao dao = new ClusterDwhDao(dataSource);
    List<ClusterResourceAverage> averages = dao.getClusterCpuAndMemoryAverage();
    List<HeatMapBlock> cpu = new ArrayList<>();
    List<HeatMapBlock> memory = new ArrayList<>();
    for (ClusterResourceAverage data : averages) {
        cpu.add(new HeatMapBlock(data.getName(), data.getCpuAverage()));
        memory.add(new HeatMapBlock(data.getName(), data.getMemoryAverage()));
    }
    utilization.setCpu(cpu);
    utilization.setMemory(memory);
}
#end_block

#method_before
public static List<HeatMapBlock> getStorage(DataSource dwhDataSource) throws DashboardDataException {
    List<HeatMapBlock> nodes = new ArrayList<>();
    StorageDomainDwhDAO dao = new StorageDomainDwhDAO(dwhDataSource);
    for (StorageDomainAverage data : dao.getStorageAverage()) {
        nodes.add(new HeatMapBlock(data.getName(), data.getValue()));
    }
    return nodes;
}
#method_after
public static List<HeatMapBlock> getStorage(DataSource dwhDataSource) throws DashboardDataException {
    List<HeatMapBlock> nodes = new ArrayList<>();
    StorageDomainDwhDao dao = new StorageDomainDwhDao(dwhDataSource);
    for (StorageDomainAverage data : dao.getStorageAverage()) {
        nodes.add(new HeatMapBlock(data.getName(), data.getValue()));
    }
    return nodes;
}
#end_block

#method_before
public static InventoryStatus getDcInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    DataCenterDAO dao = new DataCenterDAO(engineDataSource);
    return dao.getDcInventoryStatus();
}
#method_after
public static InventoryStatus getDcInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    DataCenterDao dao = new DataCenterDao(engineDataSource);
    return dao.getDcInventoryStatus();
}
#end_block

#method_before
public static InventoryStatus getClusterInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    ClusterEngineDAO dao = new ClusterEngineDAO(engineDataSource);
    return dao.getClusterInventorySummary();
}
#method_after
public static InventoryStatus getClusterInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    ClusterEngineDao dao = new ClusterEngineDao(engineDataSource);
    return dao.getClusterInventorySummary();
}
#end_block

#method_before
public static InventoryStatus getHostInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    HostEngineDAO dao = new HostEngineDAO(engineDataSource);
    return dao.getHostInventoryStatus();
}
#method_after
public static InventoryStatus getHostInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    HostEngineDao dao = new HostEngineDao(engineDataSource);
    return dao.getHostInventoryStatus();
}
#end_block

#method_before
public static InventoryStatus getStorageInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    StorageDomainEngineDAO dao = new StorageDomainEngineDAO(engineDataSource);
    return dao.getStorageInventoryStatus();
}
#method_after
public static InventoryStatus getStorageInventoryStatus(DataSource engineDataSource) throws DashboardDataException {
    StorageDomainEngineDao dao = new StorageDomainEngineDao(engineDataSource);
    return dao.getStorageInventoryStatus();
}
#end_block

#method_before
public static InventoryStatus getVmInventorySummary(DataSource engineDataSource) throws DashboardDataException {
    VmEngineDAO dao = new VmEngineDAO(engineDataSource);
    return dao.getVmInventoryStatus();
}
#method_after
public static InventoryStatus getVmInventorySummary(DataSource engineDataSource) throws DashboardDataException {
    VmEngineDao dao = new VmEngineDao(engineDataSource);
    return dao.getVmInventoryStatus();
}
#end_block

#method_before
protected String[] addSession(String... names) {
    String[] ret = new String[names.length + 1];
    for (int i = 0; i < names.length; i++) {
        ret[i] = names[i];
    }
    ret[names.length] = "SessionId";
    return ret;
}
#method_after
protected String[] addSession(String... names) {
    String[] ret = new String[names.length + 1];
    System.arraycopy(names, 0, ret, 0, names.length);
    ret[names.length] = "SessionId";
    return ret;
}
#end_block

#method_before
protected Object[] addSession(Object... values) {
    Object[] ret = new Object[values.length + 1];
    for (int i = 0; i < values.length; i++) {
        ret[i] = values[i];
    }
    ret[values.length] = SESSION_ID;
    return ret;
}
#method_after
protected Object[] addSession(Object... values) {
    Object[] ret = new Object[values.length + 1];
    System.arraycopy(values, 0, ret, 0, values.length);
    ret[values.length] = SESSION_ID;
    return ret;
}
#end_block

#method_before
protected UriInfo setUpGetMatrixConstraintsExpectations(String matrixConstraint, String matrixConstraintValue, UriInfo uriInfo, boolean replay) {
    List<PathSegment> psl = new ArrayList<>();
    PathSegment ps = control.createMock(PathSegment.class);
    MultivaluedMap<String, String> matrixParams = control.createMock(MultivaluedMap.class);
    expect(matrixParams.isEmpty()).andReturn(false);
    expect(ps.getMatrixParameters()).andReturn(matrixParams).anyTimes();
    expect(matrixParams.containsKey(matrixConstraint)).andReturn(true).anyTimes();
    expect(matrixParams.getFirst(matrixConstraint)).andReturn(matrixConstraintValue).anyTimes();
    psl.add(ps);
    expect(uriInfo.getPathSegments()).andReturn(psl).anyTimes();
    if (replay) {
        control.replay();
    }
    return uriInfo;
}
#method_after
protected UriInfo setUpGetMatrixConstraintsExpectations(String matrixConstraint, boolean matrixConstraintExist, String matrixConstraintValue, UriInfo uriInfo, boolean replay) {
    List<PathSegment> psl = new ArrayList<>();
    PathSegment ps = control.createMock(PathSegment.class);
    MultivaluedMap<String, String> matrixParams = control.createMock(MultivaluedMap.class);
    expect(matrixParams.isEmpty()).andReturn(!matrixConstraintExist);
    expect(ps.getMatrixParameters()).andReturn(matrixParams).anyTimes();
    if (matrixConstraintExist) {
        expect(matrixParams.containsKey(matrixConstraint)).andReturn(matrixConstraintExist).anyTimes();
        expect(matrixParams.getFirst(matrixConstraint)).andReturn(matrixConstraintValue).anyTimes();
    }
    psl.add(ps);
    expect(uriInfo.getPathSegments()).andReturn(psl).anyTimes();
    if (replay) {
        control.replay();
    }
    return uriInfo;
}
#end_block

