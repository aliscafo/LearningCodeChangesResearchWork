471
#method_before
public static Builder builder() {
    return new AutoValue_TestAccountUpdate.Builder().httpPassword("http-pass");
}
#method_after
public static Builder builder(ThrowingFunction<TestAccountUpdate, TestAccount> accountUpdater) {
    return new AutoValue_TestAccountUpdate.Builder().accountUpdater(accountUpdater).httpPassword("http-pass");
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (!testRequiresSsh) {
        baseConfig.setString("sshd", null, "listenAddress", "off");
    }
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    Module module = createModule();
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig, module);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig, module);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    reindexAllGroups();
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict and reindex accounts in case tests modify them.
    evictAndReindexAccount(admin.getId());
    evictAndReindexAccount(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (!testRequiresSsh) {
        baseConfig.setString("sshd", null, "listenAddress", "off");
    }
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    Module module = createModule();
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig, module);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig, module);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    reindexAllGroups();
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict and reindex accounts in case tests modify them.
    evictAndReindexAccount(admin.getId());
    evictAndReindexAccount(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    ProjectInput in = projectInput(description);
    gApi.projects().create(in);
    project = new Project.NameKey(in.name);
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected Project.NameKey createProject(String nameSuffix, Project.NameKey parent, boolean createEmptyCommit, SubmitType submitType) throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = name(nameSuffix);
    in.parent = parent != null ? parent.get() : null;
    in.submitType = submitType;
    in.createEmptyCommit = createEmptyCommit;
    return createProject(in);
}
#method_after
protected Project.NameKey createProject(String nameSuffix, Project.NameKey parent, boolean createEmptyCommit, SubmitType submitType) throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = name(nameSuffix);
    in.parent = parent != null ? parent.get() : null;
    in.submitType = submitType;
    in.createEmptyCommit = createEmptyCommit;
    gApi.projects().create(in);
    return new Project.NameKey(in.name);
}
#end_block

#method_before
protected void allow(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void allow(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.allow(u.getConfig(), permission, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected void allowGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    for (String capabilityName : capabilityNames) {
        Util.allow(cfg, capabilityName, id);
    }
    saveProjectConfig(allProjects, cfg);
}
#method_after
protected void allowGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        for (String capabilityName : capabilityNames) {
            Util.allow(u.getConfig(), capabilityName, id);
        }
        u.save();
    }
}
#end_block

#method_before
protected void removeGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    for (String capabilityName : capabilityNames) {
        Util.remove(cfg, capabilityName, id);
    }
    saveProjectConfig(allProjects, cfg);
}
#method_after
protected void removeGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        for (String capabilityName : capabilityNames) {
            Util.remove(u.getConfig(), capabilityName, id);
        }
        u.save();
    }
}
#end_block

#method_before
protected void deny(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.deny(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void deny(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.deny(u.getConfig(), permission, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected PermissionRule block(Project.NameKey project, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    PermissionRule rule = Util.block(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
    return rule;
}
#method_after
protected PermissionRule block(Project.NameKey project, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        PermissionRule rule = Util.block(u.getConfig(), permission, id, ref);
        u.save();
        return rule;
    }
}
#end_block

#method_before
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, Permission.LABEL + label, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.block(u.getConfig(), Permission.LABEL + label, min, max, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(Iterables.transform(actual, i1 -> i1.changeId)).containsExactly((Object[]) expected).inOrder();
    assertThat(Iterables.transform(info.changes, i -> i.changeId)).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = group(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = group(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        u.getConfig().replace(ca);
        u.save();
        return ca;
    }
}
#end_block

#method_before
protected Map<Branch.NameKey, ObjectId> fetchFromSubmitPreview(String changeId) throws Exception {
    try (BinaryResult result = submitPreview(changeId)) {
        return fetchFromBundles(result);
    }
}
#method_after
protected Map<Branch.NameKey, ObjectId> fetchFromSubmitPreview(String changeId) throws Exception {
    try (BinaryResult result = gApi.changes().id(changeId).current().submitPreview()) {
        return fetchFromBundles(result);
    }
}
#end_block

#method_before
private void assertPermission(Permission permission, String expectedName, boolean expectedExclusive, @Nullable String expectedLabelName) {
    assertThat(permission).isNotNull();
    assertThat(permission.getName()).isEqualTo(expectedName);
    assertThat(permission.getExclusiveGroup()).isEqualTo(expectedExclusive);
    assertThat(permission.getLabel()).isEqualTo(expectedLabelName);
}
#method_after
protected void assertPermission(Permission permission, String expectedName, boolean expectedExclusive, @Nullable String expectedLabelName) {
    assertThat(permission).isNotNull();
    assertThat(permission.getName()).isEqualTo(expectedName);
    assertThat(permission.getExclusiveGroup()).isEqualTo(expectedExclusive);
    assertThat(permission.getLabel()).isEqualTo(expectedLabelName);
}
#end_block

#method_before
private void assertPermissionRule(PermissionRule rule, GroupReference expectedGroupReference, Action expectedAction, boolean expectedForce, int expectedMin, int expectedMax) {
    assertThat(rule.getGroup()).isEqualTo(expectedGroupReference);
    assertThat(rule.getAction()).isEqualTo(expectedAction);
    assertThat(rule.getForce()).isEqualTo(expectedForce);
    assertThat(rule.getMin()).isEqualTo(expectedMin);
    assertThat(rule.getMax()).isEqualTo(expectedMax);
}
#method_after
protected void assertPermissionRule(PermissionRule rule, GroupReference expectedGroupReference, Action expectedAction, boolean expectedForce, int expectedMin, int expectedMax) {
    assertThat(rule.getGroup()).isEqualTo(expectedGroupReference);
    assertThat(rule.getAction()).isEqualTo(expectedAction);
    assertThat(rule.getForce()).isEqualTo(expectedForce);
    assertThat(rule.getMin()).isEqualTo(expectedMin);
    assertThat(rule.getMax()).isEqualTo(expectedMax);
}
#end_block

#method_before
protected void configLabel(Project.NameKey project, String label, LabelFunction func, LabelValue... value) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType labelType = category(label, value);
    labelType.setFunction(func);
    cfg.getLabelSections().put(labelType.getName(), labelType);
    saveProjectConfig(project, cfg);
}
#method_after
protected void configLabel(Project.NameKey project, String label, LabelFunction func, LabelValue... value) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        LabelType labelType = category(label, value);
        labelType.setFunction(func);
        u.getConfig().getLabelSections().put(labelType.getName(), labelType);
        u.save();
    }
}
#end_block

#method_before
protected void enableCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setBooleanConfig(BooleanProjectConfig.CREATE_NEW_CHANGE_FOR_ALL_NOT_IN_TARGET, InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
}
#method_after
protected void enableCreateNewChangeForAllNotInTarget() throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getProject().setBooleanConfig(BooleanProjectConfig.CREATE_NEW_CHANGE_FOR_ALL_NOT_IN_TARGET, InheritableBoolean.TRUE);
        u.save();
    }
}
#end_block

#method_before
private AccountState createAccount(Consumer<TestAccountUpdate.Builder> accountUpdate) throws OrmException, IOException, ConfigInvalidException {
    Account.Id accountId = new Account.Id(seq.nextAccountId());
    return accountsUpdate.insert("Create Test Account", accountId, (account, updateBuilder) -> applyUpdate(account, updateBuilder, toAccountUpdate(accountUpdate)));
}
#method_after
private TestAccount createAccount(TestAccountCreation accountCreation) throws Exception {
    AccountsUpdate.AccountUpdater accountUpdater = (account, updateBuilder) -> fillBuilder(updateBuilder, accountCreation, account.getAccount().getId());
    AccountState createdAccount = createAccount(accountUpdater);
    TestAccount.Builder builder = toTestAccount(createdAccount);
    Optional<String> userName = createdAccount.getUserName();
    if (sshEnabled && userName.isPresent()) {
        addSshKeyPair(builder, createdAccount.getAccount(), userName.get());
    }
    return builder.build();
}
#end_block

#method_before
@Test
public void pendingReviewersInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    PushOneCommit.Result r = createWorkInProgressChange();
    String changeId = r.getChangeId();
    assertThat(gApi.changes().id(changeId).get().pendingReviewers).isEmpty();
    // Add some pending reviewers.
    String email1 = name("user1") + "@example.com";
    String email2 = name("user2") + "@example.com";
    String email3 = name("user3") + "@example.com";
    String email4 = name("user4") + "@example.com";
    accountOperations.create(creation -> creation.username(name("user1")).preferredEmail(email1).fullname("User 1"));
    accountOperations.create(creation -> creation.username(name("user2")).preferredEmail(email2).fullname("User 2"));
    accountOperations.create(creation -> creation.username(name("user3")).preferredEmail(email3).fullname("User 3"));
    accountOperations.create(creation -> creation.username(name("user4")).preferredEmail(email4).fullname("User 4"));
    ReviewInput in = ReviewInput.noScore().reviewer(email1).reviewer(email2).reviewer(email3, CC, false).reviewer(email4, CC, false).reviewer("byemail1@example.com").reviewer("byemail2@example.com").reviewer("byemail3@example.com", CC, false).reviewer("byemail4@example.com", CC, false);
    ReviewResult result = gApi.changes().id(changeId).revision("current").review(in);
    assertThat(result.reviewers).isNotEmpty();
    ChangeInfo info = gApi.changes().id(changeId).get();
    Function<Collection<AccountInfo>, Collection<String>> toEmails = ais -> ais.stream().map(ai -> ai.email).collect(toSet());
    assertThat(toEmails.apply(info.pendingReviewers.get(REVIEWER))).containsExactly(admin.email, email1, email2, "byemail1@example.com", "byemail2@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(CC))).containsExactly(email3, email4, "byemail3@example.com", "byemail4@example.com");
    assertThat(info.pendingReviewers.get(REMOVED)).isNull();
    // Stage some pending reviewer removals.
    gApi.changes().id(changeId).reviewer(email1).remove();
    gApi.changes().id(changeId).reviewer(email3).remove();
    gApi.changes().id(changeId).reviewer("byemail1@example.com").remove();
    gApi.changes().id(changeId).reviewer("byemail3@example.com").remove();
    info = gApi.changes().id(changeId).get();
    assertThat(toEmails.apply(info.pendingReviewers.get(REVIEWER))).containsExactly(admin.email, email2, "byemail2@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(CC))).containsExactly(email4, "byemail4@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(REMOVED))).containsExactly(email1, email3, "byemail1@example.com", "byemail3@example.com");
    // "Undo" a removal.
    in = ReviewInput.noScore().reviewer(email1);
    gApi.changes().id(changeId).revision("current").review(in);
    info = gApi.changes().id(changeId).get();
    assertThat(toEmails.apply(info.pendingReviewers.get(REVIEWER))).containsExactly(admin.email, email1, email2, "byemail2@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(CC))).containsExactly(email4, "byemail4@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(REMOVED))).containsExactly(email3, "byemail1@example.com", "byemail3@example.com");
    // "Commit" by moving out of WIP.
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.pendingReviewers).isEmpty();
    assertThat(toEmails.apply(info.reviewers.get(REVIEWER))).containsExactly(admin.email, email1, email2, "byemail2@example.com");
    assertThat(toEmails.apply(info.reviewers.get(CC))).containsExactly(email4, "byemail4@example.com");
    assertThat(info.reviewers.get(REMOVED)).isNull();
}
#method_after
@Test
public void pendingReviewersInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    PushOneCommit.Result r = createWorkInProgressChange();
    String changeId = r.getChangeId();
    assertThat(gApi.changes().id(changeId).get().pendingReviewers).isEmpty();
    // Add some pending reviewers.
    String email1 = name("user1") + "@example.com";
    String email2 = name("user2") + "@example.com";
    String email3 = name("user3") + "@example.com";
    String email4 = name("user4") + "@example.com";
    accountOperations.newAccount().username(name("user1")).preferredEmail(email1).fullname("User 1").create();
    accountOperations.newAccount().username(name("user2")).preferredEmail(email2).fullname("User 2").create();
    accountOperations.newAccount().username(name("user3")).preferredEmail(email3).fullname("User 3").create();
    accountOperations.newAccount().username(name("user4")).preferredEmail(email4).fullname("User 4").create();
    ReviewInput in = ReviewInput.noScore().reviewer(email1).reviewer(email2).reviewer(email3, CC, false).reviewer(email4, CC, false).reviewer("byemail1@example.com").reviewer("byemail2@example.com").reviewer("byemail3@example.com", CC, false).reviewer("byemail4@example.com", CC, false);
    ReviewResult result = gApi.changes().id(changeId).revision("current").review(in);
    assertThat(result.reviewers).isNotEmpty();
    ChangeInfo info = gApi.changes().id(changeId).get();
    Function<Collection<AccountInfo>, Collection<String>> toEmails = ais -> ais.stream().map(ai -> ai.email).collect(toSet());
    assertThat(toEmails.apply(info.pendingReviewers.get(REVIEWER))).containsExactly(admin.email, email1, email2, "byemail1@example.com", "byemail2@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(CC))).containsExactly(email3, email4, "byemail3@example.com", "byemail4@example.com");
    assertThat(info.pendingReviewers.get(REMOVED)).isNull();
    // Stage some pending reviewer removals.
    gApi.changes().id(changeId).reviewer(email1).remove();
    gApi.changes().id(changeId).reviewer(email3).remove();
    gApi.changes().id(changeId).reviewer("byemail1@example.com").remove();
    gApi.changes().id(changeId).reviewer("byemail3@example.com").remove();
    info = gApi.changes().id(changeId).get();
    assertThat(toEmails.apply(info.pendingReviewers.get(REVIEWER))).containsExactly(admin.email, email2, "byemail2@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(CC))).containsExactly(email4, "byemail4@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(REMOVED))).containsExactly(email1, email3, "byemail1@example.com", "byemail3@example.com");
    // "Undo" a removal.
    in = ReviewInput.noScore().reviewer(email1);
    gApi.changes().id(changeId).revision("current").review(in);
    info = gApi.changes().id(changeId).get();
    assertThat(toEmails.apply(info.pendingReviewers.get(REVIEWER))).containsExactly(admin.email, email1, email2, "byemail2@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(CC))).containsExactly(email4, "byemail4@example.com");
    assertThat(toEmails.apply(info.pendingReviewers.get(REMOVED))).containsExactly(email3, "byemail1@example.com", "byemail3@example.com");
    // "Commit" by moving out of WIP.
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.pendingReviewers).isEmpty();
    assertThat(toEmails.apply(info.reviewers.get(REVIEWER))).containsExactly(admin.email, email1, email2, "byemail2@example.com");
    assertThat(toEmails.apply(info.reviewers.get(CC))).containsExactly(email4, "byemail4@example.com");
    assertThat(info.reviewers.get(REMOVED)).isNull();
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, adminGroupUuid(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.allow(u.getConfig(), Permission.READ, adminGroupUuid(), "refs/*");
        Util.block(u.getConfig(), Permission.READ, REGISTERED_USERS, "refs/*");
        u.save();
    }
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, adminGroupUuid(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.allow(u.getConfig(), Permission.READ, adminGroupUuid(), "refs/*");
        Util.block(u.getConfig(), Permission.READ, REGISTERED_USERS, "refs/*");
        u.save();
    }
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, adminGroupUuid(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.allow(u.getConfig(), Permission.READ, adminGroupUuid(), "refs/*");
        Util.block(u.getConfig(), Permission.READ, REGISTERED_USERS, "refs/*");
        u.save();
    }
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    gApi.accounts().id(user.id.get()).setStatus("new status");
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    accountOperations.account(user.id).forUpdate().status("new status").update();
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#end_block

#method_before
@Test
public void addReviewerThatIsNotPerfectMatch() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    // create a group named "ab" with one user: testUser
    String email = "abcd@test.com";
    String fullname = "abcd";
    TestAccount testUser = accountOperations.create(creation -> creation.username("abcd").preferredEmail(email).fullname(fullname));
    String testGroup = createGroupWithRealName("ab");
    GroupApi groupApi = gApi.groups().id(testGroup);
    groupApi.description("test group");
    groupApi.addMembers(user.fullName);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = "abc";
    gApi.changes().id(r.getChangeId()).addReviewer(in.reviewer);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(new Address(fullname, email));
    assertThat(m.body()).contains("Hello " + fullname + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(testUser.accountId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewerThatIsNotPerfectMatch() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    // create a group named "ab" with one user: testUser
    String email = "abcd@test.com";
    String fullname = "abcd";
    TestAccount testUser = accountOperations.newAccount().username("abcd").preferredEmail(email).fullname(fullname).create();
    String testGroup = createGroupWithRealName("ab");
    GroupApi groupApi = gApi.groups().id(testGroup);
    groupApi.description("test group");
    groupApi.addMembers(user.fullName);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = "abc";
    gApi.changes().id(r.getChangeId()).addReviewer(in.reviewer);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(new Address(fullname, email));
    assertThat(m.body()).contains("Hello " + fullname + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(testUser.accountId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Test
public void addGroupAsReviewersWhenANotPerfectMatchedUserExists() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    // create a group named "kobe" with one user: lee
    String testUserFullname = "kobebryant";
    accountOperations.create(creation -> creation.username("kobebryant").preferredEmail("kobebryant@test.com").fullname(testUserFullname));
    String myGroupUserEmail = "lee@test.com";
    String myGroupUserFullname = "lee";
    TestAccount myGroupUser = accountOperations.create(creation -> creation.username("lee").preferredEmail(myGroupUserEmail).fullname(myGroupUserFullname));
    String testGroup = createGroupWithRealName("kobe");
    GroupApi groupApi = gApi.groups().id(testGroup);
    groupApi.description("test group");
    groupApi.addMembers(myGroupUserFullname);
    // ensure that user "user" is not in the group
    groupApi.removeMembers(testUserFullname);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = testGroup;
    gApi.changes().id(r.getChangeId()).addReviewer(in.reviewer);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(new Address(myGroupUserFullname, myGroupUserEmail));
    assertThat(m.body()).contains("Hello " + myGroupUserFullname + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, myGroupUserEmail);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(myGroupUser.accountId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addGroupAsReviewersWhenANotPerfectMatchedUserExists() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    // create a group named "kobe" with one user: lee
    String testUserFullname = "kobebryant";
    accountOperations.newAccount().username("kobebryant").preferredEmail("kobebryant@test.com").fullname(testUserFullname).create();
    String myGroupUserEmail = "lee@test.com";
    String myGroupUserFullname = "lee";
    TestAccount myGroupUser = accountOperations.newAccount().username("lee").preferredEmail(myGroupUserEmail).fullname(myGroupUserFullname).create();
    String testGroup = createGroupWithRealName("kobe");
    GroupApi groupApi = gApi.groups().id(testGroup);
    groupApi.description("test group");
    groupApi.addMembers(myGroupUserFullname);
    // ensure that user "user" is not in the group
    groupApi.removeMembers(testUserFullname);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = testGroup;
    gApi.changes().id(r.getChangeId()).addReviewer(in.reviewer);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(new Address(myGroupUserFullname, myGroupUserEmail));
    assertThat(m.body()).contains("Hello " + myGroupUserFullname + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, myGroupUserEmail);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(myGroupUser.accountId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Test
public void removeReviewerNoVotes() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    // ReviewerState will vary between ReviewDb and NoteDb; we just care that it
    // shows up somewhere.
    Iterable<AccountInfo> reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    sender.clear();
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    assertThat(gApi.changes().id(changeId).get().reviewers).isEmpty();
    assertThat(sender.getMessages()).hasSize(1);
    Message message = sender.getMessages().get(0);
    assertThat(message.body()).contains("Removed reviewer " + user.fullName + ".");
    assertThat(message.body()).doesNotContain("with the following votes");
    // Make sure the reviewer can still be added again.
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Remove again, and then try to remove once more to verify 404 is
    // returned.
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    exception.expect(ResourceNotFoundException.class);
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNoVotes() throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
        u.getConfig().getLabelSections().put(verified.getName(), verified);
        AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
        String heads = RefNames.REFS_HEADS + "*";
        Util.allow(u.getConfig(), Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
        u.save();
    }
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    // ReviewerState will vary between ReviewDb and NoteDb; we just care that it
    // shows up somewhere.
    Iterable<AccountInfo> reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    sender.clear();
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    assertThat(gApi.changes().id(changeId).get().reviewers).isEmpty();
    assertThat(sender.getMessages()).hasSize(1);
    Message message = sender.getMessages().get(0);
    assertThat(message.body()).contains("Removed reviewer " + user.fullName + ".");
    assertThat(message.body()).doesNotContain("with the following votes");
    // Make sure the reviewer can still be added again.
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Remove again, and then try to remove once more to verify 404 is
    // returned.
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    exception.expect(ResourceNotFoundException.class);
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    String email = "user2@example.com";
    TestAccount user2 = accountOperations.create(creation -> creation.username("user2").preferredEmail(email).fullname("User2"));
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    String email = "user2@example.com";
    TestAccount user2 = accountOperations.newAccount().username("user2").preferredEmail(email).fullname("User2").create();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID owners = systemGroupBackend.getGroup(CHANGE_OWNER).getUUID();
    AccountGroup.UUID registered = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, owners, heads);
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, heads);
    saveProjectConfig(project, cfg);
    // Set Code-Review+2 and Verified+1 as admin (change owner)
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    ReviewInput input = ReviewInput.approve();
    input.label(verified.getName(), 1);
    gApi.changes().id(changeId).revision(commit).review(input);
    // Reviewers should only be "admin"
    ChangeInfo c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    assertThat(c.reviewers.get(CC)).isNull();
    // Add the user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    // Approve the change as user, then remove the approval
    // (only to confirm that the user does have Code-Review+2 permission)
    setApiUser(user);
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.noScore());
    // Submit the change
    setApiUser(admin);
    gApi.changes().id(changeId).revision(commit).submit();
    // User should still be on the change
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getLabelSections().put(verified.getName(), verified);
        String heads = "refs/heads/*";
        AccountGroup.UUID owners = systemGroupBackend.getGroup(CHANGE_OWNER).getUUID();
        AccountGroup.UUID registered = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
        Util.allow(u.getConfig(), Permission.forLabel(verified.getName()), -1, 1, owners, heads);
        Util.allow(u.getConfig(), Permission.forLabel("Code-Review"), -2, +2, registered, heads);
        u.save();
    }
    // Set Code-Review+2 and Verified+1 as admin (change owner)
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    ReviewInput input = ReviewInput.approve();
    input.label(verified.getName(), 1);
    gApi.changes().id(changeId).revision(commit).review(input);
    // Reviewers should only be "admin"
    ChangeInfo c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    assertThat(c.reviewers.get(CC)).isNull();
    // Add the user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    // Approve the change as user, then remove the approval
    // (only to confirm that the user does have Code-Review+2 permission)
    setApiUser(user);
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.noScore());
    // Submit the change
    setApiUser(admin);
    gApi.changes().id(changeId).revision(commit).submit();
    // User should still be on the change
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getLabelSections().put(verified.getName(), verified);
        u.getConfig().getLabelSections().put(custom1.getName(), custom1);
        u.getConfig().getLabelSections().put(custom2.getName(), custom2);
        String heads = "refs/heads/*";
        AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
        Util.allow(u.getConfig(), Permission.forLabel("Verified"), -1, 1, anon, heads);
        Util.allow(u.getConfig(), Permission.forLabel("Custom1"), -1, 1, anon, heads);
        Util.allow(u.getConfig(), Permission.forLabel("Custom2"), -1, 1, anon, heads);
        u.save();
    }
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#method_after
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.blockLabel(u.getConfig(), "Code-Review", REGISTERED_USERS, "refs/heads/*");
        u.save();
    }
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#end_block

#method_before
@Test
public void checkLabelsForUnsubmittedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", -2, -1, 0, 1, 2);
    assertPermitted(change, "Verified", -1, 0, 1);
    // add an approval on the new label
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // abandon the change and see that the returned labels stay the same
    // while all permitted labels disappear.
    gApi.changes().id(r.getChangeId()).abandon();
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels).isEmpty();
}
#method_after
@Test
public void checkLabelsForUnsubmittedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // add new label and assert that it's returned for existing changes
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    LabelType verified = Util.verified();
    String heads = RefNames.REFS_HEADS + "*";
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getLabelSections().put(verified.getName(), verified);
        Util.allow(u.getConfig(), Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
        u.save();
    }
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", -2, -1, 0, 1, 2);
    assertPermitted(change, "Verified", -1, 0, 1);
    // add an approval on the new label
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    try (ProjectConfigUpdate u = updateProject(project)) {
        // remove label and assert that it's no longer returned for existing
        // changes, even if there is an approval for it
        u.getConfig().getLabelSections().remove(verified.getName());
        Util.remove(u.getConfig(), Permission.forLabel(verified.getName()), registeredUsers, heads);
        u.save();
    }
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // abandon the change and see that the returned labels stay the same
    // while all permitted labels disappear.
    gApi.changes().id(r.getChangeId()).abandon();
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels).isEmpty();
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#method_after
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    LabelType verified = Util.verified();
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    // add new label and assert that it's returned for existing changes
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getLabelSections().put(verified.getName(), verified);
        Util.allow(u.getConfig(), Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
        u.save();
    }
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // changes, even if there is an approval for it
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getLabelSections().remove(verified.getName());
        Util.remove(u.getConfig(), Permission.forLabel(verified.getName()), registeredUsers, heads);
        u.save();
    }
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChangeWithNonAuthorCodeReview() throws Exception {
    // Configure Non-Author-Code-Review
    RevCommit oldHead = getRemoteHead();
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Configure Non-Author-Code-Review", "rules.pl", "submit_rule(S) :-\n" + "  gerrit:default_submit(X),\n" + "  X =.. [submit | Ls],\n" + "  add_non_author_approval(Ls, R),\n" + "  S =.. [submit | R].\n" + "\n" + "add_non_author_approval(S1, S2) :-\n" + "  gerrit:commit_author(A),\n" + "  gerrit:commit_label(label('Code-Review', 2), R),\n" + "  R \\= A, !,\n" + "  S2 = [label('Non-Author-Code-Review', ok(R)) | S1].\n" + "add_non_author_approval(S1," + " [label('Non-Author-Code-Review', need(_)) | S1]).");
    push2.to(RefNames.REFS_CONFIG);
    testRepo.reset(oldHead);
    // Allow user to approve
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.codeReview().getName()), -2, 2, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Non-Author-Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 0, 1, 2);
}
#method_after
@Test
public void checkLabelsForMergedChangeWithNonAuthorCodeReview() throws Exception {
    // Configure Non-Author-Code-Review
    RevCommit oldHead = getRemoteHead();
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Configure Non-Author-Code-Review", "rules.pl", "submit_rule(S) :-\n" + "  gerrit:default_submit(X),\n" + "  X =.. [submit | Ls],\n" + "  add_non_author_approval(Ls, R),\n" + "  S =.. [submit | R].\n" + "\n" + "add_non_author_approval(S1, S2) :-\n" + "  gerrit:commit_author(A),\n" + "  gerrit:commit_label(label('Code-Review', 2), R),\n" + "  R \\= A, !,\n" + "  S2 = [label('Non-Author-Code-Review', ok(R)) | S1].\n" + "add_non_author_approval(S1," + " [label('Non-Author-Code-Review', need(_)) | S1]).");
    push2.to(RefNames.REFS_CONFIG);
    testRepo.reset(oldHead);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    // Allow user to approve
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.allow(u.getConfig(), Permission.forLabel(Util.codeReview().getName()), -2, 2, registeredUsers, heads);
        u.save();
    }
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Non-Author-Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 0, 1, 2);
}
#end_block

#method_before
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#method_after
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.allow(u.getConfig(), Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
        u.save();
    }
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#end_block

#method_before
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#method_after
@Test
public void maxPermittedValueBlocked() throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.blockLabel(u.getConfig(), "Code-Review", REGISTERED_USERS, "refs/heads/*");
        u.save();
    }
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#end_block

#method_before
public void submittableAfterLosingPermissions(String label) throws Exception {
    String codeReviewLabel = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID registered = SystemGroupBackend.REGISTERED_USERS;
    Util.allow(cfg, Permission.forLabel(label), -1, +1, registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(codeReviewLabel), -2, +2, registered, "refs/heads/*");
    saveProjectConfig(cfg);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // Verify user's permitted range.
    ChangeInfo change = gApi.changes().id(changeId).get();
    assertPermitted(change, label, -1, 0, 1);
    assertPermitted(change, codeReviewLabel, -2, -1, 0, 1, 2);
    ReviewInput input = new ReviewInput();
    input.label(codeReviewLabel, 2);
    input.label(label, 1);
    gApi.changes().id(changeId).current().review(input);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().keySet()).containsExactly(codeReviewLabel, label);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    // Remove user's permission for 'Label'.
    Util.remove(cfg, Permission.forLabel(label), registered, "refs/heads/*");
    // Update user's permitted range for 'Code-Review' to be -1...+1.
    Util.remove(cfg, Permission.forLabel(codeReviewLabel), registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(codeReviewLabel), -1, +1, registered, "refs/heads/*");
    saveProjectConfig(cfg);
    // Verify user's new permitted range.
    setApiUser(user);
    change = gApi.changes().id(changeId).get();
    assertPermitted(change, label);
    assertPermitted(change, codeReviewLabel, -1, 0, 1);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    gApi.changes().id(changeId).current().submit();
}
#method_after
public void submittableAfterLosingPermissions(String label) throws Exception {
    String codeReviewLabel = "Code-Review";
    AccountGroup.UUID registered = SystemGroupBackend.REGISTERED_USERS;
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.allow(u.getConfig(), Permission.forLabel(label), -1, +1, registered, "refs/heads/*");
        Util.allow(u.getConfig(), Permission.forLabel(codeReviewLabel), -2, +2, registered, "refs/heads/*");
        u.save();
    }
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // Verify user's permitted range.
    ChangeInfo change = gApi.changes().id(changeId).get();
    assertPermitted(change, label, -1, 0, 1);
    assertPermitted(change, codeReviewLabel, -2, -1, 0, 1, 2);
    ReviewInput input = new ReviewInput();
    input.label(codeReviewLabel, 2);
    input.label(label, 1);
    gApi.changes().id(changeId).current().review(input);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().keySet()).containsExactly(codeReviewLabel, label);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    // Remove user's permission for 'Label'.
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.remove(u.getConfig(), Permission.forLabel(label), registered, "refs/heads/*");
        // Update user's permitted range for 'Code-Review' to be -1...+1.
        Util.remove(u.getConfig(), Permission.forLabel(codeReviewLabel), registered, "refs/heads/*");
        Util.allow(u.getConfig(), Permission.forLabel(codeReviewLabel), -1, +1, registered, "refs/heads/*");
        u.save();
    }
    // Verify user's new permitted range.
    setApiUser(user);
    change = gApi.changes().id(changeId).get();
    assertPermitted(change, label);
    assertPermitted(change, codeReviewLabel, -1, 0, 1);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    gApi.changes().id(changeId).current().submit();
}
#end_block

#method_before
@Test
public void ignore() throws Exception {
    String email = "user2@example.com";
    String fullname = "User2";
    accountOperations.create(creation -> creation.username("user2").preferredEmail(email).fullname(fullname));
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    in = new AddReviewerInput();
    in.reviewer = email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).ignore(true);
    assertThat(gApi.changes().id(r.getChangeId()).ignored()).isTrue();
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    assertThat(messages.get(0).rcpt()).containsExactly(new Address(fullname, email));
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).ignore(false);
    assertThat(gApi.changes().id(r.getChangeId()).ignored()).isFalse();
}
#method_after
@Test
public void ignore() throws Exception {
    String email = "user2@example.com";
    String fullname = "User2";
    accountOperations.newAccount().username("user2").preferredEmail(email).fullname(fullname).create();
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    in = new AddReviewerInput();
    in.reviewer = email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).ignore(true);
    assertThat(gApi.changes().id(r.getChangeId()).ignored()).isTrue();
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    assertThat(messages.get(0).rcpt()).containsExactly(new Address(fullname, email));
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).ignore(false);
    assertThat(gApi.changes().id(r.getChangeId()).ignored()).isFalse();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public <T> JiraRestApi<T> get(Class<T> classOfT, String classPrefix) {
    return (JiraRestApi<T>) jiraRestApiFactory.create(classOfT, classPrefix);
}
#method_after
public <T> JiraRestApi<T> get(Class<T> classOfT, String classPrefix) {
    return new JiraRestApi<>(jiraConfig.getJiraUrl(), jiraConfig.getUsername(), jiraConfig.getPassword(), classOfT, classPrefix);
}
#end_block

#method_before
@Test
public void testJiraServerInfoForNonRootJiraUrl() throws Exception {
    String nonRootJiraUrl = "http://jira.mycompany.com/myroot/";
    url = new URL(nonRootJiraUrl);
    setUpCommonMocks();
    restApi = new JiraRestApi(jiraConfig, JiraIssue.class, ISSUE_CLASS_PREFIX);
    String jiraApiUrl = restApi.getBaseUrl();
    assertThat(jiraApiUrl).startsWith(nonRootJiraUrl);
}
#method_after
@Test
public void testJiraServerInfoForNonRootJiraUrl() throws Exception {
    setURL("http://jira.mycompany.com/myroot/");
    restApi = new JiraRestApi(url, user, password, JiraIssue.class, ISSUE_CLASS_PREFIX);
    String jiraApiUrl = restApi.getBaseUrl().toString();
    assertThat(jiraApiUrl).startsWith(url.toString());
}
#end_block

#method_before
@Test
public void testJiraServerInfoForNonRootJiraUrlNotEndingWithSlash() throws Exception {
    String nonRootJiraUrl = "http://jira.mycompany.com/myroot";
    url = new URL(nonRootJiraUrl);
    setUpCommonMocks();
    restApi = new JiraRestApi(jiraConfig, JiraIssue.class, ISSUE_CLASS_PREFIX);
    String jiraApiUrl = restApi.getBaseUrl();
    assertThat(jiraApiUrl).startsWith(nonRootJiraUrl);
}
#method_after
@Test
public void testJiraServerInfoForNonRootJiraUrlNotEndingWithSlash() throws Exception {
    setURL("http://jira.mycompany.com/myroot");
    restApi = new JiraRestApi(url, user, password, JiraIssue.class, ISSUE_CLASS_PREFIX);
    String jiraApiUrl = restApi.getBaseUrl().toString();
    assertThat(jiraApiUrl).startsWith(url.toString());
}
#end_block

#method_before
@Test
public void testJiraServerInfoForRootJiraUrl() throws Exception {
    String rootJiraUrl = "http://jira.mycompany.com";
    url = new URL(rootJiraUrl);
    setUpCommonMocks();
    restApi = new JiraRestApi(jiraConfig, JiraIssue.class, ISSUE_CLASS_PREFIX);
    String jiraApiUrl = restApi.getBaseUrl();
    assertThat(jiraApiUrl).startsWith(rootJiraUrl);
}
#method_after
@Test
public void testJiraServerInfoForRootJiraUrl() throws Exception {
    setURL("http://jira.mycompany.com");
    restApi = new JiraRestApi(url, user, password, JiraIssue.class, ISSUE_CLASS_PREFIX);
    String jiraApiUrl = restApi.getBaseUrl().toString();
    assertThat(jiraApiUrl).startsWith(url.toString());
}
#end_block

#method_before
private void init() {
    this.jira = sections.get(pluginName, null);
    Section jiraComment = sections.get(COMMENT_LINK_SECTION, pluginName);
    do {
        enterJiraConnectivity();
    } while (jiraUrl != null && (isConnectivityRequested(jiraUrl) && !isJiraConnectSuccessful()));
    if (jiraUrl == null) {
        return;
    }
    ui.header("Jira issue-tracking association");
    jiraComment.string("Jira issue-Id regex", "match", "([A-Z]+-[0-9]+)");
    jiraComment.set("html", String.format("<a href=\"%s/browse/$1\">$1</a>", jiraUrl));
    Section pluginConfig = sections.get("plugin", pluginName);
    pluginConfig.select("Issue-id enforced in commit message", "association", ItsAssociationPolicy.SUGGESTED);
}
#method_after
private void init() throws MalformedURLException {
    this.jira = sections.get(pluginName, null);
    Section jiraComment = sections.get(COMMENT_LINK_SECTION, pluginName);
    do {
        enterJiraConnectivity();
    } while (jiraUrl != null && (isConnectivityRequested(jiraUrl.toString()) && !isJiraConnectSuccessful()));
    if (jiraUrl == null) {
        return;
    }
    ui.header("Jira issue-tracking association");
    jiraComment.string("Jira issue-Id regex", "match", "([A-Z]+-[0-9]+)");
    jiraComment.set("html", String.format("<a href=\"%s/browse/$1\">$1</a>", jiraUrl));
    Section pluginConfig = sections.get("plugin", pluginName);
    pluginConfig.select("Issue-id enforced in commit message", "association", ItsAssociationPolicy.SUGGESTED);
}
#end_block

#method_before
public void enterJiraConnectivity() {
    jiraUrl = jira.string("Jira URL (empty to skip)", "url", null);
    if (jiraUrl != null) {
        jiraUsername = jira.string("Jira username", "username", "");
        jiraPassword = jira.password("username", "password");
    }
}
#method_after
public void enterJiraConnectivity() throws MalformedURLException {
    String jiraUrlString = jira.string("Jira URL (empty to skip)", "url", null);
    if (jiraUrlString != null) {
        jiraUrl = new URL(jiraUrlString);
        jiraUsername = jira.string("Jira username", "username", "");
        jiraPassword = jira.password("username", "password");
    }
}
#end_block

#method_before
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        URL serverUrl = new URL(jiraUrl);
        new JiraRestApi<>(serverUrl, jiraUsername, jiraPassword).ping();
        ui.message("[OK]\n");
        return true;
    } catch (MalformedURLException e) {
        ui.message("*Invalid URL* (%s)\n", e.toString());
        return false;
    } catch (IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#method_after
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        JiraServerInfo serverInfo = new JiraServerInfoRestApi(jiraUrl, jiraUsername, jiraPassword).get();
        if (Strings.isNullOrEmpty(serverInfo.getVersion())) {
            ui.message("*ERROR* Jira returned an empty version number");
            return false;
        }
        ui.message("[OK] - Jira Ver {}\n", serverInfo.getVersion());
        return true;
    } catch (IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#end_block

#method_before
public boolean issueExists(String issueKey) throws IOException {
    JiraRestApi<JiraIssue> api = apiBuilder.getIssue();
    api.doGet("/" + issueKey, HTTP_OK, new int[] { HTTP_NOT_FOUND, HTTP_FORBIDDEN });
    Integer code = api.getResponseCode();
    switch(code) {
        case HTTP_OK:
            return true;
        case HTTP_NOT_FOUND:
            log.error("Issue {} not found", issueKey);
            return false;
        case HTTP_FORBIDDEN:
            log.error("No permission to read Issue {}", issueKey);
            return false;
        default:
            // Cannot happen due to passCodes filter
            throw new IOException("Unexpected HTTP code received:" + code.toString());
    }
}
#method_after
public boolean issueExists(String issueKey) throws IOException {
    JiraRestApi<JiraIssue> api = apiBuilder.getIssue();
    api.doGet(issueKey, HTTP_OK, new int[] { HTTP_NOT_FOUND, HTTP_FORBIDDEN });
    Integer code = api.getResponseCode();
    switch(code) {
        case HTTP_OK:
            return true;
        case HTTP_NOT_FOUND:
            log.error("Issue {} not found", issueKey);
            return false;
        case HTTP_FORBIDDEN:
            log.error("No permission to read Issue {}", issueKey);
            return false;
        default:
            // Cannot happen due to passCodes filter
            throw new IOException("Unexpected HTTP code received:" + code.toString());
    }
}
#end_block

#method_before
public List<JiraTransition.Item> getTransitions(String issueKey) throws IOException {
    JiraRestApi<JiraTransition> api = apiBuilder.get(JiraTransition.class, "/issue");
    return Arrays.asList(api.doGet("/" + issueKey + "/transitions", HTTP_OK).getTransitions());
}
#method_after
public List<JiraTransition.Item> getTransitions(String issueKey) throws IOException {
    JiraRestApi<JiraTransition> api = apiBuilder.get(JiraTransition.class, "/issue");
    return Arrays.asList(api.doGet(issueKey + "/transitions", HTTP_OK).getTransitions());
}
#end_block

#method_before
public void addComment(String issueKey, String comment) throws IOException {
    if (issueExists(issueKey)) {
        log.debug("Trying to add comment for issue {}", issueKey);
        apiBuilder.getIssue().doPost("/" + issueKey + "/comment", gson.toJson(new JiraComment(comment)), HTTP_CREATED);
        log.debug("Comment added to issue {}", issueKey);
    } else {
        log.error("Issue {} does not exist or no access permission", issueKey);
    }
}
#method_after
public void addComment(String issueKey, String comment) throws IOException {
    if (issueExists(issueKey)) {
        log.debug("Trying to add comment for issue {}", issueKey);
        apiBuilder.getIssue().doPost(issueKey + "/comment", gson.toJson(new JiraComment(comment)), HTTP_CREATED);
        log.debug("Comment added to issue {}", issueKey);
    } else {
        log.error("Issue {} does not exist or no access permission", issueKey);
    }
}
#end_block

#method_before
public boolean doTransition(String issueKey, String transition) throws IOException, InvalidTransitionException {
    log.debug("Making transition to {} for {}", transition, issueKey);
    JiraTransition.Item t = getTransitionByName(issueKey, transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    log.debug("Transition issue {} to '{}' ({})", issueKey, transition, t.getId());
    return apiBuilder.getIssue().doPost("/" + issueKey + "/transitions", gson.toJson(new JiraTransition(t)), HTTP_NO_CONTENT);
}
#method_after
public boolean doTransition(String issueKey, String transition) throws IOException, InvalidTransitionException {
    log.debug("Making transition to {} for {}", transition, issueKey);
    JiraTransition.Item t = getTransitionByName(issueKey, transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    log.debug("Transition issue {} to '{}' ({})", issueKey, transition, t.getId());
    return apiBuilder.getIssue().doPost(issueKey + "/transitions", gson.toJson(new JiraTransition(t)), HTTP_NO_CONTENT);
}
#end_block

#method_before
private String encode(String user, String pass) {
    return Base64.getEncoder().encodeToString((user + ":" + pass).getBytes());
}
#method_after
private static String encode(String user, String pass) {
    return Base64.getEncoder().encodeToString((user + ":" + pass).getBytes());
}
#end_block

#method_before
String getBaseUrl() {
    return baseUrl;
}
#method_after
URL getBaseUrl() {
    return baseUrl;
}
#end_block

#method_before
private HttpURLConnection prepHttpConnection(String spec, boolean isPostRequest) throws IOException {
    String urlWithSpec = baseUrl + spec;
    URL url = new URL(urlWithSpec);
    ProxySelector proxySelector = ProxySelector.getDefault();
    Proxy proxy = HttpSupport.proxyFor(proxySelector, url);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection(proxy);
    conn.setRequestProperty("Authorization", "Basic " + auth);
    conn.setRequestProperty("Content-Type", "application/json");
    if (isPostRequest) {
        conn.setRequestMethod("POST");
        conn.setDoOutput(true);
    } else {
        conn.setRequestMethod("GET");
    }
    return conn;
}
#method_after
private HttpURLConnection prepHttpConnection(String spec, boolean isPostRequest) throws IOException {
    URL url = new URL(baseUrl, spec);
    ProxySelector proxySelector = ProxySelector.getDefault();
    Proxy proxy = HttpSupport.proxyFor(proxySelector, url);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection(proxy);
    conn.setRequestProperty("Authorization", "Basic " + auth);
    conn.setRequestProperty("Content-Type", "application/json");
    if (isPostRequest) {
        conn.setRequestMethod("POST");
        conn.setDoOutput(true);
    } else {
        conn.setRequestMethod("GET");
    }
    return conn;
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
    assertQuery("is:pending", expected);
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    Change change = insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    assertQuery("commit:0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, change);
        assertQuery("commit:" + q, change);
    }
}
#end_block

#method_before
@Test
public void byOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    assertQuery("owner:" + userId.get(), change1);
    assertQuery("owner:" + user2, change2);
    String nameEmail = user.asIdentifiedUser().getNameEmail();
    assertQuery("owner: \"" + nameEmail + "\"", change1);
}
#method_after
@Test
public void byOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    assertQuery("is:owner", change1);
    assertQuery("owner:" + userId.get(), change1);
    assertQuery("owner:" + user2, change2);
    String nameEmail = user.asIdentifiedUser().getNameEmail();
    assertQuery("owner: \"" + nameEmail + "\"", change1);
}
#end_block

#method_before
@Test
public void byOwnerIn() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    Change change3 = insert(repo, newChange(repo), user2);
    gApi.changes().id(change3.getId().get()).current().review(ReviewInput.approve());
    gApi.changes().id(change3.getId().get()).current().submit();
    assertQuery("ownerin:Administrators", change1);
    assertQuery("ownerin:\"Registered Users\"", change3, change2, change1);
    assertQuery("ownerin:\"Registered Users\" status:merged", change3);
}
#method_after
@Test
public void byOwnerIn() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    Change change3 = insert(repo, newChange(repo), user2);
    gApi.changes().id(change3.getId().get()).current().review(ReviewInput.approve());
    gApi.changes().id(change3.getId().get()).current().submit();
    assertQuery("ownerin:Administrators", change1);
    assertQuery("ownerin:\"Registered Users\"", change3, change2, change1);
    assertQuery("ownerin:\"Registered Users\" project:repo", change3, change2, change1);
    assertQuery("ownerin:\"Registered Users\" status:merged", change3);
}
#end_block

#method_before
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = insert(repo, newChangeForCommit(repo, commit1));
    Change change2 = insert(repo, newChangeForCommit(repo, commit2));
    assertQuery("added:>4");
    assertQuery("-added:<=4");
    assertQuery("added:3", change1);
    assertQuery("-(added:<3 OR added>3)", change1);
    assertQuery("added:>2", change1);
    assertQuery("-added:<=2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("-added:<3", change1);
    assertQuery("added:<1", change2);
    assertQuery("-added:>=1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("-added:>0", change2);
    assertQuery("deleted:>3");
    assertQuery("-deleted:<=3");
    assertQuery("deleted:2", change2);
    assertQuery("-(deleted:<2 OR deleted>2)", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("-deleted:<=1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("-deleted:<2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("-deleted:>=1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#method_after
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = insert(repo, newChangeForCommit(repo, commit1));
    Change change2 = insert(repo, newChangeForCommit(repo, commit2));
    assertQuery("added:>4");
    assertQuery("-added:<=4");
    assertQuery("added:3", change1);
    assertQuery("-(added:<3 OR added>3)", change1);
    assertQuery("added:>2", change1);
    assertQuery("-added:<=2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("-added:<3", change1);
    assertQuery("added:<1", change2);
    assertQuery("-added:>=1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("-added:>0", change2);
    assertQuery("deleted:>3");
    assertQuery("-deleted:<=3");
    assertQuery("deleted:2", change2);
    assertQuery("-(deleted:<2 OR deleted>2)", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("-deleted:<=1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("-deleted:<2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("-deleted:>=1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta:", "size:")) {
        assertQuery(str + "<2");
        assertQuery(str + "3", change1);
        assertQuery(str + ">2", change1);
        assertQuery(str + ">=3", change1);
        assertQuery(str + "<3", change2);
        assertQuery(str + "<=2", change2);
    }
}
#end_block

#method_before
@Test
public void reviewerAndCc() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    if (notesMigration.readChanges()) {
        assertQuery("reviewer:" + user1, change1);
        assertQuery("cc:" + user1, change2);
    } else {
        assertQuery("reviewer:" + user1, change2, change1);
        assertQuery("cc:" + user1);
    }
}
#method_after
@Test
public void reviewerAndCc() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    Change change3 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    assertQuery("is:reviewer");
    assertQuery("reviewer:self");
    gApi.changes().id(change3.getChangeId()).revision("current").review(ReviewInput.recommend());
    assertQuery("is:reviewer", change3);
    assertQuery("reviewer:self", change3);
    requestContext.setContext(newRequestContext(user1));
    if (notesMigration.readChanges()) {
        assertQuery("reviewer:" + user1, change1);
        assertQuery("cc:" + user1, change2);
        assertQuery("is:cc", change2);
        assertQuery("cc:self", change2);
    } else {
        assertQuery("reviewer:" + user1, change2, change1);
        assertQuery("cc:" + user1);
        assertQuery("is:cc");
        assertQuery("cc:self");
    }
}
#end_block

#method_before
@Test
public void reviewerin() throws Exception {
    Account.Id user1 = accountManager.authenticate(AuthRequest.forUser("user1")).getAccountId();
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("user2")).getAccountId();
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user2.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    String group = gApi.groups().create("foo").get().name;
    gApi.groups().id(group).addMembers(user2.toString());
    List<String> members = gApi.groups().id(group).members().stream().map(a -> a._accountId.toString()).collect(toList());
    assertThat(members).contains(user2.toString());
    assertQuery("reviewerin:\"Registered Users\"", change2, change1);
    assertQuery("reviewerin:" + group, change2);
    gApi.changes().id(change2.getId().get()).current().review(ReviewInput.approve());
    gApi.changes().id(change2.getId().get()).current().submit();
    assertQuery("reviewerin:" + group, change2);
    assertQuery("status:merged reviewerin:" + group, change2);
}
#method_after
@Test
public void reviewerin() throws Exception {
    Account.Id user1 = accountManager.authenticate(AuthRequest.forUser("user1")).getAccountId();
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("user2")).getAccountId();
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user2.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    String group = gApi.groups().create("foo").get().name;
    gApi.groups().id(group).addMembers(user2.toString());
    List<String> members = gApi.groups().id(group).members().stream().map(a -> a._accountId.toString()).collect(toList());
    assertThat(members).contains(user2.toString());
    assertQuery("reviewerin:\"Registered Users\"", change2, change1);
    assertQuery("reviewerin:" + group, change2);
    gApi.changes().id(change2.getId().get()).current().review(ReviewInput.approve());
    gApi.changes().id(change2.getId().get()).current().submit();
    assertQuery("reviewerin:" + group, change2);
    assertQuery("project:repo reviewerin:" + group, change2);
    assertQuery("status:merged reviewerin:" + group, change2);
}
#end_block

#method_before
@Test
public void submitRecords() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    gApi.changes().id(change1.getId().get()).current().review(ReviewInput.approve());
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(change2.getId().get()).current().review(ReviewInput.recommend());
    requestContext.setContext(newRequestContext(user.getAccountId()));
    assertQuery("is:submittable", change1);
    assertQuery("-is:submittable", change2);
    assertQuery("submittable:ok", change1);
    assertQuery("submittable:not_ready", change2);
    assertQuery("label:CodE-RevieW=ok", change1);
    assertQuery("label:CodE-RevieW=ok,user=user", change1);
    assertQuery("label:CodE-RevieW=ok,Administrators", change1);
    assertQuery("label:CodE-RevieW=ok,group=Administrators", change1);
    assertQuery("label:CodE-RevieW=ok,owner", change1);
    assertQuery("label:CodE-RevieW=ok,user1");
    assertQuery("label:CodE-RevieW=need", change2);
    // NEED records don't have associated users.
    assertQuery("label:CodE-RevieW=need,user1");
    assertQuery("label:CodE-RevieW=need,user");
}
#method_after
@Test
public void submitRecords() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    gApi.changes().id(change1.getId().get()).current().review(ReviewInput.approve());
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(change2.getId().get()).current().review(ReviewInput.recommend());
    requestContext.setContext(newRequestContext(user.getAccountId()));
    assertQuery("is:submittable", change1);
    assertQuery("-is:submittable", change2);
    assertQuery("submittable:ok", change1);
    assertQuery("submittable:not_ready", change2);
    assertQuery("label:CodE-RevieW=ok", change1);
    assertQuery("label:CodE-RevieW=ok,user=user", change1);
    assertQuery("label:CodE-RevieW=ok,Administrators", change1);
    assertQuery("label:CodE-RevieW=ok,group=Administrators", change1);
    assertQuery("label:CodE-RevieW=ok,owner", change1);
    assertQuery("label:CodE-RevieW=ok,user1");
    assertQuery("label:CodE-RevieW=need", change2);
    // NEED records don't have associated users.
    assertQuery("label:CodE-RevieW=need,user1");
    assertQuery("label:CodE-RevieW=need,user");
    gApi.changes().id(change1.getId().get()).current().submit();
    assertQuery("submittable:ok");
    assertQuery("submittable:closed", change1);
}
#end_block

#method_before
protected TestRepository<Repo> createProject(String name) throws Exception {
    gApi.projects().create(name).get();
    return new TestRepository<>(repoManager.openRepository(new Project.NameKey(name)));
}
#method_after
protected TestRepository<Repo> createProject(String name, String parent) throws Exception {
    ProjectInput input = new ProjectInput();
    input.name = name;
    input.parent = parent;
    gApi.projects().create(input).get();
    return new TestRepository<>(repoManager.openRepository(new Project.NameKey(name)));
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("Comment{").append("key=").append(key).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("realAuthor=").append(realAuthor != null ? realAuthor.getId().get() : "").append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append("tag=").append(Objects.toString(tag, "")).append("unresolved=").append(unresolved).append(',').append('}').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("Comment{").append("key=").append(key).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("realAuthor=").append(realAuthor != null ? realAuthor.getId().get() : "").append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("unresolved=").append(unresolved).append('}').toString();
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("realAuthor=").append(realAuthor != null ? realAuthor.get() : "").append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append("tag=").append(Objects.toString(tag, ""));
    builder.append("unresolved=").append(unresolved).append(',');
    builder.append('}');
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("realAuthor=").append(realAuthor != null ? realAuthor.get() : "").append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "").append(',');
    builder.append("tag=").append(Objects.toString(tag, "")).append(',');
    builder.append("unresolved=").append(unresolved);
    builder.append('}');
    return builder.toString();
}
#end_block

#method_before
@Test
public void cherryPickToExistingChange() throws Exception {
    PushOneCommit.Result r1 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "a").to("refs/for/master");
    String t1 = project.get() + "~master~" + r1.getChangeId();
    BranchInput bin = new BranchInput();
    bin.revision = r1.getCommit().getParent(0).name();
    gApi.projects().name(project.get()).branch("foo").create(bin);
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "b", r1.getChangeId()).to("refs/for/foo");
    String t2 = project.get() + "~foo~" + r2.getChangeId();
    gApi.changes().id(t2).abandon();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = r1.getCommit().getFullMessage();
    try {
        gApi.changes().id(t1).current().cherryPick(in);
        fail("did not get ResourceNotFoundException");
    } catch (ResourceConflictException e) {
        assertThat(e.getMessage()).isEqualTo("Cannot create new patch set of change " + info(t2)._number + " because it is abandoned");
    }
    gApi.changes().id(t2).restore();
    gApi.changes().id(t1).current().cherryPick(in);
    assertThat(get(t2, ALL_REVISIONS).revisions).hasSize(2);
    assertThat(gApi.changes().id(t2).current().file(FILE_NAME).content().asString()).isEqualTo("a");
}
#method_after
@Test
public void cherryPickToExistingChange() throws Exception {
    PushOneCommit.Result r1 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "a").to("refs/for/master");
    String t1 = project.get() + "~master~" + r1.getChangeId();
    BranchInput bin = new BranchInput();
    bin.revision = r1.getCommit().getParent(0).name();
    gApi.projects().name(project.get()).branch("foo").create(bin);
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "b", r1.getChangeId()).to("refs/for/foo");
    String t2 = project.get() + "~foo~" + r2.getChangeId();
    gApi.changes().id(t2).abandon();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = r1.getCommit().getFullMessage();
    try {
        gApi.changes().id(t1).current().cherryPick(in);
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e.getMessage()).isEqualTo("Cannot create new patch set of change " + info(t2)._number + " because it is abandoned");
    }
    gApi.changes().id(t2).restore();
    gApi.changes().id(t1).current().cherryPick(in);
    assertThat(get(t2, ALL_REVISIONS).revisions).hasSize(2);
    assertThat(gApi.changes().id(t2).current().file(FILE_NAME).content().asString()).isEqualTo("a");
}
#end_block

#method_before
private void deleteGroupRef(String groupId) throws Exception {
    AccountGroup.UUID uuid = new AccountGroup.UUID(groupId);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        RefUpdate ru = repo.updateRef(RefNames.refsGroups(uuid));
        ru.setForceUpdate(true);
        ru.setNewObjectId(ObjectId.zeroId());
        assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Reindex the group.
    gApi.groups().id(uuid.get()).index();
    // Verify "sub-group" has been deleted.
    try {
        gApi.groups().id(uuid.get()).get();
        fail("did not get ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    }
}
#method_after
private void deleteGroupRef(String groupId) throws Exception {
    AccountGroup.UUID uuid = new AccountGroup.UUID(groupId);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        RefUpdate ru = repo.updateRef(RefNames.refsGroups(uuid));
        ru.setForceUpdate(true);
        ru.setNewObjectId(ObjectId.zeroId());
        assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Reindex the group.
    gApi.groups().id(uuid.get()).index();
    // Verify "sub-group" has been deleted.
    try {
        gApi.groups().id(uuid.get()).get();
        fail("expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    }
}
#end_block

#method_before
public Set<Property> extractFrom(ChangeAttribute changeAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("branch", changeAttribute.branch));
    properties.add(propertyFactory.create("topic", changeAttribute.topic));
    properties.add(propertyFactory.create("subject", changeAttribute.subject));
    properties.add(propertyFactory.create("commitMessage", changeAttribute.commitMessage));
    properties.add(propertyFactory.create("changeId", changeAttribute.id));
    properties.add(propertyFactory.create("changeNumber", String.valueOf(changeAttribute.number)));
    properties.add(propertyFactory.create("changeUrl", changeAttribute.url));
    properties.add(propertyFactory.create("formatChangeUrl", its.createLinkForWebui(changeAttribute.url, changeAttribute.url)));
    String status = null;
    if (changeAttribute.status != null) {
        status = changeAttribute.status.toString();
    }
    properties.add(propertyFactory.create("status", status));
    properties.addAll(extractFrom(changeAttribute.owner, "owner"));
    return properties;
}
#method_after
public Set<Property> extractFrom(ChangeAttribute changeAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("branch", changeAttribute.branch));
    properties.add(propertyFactory.create("topic", changeAttribute.topic));
    properties.add(propertyFactory.create("subject", changeAttribute.subject));
    properties.add(propertyFactory.create("escapedSubject", StringEscapeUtils.escapeJava(changeAttribute.subject)));
    properties.add(propertyFactory.create("commitMessage", changeAttribute.commitMessage));
    properties.add(propertyFactory.create("changeId", changeAttribute.id));
    properties.add(propertyFactory.create("changeNumber", String.valueOf(changeAttribute.number)));
    properties.add(propertyFactory.create("changeUrl", changeAttribute.url));
    properties.add(propertyFactory.create("formatChangeUrl", its.createLinkForWebui(changeAttribute.url, changeAttribute.url)));
    String status = null;
    if (changeAttribute.status != null) {
        status = changeAttribute.status.toString();
    }
    properties.add(propertyFactory.create("status", status));
    properties.addAll(extractFrom(changeAttribute.owner, "owner"));
    return properties;
}
#end_block

#method_before
public void testChangeAttribute() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    Property propertyBranch = createMock(Property.class);
    expect(propertyFactory.create("branch", "testBranch")).andReturn(propertyBranch);
    Property propertyTopic = createMock(Property.class);
    expect(propertyFactory.create("topic", "testTopic")).andReturn(propertyTopic);
    Property propertySubject = createMock(Property.class);
    expect(propertyFactory.create("subject", "testSubject")).andReturn(propertySubject);
    Property propertyId = createMock(Property.class);
    expect(propertyFactory.create("changeId", "testId")).andReturn(propertyId);
    Property propertyNumber = createMock(Property.class);
    expect(propertyFactory.create("changeNumber", "4711")).andReturn(propertyNumber);
    Property propertyUrl = createMock(Property.class);
    expect(propertyFactory.create("changeUrl", "http://www.example.org/test")).andReturn(propertyUrl);
    Property propertyStatus = createMock(Property.class);
    expect(propertyFactory.create("status", null)).andReturn(propertyStatus);
    Property propertyEmail = createMock(Property.class);
    expect(propertyFactory.create("ownerEmail", "testEmail")).andReturn(propertyEmail);
    Property propertyName = createMock(Property.class);
    expect(propertyFactory.create("ownerName", "testName")).andReturn(propertyName);
    Property propertyUsername = createMock(Property.class);
    expect(propertyFactory.create("ownerUsername", "testUsername")).andReturn(propertyUsername);
    Property propertyCommitMessage = createMock(Property.class);
    expect(propertyFactory.create("commitMessage", "Commit Message")).andReturn(propertyCommitMessage);
    Property propertyFormatChangeUrl = createMock(Property.class);
    expect(propertyFactory.create("formatChangeUrl", "http://www.example.org/test")).andReturn(propertyFormatChangeUrl);
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Set<Property> actual = extractor.extractFrom(changeAttribute);
    Set<Property> expected = Sets.newHashSet();
    expected.add(propertyBranch);
    expected.add(propertyTopic);
    expected.add(propertySubject);
    expected.add(propertyId);
    expected.add(propertyNumber);
    expected.add(propertyUrl);
    expected.add(propertyStatus);
    expected.add(propertyEmail);
    expected.add(propertyName);
    expected.add(propertyUsername);
    expected.add(propertyCommitMessage);
    expected.add(propertyFormatChangeUrl);
    assertEquals("Properties do not match", expected, actual);
}
#method_after
public void testChangeAttribute() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    Property propertyBranch = createMock(Property.class);
    expect(propertyFactory.create("branch", "testBranch")).andReturn(propertyBranch);
    Property propertyTopic = createMock(Property.class);
    expect(propertyFactory.create("topic", "testTopic")).andReturn(propertyTopic);
    Property propertySubject = createMock(Property.class);
    expect(propertyFactory.create("subject", "testSubject")).andReturn(propertySubject);
    Property propertyEscapedSubject = createMock(Property.class);
    expect(propertyFactory.create("escapedSubject", "testSubject")).andReturn(propertyEscapedSubject);
    Property propertyId = createMock(Property.class);
    expect(propertyFactory.create("changeId", "testId")).andReturn(propertyId);
    Property propertyNumber = createMock(Property.class);
    expect(propertyFactory.create("changeNumber", "4711")).andReturn(propertyNumber);
    Property propertyUrl = createMock(Property.class);
    expect(propertyFactory.create("changeUrl", "http://www.example.org/test")).andReturn(propertyUrl);
    Property propertyStatus = createMock(Property.class);
    expect(propertyFactory.create("status", null)).andReturn(propertyStatus);
    Property propertyEmail = createMock(Property.class);
    expect(propertyFactory.create("ownerEmail", "testEmail")).andReturn(propertyEmail);
    Property propertyName = createMock(Property.class);
    expect(propertyFactory.create("ownerName", "testName")).andReturn(propertyName);
    Property propertyUsername = createMock(Property.class);
    expect(propertyFactory.create("ownerUsername", "testUsername")).andReturn(propertyUsername);
    Property propertyCommitMessage = createMock(Property.class);
    expect(propertyFactory.create("commitMessage", "Commit Message")).andReturn(propertyCommitMessage);
    Property propertyFormatChangeUrl = createMock(Property.class);
    expect(propertyFactory.create("formatChangeUrl", "http://www.example.org/test")).andReturn(propertyFormatChangeUrl);
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Set<Property> actual = extractor.extractFrom(changeAttribute);
    Set<Property> expected = Sets.newHashSet();
    expected.add(propertyBranch);
    expected.add(propertyTopic);
    expected.add(propertySubject);
    expected.add(propertyEscapedSubject);
    expected.add(propertyId);
    expected.add(propertyNumber);
    expected.add(propertyUrl);
    expected.add(propertyStatus);
    expected.add(propertyEmail);
    expected.add(propertyName);
    expected.add(propertyUsername);
    expected.add(propertyCommitMessage);
    expected.add(propertyFormatChangeUrl);
    assertEquals("Properties do not match", expected, actual);
}
#end_block

#method_before
public void testChangeAttributeFull() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.status = Status.ABANDONED;
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    Property propertyBranch = createMock(Property.class);
    expect(propertyFactory.create("branch", "testBranch")).andReturn(propertyBranch);
    Property propertyTopic = createMock(Property.class);
    expect(propertyFactory.create("topic", "testTopic")).andReturn(propertyTopic);
    Property propertySubject = createMock(Property.class);
    expect(propertyFactory.create("subject", "testSubject")).andReturn(propertySubject);
    Property propertyId = createMock(Property.class);
    expect(propertyFactory.create("changeId", "testId")).andReturn(propertyId);
    Property propertyNumber = createMock(Property.class);
    expect(propertyFactory.create("changeNumber", "4711")).andReturn(propertyNumber);
    Property propertyUrl = createMock(Property.class);
    expect(propertyFactory.create("changeUrl", "http://www.example.org/test")).andReturn(propertyUrl);
    Property propertyStatus = createMock(Property.class);
    expect(propertyFactory.create("status", "ABANDONED")).andReturn(propertyStatus);
    Property propertyEmail = createMock(Property.class);
    expect(propertyFactory.create("ownerEmail", "testEmail")).andReturn(propertyEmail);
    Property propertyName = createMock(Property.class);
    expect(propertyFactory.create("ownerName", "testName")).andReturn(propertyName);
    Property propertyUsername = createMock(Property.class);
    expect(propertyFactory.create("ownerUsername", "testUsername")).andReturn(propertyUsername);
    Property propertyCommitMessage = createMock(Property.class);
    expect(propertyFactory.create("commitMessage", "Commit Message")).andReturn(propertyCommitMessage);
    Property propertyFormatChangeUrl = createMock(Property.class);
    expect(propertyFactory.create("formatChangeUrl", "http://www.example.org/test")).andReturn(propertyFormatChangeUrl);
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Set<Property> actual = extractor.extractFrom(changeAttribute);
    Set<Property> expected = Sets.newHashSet();
    expected.add(propertyBranch);
    expected.add(propertyTopic);
    expected.add(propertySubject);
    expected.add(propertyId);
    expected.add(propertyNumber);
    expected.add(propertyUrl);
    expected.add(propertyStatus);
    expected.add(propertyEmail);
    expected.add(propertyName);
    expected.add(propertyUsername);
    expected.add(propertyCommitMessage);
    expected.add(propertyFormatChangeUrl);
    assertEquals("Properties do not match", expected, actual);
}
#method_after
public void testChangeAttributeFull() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.status = Status.ABANDONED;
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    Property propertyBranch = createMock(Property.class);
    expect(propertyFactory.create("branch", "testBranch")).andReturn(propertyBranch);
    Property propertyTopic = createMock(Property.class);
    expect(propertyFactory.create("topic", "testTopic")).andReturn(propertyTopic);
    Property propertySubject = createMock(Property.class);
    expect(propertyFactory.create("subject", "testSubject")).andReturn(propertySubject);
    Property propertyEscapedSubject = createMock(Property.class);
    expect(propertyFactory.create("escapedSubject", "testSubject")).andReturn(propertyEscapedSubject);
    Property propertyId = createMock(Property.class);
    expect(propertyFactory.create("changeId", "testId")).andReturn(propertyId);
    Property propertyNumber = createMock(Property.class);
    expect(propertyFactory.create("changeNumber", "4711")).andReturn(propertyNumber);
    Property propertyUrl = createMock(Property.class);
    expect(propertyFactory.create("changeUrl", "http://www.example.org/test")).andReturn(propertyUrl);
    Property propertyStatus = createMock(Property.class);
    expect(propertyFactory.create("status", "ABANDONED")).andReturn(propertyStatus);
    Property propertyEmail = createMock(Property.class);
    expect(propertyFactory.create("ownerEmail", "testEmail")).andReturn(propertyEmail);
    Property propertyName = createMock(Property.class);
    expect(propertyFactory.create("ownerName", "testName")).andReturn(propertyName);
    Property propertyUsername = createMock(Property.class);
    expect(propertyFactory.create("ownerUsername", "testUsername")).andReturn(propertyUsername);
    Property propertyCommitMessage = createMock(Property.class);
    expect(propertyFactory.create("commitMessage", "Commit Message")).andReturn(propertyCommitMessage);
    Property propertyFormatChangeUrl = createMock(Property.class);
    expect(propertyFactory.create("formatChangeUrl", "http://www.example.org/test")).andReturn(propertyFormatChangeUrl);
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Set<Property> actual = extractor.extractFrom(changeAttribute);
    Set<Property> expected = Sets.newHashSet();
    expected.add(propertyBranch);
    expected.add(propertyTopic);
    expected.add(propertySubject);
    expected.add(propertyEscapedSubject);
    expected.add(propertyId);
    expected.add(propertyNumber);
    expected.add(propertyUrl);
    expected.add(propertyStatus);
    expected.add(propertyEmail);
    expected.add(propertyName);
    expected.add(propertyUsername);
    expected.add(propertyCommitMessage);
    expected.add(propertyFormatChangeUrl);
    assertEquals("Properties do not match", expected, actual);
}
#end_block

#method_before
@Override
public List<SshKeyInfo> apply(AccountResource rsrc) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser());
}
#method_after
@Override
public List<SshKeyInfo> apply(AccountResource rsrc) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.currentUser().check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser());
}
#end_block

#method_before
public static SshKeyInfo newSshKeyInfo(AccountSshKey sshKey) {
    SshKeyInfo info = new SshKeyInfo();
    info.seq = sshKey.id().get();
    info.sshPublicKey = sshKey.sshPublicKey();
    info.encodedKey = sshKey.encodedKey();
    info.algorithm = sshKey.algorithm();
    info.comment = Strings.emptyToNull(sshKey.comment());
    info.valid = sshKey.valid();
    return info;
}
#method_after
public static SshKeyInfo newSshKeyInfo(AccountSshKey sshKey) {
    SshKeyInfo info = new SshKeyInfo();
    info.seq = sshKey.seq();
    info.sshPublicKey = sshKey.sshPublicKey();
    info.encodedKey = sshKey.encodedKey();
    info.algorithm = sshKey.algorithm();
    info.comment = Strings.emptyToNull(sshKey.comment());
    info.valid = sshKey.valid();
    return info;
}
#end_block

#method_before
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    ExternalId user = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, username));
    if (user == null) {
        return NO_SUCH_USER;
    }
    List<SshKeyCacheEntry> kl = new ArrayList<>(4);
    for (AccountSshKey k : authorizedKeys.getKeys(user.accountId())) {
        if (k.valid()) {
            add(kl, k);
        }
    }
    if (kl.isEmpty()) {
        return NO_KEYS;
    }
    return Collections.unmodifiableList(kl);
}
#method_after
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    Optional<ExternalId> user = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, username));
    if (!user.isPresent()) {
        return NO_SUCH_USER;
    }
    List<SshKeyCacheEntry> kl = new ArrayList<>(4);
    for (AccountSshKey k : authorizedKeys.getKeys(user.get().accountId())) {
        if (k.valid()) {
            add(kl, k);
        }
    }
    if (kl.isEmpty()) {
        return NO_KEYS;
    }
    return Collections.unmodifiableList(kl);
}
#end_block

#method_before
private void add(List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.id(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(k);
    }
}
#method_after
private void add(List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.accountId(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(k);
    }
}
#end_block

#method_before
private void markInvalid(AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.id() + " invalid");
        authorizedKeys.markKeyInvalid(k.account(), k.id().get());
    } catch (IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.id() + " invalid", e);
    }
}
#method_after
private void markInvalid(AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.seq() + " of account " + k.accountId() + " invalid");
        authorizedKeys.markKeyInvalid(k.accountId(), k.seq());
    } catch (IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key " + k.seq() + " of account " + k.accountId() + " invalid", e);
    }
}
#end_block

#method_before
private void deleteSshKey(SshKeyInfo i) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    AccountSshKey sshKey = AccountSshKey.create(new AccountSshKey.Id(user.getAccountId(), i.seq), i.sshPublicKey);
    deleteSshKey.apply(new AccountResource.SshKey(user.asIdentifiedUser(), sshKey), null);
}
#method_after
private void deleteSshKey(SshKeyInfo i) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    AccountSshKey sshKey = AccountSshKey.create(user.getAccountId(), i.seq, i.sshPublicKey);
    deleteSshKey.apply(new AccountResource.SshKey(user.asIdentifiedUser(), sshKey), null);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ListMultimap<Account.Id, AccountSshKey> imports = MultimapBuilder.hashKeys().arrayListValues().build();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "seq, " + "ssh_public_key, " + "valid " + "FROM account_ssh_keys")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            int seq = rs.getInt(2);
            String sshPublicKey = rs.getString(3);
            boolean valid = toBoolean(rs.getString(4));
            AccountSshKey key = AccountSshKey.create(new AccountSshKey.Id(accountId, seq), sshPublicKey, valid);
            imports.put(accountId, key);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        for (Map.Entry<Account.Id, Collection<AccountSshKey>> e : imports.asMap().entrySet()) {
            try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru)) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(new SimpleSshKeyCreator(), e.getKey());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(fixInvalidSequenceNumbers(e.getValue()));
                authorizedKeys.commit(md);
            }
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ListMultimap<Account.Id, AccountSshKey> imports = MultimapBuilder.hashKeys().arrayListValues().build();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "seq, " + "ssh_public_key, " + "valid " + "FROM account_ssh_keys")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            int seq = rs.getInt(2);
            String sshPublicKey = rs.getString(3);
            boolean valid = toBoolean(rs.getString(4));
            AccountSshKey key = AccountSshKey.create(accountId, seq, sshPublicKey, valid);
            imports.put(accountId, key);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        for (Map.Entry<Account.Id, Collection<AccountSshKey>> e : imports.asMap().entrySet()) {
            try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru)) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(new SimpleSshKeyCreator(), e.getKey());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(fixInvalidSequenceNumbers(e.getValue()));
                authorizedKeys.commit(md);
            }
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
private Collection<AccountSshKey> fixInvalidSequenceNumbers(Collection<AccountSshKey> keys) {
    Ordering<AccountSshKey> o = Ordering.from(comparing(k -> k.id().get()));
    List<AccountSshKey> fixedKeys = new ArrayList<>(keys);
    AccountSshKey minKey = o.min(keys);
    while (minKey.id().get() <= 0) {
        AccountSshKey fixedKey = AccountSshKey.create(new AccountSshKey.Id(minKey.id().getParentKey(), Math.max(o.max(keys).id().get() + 1, 1)), minKey.sshPublicKey());
        Collections.replaceAll(fixedKeys, minKey, fixedKey);
        minKey = o.min(fixedKeys);
    }
    return fixedKeys;
}
#method_after
private Collection<AccountSshKey> fixInvalidSequenceNumbers(Collection<AccountSshKey> keys) {
    Ordering<AccountSshKey> o = Ordering.from(comparing(k -> k.seq()));
    List<AccountSshKey> fixedKeys = new ArrayList<>(keys);
    AccountSshKey minKey = o.min(keys);
    while (minKey.seq() <= 0) {
        AccountSshKey fixedKey = AccountSshKey.create(minKey.accountId(), Math.max(o.max(keys).seq() + 1, 1), minKey.sshPublicKey());
        Collections.replaceAll(fixedKeys, minKey, fixedKey);
        minKey = o.min(fixedKeys);
    }
    return fixedKeys;
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().id().get());
    rsrc.getUser().getUserName().ifPresent(sshKeyCache::evict);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.currentUser().check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().seq());
    rsrc.getUser().getUserName().ifPresent(sshKeyCache::evict);
    return Response.none();
}
#end_block

#method_before
@Test
public void validity() throws Exception {
    AccountSshKey key = AccountSshKey.create(new AccountSshKey.Id(accountId, -1), KEY1);
    assertThat(key.valid()).isFalse();
    key = AccountSshKey.create(new AccountSshKey.Id(accountId, 0), KEY1);
    assertThat(key.valid()).isFalse();
    key = AccountSshKey.create(new AccountSshKey.Id(accountId, 1), KEY1);
    assertThat(key.valid()).isTrue();
}
#method_after
@Test
public void validity() throws Exception {
    AccountSshKey key = AccountSshKey.create(accountId, -1, KEY1);
    assertThat(key.valid()).isFalse();
    key = AccountSshKey.create(accountId, 0, KEY1);
    assertThat(key.valid()).isFalse();
    key = AccountSshKey.create(accountId, 1, KEY1);
    assertThat(key.valid()).isTrue();
}
#end_block

#method_before
@Test
public void getters() throws Exception {
    AccountSshKey key = AccountSshKey.create(new AccountSshKey.Id(accountId, 1), KEY1);
    assertThat(key.sshPublicKey()).isEqualTo(KEY1);
    assertThat(key.algorithm()).isEqualTo(KEY1.split(" ")[0]);
    assertThat(key.encodedKey()).isEqualTo(KEY1.split(" ")[1]);
    assertThat(key.comment()).isEqualTo(KEY1.split(" ")[2]);
}
#method_after
@Test
public void getters() throws Exception {
    AccountSshKey key = AccountSshKey.create(accountId, 1, KEY1);
    assertThat(key.sshPublicKey()).isEqualTo(KEY1);
    assertThat(key.algorithm()).isEqualTo(KEY1.split(" ")[0]);
    assertThat(key.encodedKey()).isEqualTo(KEY1.split(" ")[1]);
    assertThat(key.comment()).isEqualTo(KEY1.split(" ")[2]);
}
#end_block

#method_before
@Test
public void keyWithNewLines() throws Exception {
    AccountSshKey key = AccountSshKey.create(new AccountSshKey.Id(accountId, 1), KEY1_WITH_NEWLINES);
    assertThat(key.sshPublicKey()).isEqualTo(KEY1);
    assertThat(key.algorithm()).isEqualTo(KEY1.split(" ")[0]);
    assertThat(key.encodedKey()).isEqualTo(KEY1.split(" ")[1]);
    assertThat(key.comment()).isEqualTo(KEY1.split(" ")[2]);
}
#method_after
@Test
public void keyWithNewLines() throws Exception {
    AccountSshKey key = AccountSshKey.create(accountId, 1, KEY1_WITH_NEWLINES);
    assertThat(key.sshPublicKey()).isEqualTo(KEY1);
    assertThat(key.algorithm()).isEqualTo(KEY1.split(" ")[0]);
    assertThat(key.encodedKey()).isEqualTo(KEY1.split(" ")[1]);
    assertThat(key.comment()).isEqualTo(KEY1.split(" ")[2]);
}
#end_block

#method_before
private static void assertParse(StringBuilder authorizedKeys, List<Optional<AccountSshKey>> expectedKeys) {
    Account.Id accountId = new Account.Id(1);
    List<Optional<AccountSshKey>> parsedKeys = AuthorizedKeys.parse(accountId, authorizedKeys.toString());
    assertThat(parsedKeys).containsExactlyElementsIn(expectedKeys);
    int seq = 1;
    for (Optional<AccountSshKey> sshKey : parsedKeys) {
        if (sshKey.isPresent()) {
            assertThat(sshKey.get().account()).isEqualTo(accountId);
            assertThat(sshKey.get().id().get()).isEqualTo(seq);
        }
        seq++;
    }
}
#method_after
private static void assertParse(StringBuilder authorizedKeys, List<Optional<AccountSshKey>> expectedKeys) {
    Account.Id accountId = new Account.Id(1);
    List<Optional<AccountSshKey>> parsedKeys = AuthorizedKeys.parse(accountId, authorizedKeys.toString());
    assertThat(parsedKeys).containsExactlyElementsIn(expectedKeys);
    int seq = 1;
    for (Optional<AccountSshKey> sshKey : parsedKeys) {
        if (sshKey.isPresent()) {
            assertThat(sshKey.get().accountId()).isEqualTo(accountId);
            assertThat(sshKey.get().seq()).isEqualTo(seq);
        }
        seq++;
    }
}
#end_block

#method_before
private static String addKey(List<Optional<AccountSshKey>> keys, String pub) {
    AccountSshKey.Id keyId = new AccountSshKey.Id(new Account.Id(1), keys.size() + 1);
    AccountSshKey key = AccountSshKey.create(keyId, pub);
    keys.add(Optional.of(key));
    return key.sshPublicKey() + "\n";
}
#method_after
private static String addKey(List<Optional<AccountSshKey>> keys, String pub) {
    AccountSshKey key = AccountSshKey.create(new Account.Id(1), keys.size() + 1, pub);
    keys.add(Optional.of(key));
    return key.sshPublicKey() + "\n";
}
#end_block

#method_before
private static String addInvalidKey(List<Optional<AccountSshKey>> keys, String pub) {
    AccountSshKey.Id keyId = new AccountSshKey.Id(new Account.Id(1), keys.size() + 1);
    AccountSshKey key = AccountSshKey.createInvalid(keyId, pub);
    keys.add(Optional.of(key));
    return AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX + key.sshPublicKey() + "\n";
}
#method_after
private static String addInvalidKey(List<Optional<AccountSshKey>> keys, String pub) {
    AccountSshKey key = AccountSshKey.createInvalid(new Account.Id(1), keys.size() + 1, pub);
    keys.add(Optional.of(key));
    return AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX + key.sshPublicKey() + "\n";
}
#end_block

#method_before
private AccountSshKey createSshKey(Account.Id id, String keyFile) throws IOException {
    Path p = Paths.get(keyFile);
    if (!Files.exists(p)) {
        throw new IOException(String.format("Cannot add public SSH key: %s is not a file", keyFile));
    }
    String content = new String(Files.readAllBytes(p), UTF_8);
    return AccountSshKey.create(new AccountSshKey.Id(id, 1), content);
}
#method_after
private AccountSshKey createSshKey(Account.Id id, String keyFile) throws IOException {
    Path p = Paths.get(keyFile);
    if (!Files.exists(p)) {
        throw new IOException(String.format("Cannot add public SSH key: %s is not a file", keyFile));
    }
    String content = new String(Files.readAllBytes(p), UTF_8);
    return AccountSshKey.create(id, 1, content);
}
#end_block

#method_before
public static AccountSshKey create(AccountSshKey.Id id, String sshPublicKey, boolean valid) {
    return new AutoValue_AccountSshKey.Builder().setId(id).setSshPublicKey(stripOffNewLines(sshPublicKey)).setValid(valid && id.isValid()).build();
}
#method_after
public static AccountSshKey create(Account.Id accountId, int seq, String sshPublicKey) {
    return create(accountId, seq, sshPublicKey, true);
}
#end_block

#method_before
public static AccountSshKey createInvalid(AccountSshKey key) {
    return create(key.id(), key.sshPublicKey(), false);
}
#method_after
public static AccountSshKey createInvalid(Account.Id accountId, int seq, String sshPublicKey) {
    return create(accountId, seq, sshPublicKey, false);
}
#end_block

#method_before
public static AccountSshKey createInvalid(AccountSshKey key) {
    return create(key.id(), key.sshPublicKey(), false);
}
#method_after
public static AccountSshKey createInvalid(AccountSshKey key) {
    return create(key.accountId(), key.seq(), key.sshPublicKey(), false);
}
#end_block

#method_before
private String publicKeyPart(int index, String defaultValue) {
    String s = sshPublicKey();
    if (s != null && s.length() > 0) {
        String[] parts = s.split(" ");
        if (parts.length > index) {
            return parts[index];
        }
    }
    return defaultValue;
}
#method_after
private String publicKeyPart(int index, String defaultValue) {
    String s = sshPublicKey();
    if (s != null && s.length() > 0) {
        List<String> parts = Splitter.on(' ').splitToList(s);
        if (parts.size() > index) {
            return parts.get(index);
        }
    }
    return defaultValue;
}
#end_block

#method_before
@Override
public AccountSshKey create(Id id, String encoded) {
    return AccountSshKey.create(id, encoded);
}
#method_after
@Override
public AccountSshKey create(Account.Id accountId, int seq, String encoded) {
    return AccountSshKey.create(accountId, seq, encoded);
}
#end_block

#method_before
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    for (Optional<AccountSshKey> key : keys) {
        if (key.isPresent() && key.get().sshPublicKey().trim().equals(pub.trim())) {
            return key.get();
        }
    }
    int seq = keys.size() + 1;
    AccountSshKey.Id keyId = new AccountSshKey.Id(accountId, seq);
    AccountSshKey key = sshKeyCreator.create(keyId, pub);
    keys.add(Optional.of(key));
    return key;
}
#method_after
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    for (Optional<AccountSshKey> key : keys) {
        if (key.isPresent() && key.get().sshPublicKey().trim().equals(pub.trim())) {
            return key.get();
        }
    }
    int seq = keys.size() + 1;
    AccountSshKey key = sshKeyCreator.create(accountId, seq, pub);
    keys.add(Optional.of(key));
    return key;
}
#end_block

#method_before
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    if (key.isPresent() && key.get().valid()) {
        keys.add(seq - 1, Optional.of(AccountSshKey.createInvalid(key.get())));
        return true;
    }
    return false;
}
#method_after
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    if (key.isPresent() && key.get().valid()) {
        keys.set(seq - 1, Optional.of(AccountSshKey.createInvalid(key.get())));
        return true;
    }
    return false;
}
#end_block

#method_before
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.from(comparing(k -> k.id().get()));
    keys = new ArrayList<>(Collections.nCopies(o.max(newKeys).id().get(), Optional.empty()));
    for (AccountSshKey key : newKeys) {
        keys.set(key.id().get() - 1, Optional.of(key));
    }
}
#method_after
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.from(comparing(k -> k.seq()));
    keys = new ArrayList<>(Collections.nCopies(o.max(newKeys).seq(), Optional.empty()));
    for (AccountSshKey key : newKeys) {
        keys.set(key.seq() - 1, Optional.of(key));
    }
}
#end_block

#method_before
@Override
public AccountSshKey create(AccountSshKey.Id id, String encoded) throws InvalidSshKeyException {
    try {
        AccountSshKey key = AccountSshKey.create(id, SshUtil.toOpenSshPublicKey(encoded));
        SshUtil.parse(key);
        return key;
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        throw new InvalidSshKeyException();
    } catch (NoSuchProviderException e) {
        log.error("Cannot parse SSH key", e);
        throw new InvalidSshKeyException();
    }
}
#method_after
@Override
public AccountSshKey create(Account.Id accountId, int seq, String encoded) throws InvalidSshKeyException {
    try {
        AccountSshKey key = AccountSshKey.create(accountId, seq, SshUtil.toOpenSshPublicKey(encoded));
        SshUtil.parse(key);
        return key;
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        throw new InvalidSshKeyException();
    } catch (NoSuchProviderException e) {
        log.error("Cannot parse SSH key", e);
        throw new InvalidSshKeyException();
    }
}
#end_block

#method_before
public static List<Optional<AccountSshKey>> parse(Account.Id accountId, String s) {
    List<Optional<AccountSshKey>> keys = new ArrayList<>();
    int seq = 1;
    for (String line : s.split("\\r?\\n")) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT_PREFIX)) {
            String pub = line.substring(INVALID_KEY_COMMENT_PREFIX.length());
            AccountSshKey key = AccountSshKey.createInvalid(new AccountSshKey.Id(accountId, seq++), pub);
            keys.add(Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.add(Optional.empty());
            seq++;
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = AccountSshKey.create(new AccountSshKey.Id(accountId, seq++), line);
            keys.add(Optional.of(key));
        }
    }
    return keys;
}
#method_after
public static List<Optional<AccountSshKey>> parse(Account.Id accountId, String s) {
    List<Optional<AccountSshKey>> keys = new ArrayList<>();
    int seq = 1;
    for (String line : Splitter.on(LINE_SPLIT_PATTERN).split(s)) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT_PREFIX)) {
            String pub = line.substring(INVALID_KEY_COMMENT_PREFIX.length());
            AccountSshKey key = AccountSshKey.createInvalid(accountId, seq++, pub);
            keys.add(Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.add(Optional.empty());
            seq++;
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = AccountSshKey.create(accountId, seq++, line);
            keys.add(Optional.of(key));
        }
    }
    return keys;
}
#end_block

#method_before
@Test
@UseSsh
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    accountIndexedCounter.assertNoReindex();
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertNoReindex();
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
    // Mark first key as invalid
    authorizedKeys.markKeyInvalid(admin.id, 1);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(0).valid).isFalse();
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
}
#method_after
@Test
@UseSsh
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    accountIndexedCounter.assertNoReindex();
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertNoReindex();
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
    // Mark first key as invalid
    assertThat(info.get(0).valid).isTrue();
    authorizedKeys.markKeyInvalid(admin.id, 1);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(0).valid).isFalse();
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
}
#end_block

#method_before
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#method_after
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    // %2C is comma; the value below tests that percent decoding happens after splitting.
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test%20message%2Cm=");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message,m=");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    // %2C is comma; the value below tests that percent decoding happens after splitting.
    // All three ways of representing space ("%20", "+", and "_" are also exercised.
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test%20+_message%2Cm=");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), ALL_REVISIONS);
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test   message,m=");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithPercentEncodedMessage() throws Exception {
    // Exercise percent-encoding of UTF-8, underscores, and patterns reserved by git-rev-parse.
    PushOneCommit.Result r = pushTo("refs/for/master/%m=Punctu%2E%2e%2Eation%40%7Bu%7D%20%7C%20%28%E2%95%AF%C2%B0%E2%96" + "%A1%C2%B0%EF%BC%89%E2%95%AF%EF%B8%B5+%E2%94%BB%E2%94%81%E2%94%BB%20%5E%5F%5E");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nPunctu...ation@{u} | (╯°□°）╯︵ ┻━┻ ^_^");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("Punctu...ation@{u} | (╯°□°）╯︵ ┻━┻ ^_^");
    }
}
#method_after
@Test
public void pushForMasterWithPercentEncodedMessage() throws Exception {
    // Exercise percent-encoding of UTF-8, underscores, and patterns reserved by git-rev-parse.
    PushOneCommit.Result r = pushTo("refs/for/master/%m=" + "Punctu%2E%2e%2Eation%7E%2D%40%7Bu%7D%20%7C%20%28%E2%95%AF%C2%B0%E2%96%A1%C2%B0" + "%EF%BC%89%E2%95%AF%EF%B8%B5%20%E2%94%BB%E2%94%81%E2%94%BB%20%5E%5F%5E");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nPunctu...ation~-@{u} | (╯°□°）╯︵ ┻━┻ ^_^");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("Punctu...ation~-@{u} | (╯°□°）╯︵ ┻━┻ ^_^");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithInvalidPercentEncodedMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=not_percent_decodable_%%oops%20");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nnot percent decodable %%oops%20");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("not percent decodable %%oops%20");
    }
}
#method_after
@Test
public void pushForMasterWithInvalidPercentEncodedMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=not_percent_decodable_%%oops%20");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nnot percent decodable %%oops%20");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("not percent decodable %%oops%20");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#method_after
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id, CURRENT_REVISION);
    ChangeInfo c2 = get(changes.get(1).id, CURRENT_REVISION);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#end_block

#method_before
void init() {
    for (ReceivePackInitializer i : initializers) {
        i.init(projectControl.getProject().getNameKey(), rp);
    }
}
#method_after
void init() {
    for (ReceivePackInitializer i : initializers) {
        i.init(projectState.getNameKey(), rp);
    }
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO(xchangcheng): remove after migrating tools which are using this magic branch.
    if (magicBranch != null && magicBranch.publish) {
        addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead.");
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            try {
                permissions.check(ProjectPermission.WRITE_CONFIG);
            } catch (AuthException e) {
                reject(cmd, String.format("must be either project owner or have %s permission", ProjectPermission.WRITE_CONFIG.describeForException()));
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectState.getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectState.getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectState)) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException, NoSuchProjectException, IOException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    Branch.NameKey branch = new Branch.NameKey(project.getName(), cmd.getRefName());
    try {
        createRefControl.checkCreateRef(rp.getRepository(), branch, obj);
    } catch (AuthException denied) {
        reject(cmd, "prohibited by Gerrit: " + denied.getMessage());
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
    actualCommands.add(cmd);
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException, NoSuchProjectException, IOException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    Branch.NameKey branch = new Branch.NameKey(project.getName(), cmd.getRefName());
    try {
        // Must pass explicit user instead of injecting a provider into CreateRefControl, since
        // Provider<CurrentUser> within ReceiveCommits will always return anonymous.
        createRefControl.checkCreateRef(Providers.of(user), rp.getRepository(), branch, obj);
    } catch (AuthException denied) {
        reject(cmd, "prohibited by Gerrit: " + denied.getMessage());
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
    actualCommands.add(cmd);
}
#end_block

#method_before
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // Many characters have special meaning in the context of a git ref.
    // 
    // Clients can use underscores to represent spaces.
    message = token.replace("_", " ");
    try {
        // Other characters can be represented using percent-encoding.
        message = URLDecoder.decode(message, UTF_8.name());
    } catch (Exception e) {
    // Ignore decoding errors; leave message as percent-encoded.
    }
}
#method_after
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // Many characters have special meaning in the context of a git ref.
    // 
    // Clients can use underscores to represent spaces.
    message = token.replace("_", " ");
    try {
        // Other characters can be represented using percent-encoding.
        message = URLDecoder.decode(message, UTF_8.name());
    } catch (IllegalArgumentException e) {
    // Ignore decoding errors; leave message as percent-encoded.
    } catch (UnsupportedEncodingException e) {
        // This shouldn't happen; surely URLDecoder recognizes UTF-8.
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER));
    magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC));
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    if (!projectControl.getProject().getState().permitsWrite()) {
        reject(cmd, "project state does not permit write");
        return;
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(ReceiveError.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.dest.get());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER));
    magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC));
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    if (!projectState.getProject().getState().permitsWrite()) {
        reject(cmd, "project state does not permit write");
        return;
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(ReceiveError.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.dest.get());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && (magicBranch.edit || magicBranch.draft)) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && (magicBranch.edit || magicBranch.draft)) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectState, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Override
public List<String> queryChangeEvents(String query) throws EventsLogException {
    if (!online) {
        throw new ServiceUnavailableException();
    }
    List<SQLEntry> entries = new ArrayList<>();
    for (Entry<String, Collection<SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) {
        String projectName = entry.getKey();
        try {
            permissionBackend.user(userProvider.get()).project(new Project.NameKey(projectName)).check(ProjectPermission.ACCESS);
            entries.addAll(entry.getValue());
        } catch (AuthException e) {
        // Ignore
        } catch (PermissionBackendException e) {
            log.warn("Cannot check project access permission", e);
        }
    }
    return sortedEventsFromEntries(entries);
}
#method_after
@Override
public List<String> queryChangeEvents(String query) throws EventsLogException {
    if (!online) {
        throw new ServiceUnavailableException();
    }
    List<SQLEntry> entries = new ArrayList<>();
    for (Entry<String, Collection<SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) {
        String projectName = entry.getKey();
        try {
            permissionBackend.currentUser().project(new Project.NameKey(projectName)).check(ProjectPermission.ACCESS);
            entries.addAll(entry.getValue());
        } catch (AuthException e) {
        // Ignore
        } catch (PermissionBackendException e) {
            log.warn("Cannot check project access permission", e);
        }
    }
    return sortedEventsFromEntries(entries);
}
#end_block

#method_before
@Test
public void storeThenQueryVisible() throws Exception {
    when(permissionBackendMock.user(userProviderMock.get())).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doNothing().when(forProjectMock).check(ProjectPermission.ACCESS);
    setUpClient();
    store.storeEvent(mockEvent);
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    String json = new Gson().toJson(mockEvent);
    assertThat(events).containsExactly(json);
}
#method_after
@Test
public void storeThenQueryVisible() throws Exception {
    when(permissionBackendMock.currentUser()).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doNothing().when(forProjectMock).check(ProjectPermission.ACCESS);
    setUpClient();
    store.storeEvent(mockEvent);
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    String json = new Gson().toJson(mockEvent);
    assertThat(events).containsExactly(json);
}
#end_block

#method_before
@Test
public void storeThenQueryNotVisible() throws Exception {
    when(permissionBackendMock.user(userProviderMock.get())).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doThrow(new PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS);
    setUpClient();
    store.storeEvent(mockEvent);
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    assertThat(events).isEmpty();
}
#method_after
@Test
public void storeThenQueryNotVisible() throws Exception {
    when(permissionBackendMock.currentUser()).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doThrow(new PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS);
    setUpClient();
    store.storeEvent(mockEvent);
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    assertThat(events).isEmpty();
}
#end_block

#method_before
@Test
public void notReturnEventWithNoVisibilityInfo() throws Exception {
    when(permissionBackendMock.user(userProviderMock.get())).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doThrow(new PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS);
    setUpClient();
    store.storeEvent(mockEvent);
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    assertThat(events).isEmpty();
}
#method_after
@Test
public void notReturnEventWithNoVisibilityInfo() throws Exception {
    when(permissionBackendMock.currentUser()).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doThrow(new PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS);
    setUpClient();
    store.storeEvent(mockEvent);
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    assertThat(events).isEmpty();
}
#end_block

#method_before
@Test
public void retryOnConnectException() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(3);
    Throwable[] exceptions = new Throwable[3];
    Arrays.fill(exceptions, new SQLException(new ConnectException()));
    setUpClientMock();
    doThrow(exceptions).doNothing().when(eventsDb).storeEvent(mockEvent);
    doThrow(exceptions).doNothing().when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(3)).storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#method_after
@Test
public void retryOnConnectException() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(3);
    Throwable[] exceptions = new Throwable[3];
    Arrays.fill(exceptions, new SQLException(new ConnectException()));
    setUpClientMock();
    doThrow(exceptions).doNothing().when(eventsDb).storeEvent(mockEvent);
    doThrow(exceptions).doNothing().when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(3)).storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#end_block

#method_before
@Test
public void retryOnMessage() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(3);
    Throwable[] exceptions = new Throwable[3];
    Arrays.fill(exceptions, new SQLException(TERM_CONN_MSG));
    setUpClientMock();
    doThrow(exceptions).doNothing().when(eventsDb).storeEvent(mockEvent);
    doThrow(exceptions).doNothing().when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(3)).storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#method_after
@Test
public void retryOnMessage() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(3);
    Throwable[] exceptions = new Throwable[3];
    Arrays.fill(exceptions, new SQLException(TERM_CONN_MSG));
    setUpClientMock();
    doThrow(exceptions).doNothing().when(eventsDb).storeEvent(mockEvent);
    doThrow(exceptions).doNothing().when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(3)).storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#end_block

#method_before
@Test
public void noRetryOnMessage() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(3);
    setUpClientMock();
    doThrow(new SQLException(MSG)).when(eventsDb).storeEvent(mockEvent);
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(1)).storeEvent(mockEvent);
}
#method_after
@Test
public void noRetryOnMessage() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(3);
    setUpClientMock();
    doThrow(new SQLException(MSG)).when(eventsDb).storeEvent(mockEvent);
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(1)).storeEvent(mockEvent);
}
#end_block

#method_before
@Test
public void noRetryOnZeroMaxTries() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(0);
    Throwable[] exceptions = new Throwable[3];
    Arrays.fill(exceptions, new SQLException(new ConnectException()));
    setUpClientMock();
    doThrow(exceptions).doNothing().when(eventsDb).storeEvent(mockEvent);
    doThrow(exceptions).doNothing().when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(1)).storeEvent(mockEvent);
}
#method_after
@Test
public void noRetryOnZeroMaxTries() throws Exception {
    when(cfgMock.getMaxTries()).thenReturn(0);
    Throwable[] exceptions = new Throwable[3];
    Arrays.fill(exceptions, new SQLException(new ConnectException()));
    setUpClientMock();
    doThrow(exceptions).doNothing().when(eventsDb).storeEvent(mockEvent);
    doThrow(exceptions).doNothing().when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(eventsDb, times(1)).storeEvent(mockEvent);
}
#end_block

#method_before
@Test(expected = ServiceUnavailableException.class)
public void throwSQLExceptionIfNotOnline() throws Exception {
    setUpClientMock();
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    store.queryChangeEvents(GENERIC_QUERY);
}
#method_after
@Test(expected = ServiceUnavailableException.class)
public void throwSQLExceptionIfNotOnline() throws Exception {
    setUpClientMock();
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    store.queryChangeEvents(GENERIC_QUERY);
}
#end_block

#method_before
@Test
public void restoreEventsFromLocalDb() throws Exception {
    MockEvent mockEvent = new MockEvent();
    MockEvent mockEvent2 = new MockEvent("proj");
    when(permissionBackendMock.user(userProviderMock.get())).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doNothing().when(forProjectMock).check(ProjectPermission.ACCESS);
    eventsDb = new SQLClient(TEST_DRIVER, TEST_URL, TEST_OPTIONS);
    localEventsDb = new SQLClient(TEST_DRIVER, TEST_LOCAL_URL, TEST_OPTIONS);
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    localEventsDb.createDBIfNotCreated();
    localEventsDb.storeEvent(mockEvent);
    localEventsDb.storeEvent(mockEvent2);
    store.start();
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    Gson gson = new Gson();
    String json = gson.toJson(mockEvent);
    String json2 = gson.toJson(mockEvent2);
    assertThat(events).containsExactly(json, json2);
}
#method_after
@Test
public void restoreEventsFromLocalDb() throws Exception {
    MockEvent mockEvent = new MockEvent();
    MockEvent mockEvent2 = new MockEvent("proj");
    when(permissionBackendMock.currentUser()).thenReturn(withUserMock);
    when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock);
    doNothing().when(forProjectMock).check(ProjectPermission.ACCESS);
    eventsDb = new SQLClient(TEST_DRIVER, TEST_URL, TEST_OPTIONS);
    localEventsDb = new SQLClient(TEST_DRIVER, TEST_LOCAL_URL, TEST_OPTIONS);
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    localEventsDb.createDBIfNotCreated();
    localEventsDb.storeEvent(mockEvent);
    localEventsDb.storeEvent(mockEvent2);
    store.start();
    List<String> events = store.queryChangeEvents(GENERIC_QUERY);
    Gson gson = new Gson();
    String json = gson.toJson(mockEvent);
    String json2 = gson.toJson(mockEvent2);
    assertThat(events).containsExactly(json, json2);
}
#end_block

#method_before
@Test
public void offlineUponStart() throws Exception {
    setUpClientMock();
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    verify(localEventsDb).createDBIfNotCreated();
}
#method_after
@Test
public void offlineUponStart() throws Exception {
    setUpClientMock();
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    verify(localEventsDb).createDBIfNotCreated();
}
#end_block

#method_before
@Test
public void storeLocalOffline() throws Exception {
    setUpClientMock();
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#method_after
@Test
public void storeLocalOffline() throws Exception {
    setUpClientMock();
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#end_block

#method_before
@Test
public void storeLocalOfflineAfterNoRetry() throws Exception {
    setUpClientMock();
    when(cfgMock.getMaxTries()).thenReturn(0);
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#method_after
@Test
public void storeLocalOfflineAfterNoRetry() throws Exception {
    setUpClientMock();
    when(cfgMock.getMaxTries()).thenReturn(0);
    doThrow(new SQLException(new ConnectException())).when(eventsDb).createDBIfNotCreated();
    doThrow(new SQLException()).when(eventsDb).queryOne();
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    store.storeEvent(mockEvent);
    verify(localEventsDb).storeEvent(mockEvent);
}
#end_block

#method_before
private void setUpClient() {
    eventsDb = new SQLClient(TEST_DRIVER, TEST_URL, TEST_OPTIONS);
    localEventsDb = new SQLClient(TEST_DRIVER, TEST_LOCAL_URL, TEST_OPTIONS);
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
}
#method_after
private void setUpClient() {
    eventsDb = new SQLClient(TEST_DRIVER, TEST_URL, TEST_OPTIONS);
    localEventsDb = new SQLClient(TEST_DRIVER, TEST_LOCAL_URL, TEST_OPTIONS);
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
}
#end_block

#method_before
@Test
public void testConnectionTask() throws Exception {
    eventsDb = new SQLClient(TEST_DRIVER, TEST_URL, TEST_OPTIONS);
    localEventsDb = mock(SQLClient.class);
    when(localEventsDb.dbExists()).thenReturn(true);
    when(localEventsDb.getAll()).thenReturn(ImmutableList.of(mock(SQLEntry.class)));
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    poolMock.scheduleWithFixedDelay(store.new CheckConnectionTask(), 0, 0, TimeUnit.MILLISECONDS);
    verify(localEventsDb, times(2)).removeOldEvents(0);
}
#method_after
@Test
public void testConnectionTask() throws Exception {
    eventsDb = new SQLClient(TEST_DRIVER, TEST_URL, TEST_OPTIONS);
    localEventsDb = mock(SQLClient.class);
    when(localEventsDb.dbExists()).thenReturn(true);
    when(localEventsDb.getAll()).thenReturn(ImmutableList.of(mock(SQLEntry.class)));
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    poolMock.scheduleWithFixedDelay(store.new CheckConnectionTask(), 0, 0, TimeUnit.MILLISECONDS);
    verify(localEventsDb, times(2)).removeOldEvents(0);
}
#end_block

#method_before
private void checkConnectionAndRestore(boolean copy) throws Exception {
    eventsDb = mock(SQLClient.class);
    localEventsDb = new SQLClient(TEST_DRIVER, TEST_LOCAL_URL, TEST_OPTIONS);
    localEventsDb.createDBIfNotCreated();
    localEventsDb.storeEvent(mockEvent);
    doThrow(new SQLException(new ConnectException())).doNothing().when(eventsDb).createDBIfNotCreated();
    if (copy) {
        when(cfgMock.getCopyLocal()).thenReturn(true);
    }
    store = new SQLStore(userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    verify(eventsDb).queryOne();
    verify(eventsDb).storeEvent(any(String.class), any(Timestamp.class), any(String.class));
    List<SQLEntry> entries = localEventsDb.getAll();
    assertThat(entries).isEmpty();
}
#method_after
private void checkConnectionAndRestore(boolean copy) throws Exception {
    eventsDb = mock(SQLClient.class);
    localEventsDb = new SQLClient(TEST_DRIVER, TEST_LOCAL_URL, TEST_OPTIONS);
    localEventsDb.createDBIfNotCreated();
    localEventsDb.storeEvent(mockEvent);
    doThrow(new SQLException(new ConnectException())).doNothing().when(eventsDb).createDBIfNotCreated();
    if (copy) {
        when(cfgMock.getCopyLocal()).thenReturn(true);
    }
    store = new SQLStore(cfgMock, eventsDb, localEventsDb, poolMock, permissionBackendMock);
    store.start();
    verify(eventsDb).queryOne();
    verify(eventsDb).storeEvent(any(String.class), any(Timestamp.class), any(String.class));
    List<SQLEntry> entries = localEventsDb.getAll();
    assertThat(entries).isEmpty();
}
#end_block

#method_before
@Override
protected boolean isVisibleTo(Account.Id to) throws PermissionBackendException {
    return projectState.statePermitsRead() && args.permissionBackend.absentUser(to).change(changeData).database(args.db.get()).test(ChangePermission.READ);
}
#method_after
@Override
protected boolean isVisibleTo(Account.Id to) throws PermissionBackendException {
    return projectState.statePermitsRead() && args.permissionBackend.absentUser(to).change(changeData).database(args.db).test(ChangePermission.READ);
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (versionManager.isKnownIndex(name)) {
            if (versionManager.activateLatestIndex(name)) {
                stdout.println("Activated latest index version");
            } else {
                stdout.println("Not activating index, already using latest version");
            }
        } else {
            stdout.println("Cannot activate index, unknown based on this name");
        }
    } catch (ReindexerAlreadyRunningException e) {
        throw die("Failed to activate latest index: " + e.getMessage());
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (versionManager.isKnownIndex(name)) {
            if (versionManager.activateLatestIndex(name)) {
                stdout.println("Activated latest index version");
            } else {
                stdout.println("Not activating index, already using latest version");
            }
        } else {
            stderr.println("Cannot activate index, unknown based on this name");
        }
    } catch (ReindexerAlreadyRunningException e) {
        throw die("Failed to activate latest index: " + e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (versionManager.isKnownIndex(name)) {
            if (versionManager.startReindexer(name, force)) {
                stdout.println("Reindexer started");
            } else {
                stdout.println("Nothing to reindex, index is already the latest version");
            }
        } else {
            stdout.println("Cannot reindex, index is unknown based on this name");
        }
    } catch (ReindexerAlreadyRunningException e) {
        throw die("Failed to start reindexer: " + e.getMessage());
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (versionManager.isKnownIndex(name)) {
            if (versionManager.startReindexer(name, force)) {
                stdout.println("Reindexer started");
            } else {
                stdout.println("Nothing to reindex, index is already the latest version");
            }
        } else {
            stderr.println("Cannot reindex, index is unknown based on this name");
        }
    } catch (ReindexerAlreadyRunningException e) {
        throw die("Failed to start reindexer: " + e.getMessage());
    }
}
#end_block

#method_before
private void assertCanEdit(ChangeNotes notes) throws AuthException, PermissionBackendException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = notes.getChange();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException(String.format("change %s is %s", change.getChangeId(), change.getStatus()));
    }
    try {
        permissionBackend.currentUser().database(reviewDb).change(notes).check(ChangePermission.ADD_PATCH_SET);
        projectCache.checkedGet(notes.getProjectName()).checkStatePermitsWrite();
    } catch (AuthException denied) {
        throw new AuthException("edit not permitted", denied);
    }
}
#method_after
private void assertCanEdit(ChangeNotes notes) throws AuthException, PermissionBackendException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change c = notes.getChange();
    if (!c.getStatus().isOpen()) {
        throw new ResourceConflictException(String.format("change %s is %s", c.getChangeId(), c.getStatus().toString().toLowerCase()));
    }
    try {
        permissionBackend.currentUser().database(reviewDb).change(notes).check(ChangePermission.ADD_PATCH_SET);
        projectCache.checkedGet(notes.getProjectName()).checkStatePermitsWrite();
    } catch (AuthException denied) {
        throw new AuthException("edit not permitted", denied);
    }
}
#end_block

#method_before
@Test
public void editCannotBeCreatedOnMergedChange() throws Exception {
    ChangeInfo change = gApi.changes().id(changeId).get();
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    gApi.changes().id(changeId).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("change %s is MERGED", change._number));
    createArbitraryEditFor(changeId);
}
#method_after
@Test
public void editCannotBeCreatedOnMergedChange() throws Exception {
    ChangeInfo change = gApi.changes().id(changeId).get();
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    gApi.changes().id(changeId).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("change %s is merged", change._number));
    createArbitraryEditFor(changeId);
}
#end_block

#method_before
@Test
public void editCannotBeCreatedOnAbandonedChange() throws Exception {
    ChangeInfo change = gApi.changes().id(changeId).get();
    gApi.changes().id(changeId).abandon();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("change %s is ABANDONED", change._number));
    createArbitraryEditFor(changeId);
}
#method_after
@Test
public void editCannotBeCreatedOnAbandonedChange() throws Exception {
    ChangeInfo change = gApi.changes().id(changeId).get();
    gApi.changes().id(changeId).abandon();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("change %s is abandoned", change._number));
    createArbitraryEditFor(changeId);
}
#end_block

#method_before
private void validateNewCommits(Branch.NameKey branch, ReceiveCommand cmd) throws PermissionBackendException {
    PermissionBackend.ForRef perm = permissions.ref(branch.get());
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET_PATTERN.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(PUSH_OPTION_SKIP_VALIDATION)) {
        try {
            if (projectState.is(BooleanProjectConfig.USE_SIGNED_OFF_BY)) {
                throw new AuthException("signed_off_by is required by project " + projectState.getName());
            }
            perm.check(RefPermission.SKIP_VALIDATION);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + PUSH_OPTION_SKIP_VALIDATION);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean missingFullName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int limit = receiveConfig.maxBatchCommits;
        int n = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (++n > limit) {
                logDebug("Number of new commits exceeds limit of {}", limit);
                addMessage(String.format("Cannot push more than %d commits to %s without %s option " + "(see %sDocumentation/user-upload.html#skip_validation for details)", limit, branch.get(), PUSH_OPTION_SKIP_VALIDATION, canonicalWebUrl));
                reject(cmd, "too many commits");
                return;
            }
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, perm, branch, cmd, c, null)) {
                break;
            }
            if (missingFullName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                logDebug("Will update full name of caller");
                setFullNameTo = c.getCommitterIdent().getName();
                missingFullName = false;
            }
        }
        logDebug("Validated {} new commits", n);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(Branch.NameKey branch, ReceiveCommand cmd) throws PermissionBackendException {
    PermissionBackend.ForRef perm = permissions.ref(branch.get());
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET_PATTERN.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(PUSH_OPTION_SKIP_VALIDATION)) {
        try {
            if (projectState.is(BooleanProjectConfig.USE_SIGNED_OFF_BY)) {
                throw new AuthException("requireSignedOffBy prevents option " + PUSH_OPTION_SKIP_VALIDATION);
            }
            perm.check(RefPermission.SKIP_VALIDATION);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + PUSH_OPTION_SKIP_VALIDATION);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean missingFullName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int limit = receiveConfig.maxBatchCommits;
        int n = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (++n > limit) {
                logDebug("Number of new commits exceeds limit of {}", limit);
                addMessage(String.format("Cannot push more than %d commits to %s without %s option " + "(see %sDocumentation/user-upload.html#skip_validation for details)", limit, branch.get(), PUSH_OPTION_SKIP_VALIDATION, canonicalWebUrl));
                reject(cmd, "too many commits");
                return;
            }
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, perm, branch, cmd, c, null)) {
                break;
            }
            if (missingFullName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                logDebug("Will update full name of caller");
                setFullNameTo = c.getCommitterIdent().getName();
                missingFullName = false;
            }
        }
        logDebug("Validated {} new commits", n);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
static String getShortProjectName(String projectName) {
    int lastIndexSlash = projectName.lastIndexOf("/");
    if (lastIndexSlash == 0) {
        // Remove the first slash
        return projectName.substring(1);
    }
    return "..." + projectName.substring(lastIndexSlash + 1);
}
#method_after
@VisibleForTesting
protected static String getShortProjectName(String projectName) {
    int lastIndexSlash = projectName.lastIndexOf("/");
    if (lastIndexSlash == 0) {
        // Remove the first slash
        return projectName.substring(1);
    }
    return "..." + projectName.substring(lastIndexSlash + 1);
}
#end_block

#method_before
protected static String getInstanceAndProjectName(String instanceName, String projectName) {
    if (instanceName == null || instanceName.isEmpty()) {
        return projectName.replaceAll("/.*/", "...");
    }
    // instance name
    return instanceName + "/" + projectName.substring(projectName.lastIndexOf("/") + 1);
}
#method_after
@VisibleForTesting
protected static String getInstanceAndProjectName(String instanceName, String projectName) {
    if (instanceName == null || instanceName.isEmpty()) {
        return getShortProjectName(projectName);
    }
    // instance name
    return instanceName + "/" + projectName.substring(projectName.lastIndexOf("/") + 1);
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    QueryParams qp = null;
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        qp = ParameterParser.getQueryParams(req);
        checkCors(req, res, qp.hasXdOverride());
        if (qp.hasXdOverride()) {
            req = applyXdOverrides(req, qp);
        }
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        globals.permissionBackend.user(globals.currentUser.get()).checkAny(GlobalPermission.fromAnnotation(rc.getClass()));
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(qp.params());
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && isPost(req)) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && (isPost(req) || isPut(req))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && isPost(req)) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && isDelete(req)) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && (isPost(req) || isPut(req))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && isDelete(req)) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, qp.params(), req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            Type type = inputType(m);
            inputRequestBody = parseRequest(req, type);
            result = m.apply(rsrc, inputRequestBody);
            if (inputRequestBody instanceof RawInput) {
                consumeRawInputRequestBody(req, type);
            }
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, qp.config(), result);
            }
        }
    } catch (MalformedJsonException | JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (UpdateException e) {
        Throwable t = e.getCause();
        if (t instanceof LockFailureException) {
            responseBytes = replyError(req, res, status = SC_SERVICE_UNAVAILABLE, messageOr(t, "Lock failure"), e);
        } else {
            status = SC_INTERNAL_SERVER_ERROR;
            responseBytes = handleException(e, req, res);
        }
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, qp != null ? qp.params() : ImmutableListMultimap.of(), inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    QueryParams qp = null;
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        qp = ParameterParser.getQueryParams(req);
        checkCors(req, res, qp.hasXdOverride());
        if (qp.hasXdOverride()) {
            req = applyXdOverrides(req, qp);
        }
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        globals.permissionBackend.user(globals.currentUser.get()).checkAny(GlobalPermission.fromAnnotation(rc.getClass()));
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(qp.params());
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && isPost(req)) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && (isPost(req) || isPut(req))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && isPost(req)) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && isDelete(req)) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && (isPost(req) || isPut(req))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && isDelete(req)) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, qp.params(), req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            Type type = inputType(m);
            inputRequestBody = parseRequest(req, type);
            result = m.apply(rsrc, inputRequestBody);
            if (inputRequestBody instanceof RawInput) {
                try (InputStream is = req.getInputStream()) {
                    ServletUtils.consumeRequestBody(is);
                }
            }
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, qp.config(), result);
            }
        }
    } catch (MalformedJsonException | JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (UpdateException e) {
        Throwable t = e.getCause();
        if (t instanceof LockFailureException) {
            responseBytes = replyError(req, res, status = SC_SERVICE_UNAVAILABLE, messageOr(t, "Lock failure"), e);
        } else {
            status = SC_INTERNAL_SERVER_ERROR;
            responseBytes = handleException(e, req, res);
        }
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, qp != null ? qp.params() : ImmutableListMultimap.of(), inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    ListMultimap<String, String> params = MultimapBuilder.hashKeys().arrayListValues().build();
    ListMultimap<String, String> config = MultimapBuilder.hashKeys().arrayListValues().build();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        checkCors(req, res);
        checkUserSession(req);
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(params);
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    ListMultimap<String, String> params = MultimapBuilder.hashKeys().arrayListValues().build();
    ListMultimap<String, String> config = MultimapBuilder.hashKeys().arrayListValues().build();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        checkCors(req, res);
        checkUserSession(req);
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(params);
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            Type type = inputType(m);
            inputRequestBody = parseRequest(req, type);
            result = m.apply(rsrc, inputRequestBody);
            consumeRawInputRequestBody(req, type);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        try (BufferedReader br = req.getReader();
            JsonReader json = new JsonReader(br)) {
            json.setLenient(true);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        }
    } else if (("PUT".equals(req.getMethod()) || "POST".equals(req.getMethod())) && acceptsRawInput(type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        try (BufferedReader br = req.getReader()) {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    // 400). Consume the request body for all but raw input request types here.
    if (isType(JSON_TYPE, req.getContentType())) {
        try (BufferedReader br = req.getReader();
            JsonReader json = new JsonReader(br)) {
            try {
                json.setLenient(true);
                JsonToken first;
                try {
                    first = json.peek();
                } catch (EOFException e) {
                    throw new BadRequestException("Expected JSON object");
                }
                if (first == JsonToken.STRING) {
                    return parseString(json.nextString(), type);
                }
                return OutputFormat.JSON.newGson().fromJson(json, type);
            } finally {
                // Reader.close won't consume the rest of the input. Explicitly consume the request body.
                br.skip(Long.MAX_VALUE);
            }
        }
    } else if (rawInputRequest(req, type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        try (BufferedReader br = req.getReader()) {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
@SuppressWarnings("resource")
static long replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.getAttachmentName() != null) {
            res.setHeader("Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\"");
        }
        if (bin.isBase64()) {
            if (req != null && JSON_TYPE.equals(req.getHeader(HttpHeaders.ACCEPT))) {
                bin = stackJsonString(res, bin);
            } else {
                bin = stackBase64(res, bin);
            }
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        if (req != null) {
            req.getInputStream().skip(Long.MAX_VALUE);
        }
        if (req == null || !"HEAD".equals(req.getMethod())) {
            try (CountingOutputStream dst = new CountingOutputStream(res.getOutputStream())) {
                bin.writeTo(dst);
                return dst.getCount();
            }
        }
        return 0;
    } finally {
        appResult.close();
    }
}
#method_after
@SuppressWarnings("resource")
static long replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.getAttachmentName() != null) {
            res.setHeader("Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\"");
        }
        if (bin.isBase64()) {
            if (req != null && JSON_TYPE.equals(req.getHeader(HttpHeaders.ACCEPT))) {
                bin = stackJsonString(res, bin);
            } else {
                bin = stackBase64(res, bin);
            }
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        if (req == null || !"HEAD".equals(req.getMethod())) {
            try (CountingOutputStream dst = new CountingOutputStream(res.getOutputStream())) {
                bin.writeTo(dst);
                return dst.getCount();
            }
        }
        return 0;
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
@Nullable
public static Long getDuration(Config config, String section, String subsection, String name, @Nullable Long defaultValue) {
    long m = config.getTimeUnit(section, subsection, name, -1, MILLISECONDS);
    if (m != -1) {
        return m;
    }
    return defaultValue;
}
#method_after
@Nullable
public static Duration getDuration(Config config, String section, String subsection, String name, @Nullable Duration defaultValue) {
    long m = config.getTimeUnit(section, subsection, name, -1, MILLISECONDS);
    return m == -1 ? defaultValue : Duration.ofMillis(m);
}
#end_block

#method_before
public static CacheBuilder<Object, Object> getCacheBuilder(Config config, String name) {
    CacheBuilder<Object, Object> b = CacheBuilder.newBuilder();
    try {
        if (config.getString("cache", name, "maximumWeight") != null) {
            b.maximumWeight(config.getLong("cache", name, "maximumWeight", 20 << 20));
        }
        if (config.getString("cache", name, "maximumSize") != null) {
            b.maximumSize(config.getLong("cache", name, "maximumSize", 16384));
        }
        Long expireAfterWrite = getDuration(config, "cache", name, "expireAfterWrite", null);
        if (expireAfterWrite != null) {
            b.expireAfterWrite(expireAfterWrite, TimeUnit.MILLISECONDS);
        }
        Long expireAfterAccess = getDuration(config, "cache", name, "expireAfterAccess", null);
        if (expireAfterAccess != null) {
            b.expireAfterAccess(expireAfterAccess, TimeUnit.MILLISECONDS);
        }
    // Add other methods as needed.
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException("Error getting CacheBuilder for " + name, e);
    } catch (IllegalStateException e) {
        throw new IllegalStateException("Error getting CacheBuilder for " + name, e);
    }
    return b;
}
#method_after
public static CacheBuilder<Object, Object> getCacheBuilder(Config config, String name) {
    CacheBuilder<Object, Object> b = CacheBuilder.newBuilder();
    try {
        if (config.getString("cache", name, "maximumWeight") != null) {
            b.maximumWeight(config.getLong("cache", name, "maximumWeight", 20 << 20));
        }
        if (config.getString("cache", name, "maximumSize") != null) {
            b.maximumSize(config.getLong("cache", name, "maximumSize", 16384));
        }
        Duration expireAfterWrite = getDuration(config, "cache", name, "expireAfterWrite", null);
        if (expireAfterWrite != null) {
            b.expireAfterWrite(expireAfterWrite.toMillis(), TimeUnit.MILLISECONDS);
        }
        Duration expireAfterAccess = getDuration(config, "cache", name, "expireAfterAccess", null);
        if (expireAfterAccess != null) {
            b.expireAfterAccess(expireAfterAccess.toMillis(), TimeUnit.MILLISECONDS);
        }
    // Add other methods as needed.
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException("Error getting CacheBuilder for " + name, e);
    } catch (IllegalStateException e) {
        throw new IllegalStateException("Error getting CacheBuilder for " + name, e);
    }
    return b;
}
#end_block

#method_before
@Test
public void getDurationReturnsDuration() throws Exception {
    // 2 seconds
    Long def = 2 * 1000L;
    Config config = new Config();
    Long t;
    config.setString("core", "dht", "timeout", "500 ms");
    t = getDuration(config, "core", "dht", "timeout", def);
    assertThat(t).isEqualTo(500);
    config.setString("core", "dht", "timeout", "5.2 sec");
    try {
        getDuration(config, "core", "dht", "timeout", def);
        fail("expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
        assertThat(e).hasMessageThat().isEqualTo("Invalid time unit value: core.dht.timeout=5.2 sec");
    }
    config.setString("core", "dht", "timeout", "1 min");
    t = getDuration(config, "core", "dht", "timeout", def);
    assertThat(t).isEqualTo(60000);
}
#method_after
@Test
public void getDurationReturnsDuration() throws Exception {
    Duration def = Duration.ofSeconds(2);
    Config config = new Config();
    Duration t;
    config.setString("core", "dht", "timeout", "500 ms");
    t = getDuration(config, "core", "dht", "timeout", def);
    assertThat(t.toMillis()).isEqualTo(500);
    config.setString("core", "dht", "timeout", "5.2 sec");
    try {
        getDuration(config, "core", "dht", "timeout", def);
        fail("expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
        assertThat(e).hasMessageThat().isEqualTo("Invalid time unit value: core.dht.timeout=5.2 sec");
    }
    config.setString("core", "dht", "timeout", "1 min");
    t = getDuration(config, "core", "dht", "timeout", def);
    assertThat(t.toMillis()).isEqualTo(60000);
}
#end_block

#method_before
@Test
public void getDurationCanReturnDefault() throws Exception {
    // 1 second
    Long def = 1000L;
    Config config = new Config();
    Long t;
    t = getDuration(config, "core", null, "blank", def);
    assertThat(t).isEqualTo(1000);
    config.setString("core", null, "blank", "");
    t = getDuration(config, "core", null, "blank", def);
    assertThat(t).isEqualTo(1000);
    config.setString("core", null, "blank", " ");
    t = getDuration(config, "core", null, "blank", def);
    assertThat(t).isEqualTo(1000);
}
#method_after
@Test
public void getDurationCanReturnDefault() throws Exception {
    Duration def = Duration.ofSeconds(1);
    Config config = new Config();
    Duration t;
    t = getDuration(config, "core", null, "blank", def);
    assertThat(t.toMillis()).isEqualTo(1000);
    config.setString("core", null, "blank", "");
    t = getDuration(config, "core", null, "blank", def);
    assertThat(t.toMillis()).isEqualTo(1000);
    config.setString("core", null, "blank", " ");
    t = getDuration(config, "core", null, "blank", def);
    assertThat(t.toMillis()).isEqualTo(1000);
}
#end_block

#method_before
@Test
public void nullAsDefault() throws Exception {
    Config config = new Config();
    Long t;
    t = getDuration(config, "core", null, "blank", null);
    assertThat(t).isNull();
    config.setString("core", null, "blank", "");
    t = getDuration(config, "core", null, "blank", null);
    assertThat(t).isNull();
    config.setString("core", null, "blank", " ");
    t = getDuration(config, "core", null, "blank", null);
    assertThat(t).isNull();
}
#method_after
@Test
public void nullAsDefault() throws Exception {
    Config config = new Config();
    Duration t;
    t = getDuration(config, "core", null, "blank", null);
    assertThat(t).isNull();
    config.setString("core", null, "blank", "");
    t = getDuration(config, "core", null, "blank", null);
    assertThat(t).isNull();
    config.setString("core", null, "blank", " ");
    t = getDuration(config, "core", null, "blank", null);
    assertThat(t).isNull();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    gerritConfig = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.detect());
    // Unlike in the running server, for tests, we don't stack notedb.config on gerrit.config.
    noteDbConfig = new FileBasedConfig(sitePaths.notedb_config.toFile(), FS.detect());
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    gerritConfig = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.detect());
    // Unlike in the running server, for tests, we don't stack notedb.config on gerrit.config.
    noteDbConfig = new FileBasedConfig(sitePaths.notedb_config.toFile(), FS.detect());
    // Set gc.pruneExpire=now so GC prunes all unreachable objects from All-Users, which allows us
    // to reliably test that it behaves as expected.
    Path cfgPath = sitePaths.site_path.resolve("git").resolve("All-Users.git").resolve("config");
    assertWithMessage("Expected All-Users config at %s", cfgPath).that(Files.isRegularFile(cfgPath)).isTrue();
    FileBasedConfig cfg = new FileBasedConfig(cfgPath.toFile(), FS.detect());
    cfg.setString("gc", null, "pruneExpire", "now");
    cfg.save();
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    String email = "user@example.com";
    accountsUpdate.get().update("Add Email", userId, u -> u.addExternalId(ExternalId.createEmail(userId, email)).setPreferredEmail(email));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    String email = "user@example.com";
    accountsUpdate.get().update("Add Email", userId, u -> u.addExternalId(ExternalId.createEmail(userId, email)).setPreferredEmail(email));
    resetUser();
}
#end_block

#method_before
@Test
public void watched() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    TestRepository<Repo> repo2 = createProject("repo2");
    ChangeInserter ins2 = newChangeWithStatus(repo2, Change.Status.NEW);
    insert(repo2, ins2);
    assertQuery("is:watched");
    assertQuery("watchedby:self");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = "repo";
    pwi.filter = null;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    assertQuery("is:watched", change1);
    assertQuery("watchedby:self", change1);
}
#method_after
@Test
public void watched() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    TestRepository<Repo> repo2 = createProject("repo2");
    ChangeInserter ins2 = newChangeWithStatus(repo2, Change.Status.NEW);
    insert(repo2, ins2);
    assertQuery("is:watched");
    assertQuery("watchedby:self");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = "repo";
    pwi.filter = null;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    resetUser();
    assertQuery("is:watched", change1);
    assertQuery("watchedby:self", change1);
}
#end_block

#method_before
@Nullable
private ProjectResource _parse(String id, boolean checkAccess) throws IOException, PermissionBackendException, ResourceConflictException {
    if (id.endsWith(Constants.DOT_GIT_EXT)) {
        id = id.substring(0, id.length() - Constants.DOT_GIT_EXT.length());
    }
    Project.NameKey nameKey = new Project.NameKey(id);
    ProjectState state = projectCache.checkedGet(nameKey);
    if (state == null) {
        return null;
    }
    if (checkAccess) {
        ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
        try {
            permissionBackend.user(user).project(nameKey).check(permissionToCheck);
        } catch (AuthException e) {
            // Pretend like not found on access denied.
            return null;
        }
        // just serve as a safety net in case the individual check is forgotten.
        try {
            permissionBackend.user(user).project(nameKey).check(ProjectPermission.WRITE_CONFIG);
        } catch (AuthException e) {
            state.checkStatePermitsRead();
        }
    }
    return new ProjectResource(state, user.get());
}
#method_after
@Nullable
private ProjectResource _parse(String id, boolean checkAccess) throws IOException, PermissionBackendException, ResourceConflictException {
    if (id.endsWith(Constants.DOT_GIT_EXT)) {
        id = id.substring(0, id.length() - Constants.DOT_GIT_EXT.length());
    }
    Project.NameKey nameKey = new Project.NameKey(id);
    ProjectState state = projectCache.checkedGet(nameKey);
    if (state == null) {
        return null;
    }
    if (checkAccess) {
        // Hidden projects(permitsRead = false) should only be accessible by the project owners.
        // READ_CONFIG is checked here because it's only allowed to project owners(ACCESS may also
        // be allowed for other users). Allowing project owners to access here will help them to view
        // and update the config of hidden projects easily.
        ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
        try {
            permissionBackend.currentUser().project(nameKey).check(permissionToCheck);
        } catch (AuthException e) {
            // Pretend like not found on access denied.
            return null;
        }
        // just serve as a safety net in case the individual check is forgotten.
        try {
            permissionBackend.currentUser().project(nameKey).check(ProjectPermission.WRITE_CONFIG);
        } catch (AuthException e) {
            state.checkStatePermitsRead();
        }
    }
    return new ProjectResource(state, user.get());
}
#end_block

#method_before
@Override
public Repository open(HttpServletRequest req, String projectName) throws RepositoryNotFoundException, ServiceNotAuthorizedException, ServiceNotEnabledException, ServiceMayNotContinueException {
    while (projectName.endsWith("/")) {
        projectName = projectName.substring(0, projectName.length() - 1);
    }
    if (projectName.endsWith(".git")) {
        // Be nice and drop the trailing ".git" suffix, which we never keep
        // in our database, but clients might mistakenly provide anyway.
        // 
        projectName = projectName.substring(0, projectName.length() - 4);
        while (projectName.endsWith("/")) {
            projectName = projectName.substring(0, projectName.length() - 1);
        }
    }
    CurrentUser user = userProvider.get();
    user.setAccessPath(AccessPath.GIT);
    try {
        Project.NameKey nameKey = new Project.NameKey(projectName);
        ProjectState state = projectCache.checkedGet(nameKey);
        if (state == null) {
            throw new RepositoryNotFoundException(nameKey.get());
        }
        req.setAttribute(ATT_STATE, state);
        ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
        try {
            permissionBackend.user(user).project(nameKey).check(permissionToCheck);
        } catch (AuthException e) {
            if (user instanceof AnonymousUser) {
                throw new ServiceNotAuthorizedException();
            }
            throw new ServiceNotEnabledException(e.getMessage());
        }
        return manager.openRepository(nameKey);
    } catch (IOException | PermissionBackendException err) {
        throw new ServiceMayNotContinueException(projectName + " unavailable", err);
    }
}
#method_after
@Override
public Repository open(HttpServletRequest req, String projectName) throws RepositoryNotFoundException, ServiceNotAuthorizedException, ServiceNotEnabledException, ServiceMayNotContinueException {
    while (projectName.endsWith("/")) {
        projectName = projectName.substring(0, projectName.length() - 1);
    }
    if (projectName.endsWith(".git")) {
        // Be nice and drop the trailing ".git" suffix, which we never keep
        // in our database, but clients might mistakenly provide anyway.
        // 
        projectName = projectName.substring(0, projectName.length() - 4);
        while (projectName.endsWith("/")) {
            projectName = projectName.substring(0, projectName.length() - 1);
        }
    }
    CurrentUser user = userProvider.get();
    user.setAccessPath(AccessPath.GIT);
    try {
        Project.NameKey nameKey = new Project.NameKey(projectName);
        ProjectState state = projectCache.checkedGet(nameKey);
        if (state == null || !state.statePermitsRead()) {
            throw new RepositoryNotFoundException(nameKey.get());
        }
        req.setAttribute(ATT_STATE, state);
        try {
            permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS);
        } catch (AuthException e) {
            if (user instanceof AnonymousUser) {
                throw new ServiceNotAuthorizedException();
            }
            throw new ServiceNotEnabledException(e.getMessage());
        }
        return manager.openRepository(nameKey);
    } catch (IOException | PermissionBackendException err) {
        throw new ServiceMayNotContinueException(projectName + " unavailable", err);
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectState state = (ProjectState) request.getAttribute(ATT_STATE);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    PermissionBackend.ForProject perm = permissionBackend.user(userProvider).project(state.getNameKey());
    try {
        perm.check(ProjectPermission.RUN_UPLOAD_PACK);
    } catch (AuthException e) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    } catch (PermissionBackendException e) {
        throw new ServletException(e);
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(state.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    up.setAdvertiseRefsHook(new DefaultAdvertiseRefsHook(perm, RefFilterOptions.defaults()));
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectState state = (ProjectState) request.getAttribute(ATT_STATE);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    PermissionBackend.ForProject perm = permissionBackend.currentUser().project(state.getNameKey());
    try {
        perm.check(ProjectPermission.RUN_UPLOAD_PACK);
    } catch (AuthException e) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    } catch (PermissionBackendException e) {
        throw new ServletException(e);
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(state.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    up.setAdvertiseRefsHook(new DefaultAdvertiseRefsHook(perm, RefFilterOptions.defaults()));
    next.doFilter(request, response);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    AsyncReceiveCommits arc = (AsyncReceiveCommits) request.getAttribute(ATT_ARC);
    ReceivePack rp = arc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectState state = (ProjectState) request.getAttribute(ATT_STATE);
    Capable s;
    try {
        permissionBackend.user(userProvider).project(state.getNameKey()).check(ProjectPermission.RUN_RECEIVE_PACK);
        s = arc.canUpload();
    } catch (AuthException e) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    } catch (PermissionBackendException e) {
        throw new RuntimeException(e);
    }
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(userProvider.get().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = AdvertisedObjectsCacheKey.create(userProvider.get().getAccountId(), state.getNameKey());
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    AsyncReceiveCommits arc = (AsyncReceiveCommits) request.getAttribute(ATT_ARC);
    ReceivePack rp = arc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectState state = (ProjectState) request.getAttribute(ATT_STATE);
    Capable s;
    try {
        permissionBackend.currentUser().project(state.getNameKey()).check(ProjectPermission.RUN_RECEIVE_PACK);
        s = arc.canUpload();
    } catch (AuthException e) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    } catch (PermissionBackendException e) {
        throw new RuntimeException(e);
    }
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(userProvider.get().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = AdvertisedObjectsCacheKey.create(userProvider.get().getAccountId(), state.getNameKey());
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, PermissionBackendException, ResourceConflictException {
    ProjectState projectState = checkProjectState();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = checkProjectState();
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = checkProjectState();
        }
    }
    // The following implementation must match the GetAccess REST API endpoint.
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteProjectConfig = true;
    try {
        perm.check(ProjectPermission.WRITE_CONFIG);
    } catch (AuthException e) {
        canWriteProjectConfig = false;
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteProjectConfig) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && isAdmin()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(canWriteProjectConfig || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE) && projectState.statePermitsWrite()));
    detail.setConfigVisible(canWriteProjectConfig || checkReadConfig);
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(projectState.getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, PermissionBackendException, ResourceConflictException {
    ProjectState projectState = checkProjectState();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = checkProjectState();
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = checkProjectState();
        }
    }
    // The following implementation must match the GetAccess REST API endpoint.
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    PermissionBackend.ForProject perm = permissionBackend.currentUser().project(projectName);
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteProjectConfig = true;
    try {
        perm.check(ProjectPermission.WRITE_CONFIG);
    } catch (AuthException e) {
        canWriteProjectConfig = false;
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteProjectConfig) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && isAdmin()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName) && permissionBackend.currentUser().testOrFalse(ADMINISTRATE_SERVER)) {
        ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(canWriteProjectConfig || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE) && projectState.statePermitsWrite()));
    detail.setConfigVisible(canWriteProjectConfig || checkReadConfig);
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(projectState.getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#end_block

#method_before
private ProjectState checkProjectState() throws NoSuchProjectException, IOException, PermissionBackendException, ResourceConflictException {
    ProjectState state = projectCache.checkedGet(projectName);
    ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
    try {
        permissionBackend.user(user).project(projectName).check(permissionToCheck);
    } catch (AuthException e) {
        throw new NoSuchProjectException(projectName);
    }
    state.checkStatePermitsRead();
    return state;
}
#method_after
private ProjectState checkProjectState() throws NoSuchProjectException, IOException, PermissionBackendException, ResourceConflictException {
    ProjectState state = projectCache.checkedGet(projectName);
    // Hidden projects(permitsRead = false) should only be accessible by the project owners.
    // READ_CONFIG is checked here because it's only allowed to project owners(ACCESS may also
    // be allowed for other users). Allowing project owners to access here will help them to view
    // and update the config of hidden projects easily.
    ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
    try {
        permissionBackend.currentUser().project(projectName).check(permissionToCheck);
    } catch (AuthException e) {
        throw new NoSuchProjectException(projectName);
    }
    state.checkStatePermitsRead();
    return state;
}
#end_block

#method_before
private boolean isAdmin() throws PermissionBackendException {
    try {
        permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#method_after
private boolean isAdmin() throws PermissionBackendException {
    try {
        permissionBackend.currentUser().check(GlobalPermission.ADMINISTRATE_SERVER);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
@Override
public final int parseArguments(Parameters params) throws CmdLineException {
    String projectName = params.getParameter(0);
    while (projectName.endsWith("/")) {
        projectName = projectName.substring(0, projectName.length() - 1);
    }
    while (projectName.startsWith("/")) {
        // Be nice and drop the leading "/" if supplied by an absolute path.
        // We don't have a file system hierarchy, just a flat namespace in
        // the database's Project entities. We never encode these with a
        // leading '/' but users might accidentally include them in Git URLs.
        // 
        projectName = projectName.substring(1);
    }
    String nameWithoutSuffix = ProjectUtil.stripGitSuffix(projectName);
    Project.NameKey nameKey = new Project.NameKey(nameWithoutSuffix);
    ProjectState state;
    try {
        state = projectCache.checkedGet(nameKey);
        if (state == null) {
            throw new CmdLineException(owner, String.format("project %s not found", nameWithoutSuffix));
        }
        ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
        permissionBackend.user(user).project(nameKey).check(permissionToCheck);
    } catch (AuthException e) {
        throw new CmdLineException(owner, new NoSuchProjectException(nameKey).getMessage());
    } catch (PermissionBackendException | IOException e) {
        log.warn("Cannot load project " + nameWithoutSuffix, e);
        throw new CmdLineException(owner, new NoSuchProjectException(nameKey).getMessage());
    }
    setter.addValue(state);
    return 1;
}
#method_after
@Override
public final int parseArguments(Parameters params) throws CmdLineException {
    String projectName = params.getParameter(0);
    while (projectName.endsWith("/")) {
        projectName = projectName.substring(0, projectName.length() - 1);
    }
    while (projectName.startsWith("/")) {
        // Be nice and drop the leading "/" if supplied by an absolute path.
        // We don't have a file system hierarchy, just a flat namespace in
        // the database's Project entities. We never encode these with a
        // leading '/' but users might accidentally include them in Git URLs.
        // 
        projectName = projectName.substring(1);
    }
    String nameWithoutSuffix = ProjectUtil.stripGitSuffix(projectName);
    Project.NameKey nameKey = new Project.NameKey(nameWithoutSuffix);
    ProjectState state;
    try {
        state = projectCache.checkedGet(nameKey);
        if (state == null) {
            throw new CmdLineException(owner, String.format("project %s not found", nameWithoutSuffix));
        }
        // Hidden projects(permitsRead = false) should only be accessible by the project owners.
        // READ_CONFIG is checked here because it's only allowed to project owners(ACCESS may also
        // be allowed for other users). Allowing project owners to access here will help them to view
        // and update the config of hidden projects easily.
        ProjectPermission permissionToCheck = state.statePermitsRead() ? ProjectPermission.ACCESS : ProjectPermission.READ_CONFIG;
        permissionBackend.currentUser().project(nameKey).check(permissionToCheck);
    } catch (AuthException e) {
        throw new CmdLineException(owner, new NoSuchProjectException(nameKey).getMessage());
    } catch (PermissionBackendException | IOException e) {
        log.warn("Cannot load project " + nameWithoutSuffix, e);
        throw new CmdLineException(owner, new NoSuchProjectException(nameKey).getMessage());
    }
    setter.addValue(state);
    return 1;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        // TODO(aliceks): Switch to SQL statements.
        List<AccountGroup> allGroups = db.accountGroups().all().toList();
        BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
        writeAllGroupNamesToNoteDb(allUsersRepo, allGroups, batchRefUpdate);
        for (AccountGroup group : allGroups) {
            migrateOneGroupToNoteDb(db, allUsersRepo, group.getId(), batchRefUpdate);
        }
        RefUpdateUtil.executeChecked(batchRefUpdate, allUsersRepo);
    // TODO(aliceks): Switch config settings? Or remove all ReviewDb code in same topic?
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException(String.format("Failed to migrate groups to NoteDb for %s", allUsersName.get()), e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    if (gerritConfig.getBoolean(SECTION_NOTE_DB, GROUPS.key(), DISABLE_REVIEW_DB, false)) {
        // Groups in ReviewDb have already been disabled, nothing to do.
        return;
    }
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        List<GroupReference> allGroupReferences = readGroupReferencesFromReviewDb(db);
        BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
        writeAllGroupNamesToNoteDb(allUsersRepo, allGroupReferences, batchRefUpdate);
        GroupRebuilder groupRebuilder = createGroupRebuilder(db, allUsersRepo);
        for (GroupReference groupReference : allGroupReferences) {
            migrateOneGroupToNoteDb(db, allUsersRepo, groupRebuilder, groupReference.getUUID(), batchRefUpdate);
        }
        RefUpdateUtil.executeChecked(batchRefUpdate, allUsersRepo);
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException(String.format("Failed to migrate groups to NoteDb for %s", allUsersName.get()), e);
    }
}
#end_block

#method_before
private void writeAllGroupNamesToNoteDb(Repository allUsersRepo, List<AccountGroup> allGroups, BatchRefUpdate batchRefUpdate) throws IOException {
    try (ObjectInserter inserter = allUsersRepo.newObjectInserter()) {
        List<GroupReference> groupRefs = allGroups.stream().map(GroupReference::forGroup).collect(toImmutableList());
        GroupNameNotes.updateAllGroups(allUsersRepo, inserter, batchRefUpdate, groupRefs, serverIdent);
        inserter.flush();
    }
}
#method_after
private void writeAllGroupNamesToNoteDb(Repository allUsersRepo, List<GroupReference> allGroupReferences, BatchRefUpdate batchRefUpdate) throws IOException {
    try (ObjectInserter inserter = allUsersRepo.newObjectInserter()) {
        GroupNameNotes.updateAllGroups(allUsersRepo, inserter, batchRefUpdate, allGroupReferences, serverIdent);
        inserter.flush();
    }
}
#end_block

#method_before
private void migrateOneGroupToNoteDb(ReviewDb db, Repository allUsersRepo, AccountGroup.Id id, BatchRefUpdate batchRefUpdate) throws ConfigInvalidException, IOException, OrmException {
    GroupBundle reviewDbBundle = groupBundleFactory.fromReviewDb(db, id);
    rebuilder.rebuild(allUsersRepo, reviewDbBundle, batchRefUpdate);
}
#method_after
private static void migrateOneGroupToNoteDb(ReviewDb db, Repository allUsersRepo, GroupRebuilder rebuilder, AccountGroup.UUID uuid, BatchRefUpdate batchRefUpdate) throws ConfigInvalidException, IOException, OrmException {
    GroupBundle reviewDbBundle = GroupBundle.Factory.fromReviewDb(db, uuid);
    RefUpdateUtil.deleteChecked(allUsersRepo, RefNames.refsGroups(uuid));
    rebuilder.rebuild(allUsersRepo, reviewDbBundle, batchRefUpdate);
}
#end_block

#method_before
@Test
@UseLocalDisk
@GlobalPluginConfig(pluginName = "high-availability", name = "peerInfo.static.url", value = URL)
public void addToProjectListAreForwarded() throws Exception {
    String createdProject = "someProject";
    final String expectedRequest = "/plugins/high-availability/cache/" + Constants.PROJECT_LIST + "/" + createdProject;
    final CountDownLatch expectedRequestLatch = new CountDownLatch(1);
    wireMockRule.addMockServiceRequestListener((request, response) -> {
        if (request.getAbsoluteUrl().contains(expectedRequest)) {
            expectedRequestLatch.countDown();
        }
    });
    givenThat(post(urlEqualTo(expectedRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_NO_CONTENT)));
    adminRestSession.put("/projects/" + createdProject).assertCreated();
    assertThat(expectedRequestLatch.await(5, TimeUnit.SECONDS)).isTrue();
    verify(postRequestedFor(urlEqualTo(expectedRequest)));
}
#method_after
@Test
@UseLocalDisk
@GlobalPluginConfig(pluginName = "high-availability", name = "peerInfo.static.url", value = URL)
public void addToProjectListAreForwarded() throws Exception {
    String createdProject = "someProject";
    String expectedRequest = "/plugins/high-availability/cache/" + Constants.PROJECT_LIST + "/" + createdProject;
    CountDownLatch expectedRequestLatch = new CountDownLatch(1);
    wireMockRule.addMockServiceRequestListener((request, response) -> {
        if (request.getAbsoluteUrl().contains(expectedRequest)) {
            expectedRequestLatch.countDown();
        }
    });
    givenThat(post(urlEqualTo(expectedRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_NO_CONTENT)));
    adminRestSession.put("/projects/" + createdProject).assertCreated();
    assertThat(expectedRequestLatch.await(5, TimeUnit.SECONDS)).isTrue();
    verify(postRequestedFor(urlEqualTo(expectedRequest)));
}
#end_block

#method_before
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new GerritApiModule());
    install(new PluginApiModule());
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use Jimfs. The biggest blocker is that JGit does not support Path-based
    // Configs, only FileBasedConfig.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toProvider(TestGerritServerIdProvider.class).in(SINGLETON);
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#method_after
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new GerritApiModule());
    install(new PluginApiModule());
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use Jimfs. The biggest blocker is that JGit does not support Path-based
    // Configs, only FileBasedConfig.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new GerritInstanceNameModule());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#end_block

#method_before
public String create() {
    String summaryLine = originalGroup.isPresent() ? "Update group" : "Create group";
    List<String> footers = new ArrayList<>();
    getFooterForRename().ifPresent(footers::add);
    getFootersForMemberModifications().forEach(footers::add);
    getFootersForSubgroupModifications().forEach(footers::add);
    Collections.sort(footers);
    StringJoiner footerJoiner = new StringJoiner("\n", "\n\n", "");
    footerJoiner.setEmptyValue("");
    footers.forEach(footerJoiner::add);
    String footer = footerJoiner.toString();
    return summaryLine + footer;
}
#method_after
public String create() {
    String summaryLine = originalGroup.isPresent() ? "Update group" : "Create group";
    StringJoiner footerJoiner = new StringJoiner("\n", "\n\n", "");
    footerJoiner.setEmptyValue("");
    Streams.concat(Streams.stream(getFooterForRename()), getFootersForMemberModifications(), getFootersForSubgroupModifications()).sorted().forEach(footerJoiner::add);
    String footer = footerJoiner.toString();
    return summaryLine + footer;
}
#end_block

#method_before
@Override
public Collection<SubmitRecord> evaluate(ChangeData cd, SubmitRuleOptions options) {
    ProjectState projectState = cache.get(cd.project());
    // The Prolog rules engine will also handle the labels for us.
    if (projectState == null || projectState.hasPrologRules()) {
        return Collections.emptyList();
    }
    SubmitRecord r = new SubmitRecord();
    r.status = SubmitRecord.Status.OK;
    List<LabelType> labelTypes;
    List<PatchSetApproval> approvals;
    try {
        labelTypes = cd.getLabelTypes().getLabelTypes();
        approvals = cd.currentApprovals();
    } catch (OrmException e) {
        e.printStackTrace();
        return Collections.emptyList();
    }
    r.labels = new ArrayList<>(labelTypes.size());
    for (final LabelType t : labelTypes) {
        LabelFunction labelFunction = t.getFunction();
        if (labelFunction == null) {
            continue;
        }
        Collection<PatchSetApproval> _approvals = getApprovalsForLabel(approvals, t);
        SubmitRecord.Label label = labelFunction.check(t, _approvals);
        r.labels.add(label);
        switch(label.status) {
            case OK:
            case MAY:
                break;
            case NEED:
            case REJECT:
            case IMPOSSIBLE:
                r.status = SubmitRecord.Status.NOT_READY;
                break;
        }
    }
    return Collections.singletonList(r);
}
#method_after
@Override
public Collection<SubmitRecord> evaluate(ChangeData cd, SubmitRuleOptions options) {
    ProjectState projectState = projectCache.get(cd.project());
    // The Prolog rules engine will also handle the labels for us.
    if (projectState == null || projectState.hasPrologRules()) {
        return Collections.emptyList();
    }
    SubmitRecord submitRecord = new SubmitRecord();
    submitRecord.status = SubmitRecord.Status.OK;
    List<LabelType> labelTypes;
    List<PatchSetApproval> approvals;
    try {
        labelTypes = cd.getLabelTypes().getLabelTypes();
        approvals = cd.currentApprovals();
    } catch (OrmException e) {
        log.error("Unable to fetch labels and approvals for change {}", cd.getId(), e);
        submitRecord.errorMessage = "Unable to fetch labels and approvals for the change";
        submitRecord.status = SubmitRecord.Status.RULE_ERROR;
        return Collections.singletonList(submitRecord);
    }
    submitRecord.labels = new ArrayList<>(labelTypes.size());
    for (LabelType t : labelTypes) {
        LabelFunction labelFunction = t.getFunction();
        if (labelFunction == null) {
            log.error("Unable to find the LabelFunction for label {}, change {}", t.getName(), cd.getId());
            submitRecord.errorMessage = "Unable to find the LabelFunction for label " + t.getName();
            submitRecord.status = SubmitRecord.Status.RULE_ERROR;
            return Collections.singletonList(submitRecord);
        }
        Collection<PatchSetApproval> approvalsForLabel = getApprovalsForLabel(approvals, t);
        SubmitRecord.Label label = labelFunction.check(t, approvalsForLabel);
        submitRecord.labels.add(label);
        switch(label.status) {
            case OK:
            case MAY:
                break;
            case NEED:
            case REJECT:
            case IMPOSSIBLE:
                submitRecord.status = SubmitRecord.Status.NOT_READY;
                break;
        }
    }
    return Collections.singletonList(submitRecord);
}
#end_block

#method_before
private static List<PatchSetApproval> getApprovalsForLabel(List<PatchSetApproval> approvals, LabelType t) {
    return approvals.stream().filter(input -> input.getLabel().equals(t.getLabelId().get())).collect(Collectors.toList());
}
#method_after
private static List<PatchSetApproval> getApprovalsForLabel(List<PatchSetApproval> approvals, LabelType t) {
    return approvals.stream().filter(input -> input.getLabel().equals(t.getLabelId().get())).collect(toImmutableList());
}
#end_block

#method_before
@Test
public void checkLabelNameIsCorrect() {
    for (LabelFunction function : LabelFunction.values()) {
        SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, Collections.emptyList());
        assertThat(myLabel.label).isEqualTo("Verified");
    }
}
#method_after
@Test
public void checkLabelNameIsCorrect() {
    for (LabelFunction function : LabelFunction.values()) {
        SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, ImmutableList.of());
        assertThat(myLabel.label).isEqualTo("Verified");
    }
}
#end_block

#method_before
@Test
public void checkFunctionDoesNothing() {
    checkNothingHappens(LabelFunction.NO_BLOCK);
    checkNothingHappens(LabelFunction.NO_OP);
    checkNothingHappens(LabelFunction.PATCH_SET_LOCK);
    checkLabelIsRequired(LabelFunction.ANY_WITH_BLOCK);
    checkLabelIsRequired(LabelFunction.MAX_WITH_BLOCK);
    checkLabelIsRequired(LabelFunction.MAX_NO_BLOCK);
}
#method_after
@Test
public void checkFunctionDoesNothing() {
    checkNothingHappens(LabelFunction.NO_BLOCK);
    checkNothingHappens(LabelFunction.NO_OP);
    checkNothingHappens(LabelFunction.PATCH_SET_LOCK);
    checkNothingHappens(LabelFunction.ANY_WITH_BLOCK);
    checkLabelIsRequired(LabelFunction.MAX_WITH_BLOCK);
    checkLabelIsRequired(LabelFunction.MAX_NO_BLOCK);
}
#end_block

#method_before
@Test
public void checkMaxNoBlockIgnoresMin() {
    List<PatchSetApproval> approvals = Lists.newArrayList(APPROVAL_M2, APPROVAL_2, APPROVAL_M2);
    SubmitRecord.Label myLabel = LabelFunction.MAX_NO_BLOCK.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.OK);
    assertThat(myLabel.appliedBy).isEqualTo(APPROVAL_2.getAccountId());
}
#method_after
@Test
public void checkMaxNoBlockIgnoresMin() {
    List<PatchSetApproval> approvals = ImmutableList.of(APPROVAL_M2, APPROVAL_2, APPROVAL_M2);
    SubmitRecord.Label myLabel = LabelFunction.MAX_NO_BLOCK.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.OK);
    assertThat(myLabel.appliedBy).isEqualTo(APPROVAL_2.getAccountId());
}
#end_block

#method_before
private static PatchSetApproval makeApproval(short value) {
    Account.Id accountId = new Account.Id(10000 + value);
    PatchSetApproval.Key key = makeKey(PS_ID, accountId, LABEL_ID);
    return new PatchSetApproval(key, value, Date.from(Instant.now()));
}
#method_after
private static PatchSetApproval makeApproval(int value) {
    Account.Id accountId = new Account.Id(10000 + value);
    PatchSetApproval.Key key = makeKey(PS_ID, accountId, LABEL_ID);
    return new PatchSetApproval(key, (short) value, Date.from(Instant.now()));
}
#end_block

#method_before
private static void checkBlockWorks(LabelFunction function) {
    List<PatchSetApproval> approvals = Lists.newArrayList(APPROVAL_1, APPROVAL_M2, APPROVAL_2);
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.REJECT);
    assertThat(myLabel.appliedBy).isEqualTo(APPROVAL_M2.getAccountId());
}
#method_after
private static void checkBlockWorks(LabelFunction function) {
    List<PatchSetApproval> approvals = ImmutableList.of(APPROVAL_1, APPROVAL_M2, APPROVAL_2);
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.REJECT);
    assertThat(myLabel.appliedBy).isEqualTo(APPROVAL_M2.getAccountId());
}
#end_block

#method_before
private static void checkNothingHappens(LabelFunction function) {
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, Collections.emptyList());
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.MAY);
    assertThat(myLabel.appliedBy).isNull();
}
#method_after
private static void checkNothingHappens(LabelFunction function) {
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, ImmutableList.of());
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.MAY);
    assertThat(myLabel.appliedBy).isNull();
}
#end_block

#method_before
private static void checkLabelIsRequired(LabelFunction function) {
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, Collections.emptyList());
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.NEED);
    assertThat(myLabel.appliedBy).isNull();
}
#method_after
private static void checkLabelIsRequired(LabelFunction function) {
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, ImmutableList.of());
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.NEED);
    assertThat(myLabel.appliedBy).isNull();
}
#end_block

#method_before
private static void checkMaxIsEnforced(LabelFunction function) {
    List<PatchSetApproval> approvals = Lists.newArrayList(APPROVAL_1, APPROVAL_0);
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.NEED);
}
#method_after
private static void checkMaxIsEnforced(LabelFunction function) {
    List<PatchSetApproval> approvals = ImmutableList.of(APPROVAL_1, APPROVAL_0);
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.NEED);
}
#end_block

#method_before
private void checkMaxValidatesTheLabel(LabelFunction function) {
    List<PatchSetApproval> approvals = Lists.newArrayList(APPROVAL_1, APPROVAL_2, APPROVAL_M1);
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.OK);
    assertThat(myLabel.appliedBy).isEqualTo(APPROVAL_2.getAccountId());
}
#method_after
private static void checkMaxValidatesTheLabel(LabelFunction function) {
    List<PatchSetApproval> approvals = ImmutableList.of(APPROVAL_1, APPROVAL_2, APPROVAL_M1);
    SubmitRecord.Label myLabel = function.check(VERIFIED_LABEL, approvals);
    assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.OK);
    assertThat(myLabel.appliedBy).isEqualTo(APPROVAL_2.getAccountId());
}
#end_block

#method_before
private boolean canRead(ObjectId revId) throws IOException, PermissionBackendException {
    try {
        ProjectState projectState = projectCache.get(projectName);
        checkNotNull(projectState, "Failed to load project %s", projectName);
        projectState.checkStatePermitsRead();
        permissionBackend.user(user).project(projectName).check(ProjectPermission.READ);
        return true;
    } catch (AuthException | ResourceConflictException e) {
        // Check reachability of the specific revision.
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(revId);
            return commits.canRead(projectState, repo, commit);
        }
    }
}
#method_after
private boolean canRead(ObjectId revId) throws IOException, PermissionBackendException {
    ProjectState projectState = projectCache.get(projectName);
    checkNotNull(projectState, "Failed to load project %s", projectName);
    if (!projectState.statePermitsRead()) {
        return false;
    }
    try {
        permissionBackend.user(user).project(projectName).check(ProjectPermission.READ);
        return true;
    } catch (AuthException e) {
        // Check reachability of the specific revision.
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(revId);
            return commits.canRead(projectState, repo, commit);
        }
    }
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (Project.NameKey projectName : filter(perm)) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupsCollection.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs;
                        try {
                            e.checkStatePermitsRead();
                            permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            canReadAllRefs = true;
                        } catch (AuthException | ResourceConflictException exp) {
                            canReadAllRefs = false;
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (Project.NameKey projectName : filter(perm)) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupsCollection.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    if (req.getQueryString() == null || req.getQueryString().isEmpty()) {
        // No query string? They want the project list, which we don't
        // currently support. Return to Gerrit's own web UI.
        // 
        rsp.sendRedirect(req.getContextPath() + "/");
        return;
    }
    final Map<String, String> params = getParameters(req);
    String a = params.get("a");
    if (a != null) {
        if (deniedActions.contains(a)) {
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
        if (a.equals(PROJECT_LIST_ACTION)) {
            rsp.sendRedirect(req.getContextPath() + "/#" + PageLinks.ADMIN_PROJECTS + "?filter=" + Url.encode(params.get("pf") + "/"));
            return;
        }
    }
    String name = params.get("p");
    if (name == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    if (name.endsWith(".git")) {
        name = name.substring(0, name.length() - 4);
    }
    Project.NameKey nameKey = new Project.NameKey(name);
    try {
        ProjectState projectState = projectCache.checkedGet(nameKey);
        if (projectState == null) {
            sendErrorOrRedirect(req, rsp, HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        projectState.checkStatePermitsRead();
        permissionBackend.user(userProvider).project(nameKey).check(ProjectPermission.READ);
    } catch (AuthException e) {
        sendErrorOrRedirect(req, rsp, HttpServletResponse.SC_NOT_FOUND);
        return;
    } catch (IOException | PermissionBackendException err) {
        log.error("cannot load " + name, err);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    } catch (ResourceConflictException e) {
        sendErrorOrRedirect(req, rsp, HttpServletResponse.SC_CONFLICT);
        return;
    }
    try (Repository repo = repoManager.openRepository(nameKey)) {
        CacheHeaders.setNotCacheable(rsp);
        exec(req, rsp, nameKey);
    } catch (RepositoryNotFoundException e) {
        getServletContext().log("Cannot open repository", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    if (req.getQueryString() == null || req.getQueryString().isEmpty()) {
        // No query string? They want the project list, which we don't
        // currently support. Return to Gerrit's own web UI.
        // 
        rsp.sendRedirect(req.getContextPath() + "/");
        return;
    }
    final Map<String, String> params = getParameters(req);
    String a = params.get("a");
    if (a != null) {
        if (deniedActions.contains(a)) {
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
        if (a.equals(PROJECT_LIST_ACTION)) {
            rsp.sendRedirect(req.getContextPath() + "/#" + PageLinks.ADMIN_PROJECTS + "?filter=" + Url.encode(params.get("pf") + "/"));
            return;
        }
    }
    String name = params.get("p");
    if (name == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    if (name.endsWith(".git")) {
        name = name.substring(0, name.length() - 4);
    }
    Project.NameKey nameKey = new Project.NameKey(name);
    ProjectState projectState;
    try {
        projectState = projectCache.checkedGet(nameKey);
        if (projectState == null) {
            sendErrorOrRedirect(req, rsp, HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        projectState.checkStatePermitsRead();
        permissionBackend.user(userProvider).project(nameKey).check(ProjectPermission.READ);
    } catch (AuthException e) {
        sendErrorOrRedirect(req, rsp, HttpServletResponse.SC_NOT_FOUND);
        return;
    } catch (IOException | PermissionBackendException err) {
        log.error("cannot load " + name, err);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    } catch (ResourceConflictException e) {
        sendErrorOrRedirect(req, rsp, HttpServletResponse.SC_CONFLICT);
        return;
    }
    try (Repository repo = repoManager.openRepository(nameKey)) {
        CacheHeaders.setNotCacheable(rsp);
        exec(req, rsp, projectState);
    } catch (RepositoryNotFoundException e) {
        getServletContext().log("Cannot open repository", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private void exec(HttpServletRequest req, HttpServletResponse rsp, Project.NameKey project) throws IOException {
    final Process proc = Runtime.getRuntime().exec(new String[] { gitwebCgi.toAbsolutePath().toString() }, makeEnv(req, project), gitwebCgi.toAbsolutePath().getParent().toFile());
    copyStderrToLog(proc.getErrorStream());
    if (0 < req.getContentLength()) {
        copyContentToCGI(req, proc.getOutputStream());
    } else {
        proc.getOutputStream().close();
    }
    try (InputStream in = new BufferedInputStream(proc.getInputStream(), bufferSize)) {
        readCgiHeaders(rsp, in);
        try (OutputStream out = rsp.getOutputStream()) {
            final byte[] buf = new byte[bufferSize];
            int n;
            while ((n = in.read(buf)) > 0) {
                out.write(buf, 0, n);
            }
        }
    } catch (IOException e) {
        // The browser has probably closed its input stream. We don't
        // want to continue executing this request.
        // 
        proc.destroy();
        return;
    }
    try {
        proc.waitFor();
        final int status = proc.exitValue();
        if (0 != status) {
            log.error("Non-zero exit status (" + status + ") from " + gitwebCgi);
            if (!rsp.isCommitted()) {
                rsp.sendError(500);
            }
        }
    } catch (InterruptedException ie) {
        log.debug("CGI: interrupted waiting for CGI to terminate");
    }
}
#method_after
private void exec(HttpServletRequest req, HttpServletResponse rsp, ProjectState projectState) throws IOException {
    final Process proc = Runtime.getRuntime().exec(new String[] { gitwebCgi.toAbsolutePath().toString() }, makeEnv(req, projectState), gitwebCgi.toAbsolutePath().getParent().toFile());
    copyStderrToLog(proc.getErrorStream());
    if (0 < req.getContentLength()) {
        copyContentToCGI(req, proc.getOutputStream());
    } else {
        proc.getOutputStream().close();
    }
    try (InputStream in = new BufferedInputStream(proc.getInputStream(), bufferSize)) {
        readCgiHeaders(rsp, in);
        try (OutputStream out = rsp.getOutputStream()) {
            final byte[] buf = new byte[bufferSize];
            int n;
            while ((n = in.read(buf)) > 0) {
                out.write(buf, 0, n);
            }
        }
    } catch (IOException e) {
        // The browser has probably closed its input stream. We don't
        // want to continue executing this request.
        // 
        proc.destroy();
        return;
    }
    try {
        proc.waitFor();
        final int status = proc.exitValue();
        if (0 != status) {
            log.error("Non-zero exit status (" + status + ") from " + gitwebCgi);
            if (!rsp.isCommitted()) {
                rsp.sendError(500);
            }
        }
    } catch (InterruptedException ie) {
        log.debug("CGI: interrupted waiting for CGI to terminate");
    }
}
#end_block

#method_before
private String[] makeEnv(HttpServletRequest req, Project.NameKey nameKey) {
    final EnvList env = new EnvList(_env);
    final int contentLength = Math.max(0, req.getContentLength());
    // These ones are from "The WWW Common Gateway Interface Version 1.1"
    // 
    env.set("AUTH_TYPE", req.getAuthType());
    env.set("CONTENT_LENGTH", Integer.toString(contentLength));
    env.set("CONTENT_TYPE", req.getContentType());
    env.set("GATEWAY_INTERFACE", "CGI/1.1");
    env.set("PATH_INFO", req.getPathInfo());
    env.set("PATH_TRANSLATED", null);
    env.set("QUERY_STRING", req.getQueryString());
    env.set("REMOTE_ADDR", req.getRemoteAddr());
    env.set("REMOTE_HOST", req.getRemoteHost());
    env.set("HTTPS", req.isSecure() ? "ON" : "OFF");
    // The identity information reported about the connection by a
    // RFC 1413 [11] request to the remote agent, if
    // available. Servers MAY choose not to support this feature, or
    // not to request the data for efficiency reasons.
    // "REMOTE_IDENT" => "NYI"
    // 
    env.set("REQUEST_METHOD", req.getMethod());
    env.set("SCRIPT_NAME", req.getContextPath() + req.getServletPath());
    env.set("SCRIPT_FILENAME", gitwebCgi.toAbsolutePath().toString());
    env.set("SERVER_NAME", req.getServerName());
    env.set("SERVER_PORT", Integer.toString(req.getServerPort()));
    env.set("SERVER_PROTOCOL", req.getProtocol());
    env.set("SERVER_SOFTWARE", getServletContext().getServerInfo());
    final Enumeration<String> hdrs = enumerateHeaderNames(req);
    while (hdrs.hasMoreElements()) {
        final String name = hdrs.nextElement();
        final String value = req.getHeader(name);
        env.set("HTTP_" + name.toUpperCase().replace('-', '_'), value);
    }
    env.set("GERRIT_CONTEXT_PATH", req.getContextPath() + "/");
    env.set("GERRIT_PROJECT_NAME", nameKey.get());
    env.set("GITWEB_PROJECTROOT", repoManager.getBasePath(nameKey).toAbsolutePath().toString());
    // #service(...).
    if (permissionBackend.user(anonymousUserProvider).project(nameKey).testOrFalse(ProjectPermission.READ)) {
        env.set("GERRIT_ANONYMOUS_READ", "1");
    }
    String remoteUser = null;
    if (userProvider.get().isIdentifiedUser()) {
        IdentifiedUser u = userProvider.get().asIdentifiedUser();
        Optional<String> user = u.getUserName();
        env.set("GERRIT_USER_NAME", user.orElse(null));
        remoteUser = user.orElseGet(() -> "account-" + u.getAccountId());
    }
    env.set("REMOTE_USER", remoteUser);
    // 
    if (gitwebUrl != null) {
        int schemePort = -1;
        if (gitwebUrl.getScheme() != null) {
            if (gitwebUrl.getScheme().equals("http")) {
                env.set("HTTPS", "OFF");
                schemePort = 80;
            } else {
                env.set("HTTPS", "ON");
                schemePort = 443;
            }
        }
        if (gitwebUrl.getHost() != null) {
            env.set("SERVER_NAME", gitwebUrl.getHost());
            env.set("HTTP_HOST", gitwebUrl.getHost());
        }
        if (gitwebUrl.getPort() != -1) {
            env.set("SERVER_PORT", Integer.toString(gitwebUrl.getPort()));
        } else if (schemePort != -1) {
            env.set("SERVER_PORT", Integer.toString(schemePort));
        }
        if (gitwebUrl.getPath() != null) {
            env.set("SCRIPT_NAME", gitwebUrl.getPath().isEmpty() ? "/" : gitwebUrl.getPath());
        }
    }
    return env.getEnvArray();
}
#method_after
private String[] makeEnv(HttpServletRequest req, ProjectState projectState) {
    final EnvList env = new EnvList(_env);
    final int contentLength = Math.max(0, req.getContentLength());
    // These ones are from "The WWW Common Gateway Interface Version 1.1"
    // 
    env.set("AUTH_TYPE", req.getAuthType());
    env.set("CONTENT_LENGTH", Integer.toString(contentLength));
    env.set("CONTENT_TYPE", req.getContentType());
    env.set("GATEWAY_INTERFACE", "CGI/1.1");
    env.set("PATH_INFO", req.getPathInfo());
    env.set("PATH_TRANSLATED", null);
    env.set("QUERY_STRING", req.getQueryString());
    env.set("REMOTE_ADDR", req.getRemoteAddr());
    env.set("REMOTE_HOST", req.getRemoteHost());
    env.set("HTTPS", req.isSecure() ? "ON" : "OFF");
    // The identity information reported about the connection by a
    // RFC 1413 [11] request to the remote agent, if
    // available. Servers MAY choose not to support this feature, or
    // not to request the data for efficiency reasons.
    // "REMOTE_IDENT" => "NYI"
    // 
    env.set("REQUEST_METHOD", req.getMethod());
    env.set("SCRIPT_NAME", req.getContextPath() + req.getServletPath());
    env.set("SCRIPT_FILENAME", gitwebCgi.toAbsolutePath().toString());
    env.set("SERVER_NAME", req.getServerName());
    env.set("SERVER_PORT", Integer.toString(req.getServerPort()));
    env.set("SERVER_PROTOCOL", req.getProtocol());
    env.set("SERVER_SOFTWARE", getServletContext().getServerInfo());
    final Enumeration<String> hdrs = enumerateHeaderNames(req);
    while (hdrs.hasMoreElements()) {
        final String name = hdrs.nextElement();
        final String value = req.getHeader(name);
        env.set("HTTP_" + name.toUpperCase().replace('-', '_'), value);
    }
    Project.NameKey nameKey = projectState.getNameKey();
    env.set("GERRIT_CONTEXT_PATH", req.getContextPath() + "/");
    env.set("GERRIT_PROJECT_NAME", nameKey.get());
    env.set("GITWEB_PROJECTROOT", repoManager.getBasePath(nameKey).toAbsolutePath().toString());
    if (projectState.statePermitsRead() && permissionBackend.user(anonymousUserProvider).project(nameKey).testOrFalse(ProjectPermission.READ)) {
        env.set("GERRIT_ANONYMOUS_READ", "1");
    }
    String remoteUser = null;
    if (userProvider.get().isIdentifiedUser()) {
        IdentifiedUser u = userProvider.get().asIdentifiedUser();
        Optional<String> user = u.getUserName();
        env.set("GERRIT_USER_NAME", user.orElse(null));
        remoteUser = user.orElseGet(() -> "account-" + u.getAccountId());
    }
    env.set("REMOTE_USER", remoteUser);
    // 
    if (gitwebUrl != null) {
        int schemePort = -1;
        if (gitwebUrl.getScheme() != null) {
            if (gitwebUrl.getScheme().equals("http")) {
                env.set("HTTPS", "OFF");
                schemePort = 80;
            } else {
                env.set("HTTPS", "ON");
                schemePort = 443;
            }
        }
        if (gitwebUrl.getHost() != null) {
            env.set("SERVER_NAME", gitwebUrl.getHost());
            env.set("HTTP_HOST", gitwebUrl.getHost());
        }
        if (gitwebUrl.getPort() != -1) {
            env.set("SERVER_PORT", Integer.toString(gitwebUrl.getPort()));
        } else if (schemePort != -1) {
            env.set("SERVER_PORT", Integer.toString(schemePort));
        }
        if (gitwebUrl.getPath() != null) {
            env.set("SCRIPT_NAME", gitwebUrl.getPath().isEmpty() ? "/" : gitwebUrl.getPath());
        }
    }
    return env.getEnvArray();
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws RestApiException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName, false).getNameKey();
    if (args.newParent.equals(allUsers)) {
        throw new ResourceConflictException(String.format("Cannot inherit from '%s' project", allUsers.get()));
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    args.rejectEmptyCommit = MoreObjects.firstNonNull(input.rejectEmptyCommit, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    Lock nameLock = lockManager.get().getLock(args.getProject());
    nameLock.lock();
    try {
        for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
            try {
                l.validateNewProject(args);
            } catch (ValidationException e) {
                throw new ResourceConflictException(e.getMessage(), e);
            }
        }
        ProjectState projectState = createProject(args);
        if (projectState == null) {
            throw new RuntimeException("fail to create project " + args.getProject().get());
        }
        if (input.pluginConfigValues != null) {
            ConfigInput in = new ConfigInput();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectState, in);
        }
        return Response.created(json.format(projectState));
    } finally {
        nameLock.unlock();
    }
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws RestApiException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName, false).getNameKey();
    if (args.newParent.equals(allUsers)) {
        throw new ResourceConflictException(String.format("Cannot inherit from '%s' project", allUsers.get()));
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    args.rejectEmptyCommit = MoreObjects.firstNonNull(input.rejectEmptyCommit, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    Lock nameLock = lockManager.get().getLock(args.getProject());
    nameLock.lock();
    try {
        for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
            try {
                l.validateNewProject(args);
            } catch (ValidationException e) {
                throw new ResourceConflictException(e.getMessage(), e);
            }
        }
        ProjectState projectState = createProject(args);
        checkNotNull(projectState, "failed to create project " + args.getProject().get());
        if (input.pluginConfigValues != null) {
            ConfigInput in = new ConfigInput();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectState, in);
        }
        return Response.created(json.format(projectState));
    } finally {
        nameLock.unlock();
    }
}
#end_block

#method_before
protected <T> QueryBuilder toQueryBuilder(Predicate<T> p) throws QueryParseException {
    if (p instanceof AndPredicate) {
        return and(p);
    } else if (p instanceof OrPredicate) {
        return or(p);
    } else if (p instanceof NotPredicate) {
        return not(p);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<T>) p);
    } else if (p instanceof AnyPredicate) {
        return QueryBuilders.matchAllQuery();
    } else {
        throw new QueryParseException("cannot create query for index: " + p);
    }
}
#method_after
protected <T> QueryBuilder toQueryBuilder(Predicate<T> p) throws QueryParseException {
    if (p instanceof AndPredicate) {
        return and(p);
    } else if (p instanceof OrPredicate) {
        return or(p);
    } else if (p instanceof NotPredicate) {
        return not(p);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<T>) p);
    } else if (p instanceof PostFilterPredicate) {
        return QueryBuilders.matchAllQuery();
    } else {
        throw new QueryParseException("cannot create query for index: " + p);
    }
}
#end_block

#method_before
@Override
public boolean match(AccountState accountState) throws OrmException {
    Predicate<AccountState> pred = getChild(0);
    checkState(pred.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", pred, Matchable.class.getName());
    return pred.asMatchable().match(accountState);
}
#method_after
@Override
public boolean match(AccountState accountState) throws OrmException {
    Predicate<AccountState> pred = getChild(0);
    checkState(pred.isMatchable(), "match invoked, but child predicate %s doesn't implement %s", pred, Matchable.class.getName());
    return pred.asMatchable().match(accountState);
}
#end_block

#method_before
public Query toQuery(Predicate<V> p) throws QueryParseException {
    if (p instanceof AndPredicate) {
        return and(p);
    } else if (p instanceof OrPredicate) {
        return or(p);
    } else if (p instanceof NotPredicate) {
        return not(p);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<V>) p);
    } else if (p instanceof AnyPredicate) {
        return new MatchAllDocsQuery();
    } else {
        throw new QueryParseException("cannot create query for index: " + p);
    }
}
#method_after
public Query toQuery(Predicate<V> p) throws QueryParseException {
    if (p instanceof AndPredicate) {
        return and(p);
    } else if (p instanceof OrPredicate) {
        return or(p);
    } else if (p instanceof NotPredicate) {
        return not(p);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<V>) p);
    } else if (p instanceof PostFilterPredicate) {
        return new MatchAllDocsQuery();
    } else {
        throw new QueryParseException("cannot create query for index: " + p);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.get().post(remote, content.get());
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (RuntimeException | IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.get().post(remote, content.get());
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (Throwable e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#end_block

#method_before
private boolean isRecoverable(Exception e) {
    return !(e instanceof SSLException) && (e instanceof IOException);
}
#method_after
private boolean isRecoverable(Throwable e) {
    return (e instanceof IOException) && !(e instanceof SSLException);
}
#end_block

#method_before
@Override
protected List<String> getValues(LfsSshAuthToken token) {
    List<String> values = new ArrayList<>(4);
    values.add(token.user);
    values.add(token.project);
    values.add(token.operation);
    values.add(DATETIME.format(token.issued));
    values.add(String.valueOf(token.expiresIn));
    return values;
}
#method_after
@Override
protected List<String> getValues(LfsSshAuthToken token) {
    List<String> values = new ArrayList<>(4);
    values.add(token.user);
    values.add(token.project);
    values.add(token.operation);
    values.add(LfsDateTime.format(token.issued));
    values.add(String.valueOf(token.expiresIn));
    return values;
}
#end_block

#method_before
@Override
protected Optional<LfsSshAuthToken> createToken(List<String> values) {
    if (values.size() != 4) {
        return Optional.empty();
    }
    return Optional.of(new LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(3), Integer.valueOf(values.get(4))));
}
#method_after
@Override
protected Optional<LfsSshAuthToken> createToken(List<String> values) {
    if (values.size() != 5) {
        return Optional.empty();
    }
    return Optional.of(new LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(3), Long.valueOf(values.get(4))));
}
#end_block

#method_before
@Test
public void testVerifyAuthInfo() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), Instant.now(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken(), "o", zeroId())).isTrue();
}
#method_after
@Test
public void testVerifyAuthInfo() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), Instant.now(), 1L);
    assertThat(auth.verifyAuthInfo(info.authToken(), "o", zeroId())).isTrue();
}
#end_block

#method_before
@Test
public void testVerifyAgainstDifferentOperation() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), Instant.now(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken(), "p", zeroId())).isFalse();
}
#method_after
@Test
public void testVerifyAgainstDifferentOperation() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), Instant.now(), 1L);
    assertThat(auth.verifyAuthInfo(info.authToken(), "p", zeroId())).isFalse();
}
#end_block

#method_before
@Test
public void testVerifyAgainstDifferentObjectId() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), Instant.now(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken(), "o", LongObjectId.fromString("123456789012345678901234567890" + "123456789012345678901234567890" + "1234"))).isFalse();
}
#method_after
@Test
public void testVerifyAgainstDifferentObjectId() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), Instant.now(), 1L);
    assertThat(auth.verifyAuthInfo(info.authToken(), "o", LongObjectId.fromString("123456789012345678901234567890" + "123456789012345678901234567890" + "1234"))).isFalse();
}
#end_block

#method_before
public AuthInfo generateAuthInfo(String operation, AnyLongObjectId id, Instant now, int expiresIn) {
    LfsFsAuthToken token = new LfsFsAuthToken(operation, id, now, expiresIn);
    return new AuthInfo(processor.serialize(token), token.issued, token.expiresIn);
}
#method_after
public AuthInfo generateAuthInfo(String operation, AnyLongObjectId id, Instant now, Long expiresIn) {
    LfsFsAuthToken token = new LfsFsAuthToken(operation, id, now, expiresIn);
    return new AuthInfo(processor.serialize(token), token.issued, token.expiresIn);
}
#end_block

#method_before
@Override
protected List<String> getValues(LfsFsAuthToken token) {
    List<String> values = new ArrayList<>(3);
    values.add(token.operation);
    values.add(token.id.getName());
    values.add(DATETIME.format(token.issued));
    values.add(String.valueOf(token.expiresIn));
    return values;
}
#method_after
@Override
protected List<String> getValues(LfsFsAuthToken token) {
    List<String> values = new ArrayList<>(3);
    values.add(token.operation);
    values.add(token.id.getName());
    values.add(LfsDateTime.format(token.issued));
    values.add(String.valueOf(token.expiresIn));
    return values;
}
#end_block

#method_before
@Override
protected Optional<LfsFsAuthToken> createToken(List<String> values) {
    if (values.size() != 4) {
        return Optional.empty();
    }
    return Optional.of(new LfsFsAuthToken(values.get(0), LongObjectId.fromString(values.get(1)), values.get(2), Integer.valueOf(values.get(3))));
}
#method_after
@Override
protected Optional<LfsFsAuthToken> createToken(List<String> values) {
    if (values.size() != 4) {
        return Optional.empty();
    }
    return Optional.of(new LfsFsAuthToken(values.get(0), LongObjectId.fromString(values.get(1)), values.get(2), Long.valueOf(values.get(3))));
}
#end_block

#method_before
public String expiresAt() {
    return DATETIME.format(issued.plusSeconds(expiresIn));
}
#method_after
public String expiresAt() {
    return LfsDateTime.format(issued.plusSeconds(expiresIn));
}
#end_block

#method_before
public Integer expiresIn() {
    return expiresIn * 1000;
}
#method_after
public Long expiresIn() {
    return expiresIn;
}
#end_block

#method_before
@Test
public void testTokenSerializationDeserialization() throws Exception {
    TestTokenProessor processor = new TestTokenProessor(cipher);
    TestToken token = new TestToken(Instant.now(), 0);
    String serialized = processor.serialize(token);
    assertThat(serialized).isNotEmpty();
    Optional<TestToken> deserialized = processor.deserialize(serialized);
    assertThat(deserialized.isPresent()).isTrue();
    assertThat(token.issued).isEqualTo(deserialized.get().issued);
}
#method_after
@Test
public void testTokenSerializationDeserialization() throws Exception {
    TestTokenProessor processor = new TestTokenProessor(cipher);
    TestToken token = new TestToken(Instant.now(), 0L);
    String serialized = processor.serialize(token);
    assertThat(serialized).isNotEmpty();
    Optional<TestToken> deserialized = processor.deserialize(serialized);
    assertThat(deserialized.isPresent()).isTrue();
    assertThat(token.issued).isEqualTo(deserialized.get().issued);
}
#end_block

#method_before
@Test
public void testTokenOnTime() throws Exception {
    Instant when = Instant.now();
    TestToken token = new TestToken(when, 1);
    TestTokenVerifier verifier = new TestTokenVerifier(token);
    assertThat(verifier.onTime(when.plusMillis(999))).isTrue();
}
#method_after
@Test
public void testTokenOnTime() throws Exception {
    Instant when = Instant.now();
    TestToken token = new TestToken(when, 1L);
    TestTokenVerifier verifier = new TestTokenVerifier(token);
    assertThat(verifier.onTime(when.plusMillis(999))).isTrue();
}
#end_block

#method_before
@Test
public void testTokenExpired() throws Exception {
    Instant when = Instant.now();
    TestToken token = new TestToken(when, 1);
    TestTokenVerifier verifier = new TestTokenVerifier(token);
    assertThat(verifier.onTime(when.plusMillis(1001))).isFalse();
}
#method_after
@Test
public void testTokenExpired() throws Exception {
    Instant when = Instant.now();
    TestToken token = new TestToken(when, 1L);
    TestTokenVerifier verifier = new TestTokenVerifier(token);
    assertThat(verifier.onTime(when.plusMillis(1001))).isFalse();
}
#end_block

#method_before
@Override
protected List<String> getValues(TestToken token) {
    List<String> values = new ArrayList<>(2);
    values.add(DATETIME.format(token.issued));
    values.add(String.valueOf(token.expiresIn));
    return values;
}
#method_after
@Override
protected List<String> getValues(TestToken token) {
    List<String> values = new ArrayList<>(2);
    values.add(LfsDateTime.format(token.issued));
    values.add(String.valueOf(token.expiresIn));
    return values;
}
#end_block

#method_before
@Override
protected Optional<TestToken> createToken(List<String> values) {
    return Optional.of(new TestToken(values.get(0), Integer.valueOf(values.get(1))));
}
#method_after
@Override
protected Optional<TestToken> createToken(List<String> values) {
    return Optional.of(new TestToken(values.get(0), Long.valueOf(values.get(1))));
}
#end_block

#method_before
@ConfigSuite.Config
public static Config noteDbConfig() {
    Config config = new Config();
    config.setBoolean("user", null, "writeGroupsToNoteDb", true);
    config.setBoolean("user", null, "readGroupsFromNoteDb", true);
    return config;
}
#method_after
@ConfigSuite.Config
public static Config noteDbConfig() {
    Config config = new Config();
    config.setBoolean(SECTION_NOTE_DB, GROUPS.key(), WRITE, true);
    config.setBoolean(SECTION_NOTE_DB, GROUPS.key(), READ, true);
    return config;
}
#end_block

#method_before
@Test
public void cachedGroupsForMemberAreUpdatedOnMemberAdditionAndRemoval() throws Exception {
    // Fill the cache for the observed account.
    groupIncludeCache.getGroupsWithMember(user.getId());
    String groupName = createGroup("users");
    AccountGroup.UUID groupUuid = new AccountGroup.UUID(gApi.groups().id(groupName).get().id);
    gApi.groups().id(groupName).addMembers(user.fullName);
    Collection<AccountGroup.UUID> groupsWithMemberAfterAddition = groupIncludeCache.getGroupsWithMember(user.getId());
    assertThat(groupsWithMemberAfterAddition).contains(groupUuid);
    gApi.groups().id(groupName).removeMembers(user.fullName);
    Collection<AccountGroup.UUID> groupsWithMemberAfterRemoval = groupIncludeCache.getGroupsWithMember(user.getId());
    assertThat(groupsWithMemberAfterRemoval).doesNotContain(groupUuid);
}
#method_after
@Test
public void cachedGroupsForMemberAreUpdatedOnMemberAdditionAndRemoval() throws Exception {
    TestAccount account = createUniqueAccount("user", "User");
    // Fill the cache for the observed account.
    groupIncludeCache.getGroupsWithMember(account.getId());
    String groupName = createGroup("users");
    AccountGroup.UUID groupUuid = new AccountGroup.UUID(gApi.groups().id(groupName).get().id);
    gApi.groups().id(groupName).addMembers(account.username);
    Collection<AccountGroup.UUID> groupsWithMemberAfterAddition = groupIncludeCache.getGroupsWithMember(account.getId());
    assertThat(groupsWithMemberAfterAddition).contains(groupUuid);
    gApi.groups().id(groupName).removeMembers(account.username);
    Collection<AccountGroup.UUID> groupsWithMemberAfterRemoval = groupIncludeCache.getGroupsWithMember(account.getId());
    assertThat(groupsWithMemberAfterRemoval).doesNotContain(groupUuid);
}
#end_block

#method_before
@Test
public void addMultipleMembers() throws Exception {
    String g = createGroup("users");
    TestAccount u1 = accountCreator.create("u1", "u1@example.com", "Full Name 1");
    TestAccount u2 = accountCreator.create("u2", "u2@example.com", "Full Name 2");
    gApi.groups().id(g).addMembers(u1.username, u2.username);
    assertMembers(g, u1, u2);
}
#method_after
@Test
public void addMultipleMembers() throws Exception {
    String g = createGroup("users");
    TestAccount u1 = createUniqueAccount("u1", "Full Name 1");
    TestAccount u2 = createUniqueAccount("u2", "Full Name 2");
    gApi.groups().id(g).addMembers(u1.username, u2.username);
    assertMembers(g, u1, u2);
}
#end_block

#method_before
@Test
public void addMembersWithAtSign() throws Exception {
    String g = createGroup("users");
    TestAccount u10 = accountCreator.create("u10", "u10@example.com", "Full Name 10");
    TestAccount u11_at = accountCreator.create("u11@something", "u11@example.com", "Full Name 11 With At");
    accountCreator.create("u11", "u11.another@example.com", "Full Name 11 Without At");
    gApi.groups().id(g).addMembers(u10.username, u11_at.username);
    assertMembers(g, u10, u11_at);
}
#method_after
@Test
public void addMembersWithAtSign() throws Exception {
    String g = createGroup("users");
    TestAccount u1 = createUniqueAccount("u1", "Full Name 1");
    TestAccount u2_at = createUniqueAccount("u2@something", "Full Name 2 With At");
    TestAccount u2 = createUniqueAccount("u2", "Full Name 2 Without At");
    gApi.groups().id(g).addMembers(u1.username, u2_at.username, u2.username);
    assertMembers(g, u1, u2_at, u2);
}
#end_block

#method_before
@Test
public void createGroup() throws Exception {
    String newGroupName = name("newGroup");
    GroupInfo g = gApi.groups().create(newGroupName).get();
    assertGroupInfo(getFromCache(newGroupName), g);
}
#method_after
@Test
public void createGroup() throws Exception {
    String newGroupName = name("newGroup");
    GroupInfo g = gApi.groups().create(newGroupName).get();
    assertGroupInfo(group(newGroupName), g);
}
#end_block

#method_before
@Test
public void createGroupWithProperties() throws Exception {
    GroupInput in = new GroupInput();
    in.name = name("newGroup");
    in.description = "Test description";
    in.visibleToAll = true;
    in.ownerId = getFromCache("Administrators").getGroupUUID().get();
    GroupInfo g = gApi.groups().create(in).detail();
    assertThat(g.description).isEqualTo(in.description);
    assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll);
    assertThat(g.ownerId).isEqualTo(in.ownerId);
}
#method_after
@Test
public void createGroupWithProperties() throws Exception {
    GroupInput in = new GroupInput();
    in.name = name("newGroup");
    in.description = "Test description";
    in.visibleToAll = true;
    in.ownerId = adminGroupUuid().get();
    GroupInfo g = gApi.groups().create(in).detail();
    assertThat(g.description).isEqualTo(in.description);
    assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll);
    assertThat(g.ownerId).isEqualTo(in.ownerId);
}
#end_block

#method_before
@Test
public void createdOnFieldIsPopulatedForNewGroup() throws Exception {
    // NoteDb allows only second precision.
    Timestamp testStartTime = Timestamp.from(Instant.now().truncatedTo(ChronoUnit.SECONDS));
    String newGroupName = name("newGroup");
    GroupInfo group = gApi.groups().create(newGroupName).get();
    assertThat(group.createdOn).isAtLeast(testStartTime);
}
#method_after
@Test
public void createdOnFieldIsPopulatedForNewGroup() throws Exception {
    // NoteDb allows only second precision.
    Timestamp testStartTime = TimeUtil.truncateToSecond(TimeUtil.nowTs());
    String newGroupName = name("newGroup");
    GroupInfo group = gApi.groups().create(newGroupName).get();
    assertThat(group.createdOn).isAtLeast(testStartTime);
}
#end_block

#method_before
@Test
public void getGroup() throws Exception {
    InternalGroup adminGroup = getFromCache("Administrators");
    testGetGroup(adminGroup.getGroupUUID().get(), adminGroup);
    testGetGroup(adminGroup.getName(), adminGroup);
    testGetGroup(adminGroup.getId().get(), adminGroup);
}
#method_after
@Test
public void getGroup() throws Exception {
    InternalGroup adminGroup = adminGroup();
    testGetGroup(adminGroup.getGroupUUID().get(), adminGroup);
    testGetGroup(adminGroup.getName(), adminGroup);
    testGetGroup(adminGroup.getId().get(), adminGroup);
}
#end_block

#method_before
@Test
public void oldNameOfRenamedGroupIsNotAccessibleAnymore() throws Exception {
    String name = name("Name1");
    GroupInfo group = gApi.groups().create(name).get();
    String newName = name("Name2");
    gApi.groups().id(group.id).name(newName);
    assertThat(getFromCache(name)).isNull();
    exception.expect(ResourceNotFoundException.class);
    gApi.groups().id(name).get();
}
#method_after
@Test
public void oldNameOfRenamedGroupIsNotAccessibleAnymore() throws Exception {
    String name = name("Name1");
    GroupInfo group = gApi.groups().create(name).get();
    String newName = name("Name2");
    gApi.groups().id(group.id).name(newName);
    assertGroupDoesNotExist(name);
    exception.expect(ResourceNotFoundException.class);
    gApi.groups().id(name).get();
}
#end_block

#method_before
@Test
public void groupOwner() throws Exception {
    String name = name("group");
    GroupInfo info = gApi.groups().create(name).get();
    String adminUUID = getFromCache("Administrators").getGroupUUID().get();
    String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get();
    // get owner
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id);
    // set owner by name
    gApi.groups().id(name).owner("Registered Users");
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID);
    // set owner by UUID
    gApi.groups().id(name).owner(adminUUID);
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID);
    // set non existing owner
    exception.expect(UnprocessableEntityException.class);
    gApi.groups().id(name).owner("Non-Existing Group");
}
#method_after
@Test
public void groupOwner() throws Exception {
    String name = name("group");
    GroupInfo info = gApi.groups().create(name).get();
    String adminUUID = adminGroupUuid().get();
    String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get();
    // get owner
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id);
    // set owner by name
    gApi.groups().id(name).owner("Registered Users");
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID);
    // set owner by UUID
    gApi.groups().id(name).owner(adminUUID);
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID);
    // set non existing owner
    exception.expect(UnprocessableEntityException.class);
    gApi.groups().id(name).owner("Non-Existing Group");
}
#end_block

#method_before
@Test
public void getGroupsByOwner() throws Exception {
    String parent = createGroup("test-parent");
    List<String> children = Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent));
    // By UUID
    List<GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID().get()).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By name
    owned = gApi.groups().list().withOwnedBy(parent).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By group that does not own any others
    owned = gApi.groups().list().withOwnedBy(owned.get(0).id).get();
    assertThat(owned).isEmpty();
    // By non-existing group
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Group Not Found: does-not-exist");
    gApi.groups().list().withOwnedBy("does-not-exist").get();
}
#method_after
@Test
public void getGroupsByOwner() throws Exception {
    String parent = createGroup("test-parent");
    List<String> children = Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent));
    // By UUID
    List<GroupInfo> owned = gApi.groups().list().withOwnedBy(groupUuid(parent).get()).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By name
    owned = gApi.groups().list().withOwnedBy(parent).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By group that does not own any others
    owned = gApi.groups().list().withOwnedBy(owned.get(0).id).get();
    assertThat(owned).isEmpty();
    // By non-existing group
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Group Not Found: does-not-exist");
    gApi.groups().list().withOwnedBy("does-not-exist").get();
}
#end_block

#method_before
@Test
public void onlyVisibleGroupsReturned() throws Exception {
    String newGroupName = name("newGroup");
    GroupInput in = new GroupInput();
    in.name = newGroupName;
    in.description = "a hidden group";
    in.visibleToAll = false;
    in.ownerId = getFromCache("Administrators").getGroupUUID().get();
    gApi.groups().create(in);
    setApiUser(user);
    assertThat(gApi.groups().list().getAsMap()).doesNotContainKey(newGroupName);
    setApiUser(admin);
    gApi.groups().id(newGroupName).addMembers(user.username);
    setApiUser(user);
    assertThat(gApi.groups().list().getAsMap()).containsKey(newGroupName);
}
#method_after
@Test
public void onlyVisibleGroupsReturned() throws Exception {
    String newGroupName = name("newGroup");
    GroupInput in = new GroupInput();
    in.name = newGroupName;
    in.description = "a hidden group";
    in.visibleToAll = false;
    in.ownerId = adminGroupUuid().get();
    gApi.groups().create(in);
    setApiUser(user);
    assertThat(gApi.groups().list().getAsMap()).doesNotContainKey(newGroupName);
    setApiUser(admin);
    gApi.groups().id(newGroupName).addMembers(user.username);
    setApiUser(user);
    assertThat(gApi.groups().list().getAsMap()).containsKey(newGroupName);
}
#end_block

#method_before
@Test
public void withSubstring() throws Exception {
    String group = name("Abcdefghijklmnop");
    gApi.groups().create(group);
    // Choose a substring which isn't part of any group or test method within this class.
    String substring = "efghijk";
    Map<String, GroupInfo> groups = gApi.groups().list().withSubstring(substring).getAsMap();
    assertThat(groups).containsKey(group);
    assertThat(groups).hasSize(1);
    groups = gApi.groups().list().withSubstring("abcdefghi").getAsMap();
    assertThat(groups).containsKey(group);
    assertThat(groups).hasSize(1);
    String otherGroup = name("Abcdefghijklmnop2");
    gApi.groups().create(otherGroup);
    groups = gApi.groups().list().withSubstring(substring).getAsMap();
    assertThat(groups).hasSize(2);
    assertThat(groups).containsKey(group);
    assertThat(groups).containsKey(otherGroup);
    groups = gApi.groups().list().withSubstring("foo").getAsMap();
    assertThat(groups).isEmpty();
}
#method_after
@Test
public void withSubstring() throws Exception {
    String group = name("Abcdefghijklmnop");
    gApi.groups().create(group);
    // Choose a substring which isn't part of any group or test method within this class.
    String substring = "efghijk";
    Map<String, GroupInfo> groups = gApi.groups().list().withSubstring(substring).getAsMap();
    assertThat(groups).containsKey(group);
    assertThat(groups).hasSize(1);
    groups = gApi.groups().list().withSubstring("abcdefghi").getAsMap();
    assertThat(groups).containsKey(group);
    assertThat(groups).hasSize(1);
    String otherGroup = name("Abcdefghijklmnop2");
    gApi.groups().create(otherGroup);
    groups = gApi.groups().list().withSubstring(substring).getAsMap();
    assertThat(groups).hasSize(2);
    assertThat(groups).containsKey(group);
    assertThat(groups).containsKey(otherGroup);
    groups = gApi.groups().list().withSubstring("non-existing-substring").getAsMap();
    assertThat(groups).isEmpty();
}
#end_block

#method_before
@Test
public void allGroupInfoFieldsSetCorrectly() throws Exception {
    InternalGroup adminGroup = getFromCache("Administrators");
    Map<String, GroupInfo> groups = gApi.groups().list().addGroup(adminGroup.getName()).getAsMap();
    assertThat(groups).hasSize(1);
    assertThat(groups).containsKey("Administrators");
    assertGroupInfo(adminGroup, Iterables.getOnlyElement(groups.values()));
}
#method_after
@Test
public void allGroupInfoFieldsSetCorrectly() throws Exception {
    InternalGroup adminGroup = adminGroup();
    Map<String, GroupInfo> groups = gApi.groups().list().addGroup(adminGroup.getName()).getAsMap();
    assertThat(groups).hasSize(1);
    assertThat(groups).containsKey("Administrators");
    assertGroupInfo(adminGroup, Iterables.getOnlyElement(groups.values()));
}
#end_block

#method_before
@Test
public void getAuditLog() throws Exception {
    assume().that(cfg.getBoolean("user", null, "readGroupsFromNoteDb", false)).isFalse();
    GroupApi g = gApi.groups().create(name("group"));
    List<? extends GroupAuditEventInfo> auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(1);
    assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, admin.id);
    g.addMembers(user.username);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(2);
    assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id);
    g.removeMembers(user.username);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(3);
    assertAuditEvent(auditEvents.get(0), Type.REMOVE_USER, admin.id, user.id);
    String otherGroup = name("otherGroup");
    gApi.groups().create(otherGroup);
    g.addGroups(otherGroup);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(4);
    assertAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup);
    g.removeGroups(otherGroup);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(5);
    assertAuditEvent(auditEvents.get(0), Type.REMOVE_GROUP, admin.id, otherGroup);
    Timestamp lastDate = null;
    for (GroupAuditEventInfo auditEvent : auditEvents) {
        if (lastDate != null) {
            assertThat(lastDate).isGreaterThan(auditEvent.date);
        }
        lastDate = auditEvent.date;
    }
}
#method_after
@Test
public void getAuditLog() throws Exception {
    GroupApi g = gApi.groups().create(name("group"));
    List<? extends GroupAuditEventInfo> auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(1);
    assertMemberAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, admin.id);
    g.addMembers(user.username);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(2);
    assertMemberAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id);
    g.removeMembers(user.username);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(3);
    assertMemberAuditEvent(auditEvents.get(0), Type.REMOVE_USER, admin.id, user.id);
    String otherGroup = name("otherGroup");
    gApi.groups().create(otherGroup);
    g.addGroups(otherGroup);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(4);
    assertSubgroupAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup);
    g.removeGroups(otherGroup);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(5);
    assertSubgroupAuditEvent(auditEvents.get(0), Type.REMOVE_GROUP, admin.id, otherGroup);
    // Add a removed member back again.
    g.addMembers(user.username);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(6);
    assertMemberAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id);
    // Add a removed group back again.
    g.addGroups(otherGroup);
    auditEvents = g.auditLog();
    assertThat(auditEvents).hasSize(7);
    assertSubgroupAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup);
    Timestamp lastDate = null;
    for (GroupAuditEventInfo auditEvent : auditEvents) {
        if (lastDate != null) {
            assertThat(lastDate).isAtLeast(auditEvent.date);
        }
        lastDate = auditEvent.date;
    }
}
#end_block

#method_before
@Test
public void pushToGroupBranchIsRejectedForAllUsersRepo() throws Exception {
    pushToGroupBranch(allUsers, "Not allowed to create group branch.", "group update not allowed");
}
#method_after
@Test
public void pushToGroupBranchIsRejectedForAllUsersRepo() throws Exception {
    // branch only exists when groups are in NoteDb
    assume().that(groupsInNoteDb()).isTrue();
    assertPushToGroupBranch(allUsers, RefNames.refsGroups(adminGroupUuid()), "group update not allowed");
}
#end_block

#method_before
@Test
public void pushToGroupBranchForReviewForAllUsersRepoIsRejectedOnSubmit() throws Exception {
    pushToGroupBranchForReviewAndSubmit(allUsers, "group update not allowed");
}
#method_after
@Test
public void pushToGroupBranchForReviewForAllUsersRepoIsRejectedOnSubmit() throws Exception {
    pushToGroupBranchForReviewAndSubmit(allUsers, RefNames.refsGroups(adminGroupUuid()), "group update not allowed");
}
#end_block

#method_before
@Test
public void pushToGroupBranchForReviewForNonAllUsersRepoAndSubmit() throws Exception {
    pushToGroupBranchForReviewAndSubmit(project, null);
}
#method_after
@Test
public void pushToGroupBranchForReviewForNonAllUsersRepoAndSubmit() throws Exception {
    String groupRef = RefNames.refsGroups(adminGroupUuid());
    createBranch(project, groupRef);
    pushToGroupBranchForReviewAndSubmit(project, groupRef, null);
}
#end_block

#method_before
@Test
@Sandboxed
public void cannotCreateGroupBranch() throws Exception {
    grant(allUsers, RefNames.REFS_GROUPS + "*", Permission.CREATE);
    grant(allUsers, RefNames.REFS_GROUPS + "*", Permission.PUSH);
    String groupRef = RefNames.refsGroups(new AccountGroup.UUID(name("foo")));
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo).to(groupRef);
    r.assertErrorStatus();
    assertThat(r.getMessage()).contains("Not allowed to create group branch.");
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(groupRef)).isNull();
    }
}
#method_after
@Test
public void cannotCreateGroupBranch() throws Exception {
    testCannotCreateGroupBranch(RefNames.REFS_GROUPS + "*", RefNames.refsGroups(new AccountGroup.UUID(name("foo"))));
}
#end_block

#method_before
@Test
@Sandboxed
public void cannotDeleteGroupBranch() throws Exception {
    assume().that(groupsInNoteDb()).isTrue();
    grant(allUsers, RefNames.REFS_GROUPS + "*", Permission.DELETE, true, REGISTERED_USERS);
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    assertThat(adminGroup).isNotNull();
    String groupRef = RefNames.refsGroups(adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    PushResult r = deleteRef(allUsersRepo, groupRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef);
    assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON);
    assertThat(refUpdate.getMessage()).contains("Not allowed to delete group branch.");
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(groupRef)).isNotNull();
    }
}
#method_after
@Test
public void cannotDeleteGroupBranch() throws Exception {
    assume().that(groupsInNoteDb()).isTrue();
    testCannotDeleteGroupBranch(RefNames.REFS_GROUPS + "*", RefNames.refsGroups(adminGroupUuid()));
}
#end_block

#method_before
@Test
public void defaultPermissionsOnGroupBranches() throws Exception {
    assertPermission(allUsers, RefNames.REFS_GROUPS + "*", Permission.READ, groupRef(REGISTERED_USERS));
}
#method_after
@Test
public void defaultPermissionsOnGroupBranches() throws Exception {
    assertPermissions(allUsers, groupRef(REGISTERED_USERS), RefNames.REFS_GROUPS + "*", true, Permission.READ);
}
#end_block

#method_before
@Test
public void stalenessChecker() throws Exception {
    assume().that(groupsInNoteDb()).isTrue();
    // Newly created group is not stale
    GroupInfo groupInfo = gApi.groups().create(name("foo")).get();
    AccountGroup.UUID groupUuid = new AccountGroup.UUID(groupInfo.id);
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
    // Manual update makes index document stale
    String groupRef = RefNames.refsGroups(groupUuid);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter oi = repo.newObjectInserter();
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId());
        PersonIdent ident = new PersonIdent(serverIdent.get(), TimeUtil.nowTs());
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(commit.getTree());
        cb.setCommitter(ident);
        cb.setAuthor(ident);
        cb.setMessage(commit.getFullMessage());
        ObjectId emptyCommit = oi.insert(cb);
        oi.flush();
        RefUpdate updateRef = repo.updateRef(groupRef);
        updateRef.setExpectedOldObjectId(commit.toObjectId());
        updateRef.setNewObjectId(emptyCommit);
        assertThat(updateRef.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Evict group from cache to be sure that we use the index state for staleness checks. This has
    // to happen directly on the groupsByUUID cache because GroupsCacheImpl triggers a reindex for
    // the group.
    groupsByUUIDCache.invalidate(groupInfo.id);
    assertThat(stalenessChecker.isStale(groupUuid)).isTrue();
    // Reindex fixes staleness
    gApi.groups().id(groupInfo.id).index();
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
}
#method_after
@Test
@IgnoreGroupInconsistencies
public void stalenessChecker() throws Exception {
    assume().that(readGroupsFromNoteDb()).isTrue();
    // Newly created group is not stale
    GroupInfo groupInfo = gApi.groups().create(name("foo")).get();
    AccountGroup.UUID groupUuid = new AccountGroup.UUID(groupInfo.id);
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
    // Manual update makes index document stale
    String groupRef = RefNames.refsGroups(groupUuid);
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId());
        ObjectId emptyCommit = createCommit(repo, commit.getFullMessage(), commit.getTree());
        RefUpdate updateRef = repo.updateRef(groupRef);
        updateRef.setExpectedOldObjectId(commit.toObjectId());
        updateRef.setNewObjectId(emptyCommit);
        assertThat(updateRef.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    }
    assertStaleGroupAndReindex(groupUuid);
    // Manually delete group
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId());
        RefUpdate updateRef = repo.updateRef(groupRef);
        updateRef.setExpectedOldObjectId(commit.toObjectId());
        updateRef.setNewObjectId(ObjectId.zeroId());
        updateRef.setForceUpdate(true);
        assertThat(updateRef.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
    assertStaleGroupAndReindex(groupUuid);
}
#end_block

#method_before
private void pushToGroupBranchForReviewAndSubmit(Project.NameKey project, String expectedError) throws Exception {
    grantLabel("Code-Review", -2, 2, project, RefNames.REFS_GROUPS + "*", false, REGISTERED_USERS, false);
    grant(project, RefNames.REFS_GROUPS + "*", Permission.SUBMIT, false, REGISTERED_USERS);
    String groupRefName = RefNames.REFS_GROUPS + name("foo");
    createGroupBranch(project, groupRefName);
    TestRepository<InMemoryRepository> repo = cloneProject(project);
    fetch(repo, groupRefName + ":groupRef");
    repo.reset("groupRef");
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").to(MagicBranch.NEW_CHANGE + groupRefName);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(groupRefName);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    if (expectedError != null) {
        exception.expect(ResourceConflictException.class);
        exception.expectMessage("group update not allowed");
    }
    gApi.changes().id(r.getChangeId()).current().submit();
}
#method_after
private void pushToGroupBranchForReviewAndSubmit(Project.NameKey project, String groupRef, String expectedError) throws Exception {
    // branch only exists when groups are in NoteDb
    assume().that(groupsInNoteDb()).isTrue();
    grantLabel("Code-Review", -2, 2, project, RefNames.REFS_GROUPS + "*", false, REGISTERED_USERS, false);
    grant(project, RefNames.REFS_GROUPS + "*", Permission.SUBMIT, false, REGISTERED_USERS);
    TestRepository<InMemoryRepository> repo = cloneProject(project);
    fetch(repo, groupRef + ":groupRef");
    repo.reset("groupRef");
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").to(MagicBranch.NEW_CHANGE + groupRef);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(groupRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    if (expectedError != null) {
        exception.expect(ResourceConflictException.class);
        exception.expectMessage("group update not allowed");
    }
    gApi.changes().id(r.getChangeId()).current().submit();
}
#end_block

#method_before
private boolean groupsInNoteDb() {
    return cfg.getBoolean("user", "writeGroupsToNoteDb", false) && cfg.getBoolean("user", "readGroupsFromNoteDb", false);
}
#method_after
private boolean groupsInNoteDb() {
    return cfg.getBoolean(SECTION_NOTE_DB, GROUPS.key(), WRITE, false);
}
#end_block

#method_before
private static MetaDataUpdateFactory getMetaDataUpdateFactory(MetaDataUpdate.InternalFactory metaDataUpdateInternalFactory, @Nullable IdentifiedUser currentUser, PersonIdent serverIdent, String serverId, String anonymousCowardName) {
    return (projectName, repository, batchRefUpdate) -> {
        MetaDataUpdate metaDataUpdate = metaDataUpdateInternalFactory.create(projectName, repository, batchRefUpdate);
        metaDataUpdate.getCommitBuilder().setCommitter(serverIdent);
        PersonIdent authorIdent;
        if (currentUser != null) {
            metaDataUpdate.setAuthor(currentUser);
            authorIdent = getAuditLogAuthorIdent(currentUser.getAccount(), serverIdent, serverId, anonymousCowardName);
        } else {
            authorIdent = serverIdent;
        }
        metaDataUpdate.getCommitBuilder().setAuthor(authorIdent);
        return metaDataUpdate;
    };
}
#method_after
private static MetaDataUpdateFactory getMetaDataUpdateFactory(MetaDataUpdate.InternalFactory metaDataUpdateInternalFactory, @Nullable IdentifiedUser currentUser, PersonIdent serverIdent, AuditLogFormatter auditLogFormatter) {
    return (projectName, repository, batchRefUpdate) -> {
        MetaDataUpdate metaDataUpdate = metaDataUpdateInternalFactory.create(projectName, repository, batchRefUpdate);
        metaDataUpdate.getCommitBuilder().setCommitter(serverIdent);
        PersonIdent authorIdent;
        if (currentUser != null) {
            metaDataUpdate.setAuthor(currentUser);
            authorIdent = auditLogFormatter.getParsableAuthorIdent(currentUser.getAccount(), serverIdent);
        } else {
            authorIdent = serverIdent;
        }
        metaDataUpdate.getCommitBuilder().setAuthor(authorIdent);
        return metaDataUpdate;
    };
}
#end_block

#method_before
public InternalGroup createGroup(ReviewDb db, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws OrmException, IOException, ConfigInvalidException {
    InternalGroup createdGroupInReviewDb = createGroupInReviewDb(db, groupCreation, groupUpdate);
    if (!writeGroupsToNoteDb) {
        updateCachesOnGroupCreation(createdGroupInReviewDb);
        return createdGroupInReviewDb;
    }
    // TODO(aliceks): Add retry mechanism.
    InternalGroup createdGroup = createGroupInNoteDb(groupCreation, groupUpdate);
    updateCachesOnGroupCreation(createdGroup);
    return createdGroup;
}
#method_after
public InternalGroup createGroup(ReviewDb db, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws OrmException, IOException, ConfigInvalidException {
    if (!groupsMigration.disableGroupReviewDb()) {
        if (!groupUpdate.getUpdatedOn().isPresent()) {
            // Set updatedOn to a specific value so that the same timestamp is used for ReviewDb and
            // NoteDb.
            groupUpdate = groupUpdate.toBuilder().setUpdatedOn(TimeUtil.nowTs()).build();
        }
        InternalGroup createdGroupInReviewDb = createGroupInReviewDb(ReviewDbUtil.unwrapDb(db), groupCreation, groupUpdate);
        if (!groupsMigration.writeToNoteDb()) {
            updateCachesOnGroupCreation(createdGroupInReviewDb);
            dispatchAuditEventsOnGroupCreation(createdGroupInReviewDb);
            return createdGroupInReviewDb;
        }
    }
    InternalGroup createdGroup = createGroupInNoteDbWithRetry(groupCreation, groupUpdate);
    updateCachesOnGroupCreation(createdGroup);
    dispatchAuditEventsOnGroupCreation(createdGroup);
    return createdGroup;
}
#end_block

#method_before
public void updateGroup(ReviewDb db, AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws OrmException, IOException, NoSuchGroupException, ConfigInvalidException {
    UpdateResult result = updateGroupInDb(db, groupUuid, groupUpdate);
    updateCachesOnGroupUpdate(result);
}
#method_after
public void updateGroup(ReviewDb db, AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws OrmException, IOException, NoSuchGroupException, ConfigInvalidException {
    Optional<Timestamp> updatedOn = groupUpdate.getUpdatedOn();
    if (!updatedOn.isPresent()) {
        // Set updatedOn to a specific value so that the same timestamp is used for ReviewDb and
        // NoteDb. This timestamp is also used by audit events.
        updatedOn = Optional.of(TimeUtil.nowTs());
        groupUpdate = groupUpdate.toBuilder().setUpdatedOn(updatedOn.get()).build();
    }
    UpdateResult result = updateGroupInDb(db, groupUuid, groupUpdate);
    updateCachesOnGroupUpdate(result);
    dispatchAuditEventsOnGroupUpdate(result, updatedOn.get());
}
#end_block

#method_before
@VisibleForTesting
public UpdateResult updateGroupInDb(ReviewDb db, AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws OrmException, NoSuchGroupException, IOException, ConfigInvalidException {
    AccountGroup group = getExistingGroupFromReviewDb(db, groupUuid);
    UpdateResult reviewDbUpdateResult = updateGroupInReviewDb(db, group, groupUpdate);
    if (!writeGroupsToNoteDb) {
        return reviewDbUpdateResult;
    }
    // TODO(aliceks): Add retry mechanism.
    Optional<UpdateResult> noteDbUpdateResult = updateGroupInNoteDb(groupUuid, groupUpdate);
    return noteDbUpdateResult.orElse(reviewDbUpdateResult);
}
#method_after
@VisibleForTesting
public UpdateResult updateGroupInDb(ReviewDb db, AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws OrmException, NoSuchGroupException, IOException, ConfigInvalidException {
    UpdateResult reviewDbUpdateResult = null;
    if (!groupsMigration.disableGroupReviewDb()) {
        AccountGroup group = getExistingGroupFromReviewDb(ReviewDbUtil.unwrapDb(db), groupUuid);
        reviewDbUpdateResult = updateGroupInReviewDb(ReviewDbUtil.unwrapDb(db), group, groupUpdate);
        if (!groupsMigration.writeToNoteDb()) {
            return reviewDbUpdateResult;
        }
    }
    Optional<UpdateResult> noteDbUpdateResult = updateGroupInNoteDbWithRetry(groupUuid, groupUpdate);
    return noteDbUpdateResult.orElse(reviewDbUpdateResult);
}
#end_block

#method_before
private InternalGroup createGroupInReviewDb(ReviewDb db, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroupName gn = new AccountGroupName(groupCreation.getNameKey(), groupCreation.getId());
    // first insert the group name to validate that the group name hasn't
    // already been used to create another group
    db.accountGroupNames().insert(ImmutableList.of(gn));
    AccountGroup group = createAccountGroup(groupCreation);
    UpdateResult updateResult = updateGroupInReviewDb(db, group, groupUpdate);
    return InternalGroup.create(group, updateResult.getModifiedMembers(), updateResult.getModifiedSubgroups(), updateResult.getRefState());
}
#method_after
private InternalGroup createGroupInReviewDb(ReviewDb db, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroupName gn = new AccountGroupName(groupCreation.getNameKey(), groupCreation.getId());
    // first insert the group name to validate that the group name hasn't
    // already been used to create another group
    db.accountGroupNames().insert(ImmutableList.of(gn));
    Timestamp createdOn = groupUpdate.getUpdatedOn().orElseGet(TimeUtil::nowTs);
    AccountGroup group = createAccountGroup(groupCreation, createdOn);
    UpdateResult updateResult = updateGroupInReviewDb(db, group, groupUpdate);
    return InternalGroup.create(group, updateResult.getAddedMembers(), updateResult.getAddedSubgroups(), updateResult.getRefState());
}
#end_block

#method_before
public static AccountGroup createAccountGroup(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) {
    AccountGroup group = createAccountGroup(groupCreation);
    applyUpdate(group, groupUpdate);
    return group;
}
#method_after
public static AccountGroup createAccountGroup(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) {
    Timestamp createdOn = groupUpdate.getUpdatedOn().orElseGet(TimeUtil::nowTs);
    AccountGroup group = createAccountGroup(groupCreation, createdOn);
    applyUpdate(group, groupUpdate);
    return group;
}
#end_block

#method_before
private static AccountGroup createAccountGroup(InternalGroupCreation groupCreation) {
    return new AccountGroup(groupCreation.getNameKey(), groupCreation.getId(), groupCreation.getGroupUUID(), groupCreation.getCreatedOn());
}
#method_after
private static AccountGroup createAccountGroup(InternalGroupCreation groupCreation, Timestamp createdOn) {
    return new AccountGroup(groupCreation.getNameKey(), groupCreation.getId(), groupCreation.getGroupUUID(), createdOn);
}
#end_block

#method_before
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#method_after
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> originalMembers = Groups.getMembersFromReviewDb(db, group.getId()).collect(toImmutableSet());
    ImmutableSet<Account.Id> updatedMembers = ImmutableSet.copyOf(groupUpdate.getMemberModification().apply(originalMembers));
    ImmutableSet<AccountGroup.UUID> originalSubgroups = Groups.getSubgroupsFromReviewDb(db, group.getId()).collect(toImmutableSet());
    ImmutableSet<AccountGroup.UUID> updatedSubgroups = ImmutableSet.copyOf(groupUpdate.getSubgroupModification().apply(originalSubgroups));
    Set<Account.Id> addedMembers = addGroupMembersInReviewDb(db, group.getId(), originalMembers, updatedMembers);
    Set<Account.Id> deletedMembers = deleteGroupMembersInReviewDb(db, group.getId(), originalMembers, updatedMembers);
    Set<AccountGroup.UUID> addedSubgroups = addSubgroupsInReviewDb(db, group.getId(), originalSubgroups, updatedSubgroups);
    Set<AccountGroup.UUID> deletedSubgroups = deleteSubgroupsInReviewDb(db, group.getId(), originalSubgroups, updatedSubgroups);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setAddedMembers(addedMembers).setDeletedMembers(deletedMembers).setAddedSubgroups(addedSubgroups).setDeletedSubgroups(deletedSubgroups);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private void addGroupMembersInReviewDb(ReviewDb db, AccountGroup.Id groupId, Set<Account.Id> newMemberIds) throws OrmException {
    Set<AccountGroupMember> newMembers = newMemberIds.stream().map(accountId -> new AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableSet());
    if (currentUser != null) {
        auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMembers);
    }
    db.accountGroupMembers().insert(newMembers);
}
#method_after
private static Set<Account.Id> addGroupMembersInReviewDb(ReviewDb db, AccountGroup.Id groupId, ImmutableSet<Account.Id> originalMembers, ImmutableSet<Account.Id> updatedMembers) throws OrmException {
    Set<Account.Id> accountIds = Sets.difference(updatedMembers, originalMembers);
    if (accountIds.isEmpty()) {
        return accountIds;
    }
    ImmutableSet<AccountGroupMember> newMembers = toAccountGroupMembers(groupId, accountIds);
    db.accountGroupMembers().insert(newMembers);
    return accountIds;
}
#end_block

#method_before
private void addSubgroupsInReviewDb(ReviewDb db, AccountGroup.Id parentGroupId, Set<AccountGroup.UUID> subgroupUuids) throws OrmException {
    Set<AccountGroupById> newSubgroups = subgroupUuids.stream().map(subgroupUuid -> new AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupById::new).collect(toImmutableSet());
    if (currentUser != null) {
        auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), newSubgroups);
    }
    db.accountGroupById().insert(newSubgroups);
}
#method_after
private static Set<AccountGroup.UUID> addSubgroupsInReviewDb(ReviewDb db, AccountGroup.Id parentGroupId, ImmutableSet<AccountGroup.UUID> originalSubgroups, ImmutableSet<AccountGroup.UUID> updatedSubgroups) throws OrmException {
    Set<AccountGroup.UUID> subgroupUuids = Sets.difference(updatedSubgroups, originalSubgroups);
    if (subgroupUuids.isEmpty()) {
        return subgroupUuids;
    }
    ImmutableSet<AccountGroupById> newSubgroups = toAccountGroupByIds(parentGroupId, subgroupUuids);
    db.accountGroupById().insert(newSubgroups);
    return subgroupUuids;
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#method_after
@VisibleForTesting
public InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.forNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
        groupConfig.setGroupUpdate(groupUpdate, auditLogFormatter);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#end_block

#method_before
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, groupUuid);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#method_after
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException, NoSuchGroupException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, groupUuid);
        groupConfig.setGroupUpdate(groupUpdate, auditLogFormatter);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            if (groupsMigration.readFromNoteDb()) {
                throw new NoSuchGroupException(groupUuid);
            }
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.forRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#end_block

#method_before
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setRefState(updatedGroup.getRefState());
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#method_after
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> addedMembers = Sets.difference(updatedGroup.getMembers(), originalGroup.getMembers());
    Set<Account.Id> deletedMembers = Sets.difference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> addedSubgroups = Sets.difference(updatedGroup.getSubgroups(), originalGroup.getSubgroups());
    Set<AccountGroup.UUID> deletedSubgroups = Sets.difference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setAddedMembers(addedMembers).setDeletedMembers(deletedMembers).setAddedSubgroups(addedSubgroups).setDeletedSubgroups(deletedSubgroups).setRefState(updatedGroup.getRefState());
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#end_block

#method_before
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    if (groupNameNotes != null) {
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
    }
    RefUpdateUtil.executeChecked(batchRefUpdate, allUsersRepo);
    gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.getAccount() : null);
}
#method_after
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    if (groupNameNotes != null) {
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
    }
    RefUpdateUtil.executeChecked(batchRefUpdate, allUsersRepo);
    gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.state() : null);
}
#end_block

#method_before
private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException {
    groupCache.onCreateGroup(createdGroup.getGroupUUID());
    for (Account.Id modifiedMember : createdGroup.getMembers()) {
        accountCache.evict(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : createdGroup.getSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#method_after
private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException {
    indexer.get().index(createdGroup.getGroupUUID());
    for (Account.Id modifiedMember : createdGroup.getMembers()) {
        groupIncludeCache.evictGroupsWithMember(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : createdGroup.getSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#end_block

#method_before
private void updateCachesOnGroupUpdate(UpdateResult result) throws IOException {
    if (result.getPreviousGroupName().isPresent()) {
        AccountGroup.NameKey previousName = result.getPreviousGroupName().get();
        groupCache.evictAfterRename(previousName);
        // TODO(aliceks): After switching to NoteDb, consider to use a BatchRefUpdate.
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = renameGroupOpFactory.create(authorIdent, result.getGroupUuid(), previousName.get(), result.getGroupName().get()).start(0, TimeUnit.MILLISECONDS);
    }
    groupCache.evict(result.getGroupUuid(), result.getGroupId(), result.getGroupName());
    for (Account.Id modifiedMember : result.getModifiedMembers()) {
        groupIncludeCache.evictGroupsWithMember(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : result.getModifiedSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#method_after
private void updateCachesOnGroupUpdate(UpdateResult result) throws IOException {
    if (result.getPreviousGroupName().isPresent()) {
        AccountGroup.NameKey previousName = result.getPreviousGroupName().get();
        groupCache.evict(previousName);
        // TODO(aliceks): After switching to NoteDb, consider to use a BatchRefUpdate.
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = renameGroupOpFactory.create(authorIdent, result.getGroupUuid(), previousName.get(), result.getGroupName().get()).start(0, TimeUnit.MILLISECONDS);
    }
    groupCache.evict(result.getGroupUuid());
    groupCache.evict(result.getGroupId());
    groupCache.evict(result.getGroupName());
    indexer.get().index(result.getGroupUuid());
    result.getAddedMembers().forEach(groupIncludeCache::evictGroupsWithMember);
    result.getDeletedMembers().forEach(groupIncludeCache::evictGroupsWithMember);
    result.getAddedSubgroups().forEach(groupIncludeCache::evictParentGroupsOf);
    result.getDeletedSubgroups().forEach(groupIncludeCache::evictParentGroupsOf);
}
#end_block

#method_before
@Test
public void basicGroupProperties() throws Exception {
    GroupInfo createdGroup = gApi.groups().create(name("group")).get();
    InternalGroup reviewDbGroup = groups.getGroup(db, new AccountGroup.UUID(createdGroup.id)).get();
    deleteGroupRefs(reviewDbGroup);
    assertThat(removeRefState(rebuild(reviewDbGroup))).isEqualTo(roundToSecond(reviewDbGroup));
}
#method_after
@Test
public void basicGroupProperties() throws Exception {
    GroupInfo createdGroup = gApi.groups().create(name("group")).get();
    GroupBundle reviewDbBundle = bundleFactory.fromReviewDb(db, new AccountGroup.Id(createdGroup.groupId));
    deleteGroupRefs(reviewDbBundle);
    assertMigratedCleanly(rebuild(reviewDbBundle), reviewDbBundle);
}
#end_block

#method_before
@Test
public void logFormat() throws Exception {
    TestAccount user2 = accountCreator.user2();
    GroupInfo group1 = gApi.groups().create(name("group1")).get();
    GroupInfo group2 = gApi.groups().create(name("group2")).get();
    try (TempClockStep step = TestTimeUtil.freezeClock()) {
        gApi.groups().id(group1.id).addMembers(user.id.toString(), user2.id.toString());
    }
    gApi.groups().id(group1.id).addGroups(group2.id);
    InternalGroup reviewDbGroup = groups.getGroup(db, new AccountGroup.UUID(group1.id)).get();
    deleteGroupRefs(reviewDbGroup);
    InternalGroup noteDbGroup = rebuild(reviewDbGroup);
    assertThat(removeRefState(noteDbGroup)).isEqualTo(roundToSecond(reviewDbGroup));
    ImmutableList<CommitInfo> log = log(group1);
    assertThat(log).hasSize(4);
    assertThat(log.get(0)).message().isEqualTo("Create group");
    assertThat(log.get(0)).author().name().isEqualTo(serverIdent.get().getName());
    assertThat(log.get(0)).author().email().isEqualTo(serverIdent.get().getEmailAddress());
    assertThat(log.get(0)).author().date().isEqualTo(noteDbGroup.getCreatedOn());
    assertThat(log.get(0)).author().tz().isEqualTo(serverIdent.get().getTimeZoneOffset());
    assertThat(log.get(0)).committer().isEqualTo(log.get(0).author);
    assertThat(log.get(1)).message().isEqualTo("Update group\n\nAdd: Administrator <" + admin.id + "@" + serverId + ">");
    assertThat(log.get(1)).author().name().isEqualTo(admin.fullName);
    assertThat(log.get(1)).author().email().isEqualTo(admin.id + "@" + serverId);
    assertThat(log.get(1)).committer().hasSameDateAs(log.get(1).author);
    assertThat(log.get(2)).message().isEqualTo("Update group\n" + "\n" + ("Add: User <" + user.id + "@" + serverId + ">\n") + ("Add: User2 <" + user2.id + "@" + serverId + ">"));
    assertThat(log.get(2)).author().name().isEqualTo(admin.fullName);
    assertThat(log.get(2)).author().email().isEqualTo(admin.id + "@" + serverId);
    assertThat(log.get(2)).committer().hasSameDateAs(log.get(2).author);
    assertThat(log.get(3)).message().isEqualTo("Update group\n\nAdd-group: " + group2.name + " <" + group2.id + ">");
    assertThat(log.get(3)).author().name().isEqualTo(admin.fullName);
    assertThat(log.get(3)).author().email().isEqualTo(admin.id + "@" + serverId);
    assertThat(log.get(3)).committer().hasSameDateAs(log.get(3).author);
}
#method_after
@Test
public void logFormat() throws Exception {
    TestAccount user2 = accountCreator.user2();
    GroupInfo group1 = gApi.groups().create(name("group1")).get();
    GroupInfo group2 = gApi.groups().create(name("group2")).get();
    try (TempClockStep step = TestTimeUtil.freezeClock()) {
        gApi.groups().id(group1.id).addMembers(user.id.toString(), user2.id.toString());
    }
    TimeUtil.nowTs();
    try (TempClockStep step = TestTimeUtil.freezeClock()) {
        gApi.groups().id(group1.id).addGroups(group2.id, SystemGroupBackend.REGISTERED_USERS.get());
    }
    GroupBundle reviewDbBundle = bundleFactory.fromReviewDb(db, new AccountGroup.Id(group1.groupId));
    deleteGroupRefs(reviewDbBundle);
    GroupBundle noteDbBundle = rebuild(reviewDbBundle);
    assertMigratedCleanly(noteDbBundle, reviewDbBundle);
    ImmutableList<CommitInfo> log = log(group1);
    assertThat(log).hasSize(4);
    assertThat(log.get(0)).message().isEqualTo("Create group");
    assertThat(log.get(0)).author().name().isEqualTo(serverIdent.get().getName());
    assertThat(log.get(0)).author().email().isEqualTo(serverIdent.get().getEmailAddress());
    assertThat(log.get(0)).author().date().isEqualTo(noteDbBundle.group().getCreatedOn());
    assertThat(log.get(0)).author().tz().isEqualTo(serverIdent.get().getTimeZoneOffset());
    assertThat(log.get(0)).committer().isEqualTo(log.get(0).author);
    assertThat(log.get(1)).message().isEqualTo("Update group\n\nAdd: Administrator <" + admin.id + "@" + serverId + ">");
    assertThat(log.get(1)).author().name().isEqualTo(admin.fullName);
    assertThat(log.get(1)).author().email().isEqualTo(admin.id + "@" + serverId);
    assertThat(log.get(1)).committer().hasSameDateAs(log.get(1).author);
    assertThat(log.get(2)).message().isEqualTo("Update group\n" + "\n" + ("Add: User <" + user.id + "@" + serverId + ">\n") + ("Add: User2 <" + user2.id + "@" + serverId + ">"));
    assertThat(log.get(2)).author().name().isEqualTo(admin.fullName);
    assertThat(log.get(2)).author().email().isEqualTo(admin.id + "@" + serverId);
    assertThat(log.get(2)).committer().hasSameDateAs(log.get(2).author);
    assertThat(log.get(3)).message().isEqualTo("Update group\n" + "\n" + ("Add-group: " + group2.name + " <" + group2.id + ">\n") + ("Add-group: Registered Users <global:Registered-Users>"));
    assertThat(log.get(3)).author().name().isEqualTo(admin.fullName);
    assertThat(log.get(3)).author().email().isEqualTo(admin.id + "@" + serverId);
    assertThat(log.get(3)).committer().hasSameDateAs(log.get(3).author);
}
#end_block

#method_before
private void deleteGroupRefs(InternalGroup group) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsGroups(group.getGroupUUID());
        RefUpdate ru = repo.updateRef(refName);
        ru.setForceUpdate(true);
        Ref oldRef = repo.exactRef(refName);
        if (oldRef == null) {
            return;
        }
        ru.setExpectedOldObjectId(oldRef.getObjectId());
        ru.setNewObjectId(ObjectId.zeroId());
        assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
}
#method_after
private void deleteGroupRefs(GroupBundle bundle) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsGroups(bundle.uuid());
        RefUpdate ru = repo.updateRef(refName);
        ru.setForceUpdate(true);
        Ref oldRef = repo.exactRef(refName);
        if (oldRef == null) {
            return;
        }
        ru.setExpectedOldObjectId(oldRef.getObjectId());
        ru.setNewObjectId(ObjectId.zeroId());
        assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
}
#end_block

#method_before
private InternalGroup rebuild(InternalGroup group) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        rebuilder.rebuild(repo, GroupBundle.fromReviewDb(db, group.getId()), null);
        GroupConfig groupConfig = GroupConfig.loadForGroup(repo, group.getGroupUUID());
        Optional<InternalGroup> result = groupConfig.getLoadedGroup();
        assertThat(result).isPresent();
        return result.get();
    }
}
#method_after
private GroupBundle rebuild(GroupBundle reviewDbBundle) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        rebuilder.rebuild(repo, reviewDbBundle, null);
        return bundleFactory.fromNoteDb(repo, reviewDbBundle.uuid());
    }
}
#end_block

#method_before
@Before
public void setUpMocks() {
    indexRestApiServlet = new IndexChangeRestApiServlet(indexerMock, schemaFactoryMock);
    id = Change.Id.parse(CHANGE_NUMBER);
    when(requestMock.getPathInfo()).thenReturn("/index/change/" + CHANGE_NUMBER);
    change = new Change(null, id, null, null, TimeUtil.nowTs());
}
#method_after
@Before
public void setUpMocks() {
    indexRestApiServlet = new IndexChangeRestApiServlet(indexerMock, schemaFactoryMock);
    id = new Change.Id(CHANGE_NUMBER);
    when(requestMock.getPathInfo()).thenReturn("/index/change/" + CHANGE_NUMBER);
    change = new Change(null, id, null, null, TimeUtil.nowTs());
}
#end_block

#method_before
@Before
public void setUpMocks() {
    servlet = new IndexGroupRestApiServlet(indexerMock);
    uuid = AccountGroup.UUID.parse(UUID);
    when(requestMock.getPathInfo()).thenReturn("/index/group/" + UUID);
}
#method_after
@Before
public void setUpMocks() {
    servlet = new IndexGroupRestApiServlet(indexerMock);
    uuid = new AccountGroup.UUID(UUID);
    when(requestMock.getPathInfo()).thenReturn("/index/group/" + UUID);
}
#end_block

#method_before
@Test
public void testEvictAccountsOK() throws Exception {
    Account.Id key = Account.Id.parse("123");
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.ACCOUNTS), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.ACCOUNTS, key)).isTrue();
}
#method_after
@Test
public void testEvictAccountsOK() throws Exception {
    Account.Id key = new Account.Id(123);
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.ACCOUNTS), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.ACCOUNTS, key)).isTrue();
}
#end_block

#method_before
@Test
public void testEvictGroupsOK() throws Exception {
    AccountGroup.Id key = AccountGroup.Id.parse("123");
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.GROUPS), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.GROUPS, key)).isTrue();
}
#method_after
@Test
public void testEvictGroupsOK() throws Exception {
    AccountGroup.Id key = new AccountGroup.Id(123);
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.GROUPS), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.GROUPS, key)).isTrue();
}
#end_block

#method_before
@Test
public void testEvictGroupsByIncludeOK() throws Exception {
    AccountGroup.UUID key = AccountGroup.UUID.parse("90b3042d9094a37985f3f9281391dbbe9a5addad");
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.GROUPS_BYINCLUDE), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.GROUPS_BYINCLUDE, key)).isTrue();
}
#method_after
@Test
public void testEvictGroupsByIncludeOK() throws Exception {
    AccountGroup.UUID key = new AccountGroup.UUID("90b3042d9094a37985f3f9281391dbbe9a5addad");
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.GROUPS_BYINCLUDE), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.GROUPS_BYINCLUDE, key)).isTrue();
}
#end_block

#method_before
@Test
public void testEvictGroupsMembersOK() throws Exception {
    AccountGroup.UUID key = AccountGroup.UUID.parse("90b3042d9094a37985f3f9281391dbbe9a5addad");
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.GROUPS_MEMBERS), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.GROUPS_MEMBERS, key)).isTrue();
}
#method_after
@Test
public void testEvictGroupsMembersOK() throws Exception {
    AccountGroup.UUID key = new AccountGroup.UUID("90b3042d9094a37985f3f9281391dbbe9a5addad");
    String keyJson = new GsonBuilder().create().toJson(key);
    when(httpSessionMock.post(buildCacheEndpoint(Constants.GROUPS_MEMBERS), keyJson)).thenReturn(new HttpResult(SUCCESSFUL, EMPTY_MSG));
    assertThat(forwarder.evict(Constants.GROUPS_MEMBERS, key)).isTrue();
}
#end_block

#method_before
@Test
public void addReviewers() throws Exception {
    RevCommit oldHead = getRemoteHead();
    TestAccount user2 = accounts.user2();
    Config cfg = new Config();
    cfg.setStringList(SECTION_FILTER, "*", KEY_REVIEWER, ImmutableList.of(user.email, user2.email));
    pushFactory.create(db, admin.getIdent(), testRepo, "Add reviewers", FILENAME, cfg.toText()).to(RefNames.REFS_CONFIG).assertOkStatus();
    testRepo.reset(oldHead);
    String changeId = createChange().getChangeId();
    Collection<AccountInfo> reviewers;
    // Repeat until the create patch set event is processed by the reviewers plugin
    do {
        reviewers = gApi.changes().id(changeId).get().reviewers.get(REVIEWER);
    } while (reviewers == null);
    assertThat(reviewers.stream().map(a -> a._accountId).collect(toSet())).containsExactlyElementsIn(ImmutableSet.of(admin.id.get(), user.id.get(), user2.id.get()));
}
#method_after
@Test
public void addReviewers() throws Exception {
    RevCommit oldHead = getRemoteHead();
    TestAccount user2 = accounts.user2();
    Config cfg = new Config();
    cfg.setStringList(SECTION_FILTER, "*", KEY_REVIEWER, ImmutableList.of(user.email, user2.email));
    pushFactory.create(db, admin.getIdent(), testRepo, "Add reviewers", FILENAME, cfg.toText()).to(RefNames.REFS_CONFIG).assertOkStatus();
    testRepo.reset(oldHead);
    String changeId = createChange().getChangeId();
    Collection<AccountInfo> reviewers;
    // Wait for 100 ms until the create patch set event
    // is processed by the reviewers plugin
    long wait = 0;
    do {
        reviewers = gApi.changes().id(changeId).get().reviewers.get(REVIEWER);
        if (reviewers == null) {
            Thread.sleep(10);
            wait += 10;
            if (wait > 100) {
                assert_().fail("Timeout of 100 ms exceeded");
            }
        }
    } while (reviewers == null);
    assertThat(reviewers.stream().map(a -> a._accountId).collect(toSet())).containsExactlyElementsIn(ImmutableSet.of(admin.id.get(), user.id.get(), user2.id.get()));
}
#end_block

#method_before
public ProjectResetter build() throws IOException {
    return new ProjectResetter(repoManager, allUsersName, accountCreator, accountCache, accountIndexer, projectCache, refsByProject);
}
#method_after
public ProjectResetter build(ProjectResetter.Config input) throws IOException {
    return new ProjectResetter(repoManager, allUsersName, accountCreator, accountCache, accountIndexer, projectCache, input.refsByProject);
}
#end_block

#method_before
@Override
protected ProjectResetter resetProjects(Builder resetter) throws IOException {
    // Without this caching these tests become much too slow.
    return resetter.build();
}
#method_after
@Override
protected ProjectResetter.Config resetProjects() {
    // Without this caching these tests become much too slow.
    return new ProjectResetter.Config();
}
#end_block

#method_before
@Test
public void indexingUpdatesTheIndex() throws Exception {
    Account.Id accountId = createAccount("foo");
    String preferredEmail = "foo@example.com";
    updateAccountWithoutCacheOrIndex(accountId, newAccountUpdate().setPreferredEmail(preferredEmail).build());
    assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty();
    accountIndexer.index(accountId);
    List<AccountState> matchedAccountSates = accountQueryProvider.get().byPreferredEmail(preferredEmail);
    assertThat(matchedAccountSates).hasSize(1);
    assertThat(matchedAccountSates.get(0).getAccount().getId()).isEqualTo(accountId);
}
#method_after
@Test
public void indexingUpdatesTheIndex() throws Exception {
    Account.Id accountId = createAccount("foo");
    String preferredEmail = "foo@example.com";
    updateAccountWithoutCacheOrIndex(accountId, newAccountUpdate().setPreferredEmail(preferredEmail).build());
    assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty();
    accountIndexer.index(accountId);
    List<AccountState> matchedAccountStates = accountQueryProvider.get().byPreferredEmail(preferredEmail);
    assertThat(matchedAccountStates).hasSize(1);
    assertThat(matchedAccountStates.get(0).getAccount().getId()).isEqualTo(accountId);
}
#end_block

#method_before
@Test
public void indexCannotBeCorruptedByStaleCache() throws Exception {
    Account.Id accountId = createAccount("foo");
    loadAccountToCache(accountId);
    String preferredEmail = "foo@example.com";
    updateAccountWithoutCacheOrIndex(accountId, newAccountUpdate().setPreferredEmail(preferredEmail).build());
    assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty();
    accountIndexer.index(accountId);
    List<AccountState> matchedAccountSates = accountQueryProvider.get().byPreferredEmail(preferredEmail);
    assertThat(matchedAccountSates).hasSize(1);
    assertThat(matchedAccountSates.get(0).getAccount().getId()).isEqualTo(accountId);
}
#method_after
@Test
public void indexCannotBeCorruptedByStaleCache() throws Exception {
    Account.Id accountId = createAccount("foo");
    loadAccountToCache(accountId);
    String preferredEmail = "foo@example.com";
    updateAccountWithoutCacheOrIndex(accountId, newAccountUpdate().setPreferredEmail(preferredEmail).build());
    assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty();
    accountIndexer.index(accountId);
    List<AccountState> matchedAccountStates = accountQueryProvider.get().byPreferredEmail(preferredEmail);
    assertThat(matchedAccountStates).hasSize(1);
    assertThat(matchedAccountStates.get(0).getAccount().getId()).isEqualTo(accountId);
}
#end_block

#method_before
@Test
public void reindexingStaleAccountUpdatesTheIndex() throws Exception {
    Account.Id accountId = createAccount("foo");
    String preferredEmail = "foo@example.com";
    updateAccountWithoutCacheOrIndex(accountId, newAccountUpdate().setPreferredEmail(preferredEmail).build());
    assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty();
    accountIndexer.reindexIfStale(accountId);
    List<AccountState> matchedAccountSates = accountQueryProvider.get().byPreferredEmail(preferredEmail);
    assertThat(matchedAccountSates).hasSize(1);
    assertThat(matchedAccountSates.get(0).getAccount().getId()).isEqualTo(accountId);
}
#method_after
@Test
public void reindexingStaleAccountUpdatesTheIndex() throws Exception {
    Account.Id accountId = createAccount("foo");
    String preferredEmail = "foo@example.com";
    updateAccountWithoutCacheOrIndex(accountId, newAccountUpdate().setPreferredEmail(preferredEmail).build());
    assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty();
    accountIndexer.reindexIfStale(accountId);
    List<AccountState> matchedAccountStates = accountQueryProvider.get().byPreferredEmail(preferredEmail);
    assertThat(matchedAccountStates).hasSize(1);
    assertThat(matchedAccountStates.get(0).getAccount().getId()).isEqualTo(accountId);
}
#end_block

#method_before
private void updateAccountWithoutCacheOrIndex(Account.Id accountId, InternalAccountUpdate acountUpdate) throws IOException, ConfigInvalidException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo)) {
        PersonIdent ident = serverIdent.get();
        md.getCommitBuilder().setAuthor(ident);
        md.getCommitBuilder().setCommitter(ident);
        AccountConfig accountConfig = new AccountConfig(accountId, allUsersRepo).load();
        accountConfig.setAccountUpdate(acountUpdate);
        accountConfig.commit(md);
    }
}
#method_after
private void updateAccountWithoutCacheOrIndex(Account.Id accountId, InternalAccountUpdate accountUpdate) throws IOException, ConfigInvalidException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo)) {
        PersonIdent ident = serverIdent.get();
        md.getCommitBuilder().setAuthor(ident);
        md.getCommitBuilder().setCommitter(ident);
        AccountConfig accountConfig = new AccountConfig(accountId, allUsersRepo).load();
        accountConfig.setAccountUpdate(accountUpdate);
        accountConfig.commit(md);
    }
}
#end_block

#method_before
@Test
public void resetAllRefs() throws Exception {
    Ref matchingRef = createRef("refs/any/test");
    try (ProjectResetter resetProject = builder().reset(project).build()) {
        updateRef(matchingRef);
    }
    // The matching refs are reset to the old state.
    assertRef(matchingRef);
}
#method_after
@Test
public void resetAllRefs() throws Exception {
    Ref matchingRef = createRef("refs/any/test");
    try (ProjectResetter resetProject = builder().build(new ProjectResetter.Config().reset(project))) {
        updateRef(matchingRef);
    }
    // The matching refs are reset to the old state.
    assertRef(matchingRef);
}
#end_block

#method_before
@Test
public void onlyResetMatchingRefs() throws Exception {
    Ref matchingRef = createRef("refs/match/test");
    Ref anotherMatchingRef = createRef("refs/another-match/test");
    Ref nonMatchingRef = createRef("refs/no-match/test");
    Ref updatedNonMatchingRef;
    try (ProjectResetter resetProject = builder().reset(project, "refs/match/*", "refs/another-match/*").build()) {
        updateRef(matchingRef);
        updateRef(anotherMatchingRef);
        updatedNonMatchingRef = updateRef(nonMatchingRef);
    }
    // The matching refs are reset to the old state.
    assertRef(matchingRef);
    assertRef(anotherMatchingRef);
    // The non-matching ref is not reset, hence it still has the updated state.
    assertRef(updatedNonMatchingRef);
}
#method_after
@Test
public void onlyResetMatchingRefs() throws Exception {
    Ref matchingRef = createRef("refs/match/test");
    Ref anotherMatchingRef = createRef("refs/another-match/test");
    Ref nonMatchingRef = createRef("refs/no-match/test");
    Ref updatedNonMatchingRef;
    try (ProjectResetter resetProject = builder().build(new ProjectResetter.Config().reset(project, "refs/match/*", "refs/another-match/*"))) {
        updateRef(matchingRef);
        updateRef(anotherMatchingRef);
        updatedNonMatchingRef = updateRef(nonMatchingRef);
    }
    // The matching refs are reset to the old state.
    assertRef(matchingRef);
    assertRef(anotherMatchingRef);
    // The non-matching ref is not reset, hence it still has the updated state.
    assertRef(updatedNonMatchingRef);
}
#end_block

#method_before
@Test
public void onlyDeleteNewlyCreatedMatchingRefs() throws Exception {
    Ref matchingRef;
    Ref anotherMatchingRef;
    Ref nonMatchingRef;
    try (ProjectResetter resetProject = builder().reset(project, "refs/match/*", "refs/another-match/*").build()) {
        matchingRef = createRef("refs/match/test");
        anotherMatchingRef = createRef("refs/another-match/test");
        nonMatchingRef = createRef("refs/no-match/test");
    }
    // The matching refs are deleted since they didn't exist before.
    assertDeletedRef(matchingRef);
    assertDeletedRef(anotherMatchingRef);
    // The non-matching ref is not deleted.
    assertRef(nonMatchingRef);
}
#method_after
@Test
public void onlyDeleteNewlyCreatedMatchingRefs() throws Exception {
    Ref matchingRef;
    Ref anotherMatchingRef;
    Ref nonMatchingRef;
    try (ProjectResetter resetProject = builder().build(new ProjectResetter.Config().reset(project, "refs/match/*", "refs/another-match/*"))) {
        matchingRef = createRef("refs/match/test");
        anotherMatchingRef = createRef("refs/another-match/test");
        nonMatchingRef = createRef("refs/no-match/test");
    }
    // The matching refs are deleted since they didn't exist before.
    assertDeletedRef(matchingRef);
    assertDeletedRef(anotherMatchingRef);
    // The non-matching ref is not deleted.
    assertRef(nonMatchingRef);
}
#end_block

#method_before
@Test
public void onlyResetMatchingRefsMultipleProjects() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    Ref matchingRefProject1 = createRef("refs/foo/test");
    Ref nonMatchingRefProject1 = createRef("refs/bar/test");
    Ref matchingRefProject2 = createRef(repo2, "refs/bar/test");
    Ref nonMatchingRefProject2 = createRef(repo2, "refs/foo/test");
    Ref updatedNonMatchingRefProject1;
    Ref updatedNonMatchingRefProject2;
    try (ProjectResetter resetProject = builder().reset(project, "refs/foo/*").reset(project2, "refs/bar/*").build()) {
        updateRef(matchingRefProject1);
        updatedNonMatchingRefProject1 = updateRef(nonMatchingRefProject1);
        updateRef(repo2, matchingRefProject2);
        updatedNonMatchingRefProject2 = updateRef(repo2, nonMatchingRefProject2);
    }
    // The matching refs are reset to the old state.
    assertRef(matchingRefProject1);
    assertRef(repo2, matchingRefProject2);
    // The non-matching refs are not reset, hence they still has the updated states.
    assertRef(updatedNonMatchingRefProject1);
    assertRef(repo2, updatedNonMatchingRefProject2);
}
#method_after
@Test
public void onlyResetMatchingRefsMultipleProjects() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    Ref matchingRefProject1 = createRef("refs/foo/test");
    Ref nonMatchingRefProject1 = createRef("refs/bar/test");
    Ref matchingRefProject2 = createRef(repo2, "refs/bar/test");
    Ref nonMatchingRefProject2 = createRef(repo2, "refs/foo/test");
    Ref updatedNonMatchingRefProject1;
    Ref updatedNonMatchingRefProject2;
    try (ProjectResetter resetProject = builder().build(new ProjectResetter.Config().reset(project, "refs/foo/*").reset(project2, "refs/bar/*"))) {
        updateRef(matchingRefProject1);
        updatedNonMatchingRefProject1 = updateRef(nonMatchingRefProject1);
        updateRef(repo2, matchingRefProject2);
        updatedNonMatchingRefProject2 = updateRef(repo2, nonMatchingRefProject2);
    }
    // The matching refs are reset to the old state.
    assertRef(matchingRefProject1);
    assertRef(repo2, matchingRefProject2);
    // The non-matching refs are not reset, hence they still has the updated states.
    assertRef(updatedNonMatchingRefProject1);
    assertRef(repo2, updatedNonMatchingRefProject2);
}
#end_block

#method_before
@Test
public void onlyDeleteNewlyCreatedMatchingRefsMultipleProjects() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    Ref matchingRefProject1;
    Ref nonMatchingRefProject1;
    Ref matchingRefProject2;
    Ref nonMatchingRefProject2;
    try (ProjectResetter resetProject = builder().reset(project, "refs/foo/*").reset(project2, "refs/bar/*").build()) {
        matchingRefProject1 = createRef("refs/foo/test");
        nonMatchingRefProject1 = createRef("refs/bar/test");
        matchingRefProject2 = createRef(repo2, "refs/bar/test");
        nonMatchingRefProject2 = createRef(repo2, "refs/foo/test");
    }
    // The matching refs are deleted since they didn't exist before.
    assertDeletedRef(matchingRefProject1);
    assertDeletedRef(repo2, matchingRefProject2);
    // The non-matching ref is not deleted.
    assertRef(nonMatchingRefProject1);
    assertRef(repo2, nonMatchingRefProject2);
}
#method_after
@Test
public void onlyDeleteNewlyCreatedMatchingRefsMultipleProjects() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    Ref matchingRefProject1;
    Ref nonMatchingRefProject1;
    Ref matchingRefProject2;
    Ref nonMatchingRefProject2;
    try (ProjectResetter resetProject = builder().build(new ProjectResetter.Config().reset(project, "refs/foo/*").reset(project2, "refs/bar/*"))) {
        matchingRefProject1 = createRef("refs/foo/test");
        nonMatchingRefProject1 = createRef("refs/bar/test");
        matchingRefProject2 = createRef(repo2, "refs/bar/test");
        nonMatchingRefProject2 = createRef(repo2, "refs/foo/test");
    }
    // The matching refs are deleted since they didn't exist before.
    assertDeletedRef(matchingRefProject1);
    assertDeletedRef(repo2, matchingRefProject2);
    // The non-matching ref is not deleted.
    assertRef(nonMatchingRefProject1);
    assertRef(repo2, nonMatchingRefProject2);
}
#end_block

#method_before
@Test
public void onlyDeleteNewlyCreatedWithOverlappingRefPatterns() throws Exception {
    Ref matchingRef;
    try (ProjectResetter resetProject = builder().reset(project, "refs/match/*", "refs/match/test").build()) {
        // This ref matches 2 ref pattern, ProjectResetter should try to delete it only once.
        matchingRef = createRef("refs/match/test");
    }
    // The matching ref is deleted since it didn't exist before.
    assertDeletedRef(matchingRef);
}
#method_after
@Test
public void onlyDeleteNewlyCreatedWithOverlappingRefPatterns() throws Exception {
    Ref matchingRef;
    try (ProjectResetter resetProject = builder().build(new ProjectResetter.Config().reset(project, "refs/match/*", "refs/match/test"))) {
        // This ref matches 2 ref pattern, ProjectResetter should try to delete it only once.
        matchingRef = createRef("refs/match/test");
    }
    // The matching ref is deleted since it didn't exist before.
    assertDeletedRef(matchingRef);
}
#end_block

#method_before
@Test
public void projectEvictionIfRefsMetaConfigIsReset() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    Ref metaConfig = createRef(repo2, RefNames.REFS_CONFIG);
    ProjectCache projectCache = EasyMock.createNiceMock(ProjectCache.class);
    projectCache.evict(project2);
    EasyMock.expectLastCall();
    EasyMock.replay(projectCache);
    Ref nonMetaConfig = createRef("refs/heads/master");
    try (ProjectResetter resetProject = builder(null, null, null, projectCache).reset(project).reset(project2).build()) {
        updateRef(nonMetaConfig);
        updateRef(repo2, metaConfig);
    }
    EasyMock.verify(projectCache);
}
#method_after
@Test
public void projectEvictionIfRefsMetaConfigIsReset() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    Ref metaConfig = createRef(repo2, RefNames.REFS_CONFIG);
    ProjectCache projectCache = EasyMock.createNiceMock(ProjectCache.class);
    projectCache.evict(project2);
    EasyMock.expectLastCall();
    EasyMock.replay(projectCache);
    Ref nonMetaConfig = createRef("refs/heads/master");
    try (ProjectResetter resetProject = builder(null, null, null, projectCache).build(new ProjectResetter.Config().reset(project).reset(project2))) {
        updateRef(nonMetaConfig);
        updateRef(repo2, metaConfig);
    }
    EasyMock.verify(projectCache);
}
#end_block

#method_before
@Test
public void projectEvictionIfRefsMetaConfigIsDeleted() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    ProjectCache projectCache = EasyMock.createNiceMock(ProjectCache.class);
    projectCache.evict(project2);
    EasyMock.expectLastCall();
    EasyMock.replay(projectCache);
    try (ProjectResetter resetProject = builder(null, null, null, projectCache).reset(project).reset(project2).build()) {
        createRef("refs/heads/master");
        createRef(repo2, RefNames.REFS_CONFIG);
    }
    EasyMock.verify(projectCache);
}
#method_after
@Test
public void projectEvictionIfRefsMetaConfigIsDeleted() throws Exception {
    Project.NameKey project2 = new Project.NameKey("bar");
    Repository repo2 = repoManager.createRepository(project2);
    ProjectCache projectCache = EasyMock.createNiceMock(ProjectCache.class);
    projectCache.evict(project2);
    EasyMock.expectLastCall();
    EasyMock.replay(projectCache);
    try (ProjectResetter resetProject = builder(null, null, null, projectCache).build(new ProjectResetter.Config().reset(project).reset(project2))) {
        createRef("refs/heads/master");
        createRef(repo2, RefNames.REFS_CONFIG);
    }
    EasyMock.verify(projectCache);
}
#end_block

#method_before
@Test
public void accountEvictionIfUserBranchIsReset() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    Ref userBranch = createRef(allUsersRepo, RefNames.refsUsers(accountId));
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    // Non-user branch because it's not in All-Users.
    Ref nonUserBranch = createRef(RefNames.refsUsers(new Account.Id(2)));
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).reset(project).reset(allUsers).build()) {
        updateRef(nonUserBranch);
        updateRef(allUsersRepo, userBranch);
    }
    EasyMock.verify(accountCache);
}
#method_after
@Test
public void accountEvictionIfUserBranchIsReset() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    Ref userBranch = createRef(allUsersRepo, RefNames.refsUsers(accountId));
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    // Non-user branch because it's not in All-Users.
    Ref nonUserBranch = createRef(RefNames.refsUsers(new Account.Id(2)));
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).build(new ProjectResetter.Config().reset(project).reset(allUsers))) {
        updateRef(nonUserBranch);
        updateRef(allUsersRepo, userBranch);
    }
    EasyMock.verify(accountCache, accountIndexer);
}
#end_block

#method_before
@Test
public void accountEvictionIfUserBranchIsDeleted() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).reset(project).reset(allUsers).build()) {
        // Non-user branch because it's not in All-Users.
        createRef(RefNames.refsUsers(new Account.Id(2)));
        createRef(allUsersRepo, RefNames.refsUsers(accountId));
    }
    EasyMock.verify(accountCache);
}
#method_after
@Test
public void accountEvictionIfUserBranchIsDeleted() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).build(new ProjectResetter.Config().reset(project).reset(allUsers))) {
        // Non-user branch because it's not in All-Users.
        createRef(RefNames.refsUsers(new Account.Id(2)));
        createRef(allUsersRepo, RefNames.refsUsers(accountId));
    }
    EasyMock.verify(accountCache, accountIndexer);
}
#end_block

#method_before
@Test
public void accountEvictionIfExternalIdsBranchIsReset() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    Ref externalIds = createRef(allUsersRepo, RefNames.REFS_EXTERNAL_IDS);
    createRef(allUsersRepo, RefNames.refsUsers(accountId));
    Account.Id accountId2 = new Account.Id(2);
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    accountCache.evict(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    accountIndexer.index(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    // Non-user branch because it's not in All-Users.
    Ref nonUserBranch = createRef(RefNames.refsUsers(new Account.Id(3)));
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).reset(project).reset(allUsers).build()) {
        updateRef(nonUserBranch);
        updateRef(allUsersRepo, externalIds);
        createRef(allUsersRepo, RefNames.refsUsers(accountId2));
    }
    EasyMock.verify(accountCache);
}
#method_after
@Test
public void accountEvictionIfExternalIdsBranchIsReset() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    Ref externalIds = createRef(allUsersRepo, RefNames.REFS_EXTERNAL_IDS);
    createRef(allUsersRepo, RefNames.refsUsers(accountId));
    Account.Id accountId2 = new Account.Id(2);
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    accountCache.evict(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    accountIndexer.index(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    // Non-user branch because it's not in All-Users.
    Ref nonUserBranch = createRef(RefNames.refsUsers(new Account.Id(3)));
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).build(new ProjectResetter.Config().reset(project).reset(allUsers))) {
        updateRef(nonUserBranch);
        updateRef(allUsersRepo, externalIds);
        createRef(allUsersRepo, RefNames.refsUsers(accountId2));
    }
    EasyMock.verify(accountCache, accountIndexer);
}
#end_block

#method_before
@Test
public void accountEvictionIfExternalIdsBranchIsDeleted() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    createRef(allUsersRepo, RefNames.refsUsers(accountId));
    Account.Id accountId2 = new Account.Id(2);
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    accountCache.evict(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    accountIndexer.index(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    // Non-user branch because it's not in All-Users.
    Ref nonUserBranch = createRef(RefNames.refsUsers(new Account.Id(3)));
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).reset(project).reset(allUsers).build()) {
        updateRef(nonUserBranch);
        createRef(allUsersRepo, RefNames.REFS_EXTERNAL_IDS);
        createRef(allUsersRepo, RefNames.refsUsers(accountId2));
    }
    EasyMock.verify(accountCache);
}
#method_after
@Test
public void accountEvictionIfExternalIdsBranchIsDeleted() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    createRef(allUsersRepo, RefNames.refsUsers(accountId));
    Account.Id accountId2 = new Account.Id(2);
    AccountCache accountCache = EasyMock.createNiceMock(AccountCache.class);
    accountCache.evict(accountId);
    EasyMock.expectLastCall();
    accountCache.evict(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountCache);
    AccountIndexer accountIndexer = EasyMock.createNiceMock(AccountIndexer.class);
    accountIndexer.index(accountId);
    EasyMock.expectLastCall();
    accountIndexer.index(accountId2);
    EasyMock.expectLastCall();
    EasyMock.replay(accountIndexer);
    // Non-user branch because it's not in All-Users.
    Ref nonUserBranch = createRef(RefNames.refsUsers(new Account.Id(3)));
    try (ProjectResetter resetProject = builder(null, accountCache, accountIndexer, null).build(new ProjectResetter.Config().reset(project).reset(allUsers))) {
        updateRef(nonUserBranch);
        createRef(allUsersRepo, RefNames.REFS_EXTERNAL_IDS);
        createRef(allUsersRepo, RefNames.refsUsers(accountId2));
    }
    EasyMock.verify(accountCache, accountIndexer);
}
#end_block

#method_before
@Test
public void accountEvictionFromAccountCreatorIfUserBranchIsDeleted() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    AccountCreator accountCreator = EasyMock.createNiceMock(AccountCreator.class);
    accountCreator.evict(ImmutableSet.of(accountId));
    EasyMock.expectLastCall();
    EasyMock.replay(accountCreator);
    try (ProjectResetter resetProject = builder(accountCreator, null, null, null).reset(project).reset(allUsers).build()) {
        createRef(allUsersRepo, RefNames.refsUsers(accountId));
    }
    EasyMock.verify(accountCreator);
}
#method_after
@Test
public void accountEvictionFromAccountCreatorIfUserBranchIsDeleted() throws Exception {
    Account.Id accountId = new Account.Id(1);
    Project.NameKey allUsers = new Project.NameKey(AllUsersNameProvider.DEFAULT);
    Repository allUsersRepo = repoManager.createRepository(allUsers);
    AccountCreator accountCreator = EasyMock.createNiceMock(AccountCreator.class);
    accountCreator.evict(ImmutableSet.of(accountId));
    EasyMock.expectLastCall();
    EasyMock.replay(accountCreator);
    try (ProjectResetter resetProject = builder(accountCreator, null, null, null).build(new ProjectResetter.Config().reset(project).reset(allUsers))) {
        createRef(allUsersRepo, RefNames.refsUsers(accountId));
    }
    EasyMock.verify(accountCreator);
}
#end_block

#method_before
protected ProjectResetter resetProjects(ProjectResetter.Builder resetter) throws IOException {
    return resetter.reset(allProjects, RefNames.REFS_CONFIG).reset(allUsers, RefNames.REFS_CONFIG, RefNames.REFS_USERS + "*", RefNames.REFS_EXTERNAL_IDS, RefNames.REFS_STARRED_CHANGES + "*", RefNames.REFS_DRAFT_COMMENTS + "*").build();
}
#method_after
protected ProjectResetter.Config resetProjects() {
    return null;
}
#end_block

#method_before
private void process(HttpServletRequest req, HttpServletResponse rsp, Operation operation) {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding(UTF_8.name());
    String path = req.getPathInfo();
    T id = parse(path.substring(path.lastIndexOf('/') + 1));
    logger.debug("{} {} {}", operation, indexName, id);
    try {
        Context.setForwardedEvent(true);
        Lock idLock = idLocks.get(id);
        idLock.lock();
        try {
            index(id, operation);
        } finally {
            idLock.unlock();
        }
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        sendError(rsp, SC_CONFLICT, e.getMessage());
        logger.error("Unable to update {} index", indexName, e);
    } catch (OrmException e) {
        String msg = String.format("Error trying to find %s \n", indexName);
        sendError(rsp, SC_NOT_FOUND, msg);
        logger.debug(msg, e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#method_after
private void process(HttpServletRequest req, HttpServletResponse rsp, Operation operation) {
    setHeaders(rsp);
    String path = req.getPathInfo();
    T id = parse(path.substring(path.lastIndexOf('/') + 1));
    logger.debug("{} {} {}", operation, indexName, id);
    try {
        Context.setForwardedEvent(true);
        Lock idLock = idLocks.get(id);
        idLock.lock();
        try {
            index(id, operation);
        } finally {
            idLock.unlock();
        }
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        sendError(rsp, SC_CONFLICT, e.getMessage());
        logger.error("Unable to update {} index", indexName, e);
    } catch (OrmException e) {
        String msg = String.format("Error trying to find %s \n", indexName);
        sendError(rsp, SC_NOT_FOUND, msg);
        logger.debug(msg, e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) {
    setContentAndEncoding(rsp);
    try {
        List<String> params = Splitter.on('/').splitToList(req.getPathInfo());
        String cacheName = params.get(CACHENAME_INDEX);
        String json = req.getReader().readLine();
        forwardedCacheEvictionHandler.evict(CacheEntry.from(cacheName, GsonParser.fromJson(cacheName, json)));
        rsp.setStatus(SC_NO_CONTENT);
    } catch (CacheNotFoundException e) {
        logger.error("Failed to process eviction request: {}", e.getMessage());
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } catch (IOException e) {
        logger.error("Failed to process eviction request: {}", e.getMessage(), e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) {
    setHeaders(rsp);
    try {
        List<String> params = Splitter.on('/').splitToList(req.getPathInfo());
        String cacheName = params.get(CACHENAME_INDEX);
        String json = req.getReader().readLine();
        forwardedCacheEvictionHandler.evict(CacheEntry.from(cacheName, GsonParser.fromJson(cacheName, json)));
        rsp.setStatus(SC_NO_CONTENT);
    } catch (CacheNotFoundException e) {
        logger.error("Failed to process eviction request: {}", e.getMessage());
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } catch (IOException e) {
        logger.error("Failed to process eviction request: {}", e.getMessage(), e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) {
    setContentAndEncoding(rsp);
    try {
        if (!MediaType.parse(req.getContentType()).is(JSON_UTF_8)) {
            sendError(rsp, SC_UNSUPPORTED_MEDIA_TYPE, "Expecting " + JSON_UTF_8.toString() + " content type");
            return;
        }
        forwardedEventHandler.dispatch(getEventFromRequest(req));
        rsp.setStatus(SC_NO_CONTENT);
    } catch (OrmException e) {
        logger.debug("Error trying to find a change ", e);
        sendError(rsp, SC_NOT_FOUND, "Change not found\n");
    } catch (IOException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) {
    setHeaders(rsp);
    try {
        if (!MediaType.parse(req.getContentType()).is(JSON_UTF_8)) {
            sendError(rsp, SC_UNSUPPORTED_MEDIA_TYPE, "Expecting " + JSON_UTF_8.toString() + " content type");
            return;
        }
        forwardedEventHandler.dispatch(getEventFromRequest(req));
        rsp.setStatus(SC_NO_CONTENT);
    } catch (OrmException e) {
        logger.debug("Error trying to find a change ", e);
        sendError(rsp, SC_NOT_FOUND, "Change not found\n");
    } catch (IOException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    }
}
#end_block

#method_before
@Override
public void run() throws IOException {
    IndexType type = IndexType.LUCENE;
    if (IndexType.values().length > 1) {
        ui.header("Index");
        type = index.select("Type", "type", type);
    }
    if (type == IndexType.ELASTICSEARCH) {
        String name = index.string("Index Name", "name", "gerrit");
        Section elasticsearch = sections.get("elasticsearch", name);
        elasticsearch.select("Transport protocol", "protocol", "http", Sets.newHashSet("http", "https"));
        elasticsearch.string("Hostname", "hostname", "localhost");
        elasticsearch.string("Port", "port", "9200");
    }
    if ((site.isNew || isEmptySite()) && type == IndexType.LUCENE) {
        for (SchemaDefinitions<?> def : IndexModule.ALL_SCHEMA_DEFS) {
            IndexUtils.setReady(site, def.getName(), def.getLatest().getVersion(), true);
        }
    } else {
        if (IndexType.values().length <= 1) {
            ui.header("Index");
        }
        String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#method_after
@Override
public void run() throws IOException {
    IndexType type = IndexType.LUCENE;
    if (IndexType.values().length > 1) {
        ui.header("Index");
        type = index.select("Type", "type", type);
    }
    if (type == IndexType.ELASTICSEARCH) {
        Section elasticsearch = sections.get("elasticsearch", null);
        elasticsearch.string("Index Prefix", "prefix", "gerrit");
        String name = ui.readString("default", "Server Name");
        Section defaultServer = sections.get("elasticsearch", name);
        defaultServer.select("Transport protocol", "protocol", "http", Sets.newHashSet("http", "https"));
        defaultServer.string("Hostname", "hostname", "localhost");
        defaultServer.string("Port", "port", "9200");
    }
    if ((site.isNew || isEmptySite()) && type == IndexType.LUCENE) {
        for (SchemaDefinitions<?> def : IndexModule.ALL_SCHEMA_DEFS) {
            IndexUtils.setReady(site, def.getName(), def.getLatest().getVersion(), true);
        }
    } else {
        if (IndexType.values().length <= 1) {
            ui.header("Index");
        }
        String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#end_block

#method_before
private InternalGroup rebuild(InternalGroup group) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        rebuilder.rebuild(repo, GroupBundle.fromReviewDb(db, group.getId()));
        GroupConfig groupConfig = GroupConfig.loadForGroup(repo, group.getGroupUUID());
        Optional<InternalGroup> result = groupConfig.getLoadedGroup();
        assertThat(result).isPresent();
        return result.get();
    }
}
#method_after
private InternalGroup rebuild(InternalGroup group) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        rebuilder.rebuild(repo, GroupBundle.fromReviewDb(db, group.getId()), null);
        GroupConfig groupConfig = GroupConfig.loadForGroup(repo, group.getGroupUUID());
        Optional<InternalGroup> result = groupConfig.getLoadedGroup();
        assertThat(result).isPresent();
        return result.get();
    }
}
#end_block

#method_before
@Test
@Sandboxed
public void blockReviewDbUpdatesOnGroupCreation() throws Exception {
    assume().that(groupsInNoteDb()).isFalse();
    cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true);
    expectWriteGroupToReviewDbBlockedException();
    gApi.groups().create(name("foo"));
}
#method_after
@Test
@Sandboxed
public void blockReviewDbUpdatesOnGroupCreation() throws Exception {
    assume().that(groupsInNoteDb()).isFalse();
    cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true);
    try {
        gApi.groups().create(name("foo"));
        fail("Expected RestApiException: Updates to groups in ReviewDb are blocked");
    } catch (RestApiException e) {
        assertWriteGroupToReviewDbBlockedException(e);
    }
}
#end_block

#method_before
@Test
@Sandboxed
public void blockReviewDbUpdatesOnGroupUpdate() throws Exception {
    assume().that(groupsInNoteDb()).isFalse();
    String group1 = gApi.groups().create(name("foo")).get().id;
    String group2 = gApi.groups().create(name("bar")).get().id;
    cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true);
    expectWriteGroupToReviewDbBlockedException();
    gApi.groups().id(group1).addGroups(group2);
}
#method_after
@Test
@Sandboxed
public void blockReviewDbUpdatesOnGroupUpdate() throws Exception {
    assume().that(groupsInNoteDb()).isFalse();
    String group1 = gApi.groups().create(name("foo")).get().id;
    String group2 = gApi.groups().create(name("bar")).get().id;
    cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true);
    try {
        gApi.groups().id(group1).addGroups(group2);
        fail("Expected RestApiException: Updates to groups in ReviewDb are blocked");
    } catch (RestApiException e) {
        assertWriteGroupToReviewDbBlockedException(e);
    }
}
#end_block

#method_before
@Test
public void stalenessChecker() throws Exception {
    assume().that(groupsInNoteDb()).isTrue();
    // Newly created group is not stale
    GroupInfo groupInfo = gApi.groups().create(name("foo")).get();
    AccountGroup.UUID groupUuid = new AccountGroup.UUID(groupInfo.id);
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
    // Manual update makes index document stale
    String groupRef = RefNames.refsGroups(groupUuid);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter oi = repo.newObjectInserter();
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId());
        PersonIdent ident = new PersonIdent(serverIdent.get(), TimeUtil.nowTs());
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(commit.getTree());
        cb.setCommitter(ident);
        cb.setAuthor(ident);
        cb.setMessage(commit.getFullMessage());
        ObjectId emptyCommit = oi.insert(cb);
        oi.flush();
        RefUpdate updateRef = repo.updateRef(groupRef);
        updateRef.setExpectedOldObjectId(commit.toObjectId());
        updateRef.setNewObjectId(emptyCommit);
        assertThat(updateRef.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Evict group from cache to be sure that we use the index state for staleness checks. This has
    // to happen directly on the groupsByUUID cache because GroupsCacheImpl triggers a reindex for
    // the group.
    groupsByUUIDCache.invalidate(groupUuid);
    assertThat(stalenessChecker.isStale(groupUuid)).isTrue();
    // Reindex fixes staleness
    gApi.groups().id(groupInfo.id).index();
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
}
#method_after
@Test
public void stalenessChecker() throws Exception {
    assume().that(groupsInNoteDb()).isTrue();
    // Newly created group is not stale
    GroupInfo groupInfo = gApi.groups().create(name("foo")).get();
    AccountGroup.UUID groupUuid = new AccountGroup.UUID(groupInfo.id);
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
    // Manual update makes index document stale
    String groupRef = RefNames.refsGroups(groupUuid);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter oi = repo.newObjectInserter();
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId());
        PersonIdent ident = new PersonIdent(serverIdent.get(), TimeUtil.nowTs());
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(commit.getTree());
        cb.setCommitter(ident);
        cb.setAuthor(ident);
        cb.setMessage(commit.getFullMessage());
        ObjectId emptyCommit = oi.insert(cb);
        oi.flush();
        RefUpdate updateRef = repo.updateRef(groupRef);
        updateRef.setExpectedOldObjectId(commit.toObjectId());
        updateRef.setNewObjectId(emptyCommit);
        assertThat(updateRef.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Evict group from cache to be sure that we use the index state for staleness checks. This has
    // to happen directly on the groupsByUUID cache because GroupsCacheImpl triggers a reindex for
    // the group.
    groupsByUUIDCache.invalidate(groupInfo.id);
    assertThat(stalenessChecker.isStale(groupUuid)).isTrue();
    // Reindex fixes staleness
    gApi.groups().id(groupInfo.id).index();
    assertThat(stalenessChecker.isStale(groupUuid)).isFalse();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try {
        try (Repository repo = repoManager.openRepository(allUsersName)) {
            ProgressMonitor pm = new TextProgressMonitor();
            pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN);
            for (Account.Id id : (Iterable<Account.Id>) Accounts.readUserRefs(repo)::iterator) {
                if (removeMyDrafts(repo, id)) {
                    pm.update(1);
                }
            }
            pm.endTask();
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Removing \"My Drafts\" menu items failed", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try {
        try (Repository repo = repoManager.openRepository(allUsersName)) {
            ProgressMonitor pm = new TextProgressMonitor();
            pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN);
            for (Account.Id id : (Iterable<Account.Id>) Accounts.readUserRefs(repo)::iterator) {
                removeMyDrafts(repo, RefNames.refsUsers(id), pm);
            }
            removeMyDrafts(repo, RefNames.REFS_USERS_DEFAULT, pm);
            pm.endTask();
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Removing \"My Drafts\" menu items failed", e);
    }
}
#end_block

#method_before
private boolean removeMyDrafts(Repository repo, Account.Id id) throws IOException, ConfigInvalidException {
    MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, repo);
    PersonIdent ident = serverIdent.get();
    md.getCommitBuilder().setAuthor(ident);
    md.getCommitBuilder().setCommitter(ident);
    Prefs prefs = new Prefs(id);
    prefs.load(repo);
    prefs.removeMyDrafts();
    prefs.commit(md);
    return prefs.dirty();
}
#method_after
private void removeMyDrafts(Repository repo, String ref, ProgressMonitor pm) throws IOException, ConfigInvalidException {
    MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, repo);
    PersonIdent ident = serverIdent.get();
    md.getCommitBuilder().setAuthor(ident);
    md.getCommitBuilder().setCommitter(ident);
    Prefs prefs = new Prefs(ref);
    prefs.load(repo);
    prefs.removeMyDrafts();
    prefs.commit(md);
    if (prefs.dirty()) {
        pm.update(1);
    }
}
#end_block

#method_before
void removeMyDrafts() {
    Config cfg = getConfig();
    for (String item : cfg.getSubsections(MY)) {
        if (DEFAULT_DRAFT_ITEM_GWTUI.equals(cfg.getString(MY, item, KEY_URL))) {
            cfg.unsetSection(MY, item);
            dirty = true;
        } else if (DEFAULT_DRAFT_ITEM_PG.equals(cfg.getString(MY, item, KEY_URL))) {
            cfg.unsetSection(MY, item);
            dirty = true;
        }
    }
}
#method_after
void removeMyDrafts() {
    Config cfg = getConfig();
    for (String item : cfg.getSubsections(MY)) {
        String value = cfg.getString(MY, item, KEY_URL);
        if (DEFAULT_DRAFT_ITEMS.contains(value)) {
            cfg.unsetSection(MY, item);
            dirty = true;
        }
    }
}
#end_block

#method_before
@Test
public void skipUnmodified() throws Exception {
    ObjectId oldMetaId = metaRef(accountId);
    assertThat(myMenusFromNoteDb(accountId).values()).doesNotContain(DEFAULT_DRAFT_ITEM_GWTUI);
    assertThat(myMenusFromApi(accountId).values()).doesNotContain(DEFAULT_DRAFT_ITEM_GWTUI);
    schema160.migrateData(db, new TestUpdateUI());
    assertThat(metaRef(accountId)).isEqualTo(oldMetaId);
}
#method_after
@Test
public void skipUnmodified() throws Exception {
    ObjectId oldMetaId = metaRef(accountId);
    ImmutableSet<String> fromNoteDb = myMenusFromNoteDb(accountId);
    ImmutableSet<String> fromApi = myMenusFromApi(accountId);
    for (String item : DEFAULT_DRAFT_ITEMS) {
        assertThat(fromNoteDb).doesNotContain(item);
        assertThat(fromApi).doesNotContain(item);
    }
    schema160.migrateData(db, new TestUpdateUI());
    assertThat(metaRef(accountId)).isEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void deleteItems() throws Exception {
    ObjectId oldMetaId = metaRef(accountId);
    List<String> defaultNames = ImmutableList.copyOf(myMenusFromApi(accountId).keySet());
    GeneralPreferencesInfo prefs = gApi.accounts().id(accountId.get()).getPreferences();
    prefs.my.add(0, new MenuItem("Something else", DEFAULT_DRAFT_ITEM_GWTUI + "+is:mergeable"));
    prefs.my.add(new MenuItem("Drafts", DEFAULT_DRAFT_ITEM_GWTUI));
    prefs.my.add(new MenuItem("Totally not drafts", DEFAULT_DRAFT_ITEM_GWTUI));
    gApi.accounts().id(accountId.get()).setPreferences(prefs);
    List<String> oldNames = ImmutableList.<String>builder().add("Something else").addAll(defaultNames).add("Drafts").add("Totally not drafts").build();
    assertThat(myMenusFromApi(accountId).keySet()).containsExactlyElementsIn(oldNames).inOrder();
    schema160.migrateData(db, new TestUpdateUI());
    accountCache.evict(accountId);
    testEnv.setApiUser(accountId);
    assertThat(metaRef(accountId)).isNotEqualTo(oldMetaId);
    List<String> newNames = ImmutableList.<String>builder().add("Something else").addAll(defaultNames).build();
    assertThat(myMenusFromNoteDb(accountId).keySet()).containsExactlyElementsIn(newNames).inOrder();
    assertThat(myMenusFromApi(accountId).keySet()).containsExactlyElementsIn(newNames).inOrder();
}
#method_after
@Test
public void deleteItems() throws Exception {
    ObjectId oldMetaId = metaRef(accountId);
    ImmutableSet<String> defaultNames = myMenusFromApi(accountId);
    GeneralPreferencesInfo prefs = gApi.accounts().id(accountId.get()).getPreferences();
    prefs.my.add(0, new MenuItem("Something else", DEFAULT_DRAFT_ITEMS.get(0) + "+is:mergeable"));
    for (int i = 0; i < DEFAULT_DRAFT_ITEMS.size(); i++) {
        prefs.my.add(new MenuItem("Draft entry " + i, DEFAULT_DRAFT_ITEMS.get(i)));
    }
    gApi.accounts().id(accountId.get()).setPreferences(prefs);
    List<String> oldNames = ImmutableList.<String>builder().add("Something else").addAll(defaultNames).add("Draft entry 0").add("Draft entry 1").add("Draft entry 2").add("Draft entry 3").build();
    assertThat(myMenusFromApi(accountId)).containsExactlyElementsIn(oldNames).inOrder();
    schema160.migrateData(db, new TestUpdateUI());
    accountCache.evict(accountId);
    testEnv.setApiUser(accountId);
    assertThat(metaRef(accountId)).isNotEqualTo(oldMetaId);
    List<String> newNames = ImmutableList.<String>builder().add("Something else").addAll(defaultNames).build();
    assertThat(myMenusFromNoteDb(accountId)).containsExactlyElementsIn(newNames).inOrder();
    assertThat(myMenusFromApi(accountId)).containsExactlyElementsIn(newNames).inOrder();
}
#end_block

#method_before
private ImmutableMap<String, String> myMenusFromNoteDb(Account.Id id) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsersName)) {
        VersionedAccountPreferences prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(repo);
        Config cfg = prefs.getConfig();
        return cfg.getSubsections(MY).stream().collect(toImmutableMap(i -> i, i -> cfg.getString(MY, i, KEY_URL)));
    }
}
#method_after
private ImmutableSet<String> myMenusFromNoteDb(Account.Id id) throws Exception {
    return myMenusFromNoteDb(() -> VersionedAccountPreferences.forUser(id)).keySet();
}
#end_block

#method_before
private ImmutableMap<String, String> myMenusFromNoteDb(Account.Id id) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsersName)) {
        VersionedAccountPreferences prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(repo);
        Config cfg = prefs.getConfig();
        return cfg.getSubsections(MY).stream().collect(toImmutableMap(i -> i, i -> cfg.getString(MY, i, KEY_URL)));
    }
}
#method_after
private ImmutableMap<String, String> myMenusFromNoteDb(Supplier<VersionedAccountPreferences> prefsSupplier) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsersName)) {
        VersionedAccountPreferences prefs = prefsSupplier.get();
        prefs.load(repo);
        Config cfg = prefs.getConfig();
        return cfg.getSubsections(MY).stream().collect(toImmutableMap(i -> i, i -> cfg.getString(MY, i, KEY_URL)));
    }
}
#end_block

#method_before
private ImmutableMap<String, String> myMenusFromApi(Account.Id id) throws Exception {
    return gApi.accounts().id(id.get()).getPreferences().my.stream().collect(toImmutableMap(i -> i.name, i -> i.url));
}
#method_after
private ImmutableSet<String> myMenusFromApi(Account.Id id) throws Exception {
    return myMenus(gApi.accounts().id(id.get()).getPreferences()).keySet();
}
#end_block

#method_before
private ObjectId metaRef(Account.Id id) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsersName)) {
        return repo.exactRef(RefNames.refsUsers(id)).getObjectId();
    }
}
#method_after
private ObjectId metaRef(Account.Id id) throws Exception {
    return readRef(RefNames.refsUsers(id)).orElseThrow(() -> new AssertionError("missing ref for account " + id));
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnPatchSetCreated()) {
        return false;
    }
    // Ignore rebases or no code changes
    try {
        if (config.getIgnoreUnchangedPatchSet() && unchangedChangeKind(event.patchSet.get().kind)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking patch set kind", e);
    }
    try {
        ChangeAttribute change;
        change = event.change.get();
        if (config.getIgnoreWipPrivate() && (Boolean.TRUE.equals(change.isPrivate) || Boolean.TRUE.equals(change.wip))) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking private and work-in-progress status", e);
    }
    boolean result;
    result = true;
    try {
        Pattern pattern;
        pattern = Pattern.compile(config.getIgnore(), Pattern.DOTALL);
        Matcher matcher;
        matcher = pattern.matcher(event.change.get().commitMessage);
        // If the ignore pattern matches, publishing should not happen
        result = !matcher.matches();
    } catch (Exception e) {
        LOGGER.warn("The specified ignore pattern was invalid", e);
    }
    return result;
}
#method_after
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnPatchSetCreated()) {
        return false;
    }
    // Ignore rebases or no code changes
    try {
        if (config.getIgnoreUnchangedPatchSet() && unchangedChangeKind(event.patchSet.get().kind)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking patch set kind", e);
    }
    try {
        ChangeAttribute change;
        change = event.change.get();
        if (config.getIgnorePrivatePatchSet() && Boolean.TRUE.equals(change.isPrivate)) {
            return false;
        }
        if (config.getIgnoreWorkInProgressPatchSet() && Boolean.TRUE.equals(change.wip)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking private and work-in-progress status", e);
    }
    boolean result;
    result = true;
    try {
        Pattern pattern;
        pattern = Pattern.compile(config.getIgnore(), Pattern.DOTALL);
        Matcher matcher;
        matcher = pattern.matcher(event.change.get().commitMessage);
        // If the ignore pattern matches, publishing should not happen
        result = !matcher.matches();
    } catch (Exception e) {
        LOGGER.warn("The specified ignore pattern was invalid", e);
    }
    return result;
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnCommentAdded) throws Exception {
    return getConfig(publishOnCommentAdded, true);
}
#method_after
private ProjectConfig getConfig(boolean publishOnCommentAdded, boolean ignoreWorkInProgressPatchSet, boolean ignorePrivatePatchSet) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("publish-on-comment-added", true)).thenReturn(publishOnCommentAdded);
    when(mockPluginConfig.getBoolean("ignore-wip-patch-set", true)).thenReturn(ignoreWorkInProgressPatchSet);
    when(mockPluginConfig.getBoolean("ignore-private-patch-set", true)).thenReturn(ignorePrivatePatchSet);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
private ProjectConfig getConfig() throws Exception {
    return getConfig(true, /* publishOnCommentAdded */
    true);
}
#method_after
private ProjectConfig getConfig() throws Exception {
    return getConfig(true, /* publishOnCommentAdded */
    true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnCommentAdded) throws Exception {
    return getConfig(publishOnCommentAdded, true);
}
#method_after
private ProjectConfig getConfig(boolean publishOnCommentAdded) throws Exception {
    return getConfig(publishOnCommentAdded, true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
@Test
public void publishesWhenWorkInProgress() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnCommentAdded */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = false;
    mockChange.wip = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenWorkInProgress() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnCommentAdded */
    false, /* ignoreWorkInProgressPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = false;
    mockChange.wip = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void publishesWhenPrivate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnCommentAdded */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = true;
    mockChange.wip = false;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenPrivate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnCommentAdded */
    false, /* ignoreWorkInProgressPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = true;
    mockChange.wip = false;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
private ProjectConfig getConfig() throws Exception {
    return getConfig("^WIP.*", true, /* publishOnPatchSetCreated */
    true, /* ignoreUnchangedPatchSet */
    true);
}
#method_after
private ProjectConfig getConfig(String ignore, boolean publishOnPatchSetCreated, boolean ignoreUnchangedPatchSet, boolean ignoreWorkInProgressPatchSet, boolean ignorePrivatePatchSet) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore);
    when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated);
    when(mockPluginConfig.getBoolean("ignore-unchanged-patch-set", true)).thenReturn(ignoreUnchangedPatchSet);
    when(mockPluginConfig.getBoolean("ignore-wip-patch-set", true)).thenReturn(ignoreWorkInProgressPatchSet);
    when(mockPluginConfig.getBoolean("ignore-private-patch-set", true)).thenReturn(ignorePrivatePatchSet);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
private ProjectConfig getConfig(String ignore) throws Exception {
    return getConfig(ignore, true, /* publishOnPatchSetCreated */
    true, /* ignoreUnchangedPatchSet */
    true);
}
#method_after
private ProjectConfig getConfig(String ignore) throws Exception {
    return getConfig(ignore, true, /* publishOnPatchSetCreated */
    true, /* ignoreUnchangedPatchSet */
    true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated, true, /* ignoreUnchangedPatchSet */
    true);
}
#method_after
private ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated, true, /* ignoreUnchangedPatchSet */
    true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreUnchangedPatchSet) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreUnchangedPatchSet, true);
}
#method_after
private ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreUnchangedPatchSet) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreUnchangedPatchSet, true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
private ProjectConfig getConfig() throws Exception {
    return getConfig("^WIP.*", true, /* publishOnPatchSetCreated */
    true, /* ignoreUnchangedPatchSet */
    true);
}
#method_after
private ProjectConfig getConfig() throws Exception {
    return getConfig("^WIP.*", true, /* publishOnPatchSetCreated */
    true, /* ignoreUnchangedPatchSet */
    true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
@Test
public void publishesWhenWorkInProgress() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnPatchSetCreated */
    false, /* ignoreRebaseEmptyPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.wip = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenWorkInProgress() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnPatchSetCreated */
    false, /* ignoreRebaseEmptyPatchSet */
    false, /* ignoreWorkInProgressPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.wip = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void publishesWhenPrivate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnPatchSetCreated */
    false, /* ignoreRebaseEmptyPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenPrivate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnPatchSetCreated */
    false, /* ignoreRebaseEmptyPatchSet */
    false, /* ignoreWorkInProgressPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnReviewerAdded()) {
        return false;
    }
    try {
        ChangeAttribute change;
        change = event.change.get();
        if (config.getIgnoreWipPrivate() && (Boolean.TRUE.equals(change.isPrivate) || Boolean.TRUE.equals(change.wip))) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking private and work-in-progress status", e);
    }
    return true;
}
#method_after
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnReviewerAdded()) {
        return false;
    }
    try {
        ChangeAttribute change;
        change = event.change.get();
        if (config.getIgnorePrivatePatchSet() && Boolean.TRUE.equals(change.isPrivate)) {
            return false;
        }
        if (config.getIgnoreWorkInProgressPatchSet() && Boolean.TRUE.equals(change.wip)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking private and work-in-progress status", e);
    }
    return true;
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnReviewerAdded) throws Exception {
    return getConfig(publishOnReviewerAdded, true);
}
#method_after
private ProjectConfig getConfig(boolean publishOnReviewerAdded, boolean ignoreWorkInProgressPatchSet, boolean ignorePrivatePatchSet) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("publish-on-reviewer-added", true)).thenReturn(publishOnReviewerAdded);
    when(mockPluginConfig.getBoolean("ignore-wip-patch-set", true)).thenReturn(ignoreWorkInProgressPatchSet);
    when(mockPluginConfig.getBoolean("ignore-private-patch-set", true)).thenReturn(ignorePrivatePatchSet);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
private ProjectConfig getConfig() throws Exception {
    return getConfig(true, /* publishOnReviewerAdded */
    true);
}
#method_after
private ProjectConfig getConfig() throws Exception {
    return getConfig(true, /* publishOnReviewerAdded */
    true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnReviewerAdded) throws Exception {
    return getConfig(publishOnReviewerAdded, true);
}
#method_after
private ProjectConfig getConfig(boolean publishOnReviewerAdded) throws Exception {
    return getConfig(publishOnReviewerAdded, true, /* ignoreWorkInProgressPatchSet */
    true);
}
#end_block

#method_before
@Test
public void publishesWhenWorkInProgress() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnReviewerAdded */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.wip = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenWorkInProgress() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnReviewerAdded */
    false, /* ignoreWorkInProgressPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.wip = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void publishesWhenPrivate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnReviewerAdded */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenPrivate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, /* publishOnReviewerAdded */
    false, /* ignoreWorkInProgressPatchSet */
    false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.isPrivate = true;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnCommentAdded()) {
        return false;
    }
    try {
        ChangeAttribute change;
        change = event.change.get();
        if (config.getIgnoreWipPrivate() && (Boolean.TRUE.equals(change.isPrivate) || Boolean.TRUE.equals(change.wip))) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking private and work-in-progress status", e);
    }
    return true;
}
#method_after
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnCommentAdded()) {
        return false;
    }
    try {
        ChangeAttribute change;
        change = event.change.get();
        if (config.getIgnorePrivatePatchSet() && Boolean.TRUE.equals(change.isPrivate)) {
            return false;
        }
        if (config.getIgnoreWorkInProgressPatchSet() && Boolean.TRUE.equals(change.wip)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking private and work-in-progress status", e);
    }
    return true;
}
#end_block

#method_before
List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        List<Comment> comments = Stream.concat(publishedComments().stream(), robotComments().stream()).collect(toList());
        Set<String> nonLeafSet = comments.stream().map(c -> c.parentUuid).collect(toSet());
        Long count = comments.stream().filter(c -> (c.unresolved && !nonLeafSet.contains(c.key.uuid))).count();
        unresolvedCommentCount = count.intValue();
    }
    return unresolvedCommentCount;
}
#method_after
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        List<Comment> comments = Stream.concat(publishedComments().stream(), robotComments().stream()).collect(toList());
        // Build a map of uuid to list of direct descendants.
        Map<String, List<Comment>> forest = new HashMap<>();
        for (Comment comment : comments) {
            List<Comment> siblings = forest.get(comment.parentUuid);
            if (siblings == null) {
                siblings = new ArrayList<>();
                forest.put(comment.parentUuid, siblings);
            }
            siblings.add(comment);
        }
        // Find latest comment in each thread and apply to unresolved counter.
        int unresolved = 0;
        if (forest.containsKey(null)) {
            for (Comment root : forest.get(null)) {
                if (getLatestComment(forest, root).unresolved) {
                    unresolved++;
                }
            }
        }
        unresolvedCommentCount = unresolved;
    }
    return unresolvedCommentCount;
}
#end_block

#method_before
public SubmitTypeRecord submitTypeRecord() {
    if (submitTypeRecord == null) {
        submitTypeRecord = submitRuleEvaluatorFactory.create(DEFAULT_OPTIONS).getSubmitType(this);
    }
    return submitTypeRecord;
}
#method_after
public SubmitTypeRecord submitTypeRecord() {
    if (submitTypeRecord == null) {
        submitTypeRecord = submitRuleEvaluatorFactory.create(SubmitRuleOptions.defaults()).getSubmitType(this);
    }
    return submitTypeRecord;
}
#end_block

#method_before
public List<SubmitRecord> evaluate(ChangeData cd) {
    Change change;
    ProjectState projectState;
    try {
        change = cd.change();
        if (change == null) {
            throw new OrmException("No change found");
        }
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    } catch (OrmException | NoSuchProjectException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", cd, projectState);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), projectState.getName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results, cd);
}
#method_after
public List<SubmitRecord> evaluate(ChangeData cd) {
    Change change;
    ProjectState projectState;
    try {
        change = cd.change();
        if (change == null) {
            throw new OrmException("Change not found");
        }
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    } catch (OrmException | NoSuchProjectException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", cd, projectState);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), projectState.getName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results, cd);
}
#end_block

#method_before
private List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results, ChangeData cd) {
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord, cd);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord, cd);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord, cd);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord, cd);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord, cd);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage(), cd);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            return Collections.singletonList(rec);
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results, ChangeData cd) {
    boolean foundOk = false;
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord, cd);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord, cd);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord, cd);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord, cd);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord, cd);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage(), cd);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            foundOk = true;
            break;
        }
    }
    Collections.reverse(out);
    // the change to be submittable when at least one result is OK.
    if (foundOk) {
        for (SubmitRecord record : out) {
            record.status = SubmitRecord.Status.OK;
        }
    }
    return out;
}
#end_block

#method_before
public static Builder builder() {
    return DEFAULT_OPTIONS.toBuilder();
}
#method_after
public static Builder builder() {
    return defaults.toBuilder();
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        LabelType at = labelTypes.byLabel(ca.getLabelId());
        if (at != null) {
            out.approvals.put(at.getName(), formatValue(ca.getValue()));
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : submitRuleEvaluatorFactory.create(DEFAULT_OPTIONS).evaluate(cd)) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        LabelType at = labelTypes.byLabel(ca.getLabelId());
        if (at != null) {
            out.approvals.put(at.getName(), formatValue(ca.getValue()));
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : submitRuleEvaluator.evaluate(cd)) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#end_block

#method_before
private SubmitType getSubmitType(ChangeData cd) throws OrmException {
    SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(DEFAULT_OPTIONS).getSubmitType(cd);
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#method_after
private SubmitType getSubmitType(ChangeData cd) throws OrmException {
    SubmitTypeRecord rec = submitRuleEvaluator.getSubmitType(cd);
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#end_block

#method_before
public Collection<SubmitRecord> evaluate(ChangeData cd) {
    Change change;
    ProjectState projectState;
    try {
        change = cd.change();
        if (change == null) {
            throw new OrmException("No change found");
        }
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    } catch (OrmException | NoSuchProjectException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    return prologRule.evaluate(cd, opts);
}
#method_after
public List<SubmitRecord> evaluate(ChangeData cd) {
    Change change;
    ProjectState projectState;
    try {
        change = cd.change();
        if (change == null) {
            throw new OrmException("Change not found");
        }
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    } catch (OrmException | NoSuchProjectException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    return ImmutableList.copyOf(prologRule.evaluate(cd, opts));
}
#end_block

#method_before
@Override
protected void configure() {
    install(new EnvironmentModule());
    bind(PrologEnvironment.Args.class);
    factory(PrologRuleEvaluator.Factory.class);
}
#method_after
@Override
protected void configure() {
    install(new EnvironmentModule());
    bind(PrologEnvironment.Args.class);
    bind(PrologRule.class);
    factory(PrologRuleEvaluator.Factory.class);
}
#end_block

#method_before
@Override
public Collection<SubmitRecord> evaluate(ChangeData cd, SubmitRuleOptions opts) {
    return getEvaluator(cd, opts).evaluate();
}
#method_after
public Collection<SubmitRecord> evaluate(ChangeData cd, SubmitRuleOptions opts) {
    return getEvaluator(cd, opts).evaluate();
}
#end_block

#method_before
private List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            return Collections.singletonList(rec);
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    boolean foundOk = false;
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            foundOk = true;
            break;
        }
    }
    Collections.reverse(out);
    if (foundOk) {
        for (SubmitRecord record : out) {
            record.status = SubmitRecord.Status.OK;
        }
    }
    return out;
}
#end_block

#method_before
public List<SubmitRecord> evaluate(ChangeData cd) {
    Change change;
    ProjectState projectState;
    try {
        change = cd.change();
        if (change == null) {
            throw new OrmException("No change found");
        }
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    } catch (OrmException | NoSuchProjectException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", cd, projectState);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), projectState.getName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results, cd);
}
#method_after
public List<SubmitRecord> evaluate() {
    initOptions();
    try {
        init();
    } catch (OrmException | NoSuchProjectException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#end_block

#method_before
private List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results, ChangeData cd) {
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord, cd);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord, cd);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord, cd);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord, cd);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord, cd);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage(), cd);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            return Collections.singletonList(rec);
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    boolean foundOk = false;
    List<SubmitRecord> out = new ArrayList<>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!(submitRecord instanceof StructureTerm) || 1 != submitRecord.arity()) {
            return invalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return invalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!(submitRecord instanceof StructureTerm)) {
            return invalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!(state instanceof StructureTerm) || 2 != state.arity() || !"label".equals(state.name())) {
                return invalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return invalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return invalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            foundOk = true;
            break;
        }
    }
    Collections.reverse(out);
    // the change to be submittable when at least one result is OK.
    if (foundOk) {
        for (SubmitRecord record : out) {
            record.status = SubmitRecord.Status.OK;
        }
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> invalidResult(Term rule, Term record, ChangeData cd) {
    return invalidResult(rule, record, null, cd);
}
#method_after
private List<SubmitRecord> invalidResult(Term rule, Term record, String reason) {
    return ruleError(String.format("Submit rule %s for change %s of %s output invalid result: %s%s", rule, cd.getId(), getProjectName(), record, (reason == null ? "" : ". Reason: " + reason)));
}
#end_block

#method_before
private List<SubmitRecord> ruleError(String err, Exception e) {
    if (opts.logErrors()) {
        if (e == null) {
            log.error(err);
        } else {
            log.error(err, e);
        }
        return defaultRuleError();
    }
    return createRuleError(err);
}
#method_after
private List<SubmitRecord> ruleError(String err, Exception e) {
    if (logErrors) {
        if (e == null) {
            log.error(err);
        } else {
            log.error(err, e);
        }
        return defaultRuleError();
    }
    return createRuleError(err);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitType(ChangeData cd) {
    ProjectState projectState;
    try {
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    } catch (NoSuchProjectException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", cd, projectState);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + projectState.getName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + projectState.getName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + projectState.getName() + " output invalid result: " + typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        init();
    } catch (OrmException | NoSuchProjectException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#end_block

#method_before
private SubmitTypeRecord typeError(String err, Exception e) {
    if (opts.logErrors()) {
        if (e == null) {
            log.error(err);
        } else {
            log.error(err, e);
        }
        return defaultTypeError();
    }
    return SubmitTypeRecord.error(err);
}
#method_after
private SubmitTypeRecord typeError(String err, Exception e) {
    if (logErrors) {
        if (e == null) {
            log.error(err);
        } else {
            log.error(err, e);
        }
        return defaultTypeError();
    }
    return SubmitTypeRecord.error(err);
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, ChangeData cd, ProjectState projectState) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(cd, projectState);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), projectState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), projectState.getName()), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(ChangeData cd, ProjectState projectState) throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", projectState.getName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    ChangeData cd = env.get(StoredValues.CHANGE_DATA);
    ProjectState projectState = env.get(StoredValues.PROJECT_STATE);
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleOptions opts = SubmitRuleOptions.builder().skipFilters(input.filters == Filters.SKIP).rule(input.rule).logErrors(false).build();
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getNotes());
    List<SubmitRecord> records = submitRuleEvaluatorFactory.create(opts).evaluate(cd);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(changeDataFactory.create(db.get(), rsrc.getNotes()));
    List<SubmitRecord> records = evaluator.setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private SubmitRecord toSubmitRecord() {
    SubmitRecord rec = new SubmitRecord();
    rec.status = status;
    rec.errorMessage = errorMessage;
    if (labels != null) {
        rec.labels = new ArrayList<>(labels.size());
        for (StoredLabel label : labels) {
            SubmitRecord.Label srl = new SubmitRecord.Label();
            srl.label = label.label;
            srl.status = label.status;
            srl.appliedBy = label.appliedBy != null ? new Account.Id(label.appliedBy) : null;
            rec.labels.add(srl);
        }
    }
    if (requirements != null) {
        rec.requirements = new ArrayList<>(requirements.size());
        for (StoredRequirement requirement : requirements) {
            SubmitRequirement.Builder srb = SubmitRequirement.builder();
            srb.setFullReason(requirement.fullReason);
            srb.setShortReason(requirement.shortReason);
            if (requirement.label != null) {
                srb.setLabel(requirement.label);
            }
            rec.requirements.add(srb.build());
        }
    }
    return rec;
}
#method_after
private SubmitRecord toSubmitRecord() {
    SubmitRecord rec = new SubmitRecord();
    rec.status = status;
    rec.errorMessage = errorMessage;
    if (labels != null) {
        rec.labels = new ArrayList<>(labels.size());
        for (StoredLabel label : labels) {
            SubmitRecord.Label srl = new SubmitRecord.Label();
            srl.label = label.label;
            srl.status = label.status;
            srl.appliedBy = label.appliedBy != null ? new Account.Id(label.appliedBy) : null;
            rec.labels.add(srl);
        }
    }
    if (requirements != null) {
        rec.requirements = new ArrayList<>(requirements.size());
        for (StoredRequirement requirement : requirements) {
            SubmitRequirement sr = new SubmitRequirement(requirement.shortReason, requirement.fullReason, requirement.label);
            rec.requirements.add(sr);
        }
    }
    return rec;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(status);
    if (status == Status.RULE_ERROR && errorMessage != null) {
        sb.append('(').append(errorMessage).append(')');
    }
    sb.append('[');
    if (labels != null) {
        String delimiter = "";
        for (Label label : labels) {
            sb.append(delimiter).append(label);
            delimiter = ", ";
        }
    }
    sb.append(']');
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(status);
    if (status == Status.RULE_ERROR && errorMessage != null) {
        sb.append('(').append(errorMessage).append(')');
    }
    sb.append('[');
    if (labels != null) {
        String delimiter = "";
        for (Label label : labels) {
            sb.append(delimiter).append(label);
            delimiter = ", ";
        }
    }
    sb.append("],[");
    if (requirements != null) {
        String delimiter = "";
        for (SubmitRequirement requirement : requirements) {
            sb.append(delimiter).append(requirement);
            delimiter = ", ";
        }
    }
    sb.append(']');
    return sb.toString();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof SubmitRecord) {
        SubmitRecord r = (SubmitRecord) o;
        return Objects.equals(status, r.status) && Objects.equals(labels, r.labels) && Objects.equals(errorMessage, r.errorMessage);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof SubmitRecord) {
        SubmitRecord r = (SubmitRecord) o;
        return Objects.equals(status, r.status) && Objects.equals(labels, r.labels) && Objects.equals(errorMessage, r.errorMessage) && Objects.equals(requirements, r.requirements);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(status, labels, errorMessage);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(status, labels, errorMessage, requirements);
}
#end_block

#method_before
private void addSubmitRecordRequirements(SubmitRecord submitRecord, SubmitRecordAttribute sa) {
    if (submitRecord.requirements != null && !submitRecord.requirements.isEmpty()) {
        sa.requirements = new ArrayList<>();
        for (SubmitRequirement req : submitRecord.requirements) {
            SubmitRequirementAttribute re = new SubmitRequirementAttribute();
            re.shortReason = req.shortReason();
            re.fullReason = req.fullReason();
            re.label = req.label();
            sa.requirements.add(re);
        }
    }
}
#method_after
private void addSubmitRecordRequirements(SubmitRecord submitRecord, SubmitRecordAttribute sa) {
    if (submitRecord.requirements != null && !submitRecord.requirements.isEmpty()) {
        sa.requirements = new ArrayList<>();
        for (SubmitRequirement req : submitRecord.requirements) {
            SubmitRequirementAttribute re = new SubmitRequirementAttribute();
            re.shortReason = req.shortReason();
            re.fullReason = req.fullReason();
            re.label = req.label().orElse(null);
            sa.requirements.add(re);
        }
    }
}
#end_block

#method_before
private String getResponse(HttpURLConnection connection) {
    String response;
    InputStream responseStream;
    responseStream = null;
    try {
        responseStream = connection.getInputStream();
        response = readResponse(responseStream);
    } catch (IOException e) {
        responseStream = connection.getErrorStream();
        response = readResponse(responseStream);
    } finally {
        if (responseStream != null) {
            try {
                responseStream.close();
            } catch (IOException e) {
                LOGGER.debug("Error closing response stream: " + e.getMessage());
            }
        }
    }
    return response;
}
#method_after
private String getResponse(HttpURLConnection connection) {
    try (InputStream responseStream = getResponseStream(connection);
        Scanner scanner = new Scanner(responseStream, StandardCharsets.UTF_8.name())) {
        scanner.useDelimiter("\\A");
        return scanner.next();
    } catch (IOException e) {
        LOGGER.debug("Error closing response stream: " + e.getMessage());
    }
    return null;
}
#end_block

#method_before
@Test
public void indexStalenessIsNotDerivedFromCacheStaleness() throws Exception {
    AccountGroup.UUID groupUuid = createGroup("verifiers");
    groupIndexer.index(groupUuid);
    updateGroupWithoutCacheOrIndex(groupUuid, newGroupUpdate().setDescription("Modified").build());
    reloadGroupToCache(groupUuid);
    boolean reindexed = groupIndexer.reindexIfStale(groupUuid);
    assertWithMessage("Group should have been reindexed").that(reindexed).isTrue();
}
#method_after
@Test
public void indexStalenessIsNotDerivedFromCacheStaleness() throws Exception {
    AccountGroup.UUID groupUuid = createGroup("verifiers");
    updateGroupWithoutCacheOrIndex(groupUuid, newGroupUpdate().setDescription("Modified").build());
    reloadGroupToCache(groupUuid);
    boolean reindexed = groupIndexer.reindexIfStale(groupUuid);
    assertWithMessage("Group should have been reindexed").that(reindexed).isTrue();
}
#end_block

#method_before
@Test
public void withMergedInheritance() throws Exception {
    String configName = "test.config";
    Config parentCfg = new Config();
    parentCfg.setString("s1", null, "k1", "parentValue1");
    parentCfg.setString("s1", null, "k2", "parentValue2");
    parentCfg.setString("s2", "ss", "k3", "parentValue3");
    parentCfg.setString("s2", "ss", "k4", "parentValue4");
    pushFactory.create(db, admin.getIdent(), testRepo, "Create Project Level Config", configName, parentCfg.toText()).to(RefNames.REFS_CONFIG).assertOkStatus();
    Project.NameKey childProject = createProject("child", project);
    TestRepository<?> childTestRepo = cloneProject(childProject);
    fetch(childTestRepo, RefNames.REFS_CONFIG + ":refs/heads/config");
    childTestRepo.reset("refs/heads/config");
    Config cfg = new Config();
    cfg.setString("s1", null, "k1", "childValue1");
    cfg.setString("s2", "ss", "k3", "childValue2");
    cfg.setString("s3", null, "k5", "childValue3");
    cfg.setString("s3", "ss", "k6", "childValue4");
    pushFactory.create(db, admin.getIdent(), childTestRepo, "Create Project Level Config", configName, cfg.toText()).to(RefNames.REFS_CONFIG).assertOkStatus();
    ProjectState state = projectCache.get(childProject);
    Config expectedCfg = new Config();
    expectedCfg.setStringList("s1", null, "k1", Arrays.asList("childValue1", "parentValue1"));
    expectedCfg.setString("s1", null, "k2", "parentValue2");
    expectedCfg.setStringList("s2", "ss", "k3", Arrays.asList("childValue2", "parentValue3"));
    expectedCfg.setString("s2", "ss", "k4", "parentValue4");
    expectedCfg.setString("s3", null, "k5", "childValue3");
    expectedCfg.setString("s3", "ss", "k6", "childValue4");
    assertThat(state.getConfig(configName).getWithInheritance(true).toText()).isEqualTo(expectedCfg.toText());
    assertThat(state.getConfig(configName).get().toText()).isEqualTo(cfg.toText());
}
#method_after
@Test
public void withMergedInheritance() throws Exception {
    String configName = "test.config";
    Config parentCfg = new Config();
    parentCfg.setString("s1", null, "k1", "parentValue1");
    parentCfg.setString("s1", null, "k2", "parentValue2");
    parentCfg.setString("s2", "ss", "k3", "parentValue3");
    parentCfg.setString("s2", "ss", "k4", "parentValue4");
    pushFactory.create(db, admin.getIdent(), testRepo, "Create Project Level Config", configName, parentCfg.toText()).to(RefNames.REFS_CONFIG).assertOkStatus();
    Project.NameKey childProject = createProject("child", project);
    TestRepository<?> childTestRepo = cloneProject(childProject);
    fetch(childTestRepo, RefNames.REFS_CONFIG + ":refs/heads/config");
    childTestRepo.reset("refs/heads/config");
    Config cfg = new Config();
    cfg.setString("s1", null, "k1", "parentValue1");
    cfg.setString("s1", null, "k2", "parentValue2");
    cfg.setString("s2", "ss", "k3", "parentValue3");
    cfg.setString("s2", "ss", "k4", "parentValue4");
    cfg.setString("s1", null, "k1", "childValue1");
    cfg.setString("s2", "ss", "k3", "childValue2");
    cfg.setString("s3", null, "k5", "childValue3");
    cfg.setString("s3", "ss", "k6", "childValue4");
    pushFactory.create(db, admin.getIdent(), childTestRepo, "Create Project Level Config", configName, cfg.toText()).to(RefNames.REFS_CONFIG).assertOkStatus();
    ProjectState state = projectCache.get(childProject);
    Config expectedCfg = new Config();
    expectedCfg.setStringList("s1", null, "k1", Arrays.asList("childValue1", "parentValue1"));
    expectedCfg.setString("s1", null, "k2", "parentValue2");
    expectedCfg.setStringList("s2", "ss", "k3", Arrays.asList("childValue2", "parentValue3"));
    expectedCfg.setString("s2", "ss", "k4", "parentValue4");
    expectedCfg.setString("s3", null, "k5", "childValue3");
    expectedCfg.setString("s3", "ss", "k6", "childValue4");
    assertThat(state.getConfig(configName).getWithInheritance(true).toText()).isEqualTo(expectedCfg.toText());
    assertThat(state.getConfig(configName).get().toText()).isEqualTo(cfg.toText());
}
#end_block

#method_before
public Config getWithInheritance(boolean merge) {
    Config cfgWithInheritance = new Config();
    try {
        cfgWithInheritance.fromText(get().toText());
    } catch (ConfigInvalidException e) {
    // cannot happen
    }
    ProjectState parent = Iterables.getFirst(project.parents(), null);
    if (parent != null) {
        Config parentCfg = parent.getConfig(fileName).getWithInheritance();
        for (String section : parentCfg.getSections()) {
            Set<String> allNames = get().getNames(section);
            for (String name : parentCfg.getNames(section)) {
                if (!allNames.contains(name)) {
                    cfgWithInheritance.setStringList(section, null, name, Arrays.asList(parentCfg.getStringList(section, null, name)));
                } else if (merge) {
                    List<String> values = new ArrayList<>(Arrays.asList(cfg.getStringList(section, null, name)));
                    values.addAll(Arrays.asList(parentCfg.getStringList(section, null, name)));
                    cfgWithInheritance.setStringList(section, null, name, values);
                }
            }
            for (String subsection : parentCfg.getSubsections(section)) {
                allNames = get().getNames(section, subsection);
                for (String name : parentCfg.getNames(section, subsection)) {
                    if (!allNames.contains(name)) {
                        cfgWithInheritance.setStringList(section, subsection, name, Arrays.asList(parentCfg.getStringList(section, subsection, name)));
                    } else if (merge) {
                        List<String> values = new ArrayList<>(Arrays.asList(cfg.getStringList(section, subsection, name)));
                        values.addAll(Arrays.asList(parentCfg.getStringList(section, subsection, name)));
                        cfgWithInheritance.setStringList(section, subsection, name, values);
                    }
                }
            }
        }
    }
    return cfgWithInheritance;
}
#method_after
public Config getWithInheritance(boolean merge) {
    Config cfgWithInheritance = new Config();
    try {
        cfgWithInheritance.fromText(get().toText());
    } catch (ConfigInvalidException e) {
    // cannot happen
    }
    ProjectState parent = Iterables.getFirst(project.parents(), null);
    if (parent != null) {
        Config parentCfg = parent.getConfig(fileName).getWithInheritance();
        for (String section : parentCfg.getSections()) {
            Set<String> allNames = get().getNames(section);
            for (String name : parentCfg.getNames(section)) {
                String[] parentValues = parentCfg.getStringList(section, null, name);
                if (!allNames.contains(name)) {
                    cfgWithInheritance.setStringList(section, null, name, Arrays.asList(parentValues));
                } else if (merge) {
                    cfgWithInheritance.setStringList(section, null, name, Stream.concat(Arrays.stream(cfg.getStringList(section, null, name)), Arrays.stream(parentValues)).sorted().distinct().collect(Collectors.toList()));
                }
            }
            for (String subsection : parentCfg.getSubsections(section)) {
                allNames = get().getNames(section, subsection);
                for (String name : parentCfg.getNames(section, subsection)) {
                    String[] parentValues = parentCfg.getStringList(section, subsection, name);
                    if (!allNames.contains(name)) {
                        cfgWithInheritance.setStringList(section, subsection, name, Arrays.asList(parentValues));
                    } else if (merge) {
                        cfgWithInheritance.setStringList(section, subsection, name, Streams.concat(Arrays.stream(cfg.getStringList(section, subsection, name)), Arrays.stream(parentValues)).sorted().distinct().collect(Collectors.toList()));
                    }
                }
            }
        }
    }
    return cfgWithInheritance;
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = findExternalId(db, who.getExternalIdKey());
            if (id == null) {
                // New account, automatically create and return.
                // 
                log.info("External ID found to be null. Attempting to create new account for: " + who.getUserName());
                ExternalId.Key key = ExternalId.Key.create(SCHEME_USERNAME, who.getUserName());
                ExternalId existingId = findExternalId(db, key);
                if (existingId != null) {
                    log.info("User already has an account ID, link the account to new external ID- gerrit:" + who.getUserName());
                    return link(existingId.accountId(), who);
                }
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = findExternalId(db, who.getExternalIdKey());
            if (id == null) {
                if (who.getUserName() != null) {
                    ExternalId.Key key = ExternalId.Key.create(SCHEME_USERNAME, who.getUserName());
                    ExternalId existingId = findExternalId(db, key);
                    if (existingId != null) {
                        // An inconsistency is detected in the database, having a record for scheme "username:"
                        // but no record for scheme "gerrit:". Try to recover by linking
                        // "gerrit:" identity to the existing account.
                        log.warn("User {} already has an account; link new identity to the existing account.", who.getUserName());
                        return link(existingId.accountId(), who);
                    }
                }
                // New account, automatically create and return.
                // 
                log.info("External ID not found. Attempting to create new account.");
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException, ConfigInvalidException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(db, extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        if (user.getUserName() == null) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setUserName(who.getUserName());
        } else {
            log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
        }
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(db, extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException, ConfigInvalidException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        externalIdsUpdateFactory.create().delete(db, extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(ReviewDb db, Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        externalIdsUpdateFactory.create().delete(db, extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        log.info("Linking the already existing account to an authentication identity");
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            log.info("Creating new external ID for the existing account");
            /*In case of missing entries in DB, an update is needed in the All-users repo and an insert
        in the GerritDB, which is why "insert" operation is changed to "upsert".*/
            externalIdsUpdateFactory.create().upsert(db, ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(to);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        log.info("Link another authentication identity to an existing account");
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            log.info("Updating existing external ID data");
            update(db, who, extId);
        } else {
            log.info("Linking new external ID to the existing account");
            externalIdsUpdateFactory.create().insert(db, ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(to);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        Collection<ExternalId> filteredExtIdsByScheme = ExternalId.from(db.accountExternalIds().byAccount(to).toList()).stream().filter(e -> e.isScheme(who.getExternalIdKey().scheme())).collect(toSet());
        if (!filteredExtIdsByScheme.isEmpty() && (filteredExtIdsByScheme.size() > 1 || !filteredExtIdsByScheme.stream().filter(e -> e.key().equals(who.getExternalIdKey())).findAny().isPresent())) {
            externalIdsUpdateFactory.create().delete(db, filteredExtIdsByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        Collection<ExternalId> filteredExtIdsByScheme = ExternalId.from(db.accountExternalIds().byAccount(to).toList()).stream().filter(e -> e.isScheme(who.getExternalIdKey().scheme())).collect(toSet());
        if (!filteredExtIdsByScheme.isEmpty() && (filteredExtIdsByScheme.size() > 1 || !filteredExtIdsByScheme.stream().filter(e -> e.key().equals(who.getExternalIdKey())).findAny().isPresent())) {
            externalIdsUpdateFactory.create().delete(db, filteredExtIdsByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(from)) {
                throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' in use by another account");
            }
            externalIdsUpdateFactory.create().delete(db, extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(from);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        } else {
            throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' not found");
        }
        return new AuthResult(from, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(from)) {
                throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' in use by another account");
            }
            externalIdsUpdateFactory.create().delete(db, extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(from);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        } else {
            throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' not found");
        }
        return new AuthResult(from, who.getExternalIdKey(), false);
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(HashedPassword.fromPassword(input.httpPassword).encode());
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    // triggers reindex
    accountCache.evict(id);
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    ExternalId extUser = ExternalId.createUsername(username, id, input.httpPassword);
    if (db.accountExternalIds().get(extUser.key().asAccountExternalIdKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(ExternalId.Key.create(SCHEME_MAILTO, input.email).asAccountExternalIdKey()) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<ExternalId> extIds = new ArrayList<>();
    extIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        extIds.addAll(c.create(id, username, input.email));
    }
    ExternalIdsUpdate externalIdsUpdate = externalIdsUpdateFactory.create();
    try {
        externalIdsUpdate.insert(db, extIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        try {
            externalIdsUpdate.insert(db, ExternalId.createEmail(id, input.email));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                externalIdsUpdate.delete(db, extUser);
            } catch (IOException | OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    // triggers reindex
    accountCache.evict(id);
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    input.httpPassword = Strings.emptyToNull(input.httpPassword);
    String newPassword;
    if (input.generate) {
        if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to generate HTTP password");
        }
        newPassword = generate();
    } else if (input.httpPassword == null) {
        if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to clear HTTP password");
        }
        newPassword = null;
    } else {
        if (!self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to set HTTP password directly, " + "requires the Administrate Server permission");
        }
        newPassword = input.httpPassword;
    }
    return apply(rsrc.getUser(), newPassword);
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    input.httpPassword = Strings.emptyToNull(input.httpPassword);
    String newPassword;
    if (input.generate) {
        if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to generate HTTP password");
        }
        newPassword = generate();
    } else if (input.httpPassword == null) {
        if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to clear HTTP password");
        }
        newPassword = null;
    } else {
        if (!self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to set HTTP password directly, " + "requires the Administrate Server permission");
        }
        newPassword = input.httpPassword;
    }
    return apply(rsrc.getUser(), newPassword);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(HashedPassword.fromPassword(newPassword).encode());
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    ExternalId extId = ExternalId.from(dbProvider.get().accountExternalIds().get(ExternalId.Key.create(SCHEME_USERNAME, user.getUserName()).asAccountExternalIdKey()));
    if (extId == null) {
        throw new ResourceNotFoundException();
    }
    ExternalId newExtId = ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword);
    externalIdsUpdate.create().upsert(dbProvider.get(), newExtId);
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<AccountExternalId> extIds = new ArrayList<>(2);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(HashedPassword.fromPassword(httpPassword).encode());
                }
                extIds.add(extUser);
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = ExternalId.createEmail(id, email).asAccountExternalId();
                    extIds.add(extMailto);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<ExternalId> extIds = new ArrayList<>(2);
                extIds.add(ExternalId.createUsername(username, id, httpPassword));
                if (email != null) {
                    extIds.add(ExternalId.createEmail(id, email));
                }
                externalIds.insert(db, extIds);
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Add SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void getExternalIDs() throws Exception {
    Collection<AccountExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds();
    List<AccountExternalIdInfo> expectedIdInfos = new ArrayList<>();
    for (AccountExternalId id : expectedIds) {
        id.setCanDelete(!id.getExternalId().equals("username:" + user.username));
        id.setTrusted(true);
        expectedIdInfos.add(toInfo(id));
    }
    RestResponse response = userRestSession.get("/accounts/self/external.ids");
    response.assertOK();
    List<AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new TypeToken<List<AccountExternalIdInfo>>() {
    }.getType());
    Collections.sort(expectedIdInfos);
    Collections.sort(results);
    assertThat(results).containsExactlyElementsIn(expectedIdInfos);
}
#method_after
@Test
public void getExternalIDs() throws Exception {
    Collection<ExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds();
    List<AccountExternalIdInfo> expectedIdInfos = new ArrayList<>();
    for (ExternalId id : expectedIds) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.canDelete = !id.isScheme(SCHEME_USERNAME) ? true : null;
        info.trusted = true;
        expectedIdInfos.add(info);
    }
    RestResponse response = userRestSession.get("/accounts/self/external.ids");
    response.assertOK();
    List<AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new TypeToken<List<AccountExternalIdInfo>>() {
    }.getType());
    Collections.sort(expectedIdInfos);
    Collections.sort(results);
    assertThat(results).containsExactlyElementsIn(expectedIdInfos);
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = findExternalId(db, who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = findExternalId(db, who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        ExternalId externalId = ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password());
        db.accountExternalIds().update(Collections.singleton(externalId.asAccountExternalId()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(db, extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.email());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        ExternalId existingExtId = ExternalId.from(db.accountExternalIds().get(extId.key().asAccountExternalIdKey()));
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId.asAccountExternalId()));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        Iterator<AccountGroup> adminGroupIt = db.accountGroups().byUUID(uuid).iterator();
        if (!adminGroupIt.hasNext()) {
            throw new OrmException("Administrator group's UUID is misaligned in backend and All-Projects repository");
        }
        AccountGroup g = adminGroupIt.next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.email());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        ExternalId existingExtId = ExternalId.from(db.accountExternalIds().get(extId.key().asAccountExternalIdKey()));
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(db, extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        Iterator<AccountGroup> adminGroupIt = db.accountGroups().byUUID(uuid).iterator();
        if (!adminGroupIt.hasNext()) {
            throw new OrmException("Administrator group's UUID is misaligned in backend and All-Projects repository");
        }
        AccountGroup g = adminGroupIt.next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId.asAccountExternalId()));
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(ReviewDb db, Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        externalIdsUpdateFactory.create().delete(db, extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId.asAccountExternalId()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
            }
            byIdCache.evict(to);
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            externalIdsUpdateFactory.create().insert(db, ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(to);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = who.getExternalIdKey().asAccountExternalIdKey();
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        Collection<ExternalId> filteredExtIdsByScheme = ExternalId.from(db.accountExternalIds().byAccount(to).toList()).stream().filter(e -> e.isScheme(who.getExternalIdKey().scheme())).collect(toSet());
        if (!filteredExtIdsByScheme.isEmpty() && (filteredExtIdsByScheme.size() > 1 || !filteredExtIdsByScheme.stream().filter(e -> e.key().equals(who.getExternalIdKey())).findAny().isPresent())) {
            externalIdsUpdateFactory.create().delete(db, filteredExtIdsByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(from)) {
                throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId.asAccountExternalId()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' not found");
        }
        return new AuthResult(from, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(from)) {
                throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' in use by another account");
            }
            externalIdsUpdateFactory.create().delete(db, extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(from);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        } else {
            throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' not found");
        }
        return new AuthResult(from, who.getExternalIdKey(), false);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    manager.add(dbInjector, dbInjector.createChildInjector(SchemaVersionCheck.module()));
    manager.start();
    dbInjector.injectMembers(this);
    try (ReviewDb db = database.open()) {
        todo = db.accountExternalIds().all().toList();
        synchronized (monitor) {
            monitor.beginTask("Converting local usernames", todo.size());
        }
    }
    final List<Worker> workers = new ArrayList<>(threads);
    for (int tid = 0; tid < threads; tid++) {
        Worker t = new Worker();
        t.start();
        workers.add(t);
    }
    for (Worker t : workers) {
        t.join();
    }
    synchronized (monitor) {
        monitor.endTask();
    }
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    Injector dbInjector = createDbInjector(MULTI_USER);
    manager.add(dbInjector, dbInjector.createChildInjector(SchemaVersionCheck.module()));
    manager.start();
    dbInjector.injectMembers(this);
    try (ReviewDb db = database.open()) {
        Collection<ExternalId> todo = ExternalId.from(db.accountExternalIds().all().toList());
        monitor.beginTask("Converting local usernames", todo.size());
        for (ExternalId extId : todo) {
            convertLocalUserToLowerCase(extId);
            monitor.update(1);
        }
        externalIdsBatchUpdate.commit(db);
    }
    monitor.endTask();
    int exitCode = reindexAccounts();
    manager.stop();
    return exitCode;
}
#end_block

#method_before
private void convertLocalUserToLowerCase(final ReviewDb db, final AccountExternalId extId) {
    if (extId.isScheme(AccountExternalId.SCHEME_GERRIT)) {
        final String localUser = extId.getSchemeRest();
        final String localUserLowerCase = localUser.toLowerCase(Locale.US);
        if (!localUser.equals(localUserLowerCase)) {
            final AccountExternalId.Key extIdKeyLowerCase = new AccountExternalId.Key(AccountExternalId.SCHEME_GERRIT, localUserLowerCase);
            final AccountExternalId extIdLowerCase = new AccountExternalId(extId.getAccountId(), extIdKeyLowerCase);
            try {
                db.accountExternalIds().insert(Collections.singleton(extIdLowerCase));
                db.accountExternalIds().delete(Collections.singleton(extId));
            } catch (OrmException error) {
                System.err.println("ERR " + error.getMessage());
            }
        }
    }
}
#method_after
private void convertLocalUserToLowerCase(ExternalId extId) {
    if (extId.isScheme(SCHEME_GERRIT)) {
        String localUser = extId.key().id();
        String localUserLowerCase = localUser.toLowerCase(Locale.US);
        if (!localUser.equals(localUserLowerCase)) {
            ExternalId extIdLowerCase = ExternalId.create(SCHEME_GERRIT, localUserLowerCase, extId.accountId(), extId.email(), extId.password());
            externalIdsBatchUpdate.replace(extId, extIdLowerCase);
        }
    }
}
#end_block

#method_before
@Override
void index(Change.Id id, Operation operation) throws IOException, OrmException {
    Change change = null;
    switch(operation) {
        case INDEX:
            try (ReviewDb db = schemaFactory.open()) {
                change = db.changes().get(id);
                if (change != null) {
                    indexer.index(db, change);
                    logger.debug("Change {} successfully indexed", id);
                }
            } catch (Exception e) {
                if (!isCausedByNoSuchChangeException(e)) {
                    throw e;
                }
                logger.debug("Change {} was deleted, aborting forwarded indexing the change.", id.get());
            }
            if (change == null) {
                indexer.delete(id);
                logger.debug("Change {} not found, deleted from index", id);
            }
            break;
        case DELETE:
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
            break;
    }
}
#method_after
@Override
void index(Change.Id id, Operation operation) throws IOException, OrmException {
    switch(operation) {
        case INDEX:
            Change change = null;
            try (ReviewDb db = schemaFactory.open()) {
                change = db.changes().get(id);
                if (change != null) {
                    indexer.index(db, change);
                    logger.debug("Change {} successfully indexed", id);
                }
            } catch (Exception e) {
                if (!isCausedByNoSuchChangeException(e)) {
                    throw e;
                }
                logger.debug("Change {} was deleted, aborting forwarded indexing the change.", id.get());
            }
            if (change == null) {
                indexer.delete(id);
                logger.debug("Change {} not found, deleted from index", id);
            }
            break;
        case DELETE:
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
            break;
    }
}
#end_block

#method_before
@Override
void index(Change.Id id, Operation operation) throws IOException, OrmException {
    switch(operation) {
        case INDEX:
            try (ReviewDb db = schemaFactory.open()) {
                Change change = db.changes().get(id);
                if (change == null) {
                    indexer.delete(id);
                    return;
                }
                indexer.index(db, change);
            }
            logger.debug("Change {} successfully indexed", id);
            break;
        case DELETE:
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
            break;
    }
    indexTs.update("change");
}
#method_after
@Override
void index(Change.Id id, Operation operation) throws IOException, OrmException {
    Change change = null;
    switch(operation) {
        case INDEX:
            try (ReviewDb db = schemaFactory.open()) {
                change = db.changes().get(id);
                if (change == null) {
                    indexer.delete(id);
                } else {
                    indexer.index(db, change);
                    logger.debug("Change {} successfully indexed", id);
                }
            } catch (Exception e) {
                if (!isCausedByNoSuchChangeException(e)) {
                    throw e;
                }
                logger.debug("Change {} was deleted, aborting forwarded indexing the change.", id.get());
            }
            break;
        case DELETE:
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
            break;
    }
    updateIndexTs(change == null ? LocalDateTime.now() : change.getLastUpdatedOn().toLocalDateTime());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Executor.class).annotatedWith(IndexExecutor.class).toProvider(IndexExecutorProvider.class);
    listener().to(IndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), AccountIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), LifecycleListener.class).to(AutoReindexAtStart.class);
}
#method_after
@Override
protected void configure() {
    bind(Executor.class).annotatedWith(IndexExecutor.class).toProvider(IndexExecutorProvider.class);
    listener().to(IndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), AccountIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), GroupIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), LifecycleListener.class).to(AutoReindexListener.class);
}
#end_block

#method_before
@Override
void index(Account.Id id, Operation operation) throws IOException {
    indexer.index(id);
    logger.debug("Account {} successfully indexed", id);
    indexTs.update("account");
}
#method_after
@Override
void index(Account.Id id, Operation operation) throws IOException {
    indexer.index(id);
    logger.debug("Account {} successfully indexed", id);
    updateIndexTs(LocalDateTime.now());
}
#end_block

#method_before
@Override
void index(AccountGroup.UUID uuid, Operation operation) throws IOException {
    indexer.index(uuid);
    logger.debug("Group {} successfully indexed", uuid);
    indexTs.update("group");
}
#method_after
@Override
void index(AccountGroup.UUID uuid, Operation operation) throws IOException {
    indexer.index(uuid);
    logger.debug("Group {} successfully indexed", uuid);
    updateIndexTs(LocalDateTime.now());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enabled")).toInstance(new ItsHookEnabledConfigEntry(pluginName, pluginCfgFactory));
    bind(ItsConfig.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ItsValidateComment.class);
    DynamicSet.bind(binder(), EventListener.class).to(ActionController.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ItsRulesProjectCache.class);
    factory(ActionRequest.Factory.class);
    factory(Property.Factory.class);
    factory(Condition.Factory.class);
    factory(Rule.Factory.class);
    factory(AddComment.Factory.class);
    factory(AddSoyComment.Factory.class);
    factory(AddStandardComment.Factory.class);
    factory(LogEvent.Factory.class);
    install(new ItsRulesProjectCache.Module());
}
#method_after
@Override
protected void configure() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enabled")).toInstance(new ItsHookEnabledConfigEntry(pluginName, pluginCfgFactory));
    bind(ItsConfig.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ItsValidateComment.class);
    DynamicSet.bind(binder(), EventListener.class).to(ActionController.class);
    factory(ActionRequest.Factory.class);
    factory(Property.Factory.class);
    factory(Condition.Factory.class);
    factory(Rule.Factory.class);
    factory(AddComment.Factory.class);
    factory(AddSoyComment.Factory.class);
    factory(AddStandardComment.Factory.class);
    factory(LogEvent.Factory.class);
}
#end_block

#method_before
@Provides
@ItsPath
@Inject
Path itsPath(@SitePath Path sitePath) {
    return sitePath.normalize().resolve("etc").resolve("its");
}
#method_after
@Provides
@ItsPath
@Inject
Path itsPath(SitePaths sitePaths) {
    return sitePaths.etc_dir.normalize().resolve(ITS_FOLDER);
}
#end_block

#method_before
private void reloadRules() {
    rules = new ArrayList<>();
    // Add global rules
    File globalRuleFile = itsPath.resolve(globalRulesFileName).toFile();
    rules.addAll(getRulesFromFile(globalRuleFile));
    // Add its-specific rules
    File itsSpecificRuleFile = itsPath.resolve(pluginRulesFileName).toFile();
    rules.addAll(getRulesFromFile(itsSpecificRuleFile));
    if (!globalRuleFile.exists() && !itsSpecificRuleFile.exists()) {
        log.warn("Neither global rule file {} nor Its specific rule file {} exist. Please configure rules.", globalRuleFile, itsSpecificRuleFile);
    }
}
#method_after
private void reloadRules() {
    rules = Lists.newArrayList();
    // Add global rules
    File globalRuleFile = itsPath.resolve(String.format(CONFIG_FILE_NAME, "")).toFile();
    addRulesFromFile(globalRuleFile);
    // Add its-specific rules
    File itsSpecificRuleFile = itsPath.resolve(String.format(CONFIG_FILE_NAME, "-" + pluginName)).toFile();
    addRulesFromFile(itsSpecificRuleFile);
    if (!globalRuleFile.exists() && !itsSpecificRuleFile.exists()) {
        log.warn("Neither global rule file {} nor Its specific rule file {} exist. Please configure rules.", globalRuleFile, itsSpecificRuleFile);
    }
}
#end_block

#method_before
public Collection<ActionRequest> actionRequestsFor(Collection<Property> properties) {
    String projectName = getProjectFromProperties(properties);
    Collection<Rule> fromProjectConfig = rulesProjectCache.get(new Project.NameKey(projectName));
    Collection<Rule> rulesToAdd = !fromProjectConfig.isEmpty() ? fromProjectConfig : rules;
    Collection<ActionRequest> actions = new ArrayList<>();
    for (Rule rule : rulesToAdd) {
        actions.addAll(rule.actionRequestsFor(properties));
    }
    return actions;
}
#method_after
public Collection<ActionRequest> actionRequestsFor(Iterable<Property> properties) {
    Collection<ActionRequest> ret = Lists.newLinkedList();
    for (Rule rule : rules) {
        ret.addAll(rule.actionRequestsFor(properties));
    }
    return ret;
}
#end_block

#method_before
public void testEmptyRuleBase() throws IOException {
    injectRuleBase("");
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    Config config = capturedConfig.getValue();
    assertTrue(config.toText().isEmpty());
}
#method_after
public void testEmptyRuleBase() throws IOException {
    injectRuleBase("");
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
public void testSimpleRuleBase() throws IOException {
    String rules = "[rule \"rule1\"]\n\tconditionA = value1\n\taction = action1\n";
    injectRuleBase(rules);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testSimpleRuleBase() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\tconditionA = value1\n" + "\taction = action1");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value1")).andReturn(condition1);
    rule1.addCondition(condition1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
public void testBasicRuleBase() throws IOException {
    String rules = "[rule \"rule1\"]\n" + "\tconditionA = value1,value2\n" + "\tconditionA = value3,value of 4\n" + "\tconditionB = value5\n" + "\taction = action1\n" + "\taction = action2 param\n" + "\n" + "[ruleXZ \"nonrule\"]\n" + "\tconditionA = value1\n" + "\taction = action2\n" + "[rule \"rule2\"]\n" + "\tconditionC = value6\n" + "\taction = action3\n";
    injectRuleBase(rules);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testBasicRuleBase() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\tconditionA = value1,value2\n" + "\tconditionA = value3,value of 4\n" + "\tconditionB = value5\n" + "\taction = action1\n" + "\taction = action2 param\n" + "\n" + "[ruleXZ \"nonrule\"]\n" + "\tconditionA = value1\n" + "\taction = action2\n" + "[rule \"rule2\"]\n" + "\tconditionC = value6\n" + "\taction = action3");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value1,value2")).andReturn(condition1);
    rule1.addCondition(condition1);
    Condition condition2 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value3,value of 4")).andReturn(condition2);
    rule1.addCondition(condition2);
    Condition condition3 = createMock(Condition.class);
    expect(conditionFactory.create("conditionB", "value5")).andReturn(condition3);
    rule1.addCondition(condition3);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action2 param")).andReturn(actionRequest2);
    rule1.addActionRequest(actionRequest2);
    Rule rule2 = createMock(Rule.class);
    expect(ruleFactory.create("rule2")).andReturn(rule2);
    Condition condition4 = createMock(Condition.class);
    expect(conditionFactory.create("conditionC", "value6")).andReturn(condition4);
    rule2.addCondition(condition4);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action3")).andReturn(actionRequest3);
    rule2.addActionRequest(actionRequest3);
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
public void testActionRequestsForSimple() throws IOException {
    String rules = "[rule \"rule1\"]\n\taction = action1\n";
    injectRuleBase(rules);
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    Property property1 = createMock(Property.class);
    expect(property1.getKey()).andReturn(PROJECT_KEY);
    expect(property1.getValue()).andReturn(TEST_PROJECT);
    Collection<Property> properties = ImmutableList.of(property1);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of(rule1)).once();
    expect(rulesProjectCache.get(new Project.NameKey(TEST_PROJECT))).andReturn(ImmutableList.of());
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testActionRequestsForSimple() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    Collection<Property> properties = Collections.emptySet();
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(1);
    rule1Match.add(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3\n");
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    Property property1 = createMock(Property.class);
    expect(property1.getKey()).andReturn(PROJECT_KEY);
    expect(property1.getValue()).andReturn(TEST_PROJECT);
    Collection<Property> properties = ImmutableList.of(property1);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1, actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match).anyTimes();
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match).anyTimes();
    expect(rulesProjectCache.get(new Project.NameKey(TEST_PROJECT))).andReturn(ImmutableList.of());
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1, rule2)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1, actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#method_after
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action2")).andReturn(actionRequest2);
    rule1.addActionRequest(actionRequest2);
    Rule rule2 = createMock(Rule.class);
    expect(ruleFactory.create("rule2")).andReturn(rule2);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action3")).andReturn(actionRequest3);
    rule2.addActionRequest(actionRequest3);
    Collection<Property> properties = Lists.newArrayListWithCapacity(1);
    Property property1 = createMock(Property.class);
    properties.add(property1);
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(2);
    rule1Match.add(actionRequest1);
    rule1Match.add(actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    List<ActionRequest> rule2Match = Lists.newArrayListWithCapacity(1);
    rule2Match.add(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    expected.add(actionRequest2);
    expected.add(actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testSimpleItsRuleBase() throws IOException {
    String rules = "[rule \"rule1\"]\n\tconditionA = value1\n\taction = action1\n";
    injectRuleBase(rules, RuleBaseKind.ITS);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testSimpleItsRuleBase() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\tconditionA = value1\n" + "\taction = action1", RuleBaseKind.ITS);
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value1")).andReturn(condition1);
    rule1.addCondition(condition1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    itsPath = randomTargetPath().resolve("etc").resolve("its");
    assertFalse("itsPath (" + itsPath + ") already exists", Files.exists(itsPath));
    cleanupSitePath = true;
    rulesConfigReader = createMock(RulesConfigReader.class);
    bind(RulesConfigReader.class).toInstance(rulesConfigReader);
    rulesProjectCache = createMock(ItsRulesProjectCache.class);
    bind(ItsRulesProjectCache.class).toInstance(rulesProjectCache);
    bind(Path.class).annotatedWith(ItsPath.class).toInstance(itsPath);
    bind(String.class).annotatedWith(GlobalRulesFileName.class).toInstance(RuleBaseKind.GLOBAL.fileName);
    bind(String.class).annotatedWith(PluginRulesFileName.class).toInstance(RuleBaseKind.ITS.fileName);
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    itsPath = randomTargetPath().resolve("etc").resolve("its");
    assertFalse("itsPath (" + itsPath + ") already exists", Files.exists(itsPath));
    cleanupSitePath = true;
    bind(Path.class).annotatedWith(ItsPath.class).toInstance(itsPath);
    ruleFactory = createMock(Rule.Factory.class);
    bind(Rule.Factory.class).toInstance(ruleFactory);
    conditionFactory = createMock(Condition.Factory.class);
    bind(Condition.Factory.class).toInstance(conditionFactory);
    actionRequestFactory = createMock(ActionRequest.Factory.class);
    bind(ActionRequest.Factory.class).toInstance(actionRequestFactory);
}
#end_block

#method_before
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        Long unresolvedThreadCount = this.getCommentThreads().stream().filter(thread -> (thread.get(thread.size() - 1).unresolved)).count();
        unresolvedCommentCount = unresolvedThreadCount.intValue();
    }
    return unresolvedCommentCount;
}
#method_after
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        List<Comment> comments = Stream.concat(publishedComments().stream(), robotComments().stream()).collect(toList());
        // Build a map of uuid to list of direct descendants.
        Map<String, List<Comment>> forest = new HashMap<>();
        for (Comment comment : comments) {
            List<Comment> siblings = forest.get(comment.parentUuid);
            if (siblings == null) {
                siblings = new ArrayList<>();
                forest.put(comment.parentUuid, siblings);
            }
            siblings.add(comment);
        }
        // Find latest comment in each thread and apply to unresolved counter.
        int unresolved = 0;
        if (forest.containsKey(null)) {
            for (Comment root : forest.get(null)) {
                if (getLatestComment(forest, root).unresolved) {
                    unresolved++;
                }
            }
        }
        unresolvedCommentCount = unresolved;
    }
    return unresolvedCommentCount;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    try {
        permissionBackend.user(caller).check(GlobalPermission.ADMINISTRATE_SERVER);
    } catch (AuthException | PermissionBackendException e) {
        ((HttpServletResponse) rsp).sendError(HttpServletResponse.SC_NOT_FOUND, "Not Found");
        return;
    }
    chain.doFilter(req, rsp);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    try {
        permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
    } catch (AuthException | PermissionBackendException e) {
        ((HttpServletResponse) rsp).sendError(HttpServletResponse.SC_NOT_FOUND, "Not Found");
        return;
    }
    chain.doFilter(req, rsp);
}
#end_block

#method_before
@Override
protected void configure() {
    install(new PatternCacheModule());
    install(ContentTypeUtil.module());
    install(FooterValidator.module());
    install(MaxPathLengthValidator.module());
    install(FileExtensionValidator.module());
    install(EmailWhitelistValidator.module());
    install(InvalidFilenameValidator.module());
    install(SubmoduleValidator.module());
    install(SymlinkValidator.module());
    install(BlockedKeywordValidator.module());
    install(InvalidLineEndingValidator.module());
    install(ContentTypeValidator.module());
    install(DuplicatePathnameValidator.module());
    install(ValidatorConfig.module());
    bind(ConfigFactory.class).to(PluginConfigWithInheritanceFactory.class).in(Scopes.SINGLETON);
}
#method_after
@Override
protected void configure() {
    install(new PatternCacheModule());
    install(ContentTypeUtil.module());
    install(FooterValidator.module());
    install(MaxPathLengthValidator.module());
    install(FileExtensionValidator.module());
    install(ChangeEmailValidator.module());
    install(InvalidFilenameValidator.module());
    install(SubmoduleValidator.module());
    install(SymlinkValidator.module());
    install(BlockedKeywordValidator.module());
    install(InvalidLineEndingValidator.module());
    install(ContentTypeValidator.module());
    install(DuplicatePathnameValidator.module());
    install(ValidatorConfig.module());
    bind(ConfigFactory.class).to(PluginConfigWithInheritanceFactory.class).in(Scopes.SINGLETON);
}
#end_block

#method_before
@Override
protected void configureCommands() {
    DynamicItem.bind(binder(), SshCreateCommandInterceptor.class).to(HijackCommandInterceptor.class);
    command(HijackCommand.class);
}
#method_after
@Override
protected void configureCommands() {
    DynamicItem.bind(binder(), SshCreateCommandInterceptor.class).to(DisableCommandInterceptor.class);
    command(DisableCommand.class);
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnPatchSetCreated()) {
        return false;
    }
    // Ignore rebases or no code changes
    try {
        PatchSetAttribute patchSet;
        patchSet = event.patchSet.get();
        if (config.getIgnoreRebaseEmptyPatchSet() && (patchSet.kind == ChangeKind.TRIVIAL_REBASE || patchSet.kind == ChangeKind.MERGE_FIRST_PARENT_UPDATE || patchSet.kind == ChangeKind.NO_CODE_CHANGE || patchSet.kind == ChangeKind.NO_CHANGE)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking patch set kind", e);
    }
    boolean result;
    result = true;
    try {
        Pattern pattern;
        pattern = Pattern.compile(config.getIgnore(), Pattern.DOTALL);
        Matcher matcher;
        matcher = pattern.matcher(event.change.get().commitMessage);
        // If the ignore pattern matches, publishing should not happen
        result = !matcher.matches();
    } catch (Exception e) {
        LOGGER.warn("The specified ignore pattern was invalid", e);
    }
    return result;
}
#method_after
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnPatchSetCreated()) {
        return false;
    }
    // Ignore rebases or no code changes
    try {
        if (config.getIgnoreUnchangedPatchSet() && unchangedChangeKind(event.patchSet.get().kind)) {
            return false;
        }
    } catch (Exception e) {
        LOGGER.warn("Error checking patch set kind", e);
    }
    boolean result;
    result = true;
    try {
        Pattern pattern;
        pattern = Pattern.compile(config.getIgnore(), Pattern.DOTALL);
        Matcher matcher;
        matcher = pattern.matcher(event.change.get().commitMessage);
        // If the ignore pattern matches, publishing should not happen
        result = !matcher.matches();
    } catch (Exception e) {
        LOGGER.warn("The specified ignore pattern was invalid", e);
    }
    return result;
}
#end_block

#method_before
private ProjectConfig getConfig(String ignore, boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore);
    when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated);
    when(mockPluginConfig.getBoolean("ignore-rebase-empty-patch-set", true)).thenReturn(ignoreRebaseEmptyPatchSet);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#method_after
private ProjectConfig getConfig(String ignore, boolean publishOnPatchSetCreated, boolean ignoreUnchangedPatchSet) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore);
    when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated);
    when(mockPluginConfig.getBoolean("ignore-unchanged-patch-set", true)).thenReturn(ignoreUnchangedPatchSet);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreRebaseEmptyPatchSet);
}
#method_after
private ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreUnchangedPatchSet) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreUnchangedPatchSet);
}
#end_block

#method_before
@Test
public void doesNotPublishWhenTrivialRebase() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.TRIVIAL_REBASE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#method_after
@Test
public void doesNotPublishWhenTrivialRebase() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.TRIVIAL_REBASE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#end_block

#method_before
@Test
public void publishesWhenTrivialRebase() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.TRIVIAL_REBASE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenTrivialRebase() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.TRIVIAL_REBASE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void doesNotPublishWhenMergeUpdate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.MERGE_FIRST_PARENT_UPDATE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#method_after
@Test
public void doesNotPublishWhenMergeUpdate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.MERGE_FIRST_PARENT_UPDATE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#end_block

#method_before
@Test
public void publishesWhenMergeUpdate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.MERGE_FIRST_PARENT_UPDATE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenMergeUpdate() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.MERGE_FIRST_PARENT_UPDATE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void doesNotPublishWhenNoCodeChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.NO_CODE_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#method_after
@Test
public void doesNotPublishWhenNoCodeChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.NO_CODE_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#end_block

#method_before
@Test
public void publishesWhenNoCodeChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.NO_CODE_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenNoCodeChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.NO_CODE_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void doesNotPublishWhenNoChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.NO_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#method_after
@Test
public void doesNotPublishWhenNoChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.NO_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#end_block

#method_before
@Test
public void publishesWhenNoChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.NO_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenNoChange() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig(true, false);
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.NO_CHANGE;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void publishesWhenRework() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockAttr);
    mockAttr.kind = ChangeKind.REWORK;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenRework() throws Exception {
    // Setup mocks
    ProjectConfig config = getConfig();
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.patchSet = Suppliers.ofInstance(mockPatchSet);
    mockPatchSet.kind = ChangeKind.REWORK;
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Override
public String toString() {
    return "push " + uri;
}
#method_after
@Override
public String toString() {
    if (retryCount == 0) {
        return "push " + uri;
    }
    return "(retry " + retryCount + ") " + "push " + uri;
}
#end_block

#method_before
void setToRetry() {
    retrying = true;
}
#method_after
void setToRetry() {
    retrying = true;
    retryCount++;
}
#end_block

#method_before
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
}
#method_after
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    } finally {
        statesCleanUp();
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            log.error("Cannot replicate to " + uri + "; repository not found");
        } catch (NotSupportedException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (RuntimeException e) {
            log.error("Unexpected error during replication to " + uri, e);
        } catch (Error e) {
            log.error("Unexpected error during replication to " + uri, e);
        } finally {
            if (git != null) {
                git.close();
            }
            pool.notifyFinished(this);
        }
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        log.error("Cannot replicate " + projectName + "; " + e.getMessage());
    } catch (NoRemoteRepositoryException e) {
        wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else {
            log.error("Cannot replicate to " + uri, e);
        }
        // The remote push operation should be retried.
        pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    for (RemoteRefUpdate u : res.getRemoteUpdates()) {
        switch(u.getStatus()) {
            case OK:
            case UP_TO_DATE:
            case NON_EXISTING:
                break;
            case NOT_ATTEMPTED:
            case AWAITING_REPORT:
            case REJECTED_NODELETE:
            case REJECTED_NONFASTFORWARD:
            case REJECTED_REMOTE_CHANGED:
                log.error(String.format("Failed replicate of %s to %s: status %s", u.getRemoteName(), uri, u.getStatus()));
                break;
            case REJECTED_OTHER_REASON:
                if ("non-fast-forward".equals(u.getMessage())) {
                    log.error(String.format("Failed replicate of %s to %s" + ", remote rejected non-fast-forward push." + "  Check receive.denyNonFastForwards variable in config file" + " of destination repository.", u.getRemoteName(), uri));
                } else {
                    log.error(String.format("Failed replicate of %s to %s, reason: %s", u.getRemoteName(), uri, u.getMessage()));
                }
                break;
        }
    }
}
#method_after
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    updateStates(res.getRemoteUpdates());
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        ReplicationQueue.log.error(String.format("source project %s not available", project), err);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                ReplicationQueue.log.error(String.format("source project %s not available", project), err);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                ReplicationQueue.log.error(String.format("cannot check type of project %s", project), err);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (inflight) {
        synchronized (pending) {
            PushOne e = inflight.get(uri);
            if (e != null) {
            /* reschedule and return */
            }
            e = pending.get(uri);
            if (e == null) {
                e = opFactory.create(project, uri);
                pool.schedule(e, delay, TimeUnit.SECONDS);
                pending.put(uri, e);
            }
            e.addRef(ref);
        }
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount();
        e.addState(ref, state);
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp) {
    // It locks access to pending variable.
    synchronized (pending) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            // The PushOp method param instance should be scheduled for retry.
            // Remember when retrying it should be used different delay.
            pushOp.setToRetry();
            pending.put(uri, pushOp);
            pool.schedule(pushOp, retryDelay, TimeUnit.MINUTES);
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, delay, TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, retryDelay, TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
void notifyFinished(PushOne op) {
    synchronized (inflight) {
        inflight.remove(op.getURI());
    }
}
#method_after
void notifyFinished(PushOne op) {
    synchronized (stateLock) {
        inFlight.remove(op.getURI());
    }
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Test
public void testGetJGroupsSkipInterface() throws Exception {
    assertThat(getConfiguration().jgroups().skipInterface()).isEqualTo(DEFAULT_SKIP_INTERFACE_LIST);
    globalPluginConfig.setStringList(JGROUPS_SECTION, null, SKIP_INTERFACE_KEY, Lists.newArrayList("lo*", "eth0"));
    assertThat(getConfiguration().jgroups().skipInterface()).containsAllOf("lo*", "eth0").inOrder();
}
#method_after
@Test
public void testGetJGroupsSkipInterface() throws Exception {
    assertThat(getConfiguration().jgroups().skipInterface()).isEqualTo(DEFAULT_SKIP_INTERFACE_LIST);
    globalPluginConfig.setStringList(JGROUPS_SECTION, null, SKIP_INTERFACE_KEY, ImmutableList.of("lo*", "eth0"));
    assertThat(getConfiguration().jgroups().skipInterface()).containsAllOf("lo*", "eth0").inOrder();
}
#end_block

#method_before
@Test
public void testGetCachePatterns() throws Exception {
    globalPluginConfig.setStringList(CACHE_SECTION, null, PATTERN_KEY, Lists.newArrayList("^my_cache.*", "other"));
    assertThat(getConfiguration().cache().patterns()).containsExactly("^my_cache.*", "other");
}
#method_after
@Test
public void testGetCachePatterns() throws Exception {
    globalPluginConfig.setStringList(CACHE_SECTION, null, PATTERN_KEY, ImmutableList.of("^my_cache.*", "other"));
    assertThat(getConfiguration().cache().patterns()).containsExactly("^my_cache.*", "other");
}
#end_block

#method_before
@Test
public void testCachePatternMatcher() throws Exception {
    when(configurationMock.cache().patterns()).thenReturn(Lists.newArrayList("^my_cache.*", "other"));
    CachePatternMatcher matcher = new CachePatternMatcher(configurationMock);
    for (String cache : ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) {
        assertThat(matcher.matches(cache)).isTrue();
    }
    for (String cache : ImmutableList.of("ldap_groups_by_include", "foo")) {
        assertThat(matcher.matches(cache)).isFalse();
    }
}
#method_after
@Test
public void testCachePatternMatcher() throws Exception {
    when(configurationMock.cache().patterns()).thenReturn(ImmutableList.of("^my_cache.*", "other"));
    CachePatternMatcher matcher = new CachePatternMatcher(configurationMock);
    for (String cache : ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) {
        assertThat(matcher.matches(cache)).isTrue();
    }
    for (String cache : ImmutableList.of("ldap_groups_by_include", "foo")) {
        assertThat(matcher.matches(cache)).isFalse();
    }
}
#end_block

#method_before
@Test
public void testGetJGroupsCluster() throws Exception {
    globalPluginConfig.setString(JGROUPS_SECTION, null, CLUSTER_NAME_KEY, "foo");
    assertThat(getConfiguration().jgroups().clusterName()).isEqualTo("foo");
}
#method_after
@Test
public void testGetJGroupsCluster() throws Exception {
    assertThat(getConfiguration().jgroups().clusterName()).isEqualTo(DEFAULT_CLUSTER_NAME);
    globalPluginConfig.setString(JGROUPS_SECTION, null, CLUSTER_NAME_KEY, "foo");
    assertThat(getConfiguration().jgroups().clusterName()).isEqualTo("foo");
}
#end_block

#method_before
@Test
public void testGetJGroupsSkipInterface() throws Exception {
    assertThat(getConfiguration().jgroups().skipInterface()).isEqualTo(DEFAULT_SKIP_INTERFACE_LIST);
    globalPluginConfig.setStringList(JGROUPS_SECTION, null, SKIP_INTERFACE_KEY, Lists.newArrayList("lo*", "eth0"));
    assertThat(getConfiguration().jgroups().skipInterface()).containsAllOf("lo*", "eth0").inOrder();
}
#method_after
@Test
public void testGetJGroupsSkipInterface() throws Exception {
    assertThat(getConfiguration().jgroups().skipInterface()).isEqualTo(DEFAULT_SKIP_INTERFACE_LIST);
    globalPluginConfig.setStringList(JGROUPS_SECTION, null, SKIP_INTERFACE_KEY, ImmutableList.of("lo*", "eth0"));
    assertThat(getConfiguration().jgroups().skipInterface()).containsAllOf("lo*", "eth0").inOrder();
}
#end_block

#method_before
@Test
public void testGetIndexSynchronize() throws Exception {
    assertThat(getConfiguration().index().synchronize()).isTrue();
    globalPluginConfig.setBoolean(INDEX_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().index().synchronize()).isFalse();
    globalPluginConfig.setString(INDEX_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().index().synchronize()).isTrue();
}
#method_after
@Test
public void testGetIndexSynchronize() throws Exception {
    assertThat(getConfiguration().index().synchronize()).isEqualTo(DEFAULT_SYNCHRONIZE);
    globalPluginConfig.setBoolean(INDEX_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().index().synchronize()).isFalse();
    globalPluginConfig.setBoolean(INDEX_SECTION, null, SYNCHRONIZE_KEY, true);
    assertThat(getConfiguration().index().synchronize()).isTrue();
    globalPluginConfig.setString(INDEX_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().index().synchronize()).isTrue();
}
#end_block

#method_before
@Test
public void testGetCacheSynchronize() throws Exception {
    assertThat(getConfiguration().cache().synchronize()).isTrue();
    globalPluginConfig.setBoolean(CACHE_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().cache().synchronize()).isFalse();
    globalPluginConfig.setString(CACHE_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().cache().synchronize()).isTrue();
}
#method_after
@Test
public void testGetCacheSynchronize() throws Exception {
    assertThat(getConfiguration().cache().synchronize()).isEqualTo(DEFAULT_SYNCHRONIZE);
    globalPluginConfig.setBoolean(CACHE_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().cache().synchronize()).isFalse();
    globalPluginConfig.setBoolean(CACHE_SECTION, null, SYNCHRONIZE_KEY, true);
    assertThat(getConfiguration().cache().synchronize()).isTrue();
    globalPluginConfig.setString(CACHE_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().cache().synchronize()).isTrue();
}
#end_block

#method_before
@Test
public void testGetEventSynchronize() throws Exception {
    assertThat(getConfiguration().event().synchronize()).isTrue();
    globalPluginConfig.setBoolean(EVENT_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().event().synchronize()).isFalse();
    globalPluginConfig.setString(EVENT_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().event().synchronize()).isTrue();
}
#method_after
@Test
public void testGetEventSynchronize() throws Exception {
    assertThat(getConfiguration().event().synchronize()).isEqualTo(DEFAULT_SYNCHRONIZE);
    globalPluginConfig.setBoolean(EVENT_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().event().synchronize()).isFalse();
    globalPluginConfig.setBoolean(EVENT_SECTION, null, SYNCHRONIZE_KEY, true);
    assertThat(getConfiguration().event().synchronize()).isTrue();
    globalPluginConfig.setString(EVENT_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().event().synchronize()).isTrue();
}
#end_block

#method_before
@Test
public void testGetWebsessionSynchronize() throws Exception {
    assertThat(getConfiguration().websession().synchronize()).isTrue();
    globalPluginConfig.setBoolean(WEBSESSION_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().websession().synchronize()).isFalse();
    globalPluginConfig.setString(WEBSESSION_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().websession().synchronize()).isTrue();
}
#method_after
@Test
public void testGetWebsessionSynchronize() throws Exception {
    assertThat(getConfiguration().websession().synchronize()).isEqualTo(DEFAULT_SYNCHRONIZE);
    globalPluginConfig.setBoolean(WEBSESSION_SECTION, null, SYNCHRONIZE_KEY, false);
    assertThat(getConfiguration().websession().synchronize()).isFalse();
    globalPluginConfig.setBoolean(WEBSESSION_SECTION, null, SYNCHRONIZE_KEY, true);
    assertThat(getConfiguration().websession().synchronize()).isTrue();
    globalPluginConfig.setString(WEBSESSION_SECTION, null, SYNCHRONIZE_KEY, "invalidBoolean");
    assertThat(getConfiguration().websession().synchronize()).isTrue();
}
#end_block

#method_before
@Test
public void testGetCachePatterns() throws Exception {
    globalPluginConfig.setStringList(CACHE_SECTION, null, PATTERN_KEY, Lists.newArrayList("^my_cache.*", "other"));
    CachePatternMatcher matcher = new CachePatternMatcher(getConfiguration());
    for (String cache : ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) {
        assertThat(matcher.matches(cache)).isTrue();
    }
    for (String cache : ImmutableList.of("ldap_groups_by_include", "foo")) {
        assertThat(matcher.matches(cache)).isFalse();
    }
}
#method_after
@Test
public void testGetCachePatterns() throws Exception {
    globalPluginConfig.setStringList(CACHE_SECTION, null, PATTERN_KEY, ImmutableList.of("^my_cache.*", "other"));
    CachePatternMatcher matcher = new CachePatternMatcher(getConfiguration());
    for (String cache : ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) {
        assertThat(matcher.matches(cache)).isTrue();
    }
    for (String cache : ImmutableList.of("ldap_groups_by_include", "foo")) {
        assertThat(matcher.matches(cache)).isFalse();
    }
}
#end_block

#method_before
@Test
public void testHealthCheckEnabled() throws Exception {
    assertThat(getConfiguration().healthCheck().enabled()).isTrue();
    globalPluginConfig.setBoolean(HEALTH_CHECK_SECTION, null, ENABLE_KEY, false);
    assertThat(getConfiguration().healthCheck().enabled()).isFalse();
    globalPluginConfig.setBoolean(HEALTH_CHECK_SECTION, null, ENABLE_KEY, true);
    assertThat(getConfiguration().healthCheck().enabled()).isTrue();
}
#method_after
@Test
public void testHealthCheckEnabled() throws Exception {
    assertThat(getConfiguration().healthCheck().enabled()).isEqualTo(DEFAULT_HEALTH_CHECK_ENABLED);
    globalPluginConfig.setBoolean(HEALTH_CHECK_SECTION, null, ENABLE_KEY, false);
    assertThat(getConfiguration().healthCheck().enabled()).isFalse();
    globalPluginConfig.setBoolean(HEALTH_CHECK_SECTION, null, ENABLE_KEY, true);
    assertThat(getConfiguration().healthCheck().enabled()).isTrue();
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            repLog.info("Rescheduling replication to {} to avoid collision with an in-flight push.", uri);
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to {} started...", uri);
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to {} completed in {}ms, {}ms delay, {} retries", uri, (elapsed), (delay), retryCount);
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate {}; Remote repository error: {}", projectName, msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to {}: {}", uri, cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to {}: {}", uri, e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after {} occurrences of this error: {} during replication to {}", lockRetryCount, e.getMessage(), uri);
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to {}", uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            repLog.info("Rescheduling replication to {} to avoid collision with an in-flight push.", uri);
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to {} started...", uri);
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to {} completed in {}ms, {}ms delay, {} retries", uri, elapsed, delay, retryCount);
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate {}; Remote repository error: {}", projectName, msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to {}: {}", uri, cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to {}: {}", uri, e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after {} occurrences of this error: {} during replication to {}", lockRetryCount, e.getMessage(), uri);
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to {}", uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    DraftWorkflowMigrationStrategy strategy = DraftWorkflowMigrationStrategy.WORK_IN_PROGRESS;
    if (ui.yesno(false, "Migrate draft changes to private changes (default is work-in-progress)?")) {
        strategy = DraftWorkflowMigrationStrategy.PRIVATE;
    }
    ui.message(String.format("Replace draft changes with %s changes ...", strategy.name().toLowerCase()));
    try (StatementExecutor e = newExecutor(db)) {
        String column = strategy == DraftWorkflowMigrationStrategy.PRIVATE ? "is_private" : "work_in_progress";
        // Mark changes private/WIP and NEW if either:
        // * they have status DRAFT
        // * they have status NEW and have any draft patch sets
        e.execute(String.format("UPDATE changes " + "SET %s = 'Y', " + "    status = 'n' " + "    created_on = created_on " + "WHERE status = 'd' " + "  OR (status = 'n' " + "      AND EXISTS " + "        (SELECT * " + "         FROM patch_sets " + "         WHERE patch_sets.change_id = changes.change_id " + "           AND patch_sets.draft = 'Y')) ", column));
    }
    ui.message("done");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    DraftWorkflowMigrationStrategy strategy = DraftWorkflowMigrationStrategy.WORK_IN_PROGRESS;
    if (ui.yesno(false, "Migrate draft changes to private changes (default is work-in-progress)")) {
        strategy = DraftWorkflowMigrationStrategy.PRIVATE;
    }
    ui.message(String.format("Replace draft changes with %s changes ...", strategy.name().toLowerCase()));
    try (StatementExecutor e = newExecutor(db)) {
        String column = strategy == DraftWorkflowMigrationStrategy.PRIVATE ? "is_private" : "work_in_progress";
        // Mark changes private/WIP and NEW if either:
        // * they have status DRAFT
        // * they have status NEW and have any draft patch sets
        e.execute(String.format("UPDATE changes " + "SET %s = 'Y', " + "    status = 'n', " + "    created_on = created_on " + "WHERE status = 'd' " + "  OR (status = 'n' " + "      AND EXISTS " + "        (SELECT * " + "         FROM patch_sets " + "         WHERE patch_sets.change_id = changes.change_id " + "           AND patch_sets.draft = 'Y')) ", column));
    }
    ui.message("done");
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, changeControlFactory, permissionBackend, new MockUser(name, memberOf), newProjectState(local));
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, changeControlFactory, permissionBackend, refFilterFactory, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefPattern.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    // LinkedHashMap to maintain input ordering.
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    boolean perUser = filterRefMatchingSections(matcherList, ref, user, sectionToProject);
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    // Sort by ref pattern specificity. For equally specific patterns, the sections from the
    // project closer to the current one come first.
    sorter.sort(ref, sections);
    Set<String> permissionNames = new HashSet<>();
    for (AccessSection s : sections) {
        for (Permission p : s.getPermissions()) {
            permissionNames.add(p.getName());
        }
    }
    Map<String, List<PermissionRule>> rulesByPermission = new HashMap<>();
    Map<String, List<BlockAccessSection>> blockByPermission = new HashMap<>();
    for (String pn : permissionNames) {
        // TODO - do this body on demand?
        List<BlockAccessSection> blocks = findBlocks(sectionToProject, pn);
        if (!blocks.isEmpty()) {
            blockByPermission.put(pn, blocks);
        }
        List<PermissionRule> rules = calculateAllowRules(sections, pn);
        if (!rules.isEmpty()) {
            rulesByPermission.put(pn, rules);
        }
    }
    return new PermissionCollection(rulesByPermission, blockByPermission, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefPattern.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    // LinkedHashMap to maintain input ordering.
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    boolean perUser = filterRefMatchingSections(matcherList, ref, user, sectionToProject);
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    // Sort by ref pattern specificity. For equally specific patterns, the sections from the
    // project closer to the current one come first.
    sorter.sort(ref, sections);
    // For block permissions, we want a different order: first, we want to go from parent to child.
    List<Map.Entry<AccessSection, Project.NameKey>> accessDescending = Lists.reverse(Lists.newArrayList(sectionToProject.entrySet()));
    Map<Project.NameKey, List<AccessSection>> accessByProject = accessDescending.stream().collect(Collectors.groupingBy(e -> e.getValue(), LinkedHashMap::new, mapping(e -> e.getKey(), toList())));
    // Within each project, sort by ref specificity.
    for (List<AccessSection> secs : accessByProject.values()) {
        sorter.sort(ref, secs);
    }
    return new PermissionCollection(Lists.newArrayList(accessByProject.values()), sections, perUser);
}
#end_block

#method_before
static List<PermissionRule> calculateAllowRules(List<AccessSection> sections, String permName) {
    Set<SeenRule> seen = new HashSet<>();
    List<PermissionRule> r = new ArrayList<>();
    for (AccessSection s : sections) {
        Permission p = s.getPermission(permName);
        if (p == null) {
            continue;
        }
        for (PermissionRule pr : p.getRules()) {
            SeenRule sr = SeenRule.create(s, pr);
            if (!seen.add(sr)) {
                // If we see a DENY before an ALLOW rule, that causes the ALLOW rule to be skipped here, negating access.
                continue;
            }
            if (pr.getAction() == BLOCK) {
                // Block rules are handled elsewhere.
                continue;
            }
            if (pr.getAction() == PermissionRule.Action.DENY) {
                // DENY rules work by not adding ALLOW rules. Nothing else to do.
                continue;
            }
            r.add(pr);
        }
        if (p.getExclusiveGroup()) {
            // We found an exclusive permission, so no need to further go up the hierarchy.
            break;
        }
    }
    return r;
}
#method_after
private List<PermissionRule> calculateAllowRules(String permName) {
    Set<SeenRule> seen = new HashSet<>();
    List<PermissionRule> r = new ArrayList<>();
    for (AccessSection s : accessSectionsUpward) {
        Permission p = s.getPermission(permName);
        if (p == null) {
            continue;
        }
        for (PermissionRule pr : p.getRules()) {
            SeenRule sr = SeenRule.create(s, pr);
            if (seen.contains(sr)) {
                // negating access.
                continue;
            }
            seen.add(sr);
            if (pr.getAction() == BLOCK) {
                // Block rules are handled elsewhere.
                continue;
            }
            if (pr.getAction() == PermissionRule.Action.DENY) {
                // DENY rules work by not adding ALLOW rules. Nothing else to do.
                continue;
            }
            r.add(pr);
        }
        if (p.getExclusiveGroup()) {
            // We found an exclusive permission, so no need to further go up the hierarchy.
            break;
        }
    }
    return r;
}
#end_block

#method_before
private boolean canDelete() {
    if (RefNames.REFS_CONFIG.equals(refName)) {
        // should be removed first.
        return false;
    }
    switch(getUser().getAccessPath()) {
        case GIT:
            return canPushWithForce() || canPerform(Permission.DELETE);
        case JSON_RPC:
        case REST_API:
        case SSH_COMMAND:
        case UNKNOWN:
        case WEB_BROWSER:
        default:
            return (// it if force push is blocked, though. See commit 40bd5741026863c99bea13eb5384bd27855c5e1b
            (isOwner() && !isBlocked(Permission.PUSH, false, true)) || canPushWithForce() || canPerform(Permission.DELETE) || projectControl.isAdmin());
    }
}
#method_after
private boolean canDelete() {
    if (RefNames.REFS_CONFIG.equals(refName)) {
        // should be removed first.
        return false;
    }
    switch(getUser().getAccessPath()) {
        case GIT:
            return canPushWithForce() || canPerform(Permission.DELETE);
        case JSON_RPC:
        case REST_API:
        case SSH_COMMAND:
        case UNKNOWN:
        case WEB_BROWSER:
        default:
            return // it if force push is blocked, though. See commit 40bd5741026863c99bea13eb5384bd27855c5e1b
            (isOwner() && !isBlocked(Permission.PUSH, false, true)) || canPushWithForce() || canPerform(Permission.DELETE) || projectControl.isAdmin();
    }
}
#end_block

#method_before
private PermissionRange toRange(String permissionName, boolean isChangeOwner) {
    int blockAllowMin = Integer.MIN_VALUE, blockAllowMax = Integer.MAX_VALUE;
    for (BlockAccessSection s : relevant.getBlocks(permissionName)) {
        boolean blockFound = false;
        for (PermissionRule pr : s.blocks) {
            if (projectControl.match(pr, isChangeOwner)) {
                blockAllowMin = pr.getMin() + 1;
                blockAllowMax = pr.getMax() - 1;
                blockFound = true;
            }
        }
        for (PermissionRule pr : s.overrides) {
            if (projectControl.match(pr, isChangeOwner)) {
                blockAllowMin = pr.getMin();
                blockAllowMax = pr.getMax();
                break;
            }
        }
        if (blockFound) {
            break;
        }
    }
    int voteMin = 0, voteMax = 0;
    for (PermissionRule pr : relevant.getRules(permissionName)) {
        if (projectControl.match(pr, isChangeOwner) && pr.getAction() == PermissionRule.Action.ALLOW) {
            // For votes, contrary to normal permissions, we aggregate all applicable rules.
            voteMin = Math.min(voteMin, pr.getMin());
            voteMax = Math.max(voteMax, pr.getMax());
        }
    }
    return new PermissionRange(permissionName, Math.max(voteMin, blockAllowMin), Math.min(voteMax, blockAllowMax));
}
#method_after
private PermissionRange toRange(String permissionName, boolean isChangeOwner) {
    int blockAllowMin = Integer.MIN_VALUE, blockAllowMax = Integer.MAX_VALUE;
    projectLoop: for (List<Permission> ps : relevant.getBlockRules(permissionName)) {
        boolean blockFound = false;
        int projectBlockAllowMin = Integer.MIN_VALUE, projectBlockAllowMax = Integer.MAX_VALUE;
        for (Permission p : ps) {
            if (p.getExclusiveGroup()) {
                for (PermissionRule pr : p.getRules()) {
                    if (pr.getAction() == Action.ALLOW && projectControl.match(pr, isChangeOwner)) {
                        // exclusive override, usually for a more specific ref.
                        continue projectLoop;
                    }
                }
            }
            for (PermissionRule pr : p.getRules()) {
                if (pr.getAction() == Action.BLOCK && projectControl.match(pr, isChangeOwner)) {
                    projectBlockAllowMin = pr.getMin() + 1;
                    projectBlockAllowMax = pr.getMax() - 1;
                    blockFound = true;
                }
            }
            if (blockFound) {
                for (PermissionRule pr : p.getRules()) {
                    if (pr.getAction() == Action.ALLOW && projectControl.match(pr, isChangeOwner)) {
                        projectBlockAllowMin = pr.getMin();
                        projectBlockAllowMax = pr.getMax();
                        break;
                    }
                }
                break;
            }
        }
        blockAllowMin = Math.max(projectBlockAllowMin, blockAllowMin);
        blockAllowMax = Math.min(projectBlockAllowMax, blockAllowMax);
    }
    int voteMin = 0, voteMax = 0;
    for (PermissionRule pr : relevant.getAllowRules(permissionName)) {
        if (pr.getAction() == PermissionRule.Action.ALLOW && projectControl.match(pr, isChangeOwner)) {
            // For votes, contrary to normal permissions, we aggregate all applicable rules.
            voteMin = Math.min(voteMin, pr.getMin());
            voteMax = Math.max(voteMax, pr.getMax());
        }
    }
    return new PermissionRange(permissionName, Math.max(voteMin, blockAllowMin), Math.min(voteMax, blockAllowMax));
}
#end_block

#method_before
private boolean isBlocked(String permissionName, boolean isChangeOwner, boolean withForce) {
    for (BlockAccessSection s : relevant.getBlocks(permissionName)) {
        boolean blocked = false;
        for (PermissionRule pr : s.blocks) {
            if (!projectControl.match(pr, isChangeOwner)) {
                continue;
            }
            if (!withForce && pr.getForce()) {
                // force on block rule only applies to withForce pushes.
                continue;
            }
            blocked = true;
            break;
        }
        if (blocked) {
            for (PermissionRule pr : s.overrides) {
                if (projectControl.match(pr, isChangeOwner) && pr.getAction() == Action.ALLOW) {
                    // can't return true yet; child project may introduce another block rule.
                    blocked = false;
                }
            }
        }
        if (blocked) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isBlocked(String permissionName, boolean isChangeOwner, boolean withForce) {
    // Permissions are ordered by (more general project, more specific ref). Because Permission
    // does not have back pointers, we can't tell what ref-pattern or project each permission comes
    // from.
    List<List<Permission>> downwardPerProject = relevant.getBlockRules(permissionName);
    projectLoop: for (List<Permission> projectRules : downwardPerProject) {
        boolean overrideFound = false;
        for (Permission p : projectRules) {
            // If this is an exclusive ALLOW, then block rules from the same project are ignored.
            if (p.getExclusiveGroup()) {
                for (PermissionRule pr : p.getRules()) {
                    if (isAllow(pr, withForce) && projectControl.match(pr, isChangeOwner)) {
                        overrideFound = true;
                        break;
                    }
                }
            }
            if (overrideFound) {
                // Found an exclusive override, nothing further to do in this project.
                continue projectLoop;
            }
            boolean blocked = false;
            for (PermissionRule pr : p.getRules()) {
                if (!withForce && pr.getForce()) {
                    // force on block rule only applies to withForce permission.
                    continue;
                }
                if (isBlock(pr, withForce) && projectControl.match(pr, isChangeOwner)) {
                    blocked = true;
                    break;
                }
            }
            if (blocked) {
                // ALLOW in the same AccessSection (ie. in the same Permission) overrides the BLOCK.
                for (PermissionRule pr : p.getRules()) {
                    if (isAllow(pr, withForce) && projectControl.match(pr, isChangeOwner)) {
                        blocked = false;
                        break;
                    }
                }
            }
            if (blocked) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private boolean canPerform(String permissionName, boolean isChangeOwner, boolean withForce) {
    // TODO - reinstate the user => List<PermissionRule> caching.
    if (isBlocked(permissionName, isChangeOwner, withForce)) {
        return false;
    }
    for (PermissionRule pr : relevant.getRules(permissionName)) {
        if (projectControl.match(pr, isChangeOwner)) {
            if (withForce) {
                if (pr.getAction() == Action.ALLOW && pr.getForce()) {
                    return true;
                }
            } else if (pr.getAction() == Action.ALLOW) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean canPerform(String permissionName, boolean isChangeOwner, boolean withForce) {
    if (isBlocked(permissionName, isChangeOwner, withForce)) {
        return false;
    }
    for (PermissionRule pr : relevant.getAllowRules(permissionName)) {
        if (isAllow(pr, withForce) && projectControl.match(pr, isChangeOwner)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private String extractWhat(DispatchCommand dcmd) {
    if (dcmd == null) {
        return "Command was already destroyed";
    }
    StringBuilder commandName = new StringBuilder(dcmd.getCommandName());
    String[] trimmedArgs = dcmd.getTrimmedArguments();
    if (trimmedArgs != null) {
        for (int i = 1; i < trimmedArgs.length; i++) {
            commandName.append(".").append(trimmedArgs[i]);
        }
    }
    return commandName.toString();
}
#method_after
private String extractWhat(DispatchCommand dcmd) {
    if (dcmd == null) {
        return "Command was already destroyed";
    }
    StringBuilder commandName = new StringBuilder(dcmd.getCommandName());
    String[] trimmedArgs = dcmd.getTrimmedArguments();
    if (trimmedArgs != null) {
        commandName.append(Joiner.on(".").join(trimmedArgs));
    }
    return commandName.toString();
}
#end_block

#method_before
@Override
public Object apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, AuthException, RestApiException {
    assertDeletePermission(rsrc);
    assertCanDelete(rsrc, input);
    if (input == null || !input.force) {
        Collection<String> warnings = getWarnings(rsrc);
        if (!warnings.isEmpty()) {
            throw new ResourceConflictException(String.format("Project %s has open changes", rsrc.getName()));
        }
    }
    doDelete(rsrc, input);
    return Response.none();
}
#method_after
@Override
public Object apply(ProjectResource rsrc, Input input) throws OrmException, IOException, RestApiException {
    assertDeletePermission(rsrc);
    assertCanDelete(rsrc, input);
    if (input == null || !input.force) {
        Collection<String> warnings = getWarnings(rsrc);
        if (!warnings.isEmpty()) {
            throw new ResourceConflictException(String.format("Project %s has open changes", rsrc.getName()));
        }
    }
    doDelete(rsrc, input);
    return Response.none();
}
#end_block

#method_before
public void doDelete(ProjectResource rsrc, Input input) throws OrmException, IOException, ResourceNotFoundException, ResourceConflictException, RestApiException {
    Project project = rsrc.getProjectState().getProject();
    boolean preserve = input != null && input.preserve;
    Exception ex = null;
    try {
        if (!preserve || !cfgFactory.getFromGerritConfig(pluginName).getBoolean("hideProjectOnPreserve", false)) {
            if (!migration.disableChangeReviewDb()) {
                dbHandler.delete(project);
            }
            try {
                fsHandler.delete(project, preserve);
            } catch (RepositoryNotFoundException e) {
                throw new ResourceNotFoundException();
            }
            cacheHandler.delete(project);
        } else {
            hideProject.apply(rsrc);
        }
    } catch (Exception e) {
        ex = e;
        throw e;
    } finally {
        deleteLog.onDelete((IdentifiedUser) userProvider.get(), project.getNameKey(), input, ex);
    }
}
#method_after
public void doDelete(ProjectResource rsrc, Input input) throws OrmException, IOException, RestApiException {
    Project project = rsrc.getProjectState().getProject();
    boolean preserve = input != null && input.preserve;
    Exception ex = null;
    try {
        if (!preserve || !cfgFactory.getFromGerritConfig(pluginName).getBoolean("hideProjectOnPreserve", false)) {
            if (!migration.disableChangeReviewDb()) {
                dbHandler.delete(project);
            }
            try {
                fsHandler.delete(project, preserve);
            } catch (RepositoryNotFoundException e) {
                throw new ResourceNotFoundException();
            }
            cacheHandler.delete(project);
        } else {
            hideProject.apply(rsrc);
        }
    } catch (Exception e) {
        ex = e;
        throw e;
    } finally {
        deleteLog.onDelete((IdentifiedUser) userProvider.get(), project.getNameKey(), input, ex);
    }
}
#end_block

#method_before
public void apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, RestApiException {
    try {
        MetaDataUpdate md = metaDataUpdateFactory.create(rsrc.getNameKey());
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setState(ProjectState.HIDDEN);
        for (AccessSection as : projectConfig.getAccessSections()) {
            projectConfig.remove(as);
        }
        String parentForDeletedProjects = cfgFactory.getFromGerritConfig(pluginName).getString("parentForDeletedProjects", DEFAULT_PARENT_FOR_DELETED_PROJECTS);
        createProjectIfMissing(parentForDeletedProjects);
        p.setParentName(parentForDeletedProjects);
        md.setMessage("Hide project\n");
        projectConfig.commit(md);
        projectCache.evict(projectConfig.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException();
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
public void apply(ProjectResource rsrc) throws IOException, RestApiException {
    try {
        MetaDataUpdate md = metaDataUpdateFactory.create(rsrc.getNameKey());
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setState(ProjectState.HIDDEN);
        for (AccessSection as : projectConfig.getAccessSections()) {
            projectConfig.remove(as);
        }
        String parentForDeletedProjects = cfgFactory.getFromGerritConfig(pluginName).getString("parentForDeletedProjects", DEFAULT_PARENT_FOR_DELETED_PROJECTS);
        createProjectIfMissing(parentForDeletedProjects);
        p.setParentName(parentForDeletedProjects);
        md.setMessage("Hide project\n");
        projectConfig.commit(md);
        projectCache.evict(projectConfig.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException();
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private void createProjectIfMissing(String projectName) throws ResourceConflictException, IOException, RestApiException {
    if (projectCache.get(new Project.NameKey(projectName)) == null) {
        try {
            createProjectFactory.create(projectName).apply(TopLevelResource.INSTANCE, null);
        } catch (BadRequestException | UnprocessableEntityException | ResourceNotFoundException | ConfigInvalidException | PermissionBackendException e) {
            throw new ResourceConflictException(String.format("Failed to create project %s", projectName));
        }
    }
}
#method_after
private void createProjectIfMissing(String projectName) throws IOException, RestApiException {
    if (projectCache.get(new Project.NameKey(projectName)) == null) {
        try {
            createProjectFactory.create(projectName).apply(TopLevelResource.INSTANCE, null);
        } catch (RestApiException | ConfigInvalidException | PermissionBackendException e) {
            throw new ResourceConflictException(String.format("Failed to create project %s", projectName));
        }
    }
}
#end_block

#method_before
@Override
public void run() throws Failure, RestApiException {
    try {
        DeleteProject.Input input = new DeleteProject.Input();
        input.force = force;
        input.preserve = preserveGitRepository;
        ProjectResource rsrc = new ProjectResource(projectState, user);
        deleteProject.assertDeletePermission(rsrc);
        deleteProject.assertCanDelete(rsrc, input);
        if (!yesReallyDelete) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("Really delete ");
            msgBuilder.append(rsrc.getName());
            msgBuilder.append("?\n");
            msgBuilder.append("This is an operation which permanently deletes ");
            msgBuilder.append("data. This cannot be undone!\n");
            msgBuilder.append("If you are sure you wish to delete this project, ");
            msgBuilder.append("re-run\n");
            msgBuilder.append("with the --yes-really-delete flag.\n");
            throw new UnloggedFailure(msgBuilder.toString());
        }
        if (!force) {
            Collection<String> warnings = deleteProject.getWarnings(rsrc);
            if (warnings != null && !warnings.isEmpty()) {
                StringBuilder msgBuilder = new StringBuilder();
                msgBuilder.append("There are warnings against deleting ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(":\n");
                for (String warning : warnings) {
                    msgBuilder.append(" * ");
                    msgBuilder.append(warning);
                    msgBuilder.append("\n");
                }
                msgBuilder.append("To really delete ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(", re-run with the --force flag.");
                throw new UnloggedFailure(msgBuilder.toString());
            }
        }
        deleteProject.doDelete(rsrc, input);
    } catch (AuthException | ResourceNotFoundException | ResourceConflictException | OrmException | IOException e) {
        die(e);
    }
}
#method_after
@Override
public void run() throws Failure {
    try {
        DeleteProject.Input input = new DeleteProject.Input();
        input.force = force;
        input.preserve = preserveGitRepository;
        ProjectResource rsrc = new ProjectResource(projectState, user);
        deleteProject.assertDeletePermission(rsrc);
        deleteProject.assertCanDelete(rsrc, input);
        if (!yesReallyDelete) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("Really delete ");
            msgBuilder.append(rsrc.getName());
            msgBuilder.append("?\n");
            msgBuilder.append("This is an operation which permanently deletes ");
            msgBuilder.append("data. This cannot be undone!\n");
            msgBuilder.append("If you are sure you wish to delete this project, ");
            msgBuilder.append("re-run\n");
            msgBuilder.append("with the --yes-really-delete flag.\n");
            throw new UnloggedFailure(msgBuilder.toString());
        }
        if (!force) {
            Collection<String> warnings = deleteProject.getWarnings(rsrc);
            if (warnings != null && !warnings.isEmpty()) {
                StringBuilder msgBuilder = new StringBuilder();
                msgBuilder.append("There are warnings against deleting ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(":\n");
                for (String warning : warnings) {
                    msgBuilder.append(" * ");
                    msgBuilder.append(warning);
                    msgBuilder.append("\n");
                }
                msgBuilder.append("To really delete ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(", re-run with the --force flag.");
                throw new UnloggedFailure(msgBuilder.toString());
            }
        }
        deleteProject.doDelete(rsrc, input);
    } catch (RestApiException | OrmException | IOException e) {
        die(e);
    }
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectState projectState, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException, ConfigInvalidException, PermissionBackendException {
    CurrentUser currentUser = self.get();
    log.debug("Suggesting reviewers for change {} to user {}.", currentUser.isIdentifiedUser() ? currentUser.asIdentifiedUser().getLoggableName() : currentUser.getUserName().orElse(currentUser.getClass().getSimpleName()), changeNotes.getChangeId().get());
    String query = suggestReviewers.getQuery();
    log.debug("Query: {}", query);
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        log.debug("Reviewer suggestion is disabled.");
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers);
        log.debug("Candidate list: {}", candidateList);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectState, candidateList);
    log.debug("Sorted recommendations: {}", sortedRecommendations);
    // Filter accounts by visibility and enforce limit
    List<Account.Id> filteredRecommendations = new ArrayList<>();
    try (Timer0.Context ctx = metrics.filterVisibility.start()) {
        for (Account.Id reviewer : sortedRecommendations) {
            if (filteredRecommendations.size() >= limit) {
                break;
            }
            // Check if change is visible to reviewer and if the current user can see reviewer
            if (visibilityControl.isVisibleTo(reviewer) && accountControlFactory.get().canSee(reviewer)) {
                filteredRecommendations.add(reviewer);
            }
        }
    }
    log.debug("Filtered recommendations: {}", filteredRecommendations);
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(filteredRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectState, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() > limit) {
        suggestedReviewer = suggestedReviewer.subList(0, limit);
        log.debug("Limited suggested reviewers to {} accounts.", limit);
    }
    log.debug("Suggested reviewers: {}", suggestedReviewer.stream().map(r -> {
        if (r.account != null) {
            return "a/" + r.account._accountId;
        } else if (r.group != null) {
            return "g/" + r.group.id;
        } else {
            return "";
        }
    }).collect(toList()));
    return suggestedReviewer;
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectState projectState, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException, ConfigInvalidException, PermissionBackendException {
    CurrentUser currentUser = self.get();
    log.debug("Suggesting reviewers for change {} to user {}.", changeNotes.getChangeId().get(), currentUser.getLoggableName());
    String query = suggestReviewers.getQuery();
    log.debug("Query: {}", query);
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        log.debug("Reviewer suggestion is disabled.");
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers);
        log.debug("Candidate list: {}", candidateList);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectState, candidateList);
    log.debug("Sorted recommendations: {}", sortedRecommendations);
    // Filter accounts by visibility and enforce limit
    List<Account.Id> filteredRecommendations = new ArrayList<>();
    try (Timer0.Context ctx = metrics.filterVisibility.start()) {
        for (Account.Id reviewer : sortedRecommendations) {
            if (filteredRecommendations.size() >= limit) {
                break;
            }
            // Check if change is visible to reviewer and if the current user can see reviewer
            if (visibilityControl.isVisibleTo(reviewer) && accountControlFactory.get().canSee(reviewer)) {
                filteredRecommendations.add(reviewer);
            }
        }
    }
    log.debug("Filtered recommendations: {}", filteredRecommendations);
    List<SuggestedReviewerInfo> suggestedReviewers = loadAccounts(filteredRecommendations);
    if (!excludeGroups && suggestedReviewers.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewers.addAll(suggestAccountGroups(suggestReviewers, projectState, visibilityControl, limit - suggestedReviewers.size()));
    }
    if (suggestedReviewers.size() > limit) {
        suggestedReviewers = suggestedReviewers.subList(0, limit);
        log.debug("Limited suggested reviewers to {} accounts.", limit);
    }
    log.debug("Suggested reviewers: {}", suggestedReviewers.stream().map(r -> {
        if (r.account != null) {
            return "a/" + r.account._accountId;
        } else if (r.group != null) {
            return "g/" + r.group.id;
        } else {
            return "";
        }
    }).collect(toList()));
    return suggestedReviewers;
}
#end_block

#method_before
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + "account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, " + "patch_set_id INTEGER DEFAULT 0 NOT NULL, " + "file_name VARCHAR(256) DEFAULT '' NOT NULL, " + "CONSTRAINT primary_key_account_patch_reviews " + "PRIMARY KEY (change_id, patch_set_id, account_id, file_name)" + ")");
}
#method_after
protected void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + "account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, " + "patch_set_id INTEGER DEFAULT 0 NOT NULL, " + "file_name VARCHAR(4096) DEFAULT '' NOT NULL, " + "CONSTRAINT primary_key_account_patch_reviews " + "PRIMARY KEY (change_id, patch_set_id, account_id, file_name)" + ")");
}
#end_block

#method_before
@Override
public boolean isNameConflicting(String name) throws IOException {
    return delegate.isNameConflicting(name);
}
#method_after
@Override
public boolean isNameConflicting(String name) throws IOException {
    return git.getRefDatabase().isNameConflicting(name);
}
#end_block

#method_before
@Override
public Ref exactRef(String name) throws IOException {
    Ref ref = delegate.exactRef(name);
    if (ref == null) {
        return null;
    }
    try {
        return perm.filter(ImmutableMap.of(name, ref), git, RefFilterOptions.defaults()).get(name);
    } catch (PermissionBackendException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public Ref exactRef(String name) throws IOException {
    Ref ref = git.getRefDatabase().exactRef(name);
    if (ref == null) {
        return null;
    }
    try {
        return perm.filter(ImmutableMap.of(name, ref), git, RefFilterOptions.builder().setFilterTagsSeparately(true).build()).get(name);
    } catch (PermissionBackendException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public Ref getRef(String name) throws IOException {
    Ref ref = delegate.getRef(name);
    if (ref == null) {
        return null;
    }
    try {
        return perm.filter(ImmutableMap.of(ref.getName(), ref), git, RefFilterOptions.defaults()).get(ref.getName());
    } catch (PermissionBackendException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public Ref getRef(String name) throws IOException {
    Ref ref = git.getRefDatabase().getRef(name);
    if (ref == null) {
        return null;
    }
    try {
        return perm.filter(ImmutableMap.of(ref.getName(), ref), git, RefFilterOptions.builder().setFilterTagsSeparately(true).build()).get(ref.getName());
    } catch (PermissionBackendException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public Map<String, Ref> getRefs(String prefix) throws IOException {
    Map<String, Ref> refs;
    try {
        refs = perm.filter(delegate.getRefs(prefix), git, RefFilterOptions.defaults());
    } catch (PermissionBackendException e) {
        throw new IOException(e);
    }
    Map<String, Ref> result = Maps.newHashMapWithExpectedSize(refs.size());
    for (Ref ref : refs.values()) {
        // VisibleRefFilter adds the prefix to the keys, re-strip it.
        result.put(ref.getName().substring(prefix.length()), ref);
    }
    return refs;
}
#method_after
@Override
public Map<String, Ref> getRefs(String prefix) throws IOException {
    Map<String, Ref> refs;
    try {
        refs = perm.filter(git.getRefDatabase().getRefs(prefix), git, RefFilterOptions.builder().setFilterTagsSeparately(true).build());
    } catch (PermissionBackendException e) {
        throw new IOException(e);
    }
    Map<String, Ref> result = Maps.newHashMapWithExpectedSize(refs.size());
    for (Ref ref : refs.values()) {
        // VisibleRefFilter adds the prefix to the keys, re-strip it.
        result.put(ref.getName().substring(prefix.length()), ref);
    }
    return refs;
}
#end_block

#method_before
@Override
public List<Ref> getAdditionalRefs() throws IOException {
    List<Ref> refs = delegate.getAdditionalRefs();
    Map<String, Ref> result = Maps.newHashMapWithExpectedSize(refs.size());
    for (Ref ref : refs) {
        result.put(ref.getName(), ref);
    }
    return ImmutableList.copyOf(result.values());
}
#method_after
@Override
public List<Ref> getAdditionalRefs() throws IOException {
    List<Ref> refs = git.getRefDatabase().getAdditionalRefs();
    Map<String, Ref> result = Maps.newHashMapWithExpectedSize(refs.size());
    for (Ref ref : refs) {
        result.put(ref.getName(), ref);
    }
    return ImmutableList.copyOf(result.values());
}
#end_block

#method_before
@Override
public Ref peel(Ref ref) throws IOException {
    return delegate.peel(ref);
}
#method_after
@Override
public Ref peel(Ref ref) throws IOException {
    return git.getRefDatabase().peel(ref);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change;
    try {
        change = cd.change();
        if (change == null) {
            return false;
        }
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    ChangeNotes notes = notesFactory.createFromIndexedChange(change);
    ChangeControl cc = changeControl.controlFor(notes, user);
    boolean visible;
    try {
        visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        throw new OrmException("unable to check permissions", e);
    }
    if (visible) {
        cd.cacheVisibleTo(cc);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change = cd.change();
    if (change == null) {
        return false;
    }
    ChangeControl changeControl;
    ChangeNotes notes = notesFactory.createFromIndexedChange(change);
    try {
        changeControl = changeControlFactory.controlFor(notes, user);
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    boolean visible;
    try {
        visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        throw new OrmException("unable to check permissions", e);
    }
    if (visible) {
        cd.cacheVisibleTo(changeControl);
        return true;
    }
    return false;
}
#end_block

#method_before
public final SiteIndexer<K, V, I> getSiteIndexer() {
    return siteIndexer.get();
}
#method_after
@Nullable
public final SiteIndexer<K, V, I> getSiteIndexer() {
    return siteIndexer;
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        accountsByEmail.putAll(emailList.get(i), r.get(i));
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    return query(AccountPredicates.preferredEmail(email));
}
#end_block

#method_before
private void autoReindexIfStale(ChangeData cd) throws IOException {
    try {
        autoReindexIfStale(cd.project(), cd.getId());
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private void autoReindexIfStale(ChangeData cd) {
    autoReindexIfStale(cd.project(), cd.getId());
}
#end_block

#method_before
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    ProjectState state = projectCache.checkedGet(nameKey);
    if (state == null) {
        throw new ResourceNotFoundException(nameKey.get());
    }
    return apply(new ProjectResource(state, user.get()));
}
#method_after
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException {
    ProjectState state = projectCache.checkedGet(nameKey);
    if (state == null) {
        throw new ResourceNotFoundException(nameKey.get());
    }
    return apply(new ProjectResource(state, user.get()));
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectState projectState = projectCache.checkedGet(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        info.configWebLinks = new ArrayList<>();
        // config may have a null revision if the repo doesn't have its own refs/meta/config.
        if (config.getRevision() != null) {
            // gone, WebLinks should be fixed to use the extension data types.
            for (WebLinkInfoCommon wl : webLinks.getFileHistoryLinks(projectName.get(), config.getRevision().getName(), ProjectConfig.PROJECT_CONFIG)) {
                info.configWebLinks.add(new WebLinkInfo(wl.name, wl.imageUrl, wl.url, wl.target));
            }
        }
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    // The following implementation must match the ProjectAccessFactory JSON RPC endpoint.
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> groups = new HashMap<>();
    boolean canReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    // config to set the project state to any state that is not HIDDEN.
    if (!canWriteConfig) {
        projectState.checkStatePermitsRead();
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(groups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(groups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        loadGroup(groups, groupId);
                        if (dstPerm == null) {
                            if (dst == null) {
                                dst = new AccessSection(name);
                                info.local.put(name, createAccessSection(groups, dst));
                            }
                            dstPerm = dst.getPermission(srcPerm.getName(), true);
                        }
                        dstPerm.add(srcRule);
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(projectState.parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(projectState.statePermitsWrite() && (canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE))));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = groups.entrySet().stream().collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectState projectState = projectCache.checkedGet(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        info.configWebLinks = new ArrayList<>();
        // config may have a null revision if the repo doesn't have its own refs/meta/config.
        if (config.getRevision() != null) {
            // gone, WebLinks should be fixed to use the extension data types.
            for (WebLinkInfoCommon wl : webLinks.getFileHistoryLinks(projectName.get(), config.getRevision().getName(), ProjectConfig.PROJECT_CONFIG)) {
                info.configWebLinks.add(new WebLinkInfo(wl.name, wl.imageUrl, wl.url, wl.target));
            }
        }
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    // The following implementation must match the ProjectAccessFactory JSON RPC endpoint.
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> groups = new HashMap<>();
    boolean canReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    // config to set the project state to any state that is not HIDDEN.
    if (!canWriteConfig) {
        projectState.checkStatePermitsRead();
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(groups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(groups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        loadGroup(groups, groupId);
                        if (dstPerm == null) {
                            if (dst == null) {
                                dst = new AccessSection(name);
                                info.local.put(name, createAccessSection(groups, dst));
                            }
                            dstPerm = dst.getPermission(srcPerm.getName(), true);
                        }
                        dstPerm.add(srcRule);
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(projectState.parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(projectState.statePermitsWrite() && (canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE))));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = groups.entrySet().stream().filter(e -> e.getValue() != null).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#end_block

#method_before
private void loadGroup(Map<AccountGroup.UUID, GroupInfo> visibleGroups, AccountGroup.UUID id) throws OrmException {
    if (!visibleGroups.containsKey(id)) {
        GroupInfo group;
        try {
            GroupControl control = groupControlFactory.controlFor(id);
            group = groupJson.format(control.getGroup());
            group.id = null;
            // Paranoia: we don't check visibility, so make sure sensitive data isn't there.
            group.members = null;
            group.includes = null;
        } catch (NoSuchGroupException e) {
            LOG.warn("NoSuchGroupException; ignoring group " + id, e);
            group = null;
        }
        visibleGroups.put(id, group);
    }
}
#method_after
private void loadGroup(Map<AccountGroup.UUID, GroupInfo> groups, AccountGroup.UUID id) {
    if (!groups.containsKey(id)) {
        GroupDescription.Basic basic = groupBackend.get(id);
        GroupInfo group;
        if (basic != null) {
            group = new GroupInfo();
            // The UI only needs name + URL, so don't populate other fields to avoid leaking data
            // about groups invisible to the user.
            group.name = basic.getName();
            group.url = basic.getUrl();
        } else {
            LOG.warn("no such group: " + id);
            group = null;
        }
        groups.put(id, group);
    }
}
#end_block

#method_before
private AccessSectionInfo createAccessSection(Map<AccountGroup.UUID, GroupInfo> groups, AccessSection section) throws OrmException {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = new HashMap<>();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = new HashMap<>();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(ACTION_TYPE.get(r.getAction()), r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            AccountGroup.UUID group = r.getGroup().getUUID();
            if (group != null) {
                pInfo.rules.put(group.get(), info);
                loadGroup(groups, group);
            }
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#method_after
private AccessSectionInfo createAccessSection(Map<AccountGroup.UUID, GroupInfo> groups, AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = new HashMap<>();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = new HashMap<>();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(ACTION_TYPE.get(r.getAction()), r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            AccountGroup.UUID group = r.getGroup().getUUID();
            if (group != null) {
                pInfo.rules.put(group.get(), info);
                loadGroup(groups, group);
            }
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#end_block

#method_before
@Provides
@Singleton
@IndexExecutor(BATCH)
ListeningExecutorService getBatchIndexExecutor(@GerritServerConfig Config config, WorkQueue workQueue) {
    if (batchExecutor != null) {
        return batchExecutor;
    }
    int batchThreads = this.threads;
    if (batchThreads <= 0)
        batchThreads = config.getInt("index", null, "batchThreads", 0);
    if (batchThreads <= 0) {
        batchThreads = Runtime.getRuntime().availableProcessors();
    }
    return MoreExecutors.listeningDecorator(workQueue.createQueue(batchThreads, "Index-Batch"));
}
#method_after
@Provides
@Singleton
@IndexExecutor(BATCH)
ListeningExecutorService getBatchIndexExecutor(@GerritServerConfig Config config, WorkQueue workQueue) {
    if (batchExecutor != null) {
        return batchExecutor;
    }
    int batchThreads = this.threads;
    if (batchThreads <= 0) {
        batchThreads = config.getInt("index", null, "batchThreads", 0);
    }
    if (batchThreads <= 0) {
        batchThreads = Runtime.getRuntime().availableProcessors();
    }
    return MoreExecutors.listeningDecorator(workQueue.createQueue(batchThreads, "Index-Batch"));
}
#end_block

#method_before
@Override
public int run() throws Exception {
    RuntimeShutdown.add(this::stop);
    int actualThreads;
    try {
        mustHaveValidSite();
        dbInjector = createDbInjector(MULTI_USER);
        if (threads != null) {
            actualThreads = threads;
        } else {
            int procs = Runtime.getRuntime().availableProcessors();
            if (procs > ISSUE_8022_THREAD_LIMIT) {
                System.out.println("Not using more than " + ISSUE_8022_THREAD_LIMIT + " threads due to http://crbug.com/gerrit/8022");
                System.out.println("Can be increased by passing --threads, but may cause errors");
                actualThreads = ISSUE_8022_THREAD_LIMIT;
            } else {
                actualThreads = procs;
            }
            actualThreads = ThreadLimiter.limitThreads(dbInjector, actualThreads);
        }
        dbManager = new LifecycleManager();
        dbManager.add(dbInjector);
        dbManager.start();
        sysInjector = createSysInjector(actualThreads);
        sysInjector.injectMembers(this);
        sysManager = new LifecycleManager();
        sysManager.add(sysInjector);
        sysManager.start();
        try (NoteDbMigrator migrator = migratorBuilderProvider.get().setThreads(actualThreads).setProgressOut(System.err).setProjects(projects.stream().map(Project.NameKey::new).collect(toList())).setChanges(changes.stream().map(Change.Id::new).collect(toList())).setTrialMode(trial).setForceRebuild(force).setSequenceGap(sequenceGap).build()) {
            if (!projects.isEmpty() || !changes.isEmpty()) {
                migrator.rebuild();
            } else {
                migrator.migrate();
            }
        }
    } finally {
        stop();
    }
    boolean reindex = firstNonNull(this.reindex, !trial);
    if (!reindex) {
        return 0;
    }
    // Reindex all indices, to save the user from having to run yet another program by hand while
    // their server is offline.
    List<String> reindexArgs = ImmutableList.of("--site-path", getSitePath().toString(), "--threads", Integer.toString(actualThreads), "--index", ChangeSchemaDefinitions.NAME);
    System.out.println("Migration complete, reindexing changes with:");
    System.out.println("  reindex " + reindexArgs.stream().collect(joining(" ")));
    Reindex reindexPgm = new Reindex();
    return reindexPgm.main(reindexArgs.stream().toArray(String[]::new));
}
#method_after
@Override
public int run() throws Exception {
    RuntimeShutdown.add(this::stop);
    try {
        mustHaveValidSite();
        dbInjector = createDbInjector(MULTI_USER);
        dbManager = new LifecycleManager();
        dbManager.add(dbInjector);
        dbManager.start();
        threads = limitThreads();
        sysInjector = createSysInjector();
        sysInjector.injectMembers(this);
        sysManager = new LifecycleManager();
        sysManager.add(sysInjector);
        sysManager.start();
        try (NoteDbMigrator migrator = migratorBuilderProvider.get().setThreads(threads).setProgressOut(System.err).setProjects(projects.stream().map(Project.NameKey::new).collect(toList())).setChanges(changes.stream().map(Change.Id::new).collect(toList())).setTrialMode(trial).setForceRebuild(force).setSequenceGap(sequenceGap).build()) {
            if (!projects.isEmpty() || !changes.isEmpty()) {
                migrator.rebuild();
            } else {
                migrator.migrate();
            }
        }
    } finally {
        stop();
    }
    boolean reindex = firstNonNull(this.reindex, !trial);
    if (!reindex) {
        return 0;
    }
    // Reindex all indices, to save the user from having to run yet another program by hand while
    // their server is offline.
    List<String> reindexArgs = ImmutableList.of("--site-path", getSitePath().toString(), "--threads", Integer.toString(threads), "--index", ChangeSchemaDefinitions.NAME);
    System.out.println("Migration complete, reindexing changes with:");
    System.out.println("  reindex " + reindexArgs.stream().collect(joining(" ")));
    Reindex reindexPgm = new Reindex();
    return reindexPgm.main(reindexArgs.stream().toArray(String[]::new));
}
#end_block

#method_before
private Injector createSysInjector(int actualThreads) {
    return dbInjector.createChildInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(dbInjector.getInstance(BatchProgramModule.class));
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            install(getIndexModule(actualThreads));
            factory(ChangeResource.Factory.class);
        }
    });
}
#method_after
private Injector createSysInjector() {
    return dbInjector.createChildInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(dbInjector.getInstance(BatchProgramModule.class));
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            install(getIndexModule());
            factory(ChangeResource.Factory.class);
        }
    });
}
#end_block

#method_before
private Module getIndexModule(int actualThreads) {
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            return LuceneIndexModule.singleVersionWithExplicitVersions(ImmutableMap.of(), actualThreads);
        case ELASTICSEARCH:
            return ElasticIndexModule.singleVersionWithExplicitVersions(ImmutableMap.of(), actualThreads);
        default:
            throw new IllegalStateException("unsupported index.type");
    }
}
#method_after
private Module getIndexModule() {
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            return LuceneIndexModule.singleVersionWithExplicitVersions(ImmutableMap.of(), threads);
        case ELASTICSEARCH:
            return ElasticIndexModule.singleVersionWithExplicitVersions(ImmutableMap.of(), threads);
        default:
            throw new IllegalStateException("unsupported index.type");
    }
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    gApi.accounts().id(user.id.get()).setStatus("new status");
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNull();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNotNull();
}
#method_after
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String id = r.getChangeId();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNull();
    assertThat(c.submitter).isNull();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNotNull();
    assertThat(c.submitter).isNotNull();
    assertThat(c.submitter._accountId).isEqualTo(atrScope.get().getUser().getAccountId().get());
}
#end_block

#method_before
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    ProjectState projectState = projectCache.checkedGet(revision.getProject());
    LabelTypes labelTypes = projectState.getLabelTypes(revision.getNotes(), revision.getUser());
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, labelTypes, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, labelTypes, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(projectState, revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    CurrentUser caller = rev.getUser();
    PermissionBackend.ForChange perm = rev.permissions().database(db);
    LabelTypes labelTypes = rev.getControl().getLabelTypes();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = labelTypes.byLabel(ent.getKey());
        if (type == null) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        }
        if (!caller.isInternalUser()) {
            try {
                perm.check(new LabelPermission.WithValue(ON_BEHALF_OF, type, ent.getValue()));
            } catch (AuthException e) {
                throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", type.getName(), in.onBehalfOf));
            }
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    IdentifiedUser reviewer = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(reviewer).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", reviewer.getAccountId()));
    }
    ChangeControl ctl = rev.getControl().forUser(reviewer);
    return new RevisionResource(changes.parse(ctl), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, LabelTypes labelTypes, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    CurrentUser caller = rev.getUser();
    PermissionBackend.ForChange perm = rev.permissions().database(db);
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = labelTypes.byLabel(ent.getKey());
        if (type == null) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        }
        if (!caller.isInternalUser()) {
            try {
                perm.check(new LabelPermission.WithValue(ON_BEHALF_OF, type, ent.getValue()));
            } catch (AuthException e) {
                throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", type.getName(), in.onBehalfOf));
            }
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    IdentifiedUser reviewer = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(reviewer).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", reviewer.getAccountId()));
    }
    ChangeControl ctl = rev.getControl().forUser(reviewer);
    return new RevisionResource(changes.parse(ctl), rev.getPatchSet());
}
#end_block

#method_before
private void checkLabels(RevisionResource rsrc, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException {
    LabelTypes types = rsrc.getControl().getLabelTypes();
    PermissionBackend.ForChange perm = rsrc.permissions();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = types.byLabel(ent.getKey());
        if (lt == null) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
        }
        short val = ent.getValue();
        try {
            perm.check(new LabelPermission.WithValue(lt, val));
        } catch (AuthException e) {
            throw new AuthException(String.format("Applying label \"%s\": %d is restricted", lt.getName(), val));
        }
    }
}
#method_after
private void checkLabels(RevisionResource rsrc, LabelTypes labelTypes, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException {
    PermissionBackend.ForChange perm = rsrc.permissions();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = labelTypes.byLabel(ent.getKey());
        if (lt == null) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
        }
        short val = ent.getValue();
        try {
            perm.check(new LabelPermission.WithValue(lt, val));
        } catch (AuthException e) {
            throw new AuthException(String.format("Applying label \"%s\": %d is restricted", lt.getName(), val));
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, UnprocessableEntityException, IOException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, UnprocessableEntityException, IOException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(projectState, ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException, IOException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ProjectState projectState, ChangeContext ctx) throws OrmException, ResourceConflictException, IOException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(projectState, ctx, del);
    LabelTypes labelTypes = projectState.getLabelTypes(ctx.getNotes(), ctx.getUser());
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(projectState, ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            LabelId labelId = ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId();
            PatchSetApproval c = ApprovalsUtil.newApproval(psId, user, labelId, 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ProjectState projectState, ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            LabelId labelId = projectState.getLabelTypes(ctx.getNotes(), ctx.getUser()).getLabelTypes().get(0).getLabelId();
            PatchSetApproval c = ApprovalsUtil.newApproval(psId, user, labelId, 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, PatchSetApproval> current = new HashMap<>();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getControl(), psId, user.getAccountId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (a.isLegacySubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#method_after
private Map<String, PatchSetApproval> scanLabels(ProjectState projectState, ChangeContext ctx, List<PatchSetApproval> del) throws OrmException, IOException {
    LabelTypes labelTypes = projectState.getLabelTypes(ctx.getNotes(), ctx.getUser());
    Map<String, PatchSetApproval> current = new HashMap<>();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getControl(), psId, user.getAccountId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (a.isLegacySubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    } else if (in.ready) {
        buf.append("\n\n" + START_REVIEW_MESSAGE);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
@Override
protected void parseCommandLine() throws UnloggedFailure {
    optionList = new ArrayList<>();
    customLabels = new HashMap<>();
    ProjectControl allProjectsControl;
    try {
        allProjectsControl = projectControlFactory.controlFor(allProjects);
    } catch (NoSuchProjectException e) {
        throw die("missing " + allProjects.get());
    }
    for (LabelType type : allProjectsControl.getLabelTypes().getLabelTypes()) {
        StringBuilder usage = new StringBuilder("score for ").append(type.getName()).append("\n");
        for (LabelValue v : type.getValues()) {
            usage.append(v.format()).append("\n");
        }
        final String name = "--" + type.getName().toLowerCase();
        optionList.add(new ApproveOption(name, usage.toString(), type));
    }
    super.parseCommandLine();
}
#method_after
@Override
protected void parseCommandLine() throws UnloggedFailure {
    optionList = new ArrayList<>();
    customLabels = new HashMap<>();
    ProjectState allProjectsState;
    try {
        allProjectsState = projectCache.checkedGet(allProjects);
    } catch (IOException e) {
        throw die("missing " + allProjects.get());
    }
    for (LabelType type : allProjectsState.getLabelTypes().getLabelTypes()) {
        StringBuilder usage = new StringBuilder("score for ").append(type.getName()).append("\n");
        for (LabelValue v : type.getValues()) {
            usage.append(v.format()).append("\n");
        }
        final String name = "--" + type.getName().toLowerCase();
        optionList.add(new ApproveOption(name, usage.toString(), type));
    }
    super.parseCommandLine();
}
#end_block

#method_before
private Set<Id> findAccountsInGroup(String groupNameOrUUID) {
    AccountGroup group = Optional.ofNullable(groupCache.get(new AccountGroup.NameKey(groupNameOrUUID))).orElse(groupCache.get(new AccountGroup.UUID(groupNameOrUUID)));
    if (group == null) {
        log.warn("Group {} was not found", groupNameOrUUID);
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(adminUser.getAccountId())) {
        return groupMembers.create(adminUser).listAccounts(group.getGroupUUID(), null).stream().map(Account::getId).collect(Collectors.toSet());
    } catch (NoSuchGroupException | NoSuchProjectException | OrmException | IOException e) {
        log.error("Unable to list accounts in group " + group, e);
        return Collections.emptySet();
    }
}
#method_after
private Set<Id> findAccountsInGroup(String groupNameOrUUID) {
    Optional<InternalGroup> group = groupCache.get(new AccountGroup.NameKey(groupNameOrUUID)).map(Optional::of).orElse(groupCache.get(new AccountGroup.UUID(groupNameOrUUID)));
    if (!group.isPresent()) {
        log.warn("Group {} was not found", groupNameOrUUID);
        return Collections.emptySet();
    }
    try {
        return groupMembers.listAccounts(group.get().getGroupUUID(), null).stream().map(Account::getId).collect(Collectors.toSet());
    } catch (NoSuchProjectException | IOException e) {
        log.error("Unable to list accounts in group " + group, e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
private Set<Account.Id> findUserOrEmail(String nameOrEmail) {
    try {
        Set<Id> accountIds = resolver.findAll(db, nameOrEmail);
        if (accountIds.isEmpty()) {
            log.warn("User '{}' does not resolve to any account.", nameOrEmail);
            return accountIds;
        }
        Set<Id> fulllyMatchedAccountIds = accountIds.stream().filter(id -> isFullMatch(id, nameOrEmail)).collect(Collectors.toSet());
        if (fulllyMatchedAccountIds.isEmpty()) {
            log.warn("User '{}' resolves to {} accounts {}, but does not correspond to any them", nameOrEmail, accountIds.size(), accountIds);
            return fulllyMatchedAccountIds;
        }
        return accountIds;
    } catch (OrmException e) {
        log.error("Error trying to resolve user " + nameOrEmail, e);
        return Collections.emptySet();
    }
}
#method_after
private Set<Account.Id> findUserOrEmail(String nameOrEmail) {
    try {
        Set<Id> accountIds = resolver.findAll(nameOrEmail);
        if (accountIds.isEmpty()) {
            log.warn("User '{}' does not resolve to any account.", nameOrEmail);
            return accountIds;
        }
        Set<Id> fulllyMatchedAccountIds = accountIds.stream().filter(id -> isFullMatch(id, nameOrEmail)).collect(Collectors.toSet());
        if (fulllyMatchedAccountIds.isEmpty()) {
            log.warn("User '{}' resolves to {} accounts {}, but does not correspond to any them", nameOrEmail, accountIds.size(), accountIds);
            return fulllyMatchedAccountIds;
        }
        return accountIds;
    } catch (OrmException | IOException | ConfigInvalidException e) {
        log.error("Error trying to resolve user " + nameOrEmail, e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
private void init() {
    List<String> varParts = Lists.newArrayList(Splitter.on('.').split(sectionAndKey));
    if (varParts.size() != 2) {
        throw new IllegalArgumentException("Invalid name '" + sectionAndKey + "': expected section.key format");
    }
    section = varParts.get(0);
    key = varParts.get(1);
}
#method_after
private void init() {
    List<String> varParts = Splitter.on('.').splitToList(sectionAndKey);
    if (varParts.size() != 2) {
        throw new IllegalArgumentException("Invalid name '" + sectionAndKey + "': expected section.key format");
    }
    section = varParts.get(0);
    key = varParts.get(1);
}
#end_block

#method_before
private String getPublicKeyPart(int index, String defaultValue) {
    String s = getSshPublicKey();
    if (s != null && s.length() > 0) {
        List<String> parts = Lists.newArrayList(Splitter.on(' ').split(s));
        if (parts.size() > index) {
            return parts.get(index);
        }
    }
    return defaultValue;
}
#method_after
private String getPublicKeyPart(int index, String defaultValue) {
    String s = getSshPublicKey();
    if (s != null && s.length() > 0) {
        List<String> parts = Splitter.on(' ').splitToList(s);
        if (parts.size() > index) {
            return parts.get(index);
        }
    }
    return defaultValue;
}
#end_block

#method_before
public static String trimQuotation(String comment) {
    StringJoiner j = new StringJoiner("\n");
    List<String> lines = Lists.newArrayList(Splitter.on('\n').split(comment));
    for (int i = 0; i < lines.size() - 2; i++) {
        j.add(lines.get(i));
    }
    // Check if the last line contains the full quotation pattern (date + email)
    String lastLine = lines.get(lines.size() - 1);
    if (containsQuotationPattern(lastLine)) {
        if (lines.size() > 1) {
            j.add(lines.get(lines.size() - 2));
        }
        return j.toString().trim();
    }
    // necessary, as the quotation line can be split across the last two lines if it gets too long.
    if (lines.size() > 1) {
        String lastLines = lines.get(lines.size() - 2) + lastLine;
        if (containsQuotationPattern(lastLines)) {
            return j.toString().trim();
        }
    }
    // Add the last two lines
    if (lines.size() > 1) {
        j.add(lines.get(lines.size() - 2));
    }
    j.add(lines.get(lines.size() - 1));
    return j.toString().trim();
}
#method_after
public static String trimQuotation(String comment) {
    StringJoiner j = new StringJoiner("\n");
    List<String> lines = Splitter.on('\n').splitToList(comment);
    for (int i = 0; i < lines.size() - 2; i++) {
        j.add(lines.get(i));
    }
    // Check if the last line contains the full quotation pattern (date + email)
    String lastLine = lines.get(lines.size() - 1);
    if (containsQuotationPattern(lastLine)) {
        if (lines.size() > 1) {
            j.add(lines.get(lines.size() - 2));
        }
        return j.toString().trim();
    }
    // necessary, as the quotation line can be split across the last two lines if it gets too long.
    if (lines.size() > 1) {
        String lastLines = lines.get(lines.size() - 2) + lastLine;
        if (containsQuotationPattern(lastLines)) {
            return j.toString().trim();
        }
    }
    // Add the last two lines
    if (lines.size() > 1) {
        j.add(lines.get(lines.size() - 2));
    }
    j.add(lines.get(lines.size() - 1));
    return j.toString().trim();
}
#end_block

#method_before
private void configureAliases() {
    CommandName gerrit = Commands.named("gerrit");
    for (Map.Entry<String, String> e : aliases.entrySet()) {
        String name = e.getKey();
        List<String> dest = Lists.newArrayList(Splitter.on(ALIAS_SPLIT_PATTEN).split(e.getValue()));
        CommandName cmd = Commands.named(dest.get(0));
        for (int i = 1; i < dest.size(); i++) {
            cmd = Commands.named(cmd, dest.get(i));
        }
        bind(Commands.key(gerrit, name)).toProvider(new AliasCommandProvider(cmd));
    }
}
#method_after
private void configureAliases() {
    CommandName gerrit = Commands.named("gerrit");
    for (Map.Entry<String, String> e : aliases.entrySet()) {
        String name = e.getKey();
        List<String> dest = Splitter.on(CharMatcher.whitespace()).splitToList(e.getValue());
        CommandName cmd = Commands.named(dest.get(0));
        for (int i = 1; i < dest.size(); i++) {
            cmd = Commands.named(cmd, dest.get(i));
        }
        bind(Commands.key(gerrit, name)).toProvider(new AliasCommandProvider(cmd));
    }
}
#end_block

#method_before
private boolean convertUrl(Section database, String url) throws UnsupportedEncodingException {
    String username = null;
    String password = null;
    if (url.contains("?")) {
        final int q = url.indexOf('?');
        for (String pair : Splitter.on("&").split(url.substring(q + 1))) {
            final int eq = pair.indexOf('=');
            if (0 < eq) {
                return false;
            }
            String n = URLDecoder.decode(pair.substring(0, eq), UTF_8.name());
            String v = URLDecoder.decode(pair.substring(eq + 1), UTF_8.name());
            if ("user".equals(n) || "username".equals(n)) {
                username = v;
            } else if ("password".equals(n)) {
                password = v;
            } else {
                // 
                return false;
            }
        }
        url = url.substring(0, q);
    }
    if (url.startsWith("jdbc:h2:file:")) {
        url = url.substring("jdbc:h2:file:".length());
        database.set("type", "h2");
        database.set("database", url);
        return true;
    }
    if (url.startsWith("jdbc:postgresql://")) {
        url = url.substring("jdbc:postgresql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "postgresql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:postgresql:")) {
        url = url.substring("jdbc:postgresql:".length());
        database.set("type", "postgresql");
        database.set("hostname", "localhost");
        database.set("database", url);
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:mysql://")) {
        url = url.substring("jdbc:mysql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "mysql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    return false;
}
#method_after
private boolean convertUrl(Section database, String url) throws UnsupportedEncodingException {
    String username = null;
    String password = null;
    if (url.contains("?")) {
        final int q = url.indexOf('?');
        for (String pair : Splitter.on('&').split(url.substring(q + 1))) {
            final int eq = pair.indexOf('=');
            if (0 < eq) {
                return false;
            }
            String n = URLDecoder.decode(pair.substring(0, eq), UTF_8.name());
            String v = URLDecoder.decode(pair.substring(eq + 1), UTF_8.name());
            if ("user".equals(n) || "username".equals(n)) {
                username = v;
            } else if ("password".equals(n)) {
                password = v;
            } else {
                // 
                return false;
            }
        }
        url = url.substring(0, q);
    }
    if (url.startsWith("jdbc:h2:file:")) {
        url = url.substring("jdbc:h2:file:".length());
        database.set("type", "h2");
        database.set("database", url);
        return true;
    }
    if (url.startsWith("jdbc:postgresql://")) {
        url = url.substring("jdbc:postgresql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "postgresql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:postgresql:")) {
        url = url.substring("jdbc:postgresql:".length());
        database.set("type", "postgresql");
        database.set("hostname", "localhost");
        database.set("database", url);
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:mysql://")) {
        url = url.substring("jdbc:mysql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "mysql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    return false;
}
#end_block

#method_before
@VisibleForTesting
Map<String, Map<String, ConfigValue>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, ConfigValue>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        List<String> s = Lists.newArrayList(Splitter.on('=').split(pluginConfigValue));
        List<String> s2 = Lists.newArrayList(Splitter.on('.').split(s.get(0)));
        if (s.size() != 2 || s2.size() != 2) {
            throw die("Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'" + " or '<plugin-name>.<parameter-name>=<value1,value2,...>'");
        }
        ConfigValue value = new ConfigValue();
        String v = s.get(1);
        if (v.contains(",")) {
            value.values = Lists.newArrayList(Splitter.on(",").split(v));
        } else {
            value.value = v;
        }
        String pluginName = s2.get(0);
        String paramName = s2.get(1);
        Map<String, ConfigValue> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#method_after
@VisibleForTesting
Map<String, Map<String, ConfigValue>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, ConfigValue>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        List<String> s = Splitter.on('=').splitToList(pluginConfigValue);
        List<String> s2 = Splitter.on('.').splitToList(s.get(0));
        if (s.size() != 2 || s2.size() != 2) {
            throw die("Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'" + " or '<plugin-name>.<parameter-name>=<value1,value2,...>'");
        }
        ConfigValue value = new ConfigValue();
        String v = s.get(1);
        if (v.contains(",")) {
            value.values = Splitter.on(",").splitToList(v);
        } else {
            value.value = v;
        }
        String pluginName = s2.get(0);
        String paramName = s2.get(1);
        Map<String, ConfigValue> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#end_block

#method_before
@Override
public final int parseArguments(Parameters params) throws CmdLineException {
    final String token = params.getParameter(0);
    final List<String> tokens = Lists.newArrayList(Splitter.on(',').split(token));
    if (tokens.size() != 3) {
        throw new CmdLineException(owner, "change should be specified as <project>,<branch>,<change-id>");
    }
    try {
        final Change.Key key = Change.Key.parse(tokens.get(2));
        final Project.NameKey project = new Project.NameKey(tokens.get(0));
        final Branch.NameKey branch = new Branch.NameKey(project, tokens.get(1));
        for (ChangeData cd : queryProvider.get().byBranchKey(branch, key)) {
            setter.addValue(cd.getId());
            return 1;
        }
    } catch (IllegalArgumentException e) {
        throw new CmdLineException(owner, "Change-Id is not valid");
    } catch (OrmException e) {
        throw new CmdLineException(owner, "Database error: " + e.getMessage());
    }
    throw new CmdLineException(owner, "\"" + token + "\": change not found");
}
#method_after
@Override
public final int parseArguments(Parameters params) throws CmdLineException {
    final String token = params.getParameter(0);
    final List<String> tokens = Splitter.on(',').splitToList(token);
    if (tokens.size() != 3) {
        throw new CmdLineException(owner, "change should be specified as <project>,<branch>,<change-id>");
    }
    try {
        final Change.Key key = Change.Key.parse(tokens.get(2));
        final Project.NameKey project = new Project.NameKey(tokens.get(0));
        final Branch.NameKey branch = new Branch.NameKey(project, tokens.get(1));
        for (ChangeData cd : queryProvider.get().byBranchKey(branch, key)) {
            setter.addValue(cd.getId());
            return 1;
        }
    } catch (IllegalArgumentException e) {
        throw new CmdLineException(owner, "Change-Id is not valid");
    } catch (OrmException e) {
        throw new CmdLineException(owner, "Database error: " + e.getMessage());
    }
    throw new CmdLineException(owner, "\"" + token + "\": change not found");
}
#end_block

#method_before
private static Map<String, String> getParameters(HttpServletRequest req) {
    final Map<String, String> params = new HashMap<>();
    for (String pair : Splitter.on(QUERY_SPLIT_PATTERN).split(req.getQueryString())) {
        final int eq = pair.indexOf('=');
        if (0 < eq) {
            String name = pair.substring(0, eq);
            String value = pair.substring(eq + 1);
            name = Url.decode(name);
            value = Url.decode(value);
            params.put(name, value);
        }
    }
    return params;
}
#method_after
private static Map<String, String> getParameters(HttpServletRequest req) {
    final Map<String, String> params = new HashMap<>();
    for (String pair : Splitter.on(CharMatcher.anyOf("&;")).split(req.getQueryString())) {
        final int eq = pair.indexOf('=');
        if (0 < eq) {
            String name = pair.substring(0, eq);
            String value = pair.substring(eq + 1);
            name = Url.decode(name);
            value = Url.decode(value);
            params.put(name, value);
        }
    }
    return params;
}
#end_block

#method_before
private void readCgiHeaders(HttpServletResponse res, InputStream in) throws IOException {
    String line;
    while (!(line = readLine(in)).isEmpty()) {
        if (line.startsWith("HTTP")) {
            // 
            throw new IOException("NPH CGI not supported: " + line);
        }
        final int sep = line.indexOf(':');
        if (sep < 0) {
            throw new IOException("CGI returned invalid header: " + line);
        }
        final String key = line.substring(0, sep).trim();
        final String value = line.substring(sep + 1).trim();
        if ("Location".equalsIgnoreCase(key)) {
            res.sendRedirect(value);
        } else if ("Status".equalsIgnoreCase(key)) {
            final List<String> token = Lists.newArrayList(Splitter.on(' ').split(value));
            final int status = Integer.parseInt(token.get(0));
            res.setStatus(status);
        } else {
            res.addHeader(key, value);
        }
    }
}
#method_after
private void readCgiHeaders(HttpServletResponse res, InputStream in) throws IOException {
    String line;
    while (!(line = readLine(in)).isEmpty()) {
        if (line.startsWith("HTTP")) {
            // 
            throw new IOException("NPH CGI not supported: " + line);
        }
        final int sep = line.indexOf(':');
        if (sep < 0) {
            throw new IOException("CGI returned invalid header: " + line);
        }
        final String key = line.substring(0, sep).trim();
        final String value = line.substring(sep + 1).trim();
        if ("Location".equalsIgnoreCase(key)) {
            res.sendRedirect(value);
        } else if ("Status".equalsIgnoreCase(key)) {
            final List<String> token = Splitter.on(' ').splitToList(value);
            final int status = Integer.parseInt(token.get(0));
            res.setStatus(status);
        } else {
            res.addHeader(key, value);
        }
    }
}
#end_block

#method_before
public static HashedPassword decode(String encoded) throws DecoderException {
    if (!encoded.startsWith(ALGORITHM_PREFIX)) {
        throw new DecoderException("unrecognized algorithm");
    }
    List<String> fields = Lists.newArrayList(Splitter.on(':').split(encoded));
    if (fields.size() != 4) {
        throw new DecoderException("want 4 fields");
    }
    Integer cost = Ints.tryParse(fields.get(1));
    if (cost == null) {
        throw new DecoderException("cost parse failed");
    }
    if (!(cost >= 4 && cost < 32)) {
        throw new DecoderException("cost should be 4..31 inclusive, got " + cost);
    }
    byte[] salt = codec.decode(fields.get(2));
    if (salt.length != 16) {
        throw new DecoderException("salt should be 16 bytes, got " + salt.length);
    }
    return new HashedPassword(codec.decode(fields.get(3)), salt, cost);
}
#method_after
public static HashedPassword decode(String encoded) throws DecoderException {
    if (!encoded.startsWith(ALGORITHM_PREFIX)) {
        throw new DecoderException("unrecognized algorithm");
    }
    List<String> fields = Splitter.on(':').splitToList(encoded);
    if (fields.size() != 4) {
        throw new DecoderException("want 4 fields");
    }
    Integer cost = Ints.tryParse(fields.get(1));
    if (cost == null) {
        throw new DecoderException("cost parse failed");
    }
    if (!(cost >= 4 && cost < 32)) {
        throw new DecoderException("cost should be 4..31 inclusive, got " + cost);
    }
    byte[] salt = codec.decode(fields.get(2));
    if (salt.length != 16) {
        throw new DecoderException("salt should be 16 bytes, got " + salt.length);
    }
    return new HashedPassword(codec.decode(fields.get(3)), salt, cost);
}
#end_block

#method_before
private Map<String, Object> toFooterSoyData(Paginator paginator, @Nullable String revision, FooterBehavior behavior) {
    switch(behavior) {
        case NEXT:
            ObjectId next = paginator.getNextStart();
            if (next == null) {
                return ImmutableMap.of();
            }
            return ImmutableMap.of("nextUrl", copyAndCanonicalizeView(revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl(), "nextText", "Next");
        case LOG_HEAD:
            return ImmutableMap.of("nextUrl", GitilesView.log().copyFrom(view).toUrl(), "nextText", "Log");
        default:
            throw new IllegalStateException("unknown footer behavior: " + behavior);
    }
}
#method_after
private Map<String, Object> toFooterSoyData(Paginator paginator, @Nullable String revision, FooterBehavior behavior) {
    switch(behavior) {
        case NEXT:
            ObjectId next = paginator.getNextStart();
            if (next == null) {
                return ImmutableMap.of();
            }
            return ImmutableMap.of("nextUrl", copyAndCanonicalizeView(revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl(), "nextText", "Next");
        case LOG_HEAD:
            return ImmutableMap.of("nextUrl", GitilesView.log().copyFrom(view).toUrl(), "nextText", "More");
        default:
            throw new IllegalStateException("unknown footer behavior: " + behavior);
    }
}
#end_block

