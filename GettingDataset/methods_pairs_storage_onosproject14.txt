498
#method_before
private void processL2MulticastNextObjective(NextObjective nextObj) {
    Integer vendorData = readVendorMetadataFromSelector(nextObj.meta());
    if (vendorData == null) {
        log.warn("Vendor data required by L2 multicast next objective is missing. Aborting.");
        fail(nextObj, ObjectiveError.BADPARAMS);
        return;
    }
    // Group info should contain only single homed hosts for a given vlanId
    VlanId assignedVlan = VlanId.vlanId(vendorData.shortValue());
    List<GroupInfo> groupInfos = prepareL2InterfaceGroup(nextObj, assignedVlan);
    createL2MulticastGroup(nextObj, assignedVlan, groupInfos);
}
#method_after
private void processL2MulticastNextObjective(NextObjective nextObj) {
    VlanId assignedVlan = readVlanFromSelector(nextObj.meta());
    if (assignedVlan == null) {
        log.warn("VLAN ID required by L2 multicast next objective is missing. Aborting group creation.");
        fail(nextObj, ObjectiveError.BADPARAMS);
        return;
    }
    // Group info should contain only single homed hosts for a given vlanId
    List<GroupInfo> groupInfos = prepareL2InterfaceGroup(nextObj, assignedVlan);
    createL2MulticastGroup(nextObj, assignedVlan, groupInfos);
}
#end_block

#method_before
private void processBroadcastNextObjective(NextObjective nextObj) {
    // Handling OFDPA special cases
    Integer vendorMetadata = readVendorMetadataFromSelector(nextObj.meta());
    if (vendorMetadata != null) {
        processL2MulticastNextObjective(nextObj);
        return;
    }
    VlanId assignedVlan = readVlanFromSelector(nextObj.meta());
    if (assignedVlan == null) {
        log.warn("VLAN ID required by broadcast next obj is missing. Abort.");
        fail(nextObj, ObjectiveError.BADPARAMS);
        return;
    }
    List<GroupInfo> groupInfos = prepareL2InterfaceGroup(nextObj, assignedVlan);
    IpPrefix ipDst = readIpDstFromSelector(nextObj.meta());
    if (ipDst != null) {
        if (ipDst.isMulticast()) {
            createL3MulticastGroup(nextObj, assignedVlan, groupInfos);
        } else {
            log.warn("Broadcast NextObj with non-multicast IP address {}", nextObj);
            fail(nextObj, ObjectiveError.BADPARAMS);
        }
    } else {
        createL2FloodGroup(nextObj, assignedVlan, groupInfos);
    }
}
#method_after
private void processBroadcastNextObjective(NextObjective nextObj) {
    VlanId assignedVlan = readVlanFromSelector(nextObj.meta());
    if (assignedVlan == null) {
        log.warn("VLAN ID required by broadcast next obj is missing. Abort.");
        fail(nextObj, ObjectiveError.BADPARAMS);
        return;
    }
    // Handling L2 multicast cases.
    MacAddress dstMac = readEthDstFromSelector(nextObj.meta());
    if (dstMac != null && dstMac.isMulticast()) {
        processL2MulticastNextObjective(nextObj);
    }
    List<GroupInfo> groupInfos = prepareL2InterfaceGroup(nextObj, assignedVlan);
    IpPrefix ipDst = readIpDstFromSelector(nextObj.meta());
    if (ipDst != null) {
        if (ipDst.isMulticast()) {
            createL3MulticastGroup(nextObj, assignedVlan, groupInfos);
        } else {
            log.warn("Broadcast NextObj with non-multicast IP address {}", nextObj);
            fail(nextObj, ObjectiveError.BADPARAMS);
        }
    } else {
        createL2FloodGroup(nextObj, assignedVlan, groupInfos);
    }
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    hostEventExecutor.execute(() -> {
        switch(event.type()) {
            case HOST_MOVED:
                log.trace("Processing host event {}", event);
                Host host = event.subject();
                Set<HostLocation> prevLocations = event.prevSubject().locations();
                Set<HostLocation> newLocations = host.locations();
                // Dual-home host port failure
                // For each old location, in failed and paired devices update L2 vlan groups
                Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
                    Optional<DeviceId> pairDeviceId = srService.getPairDeviceId(prevLocation.deviceId());
                    Optional<PortNumber> pairLocalPort = srService.getPairLocalPort(prevLocation.deviceId());
                    if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && newLocations.stream().anyMatch(location -> location.deviceId().equals(pairDeviceId.get())) && hasXconnect(new ConnectPoint(prevLocation.deviceId(), prevLocation.port()))) {
                        List<VlanId> xconnectVlans = getXconnectVlans(prevLocation.deviceId(), prevLocation.port());
                        xconnectVlans.stream().forEach(xconnectVlan -> {
                            // Add single-home host into L2 multicast group at paired device side.
                            // Also append ACL rule to forward traffic from paired port to L2 multicast group.
                            newLocations.stream().filter(location -> location.deviceId().equals(pairDeviceId.get())).forEach(location -> populateL2Multicast(location.deviceId(), srService.getPairLocalPort(location.deviceId()).get(), xconnectVlan, Collections.singletonList(location.port())));
                            // Ensure pair-port attached to xconnect vlan flooding group at dual home failed device.
                            updateL2Flooding(prevLocation.deviceId(), pairLocalPort.get(), xconnectVlan, true);
                        });
                    }
                });
                // Dual-home host port restoration
                // For each new location, reverse xconnect loop prevention groups.
                Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
                    final Optional<DeviceId> pairDeviceId = srService.getPairDeviceId(newLocation.deviceId());
                    Optional<PortNumber> pairLocalPort = srService.getPairLocalPort(newLocation.deviceId());
                    if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && hasXconnect((new ConnectPoint(newLocation.deviceId(), newLocation.port())))) {
                        List<VlanId> xconnectVlans = getXconnectVlans(newLocation.deviceId(), newLocation.port());
                        xconnectVlans.stream().forEach(xconnectVlan -> {
                            // Remove recovered dual homed port from vlan L2 multicast group
                            prevLocations.stream().filter(prevLocation -> prevLocation.deviceId().equals(pairDeviceId.get())).forEach(prevLocation -> revokeL2Multicast(prevLocation.deviceId(), srService.getPairLocalPort(prevLocation.deviceId()).get(), xconnectVlan, Collections.singletonList(newLocation.port())));
                            // Remove pair-port from vlan's flooding group at dual home restored device, if needed.
                            if (!hasAccessPortInMulticastGroup(newLocation.deviceId(), xconnectVlan, pairLocalPort.get())) {
                                updateL2Flooding(newLocation.deviceId(), pairLocalPort.get(), xconnectVlan, false);
                                // Clean L2 multicast group at pair-device; also update store.
                                cleanupL2MulticastRule(pairDeviceId.get(), srService.getPairLocalPort(pairDeviceId.get()).get(), xconnectVlan, false);
                            }
                        });
                    }
                });
                break;
            default:
                log.warn("Unsupported host event type: {} received. Ignoring.", event.type());
                break;
        }
    });
}
#method_after
@Override
public void event(HostEvent event) {
    hostEventExecutor.execute(() -> {
        switch(event.type()) {
            case HOST_MOVED:
                log.trace("Processing host event {}", event);
                Host host = event.subject();
                Set<HostLocation> prevLocations = event.prevSubject().locations();
                Set<HostLocation> newLocations = host.locations();
                // Dual-home host port failure
                // For each old location, in failed and paired devices update L2 vlan groups
                Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
                    Optional<DeviceId> pairDeviceId = srService.getPairDeviceId(prevLocation.deviceId());
                    Optional<PortNumber> pairLocalPort = srService.getPairLocalPort(prevLocation.deviceId());
                    if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && newLocations.stream().anyMatch(location -> location.deviceId().equals(pairDeviceId.get())) && hasXconnect(new ConnectPoint(prevLocation.deviceId(), prevLocation.port()))) {
                        List<VlanId> xconnectVlans = getXconnectVlans(prevLocation.deviceId(), prevLocation.port());
                        xconnectVlans.forEach(xconnectVlan -> {
                            // Add single-home host into L2 multicast group at paired device side.
                            // Also append ACL rule to forward traffic from paired port to L2 multicast group.
                            newLocations.stream().filter(location -> location.deviceId().equals(pairDeviceId.get())).forEach(location -> populateL2Multicast(location.deviceId(), srService.getPairLocalPort(location.deviceId()).get(), xconnectVlan, Collections.singletonList(location.port())));
                            // Ensure pair-port attached to xconnect vlan flooding group at dual home failed device.
                            updateL2Flooding(prevLocation.deviceId(), pairLocalPort.get(), xconnectVlan, true);
                        });
                    }
                });
                // Dual-home host port restoration
                // For each new location, reverse xconnect loop prevention groups.
                Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
                    final Optional<DeviceId> pairDeviceId = srService.getPairDeviceId(newLocation.deviceId());
                    Optional<PortNumber> pairLocalPort = srService.getPairLocalPort(newLocation.deviceId());
                    if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && hasXconnect((new ConnectPoint(newLocation.deviceId(), newLocation.port())))) {
                        List<VlanId> xconnectVlans = getXconnectVlans(newLocation.deviceId(), newLocation.port());
                        xconnectVlans.forEach(xconnectVlan -> {
                            // Remove recovered dual homed port from vlan L2 multicast group
                            prevLocations.stream().filter(prevLocation -> prevLocation.deviceId().equals(pairDeviceId.get())).forEach(prevLocation -> revokeL2Multicast(prevLocation.deviceId(), srService.getPairLocalPort(prevLocation.deviceId()).get(), xconnectVlan, Collections.singletonList(newLocation.port())));
                            // Remove pair-port from vlan's flooding group at dual home restored device,if needed.
                            if (!hasAccessPortInMulticastGroup(newLocation.deviceId(), xconnectVlan, pairLocalPort.get())) {
                                updateL2Flooding(newLocation.deviceId(), pairLocalPort.get(), xconnectVlan, false);
                                // Clean L2 multicast group at pair-device; also update store.
                                cleanupL2MulticastRule(pairDeviceId.get(), srService.getPairLocalPort(pairDeviceId.get()).get(), xconnectVlan, false);
                            }
                        });
                    }
                });
                break;
            default:
                log.warn("Unsupported host event type: {} received. Ignoring.", event.type());
                break;
        }
    });
}
#end_block

#method_before
void init(DeviceId deviceId) {
    getXconnects().stream().filter(desc -> desc.key().deviceId().equals(deviceId)).forEach(desc -> populateXConnect(desc.key(), desc.ports()));
}
#method_after
private void init(DeviceId deviceId) {
    getXconnects().stream().filter(desc -> desc.key().deviceId().equals(deviceId)).forEach(desc -> populateXConnect(desc.key(), desc.ports()));
}
#end_block

#method_before
private void populateXConnect(XconnectKey key, Set<PortNumber> ports) {
    if (!mastershipService.isLocalMaster(key.deviceId())) {
        log.info("Abort populating XConnect {}: {}", key, ERROR_NOT_MASTER);
        return;
    }
    ports = addPairPort(key.deviceId(), ports);
    populateFilter(key, ports);
    populateFwd(key, populateNext(key, ports));
    populateAcl(key);
}
#method_after
private void populateXConnect(XconnectKey key, Set<PortNumber> ports) {
    if (!mastershipService.isLocalMaster(key.deviceId())) {
        log.info("Abort populating XConnect {}: {}", key, ERROR_NOT_MASTER);
        return;
    }
    populateFilter(key, ports);
    populateFwd(key, populateNext(key, ports));
    populateAcl(key);
}
#end_block

#method_before
private void revokeXConnect(XconnectKey key, Set<PortNumber> ports) {
    if (!mastershipService.isLocalMaster(key.deviceId())) {
        log.info("Abort populating XConnect {}: {}", key, ERROR_NOT_MASTER);
        return;
    }
    ports = addPairPort(key.deviceId(), ports);
    revokeFilter(key, ports);
    if (xconnectNextObjStore.containsKey(key)) {
        int nextId = xconnectNextObjStore.get(key).value();
        revokeFwd(key, nextId, null);
        revokeNext(key, ports, nextId, null);
    } else {
        log.warn("NextObj for {} does not exist in the store.", key);
    }
    revokeAcl(key);
}
#method_after
private void revokeXConnect(XconnectKey key, Set<PortNumber> ports) {
    if (!mastershipService.isLocalMaster(key.deviceId())) {
        log.info("Abort populating XConnect {}: {}", key, ERROR_NOT_MASTER);
        return;
    }
    revokeFilter(key, ports);
    if (xconnectNextObjStore.containsKey(key)) {
        int nextId = xconnectNextObjStore.get(key).value();
        revokeFwd(key, nextId, null);
        revokeNext(key, ports, nextId, null);
    } else {
        log.warn("NextObj for {} does not exist in the store.", key);
    }
    revokeAcl(key);
}
#end_block

#method_before
void updateL2Flooding(DeviceId deviceId, final PortNumber port, VlanId vlanId, boolean install) {
    // Ensure mastership on device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    // Locate L2 flooding group details for given xconnect vlan
    int nextId = getNextId(deviceId, vlanId);
    if (nextId == -1) {
        log.debug("XConnect vlan {} broadcast group for device {} doesn't exists. " + "Aborting pair group linking.", vlanId, deviceId);
        return;
    }
    // Add pairing-port group to flooding group
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    // treatment.popVlan();
    treatment.setOutput(port);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Pair port added/removed to vlan {} next objective {} on {}", vlanId, nextId, deviceId), (objective, error) -> log.warn("Failed adding/removing pair port to vlan {} next objective {} on {}." + "Error : {}", vlanId, nextId, deviceId, error));
    NextObjective.Builder vlanNextObjectiveBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVlanId(vlanId).build()).addTreatment(treatment.build());
    if (install == true) {
        flowObjectiveService.next(deviceId, vlanNextObjectiveBuilder.addToExisting(context));
    } else {
        flowObjectiveService.next(deviceId, vlanNextObjectiveBuilder.removeFromExisting(context));
    }
    log.debug("Submitted next objective {} for vlan: {} in device {}", nextId, vlanId, deviceId);
}
#method_after
private void updateL2Flooding(DeviceId deviceId, final PortNumber port, VlanId vlanId, boolean install) {
    // Ensure mastership on device
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    // Locate L2 flooding group details for given xconnect vlan
    int nextId = getNextId(deviceId, vlanId);
    if (nextId == -1) {
        log.debug("XConnect vlan {} broadcast group for device {} doesn't exists. " + "Aborting pair group linking.", vlanId, deviceId);
        return;
    }
    // Add pairing-port group to flooding group
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    // treatment.popVlan();
    treatment.setOutput(port);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Pair port added/removed to vlan {} next objective {} on {}", vlanId, nextId, deviceId), (objective, error) -> log.warn("Failed adding/removing pair port to vlan {} next objective {} on {}." + "Error : {}", vlanId, nextId, deviceId, error));
    NextObjective.Builder vlanNextObjectiveBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVlanId(vlanId).build()).addTreatment(treatment.build());
    if (install) {
        flowObjectiveService.next(deviceId, vlanNextObjectiveBuilder.addToExisting(context));
    } else {
        flowObjectiveService.next(deviceId, vlanNextObjectiveBuilder.removeFromExisting(context));
    }
    log.debug("Submitted next objective {} for vlan: {} in device {}", nextId, vlanId, deviceId);
}
#end_block

#method_before
void populateL2Multicast(DeviceId deviceId, final PortNumber pairPort, VlanId vlanId, List<PortNumber> accessPorts) {
    boolean multicastGroupExists = true;
    int vlanMulticastNextId;
    // Ensure mastership on device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    // Step 1 : Populate single homed access ports into vlan's L2 multicast group
    NextObjective.Builder vlanMulticastNextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVendorData(vlanId.toShort()).build());
    vlanMulticastNextId = getMulticastGroupNextObjectiveId(deviceId, vlanId);
    if (vlanMulticastNextId == -1) {
        // Vlan's L2 multicast group doesn't exist; create it, update store and add pair port as sub-group
        multicastGroupExists = false;
        vlanMulticastNextId = flowObjectiveService.allocateNextId();
        addMulticastGroupNextObjectiveId(deviceId, vlanId, vlanMulticastNextId);
        vlanMulticastNextObjBuilder.addTreatment(DefaultTrafficTreatment.builder().popVlan().setOutput(pairPort).build());
    }
    vlanMulticastNextObjBuilder.withId(vlanMulticastNextId);
    final int nextId = vlanMulticastNextId;
    accessPorts.stream().forEach(p -> {
        TrafficTreatment.Builder egressAction = DefaultTrafficTreatment.builder();
        // Do vlan popup action based on interface configuration
        if (interfaceService.getInterfacesByPort(new ConnectPoint(deviceId, p)).stream().noneMatch(i -> i.vlanTagged().contains(vlanId))) {
            egressAction.popVlan();
        }
        egressAction.setOutput(p);
        vlanMulticastNextObjBuilder.addTreatment(egressAction.build());
        addMulticastGroupPort(deviceId, vlanId, p);
    });
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicast group installed/updated. " + "NextObject Id {} on {} for subnet {} ", nextId, deviceId, vlanId), (objective, error) -> log.warn("L2 multicast group failed to install/update. " + " NextObject Id {} on {} for subnet {} : {}", nextId, deviceId, vlanId, error));
    if (!multicastGroupExists) {
        flowObjectiveService.next(deviceId, vlanMulticastNextObjBuilder.add(context));
        // Step 2 : Populate ACL rule; selector = vlan + pair-port, output = vlan L2 multicast group
        TrafficSelector.Builder multicastSelector = DefaultTrafficSelector.builder();
        multicastSelector.matchEthType(Ethernet.TYPE_VLAN);
        multicastSelector.matchInPort(pairPort);
        multicastSelector.matchVlanId(vlanId);
        ForwardingObjective.Builder vlanMulticastForwardingObj = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).nextStep(vlanMulticastNextId).withSelector(multicastSelector.build()).withPriority(100).fromApp(srService.appId()).makePermanent();
        context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicasting versatile rule for device {}, port/vlan {}/{} populated", deviceId, pairPort, vlanId), (objective, error) -> log.warn("Failed to populate L2 multicasting versatile rule for device {}, " + "ports/vlan {}/{}: {}", deviceId, pairPort, vlanId, error));
        flowObjectiveService.forward(deviceId, vlanMulticastForwardingObj.add(context));
    } else {
        // L2_MULTICAST & BROADCAST are similar structure in subgroups; so going with BROADCAST type.
        vlanMulticastNextObjBuilder.withType(NextObjective.Type.BROADCAST);
        flowObjectiveService.next(deviceId, vlanMulticastNextObjBuilder.addToExisting(context));
    }
}
#method_after
private void populateL2Multicast(DeviceId deviceId, final PortNumber pairPort, VlanId vlanId, List<PortNumber> accessPorts) {
    boolean multicastGroupExists = true;
    int vlanMulticastNextId;
    // Ensure enough rights to program pair device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    // Step 1 : Populate single homed access ports into vlan's L2 multicast group
    NextObjective.Builder vlanMulticastNextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVlanId(vlanId).matchEthDst(MacAddress.IPV4_MULTICAST).build());
    vlanMulticastNextId = getMulticastGroupNextObjectiveId(deviceId, vlanId);
    if (vlanMulticastNextId == -1) {
        // Vlan's L2 multicast group doesn't exist; create it, update store and add pair port as sub-group
        multicastGroupExists = false;
        vlanMulticastNextId = flowObjectiveService.allocateNextId();
        addMulticastGroupNextObjectiveId(deviceId, vlanId, vlanMulticastNextId);
        vlanMulticastNextObjBuilder.addTreatment(DefaultTrafficTreatment.builder().popVlan().setOutput(pairPort).build());
    }
    vlanMulticastNextObjBuilder.withId(vlanMulticastNextId);
    final int nextId = vlanMulticastNextId;
    accessPorts.forEach(p -> {
        TrafficTreatment.Builder egressAction = DefaultTrafficTreatment.builder();
        // Do vlan popup action based on interface configuration
        if (interfaceService.getInterfacesByPort(new ConnectPoint(deviceId, p)).stream().noneMatch(i -> i.vlanTagged().contains(vlanId))) {
            egressAction.popVlan();
        }
        egressAction.setOutput(p);
        vlanMulticastNextObjBuilder.addTreatment(egressAction.build());
        addMulticastGroupPort(deviceId, vlanId, p);
    });
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicast group installed/updated. " + "NextObject Id {} on {} for subnet {} ", nextId, deviceId, vlanId), (objective, error) -> log.warn("L2 multicast group failed to install/update. " + " NextObject Id {} on {} for subnet {} : {}", nextId, deviceId, vlanId, error));
    if (!multicastGroupExists) {
        flowObjectiveService.next(deviceId, vlanMulticastNextObjBuilder.add(context));
        // Step 2 : Populate ACL rule; selector = vlan + pair-port, output = vlan L2 multicast group
        TrafficSelector.Builder multicastSelector = DefaultTrafficSelector.builder();
        multicastSelector.matchEthType(Ethernet.TYPE_VLAN);
        multicastSelector.matchInPort(pairPort);
        multicastSelector.matchVlanId(vlanId);
        ForwardingObjective.Builder vlanMulticastForwardingObj = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).nextStep(vlanMulticastNextId).withSelector(multicastSelector.build()).withPriority(100).fromApp(srService.appId()).makePermanent();
        context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicasting versatile rule for device {}, port/vlan {}/{} populated", deviceId, pairPort, vlanId), (objective, error) -> log.warn("Failed to populate L2 multicasting versatile rule for device {}, " + "ports/vlan {}/{}: {}", deviceId, pairPort, vlanId, error));
        flowObjectiveService.forward(deviceId, vlanMulticastForwardingObj.add(context));
    } else {
        // L2_MULTICAST & BROADCAST are similar structure in subgroups; so going with BROADCAST type.
        vlanMulticastNextObjBuilder.withType(NextObjective.Type.BROADCAST);
        flowObjectiveService.next(deviceId, vlanMulticastNextObjBuilder.addToExisting(context));
    }
}
#end_block

#method_before
void revokeL2Multicast(DeviceId deviceId, final PortNumber pairPort, VlanId vlanId, List<PortNumber> accessPorts) {
    // Ensure mastership on device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    int vlanMulticastNextId = getMulticastGroupNextObjectiveId(deviceId, vlanId);
    if (vlanMulticastNextId == -1) {
        return;
    }
    NextObjective.Builder vlanMulticastNextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVlanId(vlanId).build()).withId(vlanMulticastNextId);
    accessPorts.stream().forEach(p -> {
        TrafficTreatment.Builder egressAction = DefaultTrafficTreatment.builder();
        // Do vlan popup action based on interface configuration
        if (interfaceService.getInterfacesByPort(new ConnectPoint(deviceId, p)).stream().noneMatch(i -> i.vlanTagged().contains(vlanId))) {
            egressAction.popVlan();
        }
        egressAction.setOutput(p);
        vlanMulticastNextObjBuilder.addTreatment(egressAction.build());
        removeMulticastGroupPort(deviceId, vlanId, p);
    });
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicast group installed/updated. " + "NextObject Id {} on {} for subnet {} ", vlanMulticastNextId, deviceId, vlanId), (objective, error) -> log.warn("L2 multicast group failed to install/update. " + " NextObject Id {} on {} for subnet {} : {}", vlanMulticastNextId, deviceId, vlanId, error));
    flowObjectiveService.next(deviceId, vlanMulticastNextObjBuilder.removeFromExisting(context));
}
#method_after
private void revokeL2Multicast(DeviceId deviceId, final PortNumber pairPort, VlanId vlanId, List<PortNumber> accessPorts) {
    // Ensure enough rights to program pair device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    int vlanMulticastNextId = getMulticastGroupNextObjectiveId(deviceId, vlanId);
    if (vlanMulticastNextId == -1) {
        return;
    }
    NextObjective.Builder vlanMulticastNextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVlanId(vlanId).build()).withId(vlanMulticastNextId);
    accessPorts.forEach(p -> {
        TrafficTreatment.Builder egressAction = DefaultTrafficTreatment.builder();
        // Do vlan popup action based on interface configuration
        if (interfaceService.getInterfacesByPort(new ConnectPoint(deviceId, p)).stream().noneMatch(i -> i.vlanTagged().contains(vlanId))) {
            egressAction.popVlan();
        }
        egressAction.setOutput(p);
        vlanMulticastNextObjBuilder.addTreatment(egressAction.build());
        removeMulticastGroupPort(deviceId, vlanId, p);
    });
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicast group installed/updated. " + "NextObject Id {} on {} for subnet {} ", vlanMulticastNextId, deviceId, vlanId), (objective, error) -> log.warn("L2 multicast group failed to install/update. " + " NextObject Id {} on {} for subnet {} : {}", vlanMulticastNextId, deviceId, vlanId, error));
    flowObjectiveService.next(deviceId, vlanMulticastNextObjBuilder.removeFromExisting(context));
}
#end_block

#method_before
void cleanupL2MulticastRule(DeviceId deviceId, PortNumber pairPort, VlanId vlanId, boolean force) {
    // Ensure mastership on device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    // Ensure L2 multicast group doesn't contain access ports
    if (hasAccessPortInMulticastGroup(deviceId, vlanId, pairPort) && !force) {
        return;
    }
    // Load L2 multicast group details
    int vlanMulticastNextId = getMulticastGroupNextObjectiveId(deviceId, vlanId);
    if (vlanMulticastNextId == -1) {
        return;
    }
    // Step 1 : Clear ACL rule; selector = vlan + pair-port, output = vlan L2 multicast group
    TrafficSelector.Builder l2MulticastSelector = DefaultTrafficSelector.builder();
    l2MulticastSelector.matchEthType(Ethernet.TYPE_VLAN);
    l2MulticastSelector.matchInPort(pairPort);
    l2MulticastSelector.matchVlanId(vlanId);
    ForwardingObjective.Builder vlanMulticastForwardingObj = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).nextStep(vlanMulticastNextId).withSelector(l2MulticastSelector.build()).withPriority(100).fromApp(srService.appId()).makePermanent();
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicasting rule for device {}, port/vlan {}/{} deleted", deviceId, pairPort, vlanId), (objective, error) -> log.warn("Failed to delete L2 multicasting rule for device {}, " + "ports/vlan {}/{}: {}", deviceId, pairPort, vlanId, error));
    flowObjectiveService.forward(deviceId, vlanMulticastForwardingObj.remove(context));
    // Step 2 : Clear L2 multicast group associated with vlan
    NextObjective.Builder l2MulticastGroupBuilder = DefaultNextObjective.builder().withId(vlanMulticastNextId).withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVendorData(vlanId.toShort()).build()).addTreatment(DefaultTrafficTreatment.builder().popVlan().setOutput(pairPort).build());
    context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicast group with NextObject Id {} deleted on {} for subnet {} ", vlanMulticastNextId, deviceId, vlanId), (objective, error) -> log.warn("L2 multicast group with NextObject Id {} failed to delete on {} for subnet {} : {}", vlanMulticastNextId, deviceId, vlanId, error));
    flowObjectiveService.next(deviceId, l2MulticastGroupBuilder.remove(context));
    // Finally clear store.
    removeMulticastGroup(deviceId, vlanId);
}
#method_after
private void cleanupL2MulticastRule(DeviceId deviceId, PortNumber pairPort, VlanId vlanId, boolean force) {
    // Ensure enough rights to program pair device
    if (!srService.shouldProgram(deviceId)) {
        return;
    }
    // Ensure L2 multicast group doesn't contain access ports
    if (hasAccessPortInMulticastGroup(deviceId, vlanId, pairPort) && !force) {
        return;
    }
    // Load L2 multicast group details
    int vlanMulticastNextId = getMulticastGroupNextObjectiveId(deviceId, vlanId);
    if (vlanMulticastNextId == -1) {
        return;
    }
    // Step 1 : Clear ACL rule; selector = vlan + pair-port, output = vlan L2 multicast group
    TrafficSelector.Builder l2MulticastSelector = DefaultTrafficSelector.builder();
    l2MulticastSelector.matchEthType(Ethernet.TYPE_VLAN);
    l2MulticastSelector.matchInPort(pairPort);
    l2MulticastSelector.matchVlanId(vlanId);
    ForwardingObjective.Builder vlanMulticastForwardingObj = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).nextStep(vlanMulticastNextId).withSelector(l2MulticastSelector.build()).withPriority(100).fromApp(srService.appId()).makePermanent();
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicasting rule for device {}, port/vlan {}/{} deleted", deviceId, pairPort, vlanId), (objective, error) -> log.warn("Failed to delete L2 multicasting rule for device {}, " + "ports/vlan {}/{}: {}", deviceId, pairPort, vlanId, error));
    flowObjectiveService.forward(deviceId, vlanMulticastForwardingObj.remove(context));
    // Step 2 : Clear L2 multicast group associated with vlan
    NextObjective.Builder l2MulticastGroupBuilder = DefaultNextObjective.builder().withId(vlanMulticastNextId).withType(NextObjective.Type.BROADCAST).fromApp(srService.appId()).withMeta(DefaultTrafficSelector.builder().matchVlanId(vlanId).matchEthDst(MacAddress.IPV4_MULTICAST).build()).addTreatment(DefaultTrafficTreatment.builder().popVlan().setOutput(pairPort).build());
    context = new DefaultObjectiveContext((objective) -> log.debug("L2 multicast group with NextObject Id {} deleted on {} for subnet {} ", vlanMulticastNextId, deviceId, vlanId), (objective, error) -> log.warn("L2 multicast group with NextObject Id {} failed to delete on {} for subnet {} : {}", vlanMulticastNextId, deviceId, vlanId, error));
    flowObjectiveService.next(deviceId, l2MulticastGroupBuilder.remove(context));
    // Finally clear store.
    removeMulticastGroup(deviceId, vlanId);
}
#end_block

#method_before
private int getMulticastGroupNextObjectiveId(DeviceId deviceId, VlanId vlanId) {
    Optional<Integer> nextId = xconnectMulticastNextStore.asJavaMap().entrySet().stream().filter(e -> e.getKey().deviceId().equals(deviceId) && e.getKey().vlanId().equals(vlanId)).findFirst().map(Map.Entry::getValue);
    return nextId.isPresent() ? nextId.get().intValue() : -1;
}
#method_after
private int getMulticastGroupNextObjectiveId(DeviceId deviceId, VlanId vlanId) {
    Optional<Integer> nextId = xconnectMulticastNextStore.asJavaMap().entrySet().stream().filter(e -> e.getKey().deviceId().equals(deviceId) && e.getKey().vlanId().equals(vlanId)).findFirst().map(Map.Entry::getValue);
    return nextId.orElse(-1);
}
#end_block

#method_before
public static DefaultWorkflowDescription valueOf(JsonNode root) throws WorkflowException {
    JsonNode node = root.at(ptr(WF_WORKPLACE));
    if (node == null || !(node instanceof TextNode)) {
        throw new WorkflowException("invalid workflow workplace for " + root);
    }
    String wfWorkplaceName = node.asText();
    node = root.at(ptr(WF_ID));
    if (node == null || !(node instanceof TextNode)) {
        throw new WorkflowException("invalid workflow id for " + root);
    }
    URI wfId = URI.create(node.asText());
    node = root.at(ptr(WF_DATA));
    if (node == null || node instanceof MissingNode) {
        throw new WorkflowException("invalid workflow data for " + root);
    }
    JsonNode wfData = node;
    return builder().workplaceName(wfWorkplaceName).id(wfId).data(wfData).build();
}
#method_after
public static DefaultWorkflowDescription valueOf(JsonNode root) throws WorkflowException {
    JsonNode node = root.at(ptr(WF_WORKPLACE));
    if (!(node instanceof TextNode)) {
        throw new WorkflowException("invalid workflow workplace for " + root);
    }
    String wfWorkplaceName = node.asText();
    node = root.at(ptr(WF_ID));
    if (!(node instanceof TextNode)) {
        throw new WorkflowException("invalid workflow id for " + root);
    }
    URI wfId = URI.create(node.asText());
    node = root.at(ptr(WF_DATA));
    if (node instanceof MissingNode) {
        throw new WorkflowException("invalid workflow data for " + root);
    }
    JsonNode wfData = node;
    return builder().workplaceName(wfWorkplaceName).id(wfId).data(wfData).build();
}
#end_block

#method_before
public static DefaultWorkplaceDescription valueOf(JsonNode root) throws WorkflowException {
    JsonNode node = root.at(ptr(WP_NAME));
    if (node == null || !(node instanceof TextNode)) {
        throw new WorkflowException("invalid workplace name for " + root);
    }
    Builder builder = builder().name(node.asText());
    node = root.at(ptr(WP_DATA));
    if (node != null && !(node instanceof MissingNode)) {
        if (!(node instanceof ObjectNode) && !(node instanceof ArrayNode)) {
            throw new WorkflowException("invalid workplace data for " + root);
        }
        builder.data(node);
    }
    return builder.build();
}
#method_after
public static DefaultWorkplaceDescription valueOf(JsonNode root) throws WorkflowException {
    JsonNode node = root.at(ptr(WP_NAME));
    if (!(node instanceof TextNode)) {
        throw new WorkflowException("invalid workplace name for " + root);
    }
    Builder builder = builder().name(node.asText());
    node = root.at(ptr(WP_DATA));
    if (node != null && !(node instanceof MissingNode)) {
        if (!(node instanceof ObjectNode) && !(node instanceof ArrayNode)) {
            throw new WorkflowException("invalid workplace data for " + root);
        }
        builder.data(node);
    }
    return builder.build();
}
#end_block

#method_before
private HandlerTask execEventTimeoutTask(EventTimeoutTask task) {
    Map<String, String> eventMap = null;
    try {
        eventMap = eventMapStore.getEventMap(task.eventType(), task.eventHint());
    } catch (WorkflowException e) {
        log.error("execEventTimeoutTask: Exception: {}, trace: {}", e, Lists.newArrayList(e.getStackTrace()));
        return task;
    }
    if (Objects.isNull(eventMap) || eventMap.isEmpty()) {
        return task;
    }
    if (Objects.isNull(eventMap.get(task.context().name()))) {
        return task;
    }
    log.debug("execEventTimeoutTask- task: {}, hash: {}", task, stringHash(task.context().distributor()));
    WorkflowContext context = (WorkflowContext) (task.context());
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("execEventTimeoutTask: Invalid workflow {}", context.workflowId());
        return task;
    }
    WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("execEventTimeoutTask: Invalid workflow context {}", context.name());
        return task;
    }
    try {
        Worklet worklet = workflow.getWorkletInstance(task.workletType());
        if (!Objects.equals(latestContext.current(), worklet.tag())) {
            log.error("execEventTimeoutTask: Current worklet({}) is not mismatched with task work({}). Ignored.", latestContext.current(), worklet.tag());
            return task;
        }
        if (worklet == Worklet.Common.COMPLETED || worklet == Worklet.Common.INIT) {
            log.error("execEventTimeoutTask: Current worklet is {}, Ignored", worklet);
            return task;
        }
        initWorkletExecution(latestContext);
        log.info("execEventTimeoutTask.timeout-task:{}, latest:{}", task, latestContext);
        eventMapStore.unregisterEventMap(task.eventType(), task.eventHint(), latestContext.name());
        worklet.timeout(latestContext);
        workplaceStore.commitContext(latestContext.name(), latestContext, latestContext.triggerNext());
    } catch (WorkflowException e) {
        log.error("Exception: {}, trace: {}", e, Lists.newArrayList(e.getStackTrace()));
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return task;
}
#method_after
private HandlerTask execEventTimeoutTask(EventTimeoutTask task) {
    Map<String, String> eventMap = null;
    try {
        eventMap = eventMapStore.getEventMap(task.eventType(), task.eventHint());
    } catch (WorkflowException e) {
        log.error("execEventTimeoutTask: Exception: {}, trace: {}", e, Lists.newArrayList(e.getStackTrace()));
        return task;
    }
    if (Objects.isNull(eventMap) || eventMap.isEmpty()) {
        return task;
    }
    if (Objects.isNull(eventMap.get(task.context().name()))) {
        return task;
    }
    log.debug("execEventTimeoutTask- task: {}, hash: {}", task, stringHash(task.context().distributor()));
    WorkflowContext context = task.context();
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("execEventTimeoutTask: Invalid workflow {}", context.workflowId());
        return task;
    }
    WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("execEventTimeoutTask: Invalid workflow context {}", context.name());
        return task;
    }
    try {
        Worklet worklet = workflow.getWorkletInstance(task.workletType());
        if (!Objects.equals(latestContext.current(), worklet.tag())) {
            log.error("execEventTimeoutTask: Current worklet({}) is not mismatched with task work({}). Ignored.", latestContext.current(), worklet.tag());
            return task;
        }
        if (worklet == Worklet.Common.COMPLETED || worklet == Worklet.Common.INIT) {
            log.error("execEventTimeoutTask: Current worklet is {}, Ignored", worklet);
            return task;
        }
        initWorkletExecution(latestContext);
        log.info("execEventTimeoutTask.timeout-task:{}, latest:{}", task, latestContext);
        eventMapStore.unregisterEventMap(task.eventType(), task.eventHint(), latestContext.name());
        worklet.timeout(latestContext);
        workplaceStore.commitContext(latestContext.name(), latestContext, latestContext.triggerNext());
    } catch (WorkflowException e) {
        log.error("Exception: {}, trace: {}", e, Lists.newArrayList(e.getStackTrace()));
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return task;
}
#end_block

#method_before
private void registerWorkflows() {
    // registering class-loader
    workflowStore.registerlocal(this.getClass().getClassLoader());
    // registering new workflow definition
    URI uri = URI.create("sample.workflow-0");
    Workflow workflow = ImmutableListWorkflow.builder().id(uri).chain(SampleWorklet1.class.getName()).chain(SampleWorklet2.class.getName()).chain(SampleWorklet3.class.getName()).chain(SampleWorklet4.class.getName()).chain(SampleWorklet5.class.getName()).build();
    workflowStore.register(workflow);
    // registering new workflow definition
    uri = URI.create("sample.workflow-1");
    workflow = ImmutableListWorkflow.builder().id(uri).chain(SampleWorklet3.class.getName()).chain(SampleWorklet2.class.getName()).chain(SampleWorklet1.class.getName()).chain(SampleWorklet4.class.getName()).chain(SampleWorklet5.class.getName()).build();
    workflowStore.register(workflow);
    // registering new workflow definition
    uri = URI.create("sample.workflow-2");
    workflow = ImmutableListWorkflow.builder().id(uri).chain(SampleWorklet1.class.getName()).chain(SampleWorklet3.class.getName()).chain(SampleWorklet2.class.getName()).chain(SampleWorklet4.class.getName()).chain(SampleWorklet5.class.getName()).build();
    workflowStore.register(workflow);
}
#method_after
private void registerWorkflows() {
    // registering class-loader
    workflowStore.registerLocal(this.getClass().getClassLoader());
    // registering new workflow definition
    URI uri = URI.create("sample.workflow-0");
    Workflow workflow = ImmutableListWorkflow.builder().id(uri).chain(SampleWorklet1.class.getName()).chain(SampleWorklet2.class.getName()).chain(SampleWorklet3.class.getName()).chain(SampleWorklet4.class.getName()).chain(SampleWorklet5.class.getName()).build();
    workflowStore.register(workflow);
    // registering new workflow definition
    uri = URI.create("sample.workflow-1");
    workflow = ImmutableListWorkflow.builder().id(uri).chain(SampleWorklet3.class.getName()).chain(SampleWorklet2.class.getName()).chain(SampleWorklet1.class.getName()).chain(SampleWorklet4.class.getName()).chain(SampleWorklet5.class.getName()).build();
    workflowStore.register(workflow);
    // registering new workflow definition
    uri = URI.create("sample.workflow-2");
    workflow = ImmutableListWorkflow.builder().id(uri).chain(SampleWorklet1.class.getName()).chain(SampleWorklet3.class.getName()).chain(SampleWorklet2.class.getName()).chain(SampleWorklet4.class.getName()).chain(SampleWorklet5.class.getName()).build();
    workflowStore.register(workflow);
}
#end_block

#method_before
public Collection<RpcDescription> getRpcDescriptions() throws WorkflowException {
    JsonNode node = object.at(RPC_PTR);
    if (node == null || !(node instanceof ArrayNode)) {
        throw new WorkflowException("invalid rpc for " + object);
    }
    ArrayNode rpcArrayNode = (ArrayNode) node;
    List<RpcDescription> rpcDescriptions = new ArrayList<>();
    for (JsonNode rpcNode : rpcArrayNode) {
        rpcDescriptions.add(DefaultRpcDescription.valueOf(rpcNode));
    }
    return rpcDescriptions;
}
#method_after
public Collection<RpcDescription> getRpcDescriptions() throws WorkflowException {
    JsonNode node = object.at(RPC_PTR);
    if (!(node instanceof ArrayNode)) {
        throw new WorkflowException("invalid rpc for " + object);
    }
    ArrayNode rpcArrayNode = (ArrayNode) node;
    List<RpcDescription> rpcDescriptions = new ArrayList<>();
    for (JsonNode rpcNode : rpcArrayNode) {
        rpcDescriptions.add(DefaultRpcDescription.valueOf(rpcNode));
    }
    return rpcDescriptions;
}
#end_block

#method_before
private boolean isSubmitted(WorkflowContext context) throws WorkflowException {
    JsonNode node = ((JsonDataModelTree) context.data()).nodeAt("/" + SUBMITTED);
    if (node == null || !(node instanceof BooleanNode)) {
        return false;
    }
    return node.asBoolean();
}
#method_after
private boolean isSubmitted(WorkflowContext context) throws WorkflowException {
    JsonNode node = ((JsonDataModelTree) context.data()).nodeAt("/" + SUBMITTED);
    if (!(node instanceof BooleanNode)) {
        return false;
    }
    return node.asBoolean();
}
#end_block

#method_before
private void submitTrue(WorkflowContext context) throws WorkflowException {
    JsonNode root = ((JsonDataModelTree) context.data()).root();
    if (root == null || !(root instanceof ObjectNode)) {
        throw new WorkflowException("Invalid root node for " + context);
    }
    ((ObjectNode) root).put(SUBMITTED, true);
}
#method_after
private void submitTrue(WorkflowContext context) throws WorkflowException {
    JsonNode root = ((JsonDataModelTree) context.data()).root();
    if (!(root instanceof ObjectNode)) {
        throw new WorkflowException("Invalid root node for " + context);
    }
    ((ObjectNode) root).put(SUBMITTED, true);
}
#end_block

#method_before
public static DefaultRpcDescription valueOf(JsonNode root) throws WorkflowException {
    JsonNode node = root.at(RPC_OP_PTR);
    if (node == null || !(node instanceof TextNode)) {
        throw new WorkflowException("invalid RPC operation for " + root);
    }
    String rpcOp = node.asText();
    node = root.at(RPC_PARAMS_PTR);
    if (node == null || node instanceof MissingNode) {
        throw new WorkflowException("invalid RPC parameters for " + root);
    }
    JsonNode rpcParams = node;
    node = root.at(RPC_ID_PTR);
    if (node == null || !(node instanceof TextNode)) {
        throw new WorkflowException("invalid RPC invocation ID for " + root);
    }
    String rpcId = node.asText();
    return builder().setOp(rpcOp).setParams(rpcParams).setId(rpcId).build();
}
#method_after
public static DefaultRpcDescription valueOf(JsonNode root) throws WorkflowException {
    JsonNode node = root.at(RPC_OP_PTR);
    if (!(node instanceof TextNode)) {
        throw new WorkflowException("invalid RPC operation for " + root);
    }
    String rpcOp = node.asText();
    node = root.at(RPC_PARAMS_PTR);
    if (node instanceof MissingNode) {
        throw new WorkflowException("invalid RPC parameters for " + root);
    }
    JsonNode rpcParams = node;
    node = root.at(RPC_ID_PTR);
    if (!(node instanceof TextNode)) {
        throw new WorkflowException("invalid RPC invocation ID for " + root);
    }
    String rpcId = node.asText();
    return builder().setOp(rpcOp).setParams(rpcParams).setId(rpcId).build();
}
#end_block

#method_before
private JsonNode alloc(JsonNode node, JsonPointer ptr, JsonNodeType leaftype) throws WorkflowException {
    if (ptr.matches()) {
        if (node == null || node instanceof MissingNode) {
            node = createEmpty(leaftype);
        } else {
            // TODO: checking existing node type is matched with leaftype
            if (Objects.equals(node.getNodeType(), leaftype)) {
                throw new WorkflowException("Requesting leaftype(" + leaftype + ") is not matched with " + "existing nodetype(" + node.getNodeType() + ") for " + ptr);
            }
        }
        return node;
    }
    if (ptr.getMatchingIndex() != -1) {
        if (node == null || node instanceof MissingNode) {
            node = createEmpty(JsonNodeType.ARRAY);
        }
        JsonNode child = alloc(node.get(ptr.getMatchingIndex()), ptr.tail(), leaftype);
        if (!node.has(ptr.getMatchingIndex())) {
            ((ArrayNode) node).insert(ptr.getMatchingIndex(), child);
        }
    } else if (ptr.getMatchingProperty() != null) {
        if (node == null || node instanceof MissingNode) {
            node = createEmpty(JsonNodeType.OBJECT);
        }
        JsonNode child = alloc(node.get(ptr.getMatchingProperty()), ptr.tail(), leaftype);
        if (!node.has(ptr.getMatchingProperty())) {
            ((ObjectNode) node).put(ptr.getMatchingProperty(), child);
        }
    }
    return node;
}
#method_after
private JsonNode alloc(JsonNode node, JsonPointer ptr, JsonNodeType leaftype) throws WorkflowException {
    if (ptr.matches()) {
        if (node instanceof MissingNode) {
            node = createEmpty(leaftype);
        } else {
            // TODO: checking existing node type is matched with leaftype
            if (Objects.equals(node.getNodeType(), leaftype)) {
                throw new WorkflowException("Requesting leaftype(" + leaftype + ") is not matched with " + "existing nodetype(" + node.getNodeType() + ") for " + ptr);
            }
        }
        return node;
    }
    if (ptr.getMatchingIndex() != -1) {
        if (node instanceof MissingNode) {
            node = createEmpty(JsonNodeType.ARRAY);
        }
        JsonNode child = alloc(node.get(ptr.getMatchingIndex()), ptr.tail(), leaftype);
        if (!node.has(ptr.getMatchingIndex())) {
            ((ArrayNode) node).insert(ptr.getMatchingIndex(), child);
        }
    } else if (ptr.getMatchingProperty() != null) {
        if (node instanceof MissingNode) {
            node = createEmpty(JsonNodeType.OBJECT);
        }
        JsonNode child = alloc(node.get(ptr.getMatchingProperty()), ptr.tail(), leaftype);
        if (!node.has(ptr.getMatchingProperty())) {
            ((ObjectNode) node).put(ptr.getMatchingProperty(), child);
        }
    }
    return node;
}
#end_block

#method_before
@Override
public void publish(Set<FlowInfo> flowInfos) {
    if (flowInfos.size() == 0) {
        log.debug("No record to publish");
        return;
    }
    long flowByte;
    int flowPkt;
    for (FlowInfo flowInfo : flowInfos) {
        flowByte = flowInfo.statsInfo().currAccBytes() - flowInfo.statsInfo().prevAccBytes();
        flowPkt = flowInfo.statsInfo().currAccPkts() - flowInfo.statsInfo().prevAccPkts();
        byteIP5Tuple.labels(flowInfo.uniqueFlowInfoKey()).inc(flowByte);
        byteDevice.labels(flowInfo.deviceId().toString()).inc(flowByte);
        byteSrcIp.labels(flowInfo.srcIp().toString()).inc(flowByte);
        byteDstIp.labels(flowInfo.dstIp().toString()).inc(flowByte);
        pktIP5Tuple.labels(flowInfo.uniqueFlowInfoKey()).inc(flowPkt);
        pktDevice.labels(flowInfo.deviceId().toString()).inc(flowPkt);
        pktSrcIp.labels(flowInfo.srcIp().toString()).inc(flowPkt);
        pktDstIp.labels(flowInfo.dstIp().toString()).inc(flowPkt);
        pktError.inc(flowInfo.statsInfo().errorPkts());
        pktDrop.inc(flowInfo.statsInfo().dropPkts());
    }
}
#method_after
@Override
public void publish(Set<FlowInfo> flowInfos) {
    if (flowInfos.size() == 0) {
        log.debug("No record to publish");
        return;
    }
    long flowByte;
    int flowPkt;
    for (FlowInfo flowInfo : flowInfos) {
        flowByte = flowInfo.statsInfo().currAccBytes() - flowInfo.statsInfo().prevAccBytes();
        flowPkt = flowInfo.statsInfo().currAccPkts() - flowInfo.statsInfo().prevAccPkts();
        byteVM2VM.labels(flowInfo.uniqueFlowInfoKey()).inc(flowByte);
        byteDevice.labels(flowInfo.deviceId().toString()).inc(flowByte);
        byteSrcIp.labels(flowInfo.srcIp().toString()).inc(flowByte);
        byteDstIp.labels(flowInfo.dstIp().toString()).inc(flowByte);
        pktVM2VM.labels(flowInfo.uniqueFlowInfoKey()).inc(flowPkt);
        pktDevice.labels(flowInfo.deviceId().toString()).inc(flowPkt);
        pktSrcIp.labels(flowInfo.srcIp().toString()).inc(flowPkt);
        pktDstIp.labels(flowInfo.dstIp().toString()).inc(flowPkt);
        pktError.inc(flowInfo.statsInfo().errorPkts());
        pktDrop.inc(flowInfo.statsInfo().dropPkts());
    }
}
#end_block

#method_before
@Override
public PrometheusTelemetryConfig build() {
    checkNotNull(address, "Prometheus exporter binding address cannot be null");
    return new DefaultPrometheusTelemetryConfig(address, port, configMap);
}
#method_after
@Override
public PrometheusTelemetryConfig build() {
    checkNotNull(address, "Prometheus exporter binding address cannot be null");
    checkNotNull(configMap, "Config map cannot be null");
    return new DefaultPrometheusTelemetryConfig(address, port, configMap);
}
#end_block

#method_before
private Map<Integer, Float> populateLatencyData(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float> data = initializeData(MAX_COLUMNS_NB);
    if (monStats == null) {
        return data;
    }
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        // TODO: Use min and max latency to plot bars plots with error bars
        Float value = null;
        if (stats.medianLatency().isPresent()) {
            value = stats.medianLatency().get();
        } else {
            value = new Float(0);
        }
        // Store it locally
        addToCache(deviceId, length, index, value);
        // And into the map
        data.put(index, value);
    }
    return data;
}
#method_after
private Map<Integer, Float> populateLatencyData(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float> data = initializeData(MAX_COLUMNS_NB);
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        // TODO: Use min and max latency to plot bars plots with error bars
        Float value = null;
        if ((stats.averageLatency().isPresent()) && (stats.load() > MIN_CPU_LOAD)) {
            value = stats.averageLatency().get();
        } else {
            value = new Float(0);
        }
        // Unit conversion
        LatencyUnit latencyUnit = null;
        if (stats.latencyUnit().isPresent()) {
            latencyUnit = (LatencyUnit) stats.latencyUnit().get();
        } else {
            latencyUnit = LatencyUnit.NANO_SECOND;
        }
        value = LatencyUnit.toNano(value, latencyUnit);
        // Store it locally
        addToCache(deviceId, length, index, value);
        // And into the map
        data.put(index, value);
    }
    return data;
}
#end_block

#method_before
private Map<Integer, Float[]> populateLatencyDataHistory(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float[]> data = initializeDataHistory(MAX_COLUMNS_NB);
    if (monStats == null) {
        return data;
    }
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        // TODO: Use min and max latency to plot bars plots with error bars
        Float value = null;
        if (stats.medianLatency().isPresent()) {
            value = stats.medianLatency().get();
        } else {
            value = new Float(0);
        }
        // Store it locally
        addToCache(deviceId, length, index, value);
        LruCache<Float> loadCache = getDataHistory(deviceId, index);
        if (loadCache == null) {
            continue;
        }
        float[] floatArray = Floats.toArray(Arrays.asList(loadCache.values().toArray(new Float[0])));
        // Fill the missing points
        float[] filledLoadArray = fillData(floatArray, NUM_OF_DATA_POINTS);
        // Set the data
        data.put(index, ArrayUtils.toObject(filledLoadArray));
    }
    // Keep a timestamp
    timestamp = System.currentTimeMillis();
    return data;
}
#method_after
private Map<Integer, Float[]> populateLatencyDataHistory(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float[]> data = initializeDataHistory(MAX_COLUMNS_NB);
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        // TODO: Use min and max latency to plot bars plots with error bars
        Float value = null;
        if ((stats.averageLatency().isPresent()) && (stats.load() > MIN_CPU_LOAD)) {
            value = stats.averageLatency().get();
        } else {
            value = new Float(0);
        }
        // Unit conversion
        LatencyUnit latencyUnit = null;
        if (stats.latencyUnit().isPresent()) {
            latencyUnit = (LatencyUnit) stats.latencyUnit().get();
        } else {
            latencyUnit = LatencyUnit.NANO_SECOND;
        }
        value = LatencyUnit.toNano(value, latencyUnit);
        // Store it locally
        addToCache(deviceId, length, index, value);
        LruCache<Float> loadCache = getDataHistory(deviceId, index);
        if (loadCache == null) {
            continue;
        }
        float[] floatArray = Floats.toArray(Arrays.asList(loadCache.values().toArray(new Float[0])));
        // Fill the missing points
        float[] filledLoadArray = fillData(floatArray, NUM_OF_DATA_POINTS);
        // Set the data
        data.put(index, ArrayUtils.toObject(filledLoadArray));
    }
    // Keep a timestamp
    timestamp = System.currentTimeMillis();
    return data;
}
#end_block

#method_before
private Map<Integer, Float> populateThroughputData(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float> data = initializeData(MAX_COLUMNS_NB);
    if (monStats == null) {
        return data;
    }
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        Float value = null;
        if (stats.averageThroughput().isPresent()) {
            value = stats.averageThroughput().get();
        } else {
            value = new Float(0);
        }
        // Store it locally
        addToCache(deviceId, length, index, value);
        // And into the map
        data.put(index, value);
    }
    return data;
}
#method_after
private Map<Integer, Float> populateThroughputData(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float> data = initializeData(MAX_COLUMNS_NB);
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        Float value = null;
        if ((stats.averageThroughput().isPresent()) && (stats.load() > MIN_CPU_LOAD)) {
            value = stats.averageThroughput().get();
        } else {
            value = new Float(0);
        }
        // Unit conversion
        ThroughputUnit throughputUnit = null;
        if (stats.throughputUnit().isPresent()) {
            throughputUnit = (ThroughputUnit) stats.throughputUnit().get();
        } else {
            throughputUnit = ThroughputUnit.BPS;
        }
        value = ThroughputUnit.toGbps(value, throughputUnit);
        // Store it locally
        addToCache(deviceId, length, index, value);
        // And into the map
        data.put(index, value);
    }
    return data;
}
#end_block

#method_before
private Map<Integer, Float[]> populateThroughputDataHistory(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float[]> data = initializeDataHistory(MAX_COLUMNS_NB);
    if (monStats == null) {
        return data;
    }
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        Float value = null;
        if (stats.averageThroughput().isPresent()) {
            value = stats.averageThroughput().get();
        } else {
            value = new Float(0);
        }
        // Store it locally
        addToCache(deviceId, length, index, value);
        LruCache<Float> loadCache = getDataHistory(deviceId, index);
        if (loadCache == null) {
            continue;
        }
        float[] floatArray = Floats.toArray(Arrays.asList(loadCache.values().toArray(new Float[0])));
        // Fill the missing points
        float[] filledLoadArray = fillData(floatArray, NUM_OF_DATA_POINTS);
        // Set the data
        data.put(index, ArrayUtils.toObject(filledLoadArray));
    }
    // Keep a timestamp
    timestamp = System.currentTimeMillis();
    return data;
}
#method_after
private Map<Integer, Float[]> populateThroughputDataHistory(DeviceId deviceId, int length, MonitoringStatistics monStats) {
    Map<Integer, Float[]> data = initializeDataHistory(MAX_COLUMNS_NB);
    for (CpuStatistics stats : monStats.cpuStatisticsAll()) {
        int index = stats.id();
        Float value = null;
        if ((stats.averageThroughput().isPresent()) && (stats.load() > MIN_CPU_LOAD)) {
            value = stats.averageThroughput().get();
        } else {
            value = new Float(0);
        }
        // Unit conversion
        ThroughputUnit throughputUnit = null;
        if (stats.throughputUnit().isPresent()) {
            throughputUnit = (ThroughputUnit) stats.throughputUnit().get();
        } else {
            throughputUnit = ThroughputUnit.BPS;
        }
        value = ThroughputUnit.toGbps(value, throughputUnit);
        // Store it locally
        addToCache(deviceId, length, index, value);
        LruCache<Float> loadCache = getDataHistory(deviceId, index);
        if (loadCache == null) {
            continue;
        }
        float[] floatArray = Floats.toArray(Arrays.asList(loadCache.values().toArray(new Float[0])));
        // Fill the missing points
        float[] filledLoadArray = fillData(floatArray, NUM_OF_DATA_POINTS);
        // Set the data
        data.put(index, ArrayUtils.toObject(filledLoadArray));
    }
    // Keep a timestamp
    timestamp = System.currentTimeMillis();
    return data;
}
#end_block

#method_before
public static String traceRequestString(String srcIp, String dstIp, InstancePort srcInstancePort, OpenstackNetworkService osNetService, boolean uplink) {
    String requestString = DEFAULT_REQUEST_STRING;
    if (uplink) {
        requestString = requestString + COMMA + IN_PORT + srcInstancePort.portNumber().toString() + COMMA + NW_SRC + srcIp + COMMA;
        if (osNetService.networkType(srcInstancePort.networkId()).equals(VXLAN) || osNetService.networkType(srcInstancePort.networkId()).equals(VLAN)) {
            if (srcIp.equals(dstIp)) {
                dstIp = osNetService.gatewayIp(srcInstancePort.portId());
                requestString = requestString + DL_DST + DEFAULT_GATEWAY_MAC_STR + COMMA;
            } else if (!osNetService.ipPrefix(srcInstancePort.portId()).contains(IpAddress.valueOf(dstIp))) {
                requestString = requestString + DL_DST + DEFAULT_GATEWAY_MAC_STR + COMMA;
            }
        } else {
            if (srcIp.equals(dstIp)) {
                dstIp = osNetService.gatewayIp(srcInstancePort.portId());
            }
        }
        requestString = requestString + NW_DST + dstIp + "\n";
    } else {
        requestString = requestString + COMMA + NW_SRC + dstIp + COMMA;
        if (osNetService.networkType(srcInstancePort.networkId()).equals(VXLAN) || osNetService.networkType(srcInstancePort.networkId()).equals(VLAN)) {
            requestString = requestString + TUN_ID + osNetService.segmentId(srcInstancePort.networkId()) + COMMA;
        }
        requestString = requestString + NW_DST + srcIp + "\n";
    }
    return requestString;
}
#method_after
public static String traceRequestString(String srcIp, String dstIp, InstancePort srcInstancePort, OpenstackNetworkService osNetService, boolean uplink) {
    StringBuilder requestStringBuilder = new StringBuilder(DEFAULT_REQUEST_STRING);
    if (uplink) {
        requestStringBuilder.append(COMMA).append(IN_PORT).append(srcInstancePort.portNumber().toString()).append(COMMA).append(NW_SRC).append(srcIp).append(COMMA);
        if (osNetService.networkType(srcInstancePort.networkId()).equals(VXLAN) || osNetService.networkType(srcInstancePort.networkId()).equals(VLAN)) {
            if (srcIp.equals(dstIp)) {
                dstIp = osNetService.gatewayIp(srcInstancePort.portId());
                requestStringBuilder.append(DL_DST).append(DEFAULT_GATEWAY_MAC_STR).append(COMMA);
            } else if (!osNetService.ipPrefix(srcInstancePort.portId()).contains(IpAddress.valueOf(dstIp))) {
                requestStringBuilder.append(DL_DST).append(DEFAULT_GATEWAY_MAC_STR).append(COMMA);
            }
        } else {
            if (srcIp.equals(dstIp)) {
                dstIp = osNetService.gatewayIp(srcInstancePort.portId());
            }
        }
        requestStringBuilder.append(NW_DST).append(dstIp).append("\n");
    } else {
        requestStringBuilder.append(COMMA).append(NW_SRC).append(dstIp).append(COMMA);
        if (osNetService.networkType(srcInstancePort.networkId()).equals(VXLAN) || osNetService.networkType(srcInstancePort.networkId()).equals(VLAN)) {
            requestStringBuilder.append(TUN_ID).append(osNetService.segmentId(srcInstancePort.networkId())).append(COMMA);
        }
        requestStringBuilder.append(NW_DST).append(srcIp).append("\n");
    }
    return requestStringBuilder.toString();
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackNodeAdminService osNodeService = AbstractShellCommand.get(OpenstackNodeAdminService.class);
    InstancePortAdminService instancePortService = AbstractShellCommand.get(InstancePortAdminService.class);
    OpenstackNetworkAdminService osNetService = AbstractShellCommand.get(OpenstackNetworkAdminService.class);
    Optional<InstancePort> srcInstance = instancePortService.instancePorts().stream().filter(port -> port.ipAddress().toString().equals(srcIp)).findAny();
    if (!srcInstance.isPresent()) {
        print(NO_ELEMENT);
        return;
    }
    OpenstackNode srcNode = osNodeService.node(srcInstance.get().deviceId());
    if (srcNode == null || srcNode.sshAuthInfo() == null) {
        log.error("Openstack node {} is null or has no SSH authentication information..", srcNode.hostname());
        return;
    }
    if (dstIp.equals(osNetService.gatewayIp(srcInstance.get().portId()))) {
        dstIp = srcIp;
    }
    // print uplink flow trace result
    String requestStringUplink = traceRequestString(srcIp, dstIp, srcInstance.get(), osNetService, true);
    print(FLOW_TRACE_REQUEST_STRING_UPLINK + requestStringUplink);
    String requestStringDownlink = traceRequestString(srcIp, dstIp, srcInstance.get(), osNetService, false);
    print(FLOW_TRACE_REQUEST_STRING_DOWNLINK + requestStringDownlink);
    String traceResult = sendTraceRequestToNode(requestStringUplink + '\n' + requestStringDownlink, srcNode);
    print(traceResult);
}
#method_after
@Override
protected void execute() {
    OpenstackNodeAdminService osNodeService = AbstractShellCommand.get(OpenstackNodeAdminService.class);
    InstancePortAdminService instancePortService = AbstractShellCommand.get(InstancePortAdminService.class);
    OpenstackNetworkAdminService osNetService = AbstractShellCommand.get(OpenstackNetworkAdminService.class);
    Optional<InstancePort> srcInstance = instancePortService.instancePorts().stream().filter(port -> port.ipAddress().toString().equals(srcIp)).findAny();
    if (!srcInstance.isPresent()) {
        print(NO_ELEMENT);
        return;
    }
    OpenstackNode srcNode = osNodeService.node(srcInstance.get().deviceId());
    if (srcNode == null || srcNode.sshAuthInfo() == null) {
        log.error("Openstack node {} is null or has no SSH authentication information.\n" + " Please refers to the sample network-cfg.json in OpenstackNode app to push" + "SSH authentication information", srcNode.hostname());
        return;
    }
    if (dstIp.equals(osNetService.gatewayIp(srcInstance.get().portId()))) {
        dstIp = srcIp;
    }
    // print uplink flow trace result
    String requestStringUplink = traceRequestString(srcIp, dstIp, srcInstance.get(), osNetService, true);
    print(FLOW_TRACE_REQUEST_STRING_UPLINK + requestStringUplink);
    String requestStringDownlink = traceRequestString(srcIp, dstIp, srcInstance.get(), osNetService, false);
    print(FLOW_TRACE_REQUEST_STRING_DOWNLINK + requestStringDownlink);
    String traceResult = sendTraceRequestToNode(requestStringUplink + '\n' + requestStringDownlink, srcNode);
    print(traceResult);
}
#end_block

#method_before
@Override
public void event(NetconfDeviceOutputEvent event) {
    if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
        DeviceId deviceId = event.getDeviceInfo().getDeviceId();
        DeviceAlarmConfig alarmTranslator = getAlarmTranslator(deviceId);
        Set<Alarm> alarms = alarmTranslator.translateAlarms(ImmutableList.of(event));
        triggerProbe(deviceId, alarms);
    }
}
#method_after
@Override
public void event(NetconfDeviceOutputEvent event) {
    if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
        DeviceId deviceId = event.getDeviceInfo().getDeviceId();
        Driver deviceDriver = driverService.getDriver(deviceId);
        Device device = deviceService.getDevice(deviceId);
        if (deviceDriver != null && device.is(DeviceAlarmConfig.class)) {
            DeviceAlarmConfig alarmTranslator = device.as(DeviceAlarmConfig.class);
            DriverData driverData = new DefaultDriverData(deviceDriver, deviceId);
            alarmTranslator.setHandler(new DefaultDriverHandler(driverData));
            Set<Alarm> alarms = alarmTranslator.translateAlarms(ImmutableList.of(event));
            triggerProbe(deviceId, alarms);
        } else {
            String message = event.getMessagePayload();
            InputStream in = new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8));
            Collection<Alarm> newAlarms = translator.translateToAlarm(deviceId, in);
            triggerProbe(deviceId, newAlarms);
        }
    }
}
#end_block

#method_before
@Override
public <T> Set<Alarm> translateAlarms(List<T> unparsedAlarms) {
    deviceId = handler().data().deviceId();
    Set<Alarm> alarms = new HashSet<>();
    for (T alarm : unparsedAlarms) {
        if (alarm instanceof NetconfDeviceOutputEvent) {
            NetconfDeviceOutputEvent event = (NetconfDeviceOutputEvent) alarm;
            if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
                String message = event.getMessagePayload();
                InputStream in = new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8));
                try {
                    Document doc = createDocFromMessage(in);
                    // parse date element value into long
                    Node eventTime = doc.getElementsByTagName(EVENTTIME_TAGNAME).item(0);
                    String dateTime = eventTime.getTextContent();
                    long timeStamp = DateTimeFormatter.ISO_DATE_TIME.parse(dateTime, Instant::from).getEpochSecond();
                    // event-specific tag names as alarm descriptions
                    Node descriptionNode = eventTime.getNextSibling();
                    while (descriptionNode != null) {
                        if (descriptionNode.getNodeType() == Node.ELEMENT_NODE) {
                            String nodeName = descriptionNode.getNodeName();
                            if (nodeName == "port-power-alarm") {
                                Node portIdNode = descriptionNode.getFirstChild();
                                String portId = portIdNode.getTextContent();
                                String description = "Loss of Service alarm raised for fibre " + portId;
                                alarms.add(new DefaultAlarm.Builder(AlarmId.alarmId(deviceId, Long.toString(timeStamp)), deviceId, description, Alarm.SeverityLevel.MAJOR, timeStamp).build());
                                descriptionNode = null;
                            }
                        } else {
                            descriptionNode = descriptionNode.getNextSibling();
                        }
                    }
                } catch (SAXException | IOException | ParserConfigurationException | UnsupportedOperationException | IllegalArgumentException e) {
                    log.error("Exception thrown translating message from {}.", deviceId, e);
                }
            }
        }
    }
    return alarms;
}
#method_after
@Override
public <T> Set<Alarm> translateAlarms(List<T> unparsedAlarms) {
    deviceId = handler().data().deviceId();
    Set<Alarm> alarms = new HashSet<>();
    for (T alarm : unparsedAlarms) {
        if (alarm instanceof NetconfDeviceOutputEvent) {
            NetconfDeviceOutputEvent event = (NetconfDeviceOutputEvent) alarm;
            if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
                String message = event.getMessagePayload();
                InputStream in = new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8));
                try {
                    Document doc = XmlEventParser.createDocFromMessage(in);
                    long timeStamp = XmlEventParser.getEventTime(doc);
                    Node descriptionNode = XmlEventParser.getDescriptionNode(doc);
                    while (descriptionNode != null) {
                        if (descriptionNode.getNodeType() == Node.ELEMENT_NODE) {
                            String nodeName = descriptionNode.getNodeName();
                            if (nodeName == "port-power-alarm") {
                                Node portIdNode = descriptionNode.getChildNodes().item(1);
                                String portId = portIdNode.getTextContent();
                                String description = "Loss of Service alarm raised for fibre " + portId;
                                alarms.add(new DefaultAlarm.Builder(AlarmId.alarmId(deviceId, Long.toString(timeStamp)), deviceId, description, Alarm.SeverityLevel.MAJOR, timeStamp).build());
                                descriptionNode = null;
                            }
                        } else {
                            descriptionNode = descriptionNode.getNextSibling();
                        }
                    }
                } catch (SAXException | IOException | ParserConfigurationException | UnsupportedOperationException | IllegalArgumentException e) {
                    log.error("Exception thrown translating message from {}.", deviceId, e);
                }
            }
        }
    }
    return alarms;
}
#end_block

#method_before
@Beta
protected String createSubscriptionString(String filterSchema) {
    StringBuilder subscriptionbuffer = new StringBuilder();
    subscriptionbuffer.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    subscriptionbuffer.append("  <create-subscription\n");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n");
    DriverService driverService = directory.get(DriverService.class);
    Driver driver = driverService.getDriver(this.deviceInfo.getDeviceId());
    if (driver != null) {
        String stream = driver.getProperty(STREAM);
        if (stream != null) {
            subscriptionbuffer.append("    <stream>");
            subscriptionbuffer.append(stream);
            subscriptionbuffer.append("</stream>\n");
        }
    }
    // FIXME Only subtree filtering supported at the moment.
    if (filterSchema != null) {
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBSCRIPTION_SUBTREE_FILTER_OPEN).append(NEW_LINE);
        subscriptionbuffer.append(filterSchema).append(NEW_LINE);
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBTREE_FILTER_CLOSE).append(NEW_LINE);
    }
    subscriptionbuffer.append("  </create-subscription>\n");
    subscriptionbuffer.append("</rpc>\n");
    subscriptionbuffer.append(ENDPATTERN);
    return subscriptionbuffer.toString();
}
#method_after
@Beta
protected String createSubscriptionString(String filterSchema) {
    StringBuilder subscriptionbuffer = new StringBuilder();
    subscriptionbuffer.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    subscriptionbuffer.append("  <create-subscription\n");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n");
    DriverService driverService = directory.get(DriverService.class);
    Driver driver = driverService.getDriver(deviceInfo.getDeviceId());
    if (driver != null) {
        String stream = driver.getProperty(NOTIFICATION_STREAM);
        if (stream != null) {
            subscriptionbuffer.append("    <stream>");
            subscriptionbuffer.append(stream);
            subscriptionbuffer.append("</stream>\n");
        }
    }
    // FIXME Only subtree filtering supported at the moment.
    if (filterSchema != null) {
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBSCRIPTION_SUBTREE_FILTER_OPEN).append(NEW_LINE);
        subscriptionbuffer.append(filterSchema).append(NEW_LINE);
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBTREE_FILTER_CLOSE).append(NEW_LINE);
    }
    subscriptionbuffer.append("  </create-subscription>\n");
    subscriptionbuffer.append("</rpc>\n");
    subscriptionbuffer.append(ENDPATTERN);
    return subscriptionbuffer.toString();
}
#end_block

#method_before
@Override
public void updateNode(OpenstackNode osNode) {
    checkNotNull(osNode, ERR_NULL_NODE);
    OpenstackNode updatedNode;
    OpenstackNode existNode = osNodeStore.node(osNode.hostname());
    checkNotNull(existNode, ERR_NULL_NODE);
    DeviceId existDeviceId = osNodeStore.node(osNode.hostname()).intgBridge();
    if (vlanIntfChanged(existNode, osNode) || physicalIntfChanged(existNode, osNode) || dpdkIntfChanged(existNode, osNode)) {
        removeNode(osNode.hostname());
        // we wait 1 second for ovsdb client completely to do removal job
        try {
            TimeUnit.MILLISECONDS.sleep(1000);
        } catch (InterruptedException e) {
            log.error(e.toString());
        }
        createNode(osNode);
        return;
    }
    if (osNode.intgBridge() == null && osNode.type() != CONTROLLER) {
        updatedNode = osNode.updateIntbridge(existDeviceId);
        checkArgument(!hasIntgBridge(updatedNode.intgBridge(), updatedNode.hostname()), NOT_DUPLICATED_MSG, updatedNode.intgBridge());
    } else {
        updatedNode = osNode;
        checkArgument(!hasIntgBridge(updatedNode.intgBridge(), updatedNode.hostname()), NOT_DUPLICATED_MSG, updatedNode.intgBridge());
    }
    osNodeStore.updateNode(updatedNode);
    log.info(String.format(MSG_NODE, osNode.hostname(), MSG_UPDATED));
}
#method_after
@Override
public void updateNode(OpenstackNode osNode) {
    checkNotNull(osNode, ERR_NULL_NODE);
    OpenstackNode updatedNode;
    OpenstackNode existingNode = osNodeStore.node(osNode.hostname());
    checkNotNull(existingNode, ERR_NULL_NODE);
    DeviceId existDeviceId = osNodeStore.node(osNode.hostname()).intgBridge();
    if (vlanIntfChanged(existingNode, osNode) || physicalIntfChanged(existingNode, osNode) || dpdkIntfChanged(existingNode, osNode)) {
        removeNode(osNode.hostname());
        // we wait 1 second for ovsdb client completely to do removal job
        try {
            TimeUnit.MILLISECONDS.sleep(1000);
        } catch (InterruptedException e) {
            log.error("Exception occurred because of {}", e);
        }
        if (!intfsRemovedFromExistNode(existingNode)) {
            log.error("Updated node failed because intfs of existingNode {} are not removed properly", existingNode.toString());
            return;
        }
        createNode(osNode);
        return;
    }
    if (osNode.intgBridge() == null && osNode.type() != CONTROLLER) {
        updatedNode = osNode.updateIntbridge(existDeviceId);
        checkArgument(!hasIntgBridge(updatedNode.intgBridge(), updatedNode.hostname()), NOT_DUPLICATED_MSG, updatedNode.intgBridge());
    } else {
        updatedNode = osNode;
        checkArgument(!hasIntgBridge(updatedNode.intgBridge(), updatedNode.hostname()), NOT_DUPLICATED_MSG, updatedNode.intgBridge());
    }
    osNodeStore.updateNode(updatedNode);
    log.info(String.format(MSG_NODE, osNode.hostname(), MSG_UPDATED));
}
#end_block

#method_before
@Override
public void processDeviceCreatedState(OpenstackNode osNode) {
    try {
        if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
            ovsdbController.connect(osNode.managementIp(), tpPort(ovsdbPort));
            return;
        }
        if (osNode.type() == GATEWAY) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.uplinkPort(), deviceService, true);
        }
        if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
            createTunnelInterface(osNode);
        }
        if (osNode.dpdkConfig() != null && osNode.dpdkConfig().dpdkIntfs() != null) {
            osNode.dpdkConfig().dpdkIntfs().stream().filter(dpdkInterface -> !dpdkInterface.deviceName().equals(INTEGRATION_BRIDGE)).forEach(dpdkInterface -> addOrRemoveDpdkInterface(osNode, dpdkInterface, ovsdbPort, ovsdbController, true));
            osNode.dpdkConfig().dpdkIntfs().stream().filter(dpdkInterface -> dpdkInterface.deviceName().equals(INTEGRATION_BRIDGE)).forEach(dpdkInterface -> addOrRemoveDpdkInterface(osNode, dpdkInterface, ovsdbPort, ovsdbController, true));
        }
        osNode.phyIntfs().forEach(i -> {
            if (!isIntfEnabled(osNode, i.intf())) {
                addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, i.intf(), deviceService, true);
            }
        });
        if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.vlanIntf(), deviceService, true);
        }
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#method_after
@Override
public void processDeviceCreatedState(OpenstackNode osNode) {
    try {
        if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
            ovsdbController.connect(osNode.managementIp(), tpPort(ovsdbPort));
            return;
        }
        if (osNode.type() == GATEWAY) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.uplinkPort(), deviceService, true);
        }
        if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
            createTunnelInterface(osNode);
        }
        if (osNode.dpdkConfig() != null && osNode.dpdkConfig().dpdkIntfs() != null) {
            osNode.dpdkConfig().dpdkIntfs().stream().filter(dpdkInterface -> dpdkInterface.deviceName().equals(TUNNEL_BRIDGE)).forEach(dpdkInterface -> addOrRemoveDpdkInterface(osNode, dpdkInterface, ovsdbPort, ovsdbController, true));
            osNode.dpdkConfig().dpdkIntfs().stream().filter(dpdkInterface -> dpdkInterface.deviceName().equals(INTEGRATION_BRIDGE)).forEach(dpdkInterface -> addOrRemoveDpdkInterface(osNode, dpdkInterface, ovsdbPort, ovsdbController, true));
        }
        osNode.phyIntfs().forEach(i -> {
            if (!isIntfEnabled(osNode, i.intf())) {
                addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, i.intf(), deviceService, true);
            }
        });
        if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.vlanIntf(), deviceService, true);
        }
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#end_block

#method_before
private boolean isCurrentStateDone(OpenstackNode osNode) {
    switch(osNode.state()) {
        case INIT:
            if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
                return false;
            }
            boolean initStateDone = deviceService.isAvailable(osNode.intgBridge());
            if (hasDpdkTunnelBridge(osNode)) {
                initStateDone = initStateDone && dpdkTunnelBridgeCreated(osNode);
            }
            return initStateDone;
        case DEVICE_CREATED:
            if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
                return false;
            }
            if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
                return false;
            }
            if (osNode.type() == GATEWAY && !isIntfEnabled(osNode, osNode.uplinkPort())) {
                return false;
            }
            if (osNode.dpdkConfig() != null && osNode.dpdkConfig().dpdkIntfs() != null) {
                if (!isDpdkIntfsCreated(osNode, osNode.dpdkConfig().dpdkIntfs())) {
                    return false;
                }
            }
            for (OpenstackPhyInterface intf : osNode.phyIntfs()) {
                if (intf != null && !isIntfEnabled(osNode, intf.intf())) {
                    return false;
                }
            }
            return true;
        case COMPLETE:
        case INCOMPLETE:
            // run init CLI to re-trigger node bootstrap
            return false;
        default:
            return true;
    }
}
#method_after
private boolean isCurrentStateDone(OpenstackNode osNode) {
    switch(osNode.state()) {
        case INIT:
            if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
                return false;
            }
            boolean initStateDone = deviceService.isAvailable(osNode.intgBridge());
            if (hasDpdkTunnelBridge(osNode)) {
                initStateDone = initStateDone && dpdkTunnelBridgeCreated(osNode);
            }
            return initStateDone;
        case DEVICE_CREATED:
            if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
                return false;
            }
            if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
                return false;
            }
            if (osNode.type() == GATEWAY && !isIntfEnabled(osNode, osNode.uplinkPort())) {
                return false;
            }
            if (osNode.dpdkConfig() != null && osNode.dpdkConfig().dpdkIntfs() != null && !isDpdkIntfsCreated(osNode, osNode.dpdkConfig().dpdkIntfs())) {
                return false;
            }
            for (OpenstackPhyInterface intf : osNode.phyIntfs()) {
                if (intf != null && !isIntfEnabled(osNode, intf.intf())) {
                    return false;
                }
            }
            return true;
        case COMPLETE:
        case INCOMPLETE:
            // run init CLI to re-trigger node bootstrap
            return false;
        default:
            return true;
    }
}
#end_block

#method_before
private void removeVlanInterface(OpenstackNode osNode) {
    if (osNode.vlanIntf() != null) {
        Optional<DpdkInterface> dpdkInterface = osNode.dpdkConfig().dpdkIntfs().stream().filter(intf -> intf.intf().equals(osNode.vlanIntf())).findAny();
        if (dpdkInterface.isPresent()) {
            addOrRemoveDpdkInterface(osNode, dpdkInterface.get(), ovsdbPort, ovsdbController, false);
        } else {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.vlanIntf(), deviceService, false);
        }
    }
}
#method_after
private void removeVlanInterface(OpenstackNode osNode) {
    if (osNode.vlanIntf() != null) {
        Optional<DpdkInterface> dpdkInterface = dpdkInterfaceByIntfName(osNode, osNode.vlanIntf());
        removeInterfaceOnIntegrationBridge(osNode, osNode.vlanIntf(), dpdkInterface);
    }
}
#end_block

#method_before
private void removePhysicalInterface(OpenstackNode osNode) {
    osNode.phyIntfs().forEach(phyIntf -> {
        Optional<DpdkInterface> dpdkInterface = osNode.dpdkConfig().dpdkIntfs().stream().filter(dpdkIntf -> dpdkIntf.intf().equals(phyIntf.intf())).findAny();
        if (dpdkInterface.isPresent()) {
            addOrRemoveDpdkInterface(osNode, dpdkInterface.get(), ovsdbPort, ovsdbController, false);
        } else {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, phyIntf.intf(), deviceService, false);
        }
    });
}
#method_after
private void removePhysicalInterface(OpenstackNode osNode) {
    osNode.phyIntfs().forEach(phyIntf -> {
        Optional<DpdkInterface> dpdkInterface = dpdkInterfaceByIntfName(osNode, phyIntf.intf());
        removeInterfaceOnIntegrationBridge(osNode, phyIntf.intf(), dpdkInterface);
    });
}
#end_block

#method_before
private void processOpenstackNodeRemoved(OpenstackNode osNode) {
    // delete physical interfaces from the node
    removePhysicalInterface(osNode);
    // delete vlan interface from the node
    removeVlanInterface(osNode);
    // delete dpdk interfaces from the node
    osNode.dpdkConfig().dpdkIntfs().forEach(dpdkInterface -> {
        addOrRemoveDpdkInterface(osNode, dpdkInterface, ovsdbPort, ovsdbController, false);
    });
}
#method_after
private void processOpenstackNodeRemoved(OpenstackNode osNode) {
    // delete physical interfaces from the node
    removePhysicalInterface(osNode);
    // delete vlan interface from the node
    removeVlanInterface(osNode);
    // delete dpdk interfaces from the node
    if (osNode.dpdkConfig() != null) {
        osNode.dpdkConfig().dpdkIntfs().forEach(dpdkInterface -> {
            if (isDpdkIntfsCreated(osNode, Lists.newArrayList(dpdkInterface))) {
                addOrRemoveDpdkInterface(osNode, dpdkInterface, ovsdbPort, ovsdbController, false);
            }
        });
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    OpenstackNode osNode = osNodeService.node(device.id());
    switch(event.type()) {
        case DEVICE_AVAILABILITY_CHANGED:
        case DEVICE_ADDED:
            eventExecutor.execute(() -> {
                if (deviceService.isAvailable(device.id())) {
                    log.debug("Integration bridge created on {}", osNode.hostname());
                    bootstrapNode(osNode);
                } else if (osNode.state() == COMPLETE) {
                    log.info("Device {} disconnected", device.id());
                    setState(osNode, INCOMPLETE);
                }
                if (autoRecovery) {
                    if (osNode.state() == INCOMPLETE || osNode.state() == DEVICE_CREATED) {
                        log.info("Device {} is reconnected", device.id());
                        osNodeAdminService.updateNode(osNode.updateState(NodeState.INIT));
                    }
                }
            });
            break;
        case PORT_UPDATED:
        case PORT_ADDED:
            eventExecutor.execute(() -> {
                Port port = event.port();
                String portName = port.annotations().value(PORT_NAME);
                if (osNode.state() == DEVICE_CREATED && (Objects.equals(portName, DEFAULT_TUNNEL) || Objects.equals(portName, osNode.vlanIntf()) || Objects.equals(portName, osNode.uplinkPort()) || containsPhyIntf(osNode, portName)) || containsDpdkIntfs(osNode, portName)) {
                    log.info("Interface {} added to {}", portName, device.id());
                    bootstrapNode(osNode);
                }
            });
            break;
        case PORT_REMOVED:
            eventExecutor.execute(() -> {
                Port port = event.port();
                String portName = port.annotations().value(PORT_NAME);
                if (osNode.state() == COMPLETE && (Objects.equals(portName, DEFAULT_TUNNEL) || Objects.equals(portName, osNode.vlanIntf()) || Objects.equals(portName, osNode.uplinkPort()) || containsPhyIntf(osNode, portName)) || containsDpdkIntfs(osNode, portName)) {
                    log.warn("Interface {} removed from {}", portName, event.subject().id());
                    setState(osNode, INCOMPLETE);
                }
            });
            break;
        case DEVICE_REMOVED:
        default:
            // do nothing
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    OpenstackNode osNode = osNodeService.node(device.id());
    switch(event.type()) {
        case DEVICE_AVAILABILITY_CHANGED:
        case DEVICE_ADDED:
            eventExecutor.execute(() -> {
                if (deviceService.isAvailable(device.id())) {
                    log.debug("Integration bridge created on {}", osNode.hostname());
                    bootstrapNode(osNode);
                } else if (osNode.state() == COMPLETE) {
                    log.info("Device {} disconnected", device.id());
                    setState(osNode, INCOMPLETE);
                }
                if (autoRecovery) {
                    if (osNode.state() == INCOMPLETE || osNode.state() == DEVICE_CREATED) {
                        log.info("Device {} is reconnected", device.id());
                        osNodeAdminService.updateNode(osNode.updateState(NodeState.INIT));
                    }
                }
            });
            break;
        case PORT_UPDATED:
        case PORT_ADDED:
            eventExecutor.execute(() -> {
                Port port = event.port();
                String portName = port.annotations().value(PORT_NAME);
                if (osNode.state() == DEVICE_CREATED && (Objects.equals(portName, DEFAULT_TUNNEL) || Objects.equals(portName, osNode.vlanIntf()) || Objects.equals(portName, osNode.uplinkPort()) || containsPhyIntf(osNode, portName)) || containsDpdkIntfs(osNode, portName)) {
                    log.info("Interface {} added or updated to {}", portName, device.id());
                    bootstrapNode(osNode);
                }
            });
            break;
        case PORT_REMOVED:
            eventExecutor.execute(() -> {
                Port port = event.port();
                String portName = port.annotations().value(PORT_NAME);
                if (osNode.state() == COMPLETE && (Objects.equals(portName, DEFAULT_TUNNEL) || Objects.equals(portName, osNode.vlanIntf()) || Objects.equals(portName, osNode.uplinkPort()) || containsPhyIntf(osNode, portName)) || containsDpdkIntfs(osNode, portName)) {
                    log.warn("Interface {} removed from {}", portName, event.subject().id());
                    setState(osNode, INCOMPLETE);
                }
            });
            break;
        case DEVICE_REMOVED:
        default:
            // do nothing
            break;
    }
}
#end_block

#method_before
private boolean containsDpdkIntfs(OpenstackNode osNode, String portName) {
    return osNode.dpdkConfig().dpdkIntfs().stream().anyMatch(dpdkInterface -> dpdkInterface.intf().equals(portName));
}
#method_after
private boolean containsDpdkIntfs(OpenstackNode osNode, String portName) {
    if (osNode.dpdkConfig() == null) {
        return false;
    }
    return osNode.dpdkConfig().dpdkIntfs().stream().anyMatch(dpdkInterface -> dpdkInterface.intf().equals(portName));
}
#end_block

#method_before
public static void addOrRemoveSystemInterface(OpenstackNode osNode, String bridgeName, String intfName, DeviceService deviceService, boolean addOrRemove) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.info("device is null or this device if not ovsdb device");
        return;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    if (addOrRemove) {
        bridgeConfig.addPort(BridgeName.bridgeName(bridgeName), intfName);
    } else {
        bridgeConfig.deletePort(BridgeName.bridgeName(bridgeName), intfName);
    }
}
#method_after
public static synchronized void addOrRemoveSystemInterface(OpenstackNode osNode, String bridgeName, String intfName, DeviceService deviceService, boolean addOrRemove) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.info("device is null or this device if not ovsdb device");
        return;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    if (addOrRemove) {
        bridgeConfig.addPort(BridgeName.bridgeName(bridgeName), intfName);
    } else {
        bridgeConfig.deletePort(BridgeName.bridgeName(bridgeName), intfName);
    }
}
#end_block

#method_before
public static void addOrRemoveDpdkInterface(OpenstackNode osNode, DpdkInterface dpdkInterface, int ovsdbPort, OvsdbController ovsdbController, boolean addOrRemove) {
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    if (client == null) {
        log.info("Failed to get ovsdb client");
        return;
    }
    if (addOrRemove) {
        Map<String, String> options = Maps.newHashMap();
        options.put(DPDK_DEVARGS, dpdkInterface.pciAddress());
        OvsdbInterface.Builder builder = OvsdbInterface.builder().name(dpdkInterface.intf()).type(OvsdbInterface.Type.DPDK).mtu(dpdkInterface.mtu()).options(options);
        client.createInterface(dpdkInterface.deviceName(), builder.build());
    } else {
        client.dropInterface(dpdkInterface.intf());
    }
}
#method_after
public static synchronized void addOrRemoveDpdkInterface(OpenstackNode osNode, DpdkInterface dpdkInterface, int ovsdbPort, OvsdbController ovsdbController, boolean addOrRemove) {
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    if (client == null) {
        log.info("Failed to get ovsdb client");
        return;
    }
    if (addOrRemove) {
        Map<String, String> options = ImmutableMap.of(DPDK_DEVARGS, dpdkInterface.pciAddress());
        OvsdbInterface.Builder builder = OvsdbInterface.builder().name(dpdkInterface.intf()).type(OvsdbInterface.Type.DPDK).mtu(dpdkInterface.mtu()).options(options);
        client.createInterface(dpdkInterface.deviceName(), builder.build());
    } else {
        client.dropInterface(dpdkInterface.intf());
    }
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    log.info("Flow statistics add request called with src IP: {}, dst IP: {}", srcIp, dstIp);
    eventExecutor.execute(() -> processFlowStatsAddRequest(srcIp, dstIp));
}
#method_after
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    log.info("Flow statistics add request called with src IP: {}, dst IP: {}", srcIp, dstIp);
    eventExecutor.execute(() -> processFlowStatsRequest(srcIp, dstIp, true));
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    log.info("Flow statistics removal request called with src IP: {}, dst IP: {}", srcIp, dstIp);
    eventExecutor.execute(() -> processFlowStatsRemoveRequest(srcIp, dstIp));
}
#method_after
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    log.info("Flow statistics removal request called with src IP: {}, dst IP: {}", srcIp, dstIp);
    eventExecutor.execute(() -> processFlowStatsRequest(srcIp, dstIp, false));
}
#end_block

#method_before
@Override
public void setStatFlowL2Rule(String srcIp, String dstIp, Boolean install) {
    StatsFlowRule statsFlowRule = DefaultStatsFlowRule.builder().srcIpPrefix(IpPrefix.valueOf(srcIp + "/" + String.valueOf(ARBITRARY_LENGTH))).dstIpPrefix(IpPrefix.valueOf(dstIp + "/" + String.valueOf(ARBITRARY_LENGTH))).ipProtocol((byte) ARBITRARY_PROTOCOL).build();
    setStatFlowRule(statsFlowRule, install);
}
#method_after
@Override
public void setStatFlowL2Rule(String srcIp, String dstIp, Boolean install) {
    StatsFlowRule statsFlowRule = DefaultStatsFlowRule.builder().srcIpPrefix(IpPrefix.valueOf(IpAddress.valueOf(srcIp), ARBITRARY_LENGTH)).dstIpPrefix(IpPrefix.valueOf(IpAddress.valueOf(dstIp), ARBITRARY_LENGTH)).ipProtocol((byte) ARBITRARY_PROTOCOL).build();
    setStatFlowRule(statsFlowRule, install);
}
#end_block

#method_before
private void reassertRole(final DeviceId did, final MastershipRole nextRole) {
    MastershipRole myNextRole = nextRole;
    if (myNextRole == NONE && upgradeService.isLocalActive()) {
        try {
            mastershipService.requestRoleFor(did).get();
            MastershipTerm term = termService.getMastershipTerm(did);
            if (term != null && localNodeId.equals(term.master())) {
                myNextRole = MASTER;
            } else {
                myNextRole = STANDBY;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Interrupted waiting for Mastership", e);
        } catch (ExecutionException e) {
            log.error("Encountered an error waiting for Mastership", e);
        }
    }
    switch(myNextRole) {
        case MASTER:
            // Carmelo: this would mark online any device with
            // defaultAvailable=false. Instead we should leave to providers
            // the decision on when to mark a device as available or not.
            // final Device device = getDevice(did);
            // if (device != null && !isAvailable(did)) {
            // post(store.markOnline(did));
            // }
            // TODO: should apply role only if there is mismatch
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, MASTER)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case STANDBY:
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, STANDBY)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case NONE:
            break;
        default:
            // should never reach here
            log.error("You didn't see anything. I did not exist.");
            break;
    }
}
#method_after
private void reassertRole(final DeviceId did, final MastershipRole nextRole) {
    MastershipRole myNextRole = nextRole;
    if (myNextRole == NONE && upgradeService.isLocalActive()) {
        try {
            mastershipService.requestRoleFor(did).get();
            MastershipTerm term = termService.getMastershipTerm(did);
            if (term != null && localNodeId.equals(term.master())) {
                myNextRole = MASTER;
            } else {
                myNextRole = STANDBY;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Interrupted waiting for Mastership", e);
        } catch (ExecutionException e) {
            log.error("Encountered an error waiting for Mastership", e);
        }
    }
    switch(myNextRole) {
        case MASTER:
            final Device device = getDevice(did);
            if (device != null && !isAvailable(did) && canMarkOnline(device)) {
                post(store.markOnline(did));
            }
            // TODO: should apply role only if there is mismatch
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, MASTER)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case STANDBY:
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, STANDBY)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case NONE:
            break;
        default:
            // should never reach here
            log.error("You didn't see anything. I did not exist.");
            break;
    }
}
#end_block

#method_before
private void startAcceptingConnections() throws InterruptedException {
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup).channel(serverChannelClass).childHandler(new OvsdbChannelInitializer(this, sslContext));
    b.option(ChannelOption.SO_BACKLOG, 128);
    b.option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 32 * 1024);
    b.option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 8 * 1024);
    b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
    b.childOption(ChannelOption.SO_KEEPALIVE, true);
    b.bind(ovsdbPort).sync();
}
#method_after
private void startAcceptingConnections() throws InterruptedException {
    if (cg == null) {
        return;
    }
    final ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup).channel(serverChannelClass).childHandler(new OvsdbChannelInitializer(this, sslContext));
    b.option(ChannelOption.SO_REUSEADDR, true);
    b.option(ChannelOption.SO_BACKLOG, 128);
    b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
    b.childOption(ChannelOption.SO_SNDBUF, Controller.SEND_BUFFER_SIZE);
    b.childOption(ChannelOption.SO_KEEPALIVE, true);
    cg.add(b.bind(ovsdbPort).syncUninterruptibly().channel());
}
#end_block

#method_before
protected void handleNewNodeConnection(final Channel channel) {
    executorService.execute(new Runnable() {

        @Override
        public void run() {
            log.info("Handle new node connection");
            IpAddress ipAddress = IpAddress.valueOf(((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress());
            long port = ((InetSocketAddress) channel.remoteAddress()).getPort();
            log.info("Get connection from ip address {} : {}", ipAddress.toString(), port);
            OvsdbNodeId nodeId = new OvsdbNodeId(ipAddress, port);
            OvsdbProviderService ovsdbProviderService = getNodeInstance(nodeId, agent, monitorCallback, channel);
            ovsdbProviderService.setConnection(true);
            OvsdbJsonRpcHandler ovsdbJsonRpcHandler = new OvsdbJsonRpcHandler(nodeId);
            ovsdbJsonRpcHandler.setOvsdbProviderService(ovsdbProviderService);
            channel.pipeline().addLast(ovsdbJsonRpcHandler);
            ovsdbProviderService.nodeAdded();
            ChannelFuture closeFuture = channel.closeFuture();
            closeFuture.addListener(new ChannelConnectionListener(ovsdbProviderService));
        }
    });
}
#method_after
protected void handleNewNodeConnection(final Channel channel) {
    executorService.execute(() -> {
        log.info("Handle new node connection");
        IpAddress ipAddress = IpAddress.valueOf(((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress());
        long port = ((InetSocketAddress) channel.remoteAddress()).getPort();
        log.info("Get connection from ip address {} : {}", ipAddress.toString(), port);
        OvsdbNodeId nodeId = new OvsdbNodeId(ipAddress, port);
        OvsdbProviderService ovsdbProviderService = getNodeInstance(nodeId, agent, monitorCallback, channel);
        ovsdbProviderService.setConnection(true);
        OvsdbJsonRpcHandler ovsdbJsonRpcHandler = new OvsdbJsonRpcHandler(nodeId);
        ovsdbJsonRpcHandler.setOvsdbProviderService(ovsdbProviderService);
        channel.pipeline().addLast(ovsdbJsonRpcHandler);
        ovsdbProviderService.nodeAdded();
        ChannelFuture closeFuture = channel.closeFuture();
        closeFuture.addListener(new ChannelConnectionListener(ovsdbProviderService));
    });
}
#end_block

#method_before
public void stop() {
    workerGroup.shutdownGracefully();
    bossGroup.shutdownGracefully();
}
#method_after
public void stop() {
    if (cg != null) {
        cg.close();
        cg = null;
        workerGroup.shutdownGracefully();
        bossGroup.shutdownGracefully();
        // Wait until all threads are terminated.
        try {
            bossGroup.terminationFuture().sync();
            workerGroup.terminationFuture().sync();
        } catch (InterruptedException e) {
            log.warn("Interrupted while stopping", e);
            Thread.currentThread().interrupt();
        }
    }
}
#end_block

#method_before
private void connectRetry(IpAddress ip, TpPort port, ChannelFutureListener listener) {
    Bootstrap b = new Bootstrap();
    b.group(workerGroup).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true).handler(new ChannelInitializer<SocketChannel>() {

        @Override
        protected void initChannel(SocketChannel channel) throws Exception {
            ChannelPipeline pipeline = channel.pipeline();
            /* TODO: When ONOS need to intitiate connection to OVSDB using Password SSL(pssl:).*/
            /*
                        if (sslContext != null) {
                            log.info("OVSDB SSL enabled.");
                            SSLEngine sslEngine = sslContext.createSSLEngine();

                            sslEngine.setNeedClientAuth(true);
                            sslEngine.setUseClientMode(false);
                            sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());
                            sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());
                            sslEngine.setEnableSessionCreation(true);

                            SslHandler sslHandler = new SslHandler(sslEngine);
                            pipeline.addLast("ssl", sslHandler);
                        } else {
                            log.info("OVSDB SSL disabled.");
                        }
                        */
            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
            pipeline.addLast(new MessageDecoder());
            pipeline.addLast(new IdleStateHandler(IDLE_TIMEOUT_SEC, 0, 0));
            pipeline.addLast(new ConnectionHandler());
        }
    });
    b.remoteAddress(ip.toString(), port.toInt());
    b.connect().addListener(listener);
}
#method_after
private void connectRetry(IpAddress ip, TpPort port, ChannelFutureListener listener) {
    Bootstrap b = new Bootstrap();
    b.group(workerGroup).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true).handler(new ChannelInitializer<SocketChannel>() {

        @Override
        protected void initChannel(SocketChannel channel) throws Exception {
            ChannelPipeline pipeline = channel.pipeline();
            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
            pipeline.addLast(new MessageDecoder());
            pipeline.addLast(new IdleStateHandler(IDLE_TIMEOUT_SEC, 0, 0));
            pipeline.addLast(new ConnectionHandler());
        }
    });
    b.remoteAddress(ip.toString(), port.toInt());
    b.connect().addListener(listener);
}
#end_block

#method_before
public void init() {
    try {
        getTlsParameters();
        if (enableOvsdbTls) {
            initSsl();
        }
    } catch (Exception ex) {
        log.error("SSL init failed: {}", ex.getMessage());
    }
}
#method_after
public void init() {
    cg = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    if (tlsParams.isTlsEnabled()) {
        initSsl();
    }
}
#end_block

#method_before
private void initSsl() throws Exception {
    TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    KeyStore ts = KeyStore.getInstance("JKS");
    ts.load(new FileInputStream(tsLocation), tsPwd);
    tmFactory.init(ts);
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    KeyStore ks = KeyStore.getInstance("JKS");
    ks.load(new FileInputStream(ksLocation), ksPwd);
    kmf.init(ks, ksPwd);
    sslContext = SSLContext.getInstance("TLS");
    log.debug("sslContext is {}", sslContext != null ? "present" : "null", sslContext);
    sslContext.init(kmf.getKeyManagers(), tmFactory.getTrustManagers(), null);
}
#method_after
private void initSsl() {
    try {
        TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        KeyStore ts = KeyStore.getInstance(JAVA_KEY_STORE);
        ts.load(new FileInputStream(tlsParams.tsLocation), tlsParams.tsPwd());
        tmFactory.init(ts);
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyStore = KeyStore.getInstance(JAVA_KEY_STORE);
        keyStore.load(new FileInputStream(tlsParams.ksLocation), tlsParams.ksPwd());
        kmf.init(keyStore, tlsParams.ksPwd());
        sslContext = SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(), tmFactory.getTrustManagers(), null);
    } catch (NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException | KeyManagementException | UnrecoverableKeyException ex) {
        log.error("SSL init failed: {}", ex.getMessage());
    }
}
#end_block

#method_before
@Override
protected void initChannel(SocketChannel channel) throws Exception {
    ChannelPipeline pipeline = channel.pipeline();
    if (sslContext != null) {
        log.info("OVSDB SSL enabled.");
        SSLEngine sslEngine = sslContext.createSSLEngine();
        sslEngine.setNeedClientAuth(true);
        sslEngine.setUseClientMode(false);
        sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());
        sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());
        sslEngine.setEnableSessionCreation(true);
        SslHandler sslHandler = new SslHandler(sslEngine);
        pipeline.addLast("ssl", sslHandler);
    } else {
        log.info("OVSDB SSL disabled.");
    }
    pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
    pipeline.addLast(new MessageDecoder());
    pipeline.addLast(new IdleStateHandler(20, 25, 0));
    pipeline.addLast(new ReadTimeoutHandler(180));
    controller.handleNewNodeConnection(channel);
}
#method_after
@Override
protected void initChannel(SocketChannel channel) throws Exception {
    ChannelPipeline pipeline = channel.pipeline();
    if (sslContext != null) {
        log.info("OVSDB SSL enabled.");
        SSLEngine sslEngine = sslContext.createSSLEngine();
        sslEngine.setNeedClientAuth(true);
        sslEngine.setUseClientMode(false);
        sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());
        sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());
        sslEngine.setEnableSessionCreation(true);
        SslHandler sslHandler = new SslHandler(sslEngine);
        pipeline.addLast("ssl", sslHandler);
    } else {
        log.info("OVSDB SSL disabled.");
    }
    pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
    pipeline.addLast(new MessageDecoder());
    pipeline.addLast(new IdleStateHandler(READER_IDLE_TIME, WRITER_IDLE_TIME, ALL_IDLE_TIME));
    pipeline.addLast(new ReadTimeoutHandler(TIMEOUT));
    controller.handleNewNodeConnection(channel);
}
#end_block

#method_before
private boolean dpdkTunnelBridgeCreated(OpenstackNode osNode) {
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    return client.getBridges().stream().anyMatch(bridge -> bridge.name().equals(TUNNEL_BRIDGE));
}
#method_after
private boolean dpdkTunnelBridgeCreated(OpenstackNode osNode) {
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    if (client == null) {
        log.info("Failed to get ovsdb client");
        return false;
    }
    return client.getBridges().stream().anyMatch(bridge -> bridge.name().equals(TUNNEL_BRIDGE));
}
#end_block

#method_before
private void createBridge(OpenstackNode osNode, String bridgeName, DeviceId deviceId) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.error("Failed to create integration bridge on {}", osNode.ovsdb());
        return;
    }
    List<ControllerInfo> controllers;
    if (osNode.controllers() != null && osNode.controllers().size() > 0) {
        controllers = (List<ControllerInfo>) osNode.controllers();
    } else {
        Set<IpAddress> controllerIps = clusterService.getNodes().stream().map(ControllerNode::ip).collect(Collectors.toSet());
        controllers = controllerIps.stream().map(ip -> new ControllerInfo(ip, DEFAULT_OFPORT, DEFAULT_OF_PROTO)).collect(Collectors.toList());
    }
    String dpid = deviceId.toString().substring(DPID_BEGIN);
    BridgeDescription.Builder builder = DefaultBridgeDescription.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(controllers);
    if (osNode.datapathType().equals(NETDEV)) {
        builder.datapathType(NETDEV.name().toLowerCase());
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addBridge(builder.build());
}
#method_after
private void createBridge(OpenstackNode osNode, String bridgeName, DeviceId deviceId) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    List<ControllerInfo> controllers;
    if (osNode.controllers() != null && osNode.controllers().size() > 0) {
        controllers = (List<ControllerInfo>) osNode.controllers();
    } else {
        Set<IpAddress> controllerIps = clusterService.getNodes().stream().map(ControllerNode::ip).collect(Collectors.toSet());
        controllers = controllerIps.stream().map(ip -> new ControllerInfo(ip, DEFAULT_OFPORT, DEFAULT_OF_PROTO)).collect(Collectors.toList());
    }
    String dpid = deviceId.toString().substring(DPID_BEGIN);
    BridgeDescription.Builder builder = DefaultBridgeDescription.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(controllers);
    if (osNode.datapathType().equals(NETDEV)) {
        builder.datapathType(NETDEV.name().toLowerCase());
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addBridge(builder.build());
}
#end_block

#method_before
private void createDpdkTunnelBridge(OpenstackNode osNode) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.error("Failed to create tunnel bridge on {}", osNode.ovsdb());
        return;
    }
    BridgeDescription.Builder builder = DefaultBridgeDescription.builder().name(TUNNEL_BRIDGE).datapathType(NETDEV.name().toLowerCase());
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addBridge(builder.build());
}
#method_after
private void createDpdkTunnelBridge(OpenstackNode osNode) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    BridgeDescription.Builder builder = DefaultBridgeDescription.builder().name(TUNNEL_BRIDGE).datapathType(NETDEV.name().toLowerCase());
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addBridge(builder.build());
}
#end_block

#method_before
private void addOrRemoveDpdkInterface(OpenstackNode osNode, DpdkInterface dpdkInterface, boolean addOrRemove) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.info("device is null or this device if not ovsdb device");
        return;
    }
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    if (addOrRemove) {
        Map<String, String> options = Maps.newHashMap();
        options.put(DPDK_DEVARGS, dpdkInterface.pciAddress());
        OvsdbInterface.Builder builder = OvsdbInterface.builder().name(dpdkInterface.intf()).type(OvsdbInterface.Type.DPDK).mtu(dpdkInterface.mtu()).options(options);
        client.createInterface(dpdkInterface.deviceName(), builder.build());
    } else {
        client.dropInterface(dpdkInterface.intf());
    }
}
#method_after
private void addOrRemoveDpdkInterface(OpenstackNode osNode, DpdkInterface dpdkInterface, boolean addOrRemove) {
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    if (client == null) {
        log.info("Failed to get ovsdb client");
        return;
    }
    if (addOrRemove) {
        Map<String, String> options = Maps.newHashMap();
        options.put(DPDK_DEVARGS, dpdkInterface.pciAddress());
        OvsdbInterface.Builder builder = OvsdbInterface.builder().name(dpdkInterface.intf()).type(OvsdbInterface.Type.DPDK).mtu(dpdkInterface.mtu()).options(options);
        client.createInterface(dpdkInterface.deviceName(), builder.build());
    } else {
        client.dropInterface(dpdkInterface.intf());
    }
}
#end_block

#method_before
private boolean isCurrentStateDone(OpenstackNode osNode) {
    switch(osNode.state()) {
        case INIT:
            if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
                return false;
            }
            boolean initStateDone = deviceService.isAvailable(osNode.intgBridge());
            if (hasDpdkTunnelBridge(osNode)) {
                initStateDone = initStateDone && dpdkTunnelBridgeCreated(osNode);
            }
            return initStateDone;
        case DEVICE_CREATED:
            if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
                return false;
            }
            if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
                return false;
            }
            if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
                return false;
            }
            if (osNode.type() == GATEWAY && !isIntfEnabled(osNode, osNode.uplinkPort())) {
                return false;
            }
            if (osNode.dpdkConfig() != null && osNode.dpdkConfig().dpdkIntfs() != null) {
                return isDpdkIntfsCreated(osNode, osNode.dpdkConfig().dpdkIntfs());
            }
            for (OpenstackPhyInterface intf : osNode.phyIntfs()) {
                if (intf != null && !isIntfEnabled(osNode, intf.intf())) {
                    return false;
                }
            }
            return true;
        case COMPLETE:
        case INCOMPLETE:
            // run init CLI to re-trigger node bootstrap
            return false;
        default:
            return true;
    }
}
#method_after
private boolean isCurrentStateDone(OpenstackNode osNode) {
    switch(osNode.state()) {
        case INIT:
            if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
                return false;
            }
            boolean initStateDone = deviceService.isAvailable(osNode.intgBridge());
            if (hasDpdkTunnelBridge(osNode)) {
                initStateDone = initStateDone && dpdkTunnelBridgeCreated(osNode);
            }
            return initStateDone;
        case DEVICE_CREATED:
            if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
                return false;
            }
            if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
                return false;
            }
            if (osNode.type() == GATEWAY && !isIntfEnabled(osNode, osNode.uplinkPort())) {
                return false;
            }
            if (osNode.dpdkConfig() != null && osNode.dpdkConfig().dpdkIntfs() != null) {
                return isDpdkIntfsCreated(osNode, osNode.dpdkConfig().dpdkIntfs());
            }
            for (OpenstackPhyInterface intf : osNode.phyIntfs()) {
                if (intf != null && !isIntfEnabled(osNode, intf.intf())) {
                    return false;
                }
            }
            return true;
        case COMPLETE:
        case INCOMPLETE:
            // run init CLI to re-trigger node bootstrap
            return false;
        default:
            return true;
    }
}
#end_block

#method_before
private boolean isDpdkIntfsCreated(OpenstackNode osNode, Collection<DpdkInterface> dpdkInterfaces) {
    for (DpdkInterface dpdkInterface : dpdkInterfaces) {
        if (dpdkInterface.deviceName().equals(INTEGRATION_BRIDGE)) {
            boolean dpdkIntfCreated = deviceService.getPorts(osNode.intgBridge()).stream().anyMatch(port -> port.annotations().value(PORT_NAME).equals(dpdkInterface.intf()));
            if (!dpdkIntfCreated) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean isDpdkIntfsCreated(OpenstackNode osNode, Collection<DpdkInterface> dpdkInterfaces) {
    OvsdbClientService client = getOvsdbClient(osNode, ovsdbPort, ovsdbController);
    if (client == null) {
        log.info("Failed to get ovsdb client");
        return false;
    }
    Set<OvsdbPort> ports = client.getPorts();
    for (DpdkInterface dpdkInterface : dpdkInterfaces) {
        Optional<OvsdbPort> port = ports.stream().filter(ovsdbPort -> ovsdbPort.portName().value().equals(dpdkInterface.intf())).findAny();
        if (!port.isPresent()) {
            return false;
        }
        Interface intf = client.getInterface(dpdkInterface.intf());
        if (intf == null) {
            return false;
        }
        OvsdbSet mtu = (OvsdbSet) intf.getMtuColumn().data();
        if (mtu == null) {
            return false;
        }
        OvsdbMap option = (OvsdbMap) intf.getOptionsColumn().data();
        if (option == null) {
            return false;
        }
        if (!mtu.set().contains(dpdkInterface.mtu().intValue()) || !option.toString().contains(dpdkInterface.pciAddress())) {
            log.trace("The dpdk interface {} was created but mtu or pci address is different from the config.");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public Set<OvsdbPort> getPorts() {
    OvsdbTableStore tableStore = getTableStore(DATABASENAME);
    if (tableStore == null) {
        return null;
    }
    OvsdbRowStore rowStore = tableStore.getRows(INTERFACE);
    if (rowStore == null) {
        return null;
    }
    ConcurrentMap<String, Row> rows = rowStore.getRowStore();
    return rows.keySet().stream().map(uuid -> getRow(DATABASENAME, INTERFACE, uuid)).map(this::getOvsdbPort).filter(Objects::nonNull).collect(Collectors.toSet());
}
#method_after
@Override
public Set<OvsdbPort> getPorts() {
    return (Set<OvsdbPort>) getElements(this::getOvsdbPort);
}
#end_block

#method_before
@Override
public Set<Interface> getInterfaces() {
    OvsdbTableStore tableStore = getTableStore(DATABASENAME);
    if (tableStore == null) {
        return null;
    }
    OvsdbRowStore rowStore = tableStore.getRows(INTERFACE);
    if (rowStore == null) {
        return null;
    }
    ConcurrentMap<String, Row> rows = rowStore.getRowStore();
    return rows.keySet().stream().map(uuid -> getRow(DATABASENAME, INTERFACE, uuid)).map(this::getInterface).filter(Objects::nonNull).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Interface> getInterfaces() {
    return (Set<Interface>) getElements(this::getInterface);
}
#end_block

#method_before
@Override
public Collection<DpdkInterface> dpdkIntfs() {
    if (dpdkIntfs == null) {
        return new ArrayList<>();
    }
    return dpdkIntfs;
}
#method_after
@Override
public Collection<DpdkInterface> dpdkIntfs() {
    if (dpdkIntfs == null) {
        return new ArrayList<>();
    }
    return ImmutableList.copyOf(dpdkIntfs);
}
#end_block

#method_before
public DpdkInterface build() {
    checkArgument(deviceName != null, NOT_NULL_MSG, "deviceName");
    checkArgument(intf != null, NOT_NULL_MSG, "intf");
    checkArgument(pciAddress != null, NOT_NULL_MSG, "pciAddress");
    checkArgument(type != null, NOT_NULL_MSG, "type");
    return new DefaultDpdkInterface(deviceName, intf, pciAddress, type, mtu);
}
#method_after
@Override
public DpdkInterface build() {
    checkArgument(deviceName != null, NOT_NULL_MSG, "deviceName");
    checkArgument(intf != null, NOT_NULL_MSG, "intf");
    checkArgument(pciAddress != null, NOT_NULL_MSG, "pciAddress");
    checkArgument(type != null, NOT_NULL_MSG, "type");
    return new DefaultDpdkInterface(deviceName, intf, pciAddress, type, mtu);
}
#end_block

#method_before
@Test
public void testOpenstackDpdkComputeNodeDecode() throws IOException {
    OpenstackNode node = getOpenstackNode("OpenstackDpdkComputeNode.json");
    assertThat(node.datapathType(), is(DpdkConfig.DatapathType.NETDEV));
    assertThat(node.socketDir(), is("/var/lib/libvirt/qemu"));
    assertThat(node.dpdkConfig().dpdkIntfs().size(), is(2));
}
#method_after
@Test
public void testOpenstackDpdkComputeNodeDecode() throws IOException {
    OpenstackNode node = getOpenstackNode("OpenstackDpdkComputeNode.json");
    assertEquals(node.datapathType(), DpdkConfig.DatapathType.NETDEV);
    assertEquals(node.socketDir(), "/var/lib/libvirt/qemu");
    assertEquals(node.dpdkConfig().dpdkIntfs().size(), 2);
}
#end_block

#method_before
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // Set of truly-removed rules to be reported
    Set<FlowRule> removedRules = Sets.<FlowRule>newConcurrentHashSet();
    List<FlowRule> ruleList = (List) rules;
    int ruleCount = rules.size();
    int ruleStart = 0;
    int processed = 0;
    int batchNb = 1;
    while (processed < ruleCount) {
        String ruleIds = "";
        for (int i = ruleStart; i < ruleCount; i++) {
            // Batch completed
            if (i >= (batchNb * RULE_DELETE_BATCH_SIZE)) {
                break;
            }
            // Create a comma-separated sequence of rule IDs
            ruleIds += Long.toString(ruleList.get(i).id().value()) + ",";
            processed++;
        }
        // Remove last comma
        ruleIds = ruleIds.substring(0, ruleIds.length() - 1);
        // Remove the entire batch of rules at once
        if (removeNicFlowRuleBatch(deviceId, ruleIds)) {
            removedRules.addAll(ruleList.subList(ruleStart, processed));
        }
        // Prepare for the next batch (if any)
        batchNb++;
        ruleStart += RULE_DELETE_BATCH_SIZE;
    }
    return removedRules;
}
#method_after
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    int ruleDeleteBatchSize = getRuleDeleteBatchSizeProperty(deviceId);
    // Set of truly-removed rules to be reported
    Set<FlowRule> removedRules = Sets.<FlowRule>newConcurrentHashSet();
    List<FlowRule> ruleList = (List) rules;
    int ruleCount = rules.size();
    int ruleStart = 0;
    int processed = 0;
    int batchNb = 1;
    while (processed < ruleCount) {
        String ruleIds = "";
        for (int i = ruleStart; i < ruleCount; i++) {
            // Batch completed
            if (i >= (batchNb * ruleDeleteBatchSize)) {
                break;
            }
            // TODO: Turn this string into a list and modify removeNicFlowRuleBatch()
            // Create a comma-separated sequence of rule IDs
            ruleIds += Long.toString(ruleList.get(i).id().value()) + ",";
            processed++;
        }
        // Remove last comma
        ruleIds = ruleIds.substring(0, ruleIds.length() - 1);
        // Remove the entire batch of rules at once
        if (removeNicFlowRuleBatch(deviceId, ruleIds)) {
            removedRules.addAll(ruleList.subList(ruleStart, processed));
        }
        // Prepare for the next batch (if any)
        batchNb++;
        ruleStart += ruleDeleteBatchSize;
    }
    return removedRules;
}
#end_block

#method_before
@Override
public void performGroupOperation(DeviceId deviceId, GroupOperations groupOps) {
    if (!setupBehaviour()) {
        return;
    }
    groupOps.operations().forEach(op -> {
        // We need app cookie (action profile id) from the group
        Group groupOnStore = groupStore.getGroup(deviceId, op.groupId());
        GroupDescription groupDesc = new DefaultGroupDescription(deviceId, op.groupType(), op.buckets(), groupOnStore.appCookie(), op.groupId().id(), groupOnStore.appId());
        DefaultGroup groupToApply = new DefaultGroup(op.groupId(), groupDesc);
        if (op.groupType().equals(GroupDescription.Type.ALL)) {
            processMcGroupOp(deviceId, groupToApply, op.opType());
        } else {
            processGroupOp(deviceId, groupToApply, op.opType());
        }
    });
}
#method_after
@Override
public void performGroupOperation(DeviceId deviceId, GroupOperations groupOps) {
    if (!setupBehaviour()) {
        return;
    }
    groupOps.operations().forEach(op -> {
        // ONOS-7785 We need app cookie (action profile id) from the group
        Group groupOnStore = groupStore.getGroup(deviceId, op.groupId());
        GroupDescription groupDesc = new DefaultGroupDescription(deviceId, op.groupType(), op.buckets(), groupOnStore.appCookie(), op.groupId().id(), groupOnStore.appId());
        DefaultGroup groupToApply = new DefaultGroup(op.groupId(), groupDesc);
        if (op.groupType().equals(GroupDescription.Type.ALL)) {
            processMcGroupOp(deviceId, groupToApply, op.opType());
        } else {
            processGroupOp(deviceId, groupToApply, op.opType());
        }
    });
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).omitNullValues().add("device", deviceId).add("id", id()).add("load", load()).add("isBusy", busy()).add("throughputUnit", throughputUnit.orElse(null)).add("averageThroughput", averageThroughput.orElse(null)).add("latencyUnit", latencyUnit.orElse(null)).add("minLatency", minLatency.orElse(null)).add("medianLatency", medianLatency.orElse(null)).add("maxLatency", maxLatency.orElse(null)).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).omitNullValues().add("device", deviceId).add("id", id()).add("load", load()).add("queue", queue()).add("isBusy", busy()).add("throughputUnit", throughputUnit.orElse(null)).add("averageThroughput", averageThroughput.orElse(null)).add("latencyUnit", latencyUnit.orElse(null)).add("minLatency", minLatency.orElse(null)).add("medianLatency", medianLatency.orElse(null)).add("maxLatency", maxLatency.orElse(null)).toString();
}
#end_block

#method_before
public DefaultCpuStatistics build() {
    return new DefaultCpuStatistics(deviceId, id, load, isBusy, throughputUnit, averageThroughput, latencyUnit, minLatency, medianLatency, maxLatency);
}
#method_after
public DefaultCpuStatistics build() {
    return new DefaultCpuStatistics(deviceId, id, load, queue, isBusy, throughputUnit, averageThroughput, latencyUnit, minLatency, medianLatency, maxLatency);
}
#end_block

#method_before
private DeviceDescription getDeviceDetails(DeviceId deviceId) {
    // Create a description for this server device
    ServerDeviceDescription desc = null;
    // Retrieve the device ID, if null given
    if (deviceId == null) {
        deviceId = getHandler().data().deviceId();
        checkNotNull(deviceId, DEVICE_ID_NULL);
    }
    // Get the device
    RestSBDevice device = getController().getDevice(deviceId);
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, RESOURCE_DISCOVERY_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    if (jsonMap == null) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Get all the attributes
    String id = get(jsonNode, BasicServerDriver.PARAM_ID);
    String vendor = get(jsonNode, PARAM_MANUFACTURER);
    String hw = get(jsonNode, PARAM_HW_VENDOR);
    String sw = get(jsonNode, PARAM_SW_VENDOR);
    String serial = get(jsonNode, PARAM_SERIAL);
    // CPUs are composite attributes
    Set<CpuDevice> cpuSet = new HashSet<CpuDevice>();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    // Construct CPU objects
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // All the CPU attributes
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        String cpuVendorStr = get(cn, CPU_PARAM_VENDOR);
        long cpuFrequency = cpuObjNode.path(CPU_PARAM_FREQUENCY).asLong();
        // Verify that this is a valid vendor
        CpuVendor cpuVendor = CpuVendor.getByName(cpuVendorStr);
        checkNotNull(cpuVendor, CPU_VENDOR_NULL);
        // Construct a CPU device
        CpuDevice cpu = new DefaultCpuDevice(cpuId, cpuVendor, cpuFrequency);
        // Add it to the set
        cpuSet.add(cpu);
    }
    // NICs are composite attributes too
    Set<NicDevice> nicSet = new HashSet<NicDevice>();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
    // Construct NIC objects
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        long nicIndex = nicObjNode.path(NIC_PARAM_PORT_INDEX).asLong();
        long speed = nicObjNode.path(NIC_PARAM_SPEED).asLong();
        String portTypeStr = get(nn, NIC_PARAM_PORT_TYPE);
        Port.Type portType = PORT_TYPE_MAP.get(portTypeStr);
        if (portType == null) {
            throw new IllegalArgumentException(portTypeStr + " is not a valid port type for NIC " + nicName);
        }
        boolean status = nicObjNode.path(NIC_PARAM_STATUS).asInt() > 0;
        String hwAddr = get(nn, NIC_PARAM_HW_ADDR);
        JsonNode tagNode = nicObjNode.path(BasicServerDriver.NIC_PARAM_RX_FILTER);
        if (tagNode == null) {
            throw new IllegalArgumentException("The Rx filters of NIC " + nicName + " are not reported");
        }
        // Convert the JSON list into an array of strings
        List<String> rxFilters = null;
        try {
            rxFilters = mapper.readValue(tagNode.traverse(), new TypeReference<ArrayList<String>>() {
            });
        } catch (IOException ioEx) {
            continue;
        }
        // Parse the array of strings and create an RxFilter object
        NicRxFilter rxFilterMechanism = new NicRxFilter();
        for (String s : rxFilters) {
            // Verify that this is a valid Rx filter
            RxFilter rf = RxFilter.getByName(s);
            checkNotNull(rf, NIC_RX_FILTER_NULL);
            rxFilterMechanism.addRxFilter(rf);
        }
        // Store NIC name to number mapping as an annotation
        annotations.set(nicName, Long.toString(nicIndex));
        // Construct a NIC device for this server
        NicDevice nic = new DefaultNicDevice(nicName, nicIndex, portType, speed, status, hwAddr, rxFilterMechanism);
        // Add it to the set
        nicSet.add(nic);
    }
    // Construct a complete server device object.
    // Lists of NICs and CPUs extend the information
    // already in RestSBDevice (parent class).
    RestServerSBDevice dev = new DefaultRestServerSBDevice(device.ip(), device.port(), device.username(), device.password(), device.protocol(), device.url(), device.isActive(), device.testUrl().toString(), vendor, hw, sw, AuthenticationScheme.BASIC, "", cpuSet, nicSet);
    checkNotNull(dev, DEVICE_NULL);
    // Updates the controller with the complete device information
    getController().removeDevice(deviceId);
    getController().addDevice((RestSBDevice) dev);
    try {
        desc = new DefaultServerDeviceDescription(new URI(id), Device.Type.SERVER, vendor, hw, sw, serial, new ChassisId(), cpuSet, nicSet, annotations.build());
    } catch (URISyntaxException uEx) {
        log.error("Failed to create a server device description for: {}", deviceId);
        return null;
    }
    log.info("Device's {} details sent to the controller", deviceId);
    return desc;
}
#method_after
private DeviceDescription getDeviceDetails(DeviceId deviceId) {
    // Retrieve the device ID, if null given
    if (deviceId == null) {
        deviceId = getHandler().data().deviceId();
        checkNotNull(deviceId, DEVICE_ID_NULL);
    }
    // Get the device
    RestSBDevice device = getController().getDevice(deviceId);
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, RESOURCE_DISCOVERY_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return null;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return null;
    }
    if (jsonMap == null) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return null;
    }
    // Get all the attributes
    String id = get(jsonNode, BasicServerDriver.PARAM_ID);
    String vendor = get(jsonNode, PARAM_MANUFACTURER);
    String hw = get(jsonNode, PARAM_HW_VENDOR);
    String sw = get(jsonNode, PARAM_SW_VENDOR);
    String serial = get(jsonNode, PARAM_SERIAL);
    // CPUs are composite attributes
    Set<CpuDevice> cpuSet = new HashSet<CpuDevice>();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    // Construct CPU objects
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // All the CPU attributes
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        String cpuVendorStr = get(cn, CPU_PARAM_VENDOR);
        long cpuFrequency = cpuObjNode.path(CPU_PARAM_FREQUENCY).asLong();
        // Verify that this is a valid vendor
        CpuVendor cpuVendor = CpuVendor.getByName(cpuVendorStr);
        checkNotNull(cpuVendor, CPU_VENDOR_NULL);
        // Construct a CPU device
        CpuDevice cpu = new DefaultCpuDevice(cpuId, cpuVendor, cpuFrequency);
        // Add it to the set
        cpuSet.add(cpu);
    }
    // NICs are composite attributes too
    Set<NicDevice> nicSet = new HashSet<NicDevice>();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
    // Construct NIC objects
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        long nicIndex = nicObjNode.path(NIC_PARAM_PORT_INDEX).asLong();
        long speed = nicObjNode.path(NIC_PARAM_SPEED).asLong();
        String portTypeStr = get(nn, NIC_PARAM_PORT_TYPE);
        Port.Type portType = PORT_TYPE_MAP.get(portTypeStr);
        if (portType == null) {
            throw new IllegalArgumentException(portTypeStr + " is not a valid port type for NIC " + nicName);
        }
        boolean status = nicObjNode.path(NIC_PARAM_STATUS).asInt() > 0;
        String hwAddr = get(nn, NIC_PARAM_HW_ADDR);
        JsonNode tagNode = nicObjNode.path(BasicServerDriver.NIC_PARAM_RX_FILTER);
        if (tagNode == null) {
            throw new IllegalArgumentException("The Rx filters of NIC " + nicName + " are not reported");
        }
        // Convert the JSON list into an array of strings
        List<String> rxFilters = null;
        try {
            rxFilters = mapper.readValue(tagNode.traverse(), new TypeReference<ArrayList<String>>() {
            });
        } catch (IOException ioEx) {
            continue;
        }
        // Parse the array of strings and create an RxFilter object
        NicRxFilter rxFilterMechanism = new NicRxFilter();
        for (String s : rxFilters) {
            // Verify that this is a valid Rx filter
            RxFilter rf = RxFilter.getByName(s);
            checkNotNull(rf, NIC_RX_FILTER_NULL);
            rxFilterMechanism.addRxFilter(rf);
        }
        // Store NIC name to number mapping as an annotation
        annotations.set(nicName, Long.toString(nicIndex));
        // Construct a NIC device for this server
        NicDevice nic = new DefaultNicDevice(nicName, nicIndex, portType, speed, status, hwAddr, rxFilterMechanism);
        // Add it to the set
        nicSet.add(nic);
    }
    // Construct a complete server device object.
    // Lists of NICs and CPUs extend the information
    // already in RestSBDevice (parent class).
    RestServerSBDevice dev = new DefaultRestServerSBDevice(device.ip(), device.port(), device.username(), device.password(), device.protocol(), device.url(), device.isActive(), device.testUrl().toString(), vendor, hw, sw, AuthenticationScheme.BASIC, "", cpuSet, nicSet);
    checkNotNull(dev, DEVICE_NULL);
    // Set alive
    raiseDeviceReconnect(dev);
    // Updates the controller with the complete device information
    getController().removeDevice(deviceId);
    getController().addDevice((RestSBDevice) dev);
    // Create a description for this server device
    ServerDeviceDescription desc = null;
    try {
        desc = new DefaultServerDeviceDescription(new URI(id), Device.Type.SERVER, vendor, hw, sw, serial, new ChassisId(), cpuSet, nicSet, annotations.build());
    } catch (URISyntaxException uEx) {
        log.error("Failed to create a server device description for: {}", deviceId);
        return null;
    }
    log.info("Device's {} details sent to the controller", deviceId);
    return desc;
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    // List of port descriptions to return
    List<PortDescription> portDescriptions = Lists.newArrayList();
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // .. and object
    RestServerSBDevice device = null;
    // In case this method is called before discoverDeviceDetails,
    // there is missing information to be gathered.
    short i = 0;
    while ((device == null) && (i < DISCOVERY_RETRIES)) {
        i++;
        try {
            device = (RestServerSBDevice) getController().getDevice(deviceId);
        } catch (ClassCastException ccEx) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException intEx) {
                // Just retry
                continue;
            }
        }
        // No device
        if (device == null) {
            // This method will add the device to the RestSBController
            this.getDeviceDetails(deviceId);
        }
    }
    if ((device == null) || (device.nics() == null)) {
        log.error("No ports available on {}", deviceId);
        return Collections.EMPTY_LIST;
    }
    // Sorted list of NIC ports
    Set<NicDevice> nics = new TreeSet(device.nics());
    // Iterate through the NICs of this device to populate the list
    for (NicDevice nic : nics) {
        // Include the name of this device as an annotation
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, nic.name());
        // Create a port description and add it to the list
        portDescriptions.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(nic.portNumber(), nic.name())).isEnabled(nic.status()).type(nic.portType()).portSpeed(nic.speed()).annotations(annotations.build()).build());
        log.info("Port discovery on device {}: NIC {} is {} at {} Mbps", deviceId, nic.portNumber(), nic.status() ? "up" : "down", nic.speed());
    }
    return ImmutableList.copyOf(portDescriptions);
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // .. and object
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to discover ports for device {}", deviceId);
        return Collections.EMPTY_LIST;
    }
    if (device == null) {
        log.error("No device with ID {} is available for port discovery", deviceId);
        return Collections.EMPTY_LIST;
    }
    if ((device.nics() == null) || (device.nics().size() == 0)) {
        log.error("No ports available on {}", deviceId);
        return Collections.EMPTY_LIST;
    }
    // List of port descriptions to return
    List<PortDescription> portDescriptions = Lists.newArrayList();
    // Sorted list of NIC ports
    Set<NicDevice> nics = new TreeSet(device.nics());
    // Iterate through the NICs of this device to populate the list
    for (NicDevice nic : nics) {
        // Include the name of this device as an annotation
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, nic.name());
        // Create a port description and add it to the list
        portDescriptions.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(nic.portNumber(), nic.name())).isEnabled(nic.status()).type(nic.portType()).portSpeed(nic.speed()).annotations(annotations.build()).build());
        log.info("Port discovery on device {}: NIC {} is {} at {} Mbps", deviceId, nic.portNumber(), nic.status() ? "up" : "down", nic.speed());
    }
    return ImmutableList.copyOf(portDescriptions);
}
#end_block

#method_before
public MonitoringStatistics getGlobalMonitoringStatistics(DeviceId deviceId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's global resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, GLOBAL_STATS_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        JsonNode jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Get high-level CPU statistics
    int busyCpus = objNode.path(MON_PARAM_BUSY_CPUS).asInt();
    int freeCpus = objNode.path(MON_PARAM_FREE_CPUS).asInt();
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get zero timing statistics
    TimingStatistics timinsgStats = getZeroTimingStatistics();
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats);
    monStats = statsBuilder.build();
    log.debug("Global monitoring statistics: {}", monStats.toString());
    return monStats;
}
#method_after
public MonitoringStatistics getGlobalMonitoringStatistics(DeviceId deviceId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if ((device == null) || (!device.isActive())) {
        return monStats;
    }
    // Hit the path that provides the server's global resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, GLOBAL_STATS_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        JsonNode jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Get high-level CPU statistics
    int busyCpus = objNode.path(MON_PARAM_BUSY_CPUS).asInt();
    int freeCpus = objNode.path(MON_PARAM_FREE_CPUS).asInt();
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get zero timing statistics
    TimingStatistics timinsgStats = getZeroTimingStatistics();
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats);
    monStats = statsBuilder.build();
    // When a device reports monitoring data, it means it is alive
    raiseDeviceReconnect(device);
    log.debug("Global monitoring statistics: {}", monStats.toString());
    return monStats;
}
#end_block

#method_before
private MonitoringStatistics getMonitoringStatistics(DeviceId deviceId, URI tcId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    checkNotNull(device, DEVICE_NULL);
    // Create a resource-specific URL
    String scUrl = SERVICE_CHAINS_STATS_URL + "/" + tcId.toString();
    // Hit the path that provides the server's specific resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, scUrl, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Get the ID of the traffic class
    String id = get(jsonNode, PARAM_ID);
    // And verify that this is the traffic class we want to monitor
    if (!id.equals(tcId.toString())) {
        throw new IllegalStateException("Failed to retrieve monitoring data for traffic class " + tcId + ". Traffic class ID does not agree.");
    }
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get timing statistics
    TimingStatistics timinsgStats = parseTimingStatistics(objNode);
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats);
    monStats = statsBuilder.build();
    log.debug("Monitoring statistics: {}", monStats.toString());
    return monStats;
}
#method_after
private MonitoringStatistics getMonitoringStatistics(DeviceId deviceId, URI tcId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (device == null) {
        return monStats;
    }
    // Create a resource-specific URL
    String scUrl = SERVICE_CHAINS_STATS_URL + SLASH + tcId.toString();
    // Hit the path that provides the server's specific resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, scUrl, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Get the ID of the traffic class
    String id = get(jsonNode, PARAM_ID);
    // And verify that this is the traffic class we want to monitor
    if (!id.equals(tcId.toString())) {
        throw new IllegalStateException("Failed to retrieve monitoring data for traffic class " + tcId + ". Traffic class ID does not agree.");
    }
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get timing statistics
    TimingStatistics timinsgStats = parseTimingStatistics(objNode);
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats);
    monStats = statsBuilder.build();
    // When a device reports monitoring data, it means it is alive
    raiseDeviceReconnect(device);
    log.debug("Monitoring statistics: {}", monStats.toString());
    return monStats;
}
#end_block

#method_before
private Collection<CpuStatistics> parseCpuStatistics(DeviceId deviceId, JsonNode objNode) {
    if (objNode == null) {
        return Collections.EMPTY_LIST;
    }
    Collection<CpuStatistics> cpuStats = Lists.newArrayList();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // CPU statistics builder
        DefaultCpuStatistics.Builder cpuBuilder = DefaultCpuStatistics.builder();
        // Throughput statistics are optional
        JsonNode throughputNode = cpuObjNode.get(CPU_PARAM_THROUGHPUT);
        if (throughputNode != null) {
            String throughputUnit = get(throughputNode, MON_PARAM_UNIT);
            float averageThroughput = throughputNode.path(MON_PARAM_AVERAGE).floatValue();
            cpuBuilder.setThroughputUnit(throughputUnit).setAverageThroughput(averageThroughput);
        }
        // Latency statistics are optional
        JsonNode latencyNode = cpuObjNode.get(CPU_PARAM_LATENCY);
        if (latencyNode != null) {
            String latencyUnit = get(latencyNode, MON_PARAM_UNIT);
            float minLatency = latencyNode.path(MON_PARAM_MIN).floatValue();
            float medianLatency = latencyNode.path(MON_PARAM_MEDIAN).floatValue();
            float maxLatency = latencyNode.path(MON_PARAM_MAX).floatValue();
            cpuBuilder.setLatencyUnit(latencyUnit).setMinLatency(minLatency).setMedianLatency(medianLatency).setMaxLatency(maxLatency);
        }
        // CPU ID with its load and status
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        float cpuLoad = cpuObjNode.path(CPU_PARAM_LOAD).floatValue();
        boolean isBusy = cpuObjNode.path(CPU_PARAM_STATUS).booleanValue();
        // This is mandatory information
        cpuBuilder.setDeviceId(deviceId).setId(cpuId).setLoad(cpuLoad).setIsBusy(isBusy);
        // We have all the statistics for this CPU core
        cpuStats.add(cpuBuilder.build());
    }
    return cpuStats;
}
#method_after
private Collection<CpuStatistics> parseCpuStatistics(DeviceId deviceId, JsonNode objNode) {
    if ((deviceId == null) || (objNode == null)) {
        return Collections.EMPTY_LIST;
    }
    Collection<CpuStatistics> cpuStats = Lists.newArrayList();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // CPU statistics builder
        DefaultCpuStatistics.Builder cpuBuilder = DefaultCpuStatistics.builder();
        // Throughput statistics are optional
        JsonNode throughputNode = cpuObjNode.get(CPU_PARAM_THROUGHPUT);
        if (throughputNode != null) {
            String throughputUnit = get(throughputNode, MON_PARAM_UNIT);
            if (!Strings.isNullOrEmpty(throughputUnit)) {
                cpuBuilder.setThroughputUnit(throughputUnit);
            }
            float averageThroughput = (float) 0;
            if (throughputNode.get(MON_PARAM_AVERAGE) != null) {
                averageThroughput = throughputNode.path(MON_PARAM_AVERAGE).floatValue();
            }
            cpuBuilder.setAverageThroughput(averageThroughput);
        }
        // Latency statistics are optional
        JsonNode latencyNode = cpuObjNode.get(CPU_PARAM_LATENCY);
        if (latencyNode != null) {
            String latencyUnit = get(latencyNode, MON_PARAM_UNIT);
            if (!Strings.isNullOrEmpty(latencyUnit)) {
                cpuBuilder.setLatencyUnit(latencyUnit);
            }
            float minLatency = (float) 0;
            if (latencyNode.get(MON_PARAM_MIN) != null) {
                minLatency = latencyNode.path(MON_PARAM_MIN).floatValue();
            }
            float medianLatency = (float) 0;
            if (latencyNode.get(MON_PARAM_MEDIAN) != null) {
                medianLatency = latencyNode.path(MON_PARAM_MEDIAN).floatValue();
            }
            float maxLatency = (float) 0;
            if (latencyNode.get(MON_PARAM_MAX) != null) {
                maxLatency = latencyNode.path(MON_PARAM_MAX).floatValue();
            }
            cpuBuilder.setMinLatency(minLatency).setMedianLatency(medianLatency).setMaxLatency(maxLatency);
        }
        // CPU ID with its load and status
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        float cpuLoad = cpuObjNode.path(CPU_PARAM_LOAD).floatValue();
        int queueId = cpuObjNode.path(CPU_PARAM_QUEUE).asInt();
        boolean isBusy = cpuObjNode.path(CPU_PARAM_STATUS).booleanValue();
        // This is mandatory information
        cpuBuilder.setDeviceId(deviceId).setId(cpuId).setLoad(cpuLoad).setQueue(queueId).setIsBusy(isBusy);
        // We have all the statistics for this CPU core
        cpuStats.add(cpuBuilder.build());
    }
    return cpuStats;
}
#end_block

#method_before
private Collection<PortStatistics> parseNicStatistics(DeviceId deviceId, JsonNode objNode) {
    if (objNode == null) {
        return Collections.EMPTY_LIST;
    }
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        return Collections.EMPTY_LIST;
    }
    checkNotNull(device, DEVICE_NULL);
    Collection<PortStatistics> nicStats = Lists.newArrayList();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        checkArgument(!Strings.isNullOrEmpty(nicName), "NIC name is empty or NULL");
        long portNumber = device.portNumberFromName(nicName);
        checkArgument(portNumber >= 0, "Unknown port ID " + portNumber + " for NIC " + nicName);
        long rxCount = nicObjNode.path(NIC_STATS_RX_COUNT).asLong();
        long rxBytes = nicObjNode.path(NIC_STATS_RX_BYTES).asLong();
        long rxDropped = nicObjNode.path(NIC_STATS_RX_DROPS).asLong();
        long rxErrors = nicObjNode.path(NIC_STATS_RX_ERRORS).asLong();
        long txCount = nicObjNode.path(NIC_STATS_TX_COUNT).asLong();
        long txBytes = nicObjNode.path(NIC_STATS_TX_BYTES).asLong();
        long txDropped = nicObjNode.path(NIC_STATS_TX_DROPS).asLong();
        long txErrors = nicObjNode.path(NIC_STATS_TX_ERRORS).asLong();
        // Incorporate these statistics into an object
        DefaultPortStatistics.Builder nicBuilder = DefaultPortStatistics.builder();
        nicBuilder.setDeviceId(deviceId).setPort((int) portNumber).setPacketsReceived(rxCount).setPacketsSent(txCount).setBytesReceived(rxBytes).setBytesSent(txBytes).setPacketsRxDropped(rxDropped).setPacketsRxErrors(rxErrors).setPacketsTxDropped(txDropped).setPacketsTxErrors(txErrors);
        // We have statistics for this NIC
        nicStats.add(nicBuilder.build());
    }
    return nicStats;
}
#method_after
private Collection<PortStatistics> parseNicStatistics(DeviceId deviceId, JsonNode objNode) {
    if ((deviceId == null) || (objNode == null)) {
        return Collections.EMPTY_LIST;
    }
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        return Collections.EMPTY_LIST;
    }
    if (device == null) {
        return Collections.EMPTY_LIST;
    }
    Collection<PortStatistics> nicStats = Lists.newArrayList();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        checkArgument(!Strings.isNullOrEmpty(nicName), "NIC name is empty or NULL");
        long portNumber = device.portNumberFromName(nicName);
        checkArgument(portNumber >= 0, "Unknown port ID " + portNumber + " for NIC " + nicName);
        long rxCount = nicObjNode.path(NIC_STATS_RX_COUNT).asLong();
        long rxBytes = nicObjNode.path(NIC_STATS_RX_BYTES).asLong();
        long rxDropped = nicObjNode.path(NIC_STATS_RX_DROPS).asLong();
        long rxErrors = nicObjNode.path(NIC_STATS_RX_ERRORS).asLong();
        long txCount = nicObjNode.path(NIC_STATS_TX_COUNT).asLong();
        long txBytes = nicObjNode.path(NIC_STATS_TX_BYTES).asLong();
        long txDropped = nicObjNode.path(NIC_STATS_TX_DROPS).asLong();
        long txErrors = nicObjNode.path(NIC_STATS_TX_ERRORS).asLong();
        // Incorporate these statistics into an object
        DefaultPortStatistics.Builder nicBuilder = DefaultPortStatistics.builder();
        nicBuilder.setDeviceId(deviceId).setPort((int) portNumber).setPacketsReceived(rxCount).setPacketsSent(txCount).setBytesReceived(rxBytes).setBytesSent(txBytes).setPacketsRxDropped(rxDropped).setPacketsRxErrors(rxErrors).setPacketsTxDropped(txDropped).setPacketsTxErrors(txErrors);
        // We have statistics for this NIC
        nicStats.add(nicBuilder.build());
    }
    return nicStats;
}
#end_block

#method_before
private TimingStatistics parseTimingStatistics(JsonNode objNode) {
    TimingStatistics timinsgStats = null;
    if (objNode == null) {
        return timinsgStats;
    }
    // Get timing statistics
    JsonNode timingNode = objNode.path(PARAM_TIMING_STATS);
    ObjectNode timingObjNode = (ObjectNode) timingNode;
    // The unit of timing statistics
    String timingStatsUnit = get(timingNode, MON_PARAM_UNIT);
    // Time (ns) to parse the controller's deployment instruction
    long parsingTime = timingObjNode.path(TIMING_PARAM_PARSE).asLong();
    // Time (ns) to do the deployment
    long launchingTime = timingObjNode.path(TIMING_PARAM_LAUNCH).asLong();
    // Deployment time (ns) equals to time to parse + time to launch
    long deplTime = timingObjNode.path(TIMING_PARAM_TOTAL).asLong();
    checkArgument(deplTime == parsingTime + launchingTime, "Inconsistent timing statistics");
    // Get autoscale timing statistics
    JsonNode autoscaleTimingNode = objNode.path(PARAM_TIMING_AUTOSCALE);
    ObjectNode autoscaleTimingObjNode = (ObjectNode) autoscaleTimingNode;
    // Time (ns) to autoscale a server's load
    long autoscaleTime = autoscaleTimingObjNode.path(TIMING_PARAM_AUTOSCALE).asLong();
    DefaultTimingStatistics.Builder timingBuilder = DefaultTimingStatistics.builder();
    timingBuilder.setUnit(timingStatsUnit).setParsingTime(parsingTime).setLaunchingTime(launchingTime).setAutoscaleTime(autoscaleTime);
    return timingBuilder.build();
}
#method_after
private TimingStatistics parseTimingStatistics(JsonNode objNode) {
    TimingStatistics timinsgStats = null;
    if (objNode == null) {
        return timinsgStats;
    }
    // If no timing statistics are present, then send zeros
    if (objNode.get(PARAM_TIMING_STATS) == null) {
        return getZeroTimingStatistics();
    }
    DefaultTimingStatistics.Builder timingBuilder = DefaultTimingStatistics.builder();
    // Get timing statistics
    JsonNode timingNode = objNode.path(PARAM_TIMING_STATS);
    ObjectNode timingObjNode = (ObjectNode) timingNode;
    // The unit of timing statistics
    String timingStatsUnit = get(timingNode, MON_PARAM_UNIT);
    if (!Strings.isNullOrEmpty(timingStatsUnit)) {
        timingBuilder.setUnit(timingStatsUnit);
    }
    // Time (ns) to parse the controller's deployment instruction
    long parsingTime = 0;
    if (timingObjNode.get(TIMING_PARAM_PARSE) != null) {
        parsingTime = timingObjNode.path(TIMING_PARAM_PARSE).asLong();
    }
    // Time (ns) to do the deployment
    long launchingTime = 0;
    if (timingObjNode.get(TIMING_PARAM_LAUNCH) != null) {
        launchingTime = timingObjNode.path(TIMING_PARAM_LAUNCH).asLong();
    }
    // Deployment time (ns) equals to time to parse + time to launch
    long deployTime = 0;
    if (timingObjNode.get(TIMING_PARAM_DEPLOY) != null) {
        deployTime = timingObjNode.path(TIMING_PARAM_DEPLOY).asLong();
    }
    checkArgument(deployTime == parsingTime + launchingTime, "Inconsistent timing statistics");
    timingBuilder.setParsingTime(parsingTime).setLaunchingTime(launchingTime);
    // Get autoscale timing statistics
    JsonNode autoscaleTimingNode = objNode.path(PARAM_TIMING_AUTOSCALE);
    if (autoscaleTimingNode == null) {
        return timingBuilder.build();
    }
    ObjectNode autoscaleTimingObjNode = (ObjectNode) autoscaleTimingNode;
    // Time (ns) to autoscale a server's load
    long autoscaleTime = 0;
    if (autoscaleTimingObjNode.get(TIMING_PARAM_AUTOSCALE) != null) {
        autoscaleTimingObjNode.path(TIMING_PARAM_AUTOSCALE).asLong();
    }
    timingBuilder.setAutoscaleTime(autoscaleTime);
    return timingBuilder.build();
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId did = data().deviceId();
    NetconfSession ns = Optional.ofNullable(handler().get(NetconfController.class)).map(c -> c.getNetconfDevice(did)).map(NetconfDevice::getSession).orElseThrow(() -> new IllegalStateException("No NetconfSession found for " + did));
    String hwVersion = "1830", swVersion = "OpenAgent";
    if (loginToDevice(handler().data().deviceId(), USER_NAME, PASSWORD)) {
        // log.info("logged into device {}", handler().data().deviceId());
        log.info("Discovering device details {}", handler().data().deviceId());
        try {
            String reply = ns.requestSync(buildGetSystemSoftwareRpc());
            XMLConfiguration cfg = (XMLConfiguration) XmlConfigParser.loadXmlString(getDataOfRpcReply(reply));
            hwVersion = cfg.getString("components.component.state.description");
            swVersion = cfg.getString("components.component.state.version");
        } catch (NetconfException e) {
            log.error("Error discovering device details on {}", data().deviceId(), e);
        }
    } else {
        log.error("Authentication error on device {}", data().deviceId());
    }
    return new DefaultDeviceDescription(handler().data().deviceId().uri(), Device.Type.ROADM_OTN, "NOKIA", hwVersion, swVersion, "", new ChassisId("1"));
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId did = data().deviceId();
    NetconfSession ns = getNetconfSessionAndLogin(did, USER_NAME, PASSWORD);
    if (ns == null) {
        log.error("DiscoverDeviceDetails called with null session for {}", did);
        return null;
    }
    log.info("Discovering device details {}", handler().data().deviceId());
    String hwVersion = "1830", swVersion = "OpenAgent";
    try {
        String reply = ns.requestSync(buildGetSystemSoftwareRpc());
        XMLConfiguration cfg = (XMLConfiguration) XmlConfigParser.loadXmlString(getDataOfRpcReply(reply));
        hwVersion = cfg.getString("components.component.state.description");
        swVersion = cfg.getString("components.component.state.version");
    } catch (NetconfException e) {
        log.error("Error discovering device details on {}", data().deviceId(), e);
    }
    return new DefaultDeviceDescription(handler().data().deviceId().uri(), Device.Type.ROADM_OTN, "NOKIA", hwVersion, swVersion, "", new ChassisId("1"));
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    try {
        return discoverPorts();
    } catch (Exception e) {
        log.error("Error discovering port details on {}", data().deviceId(), e);
        return ImmutableList.of();
    }
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    DeviceId did = data().deviceId();
    XMLConfiguration cfg = new XMLConfiguration();
    NetconfSession ns = getNetconfSessionAndLogin(did, USER_NAME, PASSWORD);
    if (ns == null) {
        log.error("discoverPorts called with null session for {}", did);
        return ImmutableList.of();
    }
    log.info("Discovering ports details {}", handler().data().deviceId());
    try {
        String reply = ns.requestSync(buildGetPlatformComponentsRpc());
        String data = getDataOfRpcReply(reply);
        if (data == null) {
            log.error("No valid response found from {}:\n{}", did, reply);
            return ImmutableList.of();
        }
        cfg.load(CharSource.wrap(data).openStream());
        return discoverPorts(cfg);
    } catch (Exception e) {
        log.error("Error discovering port details on {}", data().deviceId(), e);
        return ImmutableList.of();
    }
}
#end_block

#method_before
@VisibleForTesting
protected List<PortDescription> discoverPorts(XMLConfiguration cfg) {
    // If we want to use XPath
    cfg.setExpressionEngine(new XPathExpressionEngine());
    // converting components into PortDescription.
    List<HierarchicalConfiguration> components = cfg.configurationsAt("components/component");
    return components.stream().map(this::toPortDescription).filter(Objects::nonNull).collect(Collectors.toList());
}
#method_after
@VisibleForTesting
private List<PortDescription> discoverPorts(XMLConfiguration cfg) {
    // If we want to use XPath
    cfg.setExpressionEngine(new XPathExpressionEngine());
    // converting components into PortDescription.
    List<HierarchicalConfiguration> components = cfg.configurationsAt("components/component");
    return components.stream().map(this::toPortDescriptionInternal).filter(Objects::nonNull).collect(Collectors.toList());
}
#end_block

#method_before
private PortDescription toPortDescriptionInternal(HierarchicalConfiguration component) {
    // testing on an actual device
    // onos> ports
    // id=netconf:135.104.234.184:830, available=true, local-status=connected 1m7s ago, role=MASTER, type=ROADM_OTN, mfr=NOKIA, hw=Nokia 1830 PSI v2.0 SONET ADM, sw=1830PSS-17.1-20, serial=, chassis=1, driver=nokia-netconf, ipaddress=135.104.234.184, locType=none, name=netconf:135.104.234.184:830, port=830, protocol=NETCONF
    // port=[OCH-1-2-1](1), state=enabled, type=och, speed=1000 , oc-name=PORT-1-2-1, oc-type=oc-platform-types:PORT, odtn-connection-id=1, odtn-port-type=line
    // port=[OCH-1-2-2](2), state=enabled, type=och, speed=1000 , oc-name=PORT-1-2-2, oc-type=oc-platform-types:PORT, odtn-connection-id=2, odtn-port-type=line
    // port=[OCH-1-2-3](3), state=enabled, type=och, speed=1000 , oc-name=PORT-1-2-3, oc-type=oc-platform-types:PORT, odtn-connection-id=3, odtn-port-type=line
    // port=[OCH-1-2-4](4), state=enabled, type=och, speed=1000 , oc-name=PORT-1-2-4, oc-type=oc-platform-types:PORT, odtn-connection-id=4, odtn-port-type=line
    // port=[TRANSCEIVER-1-2-9](9), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-9, oc-type=oc-platform-types:PORT, odtn-connection-id=9, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-13](13), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-13, oc-type=oc-platform-types:PORT, odtn-connection-id=13, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-17](17), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-17, oc-type=oc-platform-types:PORT, odtn-connection-id=17, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-21](21), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-21, oc-type=oc-platform-types:PORT, odtn-connection-id=21, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-25](25), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-25, oc-type=oc-platform-types:PORT, odtn-connection-id=25, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-33](33), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-33, oc-type=oc-platform-types:PORT, odtn-connection-id=33, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-37](37), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-37, oc-type=oc-platform-types:PORT, odtn-connection-id=37, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-41](41), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-41, oc-type=oc-platform-types:PORT, odtn-connection-id=41, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-45](45), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-45, oc-type=oc-platform-types:PORT, odtn-connection-id=45, odtn-port-type=client
    // port=[TRANSCEIVER-1-2-49](49), state=enabled, type=packet, speed=1000 , oc-name=PORT-1-2-49, oc-type=oc-platform-types:PORT, odtn-connection-id=49, odtn-port-type=client
    Map<String, String> props = new HashMap<>();
    String name = component.getString("name");
    String type = component.getString("state/type");
    checkNotNull(name, "name not found");
    checkNotNull(type, "state/type not found");
    props.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    props.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, type);
    Builder builder = DefaultPortDescription.builder();
    if (type.equals("oc-platform-types:PORT")) {
        String subComponentName = component.getString("subcomponents/subcomponent/name");
        String[] textStr = subComponentName.split("-");
        String portComponentType = textStr[0];
        String portComponentIndex = textStr[textStr.length - 1];
        builder.withPortNumber(PortNumber.portNumber(Long.parseLong(portComponentIndex), subComponentName));
        if (portComponentType.equals(OPTICAL_CHANNEL)) {
            builder.type(Type.OCH);
            props.putIfAbsent(PORT_TYPE, OdtnPortType.LINE.value());
            props.putIfAbsent(CONNECTION_ID, portComponentIndex);
        } else if (portComponentType.equals(TRANSCEIVER)) {
            builder.type(Type.PACKET);
            props.putIfAbsent(PORT_TYPE, OdtnPortType.CLIENT.value());
            props.putIfAbsent(CONNECTION_ID, portComponentIndex);
        } else {
            log.info("DEBUG: Unknown port component type {}", type);
            return null;
        }
    } else {
        // log.info("DEBUG: another component type {}", type);
        return null;
    }
    builder.annotations(DefaultAnnotations.builder().putAll(props).build());
    return builder.build();
}
#method_after
private PortDescription toPortDescriptionInternal(HierarchicalConfiguration component) {
    Map<String, String> props = new HashMap<>();
    String name = component.getString("name");
    String type = component.getString("state/type");
    checkNotNull(name, "name not found");
    checkNotNull(type, "state/type not found");
    props.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    props.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, type);
    Builder builder = DefaultPortDescription.builder();
    if (type.equals("oc-platform-types:PORT")) {
        String subComponentName = component.getString("subcomponents/subcomponent/name");
        String[] textStr = subComponentName.split("-");
        String portComponentType = textStr[0];
        String portComponentIndex = textStr[textStr.length - 1];
        builder.withPortNumber(PortNumber.portNumber(Long.parseLong(portComponentIndex), subComponentName));
        if (portComponentType.equals(OPTICAL_CHANNEL)) {
            builder.type(Type.OCH);
            props.putIfAbsent(PORT_TYPE, OdtnPortType.LINE.value());
            props.putIfAbsent(CONNECTION_ID, portComponentIndex);
        } else if (portComponentType.equals(TRANSCEIVER)) {
            builder.type(Type.PACKET);
            props.putIfAbsent(PORT_TYPE, OdtnPortType.CLIENT.value());
            props.putIfAbsent(CONNECTION_ID, portComponentIndex);
        } else {
            log.debug("Unknown port component type {}", type);
            return null;
        }
    } else {
        log.debug("Another component type {}", type);
        return null;
    }
    builder.annotations(DefaultAnnotations.builder().putAll(props).build());
    return builder.build();
}
#end_block

#method_before
private String getDataOfRpcReply(String rpcReply) {
    String data = null;
    int begin = rpcReply.indexOf("<data>");
    int end = rpcReply.lastIndexOf("</data>");
    if (begin != -1 && end != -1) {
        data = (String) rpcReply.subSequence(begin, end + "</data>".length());
    } else {
        // FIXME probably should exceptionally fail here.
        data = rpcReply;
    }
    return data;
}
#method_after
private String getDataOfRpcReply(String rpcReply) {
    String data = null;
    int begin = rpcReply.indexOf("<data>");
    int end = rpcReply.lastIndexOf("</data>");
    if (begin != -1 && end != -1) {
        data = (String) rpcReply.subSequence(begin, end + "</data>".length());
    } else {
        data = rpcReply;
    }
    return data;
}
#end_block

#method_before
private String buildLoginRpc(String userName, String passwd) {
    StringBuilder rpc = new StringBuilder(RPC_TAG_NETCONF_BASE);
    rpc.append("<login>");
    rpc.append("<user>");
    rpc.append(userName);
    rpc.append("</user>");
    rpc.append("<password>");
    rpc.append(passwd);
    rpc.append("</password>");
    rpc.append("</login>");
    rpc.append(RPC_CLOSE_TAG);
    return rpc.toString();
}
#method_after
private String buildLoginRpc(String userName, String passwd) {
    StringBuilder rpc = new StringBuilder(RPC_TAG_NETCONF_BASE);
    rpc.append("<login xmlns=\"http://nokia.com/yang/nokia-security\">");
    rpc.append("<username>");
    rpc.append(userName);
    rpc.append("</username>");
    rpc.append("<password>");
    rpc.append(passwd);
    rpc.append("</password>");
    rpc.append("</login>");
    rpc.append(RPC_CLOSE_TAG);
    return rpc.toString();
}
#end_block

#method_before
private void startClient() throws IOException {
    client = SshClient.setUpDefaultClient();
    client.getProperties().putIfAbsent(FactoryManager.IDLE_TIMEOUT, TimeUnit.SECONDS.toMillis(idleTimeout));
    client.getProperties().putIfAbsent(FactoryManager.NIO2_READ_TIMEOUT, TimeUnit.SECONDS.toMillis(idleTimeout + 15L));
    client.start();
    client.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());
    startSession();
}
#method_after
private void startClient() throws IOException {
    log.info("Creating NETCONF session to {}", deviceInfo.getDeviceId());
    client = SshClient.setUpDefaultClient();
    client.getProperties().putIfAbsent(FactoryManager.IDLE_TIMEOUT, TimeUnit.SECONDS.toMillis(idleTimeout));
    client.getProperties().putIfAbsent(FactoryManager.NIO2_READ_TIMEOUT, TimeUnit.SECONDS.toMillis(idleTimeout + 15L));
    client.start();
    client.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());
    startSession();
}
#end_block

#method_before
@Deprecated
private void startSession() throws IOException {
    final ConnectFuture connectFuture;
    connectFuture = client.connect(deviceInfo.name(), deviceInfo.ip().toString(), deviceInfo.port()).verify(connectTimeout, TimeUnit.SECONDS);
    session = connectFuture.getSession();
    // Using the device ssh key if possible
    if (deviceInfo.getKey() != null) {
        try (PEMParser pemParser = new PEMParser(new CharArrayReader(deviceInfo.getKey()))) {
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME);
            try {
                KeyPair kp = converter.getKeyPair((PEMKeyPair) pemParser.readObject());
                session.addPublicKeyIdentity(kp);
            } catch (IOException e) {
                throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check key to be a valid key", e);
            }
        }
    } else {
        session.addPasswordIdentity(deviceInfo.password());
    }
    session.auth().verify(connectTimeout, TimeUnit.SECONDS);
    Set<ClientSession.ClientSessionEvent> event = session.waitFor(ImmutableSet.of(ClientSession.ClientSessionEvent.WAIT_AUTH, ClientSession.ClientSessionEvent.CLOSED, ClientSession.ClientSessionEvent.AUTHED), 0);
    if (!event.contains(ClientSession.ClientSessionEvent.AUTHED)) {
        log.debug("Session closed {} {}", event, session.isClosed());
        throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check the user/pwd or key");
    }
    openChannel();
}
#method_after
// TODO: Remove the default methods already implemented in NetconfSession
@Deprecated
private void startSession() throws IOException {
    final ConnectFuture connectFuture;
    connectFuture = client.connect(deviceInfo.name(), deviceInfo.ip().toString(), deviceInfo.port()).verify(connectTimeout, TimeUnit.SECONDS);
    session = connectFuture.getSession();
    // Using the device ssh key if possible
    if (deviceInfo.getKey() != null) {
        try (PEMParser pemParser = new PEMParser(new CharArrayReader(deviceInfo.getKey()))) {
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME);
            try {
                KeyPair kp = converter.getKeyPair((PEMKeyPair) pemParser.readObject());
                session.addPublicKeyIdentity(kp);
            } catch (IOException e) {
                throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check key to be a valid key", e);
            }
        }
    } else {
        session.addPasswordIdentity(deviceInfo.password());
    }
    session.auth().verify(connectTimeout, TimeUnit.SECONDS);
    Set<ClientSession.ClientSessionEvent> event = session.waitFor(ImmutableSet.of(ClientSession.ClientSessionEvent.WAIT_AUTH, ClientSession.ClientSessionEvent.CLOSED, ClientSession.ClientSessionEvent.AUTHED), 0);
    if (!event.contains(ClientSession.ClientSessionEvent.AUTHED)) {
        log.debug("Session closed {} {}", event, session.isClosed());
        throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check the user/pwd or key");
    }
    openChannel();
}
#end_block

#method_before
@Override
public String requestSync(String request) throws NetconfException {
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#method_after
@Override
public String requestSync(String request) throws NetconfException {
    String reply = sendRequest(request);
    if (!checkReply(reply)) {
        throw new NetconfException("Request not successful with device " + deviceInfo + " with reply " + reply);
    }
    return reply;
}
#end_block

#method_before
@Override
public CompletableFuture<String> rpc(String request) {
    String rpc = request;
    // - assign message-id
    int msgId = messageIdInteger.incrementAndGet();
    // - re-write request to insert message-id
    // FIXME avoid using formatRequestMessageId
    rpc = formatRequestMessageId(rpc, msgId);
    // - ensure it contains XML header
    rpc = formatXmlHeader(rpc);
    // - use chunked framing if talking to NC 1.1 device
    // FIXME avoid using formatNetconfMessage
    rpc = formatNetconfMessage(rpc);
    // TODO session liveness check & recovery
    log.debug("Sending {} to {}", rpc, this.deviceInfo.getDeviceId());
    return streamHandler.sendMessage(rpc, msgId).handleAsync((reply, t) -> {
        if (t != null) {
            // checked Exception.
            throw new NetconfTransportException(t);
        } else {
            // FIXME avoid using checkReply, error handling is weird
            checkReply(reply);
            return reply;
        }
    }, SharedExecutors.getPoolThreadExecutor());
}
#method_after
@Override
public CompletableFuture<String> rpc(String request) {
    String rpc = request;
    // - assign message-id
    int msgId = messageIdInteger.incrementAndGet();
    // - re-write request to insert message-id
    // FIXME avoid using formatRequestMessageId
    rpc = formatRequestMessageId(rpc, msgId);
    // - ensure it contains XML header
    rpc = formatXmlHeader(rpc);
    // - use chunked framing if talking to NC 1.1 device
    // FIXME avoid using formatNetconfMessage
    rpc = formatNetconfMessage(rpc);
    // TODO session liveness check & recovery
    log.debug("Sending {} to {}", rpc, this.deviceInfo.getDeviceId());
    return streamHandler.sendMessage(rpc, msgId).handleAsync((reply, t) -> {
        if (t != null) {
            // checked Exception.
            throw new NetconfTransportException(t);
        } else {
            // FIXME avoid using checkReply, error handling is weird
            if (!checkReply(reply)) {
                throw new NetconfTransportException("rpc-request not successful with device " + deviceInfo + " with reply " + reply);
            }
            return reply;
        }
    }, SharedExecutors.getPoolThreadExecutor());
}
#end_block

#method_before
private boolean checkReply(String reply) {
    if (reply != null) {
        if (!reply.contains("<rpc-error>")) {
            log.debug("Device {} sent reply {}", deviceInfo, reply);
            return true;
        } else if (reply.contains("<ok/>") || (reply.contains("<rpc-error>") && reply.contains("warning"))) {
            // FIXME rpc-error with a warning is considered same as Ok??
            log.debug("Device {} sent reply {}", deviceInfo, reply);
            return true;
        }
    }
    log.warn("Device {} has error in reply {}", deviceInfo, reply);
    return false;
}
#method_after
@Override
protected boolean checkReply(String reply) {
    // Overridden to record error logs
    if (reply != null) {
        if (!reply.contains("<rpc-error>")) {
            log.debug("Device {} sent reply {}", deviceInfo, reply);
            return true;
        } else if (reply.contains("<ok/>") || (reply.contains("<rpc-error>") && reply.contains("warning"))) {
            // FIXME rpc-error with a warning is considered same as Ok??
            log.debug("Device {} sent reply {}", deviceInfo, reply);
            return true;
        }
    }
    log.warn("Device {} has error in reply {}", deviceInfo, reply);
    return false;
}
#end_block

#method_before
private void encodeConfigs(String component, String variable, Set<ConfigProperty> props, ObjectNode node) {
    ObjectNode compNode = mapper().createObjectNode();
    node.set(component, compNode);
    props.forEach(p -> {
        if (p.name().equals(variable)) {
            compNode.put(p.name(), p.value());
        }
    });
}
#method_after
private void encodeConfigs(String component, String attribute, ConfigProperty props, ObjectNode node) {
    ObjectNode compNode = mapper().createObjectNode();
    node.set(component, compNode);
    compNode.put(attribute, props.value());
}
#end_block

#method_before
private void triggerUpdate(String componentName) {
    try {
        Configuration cfg = cfgAdmin.getConfiguration(componentName, null);
        Map<String, ConfigProperty> map = properties.get(componentName);
        Dictionary<String, Object> props = new Hashtable<>();
        map.values().stream().filter(p -> p.value() != null).forEach(p -> props.put(p.name(), p.value()));
        cfg.update(props);
    } catch (IOException e) {
        log.warn("Unable to update configuration for " + componentName, e);
    }
}
#method_after
private void triggerUpdate(String componentName) {
    try {
        Configuration cfg = cfgAdmin.getConfiguration(componentName, null);
        Map<String, ConfigProperty> map = properties.get(componentName);
        if (map == null) {
            // Prevent NPE if the component isn't there
            log.warn("Component not found for " + componentName);
            return;
        }
        Dictionary<String, Object> props = new Hashtable<>();
        map.values().stream().filter(p -> p.value() != null).forEach(p -> props.put(p.name(), p.value()));
        cfg.update(props);
    } catch (IOException e) {
        log.warn("Unable to update configuration for " + componentName, e);
    }
}
#end_block

#method_before
@Override
public Port port(org.onosproject.net.Port port) {
    String portName = port.annotations().value(PORT_NAME);
    if (Strings.isNullOrEmpty(portName)) {
        return null;
    }
    if (port.annotations().value(PORT_NAME).startsWith(PORT_NAME_PREFIX_VM) || portName.startsWith(PORT_NAME_VHOST_USER_PREFIX_VM)) {
        Optional<Port> osPort = osNetworkStore.ports().stream().filter(p -> p.getId().contains(portName.substring(3))).findFirst();
        return osPort.orElse(null);
    } else if (isDirectPort(portName)) {
        // Additional prefixes will be added
        Optional<Port> osPort = osNetworkStore.ports().stream().filter(p -> p.getvNicType().equals(DIRECT) && p.getProfile().get(PCISLOT) != null).filter(p -> getIntfNameFromPciAddress(p).equals(portName)).findFirst();
        return osPort.orElse(null);
    } else {
        return null;
    }
}
#method_after
@Override
public Port port(org.onosproject.net.Port port) {
    String portName = port.annotations().value(PORT_NAME);
    if (Strings.isNullOrEmpty(portName)) {
        return null;
    }
    try {
        Optional<Port> osPort;
        switch(vnicType(portName)) {
            case NORMAL:
                osPort = osNetworkStore.ports().stream().filter(p -> p.getId().contains(portName.substring(3))).findFirst();
                return osPort.orElse(null);
            case DIRECT:
                // Additional prefixes will be added
                osPort = osNetworkStore.ports().stream().filter(p -> p.getvNicType().equals(DIRECT) && p.getProfile().get(PCISLOT) != null).filter(p -> getIntfNameFromPciAddress(p).equals(portName)).findFirst();
                return osPort.orElse(null);
            default:
                return null;
        }
    } catch (IllegalArgumentException e) {
        log.error("IllegalArgumentException occurred because of {}", e);
        return null;
    }
}
#end_block

#method_before
@PUT
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updatePort(@PathParam("id") String id, InputStream input) {
    log.trace(String.format(MESSAGE, "UPDATE " + id));
    final NeutronPort port = (NeutronPort) jsonToModelEntity(input, NeutronPort.class);
    adminService.updatePort(port);
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode jsonNode = mapper.createObjectNode();
    OpenstackNode node = nodeService.node(port.getHostId());
    if (node == null) {
        return status(Response.Status.OK).build();
    } else if (node.datapathType().equals(OpenstackNode.DatapathType.NETDEV)) {
        log.debug("UpdatePort for port {} called in netdev device {} " + "so sends vif type as a payload of the response", port.getId(), node.hostname());
        jsonNode.put(VIF_TYPE, VHOSTUSER);
        return status(Response.Status.OK).entity(jsonNode.toString()).build();
    } else {
        return status(Response.Status.OK).build();
    }
}
#method_after
@PUT
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updatePort(@PathParam("id") String id, InputStream input) {
    log.trace(String.format(MESSAGE, "UPDATE " + id));
    final NeutronPort port = (NeutronPort) jsonToModelEntity(input, NeutronPort.class);
    adminService.updatePort(port);
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode jsonNode = mapper.createObjectNode();
    OpenstackNode node = nodeService.node(port.getHostId());
    if (node == null) {
        return status(Response.Status.OK).build();
    } else if (node.datapathType().equals(OpenstackNode.DatapathType.NETDEV)) {
        log.debug("UpdatePort for port {} called in netdev device {} " + "so sends vif type as a payload of the response", port.getId(), node.hostname());
        jsonNode.put(VIF_TYPE, VHOSTUSER);
        if (node.socketDir() != null) {
            jsonNode.put(SOCKET_DIR, node.socketDir());
        }
        return status(Response.Status.OK).entity(jsonNode.toString()).build();
    } else {
        return status(Response.Status.OK).build();
    }
}
#end_block

#method_before
private void processCompleteNode(OpenstackNode osNode) {
    deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> (port.annotations().value(PORT_NAME).startsWith(PORT_NAME_PREFIX_VM) || port.annotations().value(PORT_NAME).startsWith(PORT_NAME_VHOST_USER_PREFIX_VM)) && port.isEnabled()).forEach(port -> {
        log.debug("Instance port {} is detected from {}", port.annotations().value(PORT_NAME), osNode.hostname());
        processPortAdded(port);
    });
    portNamePrefixMap().values().forEach(portNamePrefix -> deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> port.annotations().value(PORT_NAME).startsWith(portNamePrefix) && port.isEnabled()).forEach(port -> {
        log.debug("Instance port {} is detected from {}", port.annotations().value(portNamePrefix), osNode.hostname());
        processPortAdded(port);
    }));
    Tools.stream(hostService.getHosts()).filter(host -> deviceService.getPort(host.location().deviceId(), host.location().port()) == null).forEach(host -> {
        log.info("Remove stale host {}", host.id());
        hostProviderService.hostVanished(host.id());
    });
}
#method_after
private void processCompleteNode(OpenstackNode osNode) {
    deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> vnicType(port.annotations().value(PORT_NAME)).equals(Constants.VnicType.NORMAL) || vnicType(port.annotations().value(PORT_NAME)).equals(Constants.VnicType.DIRECT)).filter(Port::isEnabled).forEach(port -> {
        log.debug("Instance port {} is detected from {}", port.annotations().value(PORT_NAME), osNode.hostname());
        processPortAdded(port);
    });
    Tools.stream(hostService.getHosts()).filter(host -> deviceService.getPort(host.location().deviceId(), host.location().port()) == null).forEach(host -> {
        log.info("Remove stale host {}", host.id());
        hostProviderService.hostVanished(host.id());
    });
}
#end_block

#method_before
private void installUpstreamRules(ForwardingObjective fwd) {
    List<Pair<Instruction, Instruction>> vlanOps = vlanOps(fwd, L2ModificationInstruction.L2SubType.VLAN_PUSH);
    if (vlanOps == null) {
        return;
    }
    Instruction output = fetchOutput(fwd, "upstream");
    if (output == null) {
        return;
    }
    Pair<Instruction, Instruction> innerPair = vlanOps.remove(0);
    Pair<Instruction, Instruction> outerPair = vlanOps.remove(0);
    FlowRule.Builder inner = DefaultFlowRule.builder().fromApp(fwd.appId()).forDevice(deviceId).makePermanent().withPriority(fwd.priority()).withSelector(fwd.selector()).withTreatment(buildTreatment(innerPair.getRight(), Instructions.transition(QQ_TABLE)));
    PortCriterion inPort = (PortCriterion) fwd.selector().getCriterion(Criterion.Type.IN_PORT);
    VlanId cVlanId = ((L2ModificationInstruction.ModVlanIdInstruction) innerPair.getRight()).vlanId();
    FlowRule.Builder outer = DefaultFlowRule.builder().fromApp(fwd.appId()).forDevice(deviceId).forTable(QQ_TABLE).makePermanent().withPriority(fwd.priority()).withSelector(buildSelector(inPort, Criteria.matchVlanId(cVlanId))).withTreatment(buildTreatment(outerPair.getLeft(), outerPair.getRight(), output));
    applyRules(fwd, inner, outer);
}
#method_after
private void installUpstreamRules(ForwardingObjective fwd) {
    List<Pair<Instruction, Instruction>> vlanOps = vlanOps(fwd, L2ModificationInstruction.L2SubType.VLAN_PUSH);
    if (vlanOps == null) {
        return;
    }
    Instruction output = fetchOutput(fwd, "upstream");
    if (output == null) {
        return;
    }
    Pair<Instruction, Instruction> innerPair = vlanOps.remove(0);
    Pair<Instruction, Instruction> outerPair = vlanOps.remove(0);
    // Add the VLAN_PUSH treatment if we're matching on VlanId.NONE
    Criterion vlanMatchCriterion = filterForCriterion(fwd.selector().criteria(), Criterion.Type.VLAN_VID);
    boolean push = false;
    if (vlanMatchCriterion != null) {
        push = ((VlanIdCriterion) vlanMatchCriterion).vlanId().equals(VlanId.NONE);
    }
    TrafficTreatment treatment;
    if (push) {
        treatment = buildTreatment(innerPair.getLeft(), innerPair.getRight(), Instructions.transition(QQ_TABLE));
    } else {
        treatment = buildTreatment(innerPair.getRight(), Instructions.transition(QQ_TABLE));
    }
    FlowRule.Builder inner = DefaultFlowRule.builder().fromApp(fwd.appId()).forDevice(deviceId).makePermanent().withPriority(fwd.priority()).withSelector(fwd.selector()).withTreatment(treatment);
    PortCriterion inPort = (PortCriterion) fwd.selector().getCriterion(Criterion.Type.IN_PORT);
    VlanId cVlanId = ((L2ModificationInstruction.ModVlanIdInstruction) innerPair.getRight()).vlanId();
    FlowRule.Builder outer = DefaultFlowRule.builder().fromApp(fwd.appId()).forDevice(deviceId).forTable(QQ_TABLE).makePermanent().withPriority(fwd.priority()).withSelector(buildSelector(inPort, Criteria.matchVlanId(cVlanId))).withTreatment(buildTreatment(outerPair.getLeft(), outerPair.getRight(), output));
    applyRules(fwd, inner, outer);
}
#end_block

#method_before
@Modified
private void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strActiveProbing = Tools.get(properties, "activeProbing");
    boolean expectActiveProbing = Boolean.parseBoolean(strActiveProbing);
    if (expectActiveProbing != activeProbing) {
        activeProbing = expectActiveProbing;
        log.info("{} active probing", activeProbing ? "Enabling" : "Disabling");
    }
    String strSingleHomedDown = Tools.get(properties, "singleHomedDown");
    boolean expectSingleHomedDown = Boolean.parseBoolean(strSingleHomedDown);
    if (expectSingleHomedDown != singleHomedDown) {
        singleHomedDown = expectSingleHomedDown;
        log.info("{} downing of single homed hosts for lost uplinks", singleHomedDown ? "Enabling" : "Disabling");
        if (singleHomedDown && linkHandler != null) {
            hostService.getHosts().forEach(host -> host.locations().forEach(loc -> {
                if (interfaceService.isConfigured(loc)) {
                    linkHandler.checkUplinksForHost(loc);
                }
            }));
        } else {
            log.warn("Disabling singleHomedDown does not re-enable already " + "downed ports for single-homed hosts");
        }
    }
    String strRespondToUnknownHosts = Tools.get(properties, "respondToUnknownHosts");
    boolean expectRespondToUnknownHosts = Boolean.parseBoolean(strRespondToUnknownHosts);
    if (expectRespondToUnknownHosts != respondToUnknownHosts) {
        respondToUnknownHosts = expectRespondToUnknownHosts;
        log.info("{} responding to ARPs/NDPs from unknown hosts", respondToUnknownHosts ? "Enabling" : "Disabling");
    }
    String strRouteDoubleTaggedHosts = Tools.get(properties, "routeDoubleTaggedHosts");
    boolean expectRouteDoubleTaggedHosts = Boolean.parseBoolean(strRouteDoubleTaggedHosts);
    if (expectRouteDoubleTaggedHosts != routeDoubleTaggedHosts) {
        routeDoubleTaggedHosts = expectRouteDoubleTaggedHosts;
        log.info("{} routing for double tagged hosts", routeDoubleTaggedHosts ? "Enabling" : "Disabling");
        if (routeDoubleTaggedHosts) {
            hostHandler.populateAllDoubleTaggedHost();
        } else {
            hostHandler.revokeAllDoubleTaggedHost();
        }
    }
    String strDefaultInternalVlan = Tools.get(properties, "defaultInternalVlan");
    int defIntVlan = Integer.parseInt(strDefaultInternalVlan);
    if (defIntVlan != defaultInternalVlan) {
        if (canUseVlanId(defIntVlan)) {
            log.warn("Default internal vlan value changed from {} to {}.. " + "re-programming filtering rules, but NOT any groups already " + "created with the former value", defaultInternalVlan, defIntVlan);
            VlanId oldDefIntVlan = VlanId.vlanId((short) defaultInternalVlan);
            defaultInternalVlan = defIntVlan;
            routingRulePopulator.updateSpecialVlanFilteringRules(true, oldDefIntVlan, VlanId.vlanId((short) defIntVlan));
        } else {
            log.info("Cannot change default internal vlan to unusable " + "value {}", defIntVlan);
        }
    }
    String strPwTxpVlan = Tools.get(properties, "pwTransportVlan");
    int pwTxpVlan = Integer.parseInt(strPwTxpVlan);
    if (pwTxpVlan != pwTransportVlan) {
        if (canUseVlanId(pwTxpVlan)) {
            log.warn("Pseudowire transport vlan value changed from {} to {}.. " + "re-programming filtering rules, but NOT any groups already " + "created with the former value", pwTransportVlan, pwTxpVlan);
            VlanId oldPwTxpVlan = VlanId.vlanId((short) pwTransportVlan);
            pwTransportVlan = pwTxpVlan;
            routingRulePopulator.updateSpecialVlanFilteringRules(false, oldPwTxpVlan, VlanId.vlanId((short) pwTxpVlan));
        } else {
            log.info("Cannot change pseudowire transport vlan to unusable " + "value {}", pwTxpVlan);
        }
    }
}
#method_after
@Modified
private void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strActiveProbing = Tools.get(properties, "activeProbing");
    boolean expectActiveProbing = Boolean.parseBoolean(strActiveProbing);
    if (expectActiveProbing != activeProbing) {
        activeProbing = expectActiveProbing;
        log.info("{} active probing", activeProbing ? "Enabling" : "Disabling");
    }
    String strSingleHomedDown = Tools.get(properties, "singleHomedDown");
    boolean expectSingleHomedDown = Boolean.parseBoolean(strSingleHomedDown);
    if (expectSingleHomedDown != singleHomedDown) {
        singleHomedDown = expectSingleHomedDown;
        log.info("{} downing of single homed hosts for lost uplinks", singleHomedDown ? "Enabling" : "Disabling");
        if (singleHomedDown && linkHandler != null) {
            hostService.getHosts().forEach(host -> host.locations().forEach(loc -> {
                if (interfaceService.isConfigured(loc)) {
                    linkHandler.checkUplinksForHost(loc);
                }
            }));
        } else {
            log.warn("Disabling singleHomedDown does not re-enable already " + "downed ports for single-homed hosts");
        }
    }
    String strRespondToUnknownHosts = Tools.get(properties, "respondToUnknownHosts");
    boolean expectRespondToUnknownHosts = Boolean.parseBoolean(strRespondToUnknownHosts);
    if (expectRespondToUnknownHosts != respondToUnknownHosts) {
        respondToUnknownHosts = expectRespondToUnknownHosts;
        log.info("{} responding to ARPs/NDPs from unknown hosts", respondToUnknownHosts ? "Enabling" : "Disabling");
    }
    String strRouteDoubleTaggedHosts = Tools.get(properties, "routeDoubleTaggedHosts");
    boolean expectRouteDoubleTaggedHosts = Boolean.parseBoolean(strRouteDoubleTaggedHosts);
    if (expectRouteDoubleTaggedHosts != routeDoubleTaggedHosts) {
        routeDoubleTaggedHosts = expectRouteDoubleTaggedHosts;
        log.info("{} routing for double tagged hosts", routeDoubleTaggedHosts ? "Enabling" : "Disabling");
        if (routeDoubleTaggedHosts) {
            hostHandler.populateAllDoubleTaggedHost();
        } else {
            hostHandler.revokeAllDoubleTaggedHost();
        }
    }
    String strDefaultInternalVlan = Tools.get(properties, "defaultInternalVlan");
    int defIntVlan = Integer.parseInt(strDefaultInternalVlan);
    if (defIntVlan != defaultInternalVlan) {
        if (canUseVlanId(defIntVlan)) {
            log.warn("Default internal vlan value changed from {} to {}.. " + "re-programming filtering rules, but NOT any groups already " + "created with the former value", defaultInternalVlan, defIntVlan);
            VlanId oldDefIntVlan = VlanId.vlanId((short) defaultInternalVlan);
            defaultInternalVlan = defIntVlan;
            routingRulePopulator.updateSpecialVlanFilteringRules(true, oldDefIntVlan, VlanId.vlanId((short) defIntVlan));
        } else {
            log.warn("Cannot change default internal vlan to unusable " + "value {}", defIntVlan);
        }
    }
    String strPwTxpVlan = Tools.get(properties, "pwTransportVlan");
    int pwTxpVlan = Integer.parseInt(strPwTxpVlan);
    if (pwTxpVlan != pwTransportVlan) {
        if (canUseVlanId(pwTxpVlan)) {
            log.warn("Pseudowire transport vlan value changed from {} to {}.. " + "re-programming filtering rules, but NOT any groups already " + "created with the former value", pwTransportVlan, pwTxpVlan);
            VlanId oldPwTxpVlan = VlanId.vlanId((short) pwTransportVlan);
            pwTransportVlan = pwTxpVlan;
            routingRulePopulator.updateSpecialVlanFilteringRules(false, oldPwTxpVlan, VlanId.vlanId((short) pwTxpVlan));
        } else {
            log.warn("Cannot change pseudowire transport vlan to unusable " + "value {}", pwTxpVlan);
        }
    }
}
#end_block

#method_before
public boolean canUseVlanId(int vlanId) {
    if (vlanId >= 4095 || vlanId <= 1) {
        log.error("Vlan id {} value is not in valid range 2 <--> 4094", vlanId);
        return false;
    }
    VlanId vid = VlanId.vlanId((short) vlanId);
    if (getDefaultInternalVlan().equals(vid) || getPwTransportVlan().equals(vid)) {
        log.warn("Vlan id {} value is already in use system-wide. " + "DefaultInternalVlan:{} PwTransportVlan:{} ", vlanId, getDefaultInternalVlan(), getPwTransportVlan());
        return false;
    }
    if (interfaceService.isConfigured(vid)) {
        log.warn("Vlan id {} value is already in use on a configured " + "interface in the system", vlanId);
        return false;
    }
    return true;
}
#method_after
public boolean canUseVlanId(int vlanId) {
    if (vlanId >= 4095 || vlanId <= 1) {
        log.error("Vlan id {} value is not in valid range 2 <--> 4094", vlanId);
        return false;
    }
    VlanId vid = VlanId.vlanId((short) vlanId);
    if (getDefaultInternalVlan().equals(vid) || getPwTransportVlan().equals(vid)) {
        log.warn("Vlan id {} value is already in use system-wide. " + "DefaultInternalVlan:{} PwTransportVlan:{} ", vlanId, getDefaultInternalVlan(), getPwTransportVlan());
        return false;
    }
    if (interfaceService.inUse(vid)) {
        log.warn("Vlan id {} value is already in use on a configured " + "interface in the system", vlanId);
        return false;
    }
    return true;
}
#end_block

#method_before
private void setDefaultArpRuleForBroadcastMode(OpenstackNode osNode, boolean install) {
    // we only match ARP_REPLY in gateway node, because controller
    // somehow need to process ARP_REPLY which is issued from
    // external router...
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpOp(ARP.OP_REPLY).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().punt().build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), selector, treatment, PRIORITY_ARP_CONTROL_RULE, GW_COMMON_TABLE, install);
}
#method_after
private void setDefaultArpRuleForBroadcastMode(OpenstackNode osNode, boolean install) {
    // we only match ARP_REPLY in gateway node, because controller
    // somehow need to process ARP_REPLY which is issued from
    // external router...
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpOp(ARP.OP_REPLY).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().punt().build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), selector, treatment, PRIORITY_ARP_CONTROL_RULE, GW_COMMON_TABLE, install);
    osRouterService.routers().stream().filter(router -> router.getExternalGatewayInfo() != null).forEach(router -> setFakeGatewayArpRule(router, install));
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = Dhcp6HandlerUtil.extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = Dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.DHCP, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.DHCP, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    if (record != null) {
        record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        record.addLocation(new HostLocation(location, System.currentTimeMillis()));
        record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
        record.setDirectlyConnected(directConnFlag);
        if (!directConnFlag) {
            // Update gateway mac address if the host is not directly connected
            record.nextHop(srcMac);
        }
        record.updateLastSeen();
    }
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = Dhcp6HandlerUtil.extractClientId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = Dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.DHCP, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.DHCP, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    if (record != null) {
        record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        record.addLocation(new HostLocation(location, System.currentTimeMillis()));
        record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
        record.setDirectlyConnected(directConnFlag);
        if (!directConnFlag) {
            // Update gateway mac address if the host is not directly connected
            record.nextHop(srcMac);
        }
        record.updateLastSeen();
    }
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = Dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = Dhcp6HandlerUtil.extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.DHCP, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.replaceRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.DHCP, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.replaceRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("Client IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
            record.updateAddrPrefTime(ipInfo.prefTime);
            record.updateLastIp6Update();
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
            record.pdPrefix(pdInfo.pdPrefix);
            record.updatePdPrefTime(pdInfo.prefTime);
            record.updateLastPdUpdate();
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#method_after
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = Dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = Dhcp6HandlerUtil.extractClientId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.DHCP, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.replaceRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.DHCP, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.replaceRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("Client IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
            record.updateAddrPrefTime(ipInfo.prefTime);
            record.updateLastIp6Update();
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
            record.pdPrefix(pdInfo.pdPrefix);
            record.updatePdPrefTime(pdInfo.prefTime);
            record.updateLastPdUpdate();
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultOpenstackNode) {
        DefaultOpenstackNode that = (DefaultOpenstackNode) obj;
        return Objects.equals(hostname, that.hostname) && Objects.equals(type, that.type) && Objects.equals(intgBridge, that.intgBridge) && Objects.equals(managementIp, that.managementIp) && Objects.equals(dataIp, that.dataIp) && Objects.equals(uplinkPort, that.uplinkPort) && Objects.equals(vlanIntf, that.vlanIntf) && Objects.equals(phyIntfs, that.phyIntfs) && Objects.equals(controllers, that.controllers) && Objects.equals(auth, that.auth) && Objects.equals(endPoint, that.endPoint) && Objects.equals(sshAuth, that.sshAuth) && Objects.equals(dataPathType, that.dataPathType);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultOpenstackNode) {
        DefaultOpenstackNode that = (DefaultOpenstackNode) obj;
        return Objects.equals(hostname, that.hostname) && Objects.equals(type, that.type) && Objects.equals(intgBridge, that.intgBridge) && Objects.equals(managementIp, that.managementIp) && Objects.equals(dataIp, that.dataIp) && Objects.equals(uplinkPort, that.uplinkPort) && Objects.equals(vlanIntf, that.vlanIntf) && Objects.equals(phyIntfs, that.phyIntfs) && Objects.equals(controllers, that.controllers) && Objects.equals(auth, that.auth) && Objects.equals(endPoint, that.endPoint) && Objects.equals(sshAuth, that.sshAuth) && Objects.equals(datapathType, that.datapathType);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(hostname, type, intgBridge, managementIp, dataIp, vlanIntf, uplinkPort, phyIntfs, controllers, auth, endPoint, sshAuth, dataPathType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(hostname, type, intgBridge, managementIp, dataIp, vlanIntf, uplinkPort, phyIntfs, controllers, auth, endPoint, sshAuth, datapathType);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("hostname", hostname).add("type", type).add("integrationBridge", intgBridge).add("managementIp", managementIp).add("dataIp", dataIp).add("vlanIntf", vlanIntf).add("uplinkPort", uplinkPort).add("state", state).add("phyIntfs", phyIntfs).add("controllers", controllers).add("auth", auth).add("endpoint", endPoint).add("sshAuth", sshAuth).add("dataPathType", dataPathType).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("hostname", hostname).add("type", type).add("integrationBridge", intgBridge).add("managementIp", managementIp).add("dataIp", dataIp).add("vlanIntf", vlanIntf).add("uplinkPort", uplinkPort).add("state", state).add("phyIntfs", phyIntfs).add("controllers", controllers).add("auth", auth).add("endpoint", endPoint).add("sshAuth", sshAuth).add("datapathType", datapathType).toString();
}
#end_block

#method_before
@Override
public OpenstackNode updateState(NodeState newState) {
    return new Builder().type(type).hostname(hostname).intgBridge(intgBridge).managementIp(managementIp).dataIp(dataIp).vlanIntf(vlanIntf).uplinkPort(uplinkPort).state(newState).phyIntfs(phyIntfs).controllers(controllers).authentication(auth).endPoint(endPoint).sshAuthInfo(sshAuth).dataPathType(dataPathType).build();
}
#method_after
@Override
public OpenstackNode updateState(NodeState newState) {
    return new Builder().type(type).hostname(hostname).intgBridge(intgBridge).managementIp(managementIp).dataIp(dataIp).vlanIntf(vlanIntf).uplinkPort(uplinkPort).state(newState).phyIntfs(phyIntfs).controllers(controllers).authentication(auth).endPoint(endPoint).sshAuthInfo(sshAuth).datapathType(datapathType).build();
}
#end_block

#method_before
public static Builder from(OpenstackNode osNode) {
    return new Builder().hostname(osNode.hostname()).type(osNode.type()).intgBridge(osNode.intgBridge()).managementIp(osNode.managementIp()).dataIp(osNode.dataIp()).vlanIntf(osNode.vlanIntf()).uplinkPort(osNode.uplinkPort()).state(osNode.state()).phyIntfs(osNode.phyIntfs()).controllers(osNode.controllers()).authentication(osNode.authentication()).endPoint(osNode.endPoint()).sshAuthInfo(osNode.sshAuthInfo());
}
#method_after
public static Builder from(OpenstackNode osNode) {
    return new Builder().hostname(osNode.hostname()).type(osNode.type()).intgBridge(osNode.intgBridge()).managementIp(osNode.managementIp()).dataIp(osNode.dataIp()).vlanIntf(osNode.vlanIntf()).uplinkPort(osNode.uplinkPort()).state(osNode.state()).phyIntfs(osNode.phyIntfs()).controllers(osNode.controllers()).authentication(osNode.authentication()).endPoint(osNode.endPoint()).sshAuthInfo(osNode.sshAuthInfo()).datapathType(osNode.datapathType());
}
#end_block

#method_before
@Override
public DefaultOpenstackNode build() {
    checkArgument(hostname != null, NOT_NULL_MSG, "hostname");
    checkArgument(type != null, NOT_NULL_MSG, "type");
    checkArgument(state != null, NOT_NULL_MSG, "state");
    checkArgument(managementIp != null, NOT_NULL_MSG, "management IP");
    if (type != NodeType.CONTROLLER) {
        checkArgument(intgBridge != null, NOT_NULL_MSG, "integration bridge");
        if (dataIp == null && Strings.isNullOrEmpty(vlanIntf)) {
            throw new IllegalArgumentException("Either data IP or VLAN interface is required");
        }
    } else {
        checkArgument(endPoint != null, NOT_NULL_MSG, "endpoint URL");
    }
    if (type == NodeType.GATEWAY && uplinkPort == null) {
        throw new IllegalArgumentException("Uplink port is required for gateway node");
    }
    return new DefaultOpenstackNode(hostname, type, intgBridge, managementIp, dataIp, vlanIntf, uplinkPort, state, phyIntfs, controllers, auth, endPoint, sshAuth, dataPathType);
}
#method_after
@Override
public DefaultOpenstackNode build() {
    checkArgument(hostname != null, NOT_NULL_MSG, "hostname");
    checkArgument(type != null, NOT_NULL_MSG, "type");
    checkArgument(state != null, NOT_NULL_MSG, "state");
    checkArgument(managementIp != null, NOT_NULL_MSG, "management IP");
    if (type != NodeType.CONTROLLER) {
        checkArgument(intgBridge != null, NOT_NULL_MSG, "integration bridge");
        if (dataIp == null && Strings.isNullOrEmpty(vlanIntf)) {
            throw new IllegalArgumentException("Either data IP or VLAN interface is required");
        }
    } else {
        checkArgument(endPoint != null, NOT_NULL_MSG, "endpoint URL");
    }
    if (type == NodeType.GATEWAY && uplinkPort == null) {
        throw new IllegalArgumentException("Uplink port is required for gateway node");
    }
    return new DefaultOpenstackNode(hostname, type, intgBridge, managementIp, dataIp, vlanIntf, uplinkPort, state, phyIntfs, controllers, auth, endPoint, sshAuth, datapathType);
}
#end_block

#method_before
private void createBridge(OpenstackNode osNode, String bridgeName, DeviceId deviceId) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.error("Failed to create integration bridge on {}", osNode.ovsdb());
        return;
    }
    List<ControllerInfo> controllers;
    if (osNode.controllers() != null && osNode.controllers().size() > 0) {
        controllers = (List<ControllerInfo>) osNode.controllers();
    } else {
        Set<IpAddress> controllerIps = clusterService.getNodes().stream().map(ControllerNode::ip).collect(Collectors.toSet());
        controllers = controllerIps.stream().map(ip -> new ControllerInfo(ip, DEFAULT_OFPORT, DEFAULT_OF_PROTO)).collect(Collectors.toList());
    }
    String dpid = deviceId.toString().substring(DPID_BEGIN);
    BridgeDescription.Builder builder = DefaultBridgeDescription.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(controllers);
    if (osNode.dataPathType().equals(OpenstackNode.DATA_PATH_TYPE_NETDEV)) {
        builder.datapathType(osNode.dataPathType());
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addBridge(builder.build());
}
#method_after
private void createBridge(OpenstackNode osNode, String bridgeName, DeviceId deviceId) {
    Device device = deviceService.getDevice(osNode.ovsdb());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.error("Failed to create integration bridge on {}", osNode.ovsdb());
        return;
    }
    List<ControllerInfo> controllers;
    if (osNode.controllers() != null && osNode.controllers().size() > 0) {
        controllers = (List<ControllerInfo>) osNode.controllers();
    } else {
        Set<IpAddress> controllerIps = clusterService.getNodes().stream().map(ControllerNode::ip).collect(Collectors.toSet());
        controllers = controllerIps.stream().map(ip -> new ControllerInfo(ip, DEFAULT_OFPORT, DEFAULT_OF_PROTO)).collect(Collectors.toList());
    }
    String dpid = deviceId.toString().substring(DPID_BEGIN);
    BridgeDescription.Builder builder = DefaultBridgeDescription.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(controllers);
    if (osNode.datapathType().equals(NETDEV)) {
        builder.datapathType(osNode.datapathType().name().toLowerCase());
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addBridge(builder.build());
}
#end_block

#method_before
@Override
public ObjectNode encode(OpenstackNode node, CodecContext context) {
    checkNotNull(node, "Openstack node cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put(HOST_NAME, node.hostname()).put(TYPE, node.type().name()).put(STATE, node.state().name()).put(MANAGEMENT_IP, node.managementIp().toString()).put(DATA_PATH_TYPE, node.dataPathType());
    OpenstackNode.NodeType type = node.type();
    if (type == OpenstackNode.NodeType.GATEWAY) {
        result.put(UPLINK_PORT, node.uplinkPort());
    }
    if (type != OpenstackNode.NodeType.CONTROLLER) {
        result.put(INTEGRATION_BRIDGE, node.intgBridge().toString());
    } else {
        result.put(END_POINT, node.endPoint());
    }
    if (node.vlanIntf() != null) {
        result.put(VLAN_INTF_NAME, node.vlanIntf());
    }
    if (node.dataIp() != null) {
        result.put(DATA_IP, node.dataIp().toString());
    }
    // TODO: need to find a way to not refer to ServiceDirectory from
    // DefaultOpenstackNode
    ArrayNode phyIntfs = context.mapper().createArrayNode();
    node.phyIntfs().forEach(phyIntf -> {
        ObjectNode phyIntfJson = context.codec(OpenstackPhyInterface.class).encode(phyIntf, context);
        phyIntfs.add(phyIntfJson);
    });
    result.set(PHYSICAL_INTERFACES, phyIntfs);
    ArrayNode controllers = context.mapper().createArrayNode();
    node.controllers().forEach(controller -> {
        ObjectNode controllerJson = context.codec(ControllerInfo.class).encode(controller, context);
        controllers.add(controllerJson);
    });
    if (node.authentication() != null) {
        ObjectNode authJson = context.codec(OpenstackAuth.class).encode(node.authentication(), context);
        result.set(AUTHENTICATION, authJson);
    }
    if (node.sshAuthInfo() != null) {
        ObjectNode sshAuthJson = context.codec(OpenstackSshAuth.class).encode(node.sshAuthInfo(), context);
        result.set(SSH_AUTH, sshAuthJson);
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(OpenstackNode node, CodecContext context) {
    checkNotNull(node, "Openstack node cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put(HOST_NAME, node.hostname()).put(TYPE, node.type().name()).put(STATE, node.state().name()).put(MANAGEMENT_IP, node.managementIp().toString()).put(DATA_PATH_TYPE, node.datapathType().name());
    OpenstackNode.NodeType type = node.type();
    if (type == OpenstackNode.NodeType.GATEWAY) {
        result.put(UPLINK_PORT, node.uplinkPort());
    }
    if (type != OpenstackNode.NodeType.CONTROLLER) {
        result.put(INTEGRATION_BRIDGE, node.intgBridge().toString());
    } else {
        result.put(END_POINT, node.endPoint());
    }
    if (node.vlanIntf() != null) {
        result.put(VLAN_INTF_NAME, node.vlanIntf());
    }
    if (node.dataIp() != null) {
        result.put(DATA_IP, node.dataIp().toString());
    }
    // TODO: need to find a way to not refer to ServiceDirectory from
    // DefaultOpenstackNode
    ArrayNode phyIntfs = context.mapper().createArrayNode();
    node.phyIntfs().forEach(phyIntf -> {
        ObjectNode phyIntfJson = context.codec(OpenstackPhyInterface.class).encode(phyIntf, context);
        phyIntfs.add(phyIntfJson);
    });
    result.set(PHYSICAL_INTERFACES, phyIntfs);
    ArrayNode controllers = context.mapper().createArrayNode();
    node.controllers().forEach(controller -> {
        ObjectNode controllerJson = context.codec(ControllerInfo.class).encode(controller, context);
        controllers.add(controllerJson);
    });
    if (node.authentication() != null) {
        ObjectNode authJson = context.codec(OpenstackAuth.class).encode(node.authentication(), context);
        result.set(AUTHENTICATION, authJson);
    }
    if (node.sshAuthInfo() != null) {
        ObjectNode sshAuthJson = context.codec(OpenstackSshAuth.class).encode(node.sshAuthInfo(), context);
        result.set(SSH_AUTH, sshAuthJson);
    }
    return result;
}
#end_block

#method_before
@Override
public OpenstackNode decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String hostname = nullIsIllegal(json.get(HOST_NAME).asText(), HOST_NAME + MISSING_MESSAGE);
    String type = nullIsIllegal(json.get(TYPE).asText(), TYPE + MISSING_MESSAGE);
    String mIp = nullIsIllegal(json.get(MANAGEMENT_IP).asText(), MANAGEMENT_IP + MISSING_MESSAGE);
    DefaultOpenstackNode.Builder nodeBuilder = DefaultOpenstackNode.builder().hostname(hostname).type(OpenstackNode.NodeType.valueOf(type)).state(NodeState.INIT).managementIp(IpAddress.valueOf(mIp));
    if (type.equals(GATEWAY)) {
        nodeBuilder.uplinkPort(nullIsIllegal(json.get(UPLINK_PORT).asText(), UPLINK_PORT + MISSING_MESSAGE));
    }
    if (!type.equals(CONTROLLER)) {
        String iBridge = nullIsIllegal(json.get(INTEGRATION_BRIDGE).asText(), INTEGRATION_BRIDGE + MISSING_MESSAGE);
        nodeBuilder.intgBridge(DeviceId.deviceId(iBridge));
    } else {
        String endPoint = nullIsIllegal(json.get(END_POINT).asText(), END_POINT + MISSING_MESSAGE);
        nodeBuilder.endPoint(endPoint);
    }
    if (json.get(VLAN_INTF_NAME) != null) {
        nodeBuilder.vlanIntf(json.get(VLAN_INTF_NAME).asText());
    }
    if (json.get(DATA_IP) != null) {
        nodeBuilder.dataIp(IpAddress.valueOf(json.get(DATA_IP).asText()));
    }
    if (json.get(DATA_PATH_TYPE) == null) {
        nodeBuilder.dataPathType(OpenstackNode.DATA_PATH_TYPE_NORMAL);
    } else {
        nodeBuilder.dataPathType(json.get(DATA_PATH_TYPE).asText());
    }
    // parse physical interfaces
    List<OpenstackPhyInterface> phyIntfs = new ArrayList<>();
    JsonNode phyIntfsJson = json.get(PHYSICAL_INTERFACES);
    if (phyIntfsJson != null) {
        final JsonCodec<OpenstackPhyInterface> phyIntfCodec = context.codec(OpenstackPhyInterface.class);
        IntStream.range(0, phyIntfsJson.size()).forEach(i -> {
            ObjectNode intfJson = get(phyIntfsJson, i);
            phyIntfs.add(phyIntfCodec.decode(intfJson, context));
        });
    }
    nodeBuilder.phyIntfs(phyIntfs);
    // parse customized controllers
    List<ControllerInfo> controllers = new ArrayList<>();
    JsonNode controllersJson = json.get(CONTROLLERS);
    if (controllersJson != null) {
        final JsonCodec<ControllerInfo> controllerCodec = context.codec(ControllerInfo.class);
        IntStream.range(0, controllersJson.size()).forEach(i -> {
            ObjectNode controllerJson = get(controllersJson, i);
            controllers.add(controllerCodec.decode(controllerJson, context));
        });
    }
    nodeBuilder.controllers(controllers);
    // parse authentication
    JsonNode authJson = json.get(AUTHENTICATION);
    if (json.get(AUTHENTICATION) != null) {
        final JsonCodec<OpenstackAuth> authCodec = context.codec(OpenstackAuth.class);
        OpenstackAuth auth = authCodec.decode((ObjectNode) authJson.deepCopy(), context);
        nodeBuilder.authentication(auth);
    }
    // parse ssh authentication
    JsonNode sshAuthJson = json.get(SSH_AUTH);
    if (json.get(SSH_AUTH) != null) {
        final JsonCodec<OpenstackSshAuth> sshAuthJsonCodec = context.codec(OpenstackSshAuth.class);
        OpenstackSshAuth sshAuth = sshAuthJsonCodec.decode((ObjectNode) sshAuthJson.deepCopy(), context);
        nodeBuilder.sshAuthInfo(sshAuth);
    }
    log.trace("node is {}", nodeBuilder.build().toString());
    return nodeBuilder.build();
}
#method_after
@Override
public OpenstackNode decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String hostname = nullIsIllegal(json.get(HOST_NAME).asText(), HOST_NAME + MISSING_MESSAGE);
    String type = nullIsIllegal(json.get(TYPE).asText(), TYPE + MISSING_MESSAGE);
    String mIp = nullIsIllegal(json.get(MANAGEMENT_IP).asText(), MANAGEMENT_IP + MISSING_MESSAGE);
    DefaultOpenstackNode.Builder nodeBuilder = DefaultOpenstackNode.builder().hostname(hostname).type(OpenstackNode.NodeType.valueOf(type)).state(NodeState.INIT).managementIp(IpAddress.valueOf(mIp));
    if (type.equals(GATEWAY)) {
        nodeBuilder.uplinkPort(nullIsIllegal(json.get(UPLINK_PORT).asText(), UPLINK_PORT + MISSING_MESSAGE));
    }
    if (!type.equals(CONTROLLER)) {
        String iBridge = nullIsIllegal(json.get(INTEGRATION_BRIDGE).asText(), INTEGRATION_BRIDGE + MISSING_MESSAGE);
        nodeBuilder.intgBridge(DeviceId.deviceId(iBridge));
    } else {
        String endPoint = nullIsIllegal(json.get(END_POINT).asText(), END_POINT + MISSING_MESSAGE);
        nodeBuilder.endPoint(endPoint);
    }
    if (json.get(VLAN_INTF_NAME) != null) {
        nodeBuilder.vlanIntf(json.get(VLAN_INTF_NAME).asText());
    }
    if (json.get(DATA_IP) != null) {
        nodeBuilder.dataIp(IpAddress.valueOf(json.get(DATA_IP).asText()));
    }
    JsonNode datapathTypeJson = json.get(DATA_PATH_TYPE);
    if (datapathTypeJson == null || datapathTypeJson.asText().equals(OpenstackNode.DatapathType.NORMAL.name().toLowerCase())) {
        nodeBuilder.datapathType(OpenstackNode.DatapathType.NORMAL);
    } else if (datapathTypeJson.asText().equals(OpenstackNode.DatapathType.NETDEV.name().toLowerCase())) {
        nodeBuilder.datapathType(OpenstackNode.DatapathType.NETDEV);
    } else {
        throw new IllegalArgumentException(UNSUPPORTED_DATAPATH_TYPE + datapathTypeJson.asText());
    }
    // parse physical interfaces
    List<OpenstackPhyInterface> phyIntfs = new ArrayList<>();
    JsonNode phyIntfsJson = json.get(PHYSICAL_INTERFACES);
    if (phyIntfsJson != null) {
        final JsonCodec<OpenstackPhyInterface> phyIntfCodec = context.codec(OpenstackPhyInterface.class);
        IntStream.range(0, phyIntfsJson.size()).forEach(i -> {
            ObjectNode intfJson = get(phyIntfsJson, i);
            phyIntfs.add(phyIntfCodec.decode(intfJson, context));
        });
    }
    nodeBuilder.phyIntfs(phyIntfs);
    // parse customized controllers
    List<ControllerInfo> controllers = new ArrayList<>();
    JsonNode controllersJson = json.get(CONTROLLERS);
    if (controllersJson != null) {
        final JsonCodec<ControllerInfo> controllerCodec = context.codec(ControllerInfo.class);
        IntStream.range(0, controllersJson.size()).forEach(i -> {
            ObjectNode controllerJson = get(controllersJson, i);
            controllers.add(controllerCodec.decode(controllerJson, context));
        });
    }
    nodeBuilder.controllers(controllers);
    // parse authentication
    JsonNode authJson = json.get(AUTHENTICATION);
    if (json.get(AUTHENTICATION) != null) {
        final JsonCodec<OpenstackAuth> authCodec = context.codec(OpenstackAuth.class);
        OpenstackAuth auth = authCodec.decode((ObjectNode) authJson.deepCopy(), context);
        nodeBuilder.authentication(auth);
    }
    // parse ssh authentication
    JsonNode sshAuthJson = json.get(SSH_AUTH);
    if (json.get(SSH_AUTH) != null) {
        final JsonCodec<OpenstackSshAuth> sshAuthJsonCodec = context.codec(OpenstackSshAuth.class);
        OpenstackSshAuth sshAuth = sshAuthJsonCodec.decode((ObjectNode) sshAuthJson.deepCopy(), context);
        nodeBuilder.sshAuthInfo(sshAuth);
    }
    log.trace("node is {}", nodeBuilder.build().toString());
    return nodeBuilder.build();
}
#end_block

#method_before
private static OpenstackNode createNode(String hostname, OpenstackNode.NodeType type, Device intgBridge, IpAddress ipAddr, NodeState state, Set<OpenstackPhyInterface> phyIntfs, Set<ControllerInfo> controllers) {
    return new TestOpenstackNode(hostname, type, intgBridge.id(), ipAddr, ipAddr, null, null, state, phyIntfs, controllers, null, null, null, OpenstackNode.DATA_PATH_TYPE_NORMAL);
}
#method_after
private static OpenstackNode createNode(String hostname, OpenstackNode.NodeType type, Device intgBridge, IpAddress ipAddr, NodeState state, Set<OpenstackPhyInterface> phyIntfs, Set<ControllerInfo> controllers) {
    return new TestOpenstackNode(hostname, type, intgBridge.id(), ipAddr, ipAddr, null, null, state, phyIntfs, controllers, null, null, null, OpenstackNode.DatapathType.NORMAL);
}
#end_block

#method_before
private static OpenstackNode createGatewayNode(String hostname, OpenstackNode.NodeType type, Device intgBridge, IpAddress ipAddr, String uplinkPort, NodeState state) {
    return new TestOpenstackNode(hostname, type, intgBridge.id(), ipAddr, ipAddr, null, uplinkPort, state, null, null, null, null, null, OpenstackNode.DATA_PATH_TYPE_NORMAL);
}
#method_after
private static OpenstackNode createGatewayNode(String hostname, OpenstackNode.NodeType type, Device intgBridge, IpAddress ipAddr, String uplinkPort, NodeState state) {
    return new TestOpenstackNode(hostname, type, intgBridge.id(), ipAddr, ipAddr, null, uplinkPort, state, null, null, null, null, null, OpenstackNode.DatapathType.NORMAL);
}
#end_block

#method_before
@Test
public void testOpenstackComputeNodeDecode() throws IOException {
    OpenstackNode node = getOpenstackNode("OpenstackComputeNode.json");
    assertThat(node.hostname(), is("compute-01"));
    assertThat(node.type().name(), is("COMPUTE"));
    assertThat(node.managementIp().toString(), is("172.16.130.4"));
    assertThat(node.dataIp().toString(), is("172.16.130.4"));
    assertThat(node.intgBridge().toString(), is("of:00000000000000a1"));
    assertThat(node.vlanIntf(), is("eth2"));
    assertThat(node.phyIntfs().size(), is(2));
    assertThat(node.controllers().size(), is(2));
    assertThat(node.sshAuthInfo().id(), is("sdn"));
    assertThat(node.sshAuthInfo().password(), is("sdn"));
    assertThat(node.dataPathType(), is(OpenstackNode.DATA_PATH_TYPE_NORMAL));
    node.phyIntfs().forEach(intf -> {
        if (intf.network().equals("mgmtnetwork")) {
            assertThat(intf.intf(), is("eth3"));
        }
        if (intf.network().equals("oamnetwork")) {
            assertThat(intf.intf(), is("eth4"));
        }
    });
    node.controllers().forEach(ctrl -> {
        if (ctrl.ip().toString().equals("10.10.10.2")) {
            assertThat(ctrl.port(), is(6653));
        }
        if (ctrl.ip().toString().equals("10.10.10.3")) {
            assertThat(ctrl.port(), is(6663));
        }
    });
    OpenstackNode dpdkNode = getOpenstackNode("OpenstackDpdkComputeNode.json");
    assertThat(dpdkNode.dataPathType(), is(OpenstackNode.DATA_PATH_TYPE_NETDEV));
}
#method_after
@Test
public void testOpenstackComputeNodeDecode() throws IOException {
    OpenstackNode node = getOpenstackNode("OpenstackComputeNode.json");
    assertThat(node.hostname(), is("compute-01"));
    assertThat(node.type().name(), is("COMPUTE"));
    assertThat(node.managementIp().toString(), is("172.16.130.4"));
    assertThat(node.dataIp().toString(), is("172.16.130.4"));
    assertThat(node.intgBridge().toString(), is("of:00000000000000a1"));
    assertThat(node.vlanIntf(), is("eth2"));
    assertThat(node.phyIntfs().size(), is(2));
    assertThat(node.controllers().size(), is(2));
    assertThat(node.sshAuthInfo().id(), is("sdn"));
    assertThat(node.sshAuthInfo().password(), is("sdn"));
    assertThat(node.datapathType(), is(OpenstackNode.DatapathType.NORMAL));
    node.phyIntfs().forEach(intf -> {
        if (intf.network().equals("mgmtnetwork")) {
            assertThat(intf.intf(), is("eth3"));
        }
        if (intf.network().equals("oamnetwork")) {
            assertThat(intf.intf(), is("eth4"));
        }
    });
    node.controllers().forEach(ctrl -> {
        if (ctrl.ip().toString().equals("10.10.10.2")) {
            assertThat(ctrl.port(), is(6653));
        }
        if (ctrl.ip().toString().equals("10.10.10.3")) {
            assertThat(ctrl.port(), is(6663));
        }
    });
    OpenstackNode dpdkNode = getOpenstackNode("OpenstackDpdkComputeNode.json");
    assertThat(dpdkNode.datapathType(), is(OpenstackNode.DatapathType.NETDEV));
}
#end_block

#method_before
public static OpenstackNode getGwByInstancePort(Set<OpenstackNode> gateways, InstancePort instPort) {
    OpenstackNode gw = null;
    if (instPort != null) {
        gw = getGwByComputeDevId(gateways, instPort.deviceId());
    }
    return gw;
}
#method_after
public static OpenstackNode getGwByInstancePort(Set<OpenstackNode> gateways, InstancePort instPort) {
    OpenstackNode gw = null;
    if (instPort != null && instPort.deviceId() != null) {
        gw = getGwByComputeDevId(gateways, instPort.deviceId());
    }
    return gw;
}
#end_block

#method_before
@Before
public void setUp() {
    instancePort1 = DefaultInstancePort.builder().networkId("net-id-1").portId("ce705c24-c1ef-408a-bda3-7bbd946164ab").deviceId(DeviceId.deviceId("of:000000000000000a")).portNumber(PortNumber.portNumber(1, "tap-1")).ipAddress(IpAddress.valueOf("10.0.0.3")).macAddress(MacAddress.valueOf("11:22:33:44:55:66")).state(InstancePort.State.valueOf("ACTIVE")).build();
    instancePort2 = DefaultInstancePort.builder().networkId("net-id-2").portId("port-id-2").deviceId(DeviceId.deviceId("of:000000000000000b")).portNumber(PortNumber.portNumber(2, "tap-2")).ipAddress(IpAddress.valueOf("10.10.10.2")).macAddress(MacAddress.valueOf("22:33:44:55:66:11")).state(InstancePort.State.valueOf("ACTIVE")).build();
    instancePort3 = DefaultInstancePort.builder().networkId("net-id-3").portId("port-id-3").deviceId(DeviceId.deviceId("of:000000000000000c")).oldDeviceId(DeviceId.deviceId("of:000000000000000d")).oldPortNumber(PortNumber.portNumber(4, "tap-4")).portNumber(PortNumber.portNumber(3, "tap-3")).ipAddress(IpAddress.valueOf("10.10.10.3")).macAddress(MacAddress.valueOf("33:44:55:66:11:22")).state(InstancePort.State.valueOf("ACTIVE")).build();
    InputStream floatingIpjsonStream1 = OpenstackFloatingIpWebResourceTest.class.getResourceAsStream("openstack-floatingip1.json");
    InputStream floatingIpjsonStream2 = OpenstackFloatingIpWebResourceTest.class.getResourceAsStream("openstack-floatingip2.json");
    InputStream floatingIpjsonStream3 = OpenstackFloatingIpWebResourceTest.class.getResourceAsStream("openstack-floatingip3.json");
    floatingIp1 = (NetFloatingIP) OpenstackNetworkingUtil.jsonToModelEntity(floatingIpjsonStream1, NeutronFloatingIP.class);
    floatingIp2 = (NetFloatingIP) OpenstackNetworkingUtil.jsonToModelEntity(floatingIpjsonStream2, NeutronFloatingIP.class);
    floatingIp3 = (NetFloatingIP) OpenstackNetworkingUtil.jsonToModelEntity(floatingIpjsonStream3, NeutronFloatingIP.class);
    InputStream portJsonStream = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port.json");
    InputStream sriovPortJsonStream1 = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port-sriov1.json");
    InputStream sriovPortJsonStream2 = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port-sriov2.json");
    InputStream sriovPortJsonStream3 = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port-sriov3.json");
    openstackPort = (Port) OpenstackNetworkingUtil.jsonToModelEntity(portJsonStream, NeutronPort.class);
    openstackSriovPort1 = (Port) OpenstackNetworkingUtil.jsonToModelEntity(sriovPortJsonStream1, NeutronPort.class);
    openstackSriovPort2 = (Port) OpenstackNetworkingUtil.jsonToModelEntity(sriovPortJsonStream2, NeutronPort.class);
    openstackSriovPort3 = (Port) OpenstackNetworkingUtil.jsonToModelEntity(sriovPortJsonStream3, NeutronPort.class);
}
#method_after
@Before
public void setUp() {
    instancePort1 = DefaultInstancePort.builder().networkId("net-id-1").portId("ce705c24-c1ef-408a-bda3-7bbd946164ab").deviceId(DeviceId.deviceId("of:000000000000000a")).portNumber(PortNumber.portNumber(1, "tap-1")).ipAddress(IpAddress.valueOf("10.0.0.3")).macAddress(MacAddress.valueOf("11:22:33:44:55:66")).state(InstancePort.State.valueOf("ACTIVE")).build();
    instancePort2 = DefaultInstancePort.builder().networkId("net-id-2").portId("port-id-2").deviceId(DeviceId.deviceId("of:000000000000000b")).portNumber(PortNumber.portNumber(2, "tap-2")).ipAddress(IpAddress.valueOf("10.10.10.2")).macAddress(MacAddress.valueOf("22:33:44:55:66:11")).state(InstancePort.State.valueOf("ACTIVE")).build();
    instancePort3 = DefaultInstancePort.builder().networkId("net-id-3").portId("port-id-3").deviceId(DeviceId.deviceId("of:000000000000000c")).oldDeviceId(DeviceId.deviceId("of:000000000000000d")).oldPortNumber(PortNumber.portNumber(4, "tap-4")).portNumber(PortNumber.portNumber(3, "tap-3")).ipAddress(IpAddress.valueOf("10.10.10.3")).macAddress(MacAddress.valueOf("33:44:55:66:11:22")).state(InstancePort.State.valueOf("ACTIVE")).build();
    InputStream floatingIpjsonStream1 = OpenstackFloatingIpWebResourceTest.class.getResourceAsStream("openstack-floatingip1.json");
    InputStream floatingIpjsonStream2 = OpenstackFloatingIpWebResourceTest.class.getResourceAsStream("openstack-floatingip2.json");
    InputStream floatingIpjsonStream3 = OpenstackFloatingIpWebResourceTest.class.getResourceAsStream("openstack-floatingip3.json");
    floatingIp1 = (NetFloatingIP) jsonToModelEntity(floatingIpjsonStream1, NeutronFloatingIP.class);
    floatingIp2 = (NetFloatingIP) jsonToModelEntity(floatingIpjsonStream2, NeutronFloatingIP.class);
    floatingIp3 = (NetFloatingIP) jsonToModelEntity(floatingIpjsonStream3, NeutronFloatingIP.class);
    InputStream portJsonStream = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port.json");
    InputStream sriovPortJsonStream1 = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port-sriov1.json");
    InputStream sriovPortJsonStream2 = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port-sriov2.json");
    InputStream sriovPortJsonStream3 = OpenstackNetworkWebResourceTest.class.getResourceAsStream("openstack-port-sriov3.json");
    openstackPort = (Port) jsonToModelEntity(portJsonStream, NeutronPort.class);
    openstackSriovPort1 = (Port) jsonToModelEntity(sriovPortJsonStream1, NeutronPort.class);
    openstackSriovPort2 = (Port) jsonToModelEntity(sriovPortJsonStream2, NeutronPort.class);
    openstackSriovPort3 = (Port) jsonToModelEntity(sriovPortJsonStream3, NeutronPort.class);
}
#end_block

#method_before
@Test
public void testFloatingIp() throws IOException {
    ObjectNode floatingIpNode = OpenstackNetworkingUtil.modelEntityToJson(floatingIp1, NeutronFloatingIP.class);
    InputStream is = IOUtils.toInputStream(floatingIpNode.toString(), StandardCharsets.UTF_8.name());
    NetFloatingIP floatingIp2 = (NetFloatingIP) OpenstackNetworkingUtil.jsonToModelEntity(is, NeutronFloatingIP.class);
    new EqualsTester().addEqualityGroup(floatingIp1, floatingIp2).testEquals();
}
#method_after
@Test
public void testFloatingIp() throws IOException {
    ObjectNode floatingIpNode = modelEntityToJson(floatingIp1, NeutronFloatingIP.class);
    InputStream is = IOUtils.toInputStream(floatingIpNode.toString(), StandardCharsets.UTF_8.name());
    NetFloatingIP floatingIp2 = (NetFloatingIP) jsonToModelEntity(is, NeutronFloatingIP.class);
    new EqualsTester().addEqualityGroup(floatingIp1, floatingIp2).testEquals();
}
#end_block

#method_before
@Test
public void testAsscoatedFloatingIp() throws NullPointerException {
    Set<NetFloatingIP> testSet = Sets.newHashSet();
    testSet.add(floatingIp1);
    testSet.add(floatingIp2);
    testSet.add(floatingIp3);
    NetFloatingIP floatingIp1 = OpenstackNetworkingUtil.associatedFloatingIp(instancePort1, testSet);
    NetFloatingIP floatingIp2 = OpenstackNetworkingUtil.associatedFloatingIp(instancePort2, testSet);
    assertEquals(floatingIp1, this.floatingIp1);
    assertEquals(floatingIp2, null);
}
#method_after
@Test
public void testAsscoatedFloatingIp() throws NullPointerException {
    Set<NetFloatingIP> testSet = Sets.newHashSet();
    testSet.add(floatingIp1);
    testSet.add(floatingIp2);
    testSet.add(floatingIp3);
    NetFloatingIP floatingIp1 = associatedFloatingIp(instancePort1, testSet);
    NetFloatingIP floatingIp2 = associatedFloatingIp(instancePort2, testSet);
    assertEquals(floatingIp1, this.floatingIp1);
    assertEquals(floatingIp2, null);
}
#end_block

#method_before
@Test
public void testIsAssociatedWithVM() {
    OpenstackNetworkService service = new TestOpenstackNetworkService();
    NetFloatingIP floatingIp4 = new NeutronFloatingIP().toBuilder().portId("portId4").build();
    assertFalse(OpenstackNetworkingUtil.isAssociatedWithVM(service, floatingIp4));
    assertFalse(OpenstackNetworkingUtil.isAssociatedWithVM(service, floatingIp3));
    assertTrue(OpenstackNetworkingUtil.isAssociatedWithVM(service, floatingIp1));
}
#method_after
@Test
public void testIsAssociatedWithVM() {
    OpenstackNetworkService service = new TestOpenstackNetworkService();
    NetFloatingIP floatingIp4 = new NeutronFloatingIP().toBuilder().portId("portId4").build();
    assertFalse(isAssociatedWithVM(service, floatingIp4));
    assertFalse(isAssociatedWithVM(service, floatingIp3));
    assertTrue(isAssociatedWithVM(service, floatingIp1));
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void testIsAssociatedWithVMexceptionCase() {
    OpenstackNetworkService service = new TestOpenstackNetworkService();
    OpenstackNetworkingUtil.isAssociatedWithVM(service, floatingIp2);
}
#method_after
@Test(expected = IllegalStateException.class)
public void testIsAssociatedWithVMexceptionCase() {
    OpenstackNetworkService service = new TestOpenstackNetworkService();
    isAssociatedWithVM(service, floatingIp2);
}
#end_block

#method_before
@Test
public void testGetGwByInstancePort() {
    Set<OpenstackNode> gws = Sets.newConcurrentHashSet();
    gws.add(genGateway(1));
    gws.add(genGateway(2));
    gws.add(genGateway(3));
    int expectedGwIndex = 2;
    OpenstackNode gw = OpenstackNetworkingUtil.getGwByInstancePort(gws, instancePort1);
    assertEquals(genGateway(expectedGwIndex), gw);
    assertNull(OpenstackNetworkingUtil.getGwByInstancePort(gws, null));
}
#method_after
@Test
public void testGetGwByInstancePort() {
    Set<OpenstackNode> gws = Sets.newConcurrentHashSet();
    gws.add(genGateway(1));
    gws.add(genGateway(2));
    gws.add(genGateway(3));
    int expectedGwIndex = 2;
    OpenstackNode gw = getGwByInstancePort(gws, instancePort1);
    assertEquals(genGateway(expectedGwIndex), gw);
    assertNull(getGwByInstancePort(gws, null));
}
#end_block

#method_before
@Test
public void testGetIntfNameFromPciAddress() {
    String expectedIntfName1 = "enp5s8";
    String expectedIntfName2 = "enp5s8f3";
    assertNull(OpenstackNetworkingUtil.getIntfNameFromPciAddress(openstackPort));
    assertEquals(expectedIntfName1, OpenstackNetworkingUtil.getIntfNameFromPciAddress(openstackSriovPort1));
    assertEquals(expectedIntfName2, OpenstackNetworkingUtil.getIntfNameFromPciAddress(openstackSriovPort2));
    assertNull(OpenstackNetworkingUtil.getIntfNameFromPciAddress(openstackSriovPort3));
}
#method_after
@Test
public void testGetIntfNameFromPciAddress() {
    String expectedIntfName1 = "enp5s8";
    String expectedIntfName2 = "enp5s8f3";
    assertNull(getIntfNameFromPciAddress(openstackPort));
    assertEquals(expectedIntfName1, getIntfNameFromPciAddress(openstackSriovPort1));
    assertEquals(expectedIntfName2, getIntfNameFromPciAddress(openstackSriovPort2));
    assertNull(getIntfNameFromPciAddress(openstackSriovPort3));
}
#end_block

#method_before
@Test
public void testSwapStaleLocation() {
    InstancePort swappedInstancePort = OpenstackNetworkingUtil.swapStaleLocation(instancePort3);
    assertEquals(instancePort3.oldDeviceId(), swappedInstancePort.deviceId());
    assertEquals(instancePort3.oldPortNumber(), swappedInstancePort.portNumber());
}
#method_after
@Test
public void testSwapStaleLocation() {
    InstancePort swappedInstancePort = swapStaleLocation(instancePort3);
    assertEquals(instancePort3.oldDeviceId(), swappedInstancePort.deviceId());
    assertEquals(instancePort3.oldPortNumber(), swappedInstancePort.portNumber());
}
#end_block

#method_before
@Test
public void testAddRouterIface() {
    OpenstackRouterAdminService service = new TestOpenstackRouterAdminService();
    OpenstackNetworkingUtil.addRouterIface(openstackPort, service);
    RouterInterface initialRouterInterface = new TestRouterInterface(openstackPort.getDeviceId(), openstackPort.getFixedIps().stream().findAny().get().getSubnetId(), openstackPort.getId(), openstackPort.getTenantId());
    routerInterfacesEquals(initialRouterInterface, service.routerInterface(openstackPort.getId()));
    OpenstackNetworkingUtil.addRouterIface(openstackSriovPort1, service);
    RouterInterface updatedInitialRouterInterface = new TestRouterInterface(openstackSriovPort1.getDeviceId(), openstackSriovPort1.getFixedIps().stream().findAny().get().getSubnetId(), openstackSriovPort1.getId(), openstackSriovPort1.getTenantId());
    routerInterfacesEquals(updatedInitialRouterInterface, service.routerInterface(openstackSriovPort1.getId()));
}
#method_after
@Test
public void testAddRouterIface() {
    OpenstackRouterAdminService service = new TestOpenstackRouterAdminService();
    addRouterIface(openstackPort, service);
    RouterInterface initialRouterInterface = new TestRouterInterface(openstackPort.getDeviceId(), openstackPort.getFixedIps().stream().findAny().get().getSubnetId(), openstackPort.getId(), openstackPort.getTenantId());
    assertTrue(routerInterfacesEquals(initialRouterInterface, service.routerInterface(openstackPort.getId())));
    addRouterIface(openstackSriovPort1, service);
    RouterInterface updatedInitialRouterInterface = new TestRouterInterface(openstackSriovPort1.getDeviceId(), openstackSriovPort1.getFixedIps().stream().findAny().get().getSubnetId(), openstackSriovPort1.getId(), openstackSriovPort1.getTenantId());
    assertTrue(routerInterfacesEquals(updatedInitialRouterInterface, service.routerInterface(openstackSriovPort1.getId())));
}
#end_block

#method_before
private OpenstackNode genGateway(int index) {
    Device intgBrg = InternalOpenstackNodeTest.createDevice(index);
    String hostname = "gateway-" + index;
    IpAddress ip = Ip4Address.valueOf("10.10.10." + index);
    NodeState state = NodeState.COMPLETE;
    String uplinkPort = "eth0";
    return InternalOpenstackNodeTest.createNode(hostname, OpenstackNode.NodeType.GATEWAY, intgBrg, ip, uplinkPort, state);
}
#method_after
public OpenstackNode genGateway(int index) {
    Device intgBrg = InternalOpenstackNodeTest.createDevice(index);
    String hostname = "gateway-" + index;
    IpAddress ip = Ip4Address.valueOf("10.10.10." + index);
    NodeState state = NodeState.COMPLETE;
    String uplinkPort = "eth0";
    return InternalOpenstackNodeTest.createNode(hostname, OpenstackNode.NodeType.GATEWAY, intgBrg, ip, uplinkPort, state);
}
#end_block

#method_before
@Test
public void testPrettyJson() {
    String string = OpenstackNetworkingUtil.prettyJson(new ObjectMapper(), "{\"json\":\"json\"}");
    String prettyJsonString = "{\n  \"json\" : \"json\"\n}";
    assertEquals(string, prettyJsonString);
    assertNull(OpenstackNetworkingUtil.prettyJson(new ObjectMapper(), "{\"json\":\"json\""));
    assertNull(OpenstackNetworkingUtil.prettyJson(new ObjectMapper(), "{\"json\"\"json\"}"));
}
#method_after
@Test
public void testPrettyJson() {
    String string = prettyJson(new ObjectMapper(), "{\"json\":\"json\"}");
    String prettyJsonString = "{\n  \"json\" : \"json\"\n}";
    assertEquals(string, prettyJsonString);
    assertNull(prettyJson(new ObjectMapper(), "{\"json\":\"json\""));
    assertNull(prettyJson(new ObjectMapper(), "{\"json\"\"json\"}"));
}
#end_block

#method_before
@Test
public void testCheckArpMode() {
    assertFalse(OpenstackNetworkingUtil.checkArpMode(null));
    assertTrue(OpenstackNetworkingUtil.checkArpMode("proxy"));
    assertTrue(OpenstackNetworkingUtil.checkArpMode("broadcast"));
}
#method_after
@Test
public void testCheckArpMode() {
    assertFalse(checkArpMode(null));
    assertTrue(checkArpMode("proxy"));
    assertTrue(checkArpMode("broadcast"));
}
#end_block

#method_before
@Test(expected = Exception.class)
public void testGetConnectedClient() {
    OpenstackNode.Builder osNodeBuilderV2 = DefaultOpenstackNode.builder();
    OpenstackAuth.Builder osNodeAuthBuilderV2 = DefaultOpenstackAuth.builder().version("v2.0").port(35357).protocol(OpenstackAuth.Protocol.HTTP).project("admin").username("admin").password("password").perspective(OpenstackAuth.Perspective.PUBLIC);
    openstackControlNodeV2 = osNodeBuilderV2.hostname("controllerv2").type(OpenstackNode.NodeType.CONTROLLER).managementIp(IpAddress.valueOf("1.1.1.1")).endPoint("1.1.1.1").authentication(osNodeAuthBuilderV2.build()).state(NodeState.COMPLETE).build();
    OpenstackNode.Builder osNodeBuilderV3 = DefaultOpenstackNode.builder();
    OpenstackAuth.Builder osNodeAuthBuilderV3 = DefaultOpenstackAuth.builder().version("v2").port(80).protocol(OpenstackAuth.Protocol.HTTP).project("admin").username("admin").password("password").perspective(OpenstackAuth.Perspective.PUBLIC);
    openstackControlNodeV3 = osNodeBuilderV3.hostname("controllerv3").type(OpenstackNode.NodeType.CONTROLLER).managementIp(IpAddress.valueOf("2.2.2.2")).endPoint("2.2.2.2").authentication(osNodeAuthBuilderV3.build()).state(NodeState.COMPLETE).build();
    OpenstackNetworkingUtil.getConnectedClient(openstackControlNodeV2);
    OpenstackNetworkingUtil.getConnectedClient(openstackControlNodeV3);
}
#method_after
@Test(expected = Exception.class)
public void testGetConnectedClient() {
    OpenstackNode.Builder osNodeBuilderV2 = DefaultOpenstackNode.builder();
    OpenstackAuth.Builder osNodeAuthBuilderV2 = DefaultOpenstackAuth.builder().version("v2.0").port(35357).protocol(OpenstackAuth.Protocol.HTTP).project("admin").username("admin").password("password").perspective(OpenstackAuth.Perspective.PUBLIC);
    openstackControlNodeV2 = osNodeBuilderV2.hostname("controllerv2").type(OpenstackNode.NodeType.CONTROLLER).managementIp(IpAddress.valueOf("1.1.1.1")).endPoint("1.1.1.1").authentication(osNodeAuthBuilderV2.build()).state(NodeState.COMPLETE).build();
    OpenstackNode.Builder osNodeBuilderV3 = DefaultOpenstackNode.builder();
    OpenstackAuth.Builder osNodeAuthBuilderV3 = DefaultOpenstackAuth.builder().version("v2").port(80).protocol(OpenstackAuth.Protocol.HTTP).project("admin").username("admin").password("password").perspective(OpenstackAuth.Perspective.PUBLIC);
    openstackControlNodeV3 = osNodeBuilderV3.hostname("controllerv3").type(OpenstackNode.NodeType.CONTROLLER).managementIp(IpAddress.valueOf("2.2.2.2")).endPoint("2.2.2.2").authentication(osNodeAuthBuilderV3.build()).state(NodeState.COMPLETE).build();
    getConnectedClient(openstackControlNodeV2);
    getConnectedClient(openstackControlNodeV3);
}
#end_block

#method_before
@Override
public Set<FlowInfo> getFlowInfos() {
    Set<FlowInfo> flowInfos = Sets.newConcurrentHashSet();
    // obtain all flow rule entries installed by telemetry app
    for (FlowEntry entry : flowRuleService.getFlowEntriesById(appId)) {
        FlowInfo.Builder fBuilder = new DefaultFlowInfo.DefaultBuilder();
        TrafficSelector selector = entry.selector();
        IPCriterion srcIp = (IPCriterion) selector.getCriterion(IPV4_SRC);
        IPCriterion dstIp = (IPCriterion) selector.getCriterion(IPV4_DST);
        IPProtocolCriterion ipProtocol = (IPProtocolCriterion) selector.getCriterion(IP_PROTO);
        log.debug("[FlowInfo]  TableID:{}  SRC_IP:{}  DST_IP:{}  Pkt:{}  Byte:{}", ((IndexTableId) entry.table()).id(), srcIp.ip().toString(), dstIp.ip().toString(), entry.packets(), entry.bytes());
        fBuilder.withFlowType(FLOW_TYPE_SONA).withSrcIp(srcIp.ip()).withDstIp(dstIp.ip());
        if (ipProtocol != null) {
            fBuilder.withProtocol((byte) ipProtocol.protocol());
            if (ipProtocol.protocol() == PROTOCOL_TCP) {
                TcpPortCriterion tcpSrc = (TcpPortCriterion) selector.getCriterion(TCP_SRC);
                TcpPortCriterion tcpDst = (TcpPortCriterion) selector.getCriterion(TCP_DST);
                log.debug("TCP SRC Port: {}, DST Port: {}", tcpSrc.tcpPort().toInt(), tcpDst.tcpPort().toInt());
                fBuilder.withSrcPort(tcpSrc.tcpPort());
                fBuilder.withDstPort(tcpDst.tcpPort());
            } else if (ipProtocol.protocol() == PROTOCOL_UDP) {
                UdpPortCriterion udpSrc = (UdpPortCriterion) selector.getCriterion(UDP_SRC);
                UdpPortCriterion udpDst = (UdpPortCriterion) selector.getCriterion(UDP_DST);
                log.debug("UDP SRC Port: {}, DST Port: {}", udpSrc.udpPort().toInt(), udpDst.udpPort().toInt());
                fBuilder.withSrcPort(udpSrc.udpPort());
                fBuilder.withDstPort(udpDst.udpPort());
            } else {
                log.debug("Other protocol: {}", ipProtocol.protocol());
            }
        }
        fBuilder.withSrcMac(getMacAddress(srcIp.ip().address())).withDstMac(getMacAddress(dstIp.ip().address())).withInputInterfaceId(getInterfaceId(srcIp.ip().address())).withOutputInterfaceId(getInterfaceId(dstIp.ip().address())).withVlanId(getVlanId(srcIp.ip().address())).withDeviceId(entry.deviceId());
        StatsInfo.Builder sBuilder = new DefaultStatsInfo.DefaultBuilder();
        // TODO: need to collect error and drop packets stats
        // TODO: need to make the refresh interval configurable
        sBuilder.withStartupTime(System.currentTimeMillis()).withFstPktArrTime(System.currentTimeMillis()).withLstPktOffset((int) (REFRESH_INTERVAL * MILLISECONDS)).withCurrAccPkts((int) entry.packets()).withCurrAccBytes(entry.bytes()).withErrorPkts((short) 0).withDropPkts((short) 0);
        fBuilder.withStatsInfo(sBuilder.build());
        FlowInfo flowInfo = mergeFlowInfo(fBuilder.build(), fBuilder, sBuilder);
        flowInfos.add(flowInfo);
        log.debug("FlowInfo: \n{}", flowInfo.toString());
    }
    return flowInfos;
}
#method_after
@Override
public Set<FlowInfo> getFlowInfos() {
    Set<FlowInfo> flowInfos = Sets.newConcurrentHashSet();
    // obtain all flow rule entries installed by telemetry app
    for (FlowEntry entry : flowRuleService.getFlowEntriesById(appId)) {
        FlowInfo.Builder fBuilder = new DefaultFlowInfo.DefaultBuilder();
        TrafficSelector selector = entry.selector();
        IPCriterion srcIp = (IPCriterion) selector.getCriterion(IPV4_SRC);
        IPCriterion dstIp = (IPCriterion) selector.getCriterion(IPV4_DST);
        IPProtocolCriterion ipProtocol = (IPProtocolCriterion) selector.getCriterion(IP_PROTO);
        fBuilder.withFlowType(FLOW_TYPE_SONA).withSrcIp(srcIp.ip()).withDstIp(dstIp.ip());
        if (ipProtocol != null) {
            fBuilder.withProtocol((byte) ipProtocol.protocol());
            if (ipProtocol.protocol() == PROTOCOL_TCP) {
                TcpPortCriterion tcpSrc = (TcpPortCriterion) selector.getCriterion(TCP_SRC);
                TcpPortCriterion tcpDst = (TcpPortCriterion) selector.getCriterion(TCP_DST);
                fBuilder.withSrcPort(tcpSrc.tcpPort());
                fBuilder.withDstPort(tcpDst.tcpPort());
            } else if (ipProtocol.protocol() == PROTOCOL_UDP) {
                UdpPortCriterion udpSrc = (UdpPortCriterion) selector.getCriterion(UDP_SRC);
                UdpPortCriterion udpDst = (UdpPortCriterion) selector.getCriterion(UDP_DST);
                fBuilder.withSrcPort(udpSrc.udpPort());
                fBuilder.withDstPort(udpDst.udpPort());
            } else {
                log.debug("Other protocol: {}", ipProtocol.protocol());
            }
        }
        fBuilder.withSrcMac(getMacAddress(srcIp.ip().address())).withDstMac(getMacAddress(dstIp.ip().address())).withInputInterfaceId(getInterfaceId(srcIp.ip().address())).withOutputInterfaceId(getInterfaceId(dstIp.ip().address())).withVlanId(getVlanId(srcIp.ip().address())).withDeviceId(entry.deviceId());
        StatsInfo.Builder sBuilder = new DefaultStatsInfo.DefaultBuilder();
        // TODO: need to collect error and drop packets stats
        // TODO: need to make the refresh interval configurable
        sBuilder.withStartupTime(System.currentTimeMillis()).withFstPktArrTime(System.currentTimeMillis()).withLstPktOffset((int) (REFRESH_INTERVAL * MILLISECONDS)).withCurrAccPkts((int) entry.packets()).withCurrAccBytes(entry.bytes()).withErrorPkts((short) 0).withDropPkts((short) 0);
        fBuilder.withStatsInfo(sBuilder.build());
        FlowInfo flowInfo = mergeFlowInfo(fBuilder.build(), fBuilder, sBuilder);
        flowInfos.add(flowInfo);
        log.debug("FlowInfo: \n{}", flowInfo.toString());
    }
    return flowInfos;
}
#end_block

#method_before
private FlowInfo buildTxPortInfo(InstancePort instPort, PortStatistics stat) {
    FlowInfo.Builder fBuilder = new DefaultFlowInfo.DefaultBuilder();
    fBuilder.withFlowType(FLOW_TYPE_SONA).withSrcIp(IpPrefix.valueOf(instPort.ipAddress(), ARBITRARY_LENGTH)).withDstIp(IpPrefix.valueOf(ARBITRARY_IP)).withSrcMac(instPort.macAddress()).withDstMac(MacAddress.valueOf(ARBITRARY_MAC)).withDeviceId(instPort.deviceId()).withInputInterfaceId(ARBITRARY_IN_INTF).withOutputInterfaceId(ARBITRARY_OUT_INTF).withVlanId(VlanId.vlanId());
    StatsInfo.Builder sBuilder = new DefaultStatsInfo.DefaultBuilder();
    sBuilder.withStartupTime(System.currentTimeMillis()).withFstPktArrTime(System.currentTimeMillis()).withLstPktOffset((int) (REFRESH_INTERVAL * MILLISECONDS)).withCurrAccPkts((int) stat.packetsSent()).withCurrAccBytes(stat.bytesSent()).withErrorPkts((short) stat.packetsTxErrors()).withDropPkts((short) stat.packetsTxDropped());
    fBuilder.withStatsInfo(sBuilder.build());
    return mergeFlowInfo(fBuilder.build(), fBuilder, sBuilder);
}
#method_after
private FlowInfo buildTxPortInfo(InstancePort instPort, PortStatistics stat) {
    FlowInfo.Builder fBuilder = new DefaultFlowInfo.DefaultBuilder();
    fBuilder.withFlowType(FLOW_TYPE_SONA).withSrcIp(IpPrefix.valueOf(instPort.ipAddress(), ARBITRARY_LENGTH)).withDstIp(IpPrefix.valueOf(ARBITRARY_IP)).withSrcMac(instPort.macAddress()).withDstMac(NO_HOST_MAC).withDeviceId(instPort.deviceId()).withInputInterfaceId(ARBITRARY_IN_INTF).withOutputInterfaceId(ARBITRARY_OUT_INTF).withVlanId(VlanId.vlanId());
    StatsInfo.Builder sBuilder = new DefaultStatsInfo.DefaultBuilder();
    sBuilder.withStartupTime(System.currentTimeMillis()).withFstPktArrTime(System.currentTimeMillis()).withLstPktOffset((int) (REFRESH_INTERVAL * MILLISECONDS)).withCurrAccPkts((int) stat.packetsSent()).withCurrAccBytes(stat.bytesSent()).withErrorPkts((short) stat.packetsTxErrors()).withDropPkts((short) stat.packetsTxDropped());
    fBuilder.withStatsInfo(sBuilder.build());
    return mergeFlowInfo(fBuilder.build(), fBuilder, sBuilder);
}
#end_block

#method_before
private FlowInfo buildRxPortInfo(InstancePort instPort, PortStatistics stat) {
    FlowInfo.Builder fBuilder = new DefaultFlowInfo.DefaultBuilder();
    fBuilder.withFlowType(FLOW_TYPE_SONA).withSrcIp(IpPrefix.valueOf(ARBITRARY_IP)).withDstIp(IpPrefix.valueOf(instPort.ipAddress(), ARBITRARY_LENGTH)).withSrcMac(MacAddress.valueOf(ARBITRARY_MAC)).withDstMac(instPort.macAddress()).withDeviceId(instPort.deviceId()).withInputInterfaceId(ARBITRARY_IN_INTF).withOutputInterfaceId(ARBITRARY_OUT_INTF).withVlanId(VlanId.vlanId());
    StatsInfo.Builder sBuilder = new DefaultStatsInfo.DefaultBuilder();
    sBuilder.withStartupTime(System.currentTimeMillis()).withFstPktArrTime(System.currentTimeMillis()).withLstPktOffset((int) (REFRESH_INTERVAL * MILLISECONDS)).withCurrAccPkts((int) stat.packetsReceived()).withCurrAccBytes(stat.bytesReceived()).withErrorPkts((short) stat.packetsRxErrors()).withDropPkts((short) stat.packetsRxDropped());
    fBuilder.withStatsInfo(sBuilder.build());
    return mergeFlowInfo(fBuilder.build(), fBuilder, sBuilder);
}
#method_after
private FlowInfo buildRxPortInfo(InstancePort instPort, PortStatistics stat) {
    FlowInfo.Builder fBuilder = new DefaultFlowInfo.DefaultBuilder();
    fBuilder.withFlowType(FLOW_TYPE_SONA).withSrcIp(IpPrefix.valueOf(ARBITRARY_IP)).withDstIp(IpPrefix.valueOf(instPort.ipAddress(), ARBITRARY_LENGTH)).withSrcMac(NO_HOST_MAC).withDstMac(instPort.macAddress()).withDeviceId(instPort.deviceId()).withInputInterfaceId(ARBITRARY_IN_INTF).withOutputInterfaceId(ARBITRARY_OUT_INTF).withVlanId(VlanId.vlanId());
    StatsInfo.Builder sBuilder = new DefaultStatsInfo.DefaultBuilder();
    sBuilder.withStartupTime(System.currentTimeMillis()).withFstPktArrTime(System.currentTimeMillis()).withLstPktOffset((int) (REFRESH_INTERVAL * MILLISECONDS)).withCurrAccPkts((int) stat.packetsReceived()).withCurrAccBytes(stat.bytesReceived()).withErrorPkts((short) stat.packetsRxErrors()).withDropPkts((short) stat.packetsRxDropped());
    fBuilder.withStatsInfo(sBuilder.build());
    return mergeFlowInfo(fBuilder.build(), fBuilder, sBuilder);
}
#end_block

#method_before
private void connectTables(DeviceId deviceId, int fromTable, int toTable, StatsFlowRule statsFlowRule, int rulePriority, boolean install) {
    log.debug("Table Transition: {} -> {}", fromTable, toTable);
    int srcPrefixLength = statsFlowRule.srcIpPrefix().prefixLength();
    int dstPrefixLength = statsFlowRule.dstIpPrefix().prefixLength();
    int prefixLength = rulePriority + srcPrefixLength + dstPrefixLength;
    byte protocol = statsFlowRule.ipProtocol();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder().matchEthType(TYPE_IPV4).matchIPSrc(statsFlowRule.srcIpPrefix()).matchIPDst(statsFlowRule.dstIpPrefix());
    if (protocol == PROTOCOL_TCP) {
        selectorBuilder = selectorBuilder.matchIPProtocol(statsFlowRule.ipProtocol()).matchTcpSrc(statsFlowRule.srcTpPort()).matchTcpDst(statsFlowRule.dstTpPort());
    } else if (protocol == PROTOCOL_UDP) {
        selectorBuilder = selectorBuilder.matchIPProtocol(statsFlowRule.ipProtocol()).matchUdpSrc(statsFlowRule.srcTpPort()).matchUdpDst(statsFlowRule.dstTpPort());
    } else {
        log.warn("Unsupported protocol {}", statsFlowRule.ipProtocol());
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.transition(toTable);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(prefixLength).fromApp(appId).makePermanent().forTable(fromTable).build();
    applyRule(flowRule, install);
}
#method_after
private void connectTables(DeviceId deviceId, int fromTable, int toTable, StatsFlowRule statsFlowRule, int rulePriority, boolean install) {
    int srcPrefixLength = statsFlowRule.srcIpPrefix().prefixLength();
    int dstPrefixLength = statsFlowRule.dstIpPrefix().prefixLength();
    int prefixLength = rulePriority + srcPrefixLength + dstPrefixLength;
    byte protocol = statsFlowRule.ipProtocol();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder().matchEthType(TYPE_IPV4).matchIPSrc(statsFlowRule.srcIpPrefix()).matchIPDst(statsFlowRule.dstIpPrefix());
    if (protocol == PROTOCOL_TCP) {
        selectorBuilder = selectorBuilder.matchIPProtocol(statsFlowRule.ipProtocol()).matchTcpSrc(statsFlowRule.srcTpPort()).matchTcpDst(statsFlowRule.dstTpPort());
    } else if (protocol == PROTOCOL_UDP) {
        selectorBuilder = selectorBuilder.matchIPProtocol(statsFlowRule.ipProtocol()).matchUdpSrc(statsFlowRule.srcTpPort()).matchUdpDst(statsFlowRule.dstTpPort());
    } else {
        log.warn("Unsupported protocol {}", statsFlowRule.ipProtocol());
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.transition(toTable);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(prefixLength).fromApp(appId).makePermanent().forTable(fromTable).build();
    applyRule(flowRule, install);
}
#end_block

#method_before
private void enqFlowInfo(FlowInfo flowInfo) {
    String key = flowInfo.makeFlowInfoKey();
    Queue<FlowInfo> queue = flowInfoMap.get(key);
    if (queue == null) {
        Queue<FlowInfo> newQueue = new LinkedList<FlowInfo>();
        newQueue.offer(flowInfo);
        flowInfoMap.put(key, newQueue);
        return;
    }
    queue.offer(flowInfo);
    while (queue.size() > DEFAULT_DATA_POINT_SIZE) {
        // Removes a garbage data in the queue.
        queue.remove();
    }
}
#method_after
private void enqFlowInfo(FlowInfo flowInfo) {
    String key = flowInfo.uniqueFlowInfoKey();
    Queue<FlowInfo> queue = flowInfoMap.get(key);
    if (queue == null) {
        Queue<FlowInfo> newQueue = new LinkedList<FlowInfo>();
        newQueue.offer(flowInfo);
        flowInfoMap.put(key, newQueue);
        return;
    }
    queue.offer(flowInfo);
    while (queue.size() > DEFAULT_DATA_POINT_SIZE) {
        // Removes a garbage data in the queue.
        queue.remove();
    }
}
#end_block

#method_before
@Override
public void run() {
    Set<FlowInfo> filteredFlowInfos = Sets.newConcurrentHashSet();
    // we only let the master controller of the device where the
    // stats flow rules are installed send stats message
    getFlowInfos().forEach(f -> {
        if (checkSrcDstLocalMaster(f)) {
            filteredFlowInfos.add(f);
        }
    });
    // is located to send stats message
    if (portStats) {
        getDstPortBasedFlowInfos().forEach(f -> {
            if (checkSrcDstLocalMaster(f)) {
                filteredFlowInfos.add(f);
            }
        });
    }
    telemetryService.publish(filteredFlowInfos);
    // TODO: Refactor following code to "TelemetryService"
    filteredFlowInfos.forEach(flowInfo -> {
        enqFlowInfo(flowInfo);
    });
}
#method_after
@Override
public void run() {
    Set<FlowInfo> filteredFlowInfos = Sets.newConcurrentHashSet();
    // we only let the master controller of the device where the
    // stats flow rules are installed send stats message
    getFlowInfos().forEach(f -> {
        if (checkSrcDstLocalMaster(f)) {
            filteredFlowInfos.add(f);
        }
    });
    // is located to send stats message
    if (portStats) {
        getDstPortBasedFlowInfos().forEach(f -> {
            if (checkSrcDstLocalMaster(f)) {
                filteredFlowInfos.add(f);
            }
        });
    }
    telemetryService.publish(filteredFlowInfos);
    // TODO: Refactor the following code to "TelemetryService" style.
    filteredFlowInfos.forEach(flowInfo -> {
        enqFlowInfo(flowInfo);
    });
}
#end_block

#method_before
@Override
protected String[] getSeries() {
    String[] series = { "curr_acc_packet", "prev_acc_packet", "curr_acc_byte", "prev_acc_byte", "error_packet", "drop_packet" };
    return series;
}
#method_after
@Override
protected String[] getSeries() {
    String[] series = { STAT_CURR_ACC_PACKET, STAT_PREV_ACC_PACKET, STAT_CURR_ACC_BYTE, STAT_PREV_ACC_BYTE, STAT_ERROR_PACKET, STAT_DROP_PACKET };
    return series;
}
#end_block

#method_before
@Override
protected void populateChart(ChartModel cm, ObjectNode payload) {
    if (statsFlowRuleService == null) {
        statsFlowRuleService = get(StatsFlowRuleAdminService.class);
    }
    if (flowInfoMap == null) {
        flowInfoMap = statsFlowRuleService.getFlowInfoMap();
    }
    String flowKey = string(payload, "flowA");
    String period = string(payload, "periodA");
    if (!Strings.isNullOrEmpty(flowKey) || !Strings.isNullOrEmpty(period)) {
        if (!Strings.isNullOrEmpty(flowKey)) {
            gFlowKey = flowKey;
        }
        if (!Strings.isNullOrEmpty(period)) {
            gPeriod = period;
        }
        Queue<FlowInfo> flowInfoQ = flowInfoMap.get(gFlowKey);
        if (flowInfoQ == null) {
            log.warn("No such flow key {}", gFlowKey);
            return;
        } else {
            populateMetrics(cm, flowInfoQ);
            attachFlowList(cm);
            attachPeriodList(cm);
        }
    } else {
        flowInfoMap.keySet().forEach(key -> {
            Queue<FlowInfo> flowInfoQ = flowInfoMap.get(key);
            if (flowInfoQ == null) {
                log.warn("Key {} is not found in FlowInfoMap", key);
                return;
            }
            FlowInfo flowInfo = getLatestFlowInfo(flowInfoQ);
            Map<String, Object> local = Maps.newHashMap();
            local.put(LABEL, key);
            local.put("curr_acc_packet", flowInfo.statsInfo().currAccPkts());
            local.put("prev_acc_packet", flowInfo.statsInfo().prevAccPkts());
            local.put("curr_acc_byte", flowInfo.statsInfo().currAccBytes());
            local.put("prev_acc_byte", flowInfo.statsInfo().prevAccBytes());
            local.put("error_packet", flowInfo.statsInfo().errorPkts());
            local.put("drop_packet", flowInfo.statsInfo().dropPkts());
            populateMetric(cm.addDataPoint(key), local);
        });
    }
}
#method_after
@Override
protected void populateChart(ChartModel cm, ObjectNode payload) {
    if (statsFlowRuleService == null) {
        statsFlowRuleService = get(StatsFlowRuleAdminService.class);
    }
    if (flowInfoMap == null) {
        flowInfoMap = statsFlowRuleService.getFlowInfoMap();
    }
    String flowKey = string(payload, JSON_NODE_FLOW);
    String period = string(payload, JSON_NODE_PERIOD);
    if (!Strings.isNullOrEmpty(flowKey) || !Strings.isNullOrEmpty(period)) {
        if (!Strings.isNullOrEmpty(flowKey)) {
            currentFlowKey = flowKey;
        }
        if (!Strings.isNullOrEmpty(period)) {
            currentPeriod = period;
        }
        Queue<FlowInfo> flowInfoQ = flowInfoMap.get(currentFlowKey);
        if (flowInfoQ == null) {
            log.warn("No such flow key {}", currentFlowKey);
            return;
        } else {
            populateMetrics(cm, flowInfoQ);
            attachFlowList(cm);
            attachPeriodList(cm);
        }
    } else {
        flowInfoMap.keySet().forEach(key -> {
            Queue<FlowInfo> flowInfoQ = flowInfoMap.get(key);
            if (flowInfoQ == null) {
                log.warn("Key {} is not found in FlowInfoMap", key);
                return;
            }
            FlowInfo flowInfo = getLatestFlowInfo(flowInfoQ);
            Map<String, Object> local = Maps.newHashMap();
            local.put(LABEL, key);
            local.put(STAT_CURR_ACC_PACKET, flowInfo.statsInfo().currAccPkts());
            local.put(STAT_PREV_ACC_PACKET, flowInfo.statsInfo().prevAccPkts());
            local.put(STAT_CURR_ACC_BYTE, flowInfo.statsInfo().currAccBytes());
            local.put(STAT_PREV_ACC_BYTE, flowInfo.statsInfo().prevAccBytes());
            local.put(STAT_ERROR_PACKET, flowInfo.statsInfo().errorPkts());
            local.put(STAT_DROP_PACKET, flowInfo.statsInfo().dropPkts());
            populateMetric(cm.addDataPoint(key), local);
        });
    }
}
#end_block

#method_before
private void populateMetrics(ChartModel cm, Queue<FlowInfo> flowInfoQ) {
    FlowInfo[] flowInfos = flowInfoQ.toArray(new FlowInfo[flowInfoQ.size()]);
    SimpleDateFormat form = new SimpleDateFormat("HH:mm:ss");
    int timeOffset = 0;
    Integer dataPointCount = PERIOD_OPTION_MAP.get(gPeriod);
    if (dataPointCount != null) {
        timeOffset = flowInfos.length - (int) dataPointCount;
        if (timeOffset < 0) {
            timeOffset = 0;
        }
    }
    for (int idx = timeOffset; idx < flowInfos.length; idx++) {
        Map<String, Object> local = Maps.newHashMap();
        local.put(LABEL, form.format(new Date(flowInfos[idx].statsInfo().fstPktArrTime())));
        local.put("curr_acc_packet", flowInfos[idx].statsInfo().currAccPkts());
        local.put("prev_acc_packet", flowInfos[idx].statsInfo().prevAccPkts());
        local.put("curr_acc_byte", flowInfos[idx].statsInfo().currAccBytes());
        local.put("prev_acc_byte", flowInfos[idx].statsInfo().prevAccBytes());
        local.put("error_packet", flowInfos[idx].statsInfo().errorPkts());
        local.put("drop_packet", flowInfos[idx].statsInfo().dropPkts());
        log.debug("Data Point: {}", local.toString());
        populateMetric(cm.addDataPoint(flowInfos[idx].makeFlowInfoKey()), local);
    }
}
#method_after
private void populateMetrics(ChartModel cm, Queue<FlowInfo> flowInfoQ) {
    FlowInfo[] flowInfos = flowInfoQ.toArray(new FlowInfo[flowInfoQ.size()]);
    SimpleDateFormat form = new SimpleDateFormat(CHART_TIME_FORMAT);
    int timeOffset = 0;
    Integer dataPointCount = PERIOD_OPTION_MAP.get(currentPeriod);
    if (dataPointCount != null) {
        timeOffset = flowInfos.length - (int) dataPointCount;
        if (timeOffset < 0) {
            timeOffset = 0;
        }
    }
    for (int idx = timeOffset; idx < flowInfos.length; idx++) {
        Map<String, Object> local = Maps.newHashMap();
        local.put(LABEL, form.format(new Date(flowInfos[idx].statsInfo().fstPktArrTime())));
        local.put(STAT_CURR_ACC_PACKET, flowInfos[idx].statsInfo().currAccPkts());
        local.put(STAT_PREV_ACC_PACKET, flowInfos[idx].statsInfo().prevAccPkts());
        local.put(STAT_CURR_ACC_BYTE, flowInfos[idx].statsInfo().currAccBytes());
        local.put(STAT_PREV_ACC_BYTE, flowInfos[idx].statsInfo().prevAccBytes());
        local.put(STAT_ERROR_PACKET, flowInfos[idx].statsInfo().errorPkts());
        local.put(STAT_DROP_PACKET, flowInfos[idx].statsInfo().dropPkts());
        populateMetric(cm.addDataPoint(flowInfos[idx].uniqueFlowInfoKey()), local);
    }
}
#end_block

#method_before
private void populateMetric(ChartModel.DataPoint dataPoint, Map<String, Object> data) {
    log.debug("Chart Data  {}", data.toString());
    data.forEach(dataPoint::data);
}
#method_after
private void populateMetric(ChartModel.DataPoint dataPoint, Map<String, Object> data) {
    data.forEach(dataPoint::data);
}
#end_block

#method_before
private ObjectNode getT3McastJsonOutput(boolean verbose) {
    TroubleshootService troubleshootService = get(TroubleshootService.class);
    final ObjectNode nodeOutput = mapper.createObjectNode();
    nodeOutput.put("title", "Tracing all Multicast routes in the System");
    // Create the generator for the list of traces.
    List<Set<StaticPacketTrace>> generator = troubleshootService.getMulitcastTrace(VlanId.vlanId("None"));
    int totalTraces = 0;
    List<StaticPacketTrace> failedTraces = new ArrayList<>();
    StaticPacketTrace previousTrace = null;
    ArrayNode traceArray = mapper.createArrayNode();
    for (Set<StaticPacketTrace> traces : generator) {
        ObjectNode genNode = mapper.createObjectNode();
        totalTraces++;
        // Print also Route if possible or packet
        ArrayNode traceOutput = mapper.createArrayNode();
        if (!verbose) {
            for (StaticPacketTrace trace : traces) {
                ObjectNode traceObject = mapper.createObjectNode();
                traceObject.set("trace", traceNode(previousTrace, trace));
                if (previousTrace == null || !previousTrace.equals(trace)) {
                    previousTrace = trace;
                }
                if (!trace.isSuccess()) {
                    traceObject.put("reason", trace.resultMessage());
                    failedTraces.add(trace);
                } else {
                    traceObject.put("result", "Success");
                }
                traceOutput.add(traceObject);
            }
        } else {
            traces.forEach(trace -> {
                ObjectNode traceObj = mapper.createObjectNode();
                ArrayNode node = mapper.createArrayNode();
                for (Criterion packet : trace.getInitialPacket().criteria()) {
                    node.add(packet.toString());
                }
                traceObj.set("input packet", node);
                traceObj.set("trace", getTraceJson(trace, verbose));
                traceOutput.add(traceObj);
            });
        }
        genNode.set("traces", traceOutput);
        traceArray.add(genNode);
    }
    nodeOutput.set("tracing packet", traceArray);
    if (!verbose) {
        if (failedTraces.size() != 0) {
            nodeOutput.put("failed trace", failedTraces.size());
        }
        previousTrace = null;
        for (StaticPacketTrace trace : failedTraces) {
            if (previousTrace == null || !previousTrace.equals(trace)) {
                previousTrace = trace;
            }
            nodeOutput.set("trace", traceNode(previousTrace, trace));
            if (previousTrace == null || !previousTrace.equals(trace)) {
                previousTrace = trace;
            }
            nodeOutput.put("failure", trace.resultMessage());
        }
        nodeOutput.put("total traces", totalTraces);
        nodeOutput.put("errors", failedTraces.size());
    }
    return nodeOutput;
}
#method_after
private ObjectNode getT3McastJsonOutput(boolean verbose) {
    TroubleshootService troubleshootService = get(TroubleshootService.class);
    final ObjectNode nodeOutput = mapper.createObjectNode();
    nodeOutput.put("title", "Tracing all Multicast routes in the System");
    // Create the generator for the list of traces.
    List<Set<StaticPacketTrace>> generator = troubleshootService.getMulitcastTrace(VlanId.vlanId("None"));
    int totalTraces = 0;
    List<StaticPacketTrace> failedTraces = new ArrayList<>();
    StaticPacketTrace previousTrace = null;
    ArrayNode traceArray = mapper.createArrayNode();
    for (Set<StaticPacketTrace> traces : generator) {
        ObjectNode genNode = mapper.createObjectNode();
        totalTraces++;
        // Print also Route if possible or packet
        ArrayNode traceOutput = mapper.createArrayNode();
        if (verbose) {
            traces.forEach(trace -> {
                ObjectNode traceObj = mapper.createObjectNode();
                ArrayNode node = mapper.createArrayNode();
                for (Criterion packet : trace.getInitialPacket().criteria()) {
                    node.add(packet.toString());
                }
                traceObj.set("input packet", node);
                traceObj.set("trace", getTraceJson(trace, verbose));
                traceOutput.add(traceObj);
            });
        } else {
            for (StaticPacketTrace trace : traces) {
                ObjectNode traceObject = mapper.createObjectNode();
                traceObject.set("trace", traceNode(previousTrace, trace));
                if (previousTrace == null || !previousTrace.equals(trace)) {
                    previousTrace = trace;
                }
                traceObject.put("result", trace.isSuccess());
                if (!trace.isSuccess()) {
                    traceObject.put("reason", trace.resultMessage());
                    failedTraces.add(trace);
                }
                traceOutput.add(traceObject);
            }
        }
        genNode.set("traces", traceOutput);
        traceArray.add(genNode);
    }
    nodeOutput.set("tracing packet", traceArray);
    if (!verbose) {
        if (failedTraces.size() != 0) {
            nodeOutput.put("failed traces", failedTraces.size());
        }
        previousTrace = null;
        for (StaticPacketTrace trace : failedTraces) {
            if (previousTrace == null || !previousTrace.equals(trace)) {
                previousTrace = trace;
            }
            nodeOutput.set("trace", traceNode(previousTrace, trace));
            if (previousTrace == null || !previousTrace.equals(trace)) {
                previousTrace = trace;
            }
            nodeOutput.put("failure", trace.resultMessage());
        }
        nodeOutput.put("total traces", totalTraces);
        nodeOutput.put("errors", failedTraces.size());
    }
    return nodeOutput;
}
#end_block

#method_before
private boolean removeNicFlowRule(DeviceId deviceId, long ruleId) {
    int response = -1;
    // Try to remove the rule, although server might be unreachable
    try {
        response = getController().delete(deviceId, RULE_MANAGEMENT_URL + "/" + Long.toString(ruleId), null, JSON);
    } catch (Exception ex) {
    // Do nothing
    }
    if (!checkStatusCode(response)) {
        log.error("Failed to remove flow rule {} from device {}", ruleId, deviceId);
        return false;
    }
    log.info("Successfully removed flow rule {} from device {}", ruleId, deviceId);
    return true;
}
#method_after
private boolean removeNicFlowRule(DeviceId deviceId, long ruleId) {
    int response = -1;
    // Try to remove the rule, although server might be unreachable
    try {
        response = getController().delete(deviceId, RULE_MANAGEMENT_URL + SLASH + Long.toString(ruleId), null, JSON);
    } catch (Exception ex) {
        log.error("Failed to remove flow rule {} from device {}", ruleId, deviceId);
        return false;
    }
    if (!checkStatusCode(response)) {
        log.error("Failed to remove flow rule {} from device {}", ruleId, deviceId);
        return false;
    }
    log.info("Successfully removed flow rule {} from device {}", ruleId, deviceId);
    return true;
}
#end_block

#method_before
private MonitoringStatistics getMonitoringStatistics(DeviceId deviceId, URI tcId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (device == null) {
        return monStats;
    }
    // Create a resource-specific URL
    String scUrl = SERVICE_CHAINS_STATS_URL + "/" + tcId.toString();
    // Hit the path that provides the server's specific resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, scUrl, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Get the ID of the traffic class
    String id = get(jsonNode, PARAM_ID);
    // And verify that this is the traffic class we want to monitor
    if (!id.equals(tcId.toString())) {
        throw new IllegalStateException("Failed to retrieve monitoring data for traffic class " + tcId + ". Traffic class ID does not agree.");
    }
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get timing statistics
    TimingStatistics timinsgStats = parseTimingStatistics(objNode);
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats).build();
    monStats = statsBuilder.build();
    log.debug("Monitoring statistics: {}", monStats.toString());
    return monStats;
}
#method_after
private MonitoringStatistics getMonitoringStatistics(DeviceId deviceId, URI tcId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (device == null) {
        return monStats;
    }
    // Create a resource-specific URL
    String scUrl = SERVICE_CHAINS_STATS_URL + SLASH + tcId.toString();
    // Hit the path that provides the server's specific resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, scUrl, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        raiseDeviceDisconnect(device);
        return monStats;
    }
    // Get the ID of the traffic class
    String id = get(jsonNode, PARAM_ID);
    // And verify that this is the traffic class we want to monitor
    if (!id.equals(tcId.toString())) {
        throw new IllegalStateException("Failed to retrieve monitoring data for traffic class " + tcId + ". Traffic class ID does not agree.");
    }
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get timing statistics
    TimingStatistics timinsgStats = parseTimingStatistics(objNode);
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats).build();
    monStats = statsBuilder.build();
    log.debug("Monitoring statistics: {}", monStats.toString());
    return monStats;
}
#end_block

#method_before
/**
 * Sets the sequencer number.
 *
 * @param sequenceNum sequence number
 * @return this
 */
public ICMPEcho setSequenceNum(final short sequenceNum) {
    this.sequenceNum = sequenceNum;
    return this;
}
#method_after
public ICMPEcho setSequenceNum(final short sequenceNum) {
    this.sequenceNum = sequenceNum;
    return this;
}
#end_block

#method_before
private void handleEchoRequest(DeviceId srcDevice, MacAddress srcMac, IPv4 ipPacket, ICMP icmp) {
    InstancePort instPort = instancePortService.instancePort(srcMac);
    if (instPort == null) {
        log.warn(ERR_REQ + "unknown source host(MAC:{})", srcMac);
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(ipPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(instPort, srcIp);
    if (srcSubnet == null) {
        log.warn(ERR_REQ + "unknown source subnet(IP:{})", srcIp);
        return;
    }
    if (Strings.isNullOrEmpty(srcSubnet.getGateway())) {
        log.warn(ERR_REQ + "source subnet(ID:{}, CIDR:{}) has no gateway", srcSubnet.getId(), srcSubnet.getCidr());
        return;
    }
    if (isForSubnetGateway(IpAddress.valueOf(ipPacket.getDestinationAddress()), srcSubnet)) {
        // this is a request for the subnet gateway
        log.trace("Icmp request to gateway {} from {}", IpAddress.valueOf(ipPacket.getDestinationAddress()).toString(), IpAddress.valueOf(ipPacket.getSourceAddress()).toString());
        processRequestForGateway(ipPacket, instPort);
    } else {
        // this is a request for the external network
        log.trace("Icmp request to external {} from {}", IpAddress.valueOf(ipPacket.getDestinationAddress()).toString(), IpAddress.valueOf(ipPacket.getSourceAddress()).toString());
        RouterInterface routerInterface = routerInterface(srcSubnet);
        if (routerInterface == null) {
            log.warn(ERR_REQ + "failed to get router interface");
            return;
        }
        ExternalGateway externalGateway = externalGateway(routerInterface);
        if (externalGateway == null) {
            log.warn(ERR_REQ + "failed to get external gateway");
            return;
        }
        ExternalPeerRouter externalPeerRouter = osNetworkService.externalPeerRouter(externalGateway);
        if (externalPeerRouter == null) {
            log.warn(ERR_REQ + "failed to get external peer router");
            return;
        }
        IpAddress externalIp = getExternalIp(externalGateway, routerInterface);
        if (externalIp == null) {
            log.warn(ERR_REQ + "failed to get external ip");
            return;
        }
        sendRequestForExternal(ipPacket, srcDevice, externalIp, externalPeerRouter);
        String icmpInfoKey = icmpInfoKey(icmp, externalIp.toString(), IPv4.fromIPv4Address(ipPacket.getDestinationAddress()));
        log.trace("Created icmpInfo key is {}", icmpInfoKey);
        try {
            icmpInfoMap.compute(icmpInfoKey, (id, existing) -> {
                checkArgument(existing == null, ERR_DUPLICATE);
                return instPort;
            });
        } catch (IllegalArgumentException e) {
            log.warn("IllegalArgumentException occurred because of {}", e.toString());
            return;
        }
    }
}
#method_after
private void handleEchoRequest(DeviceId srcDevice, MacAddress srcMac, IPv4 ipPacket, ICMP icmp) {
    InstancePort instPort = instancePortService.instancePort(srcMac);
    if (instPort == null) {
        log.warn(ERR_REQ + "unknown source host(MAC:{})", srcMac);
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(ipPacket.getSourceAddress());
    IpAddress dstIp = IpAddress.valueOf(ipPacket.getDestinationAddress());
    Subnet srcSubnet = getSourceSubnet(instPort, srcIp);
    if (srcSubnet == null) {
        log.warn(ERR_REQ + "unknown source subnet(IP:{})", srcIp);
        return;
    }
    if (Strings.isNullOrEmpty(srcSubnet.getGateway())) {
        log.warn(ERR_REQ + "source subnet(ID:{}, CIDR:{}) has no gateway", srcSubnet.getId(), srcSubnet.getCidr());
        return;
    }
    if (isForSubnetGateway(IpAddress.valueOf(ipPacket.getDestinationAddress()), srcSubnet)) {
        // this is a request for the subnet gateway
        log.trace("Icmp request to gateway {} from {}", dstIp, srcIp);
        processRequestForGateway(ipPacket, instPort);
    } else {
        // this is a request for the external network
        log.trace("Icmp request to external {} from {}", dstIp, srcIp);
        RouterInterface routerInterface = routerInterface(srcSubnet);
        if (routerInterface == null) {
            log.warn(ERR_REQ + "failed to get router interface");
            return;
        }
        ExternalGateway externalGateway = externalGateway(routerInterface);
        if (externalGateway == null) {
            log.warn(ERR_REQ + "failed to get external gateway");
            return;
        }
        ExternalPeerRouter externalPeerRouter = osNetworkService.externalPeerRouter(externalGateway);
        if (externalPeerRouter == null) {
            log.warn(ERR_REQ + "failed to get external peer router");
            return;
        }
        IpAddress externalIp = getExternalIp(externalGateway, routerInterface);
        if (externalIp == null) {
            log.warn(ERR_REQ + "failed to get external ip");
            return;
        }
        sendRequestForExternal(ipPacket, srcDevice, externalIp, externalPeerRouter);
        String icmpInfoKey = icmpInfoKey(icmp, externalIp.toString(), IPv4.fromIPv4Address(ipPacket.getDestinationAddress()));
        log.trace("Created icmpInfo key is {}", icmpInfoKey);
        try {
            icmpInfoMap.compute(icmpInfoKey, (id, existing) -> {
                checkArgument(existing == null, ERR_DUPLICATE);
                return instPort;
            });
        } catch (IllegalArgumentException e) {
            log.warn("IllegalArgumentException occurred because of {}", e.toString());
            return;
        }
    }
}
#end_block

#method_before
@Activate
public void activate() {
    membershipService = atomixManager.getAtomix().getMembershipService();
    membershipService.addListener(membershipEventListener);
    membershipService.getMembers().forEach(member -> {
        ControllerNode node = toControllerNode(member);
        nodes.put(node.id(), node);
        updateState(node, member);
        updateVersion(node, member);
    });
    membershipService.getLocalMember().metadata().put(STATE_KEY, ControllerNode.State.ACTIVE.name());
    membershipService.getLocalMember().metadata().put(VERSION_KEY, versionService.version().toString());
    localNode = toControllerNode(membershipService.getLocalMember());
    states.put(localNode.id(), ControllerNode.State.ACTIVE);
    versions.put(localNode.id(), versionService.version());
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    membershipService = atomixManager.getAtomix().getMembershipService();
    membershipService.addListener(membershipEventListener);
    membershipService.getMembers().forEach(member -> {
        ControllerNode node = toControllerNode(member);
        nodes.put(node.id(), node);
        updateState(node, member);
        updateVersion(node, member);
    });
    membershipService.getLocalMember().properties().put(STATE_KEY, ControllerNode.State.ACTIVE.name());
    membershipService.getLocalMember().properties().put(VERSION_KEY, versionService.version().toString());
    localNode = toControllerNode(membershipService.getLocalMember());
    states.put(localNode.id(), ControllerNode.State.ACTIVE);
    versions.put(localNode.id(), versionService.version());
    log.info("Started");
}
#end_block

#method_before
private void changeMembership(ClusterMembershipEvent event) {
    ControllerNode node = nodes.get(NodeId.nodeId(event.subject().id().id()));
    switch(event.type()) {
        case MEMBER_ADDED:
        case MEMBER_UPDATED:
            if (node == null) {
                node = toControllerNode(event.subject());
                nodes.put(node.id(), node);
                notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_ADDED, node));
            }
            updateVersion(node, event.subject());
            updateState(node, event.subject());
            break;
        case MEMBER_REMOVED:
            if (node != null && states.put(node.id(), ControllerNode.State.INACTIVE) != ControllerNode.State.INACTIVE) {
                notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_DEACTIVATED, node));
                notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_REMOVED, node));
            }
            break;
        default:
            break;
    }
}
#method_after
private void changeMembership(ClusterMembershipEvent event) {
    ControllerNode node = nodes.get(NodeId.nodeId(event.subject().id().id()));
    switch(event.type()) {
        case MEMBER_ADDED:
        case METADATA_CHANGED:
            if (node == null) {
                node = toControllerNode(event.subject());
                nodes.put(node.id(), node);
                notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_ADDED, node));
            }
            updateVersion(node, event.subject());
            updateState(node, event.subject());
            break;
        case MEMBER_REMOVED:
            if (node != null && states.put(node.id(), ControllerNode.State.INACTIVE) != ControllerNode.State.INACTIVE) {
                notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_DEACTIVATED, node));
                notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_REMOVED, node));
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void updateState(ControllerNode node, Member member) {
    String state = member.metadata().get(STATE_KEY);
    if (state == null || !state.equals(ControllerNode.State.READY.name())) {
        if (states.put(node.id(), ControllerNode.State.ACTIVE) != ControllerNode.State.ACTIVE) {
            log.info("Updated node {} state to {}", node.id(), ControllerNode.State.ACTIVE);
            markUpdated(node.id());
            notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_ACTIVATED, node));
        }
    } else {
        if (states.put(node.id(), ControllerNode.State.READY) != ControllerNode.State.READY) {
            log.info("Updated node {} state to {}", node.id(), ControllerNode.State.READY);
            markUpdated(node.id());
            notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_READY, node));
        }
    }
}
#method_after
private void updateState(ControllerNode node, Member member) {
    String state = member.properties().getProperty(STATE_KEY);
    if (state == null || !state.equals(ControllerNode.State.READY.name())) {
        if (states.put(node.id(), ControllerNode.State.ACTIVE) != ControllerNode.State.ACTIVE) {
            log.info("Updated node {} state to {}", node.id(), ControllerNode.State.ACTIVE);
            markUpdated(node.id());
            notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_ACTIVATED, node));
        }
    } else {
        if (states.put(node.id(), ControllerNode.State.READY) != ControllerNode.State.READY) {
            log.info("Updated node {} state to {}", node.id(), ControllerNode.State.READY);
            markUpdated(node.id());
            notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_READY, node));
        }
    }
}
#end_block

#method_before
private void updateVersion(ControllerNode node, Member member) {
    String versionString = member.metadata().get(VERSION_KEY);
    if (versionString != null) {
        Version version = Version.version(versionString);
        if (!Objects.equals(versions.put(node.id(), version), version)) {
            log.info("Updated node {} version to {}", node.id(), version);
        }
    }
}
#method_after
private void updateVersion(ControllerNode node, Member member) {
    String versionString = member.properties().getProperty(VERSION_KEY);
    if (versionString != null) {
        Version version = Version.version(versionString);
        if (!Objects.equals(versions.put(node.id(), version), version)) {
            log.info("Updated node {} version to {}", node.id(), version);
        }
    }
}
#end_block

#method_before
@Override
public Set<ControllerNode> getNodes() {
    return membershipService.getMembers().stream().filter(member -> Objects.equals(member.metadata().get("type"), "onos")).map(this::toControllerNode).collect(Collectors.toSet());
}
#method_after
@Override
public Set<ControllerNode> getNodes() {
    return membershipService.getMembers().stream().filter(member -> Objects.equals(member.properties().getProperty("type"), "onos")).map(this::toControllerNode).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public void markFullyStarted(boolean started) {
    ControllerNode.State state = started ? ControllerNode.State.READY : ControllerNode.State.ACTIVE;
    states.put(localNode.id(), state);
    membershipService.getLocalMember().metadata().put(STATE_KEY, state.name());
}
#method_after
@Override
public void markFullyStarted(boolean started) {
    ControllerNode.State state = started ? ControllerNode.State.READY : ControllerNode.State.ACTIVE;
    states.put(localNode.id(), state);
    membershipService.getLocalMember().properties().setProperty(STATE_KEY, state.name());
}
#end_block

#method_before
@Override
public ControllerNode addNode(NodeId nodeId, IpAddress ip, int tcpPort) {
    checkNotNull(nodeId, INSTANCE_ID_NULL);
    ControllerNode node = new DefaultControllerNode(nodeId, ip, tcpPort);
    nodes.put(node.id(), node);
    ControllerNode.State state = node.equals(localNode) ? ControllerNode.State.ACTIVE : ControllerNode.State.INACTIVE;
    membershipService.getMember(node.id().id()).metadata().put(STATE_KEY, state.name());
    notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_ADDED, node));
    return node;
}
#method_after
@Override
public ControllerNode addNode(NodeId nodeId, IpAddress ip, int tcpPort) {
    checkNotNull(nodeId, INSTANCE_ID_NULL);
    ControllerNode node = new DefaultControllerNode(nodeId, ip, tcpPort);
    nodes.put(node.id(), node);
    ControllerNode.State state = node.equals(localNode) ? ControllerNode.State.ACTIVE : ControllerNode.State.INACTIVE;
    membershipService.getMember(node.id().id()).properties().setProperty(STATE_KEY, state.name());
    notifyDelegate(new ClusterEvent(ClusterEvent.Type.INSTANCE_ADDED, node));
    return node;
}
#end_block

#method_before
@Override
public AsyncConsistentMultimap<K, V> buildMultimap() {
    return new AtomixConsistentMultimap<>(atomix.<K, V>consistentMultimapBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncConsistentMultimap<K, V> buildMultimap() {
    return new AtomixConsistentMultimap<>(atomix.<K, V>atomicMultimapBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public CompletableFuture<? extends Set<E>> getAsImmutableSet() {
    return atomixSet.getAsImmutableSet();
}
#method_after
@Override
public CompletableFuture<? extends Set<E>> getAsImmutableSet() {
    return CompletableFuture.completedFuture(atomixSet.stream().collect(Collectors.toSet()));
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addListener(SetEventListener<E> listener) {
    io.atomix.core.set.SetEventListener<E> atomixListener = event -> listener.event(new SetEvent<E>(event.name(), SetEvent.Type.valueOf(event.type().name()), event.entry()));
    listenerMap.put(listener, atomixListener);
    return atomixSet.addListener(atomixListener);
}
#method_after
@Override
public synchronized CompletableFuture<Void> addListener(SetEventListener<E> listener) {
    io.atomix.core.collection.CollectionEventListener<E> atomixListener = event -> listener.event(new SetEvent<E>(name(), SetEvent.Type.valueOf(event.type().name()), event.element()));
    listenerMap.put(listener, atomixListener);
    return atomixSet.addListener(atomixListener);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(SetEventListener<E> listener) {
    io.atomix.core.set.SetEventListener<E> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixSet.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(SetEventListener<E> listener) {
    io.atomix.core.collection.CollectionEventListener<E> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixSet.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public Topic<T> build() {
    return new AtomixDistributedTopic<>(atomix.<T>atomicValueBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public Topic<T> build() {
    return new AtomixDistributedTopic<>(atomix.<T>atomicValueBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public AsyncConsistentTreeMap<V> buildTreeMap() {
    return new AtomixConsistentTreeMap<>(atomix.<V>consistentTreeMapBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncConsistentTreeMap<V> buildTreeMap() {
    return new AtomixConsistentTreeMap<>(atomix.<String, V>atomicNavigableMapBuilder(name()).withRegistrationRequired().withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public AsyncAtomicCounter build() {
    return new AtomixAtomicCounter(atomix.atomicCounterBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncAtomicCounter build() {
    return new AtomixAtomicCounter(atomix.atomicCounterBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public WorkQueue<E> build() {
    return new AtomixWorkQueue<>(atomix.<E>workQueueBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public WorkQueue<E> build() {
    return new AtomixWorkQueue<>(atomix.<E>workQueueBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public CompletableFuture<Set<K>> keySet() {
    return atomixMultimap.keySet();
}
#method_after
@Override
public CompletableFuture<Set<K>> keySet() {
    return CompletableFuture.completedFuture(atomixMultimap.keySet().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Multiset<K>> keys() {
    return atomixMultimap.keys();
}
#method_after
@Override
public CompletableFuture<Multiset<K>> keys() {
    return CompletableFuture.completedFuture(atomixMultimap.keys().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Multiset<V>> values() {
    return atomixMultimap.values();
}
#method_after
@Override
public CompletableFuture<Multiset<V>> values() {
    return CompletableFuture.completedFuture(atomixMultimap.values().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Map.Entry<K, V>>> entries() {
    return atomixMultimap.entries();
}
#method_after
@Override
public CompletableFuture<Collection<Map.Entry<K, V>>> entries() {
    return CompletableFuture.completedFuture(atomixMultimap.entries().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<AsyncIterator<Map.Entry<K, V>>> iterator() {
    // TODO: Add async iterators to Atomix and wrap here
    return atomixMultimap.entries().thenApply(entries -> {
        Iterator<Map.Entry<K, V>> iterator = entries.iterator();
        return new AsyncIterator<Map.Entry<K, V>>() {

            @Override
            public CompletableFuture<Boolean> hasNext() {
                return CompletableFuture.completedFuture(iterator.hasNext());
            }

            @Override
            public CompletableFuture<Map.Entry<K, V>> next() {
                return CompletableFuture.completedFuture(iterator.next());
            }
        };
    });
}
#method_after
@Override
public CompletableFuture<AsyncIterator<Map.Entry<K, V>>> iterator() {
    return CompletableFuture.completedFuture(new AtomixIterator<>(atomixMultimap.entries().iterator()));
}
#end_block

#method_before
@Override
public CompletableFuture<Map<K, Collection<V>>> asMap() {
    return atomixMultimap.asMap();
}
#method_after
@Override
public CompletableFuture<Map<K, Collection<V>>> asMap() {
    return CompletableFuture.completedFuture(new TranscodingAsyncDistributedMap<K, Collection<V>, K, io.atomix.utils.time.Versioned<Collection<V>>>(atomixMultimap.asMap(), Function.identity(), Function.identity(), v -> new io.atomix.utils.time.Versioned<>(v, 0), v -> v.value()).sync());
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addListener(MultimapEventListener<K, V> listener, Executor executor) {
    io.atomix.core.multimap.MultimapEventListener<K, V> atomixListener = event -> listener.event(new MultimapEvent<K, V>(event.name(), event.key(), event.newValue(), event.oldValue()));
    listenerMap.put(listener, atomixListener);
    return atomixMultimap.addListener(atomixListener, executor);
}
#method_after
@Override
public synchronized CompletableFuture<Void> addListener(MultimapEventListener<K, V> listener, Executor executor) {
    io.atomix.core.multimap.AtomicMultimapEventListener<K, V> atomixListener = event -> listener.event(new MultimapEvent<K, V>(name(), event.key(), event.newValue(), event.oldValue()));
    listenerMap.put(listener, atomixListener);
    return atomixMultimap.addListener(atomixListener, executor);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(MultimapEventListener<K, V> listener) {
    io.atomix.core.multimap.MultimapEventListener<K, V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixMultimap.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(MultimapEventListener<K, V> listener) {
    io.atomix.core.multimap.AtomicMultimapEventListener<K, V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixMultimap.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
private Versioned<Collection<? extends V>> toVersioned(io.atomix.utils.time.Versioned<Collection<? extends V>> versioned) {
    return versioned != null ? new Versioned<>(versioned.value(), versioned.version(), versioned.creationTime()) : null;
}
#method_after
private Versioned<Collection<? extends V>> toVersioned(io.atomix.utils.time.Versioned<Collection<V>> versioned) {
    return versioned != null ? new Versioned<>(versioned.value(), versioned.version(), versioned.creationTime()) : null;
}
#end_block

#method_before
@Override
public Set<Node> getConsensusNodes() {
    checkPermission(CLUSTER_READ);
    return store.getConsensusNodes();
}
#method_after
@Override
public Set<Node> getConsensusNodes() {
    checkPermission(CLUSTER_READ);
    return store.getStorageNodes();
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<MastershipEvent> setMaster(NodeId nodeId, DeviceId deviceId) {
    MastershipRole role = getRole(nodeId, deviceId);
    switch(role) {
        case MASTER:
            // no-op
            return CompletableFuture.completedFuture(null);
        case STANDBY:
        case NONE:
            NodeId prevMaster = masterMap.put(deviceId, nodeId);
            incrementTerm(deviceId);
            removeFromBackups(deviceId, nodeId);
            addToBackup(deviceId, prevMaster);
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
            return null;
    }
    return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(deviceId)));
}
#method_after
@Override
public synchronized CompletableFuture<MastershipEvent> setMaster(NodeId nodeId, DeviceId deviceId) {
    MastershipRole role = getRole(nodeId, deviceId);
    switch(role) {
        case MASTER:
            // no-op
            return CompletableFuture.completedFuture(null);
        case STANDBY:
        case NONE:
            NodeId prevMaster = masterMap.put(deviceId, nodeId);
            incrementTerm(deviceId);
            removeFromBackups(deviceId, nodeId);
            addToBackup(deviceId, prevMaster);
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
            return null;
    }
    return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(deviceId)));
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<MastershipRole> requestRole(DeviceId deviceId) {
    // query+possible reelection
    NodeId node = clusterService.getLocalNode().id();
    MastershipRole role = getRole(node, deviceId);
    switch(role) {
        case MASTER:
            return CompletableFuture.completedFuture(MastershipRole.MASTER);
        case STANDBY:
            if (getMaster(deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(deviceId);
                // remove from backup list
                removeFromBackups(deviceId, node);
                notifyDelegate(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        case NONE:
            if (getMaster(deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(deviceId);
                notifyDelegate(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            // add to backup list
            if (addToBackup(deviceId, node)) {
                notifyDelegate(new MastershipEvent(BACKUPS_CHANGED, deviceId, getNodes(deviceId)));
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(role);
}
#method_after
@Override
public synchronized CompletableFuture<MastershipRole> requestRole(DeviceId deviceId) {
    // query+possible reelection
    NodeId node = clusterService.getLocalNode().id();
    MastershipRole role = getRole(node, deviceId);
    switch(role) {
        case MASTER:
            return CompletableFuture.completedFuture(MastershipRole.MASTER);
        case STANDBY:
            if (getMaster(deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(deviceId);
                // remove from backup list
                removeFromBackups(deviceId, node);
                notifyDelegate(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        case NONE:
            if (getMaster(deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(deviceId);
                notifyDelegate(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            // add to backup list
            if (addToBackup(deviceId, node)) {
                notifyDelegate(new MastershipEvent(BACKUPS_CHANGED, deviceId, getMastership(deviceId)));
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(role);
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<MastershipEvent> setStandby(NodeId nodeId, DeviceId deviceId) {
    MastershipRole role = getRole(nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(deviceId, nodeId);
            if (backup == null) {
                // no master alternative
                masterMap.remove(deviceId);
                // TODO: Should there be new event type for no MASTER?
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(deviceId)));
            } else {
                NodeId prevMaster = masterMap.put(deviceId, backup);
                incrementTerm(deviceId);
                addToBackup(deviceId, prevMaster);
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(deviceId)));
            }
        case STANDBY:
        case NONE:
            boolean modified = addToBackup(deviceId, nodeId);
            if (modified) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getNodes(deviceId)));
            }
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return null;
}
#method_after
@Override
public synchronized CompletableFuture<MastershipEvent> setStandby(NodeId nodeId, DeviceId deviceId) {
    MastershipRole role = getRole(nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(deviceId, nodeId);
            if (backup == null) {
                // no master alternative
                masterMap.remove(deviceId);
                // TODO: Should there be new event type for no MASTER?
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(deviceId)));
            } else {
                NodeId prevMaster = masterMap.put(deviceId, backup);
                incrementTerm(deviceId);
                addToBackup(deviceId, prevMaster);
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(deviceId)));
            }
        case STANDBY:
        case NONE:
            boolean modified = addToBackup(deviceId, nodeId);
            if (modified) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getMastership(deviceId)));
            }
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return null;
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<MastershipEvent> relinquishRole(NodeId nodeId, DeviceId deviceId) {
    MastershipRole role = getRole(nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(deviceId, nodeId);
            masterMap.put(deviceId, backup);
            incrementTerm(deviceId);
            return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(deviceId)));
        case STANDBY:
            if (removeFromBackups(deviceId, nodeId)) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getNodes(deviceId)));
            }
            break;
        case NONE:
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public synchronized CompletableFuture<MastershipEvent> relinquishRole(NodeId nodeId, DeviceId deviceId) {
    MastershipRole role = getRole(nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(deviceId, nodeId);
            masterMap.put(deviceId, backup);
            incrementTerm(deviceId);
            return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(deviceId)));
        case STANDBY:
            if (removeFromBackups(deviceId, nodeId)) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getMastership(deviceId)));
            }
            break;
        case NONE:
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public AsyncDistributedSet<E> build() {
    return new AtomixDistributedSet<E>(atomix.<E>setBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncDistributedSet<E> build() {
    return new AtomixDistributedSet<E>(atomix.<E>setBuilder(name()).withRegistrationRequired().withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public List<MapInfo> getMapInfo() {
    Serializer serializer = Serializer.using(KryoNamespaces.BASIC);
    return atomix.getPrimitives(ConsistentMapType.instance()).stream().map(info -> {
        io.atomix.core.map.ConsistentMap<String, byte[]> map = atomix.<String, byte[]>consistentMapBuilder(info.name()).withSerializer(new AtomixSerializerAdapter(serializer)).build();
        int size = map.size();
        map.close();
        return new MapInfo(info.name(), size);
    }).collect(Collectors.toList());
}
#method_after
@Override
public List<MapInfo> getMapInfo() {
    Serializer serializer = Serializer.using(KryoNamespaces.BASIC);
    return atomix.getPrimitives(AtomicMapType.instance()).stream().map(info -> {
        io.atomix.core.map.AtomicMap<String, byte[]> map = atomix.<String, byte[]>atomicMapBuilder(info.name()).withSerializer(new AtomixSerializerAdapter(serializer)).build();
        int size = map.size();
        map.close();
        return new MapInfo(info.name(), size);
    }).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public Map<String, WorkQueueStats> getQueueStats() {
    Serializer serializer = Serializer.using(KryoNamespaces.BASIC);
    return atomix.getPrimitives(WorkQueueType.instance()).stream().map(info -> {
        io.atomix.core.queue.WorkQueue queue = atomix.workQueueBuilder(info.name()).withSerializer(new AtomixSerializerAdapter(serializer)).build();
        io.atomix.core.queue.WorkQueueStats stats = queue.stats();
        return Maps.immutableEntry(info.name(), WorkQueueStats.builder().withTotalCompleted(stats.totalCompleted()).withTotalInProgress(stats.totalInProgress()).withTotalPending(stats.totalPending()).build());
    }).collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));
}
#method_after
@Override
public Map<String, WorkQueueStats> getQueueStats() {
    Serializer serializer = Serializer.using(KryoNamespaces.BASIC);
    return atomix.getPrimitives(WorkQueueType.instance()).stream().map(info -> {
        io.atomix.core.workqueue.WorkQueue queue = atomix.workQueueBuilder(info.name()).withSerializer(new AtomixSerializerAdapter(serializer)).build();
        io.atomix.core.workqueue.WorkQueueStats stats = queue.stats();
        return Maps.immutableEntry(info.name(), WorkQueueStats.builder().withTotalCompleted(stats.totalCompleted()).withTotalInProgress(stats.totalInProgress()).withTotalPending(stats.totalPending()).build());
    }).collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));
}
#end_block

#method_before
@Override
public AsyncAtomicIdGenerator build() {
    return new AtomixAtomicIdGenerator(atomix.atomicIdGeneratorBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncAtomicIdGenerator build() {
    return new AtomixAtomicIdGenerator(atomix.atomicIdGeneratorBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public AsyncAtomicCounterMap<K> buildAsyncMap() {
    return new AtomixAtomicCounterMap<K>(atomix.<K>atomicCounterMapBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncAtomicCounterMap<K> buildAsyncMap() {
    return new AtomixAtomicCounterMap<K>(atomix.<K>atomicCounterMapBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public AsyncDistributedLock build() {
    return new AtomixDistributedLock(atomix.lockBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncDistributedLock build() {
    return new AtomixDistributedLock(atomix.atomicLockBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public AsyncAtomicValue<V> build() {
    return new AtomixAtomicValue<V>(atomix.<V>atomicValueBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncAtomicValue<V> build() {
    return new AtomixAtomicValue<V>(atomix.<V>atomicValueBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public AsyncDocumentTree<V> buildDocumentTree() {
    return new AtomixDocumentTree<>(atomix.<V>documentTreeBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncDocumentTree<V> buildDocumentTree() {
    return new AtomixDocumentTree<>(atomix.<V>atomicDocumentTreeBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public CompletableFuture<MastershipRole> requestRole(NetworkId networkId, DeviceId deviceId) {
    // query+possible reelection
    NodeId node = clusterService.getLocalNode().id();
    MastershipRole role = getRole(networkId, node, deviceId);
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    switch(role) {
        case MASTER:
            return CompletableFuture.completedFuture(MastershipRole.MASTER);
        case STANDBY:
            if (getMaster(networkId, deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(networkId, deviceId);
                // remove from backup list
                removeFromBackups(networkId, deviceId, node);
                notifyDelegate(networkId, new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(networkId, deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        case NONE:
            if (getMaster(networkId, deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(networkId, deviceId);
                notifyDelegate(networkId, new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(networkId, deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            // add to backup list
            if (addToBackup(networkId, deviceId, node)) {
                notifyDelegate(networkId, new MastershipEvent(BACKUPS_CHANGED, deviceId, getNodes(networkId, deviceId)));
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(role);
}
#method_after
@Override
public CompletableFuture<MastershipRole> requestRole(NetworkId networkId, DeviceId deviceId) {
    // query+possible reelection
    NodeId node = clusterService.getLocalNode().id();
    MastershipRole role = getRole(networkId, node, deviceId);
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    switch(role) {
        case MASTER:
            return CompletableFuture.completedFuture(MastershipRole.MASTER);
        case STANDBY:
            if (getMaster(networkId, deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(networkId, deviceId);
                // remove from backup list
                removeFromBackups(networkId, deviceId, node);
                notifyDelegate(networkId, new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(networkId, deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        case NONE:
            if (getMaster(networkId, deviceId) == null) {
                // no master => become master
                masterMap.put(deviceId, node);
                incrementTerm(networkId, deviceId);
                notifyDelegate(networkId, new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(networkId, deviceId)));
                return CompletableFuture.completedFuture(MastershipRole.MASTER);
            }
            // add to backup list
            if (addToBackup(networkId, deviceId, node)) {
                notifyDelegate(networkId, new MastershipEvent(BACKUPS_CHANGED, deviceId, getMastership(networkId, deviceId)));
            }
            return CompletableFuture.completedFuture(MastershipRole.STANDBY);
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(role);
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<MastershipEvent> setMaster(NetworkId networkId, NodeId nodeId, DeviceId deviceId) {
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    MastershipRole role = getRole(networkId, nodeId, deviceId);
    switch(role) {
        case MASTER:
            // no-op
            return CompletableFuture.completedFuture(null);
        case STANDBY:
        case NONE:
            NodeId prevMaster = masterMap.put(deviceId, nodeId);
            incrementTerm(networkId, deviceId);
            removeFromBackups(networkId, deviceId, nodeId);
            addToBackup(networkId, deviceId, prevMaster);
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
            return null;
    }
    return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(networkId, deviceId)));
}
#method_after
@Override
public synchronized CompletableFuture<MastershipEvent> setMaster(NetworkId networkId, NodeId nodeId, DeviceId deviceId) {
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    MastershipRole role = getRole(networkId, nodeId, deviceId);
    switch(role) {
        case MASTER:
            // no-op
            return CompletableFuture.completedFuture(null);
        case STANDBY:
        case NONE:
            NodeId prevMaster = masterMap.put(deviceId, nodeId);
            incrementTerm(networkId, deviceId);
            removeFromBackups(networkId, deviceId, nodeId);
            addToBackup(networkId, deviceId, prevMaster);
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
            return null;
    }
    return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(networkId, deviceId)));
}
#end_block

#method_before
@Override
public CompletableFuture<MastershipEvent> setStandby(NetworkId networkId, NodeId nodeId, DeviceId deviceId) {
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    MastershipRole role = getRole(networkId, nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(networkId, deviceId, nodeId);
            if (backup == null) {
                // no master alternative
                masterMap.remove(deviceId);
                // TODO: Should there be new event type for no MASTER?
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(networkId, deviceId)));
            } else {
                NodeId prevMaster = masterMap.put(deviceId, backup);
                incrementTerm(networkId, deviceId);
                addToBackup(networkId, deviceId, prevMaster);
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(networkId, deviceId)));
            }
        case STANDBY:
        case NONE:
            boolean modified = addToBackup(networkId, deviceId, nodeId);
            if (modified) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getNodes(networkId, deviceId)));
            }
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return null;
}
#method_after
@Override
public CompletableFuture<MastershipEvent> setStandby(NetworkId networkId, NodeId nodeId, DeviceId deviceId) {
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    MastershipRole role = getRole(networkId, nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(networkId, deviceId, nodeId);
            if (backup == null) {
                // no master alternative
                masterMap.remove(deviceId);
                // TODO: Should there be new event type for no MASTER?
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(networkId, deviceId)));
            } else {
                NodeId prevMaster = masterMap.put(deviceId, backup);
                incrementTerm(networkId, deviceId);
                addToBackup(networkId, deviceId, prevMaster);
                return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(networkId, deviceId)));
            }
        case STANDBY:
        case NONE:
            boolean modified = addToBackup(networkId, deviceId, nodeId);
            if (modified) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getMastership(networkId, deviceId)));
            }
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return null;
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<MastershipEvent> relinquishRole(NetworkId networkId, NodeId nodeId, DeviceId deviceId) {
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    MastershipRole role = getRole(networkId, nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(networkId, deviceId, nodeId);
            masterMap.put(deviceId, backup);
            incrementTerm(networkId, deviceId);
            return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getNodes(networkId, deviceId)));
        case STANDBY:
            if (removeFromBackups(networkId, deviceId, nodeId)) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getNodes(networkId, deviceId)));
            }
            break;
        case NONE:
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public synchronized CompletableFuture<MastershipEvent> relinquishRole(NetworkId networkId, NodeId nodeId, DeviceId deviceId) {
    Map<DeviceId, NodeId> masterMap = getMasterMap(networkId);
    MastershipRole role = getRole(networkId, nodeId, deviceId);
    switch(role) {
        case MASTER:
            NodeId backup = reelect(networkId, deviceId, nodeId);
            masterMap.put(deviceId, backup);
            incrementTerm(networkId, deviceId);
            return CompletableFuture.completedFuture(new MastershipEvent(MASTER_CHANGED, deviceId, getMastership(networkId, deviceId)));
        case STANDBY:
            if (removeFromBackups(networkId, deviceId, nodeId)) {
                return CompletableFuture.completedFuture(new MastershipEvent(BACKUPS_CHANGED, deviceId, getMastership(networkId, deviceId)));
            }
            break;
        case NONE:
            break;
        default:
            log.warn("unknown Mastership Role {}", role);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public AsyncConsistentMap<K, V> buildAsyncMap() {
    return new AtomixConsistentMap<>(atomix.<K, V>consistentMapBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#method_after
@Override
public AsyncConsistentMap<K, V> buildAsyncMap() {
    return new AtomixConsistentMap<>(atomix.<K, V>atomicMapBuilder(name()).withRegistrationRequired().withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer())).build().async());
}
#end_block

#method_before
@Override
public CompletableFuture<NavigableSet<String>> navigableKeySet() {
    return atomixTreeMap.navigableKeySet();
}
#method_after
@Override
public CompletableFuture<NavigableSet<String>> navigableKeySet() {
    return CompletableFuture.completedFuture(atomixTreeMap.navigableKeySet().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<NavigableMap<String, V>> subMap(String upperKey, String lowerKey, boolean inclusiveUpper, boolean inclusiveLower) {
    return atomixTreeMap.subMap(upperKey, lowerKey, inclusiveUpper, inclusiveLower);
}
#method_after
@Override
public CompletableFuture<NavigableMap<String, V>> subMap(String upperKey, String lowerKey, boolean inclusiveUpper, boolean inclusiveLower) {
    return CompletableFuture.completedFuture(new DelegatingAsyncDistributedNavigableMap<>(atomixTreeMap.subMap(lowerKey, inclusiveLower, upperKey, inclusiveUpper)).sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Set<String>> keySet() {
    return atomixTreeMap.keySet();
}
#method_after
@Override
public CompletableFuture<Set<String>> keySet() {
    return CompletableFuture.completedFuture(atomixTreeMap.keySet().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Set<Map.Entry<String, Versioned<V>>>> entrySet() {
    return atomixTreeMap.entrySet().thenApply(entries -> entries.stream().map(this::toVersioned).collect(Collectors.toSet()));
}
#method_after
@Override
public CompletableFuture<Set<Map.Entry<String, Versioned<V>>>> entrySet() {
    return CompletableFuture.completedFuture(atomixTreeMap.entrySet().stream().map(this::toVersioned).collect(Collectors.toSet()));
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Versioned<V>>> values() {
    return atomixTreeMap.values().thenApply(values -> values.stream().map(this::toVersioned).collect(Collectors.toList()));
}
#method_after
@Override
public CompletableFuture<Collection<Versioned<V>>> values() {
    return CompletableFuture.completedFuture(new TranscodingAsyncDistributedCollection<Versioned<V>, io.atomix.utils.time.Versioned<V>>(atomixTreeMap.values(), e -> new io.atomix.utils.time.Versioned<>(e.value(), e.version()), e -> new Versioned<>(e.value(), e.version())).sync());
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addListener(MapEventListener<String, V> listener, Executor executor) {
    io.atomix.core.map.MapEventListener<String, V> atomixListener = event -> listener.event(new MapEvent<String, V>(MapEvent.Type.valueOf(event.type().name()), event.name(), event.key(), toVersioned(event.newValue()), toVersioned(event.oldValue())));
    listenerMap.put(listener, atomixListener);
    return atomixTreeMap.addListener(atomixListener, executor);
}
#method_after
@Override
public synchronized CompletableFuture<Void> addListener(MapEventListener<String, V> listener, Executor executor) {
    io.atomix.core.map.AtomicMapEventListener<String, V> atomixListener = event -> listener.event(new MapEvent<String, V>(MapEvent.Type.valueOf(event.type().name()), name(), event.key(), toVersioned(event.newValue()), toVersioned(event.oldValue())));
    listenerMap.put(listener, atomixListener);
    return atomixTreeMap.addListener(atomixListener, executor);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(MapEventListener<String, V> listener) {
    io.atomix.core.map.MapEventListener<String, V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixTreeMap.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(MapEventListener<String, V> listener) {
    io.atomix.core.map.AtomicMapEventListener<String, V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixTreeMap.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
private Atomix createAtomix() {
    return Atomix.builder(getClass().getClassLoader()).withClusterName(metadataService.getClusterMetadata().getName()).withLocalMember(toLocalMember(metadataService.getLocalNode())).withMembers(metadataService.getClusterMetadata().getConsensusNodes().stream().map(AtomixManager::toMember).collect(Collectors.toList())).build();
}
#method_after
private Atomix createAtomix() {
    return Atomix.builder(getClass().getClassLoader()).withClusterId(metadataService.getClusterMetadata().getName()).withMemberId(metadataService.getLocalNode().id().id()).withAddress(metadataService.getLocalNode().ip().toString(), metadataService.getLocalNode().tcpPort()).withProperty("type", "onos").withMembershipProvider(BootstrapDiscoveryProvider.builder().withNodes(metadataService.getClusterMetadata().getStorageNodes().stream().map(node -> io.atomix.cluster.Node.builder().withId(node.id().id()).withAddress(node.ip().toString(), node.tcpPort()).build()).collect(Collectors.toList())).build()).build();
}
#end_block

#method_before
@Override
public AsyncLeaderElector build() {
    Serializer serializer = Serializer.using(KryoNamespaces.API);
    return new AtomixLeaderElector(atomix.<NodeId>leaderElectorBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withCacheEnabled(relaxedReadConsistency()).withSerializer(new AtomixSerializerAdapter(serializer)).build().async(), localNodeId);
}
#method_after
@Override
public AsyncLeaderElector build() {
    Serializer serializer = Serializer.using(KryoNamespaces.API);
    return new AtomixLeaderElector(atomix.<NodeId>leaderElectorBuilder(name()).withProtocol(MultiRaftProtocol.builder(group).withRecoveryStrategy(Recovery.RECOVER).withMaxRetries(MAX_RETRIES).build()).withReadOnly(readOnly()).withSerializer(new AtomixSerializerAdapter(serializer)).build().async(), localNodeId);
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addListener(DocumentPath path, DocumentTreeListener<V> listener) {
    io.atomix.core.tree.DocumentTreeListener<V> atomixListener = event -> listener.event(new DocumentTreeEvent<V>(DocumentPath.from(event.path().pathElements()), DocumentTreeEvent.Type.valueOf(event.type().name()), event.newValue().map(this::toVersioned), event.oldValue().map(this::toVersioned)));
    listenerMap.put(listener, atomixListener);
    return atomixTree.addListener(toAtomixPath(path), atomixListener);
}
#method_after
@Override
public synchronized CompletableFuture<Void> addListener(DocumentPath path, DocumentTreeListener<V> listener) {
    io.atomix.core.tree.DocumentTreeEventListener<V> atomixListener = event -> listener.event(new DocumentTreeEvent<V>(DocumentPath.from(event.path().pathElements()), DocumentTreeEvent.Type.valueOf(event.type().name()), event.newValue().map(this::toVersioned), event.oldValue().map(this::toVersioned)));
    listenerMap.put(listener, atomixListener);
    return atomixTree.addListener(toAtomixPath(path), atomixListener);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(DocumentTreeListener<V> listener) {
    io.atomix.core.tree.DocumentTreeListener<V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixTree.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(DocumentTreeListener<V> listener) {
    io.atomix.core.tree.DocumentTreeEventListener<V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixTree.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public CompletableFuture<Set<K>> keySet() {
    return atomixMap.keySet();
}
#method_after
@Override
public CompletableFuture<Set<K>> keySet() {
    return CompletableFuture.completedFuture(atomixMap.keySet().sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Versioned<V>>> values() {
    return atomixMap.values().thenApply(values -> values.stream().map(this::toVersioned).collect(Collectors.toList()));
}
#method_after
@Override
public CompletableFuture<Collection<Versioned<V>>> values() {
    return CompletableFuture.completedFuture(new TranscodingAsyncDistributedCollection<Versioned<V>, io.atomix.utils.time.Versioned<V>>(atomixMap.values(), v -> new io.atomix.utils.time.Versioned<>(v.value(), v.version()), v -> new Versioned<>(v.value(), v.version())).sync());
}
#end_block

#method_before
@Override
public CompletableFuture<Set<Map.Entry<K, Versioned<V>>>> entrySet() {
    return atomixMap.entrySet().thenApply(entries -> entries.stream().map(entry -> Maps.immutableEntry(entry.getKey(), toVersioned(entry.getValue()))).collect(Collectors.toSet()));
}
#method_after
@Override
public CompletableFuture<Set<Map.Entry<K, Versioned<V>>>> entrySet() {
    return CompletableFuture.completedFuture(new TranscodingAsyncDistributedSet<Map.Entry<K, Versioned<V>>, Map.Entry<K, io.atomix.utils.time.Versioned<V>>>(atomixMap.entrySet(), e -> Maps.immutableEntry(e.getKey(), new io.atomix.utils.time.Versioned<>(e.getValue().value(), e.getValue().version())), e -> Maps.immutableEntry(e.getKey(), new Versioned<>(e.getValue().value(), e.getValue().version()))).sync());
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addListener(MapEventListener<K, V> listener, Executor executor) {
    io.atomix.core.map.MapEventListener<K, V> atomixListener = event -> listener.event(new MapEvent<K, V>(MapEvent.Type.valueOf(event.type().name()), event.name(), event.key(), toVersioned(event.newValue()), toVersioned(event.oldValue())));
    listenerMap.put(listener, atomixListener);
    return atomixMap.addListener(atomixListener, executor);
}
#method_after
@Override
public synchronized CompletableFuture<Void> addListener(MapEventListener<K, V> listener, Executor executor) {
    io.atomix.core.map.AtomicMapEventListener<K, V> atomixListener = event -> listener.event(new MapEvent<K, V>(MapEvent.Type.valueOf(event.type().name()), name(), event.key(), toVersioned(event.newValue()), toVersioned(event.oldValue())));
    listenerMap.put(listener, atomixListener);
    return atomixMap.addListener(atomixListener, executor);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(MapEventListener<K, V> listener) {
    io.atomix.core.map.MapEventListener<K, V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixMap.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(MapEventListener<K, V> listener) {
    io.atomix.core.map.AtomicMapEventListener<K, V> atomixListener = listenerMap.remove(listener);
    if (atomixListener != null) {
        return atomixMap.removeListener(atomixListener);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public String createRule() {
    String rule = "flow create " + Long.toString(this.interfaceNumber) + " ";
    return rule + ruleBody();
}
#method_after
@Override
public String createRule() {
    return "flow create " + Long.toString(this.interfaceNumber) + " " + ruleBody();
}
#end_block

#method_before
@Override
public String removeRule() {
    String rule = "flow destroy " + Long.toString(this.interfaceNumber) + " rule " + id().toString();
    return rule;
}
#method_after
@Override
public String removeRule() {
    return "flow destroy " + Long.toString(this.interfaceNumber) + " rule " + id().toString();
}
#end_block

#method_before
public static String findNicInterfaceWithPort(DeviceId deviceId, long port) {
    return nicInterfaceToPortMap.entrySet().stream().filter(nic -> nic.getKey().contains(deviceId.toString()) && nic.getValue() == port).map(nic -> nic.getKey().substring(nic.getKey().lastIndexOf(':') + 1)).collect(Collectors.joining());
}
#method_after
public static String findNicInterfaceWithPort(DeviceId deviceId, long port) {
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) controller.getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        return null;
    }
    checkNotNull(device, DEVICE_NULL);
    return device.portNameFromNumber(port);
}
#end_block

#method_before
private DeviceDescription getDeviceDetails(DeviceId deviceId) {
    // Create a description for this server device
    ServerDeviceDescription desc = null;
    // Retrieve the device ID, if null given
    if (deviceId == null) {
        deviceId = getHandler().data().deviceId();
        checkNotNull(deviceId, DEVICE_ID_NULL);
    }
    // Get the device
    RestSBDevice device = getController().getDevice(deviceId);
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, RESOURCE_DISCOVERY_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    if (jsonMap == null) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Get all the attributes
    String id = get(jsonNode, BasicServerDriver.PARAM_ID);
    String vendor = get(jsonNode, PARAM_MANUFACTURER);
    String hw = get(jsonNode, PARAM_HW_VENDOR);
    String sw = get(jsonNode, PARAM_SW_VENDOR);
    String serial = get(jsonNode, PARAM_SERIAL);
    // CPUs are composite attributes
    Set<CpuDevice> cpuSet = new HashSet<CpuDevice>();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    // Construct CPU objects
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // All the CPU attributes
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        String cpuVendorStr = get(cn, CPU_PARAM_VENDOR);
        long cpuFrequency = cpuObjNode.path(CPU_PARAM_FREQUENCY).asLong();
        // Verify that this is a valid vendor
        CpuVendor cpuVendor = CpuVendor.getByName(cpuVendorStr);
        checkNotNull(cpuVendor, CPU_VENDOR_NULL);
        // Construct a CPU device
        CpuDevice cpu = new DefaultCpuDevice(cpuId, cpuVendor, cpuFrequency);
        // Add it to the set
        cpuSet.add(cpu);
    }
    // NICs are composite attributes too
    Set<NicDevice> nicSet = new HashSet<NicDevice>();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    // Construct NIC objects
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        long nicIndex = nicObjNode.path(NIC_PARAM_PORT_INDEX).asLong();
        long speed = nicObjNode.path(NIC_PARAM_SPEED).asLong();
        String portTypeStr = get(nn, NIC_PARAM_PORT_TYPE);
        Port.Type portType = PORT_TYPE_MAP.get(portTypeStr);
        if (portType == null) {
            throw new IllegalArgumentException(portTypeStr + " is not a valid port type for NIC " + nicName);
        }
        boolean status = nicObjNode.path(NIC_PARAM_STATUS).asInt() > 0;
        String hwAddr = get(nn, NIC_PARAM_HW_ADDR);
        JsonNode tagNode = nicObjNode.path(BasicServerDriver.NIC_PARAM_RX_FILTER);
        if (tagNode == null) {
            throw new IllegalArgumentException("The Rx filters of NIC " + nicName + " are not reported");
        }
        // Convert the JSON list into an array of strings
        List<String> rxFilters = null;
        try {
            rxFilters = mapper.readValue(tagNode.traverse(), new TypeReference<ArrayList<String>>() {
            });
        } catch (IOException ioEx) {
            continue;
        }
        // Parse the array of strings and create an RxFilter object
        NicRxFilter rxFilterMechanism = new NicRxFilter();
        for (String s : rxFilters) {
            // Verify that this is a valid Rx filter
            RxFilter rf = RxFilter.getByName(s);
            checkNotNull(rf, NIC_RX_FILTER_NULL);
            rxFilterMechanism.addRxFilter(rf);
        }
        // Map device:NIC --> ONOS port ID
        nicInterfaceToPortMap.put(deviceId.toString() + ":" + nicName, nicIndex);
        // Construct a NIC device for this server
        NicDevice nic = new DefaultNicDevice(nicName, nicIndex, portType, speed, status, hwAddr, rxFilterMechanism);
        // Add it to the set
        nicSet.add(nic);
    }
    // Construct a complete server device object.
    // Lists of NICs and CPUs extend the information
    // already in RestSBDevice (parent class).
    RestServerSBDevice dev = new DefaultRestServerSBDevice(device.ip(), device.port(), device.username(), device.password(), device.protocol(), device.url(), device.isActive(), device.testUrl().toString(), vendor, hw, sw, AuthenticationScheme.BASIC, "", cpuSet, nicSet);
    checkNotNull(dev, DEVICE_NULL);
    // Updates the controller with the complete device information
    getController().removeDevice(deviceId);
    getController().addDevice((RestSBDevice) dev);
    try {
        desc = new DefaultServerDeviceDescription(new URI(id), Device.Type.SERVER, vendor, hw, sw, serial, new ChassisId(), cpuSet, nicSet, DefaultAnnotations.EMPTY);
    } catch (URISyntaxException uEx) {
        log.error("Failed to create a server device description for: {}", deviceId);
        return null;
    }
    log.info("Device's {} details sent to the controller", deviceId);
    return desc;
}
#method_after
private DeviceDescription getDeviceDetails(DeviceId deviceId) {
    // Create a description for this server device
    ServerDeviceDescription desc = null;
    // Retrieve the device ID, if null given
    if (deviceId == null) {
        deviceId = getHandler().data().deviceId();
        checkNotNull(deviceId, DEVICE_ID_NULL);
    }
    // Get the device
    RestSBDevice device = getController().getDevice(deviceId);
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, RESOURCE_DISCOVERY_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    if (jsonMap == null) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Get all the attributes
    String id = get(jsonNode, BasicServerDriver.PARAM_ID);
    String vendor = get(jsonNode, PARAM_MANUFACTURER);
    String hw = get(jsonNode, PARAM_HW_VENDOR);
    String sw = get(jsonNode, PARAM_SW_VENDOR);
    String serial = get(jsonNode, PARAM_SERIAL);
    // CPUs are composite attributes
    Set<CpuDevice> cpuSet = new HashSet<CpuDevice>();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    // Construct CPU objects
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // All the CPU attributes
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        String cpuVendorStr = get(cn, CPU_PARAM_VENDOR);
        long cpuFrequency = cpuObjNode.path(CPU_PARAM_FREQUENCY).asLong();
        // Verify that this is a valid vendor
        CpuVendor cpuVendor = CpuVendor.getByName(cpuVendorStr);
        checkNotNull(cpuVendor, CPU_VENDOR_NULL);
        // Construct a CPU device
        CpuDevice cpu = new DefaultCpuDevice(cpuId, cpuVendor, cpuFrequency);
        // Add it to the set
        cpuSet.add(cpu);
    }
    // NICs are composite attributes too
    Set<NicDevice> nicSet = new HashSet<NicDevice>();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
    // Construct NIC objects
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        long nicIndex = nicObjNode.path(NIC_PARAM_PORT_INDEX).asLong();
        long speed = nicObjNode.path(NIC_PARAM_SPEED).asLong();
        String portTypeStr = get(nn, NIC_PARAM_PORT_TYPE);
        Port.Type portType = PORT_TYPE_MAP.get(portTypeStr);
        if (portType == null) {
            throw new IllegalArgumentException(portTypeStr + " is not a valid port type for NIC " + nicName);
        }
        boolean status = nicObjNode.path(NIC_PARAM_STATUS).asInt() > 0;
        String hwAddr = get(nn, NIC_PARAM_HW_ADDR);
        JsonNode tagNode = nicObjNode.path(BasicServerDriver.NIC_PARAM_RX_FILTER);
        if (tagNode == null) {
            throw new IllegalArgumentException("The Rx filters of NIC " + nicName + " are not reported");
        }
        // Convert the JSON list into an array of strings
        List<String> rxFilters = null;
        try {
            rxFilters = mapper.readValue(tagNode.traverse(), new TypeReference<ArrayList<String>>() {
            });
        } catch (IOException ioEx) {
            continue;
        }
        // Parse the array of strings and create an RxFilter object
        NicRxFilter rxFilterMechanism = new NicRxFilter();
        for (String s : rxFilters) {
            // Verify that this is a valid Rx filter
            RxFilter rf = RxFilter.getByName(s);
            checkNotNull(rf, NIC_RX_FILTER_NULL);
            rxFilterMechanism.addRxFilter(rf);
        }
        // Store NIC name to number mapping as an annotation
        annotations.set(nicName, Long.toString(nicIndex));
        // Construct a NIC device for this server
        NicDevice nic = new DefaultNicDevice(nicName, nicIndex, portType, speed, status, hwAddr, rxFilterMechanism);
        // Add it to the set
        nicSet.add(nic);
    }
    // Construct a complete server device object.
    // Lists of NICs and CPUs extend the information
    // already in RestSBDevice (parent class).
    RestServerSBDevice dev = new DefaultRestServerSBDevice(device.ip(), device.port(), device.username(), device.password(), device.protocol(), device.url(), device.isActive(), device.testUrl().toString(), vendor, hw, sw, AuthenticationScheme.BASIC, "", cpuSet, nicSet);
    checkNotNull(dev, DEVICE_NULL);
    // Updates the controller with the complete device information
    getController().removeDevice(deviceId);
    getController().addDevice((RestSBDevice) dev);
    try {
        desc = new DefaultServerDeviceDescription(new URI(id), Device.Type.SERVER, vendor, hw, sw, serial, new ChassisId(), cpuSet, nicSet, annotations.build());
    } catch (URISyntaxException uEx) {
        log.error("Failed to create a server device description for: {}", deviceId);
        return null;
    }
    log.info("Device's {} details sent to the controller", deviceId);
    return desc;
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    // List of port descriptions to return
    List<PortDescription> portDescriptions = Lists.newArrayList();
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // .. and object
    RestServerSBDevice device = null;
    // In case this method is called before discoverDeviceDetails,
    // there is missing information to be gathered.
    short i = 0;
    while ((device == null) && (i < DISCOVERY_RETRIES)) {
        i++;
        try {
            device = (RestServerSBDevice) getController().getDevice(deviceId);
        } catch (ClassCastException ccEx) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException intEx) {
                // Just retry
                continue;
            }
        }
        // No device
        if (device == null) {
            // This method will add the device to the RestSBController
            this.getDeviceDetails(deviceId);
        }
    }
    if ((device == null) || (device.nics() == null)) {
        log.error("No ports available on {}", deviceId);
        return ImmutableList.copyOf(portDescriptions);
    }
    // Sorted list of NIC ports
    Set<NicDevice> nics = new TreeSet(device.nics());
    // Iterate through the NICs of this device to populate the list
    for (NicDevice nic : nics) {
        // Include the name of this device as an annotation
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, nic.name());
        // Create a port description and add it to the list
        portDescriptions.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(nic.portNumber(), nic.name())).isEnabled(nic.status()).type(nic.portType()).portSpeed(nic.speed()).annotations(annotations.build()).build());
        log.info("Port discovery on device {}: NIC {} is {} at {} Mbps", deviceId, nic.portNumber(), nic.status() ? "up" : "down", nic.speed());
    }
    return ImmutableList.copyOf(portDescriptions);
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    // List of port descriptions to return
    List<PortDescription> portDescriptions = Lists.newArrayList();
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // .. and object
    RestServerSBDevice device = null;
    // In case this method is called before discoverDeviceDetails,
    // there is missing information to be gathered.
    short i = 0;
    while ((device == null) && (i < DISCOVERY_RETRIES)) {
        i++;
        try {
            device = (RestServerSBDevice) getController().getDevice(deviceId);
        } catch (ClassCastException ccEx) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException intEx) {
                // Just retry
                continue;
            }
        }
        // No device
        if (device == null) {
            // This method will add the device to the RestSBController
            this.getDeviceDetails(deviceId);
        }
    }
    if ((device == null) || (device.nics() == null)) {
        log.error("No ports available on {}", deviceId);
        return Collections.EMPTY_LIST;
    }
    // Sorted list of NIC ports
    Set<NicDevice> nics = new TreeSet(device.nics());
    // Iterate through the NICs of this device to populate the list
    for (NicDevice nic : nics) {
        // Include the name of this device as an annotation
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, nic.name());
        // Create a port description and add it to the list
        portDescriptions.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(nic.portNumber(), nic.name())).isEnabled(nic.status()).type(nic.portType()).portSpeed(nic.speed()).annotations(annotations.build()).build());
        log.info("Port discovery on device {}: NIC {} is {} at {} Mbps", deviceId, nic.portNumber(), nic.status() ? "up" : "down", nic.speed());
    }
    return ImmutableList.copyOf(portDescriptions);
}
#end_block

#method_before
private Collection<PortStatistics> getPortStatistics(DeviceId deviceId) {
    // List of port statistics to return
    Collection<PortStatistics> portStats = null;
    // Get global monitoring statistics
    MonitoringStatistics monStats = getGlobalMonitoringStatistics(deviceId);
    if (monStats == null) {
        return Collections.EMPTY_LIST;
    }
    // Filter out the NIC statistics
    portStats = monStats.nicStatisticsAll();
    if (portStats == null) {
        return Collections.EMPTY_LIST;
    }
    log.debug("Port statistics: {}", portStats.toString());
    return portStats;
}
#method_after
private Collection<PortStatistics> getPortStatistics(DeviceId deviceId) {
    // Get global monitoring statistics
    MonitoringStatistics monStats = getGlobalMonitoringStatistics(deviceId);
    if (monStats == null) {
        return Collections.EMPTY_LIST;
    }
    // Filter out the NIC statistics
    Collection<PortStatistics> portStats = monStats.nicStatisticsAll();
    if (portStats == null) {
        return Collections.EMPTY_LIST;
    }
    log.debug("Port statistics: {}", portStats.toString());
    return portStats;
}
#end_block

#method_before
public Collection<CpuStatistics> getCpuStatistics(DeviceId deviceId) {
    // List of port statistics to return
    Collection<CpuStatistics> cpuStats = null;
    // Get global monitoring statistics
    MonitoringStatistics monStats = getGlobalMonitoringStatistics(deviceId);
    if (monStats == null) {
        return Collections.EMPTY_LIST;
    }
    // Filter out the CPU statistics
    cpuStats = monStats.cpuStatisticsAll();
    if (cpuStats == null) {
        return Collections.EMPTY_LIST;
    }
    log.debug("CPU statistics: {}", cpuStats.toString());
    return cpuStats;
}
#method_after
public Collection<CpuStatistics> getCpuStatistics(DeviceId deviceId) {
    // Get global monitoring statistics
    MonitoringStatistics monStats = getGlobalMonitoringStatistics(deviceId);
    if (monStats == null) {
        return Collections.EMPTY_LIST;
    }
    // Filter out the CPU statistics
    Collection<CpuStatistics> cpuStats = monStats.cpuStatisticsAll();
    if (cpuStats == null) {
        return Collections.EMPTY_LIST;
    }
    log.debug("CPU statistics: {}", cpuStats.toString());
    return cpuStats;
}
#end_block

#method_before
private Collection<CpuStatistics> parseCpuStatistics(DeviceId deviceId, JsonNode objNode) {
    Collection<CpuStatistics> cpuStats = Lists.newArrayList();
    if (objNode == null) {
        return cpuStats;
    }
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // CPU ID with its load and status
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        float cpuLoad = cpuObjNode.path(CPU_PARAM_LOAD).floatValue();
        boolean isBusy = cpuObjNode.path(CPU_PARAM_STATUS).booleanValue();
        // Incorporate these statistics into an object
        DefaultCpuStatistics.Builder cpuBuilder = DefaultCpuStatistics.builder();
        cpuBuilder.setDeviceId(deviceId).setId(cpuId).setLoad(cpuLoad).setIsBusy(isBusy).build();
        // We have statistics for this CPU core
        cpuStats.add(cpuBuilder.build());
    }
    return cpuStats;
}
#method_after
private Collection<CpuStatistics> parseCpuStatistics(DeviceId deviceId, JsonNode objNode) {
    if (objNode == null) {
        return Collections.EMPTY_LIST;
    }
    Collection<CpuStatistics> cpuStats = Lists.newArrayList();
    JsonNode cpuNode = objNode.path(BasicServerDriver.PARAM_CPUS);
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // CPU ID with its load and status
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        float cpuLoad = cpuObjNode.path(CPU_PARAM_LOAD).floatValue();
        boolean isBusy = cpuObjNode.path(CPU_PARAM_STATUS).booleanValue();
        // Incorporate these statistics into an object
        DefaultCpuStatistics.Builder cpuBuilder = DefaultCpuStatistics.builder();
        cpuBuilder.setDeviceId(deviceId).setId(cpuId).setLoad(cpuLoad).setIsBusy(isBusy).build();
        // We have statistics for this CPU core
        cpuStats.add(cpuBuilder.build());
    }
    return cpuStats;
}
#end_block

#method_before
private Collection<PortStatistics> parseNicStatistics(DeviceId deviceId, JsonNode objNode) {
    Collection<PortStatistics> nicStats = Lists.newArrayList();
    if (objNode == null) {
        return nicStats;
    }
    JsonNode nicNode = objNode.path(PARAM_NICS);
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        checkArgument(!Strings.isNullOrEmpty(nicName), "NIC name is empty or NULL");
        Long portObj = nicInterfaceToPortMap.get(deviceId.toString() + ":" + nicName);
        checkNotNull(portObj, "Unknown mapping between NIC name and ONOS port ID");
        long rxCount = nicObjNode.path(NIC_STATS_RX_COUNT).asLong();
        long rxBytes = nicObjNode.path(NIC_STATS_RX_BYTES).asLong();
        long rxDropped = nicObjNode.path(NIC_STATS_RX_DROPS).asLong();
        long rxErrors = nicObjNode.path(NIC_STATS_RX_ERRORS).asLong();
        long txCount = nicObjNode.path(NIC_STATS_TX_COUNT).asLong();
        long txBytes = nicObjNode.path(NIC_STATS_TX_BYTES).asLong();
        long txDropped = nicObjNode.path(NIC_STATS_TX_DROPS).asLong();
        long txErrors = nicObjNode.path(NIC_STATS_TX_ERRORS).asLong();
        // Incorporate these statistics into an object
        DefaultPortStatistics.Builder nicBuilder = DefaultPortStatistics.builder();
        nicBuilder.setDeviceId(deviceId).setPort(portObj.intValue()).setPacketsReceived(rxCount).setPacketsSent(txCount).setBytesReceived(rxBytes).setBytesSent(txBytes).setPacketsRxDropped(rxDropped).setPacketsRxErrors(rxErrors).setPacketsTxDropped(txDropped).setPacketsTxErrors(txErrors).build();
        // We have statistics for this NIC
        nicStats.add(nicBuilder.build());
    }
    return nicStats;
}
#method_after
private Collection<PortStatistics> parseNicStatistics(DeviceId deviceId, JsonNode objNode) {
    if (objNode == null) {
        return Collections.EMPTY_LIST;
    }
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        return Collections.EMPTY_LIST;
    }
    checkNotNull(device, DEVICE_NULL);
    Collection<PortStatistics> nicStats = Lists.newArrayList();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicName = get(nn, NIC_PARAM_NAME);
        checkArgument(!Strings.isNullOrEmpty(nicName), "NIC name is empty or NULL");
        long portNumber = device.portNumberFromName(nicName);
        checkArgument(portNumber >= 0, "Unknown port ID " + portNumber + " for NIC " + nicName);
        long rxCount = nicObjNode.path(NIC_STATS_RX_COUNT).asLong();
        long rxBytes = nicObjNode.path(NIC_STATS_RX_BYTES).asLong();
        long rxDropped = nicObjNode.path(NIC_STATS_RX_DROPS).asLong();
        long rxErrors = nicObjNode.path(NIC_STATS_RX_ERRORS).asLong();
        long txCount = nicObjNode.path(NIC_STATS_TX_COUNT).asLong();
        long txBytes = nicObjNode.path(NIC_STATS_TX_BYTES).asLong();
        long txDropped = nicObjNode.path(NIC_STATS_TX_DROPS).asLong();
        long txErrors = nicObjNode.path(NIC_STATS_TX_ERRORS).asLong();
        // Incorporate these statistics into an object
        DefaultPortStatistics.Builder nicBuilder = DefaultPortStatistics.builder();
        nicBuilder.setDeviceId(deviceId).setPort((int) portNumber).setPacketsReceived(rxCount).setPacketsSent(txCount).setBytesReceived(rxBytes).setBytesSent(txBytes).setPacketsRxDropped(rxDropped).setPacketsRxErrors(rxErrors).setPacketsTxDropped(txDropped).setPacketsTxErrors(txErrors).build();
        // We have statistics for this NIC
        nicStats.add(nicBuilder.build());
    }
    return nicStats;
}
#end_block

#method_before
private void invokeInfluxDbPublisher(InfluxDbTelemetryService service, Set<FlowInfo> flowInfos) {
    DefaultInfluxRecord<String, Set<FlowInfo>> influxRecord = new DefaultInfluxRecord<>("", flowInfos);
    service.publish(influxRecord);
}
#method_after
private void invokeInfluxDbPublisher(InfluxDbTelemetryService service, Set<FlowInfo> flowInfos) {
    DefaultInfluxRecord<String, Set<FlowInfo>> influxRecord = new DefaultInfluxRecord<>(DEFAULT_INFLUXDB_MEASUREMENT, flowInfos);
    service.publish(influxRecord);
}
#end_block

#method_before
public String toString() {
    return toStringHelper(this).add("measurement", measurement).toString();
}
#method_after
public String toString() {
    return toStringHelper(this).add("measurement", measurement).add("flowInfos", flowInfos).toString();
}
#end_block

#method_before
@Override
public void start(TelemetryConfig config) {
    if (producer != null) {
        log.info("InfluxDB producer has already been started");
        return;
    }
    InfluxDbTelemetryConfig influxDbConfig = (InfluxDbTelemetryConfig) config;
    StringBuilder influxDbServerBuilder = new StringBuilder();
    influxDbServerBuilder.append(PROTOCOL);
    influxDbServerBuilder.append(":");
    influxDbServerBuilder.append("//");
    influxDbServerBuilder.append(influxDbConfig.address());
    influxDbServerBuilder.append(":");
    influxDbServerBuilder.append(influxDbConfig.port());
    producer = InfluxDBFactory.connect(influxDbServerBuilder.toString(), influxDbConfig.username(), influxDbConfig.password());
    log.info("InfluxDB producer has Started");
    createDB();
}
#method_after
@Override
public void start(TelemetryConfig config) {
    if (producer != null) {
        log.info("InfluxDB producer has already been started");
        return;
    }
    InfluxDbTelemetryConfig influxDbConfig = (InfluxDbTelemetryConfig) config;
    StringBuilder influxDbServerBuilder = new StringBuilder();
    influxDbServerBuilder.append(INFLUX_PROTOCOL);
    influxDbServerBuilder.append(":");
    influxDbServerBuilder.append("//");
    influxDbServerBuilder.append(influxDbConfig.address());
    influxDbServerBuilder.append(":");
    influxDbServerBuilder.append(influxDbConfig.port());
    producer = InfluxDBFactory.connect(influxDbServerBuilder.toString(), influxDbConfig.username(), influxDbConfig.password());
    database = influxDbConfig.database();
    measurement = influxDbConfig.measurement();
    log.info("InfluxDB producer has Started");
    createDB();
}
#end_block

#method_before
@Override
public void publish(InfluxRecord<String, Set<FlowInfo>> record) {
    if (producer == null) {
        log.warn("InfluxDB telemetry service has not been enabled!");
        return;
    }
    if (record.flowInfos().size() == 0) {
        log.warn("No record to publish");
        return;
    }
    log.debug("Publish {} stats records to InfluxDB", record.flowInfos().size());
    producer.setDatabase(DATABASE);
    BatchPoints batchPoints = BatchPoints.database(DATABASE).build();
    for (FlowInfo flowInfo : record.flowInfos()) {
        Point point = Point.measurement(record.measurement()).tag("flowType", String.valueOf(flowInfo.flowType())).tag("deviceId", flowInfo.deviceId().toString()).tag("inputInterfaceId", String.valueOf(flowInfo.inputInterfaceId())).tag("outputInterfaceId", String.valueOf(flowInfo.outputInterfaceId())).tag("vlanId", flowInfo.vlanId().toString()).tag("vxlanId", String.valueOf(flowInfo.vxlanId())).tag("srcIp", flowInfo.srcIp().toString()).tag("dstIp", flowInfo.dstIp().toString()).tag("srcPort", getTpPort(flowInfo.srcPort())).tag("dstPort", getTpPort(flowInfo.dstPort())).tag("protocol", String.valueOf(flowInfo.protocol())).tag("srcMac", flowInfo.srcMac().toString()).tag("dstMac", flowInfo.dstMac().toString()).addField("startupTime", flowInfo.statsInfo().startupTime()).addField("fstPktArrTime", flowInfo.statsInfo().fstPktArrTime()).addField("lstPktOffset", flowInfo.statsInfo().lstPktOffset()).addField("prevAccBytes", flowInfo.statsInfo().prevAccBytes()).addField("prevAccPkts", flowInfo.statsInfo().prevAccPkts()).addField("currAccBytes", flowInfo.statsInfo().currAccBytes()).addField("currAccPkts", flowInfo.statsInfo().currAccPkts()).addField("errorPkts", flowInfo.statsInfo().errorPkts()).addField("dropPkts", flowInfo.statsInfo().dropPkts()).build();
        batchPoints.point(point);
    }
    producer.write(batchPoints);
}
#method_after
@Override
public void publish(InfluxRecord<String, Set<FlowInfo>> record) {
    if (producer == null) {
        log.warn("InfluxDB telemetry service has not been enabled!");
        return;
    }
    if (record.flowInfos().size() == 0) {
        log.warn("No record to publish");
        return;
    }
    log.debug("Publish {} stats records to InfluxDB", record.flowInfos().size());
    BatchPoints batchPoints = BatchPoints.database(database).build();
    for (FlowInfo flowInfo : record.flowInfos()) {
        Point point = Point.measurement((measurement == null) ? record.measurement() : measurement).tag(FLOW_TYPE, String.valueOf(flowInfo.flowType())).tag(DEVICE_ID, flowInfo.deviceId().toString()).tag(INPUT_INTERFACE_ID, String.valueOf(flowInfo.inputInterfaceId())).tag(OUTPUT_INTERFACE_ID, String.valueOf(flowInfo.outputInterfaceId())).tag(VLAN_ID, flowInfo.vlanId().toString()).tag(VXLAN_ID, String.valueOf(flowInfo.vxlanId())).tag(SRC_IP, flowInfo.srcIp().toString()).tag(DST_IP, flowInfo.dstIp().toString()).tag(SRC_PORT, getTpPort(flowInfo.srcPort())).tag(DST_PORT, getTpPort(flowInfo.dstPort())).tag(PROTOCOL, String.valueOf(flowInfo.protocol())).tag(SRC_MAC, flowInfo.srcMac().toString()).tag(DST_MAC, flowInfo.dstMac().toString()).addField(STARTUP_TIME, flowInfo.statsInfo().startupTime()).addField(FST_PKT_ARR_TIME, flowInfo.statsInfo().fstPktArrTime()).addField(LST_PKT_OFFSET, flowInfo.statsInfo().lstPktOffset()).addField(PREV_ACC_BYTES, flowInfo.statsInfo().prevAccBytes()).addField(PREV_ACC_PKTS, flowInfo.statsInfo().prevAccPkts()).addField(CURR_ACC_BYTES, flowInfo.statsInfo().currAccBytes()).addField(CURR_ACC_PKTS, flowInfo.statsInfo().currAccPkts()).addField(ERROR_PKTS, flowInfo.statsInfo().errorPkts()).addField(DROP_PKTS, flowInfo.statsInfo().dropPkts()).build();
        batchPoints.point(point);
    }
    producer.write(batchPoints);
}
#end_block

#method_before
public void createDB() {
    if (producer.databaseExists(DATABASE)) {
        log.debug("Database {} is already created", DATABASE);
    } else {
        producer.createDatabase(DATABASE);
        log.debug("Database {} is created", DATABASE);
    }
}
#method_after
private void createDB() {
    if (producer.databaseExists(database)) {
        log.debug("Database {} is already created", database);
    } else {
        producer.createDatabase(database);
        log.debug("Database {} is created", database);
    }
}
#end_block

#method_before
@Test
public void testGetGwByComputeDevId() {
    Set<OpenstackNode> gws = Sets.newConcurrentHashSet();
    OpenstackNode nullGw = getGwByComputeDevId(gws, genDeviceId(1));
    assertEquals(null, nullGw);
    gws.add(genGateway(1));
    gws.add(genGateway(2));
    gws.add(genGateway(3));
    Set<OpenstackNode> cloneOfGws = ImmutableSet.copyOf(gws);
    Map<String, Integer> gwCountMap = Maps.newConcurrentMap();
    int numOfDev = 99;
    for (int i = 1; i < 1 + numOfDev; i++) {
        OpenstackNode gw = getGwByComputeDevId(gws, genDeviceId(i));
        if (gwCountMap.get(gw.hostname()) == null) {
            gwCountMap.put(gw.hostname(), 1);
        } else {
            gwCountMap.compute(gw.hostname(), (k, v) -> v + 1);
        }
        new EqualsTester().addEqualityGroup(getGwByComputeDevId(gws, genDeviceId(i)), getGwByComputeDevId(cloneOfGws, genDeviceId(i))).testEquals();
    }
    int sum = gwCountMap.values().stream().mapToInt(Integer::intValue).sum();
    assertEquals(numOfDev, sum);
}
#method_after
@Test
public void testGetGwByComputeDevId() {
    Set<OpenstackNode> gws = Sets.newConcurrentHashSet();
    OpenstackNode nullGw = getGwByComputeDevId(gws, genDeviceId(1));
    assertNull(nullGw);
    gws.add(genGateway(1));
    gws.add(genGateway(2));
    gws.add(genGateway(3));
    Set<OpenstackNode> cloneOfGws = ImmutableSet.copyOf(gws);
    Map<String, Integer> gwCountMap = Maps.newConcurrentMap();
    int numOfDev = 99;
    for (int i = 1; i < 1 + numOfDev; i++) {
        OpenstackNode gw = getGwByComputeDevId(gws, genDeviceId(i));
        if (gwCountMap.get(gw.hostname()) == null) {
            gwCountMap.put(gw.hostname(), 1);
        } else {
            gwCountMap.compute(gw.hostname(), (k, v) -> v + 1);
        }
        new EqualsTester().addEqualityGroup(getGwByComputeDevId(gws, genDeviceId(i)), getGwByComputeDevId(cloneOfGws, genDeviceId(i))).testEquals();
    }
    int sum = gwCountMap.values().stream().mapToInt(Integer::intValue).sum();
    assertEquals(numOfDev, sum);
}
#end_block

#method_before
public static String getIntfNameFromPciAddress(Port port) {
    if (port.getProfile().isEmpty()) {
        log.error("Port profile is not found");
        return null;
    }
    if (!port.getProfile().isEmpty() && port.getProfile().get(PCISLOT) == "") {
        log.error("Failed to retrieve the interface name because of no pci_slot information from the port");
        return null;
    }
    String busNumHex = port.getProfile().get(PCISLOT).toString().split(":")[1];
    String busNumDecimal = String.valueOf(Integer.parseInt(busNumHex, HEX_RADIX));
    String deviceNumHex = port.getProfile().get(PCISLOT).toString().split(":")[2].split("\\.")[0];
    String deviceNumDecimal = String.valueOf(Integer.parseInt(deviceNumHex, HEX_RADIX));
    String functionNumHex = port.getProfile().get(PCISLOT).toString().split(":")[2].split("\\.")[1];
    String functionNumDecimal = String.valueOf(Integer.parseInt(functionNumHex, HEX_RADIX));
    String intfName;
    String vendorInfoForPort = String.valueOf(port.getProfile().get(PCI_VENDOR_INFO));
    if (!portNamePrefixMap().containsKey(vendorInfoForPort)) {
        log.error("Failed to retrieve the interface name because of no port name prefix for vendor ID {}", vendorInfoForPort);
        return null;
    }
    String portNamePrefix = portNamePrefixMap().get(vendorInfoForPort);
    if (functionNumDecimal.equals(ZERO_FUNCTION_NUMBER)) {
        intfName = portNamePrefix + busNumDecimal + PREFIX_DEVICE_NUMBER + deviceNumDecimal;
    } else {
        intfName = portNamePrefix + busNumDecimal + PREFIX_DEVICE_NUMBER + deviceNumDecimal + PREFIX_FUNCTION_NUMBER + functionNumDecimal;
    }
    return intfName;
}
#method_after
public static String getIntfNameFromPciAddress(Port port) {
    if (port.getProfile() == null || port.getProfile().isEmpty()) {
        log.error("Port profile is not found");
        return null;
    }
    if (!port.getProfile().containsKey(PCISLOT) || Strings.isNullOrEmpty(port.getProfile().get(PCISLOT).toString())) {
        log.error("Failed to retrieve the interface name because of no pci_slot information from the port");
        return null;
    }
    String busNumHex = port.getProfile().get(PCISLOT).toString().split(":")[1];
    String busNumDecimal = String.valueOf(Integer.parseInt(busNumHex, HEX_RADIX));
    String deviceNumHex = port.getProfile().get(PCISLOT).toString().split(":")[2].split("\\.")[0];
    String deviceNumDecimal = String.valueOf(Integer.parseInt(deviceNumHex, HEX_RADIX));
    String functionNumHex = port.getProfile().get(PCISLOT).toString().split(":")[2].split("\\.")[1];
    String functionNumDecimal = String.valueOf(Integer.parseInt(functionNumHex, HEX_RADIX));
    String intfName;
    String vendorInfoForPort = String.valueOf(port.getProfile().get(PCI_VENDOR_INFO));
    if (!portNamePrefixMap().containsKey(vendorInfoForPort)) {
        log.error("Failed to retrieve the interface name because of no port name prefix for vendor ID {}", vendorInfoForPort);
        return null;
    }
    String portNamePrefix = portNamePrefixMap().get(vendorInfoForPort);
    if (functionNumDecimal.equals(ZERO_FUNCTION_NUMBER)) {
        intfName = portNamePrefix + busNumDecimal + PREFIX_DEVICE_NUMBER + deviceNumDecimal;
    } else {
        intfName = portNamePrefix + busNumDecimal + PREFIX_DEVICE_NUMBER + deviceNumDecimal + PREFIX_FUNCTION_NUMBER + functionNumDecimal;
    }
    return intfName;
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    String srcDeviceId = string(payload, SRC_DEVICE_ID);
    String dstDeviceId = string(payload, DST_DEVICE_ID);
    log.info("SendEvent called with src IP: {}, dst IP: {}, src device ID: {}, dst device Id: {}", srcIp, dstIp, srcDeviceId, dstDeviceId);
    processFlowTraceRequest(srcIp, dstIp, srcDeviceId, dstDeviceId);
}
#method_after
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    String srcDeviceId = string(payload, SRC_DEVICE_ID);
    String dstDeviceId = string(payload, DST_DEVICE_ID);
    log.info("Flow trace request called with src IP: {}, dst IP: {}, src device ID: {}, dst device Id: {}", srcIp, dstIp, srcDeviceId, dstDeviceId);
    processFlowTraceRequest(srcIp, dstIp, srcDeviceId, dstDeviceId);
}
#end_block

#method_before
private void processFlowTraceRequest(String srcIp, String dstIp, String srcDeviceId, String dstDeviceId) {
    boolean traceSuccess = true;
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode traceResult = mapper.createObjectNode();
    ArrayNode traceResultArray = traceResult.putArray(TRACE_RESULT);
    OpenstackNode srcOpenstackNode = osNodeService.node(DeviceId.deviceId(srcDeviceId));
    if (srcOpenstackNode == null) {
        return;
    }
    String traceResultForward = sendTraceRequestToNode(srcIp, dstIp, srcOpenstackNode);
    if (traceResultForward == null) {
        return;
    }
    log.debug("traceResultForward raw data: {}", traceResultForward);
    ObjectNode traceResultForwardJson = traceResultJson(traceResultForward, srcOpenstackNode, DeviceId.deviceId(srcDeviceId));
    traceResultArray.add(traceResultForwardJson);
    log.debug("traceResultForward Json: {}", traceResultForwardJson);
    if (!traceResultForwardJson.get(IS_SUCCESS).asBoolean()) {
        traceSuccess = false;
    }
    // TODO implements trace result in backward
    traceResult.put(TRACE_SUCCESS, traceSuccess);
    log.debug("traceResult Json: {}", traceResult);
    sendMessagetoUi(FLOW_TRACE_RESULT, traceResult);
}
#method_after
private void processFlowTraceRequest(String srcIp, String dstIp, String srcDeviceId, String dstDeviceId) {
    boolean traceSuccess = true;
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode traceResult = mapper.createObjectNode();
    ArrayNode traceResultArray = traceResult.putArray(TRACE_RESULT);
    OpenstackNode srcOpenstackNode = osNodeService.node(DeviceId.deviceId(srcDeviceId));
    if (srcOpenstackNode == null) {
        return;
    }
    if (srcOpenstackNode.sshAuthInfo() == null) {
        log.error("Openstack node {} has no SSH authentication information..", srcOpenstackNode.hostname());
        return;
    }
    String traceResultForward = sendTraceRequestToNode(srcIp, dstIp, srcOpenstackNode);
    if (traceResultForward == null) {
        return;
    }
    log.debug("traceResultForward raw data: {}", traceResultForward);
    ObjectNode traceResultForwardJson = null;
    Device srcDevice = deviceService.getDevice(srcOpenstackNode.intgBridge());
    if (srcDevice.annotations().value(SW_VERSION).startsWith(OVS_VERSION_2_8)) {
        traceResultForwardJson = Ovs28FlowTraceResultParser.flowTraceResultInJson(traceResultForward, srcOpenstackNode.hostname());
    } else {
        log.error("Currently OVS version {} is not supported", deviceService.getDevice(srcOpenstackNode.intgBridge()));
    }
    if (traceResultForwardJson == null) {
        return;
    }
    traceResultArray.add(traceResultForwardJson);
    log.debug("traceResultForward Json: {}", traceResultForwardJson);
    if (!traceResultForwardJson.get(IS_SUCCESS).asBoolean()) {
        traceSuccess = false;
    }
    // TODO implements trace result in backward
    traceResult.put(TRACE_SUCCESS, traceSuccess);
    log.debug("traceResult Json: {}", traceResult);
    sendMessagetoUi(FLOW_TRACE_RESULT, traceResult);
}
#end_block

#method_before
private String sendTraceRequestToNode(String srcIp, String dstIp, OpenstackNode openstackNode) {
    String traceResult = null;
    try (SshClient client = SshClient.setUpDefaultClient()) {
        client.start();
        try (ClientSession session = client.connect("authId", openstackNode.managementIp().getIp4Address().toString(), SSH_PORT).verify(TIMEOUT_MS, TimeUnit.SECONDS).getSession()) {
            session.addPasswordIdentity("authPassword");
            session.auth().verify(TIMEOUT_MS, TimeUnit.SECONDS);
            try (ClientChannel channel = session.createChannel(ClientChannel.CHANNEL_SHELL)) {
                String requestString = traceRequestString(srcIp, dstIp, openstackNode);
                if (requestString == null) {
                    return null;
                }
                log.debug("requestString: {}", requestString);
                final InputStream inputStream = new ByteArrayInputStream(requestString.getBytes());
                OutputStream outputStream = new ByteArrayOutputStream();
                OutputStream errStream = new ByteArrayOutputStream();
                channel.setIn(new NoCloseInputStream(inputStream));
                channel.setErr(errStream);
                channel.setOut(outputStream);
                Collection<ClientChannelEvent> eventList = Lists.newArrayList();
                eventList.add(ClientChannelEvent.OPENED);
                OpenFuture channelFuture = channel.open();
                if (channelFuture.await(TIMEOUT_MS, TimeUnit.SECONDS)) {
                    long timeoutExpiredMs = System.currentTimeMillis() + TIMEOUT_MS;
                    while (!channelFuture.isOpened()) {
                        if ((timeoutExpiredMs - System.currentTimeMillis()) <= 0) {
                            log.error("Failed to open channel");
                            return null;
                        }
                    }
                    TimeUnit.SECONDS.sleep(WAIT_OUTPUT_STREAM_SECOND);
                    traceResult = ((ByteArrayOutputStream) outputStream).toString(Charsets.UTF_8.name());
                    channel.close();
                }
            } finally {
                session.close();
            }
        } finally {
            client.stop();
        }
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    return traceResult.trim();
}
#method_after
private String sendTraceRequestToNode(String srcIp, String dstIp, OpenstackNode openstackNode) {
    String traceResult = null;
    OpenstackSshAuth sshAuth = openstackNode.sshAuthInfo();
    try (SshClient client = SshClient.setUpDefaultClient()) {
        client.start();
        try (ClientSession session = client.connect(sshAuth.id(), openstackNode.managementIp().getIp4Address().toString(), SSH_PORT).verify(TIMEOUT_MS, TimeUnit.SECONDS).getSession()) {
            session.addPasswordIdentity(sshAuth.password());
            session.auth().verify(TIMEOUT_MS, TimeUnit.SECONDS);
            try (ClientChannel channel = session.createChannel(ClientChannel.CHANNEL_SHELL)) {
                String requestString = traceRequestString(srcIp, dstIp, openstackNode);
                if (requestString == null) {
                    return null;
                }
                log.debug("requestString: {}", requestString);
                final InputStream inputStream = new ByteArrayInputStream(requestString.getBytes());
                OutputStream outputStream = new ByteArrayOutputStream();
                OutputStream errStream = new ByteArrayOutputStream();
                channel.setIn(new NoCloseInputStream(inputStream));
                channel.setErr(errStream);
                channel.setOut(outputStream);
                Collection<ClientChannelEvent> eventList = Lists.newArrayList();
                eventList.add(ClientChannelEvent.OPENED);
                OpenFuture channelFuture = channel.open();
                if (channelFuture.await(TIMEOUT_MS, TimeUnit.SECONDS)) {
                    long timeoutExpiredMs = System.currentTimeMillis() + TIMEOUT_MS;
                    while (!channelFuture.isOpened()) {
                        if ((timeoutExpiredMs - System.currentTimeMillis()) <= 0) {
                            log.error("Failed to open channel");
                            return null;
                        }
                    }
                    TimeUnit.SECONDS.sleep(WAIT_OUTPUT_STREAM_SECOND);
                    traceResult = ((ByteArrayOutputStream) outputStream).toString(Charsets.UTF_8.name());
                    channel.close();
                }
            } finally {
                session.close();
            }
        } finally {
            client.stop();
        }
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    return traceResult.trim();
}
#end_block

#method_before
private String traceRequestString(String srcIp, String dstIp, OpenstackNode openstackNode) {
    Optional<InstancePort> instancePort = instancePortService.instancePorts().stream().filter(port -> port.ipAddress().getIp4Address().toString().equals(srcIp) && port.deviceId().equals(openstackNode.intgBridge())).findAny();
    if (!instancePort.isPresent()) {
        return null;
    }
    String requestString = DEFAULT_REQUEST_STRING + instancePort.get().portNumber().toString() + COMMA + NW_SRC + srcIp + COMMA;
    if (osNetService.getNetworkType(instancePort.get().networkId()).equals(VXLAN)) {
        if (srcIp.equals(dstIp)) {
            dstIp = osNetService.getGatewayIp(instancePort.get().portId());
            requestString = requestString + DL_DST + DEFAULT_GATEWAY_MAC_STR + COMMA;
        } else if (!osNetService.getIpPrefix(instancePort.get().portId()).contains(IpAddress.valueOf(dstIp))) {
            requestString = requestString + DL_DST + DEFAULT_GATEWAY_MAC_STR + COMMA;
        }
    } else if (osNetService.getNetworkType(instancePort.get().networkId()).equals(FLAT)) {
        if (srcIp.equals(dstIp)) {
            dstIp = osNetService.getGatewayIp(instancePort.get().portId());
        }
    }
    requestString = requestString + NW_DST + dstIp + "\n";
    return requestString;
}
#method_after
private String traceRequestString(String srcIp, String dstIp, OpenstackNode openstackNode) {
    Optional<InstancePort> instancePort = instancePortService.instancePorts().stream().filter(port -> port.ipAddress().getIp4Address().toString().equals(srcIp) && port.deviceId().equals(openstackNode.intgBridge())).findAny();
    if (!instancePort.isPresent()) {
        return null;
    }
    String requestString = DEFAULT_REQUEST_STRING + instancePort.get().portNumber().toString() + COMMA + NW_SRC + srcIp + COMMA;
    if (osNetService.networkType(instancePort.get().networkId()).equals(VXLAN)) {
        if (srcIp.equals(dstIp)) {
            dstIp = osNetService.gatewayIp(instancePort.get().portId());
            requestString = requestString + DL_DST + DEFAULT_GATEWAY_MAC_STR + COMMA;
        } else if (!osNetService.ipPrefix(instancePort.get().portId()).contains(IpAddress.valueOf(dstIp))) {
            requestString = requestString + DL_DST + DEFAULT_GATEWAY_MAC_STR + COMMA;
        }
    } else if (osNetService.networkType(instancePort.get().networkId()).equals(FLAT)) {
        if (srcIp.equals(dstIp)) {
            dstIp = osNetService.gatewayIp(instancePort.get().portId());
        }
    }
    requestString = requestString + NW_DST + dstIp + "\n";
    return requestString;
}
#end_block

#method_before
@Override
protected GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    if (isUnfiltered(treatment, meta)) {
        return createUnfilteredL2L3Chain(treatment, nextId, appId);
    }
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    MacAddress srcMac = MacAddress.ZERO;
    MacAddress dstMac = MacAddress.ZERO;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.debug("Driver does not handle this type of TrafficTreatment" + " instruction in l2l3chain:  {} - {}", ins.type(), ins);
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same device,
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        int mplsInterfaceIndex = getNextAvailableIndex();
        int mplsgroupId = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & mplsInterfaceIndex);
        final GroupKey mplsgroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(mplsInterfaceIndex));
        outerTtb.group(new GroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        int l3unicastIndex = getNextAvailableIndex();
        int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3unicastIndex);
        final GroupKey l3groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3unicastIndex));
        outerTtb.group(new GroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false, deviceId);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2InterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2InterfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#method_after
@Override
protected GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    if (createUnfiltered(treatment, meta)) {
        return createUnfilteredL2L3Chain(treatment, nextId, appId);
    }
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    MacAddress srcMac = MacAddress.ZERO;
    MacAddress dstMac = MacAddress.ZERO;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.debug("Driver does not handle this type of TrafficTreatment" + " instruction in l2l3chain:  {} - {}", ins.type(), ins);
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same device,
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        int mplsInterfaceIndex = getNextAvailableIndex();
        int mplsgroupId = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & mplsInterfaceIndex);
        final GroupKey mplsgroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(mplsInterfaceIndex));
        outerTtb.group(new GroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        int l3unicastIndex = getNextAvailableIndex();
        int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3unicastIndex);
        final GroupKey l3groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3unicastIndex));
        outerTtb.group(new GroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false, deviceId);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2InterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2InterfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#end_block

#method_before
@Override
protected void processFilter(FilteringObjective filteringObjective, boolean install, ApplicationId applicationId) {
    if (isDoubleTagged(filteringObjective)) {
        processDoubleTaggedFilter(filteringObjective, install, applicationId);
    } else {
        // If it is not a double-tagged filter, we fall back
        // to the OFDPA 2.0 pipeline.
        super.processFilter(filteringObjective, install, applicationId);
    }
}
#method_after
protected void processFilter(FilteringObjective filteringObjective, boolean install, ApplicationId applicationId) {
    if (isDoubleTagged(filteringObjective)) {
        processDoubleTaggedFilter(filteringObjective, install, applicationId);
    } else {
        // If it is not a double-tagged filter, we fall back
        // to the OFDPA 2.0 pipeline.
        super.processFilter(filteringObjective, install, applicationId);
    }
}
#end_block

#method_before
private List<FlowRule> processDoubleVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion innerVidCriterion, VlanIdCriterion outerVidCriterion, boolean popVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder outerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder outerTreatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder innerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder innerTreatment = DefaultTrafficTreatment.builder();
    VlanId outerVlanId = outerVidCriterion.vlanId();
    VlanId innerVlanId = innerVidCriterion.vlanId();
    PortNumber portNumber = portCriterion.port();
    // Check arguments
    if (PortNumber.ALL.equals(portNumber) || outerVlanId.equals(VlanId.NONE) || innerVlanId.equals(VlanId.NONE)) {
        log.warn("Incomplete Filtering Objective. " + "VLAN Table cannot be programmed for {}", deviceId);
        return ImmutableList.of();
    } else {
        outerSelector.matchInPort(portNumber);
        innerSelector.matchInPort(portNumber);
        outerTreatment.transition(VLAN_1_TABLE);
        innerTreatment.transition(TMAC_TABLE);
        outerTreatment.writeMetadata(outerVlanId.toShort(), 0xFFF);
        outerSelector.matchVlanId(outerVlanId);
        innerSelector.matchVlanId(innerVlanId);
        innerSelector.matchMetadata(outerVlanId.toShort());
        if (popVlan) {
            outerTreatment.popVlan();
        }
    }
    // before sending it to the controller.
    if (supportPuntGroup()) {
        GroupKey groupKey = popVlanPuntGroupKey();
        Group group = groupService.getGroup(deviceId, groupKey);
        if (group != null) {
            // push outer vlan and send to controller
            TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder().matchInPort(portNumber).matchVlanId(innerVlanId);
            TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder().pushVlan().setVlanId(outerVlanId).punt();
            rules.add(DefaultFlowRule.builder().forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(tbuilder.build()).withPriority(PacketPriority.CONTROL.priorityValue()).fromApp(driverId).makePermanent().forTable(PUNT_TABLE).build());
        } else {
            log.info("popVlanPuntGroup not found in dev:{}", deviceId);
            return Collections.emptyList();
        }
    }
    FlowRule outerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(outerSelector.build()).withTreatment(outerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
    FlowRule innerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(innerSelector.build()).withTreatment(innerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_1_TABLE).build();
    rules.add(outerRule);
    rules.add(innerRule);
    return rules;
}
#method_after
private List<FlowRule> processDoubleVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion innerVidCriterion, VlanIdCriterion outerVidCriterion, boolean popVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder outerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder outerTreatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder innerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder innerTreatment = DefaultTrafficTreatment.builder();
    VlanId outerVlanId = outerVidCriterion.vlanId();
    VlanId innerVlanId = innerVidCriterion.vlanId();
    PortNumber portNumber = portCriterion.port();
    // Check arguments
    if (PortNumber.ALL.equals(portNumber) || outerVlanId.equals(VlanId.NONE) || innerVlanId.equals(VlanId.NONE)) {
        log.warn("Incomplete Filtering Objective. " + "VLAN Table cannot be programmed for {}", deviceId);
        return ImmutableList.of();
    } else {
        outerSelector.matchInPort(portNumber);
        innerSelector.matchInPort(portNumber);
        outerTreatment.transition(VLAN_1_TABLE);
        innerTreatment.transition(TMAC_TABLE);
        outerTreatment.writeMetadata(outerVlanId.toShort(), 0xFFF);
        outerSelector.matchVlanId(outerVlanId);
        innerSelector.matchVlanId(innerVlanId);
        // force recompilation
        // FIXME might be issue due tu /fff mask
        innerSelector.matchMetadata(outerVlanId.toShort());
        if (popVlan) {
            outerTreatment.popVlan();
        }
    }
    // before sending it to the controller.
    if (supportPuntGroup()) {
        GroupKey groupKey = popVlanPuntGroupKey();
        Group group = groupService.getGroup(deviceId, groupKey);
        if (group != null) {
            // push outer vlan and send to controller
            TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder().matchInPort(portNumber).matchVlanId(innerVlanId);
            Host host = handler().get(HostService.class).getConnectedHosts(ConnectPoint.deviceConnectPoint(deviceId + "/" + portNumber.toLong())).stream().filter(h -> h.vlan().equals(outerVlanId)).findFirst().orElse(null);
            EthType vlanType = EthType.EtherType.VLAN.ethType();
            if (host != null) {
                vlanType = host.tpid();
            }
            TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder().pushVlan(vlanType).setVlanId(outerVlanId).punt();
            rules.add(DefaultFlowRule.builder().forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(tbuilder.build()).withPriority(PacketPriority.CONTROL.priorityValue()).fromApp(driverId).makePermanent().forTable(PUNT_TABLE).build());
        } else {
            log.info("popVlanPuntGroup not found in dev:{}", deviceId);
            return Collections.emptyList();
        }
    }
    FlowRule outerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(outerSelector.build()).withTreatment(outerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
    FlowRule innerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(innerSelector.build()).withTreatment(innerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_1_TABLE).build();
    rules.add(outerRule);
    rules.add(innerRule);
    return rules;
}
#end_block

#method_before
protected Collection<FlowRule> processDoubleTaggedFwd(ForwardingObjective fwd) {
    // inner for UNICAST_ROUTING_TABLE_1, outer for UNICAST_ROUTING_TABLE
    TrafficSelector selector = fwd.selector();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        sBuilder.matchEthType(Ethernet.TYPE_IPV4);
        sBuilder.matchVlanId(VlanId.ANY);
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (!ipv4Dst.isMulticast() && ipv4Dst.prefixLength() == 32) {
            sBuilder.matchIPDst(ipv4Dst);
            if (fwd.nextId() != null) {
                NextGroup next = getGroupForNextObjective(fwd.nextId());
                if (next != null) {
                    List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
                    // we only need the top level group's key to point the flow to it
                    Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
                    if (group == null) {
                        log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                        fail(fwd, ObjectiveError.GROUPMISSING);
                        return Collections.emptySet();
                    }
                    outerTtb.immediate().setVlanId(extractDummyVlanIdFromGroupId(group.id().id()));
                    // ACTSET_OUTPUT in OVS will match output action in write_action() set.
                    outerTtb.deferred().setOutput(extractOutputPortFromGroupId(group.id().id()));
                    outerTtb.transition(EGRESS_VLAN_FLOW_TABLE_IN_INGRESS);
                    innerTtb.deferred().group(group.id());
                    innerTtb.transition(ACL_TABLE);
                    FlowRule.Builder innerRuleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sBuilder.build()).withTreatment(innerTtb.build()).forTable(UNICAST_ROUTING_TABLE_1);
                    if (fwd.permanent()) {
                        innerRuleBuilder.makePermanent();
                    } else {
                        innerRuleBuilder.makeTemporary(fwd.timeout());
                    }
                    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
                    flowRuleCollection.add(innerRuleBuilder.build());
                    FlowRule.Builder outerRuleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sBuilder.build()).withTreatment(outerTtb.build()).forTable(UNICAST_ROUTING_TABLE);
                    if (fwd.permanent()) {
                        outerRuleBuilder.makePermanent();
                    } else {
                        outerRuleBuilder.makeTemporary(fwd.timeout());
                    }
                    flowRuleCollection.add(innerRuleBuilder.build());
                    flowRuleCollection.add(outerRuleBuilder.build());
                    return flowRuleCollection;
                } else {
                    log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
                    fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                    return Collections.emptySet();
                }
            } else {
                log.warn("NextId is not specified in fwd:{}", fwd.id());
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
        }
    }
    return Collections.emptySet();
}
#method_after
protected Collection<FlowRule> processDoubleTaggedFwd(ForwardingObjective fwd) {
    // inner for UNICAST_ROUTING_TABLE_1, outer for UNICAST_ROUTING_TABLE
    TrafficSelector selector = fwd.selector();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        sBuilder.matchEthType(Ethernet.TYPE_IPV4);
        sBuilder.matchVlanId(VlanId.ANY);
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (!ipv4Dst.isMulticast() && ipv4Dst.prefixLength() == 32) {
            sBuilder.matchIPDst(ipv4Dst);
            if (fwd.nextId() != null) {
                NextGroup next = getGroupForNextObjective(fwd.nextId());
                if (next != null) {
                    List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
                    // we only need the top level group's key to point the flow to it
                    Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
                    if (group == null) {
                        log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                        fail(fwd, ObjectiveError.GROUPMISSING);
                        return Collections.emptySet();
                    }
                    outerTtb.immediate().setVlanId(extractDummyVlanIdFromGroupId(group.id().id()));
                    // ACTSET_OUTPUT in OVS will match output action in write_action() set.
                    outerTtb.deferred().setOutput(extractOutputPortFromGroupId(group.id().id()));
                    outerTtb.transition(EGRESS_VLAN_FLOW_TABLE_IN_INGRESS);
                    innerTtb.deferred().group(group.id());
                    innerTtb.transition(ACL_TABLE);
                    FlowRule.Builder innerRuleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sBuilder.build()).withTreatment(innerTtb.build()).forTable(UNICAST_ROUTING_TABLE_1);
                    if (fwd.permanent()) {
                        innerRuleBuilder.makePermanent();
                    } else {
                        innerRuleBuilder.makeTemporary(fwd.timeout());
                    }
                    Collection<FlowRule> flowRuleCollection = new HashSet<>();
                    flowRuleCollection.add(innerRuleBuilder.build());
                    FlowRule.Builder outerRuleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sBuilder.build()).withTreatment(outerTtb.build()).forTable(UNICAST_ROUTING_TABLE);
                    if (fwd.permanent()) {
                        outerRuleBuilder.makePermanent();
                    } else {
                        outerRuleBuilder.makeTemporary(fwd.timeout());
                    }
                    flowRuleCollection.add(innerRuleBuilder.build());
                    flowRuleCollection.add(outerRuleBuilder.build());
                    return flowRuleCollection;
                } else {
                    log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
                    fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                    return Collections.emptySet();
                }
            } else {
                log.warn("NextId is not specified in fwd:{}", fwd.id());
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
        }
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
protected List<List<FlowRule>> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchVlanId(vidCriterion.vlanId());
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        treatment.pushVlan().setVlanId(assignedVlan);
    } else if (!vidCriterion.vlanId().equals(assignedVlan)) {
        // Rewrite with assigned vlans
        treatment.setVlanId(assignedVlan);
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null) {
        if (portCriterion.port() == PortNumber.ALL) {
            for (Port port : deviceService.getPorts(deviceId)) {
                if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                    portnums.add(port.number());
                }
            }
        } else {
            portnums.add(portCriterion.port());
        }
    }
    for (PortNumber pnum : portnums) {
        // VLAN before sending to controller
        if (supportPuntGroup() && vidCriterion.vlanId() == VlanId.NONE) {
            GroupKey groupKey = popVlanPuntGroupKey();
            Group group = groupService.getGroup(deviceId, groupKey);
            if (group != null) {
                rules.add(buildPuntTableRule(pnum, assignedVlan));
            } else {
                log.info("popVlanPuntGroup not found in dev:{}", deviceId);
                return Collections.emptyList();
            }
        }
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        rules.add(rule);
    }
    return ImmutableList.of(rules);
}
#method_after
@Override
protected List<List<FlowRule>> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchVlanId(vidCriterion.vlanId());
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        treatment.pushVlan().setVlanId(assignedVlan);
    } else if (!vidCriterion.vlanId().equals(assignedVlan)) {
        // Rewrite with assigned vlans
        treatment.setVlanId(assignedVlan);
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null) {
        if (portCriterion.port() == PortNumber.ALL) {
            for (Port port : deviceService.getPorts(deviceId)) {
                if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                    portnums.add(port.number());
                }
            }
        } else {
            portnums.add(portCriterion.port());
        }
    }
    for (PortNumber pnum : portnums) {
        // VLAN before sending to controller
        if (supportPuntGroup() && vidCriterion.vlanId() == VlanId.NONE) {
            try {
                groupCheckerLock.lock();
                if (flowRuleQueue == null) {
                    // this means that the group has been created
                    // and that groupChecker has destroyed the queue
                    log.debug("Installing punt table rule for untagged port {} and vlan {}.", pnum, assignedVlan);
                    rules.add(buildPuntTableRule(pnum, assignedVlan));
                } else {
                    // The VLAN punt group may be held back due to device initial audit.
                    // In that case, we queue all punt table flow until the group has been created.
                    log.debug("popVlanPuntGroup not found in dev:{}, queueing this flow rule.", deviceId);
                    flowRuleQueue.add(buildPuntTableRule(pnum, assignedVlan));
                }
            } finally {
                groupCheckerLock.unlock();
            }
        } else if (vidCriterion.vlanId() != VlanId.NONE) {
            // for tagged ports just forward to the controller
            log.debug("Installing punt rule for tagged port {} and vlan {}.", pnum, vidCriterion.vlanId());
            rules.add(buildPuntTableRuleTagged(pnum, vidCriterion.vlanId()));
        }
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        rules.add(rule);
    }
    return ImmutableList.of(rules);
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            // avoid matching on vlans
            return;
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.transition(PUNT_TABLE);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
        if (fwd.treatment().clearedDeferred()) {
            ttBuilder.wipeDeferred();
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
@Override
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            // avoid matching on vlans
            return;
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.transition(PUNT_TABLE);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else if (ins instanceof NoActionInstruction) {
            // No action is allowed and nothing needs to be done
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
        if (fwd.treatment().clearedDeferred()) {
            ttBuilder.wipeDeferred();
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
@Override
protected void initializePipeline() {
    initTableMiss(PORT_TABLE, VLAN_TABLE, null);
    initTableMiss(VLAN_TABLE, ACL_TABLE, null);
    initTableMiss(VLAN_1_TABLE, ACL_TABLE, null);
    initTableMiss(TMAC_TABLE, BRIDGING_TABLE, null);
    initTableMiss(UNICAST_ROUTING_TABLE, ACL_TABLE, null);
    initTableMiss(MULTICAST_ROUTING_TABLE, ACL_TABLE, null);
    initTableMiss(EGRESS_VLAN_FLOW_TABLE_IN_INGRESS, ACL_TABLE, null);
    initTableMiss(UNICAST_ROUTING_TABLE_1, ACL_TABLE, null);
    initTableMiss(MPLS_TABLE_0, MPLS_TABLE_1, null);
    initTableMiss(MPLS_TABLE_1, ACL_TABLE, null);
    initTableMiss(BRIDGING_TABLE, ACL_TABLE, null);
    initTableMiss(ACL_TABLE, -1, null);
    if (supportPuntGroup()) {
        initTableMiss(PUNT_TABLE, -1, DefaultTrafficTreatment.builder().punt().build());
        initPopVlanPuntGroup();
    } else {
        initTableMiss(PUNT_TABLE, -1, DefaultTrafficTreatment.builder().popVlan().punt().build());
    }
}
#method_after
@Override
protected void initializePipeline() {
    initTableMiss(PORT_TABLE, VLAN_TABLE, null);
    initTableMiss(VLAN_TABLE, ACL_TABLE, null);
    initTableMiss(VLAN_1_TABLE, ACL_TABLE, null);
    initTableMiss(TMAC_TABLE, BRIDGING_TABLE, null);
    initTableMiss(UNICAST_ROUTING_TABLE, ACL_TABLE, null);
    initTableMiss(MULTICAST_ROUTING_TABLE, ACL_TABLE, null);
    initTableMiss(EGRESS_VLAN_FLOW_TABLE_IN_INGRESS, ACL_TABLE, null);
    initTableMiss(UNICAST_ROUTING_TABLE_1, ACL_TABLE, null);
    initTableMiss(MPLS_TABLE_0, MPLS_TABLE_1, null);
    initTableMiss(MPLS_TABLE_1, ACL_TABLE, null);
    initTableMiss(BRIDGING_TABLE, ACL_TABLE, null);
    initTableMiss(ACL_TABLE, -1, null);
    linkDiscoveryPuntTableRules();
    if (supportPuntGroup()) {
        initPopVlanPuntGroup();
    } else {
        initTableMiss(PUNT_TABLE, -1, DefaultTrafficTreatment.builder().popVlan().punt().build());
    }
}
#end_block

#method_before
@Override
public OpenstackSshAuth.Builder id(String id) {
    this.id = id;
    return this;
}
#method_after
@Override
public Builder id(String id) {
    this.id = id;
    return this;
}
#end_block

#method_before
@Override
public OpenstackSshAuth.Builder password(String password) {
    this.password = password;
    return this;
}
#method_after
@Override
public Builder password(String password) {
    this.password = password;
    return this;
}
#end_block

#method_before
@Override
public OpenstackSshAuth decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String id = nullIsIllegal(json.get(ID).asText(), ID + MISSING_MESSAGE);
    String password = nullIsIllegal(json.get(PASSWORD).asText(), PASSWORD + MISSING_MESSAGE);
    OpenstackSshAuth.Builder builder = DefaultOpenstackSshAuth.builder().id(id).password(password);
    return builder.build();
}
#method_after
@Override
public OpenstackSshAuth decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String id = nullIsIllegal(json.get(ID).asText(), ID + MISSING_MESSAGE);
    String password = nullIsIllegal(json.get(PASSWORD).asText(), PASSWORD + MISSING_MESSAGE);
    return DefaultOpenstackSshAuth.builder().id(id).password(password).build();
}
#end_block

#method_before
@Test
public void testPortNumber() throws Exception {
    assertTrue(PORT_NUMBER == onoslldp.getPort());
    onoslldp.setPortId(PORT_NUMBER_2);
    assertTrue(PORT_NUMBER_2 == onoslldp.getPort());
}
#method_after
@Test
public void testPortNumber() throws Exception {
    assertEquals("the value from constructor with getPort value is miss matched", PORT_NUMBER, onoslldp.getPort());
    onoslldp.setPortId(PORT_NUMBER_2);
    assertEquals("the value from setPortId with getPort value is miss matched", PORT_NUMBER_2, onoslldp.getPort());
}
#end_block

#method_before
@Override
public List<ControllerInfo> getControllers() {
    List<ControllerInfo> controllers = Lists.newArrayList();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(buildRpcGetOpenFlowController()).trim();
    } catch (IOException e) {
        log.error(e.getMessage());
        return controllers;
    }
    log.debug("reply {}", reply);
    controllers = getOpenFlowControllersFromConfig(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes())));
    log.debug("controllers {}", controllers);
    return controllers;
}
#method_after
@Override
public List<ControllerInfo> getControllers() {
    List<ControllerInfo> controllers = Lists.newArrayList();
    String reply = retrieveResultCommand(buildRpcGetOpenFlowController());
    if (reply == null || (reply != null && reply.isEmpty())) {
        log.error("Cannot get the controllers from switch");
    } else {
        controllers = getOpenFlowControllersFromConfig(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes())));
        log.debug("controllers {}", controllers);
    }
    return controllers;
}
#end_block

#method_before
@Override
public void setControllers(List<ControllerInfo> controllers) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session;
    DeviceId deviceId;
    try {
        deviceId = handler().data().deviceId();
        session = controller.getDevicesMap().get(deviceId).getSession();
    } catch (Exception e) {
        log.error(e.getMessage());
        return;
    }
    String reply;
    try {
        reply = session.requestSync(buildRpcSetOpenFlowController(controllers)).trim();
        log.debug(reply);
        reply = session.requestSync(buildCommit()).trim();
        log.debug(reply);
    } catch (NetconfException e) {
        log.error(e.getMessage());
        return;
    }
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    if (!requestCommand(buildRpcSetOpenFlowController(controllers))) {
        log.error("Cannot set the controllers to switch");
    }
}
#end_block

#method_before
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session;
    try {
        session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    } catch (Exception e) {
        log.error(e.getMessage());
        return;
    }
    String reply;
    try {
        reply = session.requestSync(buildRpcRemoveOpenFlowController()).trim();
        log.debug(reply);
        reply = session.requestSync(buildCommit()).trim();
        log.debug(reply);
    } catch (NetconfException e) {
        log.error(e.getMessage());
        return;
    }
}
#method_after
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    if (!requestCommand(buildRpcRemoveOpenFlowController())) {
        log.error("Cannot remove the controllers from switch");
    }
}
#end_block

#method_before
public static List<ControllerInfo> getOpenFlowControllersFromConfig(HierarchicalConfiguration cfg) {
    List<ControllerInfo> controllers = new ArrayList<ControllerInfo>();
    String ipKey = "configuration.protocols.openflow.mode.ofagent-mode.controller.ip";
    if (!cfg.configurationsAt(ipKey).isEmpty()) {
        List<HierarchicalConfiguration> ipNodes = cfg.configurationsAt(ipKey);
        ipNodes.forEach(ipNode -> {
            int port = 0;
            String proto = UNKNOWN;
            HierarchicalConfiguration protocolNode = ipNode.configurationAt(PROTOCOL);
            HierarchicalConfiguration tcpNode = protocolNode.configurationAt(TCP);
            if (!tcpNode.isEmpty()) {
                String portString = tcpNode.getString(PORT);
                if (portString != null && !portString.isEmpty()) {
                    port = Integer.parseInt(portString);
                }
                proto = TCP;
            }
            String ipaddress = ipNode.getString(NAME);
            if (ipaddress == null) {
                ipaddress = UNKNOWN;
            }
            controllers.add(new ControllerInfo(IpAddress.valueOf(ipaddress), port, proto));
        });
    } else {
        log.debug("Controller not present");
    }
    return controllers;
}
#method_after
public static List<ControllerInfo> getOpenFlowControllersFromConfig(HierarchicalConfiguration cfg) {
    List<ControllerInfo> controllers = new ArrayList<ControllerInfo>();
    String ipKey = "configuration.protocols.openflow.mode.ofagent-mode.controller.ip";
    if (!cfg.configurationsAt(ipKey).isEmpty()) {
        List<HierarchicalConfiguration> ipNodes = cfg.configurationsAt(ipKey);
        ipNodes.forEach(ipNode -> {
            int port = 0;
            String proto = UNKNOWN;
            HierarchicalConfiguration protocolNode = ipNode.configurationAt(PROTOCOL);
            HierarchicalConfiguration tcpNode = protocolNode.configurationAt(TCP);
            if (!tcpNode.isEmpty()) {
                String portString = tcpNode.getString(PORT);
                if (portString != null && !portString.isEmpty()) {
                    port = Integer.parseInt(portString);
                }
                proto = TCP;
            }
            String ipaddress = ipNode.getString(NAME);
            if (ipaddress == null) {
                ipaddress = UNKNOWN;
            }
            if (ipaddress.equals(UNKNOWN) || proto.equals(UNKNOWN) || port == 0) {
                log.error("Controller infomation is invalid. Skip this controller node." + " ipaddress: {}, proto: {}, port: {}", ipaddress, proto, port);
                return;
            }
            controllers.add(new ControllerInfo(IpAddress.valueOf(ipaddress), port, proto));
        });
    } else {
        log.error("Controller not present");
    }
    return controllers;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultNicFlowRule) {
        DefaultNicFlowRule that = (DefaultNicFlowRule) obj;
        return Objects.equals(trafficClassId, that.trafficClassId) && Objects.equals(interfaceName, that.interfaceName) && Objects.equals(interfaceNumber, that.interfaceNumber) && Objects.equals(cpuCoreIndex, that.cpuCoreIndex) && Objects.equals(scope, that.scope) && Objects.equals(actions, that.actions);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultNicFlowRule) {
        DefaultNicFlowRule that = (DefaultNicFlowRule) obj;
        return Objects.equals(trafficClassId, that.trafficClassId) && Objects.equals(interfaceName, that.interfaceName) && Objects.equals(interfaceNumber, that.interfaceNumber) && Objects.equals(cpuCoreIndex, that.cpuCoreIndex) && Objects.equals(scope, that.scope) && Objects.equals(actions, that.actions) && Objects.equals(deviceId(), that.deviceId()) && Objects.equals(id(), that.id()) && Objects.equals(selector(), that.selector());
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(trafficClassId, interfaceName, interfaceNumber, cpuCoreIndex, scope);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(trafficClassId, interfaceName, interfaceNumber, cpuCoreIndex, scope, deviceId(), id(), selector());
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).omitNullValues().add("Device ID", deviceId()).add("Traffic class ID", trafficClassId()).add("Interface name", interfaceName()).add("Interface number", interfaceNumber()).add("CPU core index", cpuCoreIndex()).add("Scope", scope()).add("Traffic selector", selector()).add("Traffic treatment", treatment()).add("Priority", priority()).add("Ethernet type", ethernetTypeValue()).add("Ethernet address source", ethernetSrcAddress()).add("Ethernet address destination", ethernetDstAddress()).add("IP protocol", ipv4Protocol()).add("IP address source", ipv4SrcAddress()).add("IP mask source", ipv4SrcMask()).add("IP address destination", ipv4DstAddress()).add("IP mask destination", ipv4DstMask()).add("Source port", sourcePort()).add("Destination port", destinationPort()).add("Actions", actions()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).omitNullValues().add("Device ID", deviceId()).add("Traffic class ID", trafficClassId()).add("Flow ID", id()).add("Interface name", interfaceName()).add("Interface number", interfaceNumber()).add("CPU core index", cpuCoreIndex()).add("Scope", scope()).add("Traffic selector", selector()).add("Traffic treatment", treatment()).add("Priority", priority()).add("Ethernet type", ethernetTypeValue()).add("Ethernet address source", ethernetSrcAddress()).add("Ethernet address destination", ethernetDstAddress()).add("IP protocol", ipv4Protocol()).add("IP address source", ipv4SrcAddress()).add("IP mask source", ipv4SrcMask()).add("IP address destination", ipv4DstAddress()).add("IP mask destination", ipv4DstMask()).add("Source port", sourcePort()).add("Destination port", destinationPort()).add("Actions", actions()).toString();
}
#end_block

#method_before
public String value() {
    return this.flowRule;
}
#method_after
public long value() {
    return this.cpuCoreId;
}
#end_block

#method_before
public void setValue(String flowRule) {
    checkNotNull(flowRule, "NIC flow Rx filter is NULL");
    this.flowRule = flowRule;
}
#method_after
public void setValue(long cpuCoreId) {
    checkArgument(cpuCoreId >= 0, "NIC flow Rx filter has invalid CPU core ID");
    this.cpuCoreId = cpuCoreId;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(this.flowRule);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(this.cpuCoreId, this.flowRule);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if ((obj == null) || (!(obj instanceof FlowRxFilterValue))) {
        return false;
    }
    FlowRxFilterValue other = (FlowRxFilterValue) obj;
    return this.value().equals(other.value());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if ((obj == null) || (!(obj instanceof FlowRxFilterValue))) {
        return false;
    }
    FlowRxFilterValue other = (FlowRxFilterValue) obj;
    return (this.value() == other.value()) && this.rule().equals(other.rule());
}
#end_block

#method_before
@Override
public int compareTo(Object other) {
    if (this == other) {
        return 0;
    }
    if (other == null) {
        return -1;
    }
    if (other instanceof FlowRxFilterValue) {
        FlowRxFilterValue otherRxVal = (FlowRxFilterValue) other;
        String thisFlowRule = this.toString();
        String otherFlowRule = otherRxVal.toString();
        return thisFlowRule.compareToIgnoreCase(otherFlowRule);
    }
    return -1;
}
#method_after
@Override
public int compareTo(Object other) {
    if (this == other) {
        return 0;
    }
    if (other == null) {
        return -1;
    }
    if (other instanceof FlowRxFilterValue) {
        FlowRxFilterValue otherRxVal = (FlowRxFilterValue) other;
        long thisCoreId = this.value();
        long otherCoreId = otherRxVal.value();
        if (thisCoreId > otherCoreId) {
            return 1;
        } else if (thisCoreId < otherCoreId) {
            return -1;
        } else {
            return 0;
        }
    }
    return -1;
}
#end_block

#method_before
@Override
public String toString() {
    return this.value();
}
#method_after
@Override
public String toString() {
    return Long.toString(this.value());
}
#end_block

#method_before
public static String printTrace(StaticPacketTrace trace, boolean verbosity1, boolean verbosity2) {
    StringBuilder tracePrint = new StringBuilder();
    // Print based on verbosity
    if (verbosity1) {
        tracePrint = printTrace(trace, false, tracePrint);
    } else if (verbosity2) {
        tracePrint = printTrace(trace, true, tracePrint);
    } else {
        tracePrint.append("Paths");
        tracePrint.append("\n");
        List<List<ConnectPoint>> paths = trace.getCompletePaths();
        for (List<ConnectPoint> path : paths) {
            tracePrint.append(path);
            tracePrint.append("\n");
        }
    }
    tracePrint.append("Result: \n" + trace.resultMessage());
    return tracePrint.toString();
}
#method_after
static String printTrace(StaticPacketTrace trace, boolean verbosity1, boolean verbosity2) {
    StringBuilder tracePrint = new StringBuilder();
    // Print based on verbosity
    if (verbosity1) {
        tracePrint = printTrace(trace, false, tracePrint);
    } else if (verbosity2) {
        tracePrint = printTrace(trace, true, tracePrint);
    } else {
        tracePrint.append("Paths");
        tracePrint.append("\n");
        List<List<ConnectPoint>> paths = trace.getCompletePaths();
        for (List<ConnectPoint> path : paths) {
            tracePrint.append(path);
            tracePrint.append("\n");
        }
    }
    tracePrint.append("Result: \n" + trace.resultMessage());
    return tracePrint.toString();
}
#end_block

#method_before
@Override
protected void execute() {
    TroubleshootService service = get(TroubleshootService.class);
    print("Tracing all Multicast routes in the System");
    print("%s", StringUtils.rightPad("", 125, '-'));
    // Create the generator for the list of traces.
    VlanId vlanId = vlan == null || vlan.isEmpty() ? VlanId.NONE : VlanId.vlanId(vlan);
    Generator<Set<StaticPacketTrace>> generator = service.traceMcast(vlanId);
    while (generator.iterator().hasNext()) {
        // Print also Route if possible or packet
        Set<StaticPacketTrace> traces = generator.iterator().next();
        traces.forEach(trace -> {
            print("Tracing packet: %s", trace.getInitialPacket());
            print("%s", T3CliUtils.printTrace(trace, verbosity1, verbosity2));
            print("%s", StringUtils.rightPad("", 125, '-'));
        });
    }
}
#method_after
@Override
protected void execute() {
    TroubleshootService service = get(TroubleshootService.class);
    print("Tracing all Multicast routes in the System");
    // Create the generator for the list of traces.
    VlanId vlanId = vlan == null || vlan.isEmpty() ? VlanId.NONE : VlanId.vlanId(vlan);
    Generator<Set<StaticPacketTrace>> generator = service.traceMcast(vlanId);
    int totalTraces = 0;
    List<StaticPacketTrace> failedTraces = new ArrayList<>();
    StaticPacketTrace previousTrace = null;
    while (generator.iterator().hasNext()) {
        totalTraces++;
        // Print also Route if possible or packet
        Set<StaticPacketTrace> traces = generator.iterator().next();
        if (!verbosity1 && !verbosity2 && !verbosity3) {
            for (StaticPacketTrace trace : traces) {
                previousTrace = printTrace(previousTrace, trace);
                if (!trace.isSuccess()) {
                    print("Failure: %s", trace.resultMessage());
                    failedTraces.add(trace);
                } else {
                    print("Success");
                }
            }
        } else {
            traces.forEach(trace -> {
                print("Tracing packet: %s", trace.getInitialPacket());
                print("%s", T3CliUtils.printTrace(trace, verbosity2, verbosity3));
                print("%s", StringUtils.rightPad("", 125, '-'));
            });
        }
    }
    if (!verbosity1 && !verbosity2 && !verbosity3) {
        if (failedTraces.size() != 0) {
            print("%s", StringUtils.rightPad("", 125, '-'));
            print("Failed Traces: %s", failedTraces.size());
        }
        previousTrace = null;
        for (StaticPacketTrace trace : failedTraces) {
            previousTrace = printTrace(previousTrace, trace);
            print("Failure: %s", trace.resultMessage());
        }
        print("%s", StringUtils.rightPad("", 125, '-'));
        print("Summary");
        print("Total Traces %s, errors %s", totalTraces, failedTraces.size());
        print("%s", StringUtils.rightPad("", 125, '-'));
    }
}
#end_block

#method_before
private StaticPacketTrace getTrace(List<ConnectPoint> completePath, ConnectPoint in, StaticPacketTrace trace, boolean isDualHomed) {
    log.debug("------------------------------------------------------------");
    // if the trace already contains the input connect point there is a loop
    if (pathContainsDevice(completePath, in.deviceId())) {
        trace.addResultMessage("Loop encountered in device " + in.deviceId());
        completePath.add(in);
        trace.addCompletePath(completePath);
        trace.setSuccess(false);
        return trace;
    }
    // let's add the input connect point
    completePath.add(in);
    // If the trace has no outputs for the given input we stop here
    if (trace.getGroupOuputs(in.deviceId()) == null) {
        computePath(completePath, trace, null);
        trace.addResultMessage("No output out of device " + in.deviceId() + ". Packet is dropped");
        trace.setSuccess(false);
        return trace;
    }
    // If the trace has outputs we analyze them all
    for (GroupsInDevice outputPath : trace.getGroupOuputs(in.deviceId())) {
        ConnectPoint cp = outputPath.getOutput();
        log.debug("Connect point in {}", in);
        log.debug("Output path {}", cp);
        log.debug("{}", outputPath.getFinalPacket());
        // Hosts for the the given output
        Set<Host> hostsList = hostService.getConnectedHosts(cp);
        // Hosts queried from the original ip or mac
        Set<Host> hosts = getHosts(trace);
        if (in.equals(cp) && trace.getInitialPacket().getCriterion(Criterion.Type.VLAN_VID) != null && outputPath.getFinalPacket().getCriterion(Criterion.Type.VLAN_VID) != null && ((VlanIdCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.VLAN_VID)).vlanId().equals(((VlanIdCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.VLAN_VID)).vlanId())) {
            if (trace.getGroupOuputs(in.deviceId()).size() == 1 && computePath(completePath, trace, outputPath.getOutput())) {
                trace.addResultMessage("Connect point out " + cp + " is same as initial input " + in);
                trace.setSuccess(false);
            }
        } else if (!Collections.disjoint(hostsList, hosts)) {
            // If the two host collections contain the same item it means we reached the proper output
            log.debug("Stopping here because host is expected destination {}, reached through", completePath);
            if (computePath(completePath, trace, outputPath.getOutput())) {
                trace.addResultMessage("Reached required destination Host " + cp);
                trace.setSuccess(true);
            }
            break;
        } else if (cp.port().equals(PortNumber.CONTROLLER)) {
            // Getting the master when the packet gets sent as packet in
            NodeId master = mastershipService.getMasterFor(cp.deviceId());
            trace.addResultMessage(PACKET_TO_CONTROLLER + " " + master.id());
            computePath(completePath, trace, outputPath.getOutput());
            handleVlanToController(outputPath, trace);
        } else if (linkService.getEgressLinks(cp).size() > 0) {
            // in any of the ones we have.
            if (trace.getCompletePaths().size() > 0) {
                ConnectPoint inputForOutput = null;
                List<ConnectPoint> previousPath = new ArrayList<>();
                for (List<ConnectPoint> path : trace.getCompletePaths()) {
                    for (ConnectPoint connect : path) {
                        // if the path already contains the input for the output we've found we use it
                        if (connect.equals(in)) {
                            inputForOutput = connect;
                            previousPath = path;
                            break;
                        }
                    }
                }
                // we use the pre-existing path up to the point we fork to a new output
                if (inputForOutput != null && completePath.contains(inputForOutput)) {
                    List<ConnectPoint> temp = new ArrayList<>(previousPath);
                    temp = temp.subList(0, previousPath.indexOf(inputForOutput) + 1);
                    if (completePath.containsAll(temp)) {
                        completePath = temp;
                    }
                }
            }
            // let's add the ouput for the input
            completePath.add(cp);
            // let's compute the links for the given output
            Set<Link> links = linkService.getEgressLinks(cp);
            log.debug("Egress Links {}", links);
            // For each link we trace the corresponding device
            for (Link link : links) {
                ConnectPoint dst = link.dst();
                // change in-port to the dst link in port
                Builder updatedPacket = DefaultTrafficSelector.builder();
                outputPath.getFinalPacket().criteria().forEach(updatedPacket::add);
                updatedPacket.add(Criteria.matchInPort(dst.port()));
                log.debug("DST Connect Point {}", dst);
                // build the elements for that device
                traceInDevice(trace, updatedPacket.build(), dst, isDualHomed, completePath);
                // continue the trace along the path
                getTrace(completePath, dst, trace, isDualHomed);
            }
        } else if (edgePortService.isEdgePoint(outputPath.getOutput()) && trace.getInitialPacket().getCriterion(Criterion.Type.ETH_DST) != null && ((EthCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.ETH_DST)).mac().isMulticast()) {
            trace.addResultMessage("Packet is multicast and reached output " + outputPath.getOutput() + " which is enabled and is edge port");
            trace.setSuccess(true);
            computePath(completePath, trace, outputPath.getOutput());
            if (!hasOtherOutput(in.deviceId(), trace, outputPath.getOutput())) {
                return trace;
            }
        } else if (deviceService.getPort(cp) != null && deviceService.getPort(cp).isEnabled()) {
            EthTypeCriterion ethTypeCriterion = (EthTypeCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.ETH_TYPE);
            // We treat as correct output only if it's not LLDP or BDDP
            if (!(ethTypeCriterion.ethType().equals(EtherType.LLDP.ethType()) && !ethTypeCriterion.ethType().equals(EtherType.BDDP.ethType()))) {
                if (computePath(completePath, trace, outputPath.getOutput())) {
                    if (hostsList.isEmpty()) {
                        trace.addResultMessage("Packet is " + ((EthTypeCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.ETH_TYPE)).ethType() + " and reached " + cp + " with no hosts connected ");
                    } else {
                        IpAddress ipAddress = null;
                        if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST) != null) {
                            ipAddress = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST)).ip().address();
                        } else if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST) != null) {
                            ipAddress = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST)).ip().address();
                        }
                        if (ipAddress != null) {
                            IpAddress finalIpAddress = ipAddress;
                            if (hostsList.stream().anyMatch(host -> host.ipAddresses().contains(finalIpAddress)) || hostService.getHostsByIp(finalIpAddress).isEmpty()) {
                                trace.addResultMessage("Packet is " + ((EthTypeCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.ETH_TYPE)).ethType() + " and reached " + cp + " with hosts " + hostsList);
                            } else {
                                trace.addResultMessage("Wrong output " + cp + " for required destination ip " + ipAddress);
                                trace.setSuccess(false);
                            }
                        } else {
                            trace.addResultMessage("Packet is " + ((EthTypeCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.ETH_TYPE)).ethType() + " and reached " + cp + " with hosts " + hostsList);
                        }
                    }
                    trace.setSuccess(true);
                }
            }
        } else {
            computePath(completePath, trace, cp);
            trace.setSuccess(false);
            if (deviceService.getPort(cp) == null) {
                // Port is not existant on device.
                log.warn("Port {} is not available on device.", cp);
                trace.addResultMessage("Port " + cp + "is not available on device. Packet is dropped");
            } else {
                // No links means that the packet gets dropped.
                log.warn("No links out of {}", cp);
                trace.addResultMessage("No links depart from " + cp + ". Packet is dropped");
            }
        }
    }
    return trace;
}
#method_after
private StaticPacketTrace getTrace(List<ConnectPoint> completePath, ConnectPoint in, StaticPacketTrace trace, boolean isDualHomed) {
    log.debug("------------------------------------------------------------");
    // if the trace already contains the input connect point there is a loop
    if (pathContainsDevice(completePath, in.deviceId())) {
        trace.addResultMessage("Loop encountered in device " + in.deviceId());
        completePath.add(in);
        trace.addCompletePath(completePath);
        trace.setSuccess(false);
        return trace;
    }
    // let's add the input connect point
    completePath.add(in);
    // If the trace has no outputs for the given input we stop here
    if (trace.getGroupOuputs(in.deviceId()) == null) {
        computePath(completePath, trace, null);
        trace.addResultMessage("No output out of device " + in.deviceId() + ". Packet is dropped");
        trace.setSuccess(false);
        return trace;
    }
    // If the trace has outputs we analyze them all
    for (GroupsInDevice outputPath : trace.getGroupOuputs(in.deviceId())) {
        ConnectPoint cp = outputPath.getOutput();
        log.debug("Connect point in {}", in);
        log.debug("Output path {}", cp);
        log.debug("{}", outputPath.getFinalPacket());
        // Hosts for the the given output
        Set<Host> hostsList = hostService.getConnectedHosts(cp);
        // Hosts queried from the original ip or mac
        Set<Host> hosts = getHosts(trace);
        if (in.equals(cp) && trace.getInitialPacket().getCriterion(Criterion.Type.VLAN_VID) != null && outputPath.getFinalPacket().getCriterion(Criterion.Type.VLAN_VID) != null && ((VlanIdCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.VLAN_VID)).vlanId().equals(((VlanIdCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.VLAN_VID)).vlanId())) {
            if (trace.getGroupOuputs(in.deviceId()).size() == 1 && computePath(completePath, trace, outputPath.getOutput())) {
                trace.addResultMessage("Connect point out " + cp + " is same as initial input " + in);
                trace.setSuccess(false);
            }
        } else if (!Collections.disjoint(hostsList, hosts)) {
            // If the two host collections contain the same item it means we reached the proper output
            log.debug("Stopping here because host is expected destination {}, reached through", completePath);
            if (computePath(completePath, trace, outputPath.getOutput())) {
                trace.addResultMessage("Reached required destination Host " + cp);
                trace.setSuccess(true);
            }
            break;
        } else if (cp.port().equals(PortNumber.CONTROLLER)) {
            // Getting the master when the packet gets sent as packet in
            NodeId master = mastershipService.getMasterFor(cp.deviceId());
            trace.addResultMessage(PACKET_TO_CONTROLLER + " " + master.id());
            computePath(completePath, trace, outputPath.getOutput());
            handleVlanToController(outputPath, trace);
        } else if (linkService.getEgressLinks(cp).size() > 0) {
            // in any of the ones we have.
            if (trace.getCompletePaths().size() > 0) {
                ConnectPoint inputForOutput = null;
                List<ConnectPoint> previousPath = new ArrayList<>();
                for (List<ConnectPoint> path : trace.getCompletePaths()) {
                    for (ConnectPoint connect : path) {
                        // if the path already contains the input for the output we've found we use it
                        if (connect.equals(in)) {
                            inputForOutput = connect;
                            previousPath = path;
                            break;
                        }
                    }
                }
                // we use the pre-existing path up to the point we fork to a new output
                if (inputForOutput != null && completePath.contains(inputForOutput)) {
                    List<ConnectPoint> temp = new ArrayList<>(previousPath);
                    temp = temp.subList(0, previousPath.indexOf(inputForOutput) + 1);
                    if (completePath.containsAll(temp)) {
                        completePath = temp;
                    }
                }
            }
            // let's add the ouput for the input
            completePath.add(cp);
            // let's compute the links for the given output
            Set<Link> links = linkService.getEgressLinks(cp);
            log.debug("Egress Links {}", links);
            // For each link we trace the corresponding device
            for (Link link : links) {
                ConnectPoint dst = link.dst();
                // change in-port to the dst link in port
                Builder updatedPacket = DefaultTrafficSelector.builder();
                outputPath.getFinalPacket().criteria().forEach(updatedPacket::add);
                updatedPacket.add(Criteria.matchInPort(dst.port()));
                log.debug("DST Connect Point {}", dst);
                // build the elements for that device
                traceInDevice(trace, updatedPacket.build(), dst, isDualHomed, completePath);
                // continue the trace along the path
                getTrace(completePath, dst, trace, isDualHomed);
            }
        } else if (edgePortService.isEdgePoint(outputPath.getOutput()) && trace.getInitialPacket().getCriterion(Criterion.Type.ETH_DST) != null && ((EthCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.ETH_DST)).mac().isMulticast()) {
            trace.addResultMessage("Packet is multicast and reached output " + outputPath.getOutput() + " which is enabled and is edge port");
            trace.setSuccess(true);
            computePath(completePath, trace, outputPath.getOutput());
            if (!hasOtherOutput(in.deviceId(), trace, outputPath.getOutput())) {
                return trace;
            }
        } else if (deviceService.getPort(cp) != null && deviceService.getPort(cp).isEnabled()) {
            EthTypeCriterion ethTypeCriterion = (EthTypeCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.ETH_TYPE);
            // We treat as correct output only if it's not LLDP or BDDP
            if (!(ethTypeCriterion.ethType().equals(EtherType.LLDP.ethType()) && !ethTypeCriterion.ethType().equals(EtherType.BDDP.ethType()))) {
                if (computePath(completePath, trace, outputPath.getOutput())) {
                    if (hostsList.isEmpty()) {
                        trace.addResultMessage("Packet is " + ((EthTypeCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.ETH_TYPE)).ethType() + " and reached " + cp + " with no hosts connected ");
                    } else {
                        IpAddress ipAddress = null;
                        if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST) != null) {
                            ipAddress = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST)).ip().address();
                        } else if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST) != null) {
                            ipAddress = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST)).ip().address();
                        }
                        if (ipAddress != null) {
                            IpAddress finalIpAddress = ipAddress;
                            if (hostsList.stream().anyMatch(host -> host.ipAddresses().contains(finalIpAddress)) || hostService.getHostsByIp(finalIpAddress).isEmpty()) {
                                trace.addResultMessage("Packet is " + ((EthTypeCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.ETH_TYPE)).ethType() + " and reached " + cp + " with hosts " + hostsList);
                            } else {
                                trace.addResultMessage("Wrong output " + cp + " for required destination ip " + ipAddress);
                                trace.setSuccess(false);
                            }
                        } else {
                            trace.addResultMessage("Packet is " + ((EthTypeCriterion) outputPath.getFinalPacket().getCriterion(Criterion.Type.ETH_TYPE)).ethType() + " and reached " + cp + " with hosts " + hostsList);
                        }
                    }
                    trace.setSuccess(true);
                }
            }
        } else {
            computePath(completePath, trace, cp);
            trace.setSuccess(false);
            if (deviceService.getPort(cp) == null) {
                // Port is not existent on device.
                log.warn("Port {} is not available on device.", cp);
                trace.addResultMessage("Port " + cp + "is not available on device. Packet is dropped");
            } else {
                // No links means that the packet gets dropped.
                log.warn("No links out of {}", cp);
                trace.addResultMessage("No links depart from " + cp + ". Packet is dropped");
            }
        }
    }
    return trace;
}
#end_block

#method_before
private StaticPacketTrace traceInDevice(StaticPacketTrace trace, TrafficSelector packet, ConnectPoint in, boolean isDualHomed, List<ConnectPoint> completePath) {
    boolean multipleRoutes = false;
    if (trace.getGroupOuputs(in.deviceId()) != null) {
        multipleRoutes = multipleRoutes(trace);
    }
    if (trace.getGroupOuputs(in.deviceId()) != null && !isDualHomed && !multipleRoutes) {
        log.debug("Trace already contains device and given outputs");
        return trace;
    }
    log.debug("Packet {} coming in from {}", packet, in);
    // if device is not available exit here.
    if (!deviceService.isAvailable(in.deviceId())) {
        trace.addResultMessage("Device is offline " + in.deviceId());
        computePath(completePath, trace, null);
        return trace;
    }
    // as the input port.
    if (in.port().equals(PortNumber.CONTROLLER)) {
        StaticPacketTrace outputTrace = inputFromController(trace, in);
        if (outputTrace != null) {
            return trace;
        }
    }
    List<FlowEntry> flows = new ArrayList<>();
    List<FlowEntry> outputFlows = new ArrayList<>();
    List<Instruction> deferredInstructions = new ArrayList<>();
    FlowEntry nextTableIdEntry = findNextTableIdEntry(in.deviceId(), -1);
    if (nextTableIdEntry == null) {
        trace.addResultMessage("No flow rules for device " + in.deviceId() + ". Aborting");
        computePath(completePath, trace, null);
        trace.setSuccess(false);
        return trace;
    }
    TableId tableId = nextTableIdEntry.table();
    FlowEntry flowEntry;
    boolean output = false;
    while (!output) {
        log.debug("Searching a Flow Entry on table {} for packet {}", tableId, packet);
        // get the rule that matches the incoming packet
        flowEntry = matchHighestPriority(packet, in, tableId);
        log.debug("Found Flow Entry {}", flowEntry);
        boolean isOfdpaHardware = TroubleshootUtils.hardwareOfdpaMap.getOrDefault(driverService.getDriver(in.deviceId()).name(), false);
        // if the flow entry on a table is null and we are on hardware we treat as table miss, with few exceptions
        if (flowEntry == null && isOfdpaHardware) {
            log.debug("Ofdpa Hw setup, no flow rule means table miss");
            if (((IndexTableId) tableId).id() == 27) {
                // Apparently a miss but Table 27 on OFDPA is a fixed table
                packet = handleOfdpa27FixedTable(trace, packet);
            }
            // Finding next table to go In case of miss
            nextTableIdEntry = findNextTableIdEntry(in.deviceId(), ((IndexTableId) tableId).id());
            log.debug("Next table id entry {}", nextTableIdEntry);
            // (another possibility is max tableId)
            if (nextTableIdEntry == null && flows.size() == 0) {
                trace.addResultMessage("No matching flow rules for device " + in.deviceId() + ". Aborting");
                computePath(completePath, trace, null);
                trace.setSuccess(false);
                return trace;
            } else if (nextTableIdEntry == null) {
                // Means that no more flow rules are present
                output = true;
            } else if (((IndexTableId) tableId).id() == 20) {
                // if the table is 20 OFDPA skips to table 50
                log.debug("A miss on Table 20 on OFDPA means that we skip directly to table 50");
                tableId = IndexTableId.of(50);
            } else {
                tableId = nextTableIdEntry.table();
            }
        } else if (flowEntry == null) {
            trace.addResultMessage("Packet has no match on table " + tableId + " in device " + in.deviceId() + ". Dropping");
            computePath(completePath, trace, null);
            trace.setSuccess(false);
            return trace;
        } else {
            // IF the table has a transition
            if (flowEntry.treatment().tableTransition() != null) {
                // update the next table we transitions to
                tableId = IndexTableId.of(flowEntry.treatment().tableTransition().tableId());
                log.debug("Flow Entry has transition to table Id {}", tableId);
                flows.add(flowEntry);
            } else {
                // table has no transition so it means that it's an output rule if on the last table
                log.debug("Flow Entry has no transition to table, treating as last rule {}", flowEntry);
                flows.add(flowEntry);
                outputFlows.add(flowEntry);
                output = true;
            }
            // update the packet according to the immediate actions of this flow rule.
            packet = updatePacket(packet, flowEntry.treatment().immediate()).build();
            // save the deferred rules for later
            deferredInstructions.addAll(flowEntry.treatment().deferred());
            // If the flow requires to clear deferred actions we do so for all the ones we encountered.
            if (flowEntry.treatment().clearedDeferred()) {
                deferredInstructions.clear();
            }
            // On table 10 OFDPA needs two rules to apply the vlan if none and then to transition to the next table.
            if (needsSecondTable10Flow(flowEntry, isOfdpaHardware)) {
                // Let's get the packet vlanId instruction
                VlanIdCriterion packetVlanIdCriterion = (VlanIdCriterion) packet.getCriterion(Criterion.Type.VLAN_VID);
                // Let's get the flow entry vlan mod instructions
                ModVlanIdInstruction entryModVlanIdInstruction = (ModVlanIdInstruction) flowEntry.treatment().immediate().stream().filter(instruction -> instruction instanceof ModVlanIdInstruction).findFirst().orElse(null);
                // is a flow rule that matches on same criteria and with updated vlanId
                if (entryModVlanIdInstruction != null) {
                    FlowEntry secondVlanFlow = getSecondFlowEntryOnTable10(packet, in, packetVlanIdCriterion, entryModVlanIdInstruction);
                    // We found the flow that we expected
                    if (secondVlanFlow != null) {
                        flows.add(secondVlanFlow);
                    } else {
                        trace.addResultMessage("Missing forwarding rule for tagged packet on " + in);
                        computePath(completePath, trace, null);
                        return trace;
                    }
                }
            }
        }
    }
    // Creating a modifiable builder for the output packet
    Builder builder = DefaultTrafficSelector.builder();
    packet.criteria().forEach(builder::add);
    // Adding all the flows to the trace
    trace.addFlowsForDevice(in.deviceId(), ImmutableList.copyOf(flows));
    List<PortNumber> outputPorts = new ArrayList<>();
    List<FlowEntry> outputFlowEntries = handleFlows(trace, packet, in, outputFlows, builder, outputPorts);
    log.debug("Handling Groups");
    // Analyze Groups
    List<Group> groups = new ArrayList<>();
    Collection<FlowEntry> nonOutputFlows = flows;
    nonOutputFlows.removeAll(outputFlowEntries);
    // Handling groups pointed at by immediate instructions
    for (FlowEntry entry : flows) {
        getGroupsFromInstructions(trace, groups, entry.treatment().immediate(), entry.deviceId(), builder, outputPorts, in, completePath);
    }
    // If we have deferred instructions at this point we handle them.
    if (deferredInstructions.size() > 0) {
        builder = handleDeferredActions(trace, packet, in, deferredInstructions, outputPorts, groups, completePath);
    }
    packet = builder.build();
    log.debug("Output Packet {}", packet);
    return trace;
}
#method_after
private StaticPacketTrace traceInDevice(StaticPacketTrace trace, TrafficSelector packet, ConnectPoint in, boolean isDualHomed, List<ConnectPoint> completePath) {
    boolean multipleRoutes = false;
    if (trace.getGroupOuputs(in.deviceId()) != null) {
        multipleRoutes = multipleRoutes(trace);
    }
    if (trace.getGroupOuputs(in.deviceId()) != null && !isDualHomed && !multipleRoutes) {
        log.debug("Trace already contains device and given outputs");
        return trace;
    }
    log.debug("Packet {} coming in from {}", packet, in);
    // if device is not available exit here.
    if (!deviceService.isAvailable(in.deviceId())) {
        trace.addResultMessage("Device is offline " + in.deviceId());
        computePath(completePath, trace, null);
        return trace;
    }
    // as the input port.
    if (in.port().equals(PortNumber.CONTROLLER)) {
        StaticPacketTrace outputTrace = inputFromController(trace, in);
        if (outputTrace != null) {
            return trace;
        }
    }
    List<FlowEntry> flows = new ArrayList<>();
    List<FlowEntry> outputFlows = new ArrayList<>();
    List<Instruction> deferredInstructions = new ArrayList<>();
    FlowEntry nextTableIdEntry = findNextTableIdEntry(in.deviceId(), -1);
    if (nextTableIdEntry == null) {
        trace.addResultMessage("No flow rules for device " + in.deviceId() + ". Aborting");
        computePath(completePath, trace, null);
        trace.setSuccess(false);
        return trace;
    }
    TableId tableId = nextTableIdEntry.table();
    FlowEntry flowEntry;
    boolean output = false;
    while (!output) {
        log.debug("Searching a Flow Entry on table {} for packet {}", tableId, packet);
        // get the rule that matches the incoming packet
        flowEntry = matchHighestPriority(packet, in, tableId);
        log.debug("Found Flow Entry {}", flowEntry);
        boolean isOfdpaHardware = TroubleshootUtils.hardwareOfdpaMap.getOrDefault(driverService.getDriver(in.deviceId()).name(), false);
        // if the flow entry on a table is null and we are on hardware we treat as table miss, with few exceptions
        if (flowEntry == null && isOfdpaHardware) {
            log.debug("Ofdpa Hw setup, no flow rule means table miss");
            if (((IndexTableId) tableId).id() == 27) {
                // Apparently a miss but Table 27 on OFDPA is a fixed table
                packet = handleOfdpa27FixedTable(trace, packet);
            }
            // Finding next table to go In case of miss
            nextTableIdEntry = findNextTableIdEntry(in.deviceId(), ((IndexTableId) tableId).id());
            log.debug("Next table id entry {}", nextTableIdEntry);
            // (another possibility is max tableId)
            if (nextTableIdEntry == null && flows.size() == 0) {
                trace.addResultMessage("No matching flow rules for device " + in.deviceId() + ". Aborting");
                computePath(completePath, trace, null);
                trace.setSuccess(false);
                return trace;
            } else if (nextTableIdEntry == null) {
                // Means that no more flow rules are present
                output = true;
            } else if (((IndexTableId) tableId).id() == 20) {
                // if the table is 20 OFDPA skips to table 50
                log.debug("A miss on Table 20 on OFDPA means that we skip directly to table 50");
                tableId = IndexTableId.of(50);
            } else if (((IndexTableId) tableId).id() == 40) {
                // if the table is 40 OFDPA skips to table 60
                log.debug("A miss on Table 40 on OFDPA means that we skip directly to table 60");
                tableId = IndexTableId.of(60);
            } else {
                tableId = nextTableIdEntry.table();
            }
        } else if (flowEntry == null) {
            trace.addResultMessage("Packet has no match on table " + tableId + " in device " + in.deviceId() + ". Dropping");
            computePath(completePath, trace, null);
            trace.setSuccess(false);
            return trace;
        } else {
            // IF the table has a transition
            if (flowEntry.treatment().tableTransition() != null) {
                // update the next table we transitions to
                tableId = IndexTableId.of(flowEntry.treatment().tableTransition().tableId());
                log.debug("Flow Entry has transition to table Id {}", tableId);
                flows.add(flowEntry);
            } else {
                // table has no transition so it means that it's an output rule if on the last table
                log.debug("Flow Entry has no transition to table, treating as last rule {}", flowEntry);
                flows.add(flowEntry);
                outputFlows.add(flowEntry);
                output = true;
            }
            // update the packet according to the immediate actions of this flow rule.
            packet = updatePacket(packet, flowEntry.treatment().immediate()).build();
            // save the deferred rules for later
            deferredInstructions.addAll(flowEntry.treatment().deferred());
            // If the flow requires to clear deferred actions we do so for all the ones we encountered.
            if (flowEntry.treatment().clearedDeferred()) {
                deferredInstructions.clear();
            }
            // On table 10 OFDPA needs two rules to apply the vlan if none and then to transition to the next table.
            if (needsSecondTable10Flow(flowEntry, isOfdpaHardware)) {
                // Let's get the packet vlanId instruction
                VlanIdCriterion packetVlanIdCriterion = (VlanIdCriterion) packet.getCriterion(Criterion.Type.VLAN_VID);
                // Let's get the flow entry vlan mod instructions
                ModVlanIdInstruction entryModVlanIdInstruction = (ModVlanIdInstruction) flowEntry.treatment().immediate().stream().filter(instruction -> instruction instanceof ModVlanIdInstruction).findFirst().orElse(null);
                // is a flow rule that matches on same criteria and with updated vlanId
                if (entryModVlanIdInstruction != null) {
                    FlowEntry secondVlanFlow = getSecondFlowEntryOnTable10(packet, in, packetVlanIdCriterion, entryModVlanIdInstruction);
                    // We found the flow that we expected
                    if (secondVlanFlow != null) {
                        flows.add(secondVlanFlow);
                    } else {
                        trace.addResultMessage("Missing forwarding rule for tagged packet on " + in);
                        computePath(completePath, trace, null);
                        return trace;
                    }
                }
            }
        }
    }
    // Creating a modifiable builder for the output packet
    Builder builder = DefaultTrafficSelector.builder();
    packet.criteria().forEach(builder::add);
    // Adding all the flows to the trace
    trace.addFlowsForDevice(in.deviceId(), ImmutableList.copyOf(flows));
    List<PortNumber> outputPorts = new ArrayList<>();
    List<FlowEntry> outputFlowEntries = handleFlows(trace, packet, in, outputFlows, builder, outputPorts);
    log.debug("Handling Groups");
    // Analyze Groups
    List<Group> groups = new ArrayList<>();
    Collection<FlowEntry> nonOutputFlows = flows;
    nonOutputFlows.removeAll(outputFlowEntries);
    // Handling groups pointed at by immediate instructions
    for (FlowEntry entry : flows) {
        getGroupsFromInstructions(trace, groups, entry.treatment().immediate(), entry.deviceId(), builder, outputPorts, in, completePath);
    }
    // If we have deferred instructions at this point we handle them.
    if (deferredInstructions.size() > 0) {
        builder = handleDeferredActions(trace, packet, in, deferredInstructions, outputPorts, groups, completePath);
    }
    packet = builder.build();
    log.debug("Output Packet {}", packet);
    return trace;
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    log.info("type: {}", event.type());
    log.info("subject: {}", event.subject());
    DeviceId did = ((ConnectPoint) event.subject()).deviceId();
    TerminalDeviceDriver driver = TerminalDeviceDriver.create();
    TerminalDeviceConfig config;
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            config = (TerminalDeviceConfig) event.config().get();
            log.info("config: {}", config);
            driver.apply(did, config.clientCp().port(), config.subject().port(), config.isEnabled());
            break;
        case CONFIG_REMOVED:
            config = (TerminalDeviceConfig) event.prevConfig().get();
            log.info("config: {}", config);
            driver.apply(did, config.clientCp().port(), config.subject().port(), false);
            break;
        default:
            log.error("Unsupported event type.");
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    log.info("type: {}", event.type());
    log.info("subject: {}", event.subject());
    DeviceId did = ((ConnectPoint) event.subject()).deviceId();
    DefaultOdtnTerminalDeviceDriver driver = DefaultOdtnTerminalDeviceDriver.create();
    TerminalDeviceConfig config;
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            config = (TerminalDeviceConfig) event.config().get();
            log.info("config: {}", config);
            driver.apply(did, config.clientCp().port(), config.subject().port(), config.isEnabled());
            break;
        case CONFIG_REMOVED:
            config = (TerminalDeviceConfig) event.prevConfig().get();
            log.info("config: {}", config);
            driver.apply(did, config.clientCp().port(), config.subject().port(), false);
            break;
        default:
            log.error("Unsupported event type.");
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isReachable() {
    return CompletableFuture.supplyAsync(() -> handler().get(P4RuntimeController.class).isReacheable(handler().data().deviceId()));
}
#method_after
@Override
public CompletableFuture<Boolean> isReachable() {
    return CompletableFuture.supplyAsync(() -> handler().get(P4RuntimeController.class).isReachable(handler().data().deviceId()));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
PiPipelineInterpreter getInterpreter() {
    // one, obtained before driver merge.
    if (!pipeconf.implementation(PiPipelineInterpreter.class).isPresent()) {
        log.warn("Unable to get interpreter for {}, missing behaviour in pipeconf {}", deviceId, pipeconf.id());
        return null;
    }
    Class<? extends PiPipelineInterpreter> clazz = (Class<? extends PiPipelineInterpreter>) pipeconf.implementation(PiPipelineInterpreter.class).get();
    try {
        PiPipelineInterpreter interpreter = clazz.newInstance();
        interpreter.setData(this.data());
        interpreter.setHandler(this.handler());
        return interpreter;
    } catch (InstantiationException | IllegalAccessException e) {
        log.error("Unable to instantiate interpreter {} of pipeconf {} for {}: {}", clazz.getSimpleName(), pipeconf.id(), deviceId);
        return null;
    }
}
#method_after
PiPipelineInterpreter getInterpreter() {
    if (!device.is(PiPipelineInterpreter.class)) {
        log.warn("Unable to get interpreter for {}, missing behaviour", deviceId);
        return null;
    }
    return device.as(PiPipelineInterpreter.class);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> bindToDevice(PiPipeconfId pipeconfId, DeviceId deviceId) {
    return CompletableFuture.supplyAsync(() -> doMergeDriver(deviceId, pipeconfId), executor);
}
#method_after
@Override
public void bindToDevice(PiPipeconfId pipeconfId, DeviceId deviceId) {
    pipeconfMappingStore.createOrUpdateBinding(deviceId, pipeconfId);
}
#end_block

#method_before
private boolean doMergeDriver(DeviceId deviceId, PiPipeconfId pipeconfId) {
    // Perform the following operations:
    // 1) ALL nodes: create and register new merged driver (pipeconf + base driver)
    // 2) ONE node (leader): updated netcfg with new driver
    log.debug("Starting device driver merge of {} with {}...", deviceId, pipeconfId);
    final BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    final String baseDriverName = basicDeviceConfig.driver();
    if (baseDriverName.endsWith(":" + pipeconfId.id())) {
        log.debug("Base driver of {} ({}) has been already merged with {}", deviceId, baseDriverName, pipeconfId);
        return true;
    }
    final Driver baseDriver;
    try {
        baseDriver = driverService.getDriver(basicDeviceConfig.driver());
    } catch (ItemNotFoundException e) {
        log.error("Base driver {} not found for {}, aborting pipeconf driver merge", basicDeviceConfig.driver(), deviceId);
        return false;
    }
    final String newDriverName = baseDriver.name() + ":" + pipeconfId.id();
    final PiPipeconf pipeconf = pipeconfs.get(pipeconfId);
    if (pipeconf == null) {
        log.error("Pipeconf {} is not registered, aborting driver merge for {}", pipeconfId, deviceId);
        return false;
    }
    // 1) if merged driver exists already we don't create a new one.
    try {
        driverService.getDriver(newDriverName);
        log.info("Found existing merged driver {}, re-using that", newDriverName);
    } catch (ItemNotFoundException e) {
        log.info("Creating merged driver {}...", newDriverName);
        createMergedDriver(pipeconf, baseDriver, newDriverName);
    }
    // 2) Updating device cfg to enforce the merged driver (one node only)
    final boolean isLeader = leadershipService.runForLeadership(DRIVER_MERGE_TOPIC + deviceId.toString()).leaderNodeId().equals(clusterService.getLocalNode().id());
    if (isLeader) {
        // FIXME: this binding should be updated by the same entity
        // deploying the pipeconf.
        pipeconfMappingStore.createOrUpdateBinding(deviceId, pipeconfId);
        if (!basicDeviceConfig.driver().equals(newDriverName)) {
            log.info("Applying new driver {} for device {} via cfg...", newDriverName, deviceId);
            setDriverViaCfg(deviceId, newDriverName, basicDeviceConfig);
        }
    }
    return true;
}
#method_after
private String doMergeDriver(DeviceId deviceId, PiPipeconfId pipeconfId) {
    log.debug("Starting device driver merge of {} with {}...", deviceId, pipeconfId);
    final BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (basicDeviceConfig == null) {
        log.warn("Unable to get basic device config for {}, " + "aborting pipeconf driver merge");
        return null;
    }
    String baseDriverName = basicDeviceConfig.driver();
    if (baseDriverName.endsWith(mergedDriverSuffix(pipeconfId))) {
        // The config already has driver name that is a merged one. We still
        // need to make sure an instance of that merged driver is present in
        // this node.
        log.debug("Base driver of {} ({}) has been already merged with {}", deviceId, baseDriverName, pipeconfId);
        baseDriverName = getBaseDriverNameFromMerged(baseDriverName);
    }
    final String newDriverName = mergedDriverName(baseDriverName, pipeconfId);
    // If merged driver exists already we don't create a new one.
    try {
        driverService.getDriver(newDriverName);
        return newDriverName;
    } catch (ItemNotFoundException e) {
        log.info("Creating merged driver {}...", newDriverName);
    }
    final Driver mergedDriver = buildMergedDriver(pipeconfId, baseDriverName, newDriverName);
    if (mergedDriver == null) {
        // Error logged by buildMergedDriver
        return null;
    }
    registerMergedDriver(mergedDriver);
    return newDriverName;
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    providerService = providerRegistry.register(this);
    componentConfigService.registerProperties(getClass());
    coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    deviceService.addListener(deviceListener);
    handshakers.clear();
    // This will fail if ONOS has CFG and drivers which depend on this provider
    // are activated, failing due to not finding the driver.
    cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class).forEach(did -> triggerConnectWithLeadership(did, FIRST_CONNECTION_TOPIC + did.toString()));
    // Initiating a periodic check to see if any device is available again and reconnect it.
    rescheduleAvailCheckTask();
    modified(context);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    providerService = providerRegistry.register(this);
    componentConfigService.registerProperties(getClass());
    coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    deviceService.addListener(deviceListener);
    handshakers.clear();
    // This will fail if ONOS has CFG and drivers which depend on this provider
    // are activated, failing due to not finding the driver.
    cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class).forEach(this::triggerConnect);
    // Initiating a periodic check to see if any device is available again and reconnect it.
    rescheduleProbeTask();
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    final int oldStatsPollFrequency = statsPollFrequency;
    statsPollFrequency = Tools.getIntegerProperty(properties, STATS_POLL_FREQUENCY, DEFAULT_STATS_POLL_FREQUENCY);
    log.info("Configured. {} is configured to {} seconds", STATS_POLL_FREQUENCY, statsPollFrequency);
    final int oldAvailPollFrequency = availPollFrequency;
    availPollFrequency = Tools.getIntegerProperty(properties, AVAIL_POLL_FREQUENCY, DEFAULT_AVAIL_POLL_FREQUENCY);
    log.info("Configured. {} is configured to {} seconds", AVAIL_POLL_FREQUENCY, availPollFrequency);
    opTimeoutShort = Tools.getIntegerProperty(properties, OP_TIMEOUT_SHORT, DEFAULT_OP_TIMEOUT_SHORT);
    log.info("Configured. {} is configured to {} seconds", OP_TIMEOUT_SHORT, opTimeoutShort);
    opTimeoutLong = Tools.getIntegerProperty(properties, OP_TIMEOUT_LONG, DEFAULT_OP_TIMEOUT_LONG);
    log.info("Configured. {} is configured to {} seconds", OP_TIMEOUT_LONG, opTimeoutLong);
    if (oldStatsPollFrequency != statsPollFrequency) {
        rescheduleStatsPollingTasks();
    }
    if (oldAvailPollFrequency != availPollFrequency) {
        rescheduleAvailCheckTask();
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    final int oldStatsPollFrequency = statsPollFrequency;
    statsPollFrequency = Tools.getIntegerProperty(properties, STATS_POLL_FREQUENCY, DEFAULT_STATS_POLL_FREQUENCY);
    log.info("Configured. {} is configured to {} seconds", STATS_POLL_FREQUENCY, statsPollFrequency);
    final int oldProbeFrequency = probeFrequency;
    probeFrequency = Tools.getIntegerProperty(properties, PROBE_FREQUENCY, DEFAULT_PROBE_FREQUENCY);
    log.info("Configured. {} is configured to {} seconds", PROBE_FREQUENCY, probeFrequency);
    opTimeoutShort = Tools.getIntegerProperty(properties, OP_TIMEOUT_SHORT, DEFAULT_OP_TIMEOUT_SHORT);
    log.info("Configured. {} is configured to {} seconds", OP_TIMEOUT_SHORT, opTimeoutShort);
    opTimeoutLong = Tools.getIntegerProperty(properties, OP_TIMEOUT_LONG, DEFAULT_OP_TIMEOUT_LONG);
    log.info("Configured. {} is configured to {} seconds", OP_TIMEOUT_LONG, opTimeoutLong);
    if (oldStatsPollFrequency != statsPollFrequency) {
        rescheduleStatsPollingTasks();
    }
    if (oldProbeFrequency != probeFrequency) {
        rescheduleProbeTask();
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    statsExecutor.shutdown();
    availCheckExecutor.shutdown();
    componentConfigService.unregisterProperties(getClass(), false);
    cfgService.removeListener(cfgListener);
    // Not Removing the device so they can still be used from other driver providers
    // cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class)
    // .forEach(did -> connectionExecutor.execute(() -> disconnectDevice(did)));
    connectionExecutor.shutdown();
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    handshakers.clear();
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    statsExecutor.shutdown();
    probeExecutor.shutdown();
    componentConfigService.unregisterProperties(getClass(), false);
    cfgService.removeListener(cfgListener);
    // Not Removing the device so they can still be used from other driver providers
    // cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class)
    // .forEach(did -> connectionExecutor.execute(() -> disconnectDevice(did)));
    connectionExecutor.shutdown();
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    handshakers.clear();
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void triggerProbe(DeviceId deviceId) {
    // TODO Really don't see the point of this in non OF Context,
    // for now testing reachability, can be moved to no-op
    log.debug("Triggering probe equals testing reachability on device {}", deviceId);
    isReachable(deviceId);
}
#method_after
@Override
public void triggerProbe(DeviceId deviceId) {
    connectionExecutor.execute(withDeviceLock(() -> doDeviceProbe(deviceId), deviceId));
}
#end_block

#method_before
@Override
public void roleChanged(DeviceId deviceId, MastershipRole newRole) {
    log.info("Received role {} for device {}", newRole, deviceId);
    requestedRoles.put(deviceId, newRole);
    connectionExecutor.submit(exceptionSafe(() -> doRoleChanged(deviceId, newRole)));
}
#method_after
@Override
public void roleChanged(DeviceId deviceId, MastershipRole newRole) {
    log.info("Received role {} for device {}", newRole, deviceId);
    requestedRoles.put(deviceId, newRole);
    connectionExecutor.execute(() -> doRoleChanged(deviceId, newRole));
}
#end_block

#method_before
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    if (!deviceService.getDevice(deviceId).is(PortAdmin.class)) {
        log.warn("Missing PortAdmin behaviour on {}, aborting port state change", deviceId);
        return;
    }
    final PortAdmin portAdmin = deviceService.getDevice(deviceId).as(PortAdmin.class);
    final CompletableFuture<Boolean> modified = enable ? portAdmin.enable(portNumber) : portAdmin.disable(portNumber);
    modified.thenAcceptAsync(result -> {
        if (!result) {
            log.warn("Port {} status cannot be changed on {} (enable={})", portNumber, deviceId, enable);
        }
    });
}
#method_after
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    connectionExecutor.execute(() -> doChangePortState(deviceId, portNumber, enable));
}
#end_block

#method_before
@Override
public void triggerDisconnect(DeviceId deviceId) {
    log.debug("Triggering disconnection of device {}", deviceId);
    doAsyncDisconnect(deviceId);
}
#method_after
@Override
public void triggerDisconnect(DeviceId deviceId) {
    log.debug("Triggering disconnection of device {}", deviceId);
    connectionExecutor.execute(withDeviceLock(() -> doDisconnectDevice(deviceId), deviceId));
}
#end_block

#method_before
private Driver getDriver(DeviceId deviceId) {
    try {
        return driverService.getDriver(deviceId);
    } catch (ItemNotFoundException e) {
        log.debug("Falling back to configuration to fetch driver " + "for device {}", deviceId);
        BasicDeviceConfig cfg = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
        if (cfg != null) {
            try {
                return driverService.getDriver(cfg.driver());
            } catch (ItemNotFoundException ex) {
                log.error("Driver {} not found for {}", cfg.driver(), deviceId);
            }
        }
        return null;
    }
}
#method_after
private Driver getDriver(DeviceId deviceId) {
    try {
        // DriverManager checks first using basic device config.
        return driverService.getDriver(deviceId);
    } catch (ItemNotFoundException e) {
        log.error("Driver not found for {}", deviceId);
        return null;
    }
}
#end_block

#method_before
// needed since the device manager will not return the driver through implementation()
// method since the device is not pushed to the core so for the connectDeviceAsMaster
// we need to work around that in order to test before calling
private <T extends Behaviour> T getBehaviour(Driver driver, Class<T> type, DriverData data) {
    if (driver != null && driver.hasBehaviour(type)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(data);
        return driver.createBehaviour(handler, type);
    } else {
        return null;
    }
}
#method_after
private <T extends Behaviour> T getBehaviour(Driver driver, Class<T> type, DriverData data) {
    // to the core.
    if (driver != null && driver.hasBehaviour(type)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(data);
        return driver.createBehaviour(handler, type);
    } else {
        return null;
    }
}
#end_block

#method_before
private void doConnectDevice(DeviceId deviceId, boolean asMaster) {
    if (deviceService.getDevice(deviceId) != null && deviceService.isAvailable(deviceId)) {
        log.info("Device {} is already connected to ONOS and is available", deviceId);
        return;
    }
    // Retrieve config
    final GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    final BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (providerConfig == null || basicDeviceConfig == null) {
        log.error("Configuration missing, cannot connect to {}. " + "basicDeviceConfig={}, generalProvider={}", deviceId, basicDeviceConfig, providerConfig);
        return;
    }
    log.info("Initiating connection to device {} with driver {} ... asMaster={}", deviceId, basicDeviceConfig.driver(), asMaster);
    // Get handshaker, driver and driver data.
    final DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker == null) {
        log.error("Missing DeviceHandshaker behavior for {}, aborting connection", deviceId);
        return;
    }
    final Driver driver = handshaker.handler().driver();
    // Enhance driver data with info in GDP config.
    augmentConfigData(providerConfig, handshaker.data());
    final DriverData driverData = handshaker.data();
    // Start connection via handshaker.
    final Boolean connectSuccess = getFutureWithDeadline(handshaker.connect(), "initiating connection", deviceId, null, opTimeoutShort);
    if (connectSuccess == null) {
        // Error logged by getFutureWithDeadline().
        return;
    } else if (!connectSuccess) {
        log.warn("Unable to connect to {}", deviceId);
        return;
    }
    // Handle pipeconf (if device is capable)
    if (!handlePipeconf(deviceId, driver, driverData, asMaster)) {
        // We already logged the error.
        handshaker.disconnect();
        return;
    }
    // Add device agent listener.
    handshaker.addDeviceAgentListener(deviceAgentListener);
    // All good. Notify core (if master).
    if (asMaster) {
        advertiseDevice(deviceId, driver, providerConfig, driverData);
    }
}
#method_after
private void doConnectDevice(DeviceId deviceId) {
    // Some operations can be performed by one node only.
    final boolean isLocalLeader = leadershipService.runForLeadership(GeneralProviderDeviceConfig.class.getName() + deviceId).leader().nodeId().equals(clusterService.getLocalNode().id());
    if (deviceService.getDevice(deviceId) != null && deviceService.isAvailable(deviceId)) {
        log.info("Device {} is already connected to ONOS and is available", deviceId);
        return;
    }
    // Retrieve config
    final GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    final BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (providerConfig == null || basicDeviceConfig == null) {
        log.error("Configuration missing, cannot connect to {}. " + "basicDeviceConfig={}, generalProvider={}", deviceId, basicDeviceConfig, providerConfig);
        return;
    }
    log.info("Initiating connection to device {} with driver {} ... asMaster={}", deviceId, basicDeviceConfig.driver(), isLocalLeader);
    // Get handshaker, driver and driver data.
    final DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker == null) {
        log.error("Missing DeviceHandshaker behavior for {}, aborting connection", deviceId);
        return;
    }
    final Driver driver = handshaker.handler().driver();
    // Enhance driver data with info in GDP config.
    augmentConfigData(providerConfig, handshaker.data());
    final DriverData driverData = handshaker.data();
    // Start connection via handshaker.
    final Boolean connectSuccess = getFutureWithDeadline(handshaker.connect(), "initiating connection", deviceId, null, opTimeoutShort);
    if (connectSuccess == null) {
        // Error logged by getFutureWithDeadline().
        return;
    } else if (!connectSuccess) {
        log.warn("Unable to connect to {}", deviceId);
        return;
    }
    // Handle pipeconf (if device is capable)
    if (!handlePipeconf(deviceId, driver, driverData, isLocalLeader)) {
        // We already logged the error.
        getFutureWithDeadline(handshaker.disconnect(), "performing disconnection", deviceId, null, opTimeoutShort);
        return;
    }
    // Add device agent listener.
    handshaker.addDeviceAgentListener(deviceAgentListener);
    // All good. Notify core (if master).
    if (isLocalLeader) {
        advertiseDevice(deviceId, driver, providerConfig, driverData);
    }
}
#end_block

#method_before
private boolean handlePipeconf(DeviceId deviceId, Driver driver, DriverData driverData, boolean deployPipeconf) {
    final PiPipelineProgrammable pipelineProg = getBehaviour(driver, PiPipelineProgrammable.class, driverData);
    if (pipelineProg == null) {
        // Device is not pipeline programmable.
        return true;
    }
    final PiPipeconf pipeconf = getPipeconf(deviceId, pipelineProg);
    if (pipeconf == null) {
        return false;
    }
    final PiPipeconfId pipeconfId = pipeconf.id();
    if (deployPipeconf) {
        final Boolean deploySuccess = getFutureWithDeadline(pipelineProg.deployPipeconf(pipeconf), "deploying pipeconf", deviceId, null, opTimeoutLong);
        if (deploySuccess == null) {
            // Error logged by getFutureWithDeadline().
            return false;
        } else if (!deploySuccess) {
            log.error("Unable to deploy pipeconf {} to {}, aborting device discovery", pipeconfId, deviceId);
            return false;
        }
    }
    final Boolean mergeSuccess = getFutureWithDeadline(piPipeconfService.bindToDevice(pipeconfId, deviceId), "merging driver", deviceId, null, opTimeoutShort);
    if (mergeSuccess == null) {
        // Error logged by getFutureWithDeadline().
        return false;
    } else if (!mergeSuccess) {
        log.error("Unable to merge pipeconf driver for {}, aborting device discovery", pipeconfId, deviceId);
        return false;
    }
    return true;
}
#method_after
private boolean handlePipeconf(DeviceId deviceId, Driver driver, DriverData driverData, boolean asMaster) {
    final PiPipelineProgrammable pipelineProg = getBehaviour(driver, PiPipelineProgrammable.class, driverData);
    if (pipelineProg == null) {
        // Device is not pipeline programmable.
        return true;
    }
    final PiPipeconf pipeconf = getPipeconf(deviceId, pipelineProg);
    if (pipeconf == null) {
        return false;
    }
    final PiPipeconfId pipeconfId = pipeconf.id();
    final String mergedDriverName = piPipeconfService.mergeDriver(deviceId, pipeconfId);
    if (mergedDriverName == null) {
        log.error("Unable to get merged driver for {} and {}, aborting device discovery", deviceId, pipeconfId);
        return false;
    }
    if (!asMaster) {
        // From now one only the master.
        return true;
    }
    if (!setDriverViaCfg(deviceId, mergedDriverName)) {
        return false;
    }
    // FIXME: we just introduced a race condition as it might happen that a
    // node does not receive the new cfg (with the merged driver) before the
    // device is advertised to the core. Perhaps we should be waiting for a
    // NetworkConfig event signaling that the driver has been updated on all
    // nodes? The effect is mitigated by deploying the pipeconf (slow
    // operation), after calling setDriverViaCfg().
    piPipeconfService.bindToDevice(pipeconfId, deviceId);
    final Boolean deploySuccess = getFutureWithDeadline(pipelineProg.deployPipeconf(pipeconf), "deploying pipeconf", deviceId, null, opTimeoutLong);
    if (deploySuccess == null) {
        // Error logged by getFutureWithDeadline().
        return false;
    } else if (!deploySuccess) {
        log.error("Unable to deploy pipeconf {} to {}, aborting device discovery", pipeconfId, deviceId);
        return false;
    }
    return true;
}
#end_block

#method_before
private void doDisconnectDevice(DeviceId deviceId) {
    log.info("Disconnecting for device {}", deviceId);
    // Remove from core (if master)
    if (mastershipService.isLocalMaster(deviceId) && deviceService.isAvailable(deviceId)) {
        providerService.deviceDisconnected(deviceId);
    }
    cancelStatsPolling(deviceId);
    // Perform disconnection with device.
    final DeviceHandshaker handshaker = handshakers.remove(deviceId);
    if (handshaker == null) {
        // Gracefully ignore
        log.warn("Missing DeviceHandshaker behavior for {}, " + "no guarantees of complete disconnection", deviceId);
        return;
    }
    handshaker.removeDeviceAgentListener(deviceAgentListener);
    final boolean disconnectSuccess = getFutureWithDeadline(handshaker.disconnect(), "performing disconnection", deviceId, false, opTimeoutShort);
    if (disconnectSuccess) {
        log.info("Disconnected device {}", deviceId);
    } else {
        log.warn("Device {} was unable to disconnect", deviceId);
    }
}
#method_after
private void doDisconnectDevice(DeviceId deviceId) {
    log.info("Initiating disconnection from {}...", deviceId);
    // Remove from core (if master)
    if (mastershipService.isLocalMaster(deviceId) && deviceService.isAvailable(deviceId)) {
        providerService.deviceDisconnected(deviceId);
    }
    cancelStatsPolling(deviceId);
    // Perform disconnection with device.
    final DeviceHandshaker handshaker = handshakers.remove(deviceId);
    if (handshaker == null) {
        // Gracefully ignore
        log.warn("Missing DeviceHandshaker behavior for {}, " + "no guarantees of complete disconnection", deviceId);
        return;
    }
    handshaker.removeDeviceAgentListener(deviceAgentListener);
    final boolean disconnectSuccess = getFutureWithDeadline(handshaker.disconnect(), "performing disconnection", deviceId, false, opTimeoutShort);
    if (!disconnectSuccess) {
        log.warn("Unable to disconnect from {}", deviceId);
    }
}
#end_block

#method_before
private Runnable withDeviceLock(Runnable runnable, DeviceId deviceId) {
    return () -> {
        Lock lock = DEVICE_LOCKS.computeIfAbsent(deviceId, key -> new ReentrantLock());
        lock.lock();
        try {
            runnable.run();
        } finally {
            lock.unlock();
        }
    };
}
#method_after
private <U> U withDeviceLock(Supplier<U> task, DeviceId deviceId) {
    final Lock lock = deviceLocks.get(deviceId);
    lock.lock();
    try {
        return task.get();
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
private Runnable withDeviceLock(Runnable runnable, DeviceId deviceId) {
    return () -> {
        Lock lock = DEVICE_LOCKS.computeIfAbsent(deviceId, key -> new ReentrantLock());
        lock.lock();
        try {
            runnable.run();
        } finally {
            lock.unlock();
        }
    };
}
#method_after
private Runnable withDeviceLock(Runnable task, DeviceId deviceId) {
    // Wrapper of withDeviceLock(Supplier, ...) for void tasks.
    return () -> withDeviceLock(() -> {
        task.run();
        return null;
    }, deviceId);
}
#end_block

#method_before
private void updatePortStatistics(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (!Objects.isNull(device) && deviceService.isAvailable(deviceId) && device.is(PortStatisticsDiscovery.class)) {
        Collection<PortStatistics> statistics = device.as(PortStatisticsDiscovery.class).discoverPortStatistics();
        // updating statistcs only if not empty
        if (!statistics.isEmpty()) {
            providerService.updatePortStatistics(deviceId, statistics);
        }
    } else {
        log.debug("Can't update port statistics for device {}", deviceId);
    }
}
#method_after
private void updatePortStatistics(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && deviceService.isAvailable(deviceId) && device.is(PortStatisticsDiscovery.class)) {
        Collection<PortStatistics> statistics = device.as(PortStatisticsDiscovery.class).discoverPortStatistics();
        // updating statistcs only if not empty
        if (!statistics.isEmpty()) {
            providerService.updatePortStatistics(deviceId, statistics);
        }
    } else {
        log.debug("Can't update port statistics for device {}", deviceId);
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    DeviceId deviceId = (DeviceId) event.subject();
    // Assuming that the deviceId comes with uri 'device:'
    if (notMyScheme(deviceId)) {
        // not under my scheme, skipping
        log.debug("{} is not my scheme, skipping", deviceId);
        return;
    }
    if (!isDeviceConfigComplete(event, deviceId)) {
        // Still waiting for some configuration.
        return;
    }
    // Good to go.
    triggerConnectWithLeadership(deviceId, FIRST_CONNECTION_TOPIC + deviceId.toString());
    cleanUpConfigInfo(deviceId);
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    DeviceId deviceId = (DeviceId) event.subject();
    // Assuming that the deviceId comes with uri 'device:'
    if (notMyScheme(deviceId)) {
        // not under my scheme, skipping
        log.debug("{} is not my scheme, skipping", deviceId);
        return;
    }
    final boolean configComplete = withDeviceLock(() -> isDeviceConfigComplete(event, deviceId), deviceId);
    if (!configComplete) {
        // Still waiting for some configuration.
        return;
    }
    // Good to go.
    triggerConnect(deviceId);
    cleanUpConfigInfo(deviceId);
}
#end_block

#method_before
private boolean isDeviceConfigComplete(NetworkConfigEvent event, DeviceId deviceId) {
    // FIXME to be removed when netcfg will issue device events in a bundle or
    // ensure all configuration needed is present
    Lock lock = DEVICE_LOCKS.computeIfAbsent(deviceId, key -> new ReentrantLock());
    lock.lock();
    try {
        if (event.configClass().equals(GeneralProviderDeviceConfig.class)) {
            // If we want to connect a p4runtime device with no pipeline
            if (event.config().isPresent()) {
                deviceConfigured.add(deviceId);
                final boolean isNotPipelineConfigurable = Collections.disjoint(ImmutableSet.copyOf(event.config().get().node().fieldNames()), PIPELINE_CONFIGURABLE_PROTOCOLS);
                if (isNotPipelineConfigurable) {
                    // Skip waiting for a pipeline if we can't support it.
                    pipelineConfigured.add(deviceId);
                }
            }
        } else if (event.configClass().equals(BasicDeviceConfig.class)) {
            if (event.config().isPresent() && event.config().get().node().has(DRIVER)) {
                driverConfigured.add(deviceId);
            }
        } else if (event.configClass().equals(PiPipeconfConfig.class)) {
            if (event.config().isPresent() && event.config().get().node().has(PiPipeconfConfig.PIPIPECONFID)) {
                pipelineConfigured.add(deviceId);
            }
        }
        if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId) && pipelineConfigured.contains(deviceId)) {
            return true;
        } else {
            if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
                log.debug("Waiting for pipeline configuration for device {}", deviceId);
            } else if (pipelineConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
                log.debug("Waiting for device configuration for device {}", deviceId);
            } else if (pipelineConfigured.contains(deviceId) && deviceConfigured.contains(deviceId)) {
                log.debug("Waiting for driver configuration for device {}", deviceId);
            } else if (driverConfigured.contains(deviceId)) {
                log.debug("Only driver configuration for device {}", deviceId);
            } else if (deviceConfigured.contains(deviceId)) {
                log.debug("Only device configuration for device {}", deviceId);
            }
        }
        return false;
    } finally {
        lock.unlock();
    }
}
#method_after
private boolean isDeviceConfigComplete(NetworkConfigEvent event, DeviceId deviceId) {
    // ensure all configuration needed is present
    if (event.configClass().equals(GeneralProviderDeviceConfig.class)) {
        // If we want to connect a p4runtime device with no pipeline
        if (event.config().isPresent()) {
            deviceConfigured.add(deviceId);
            final boolean isNotPipelineConfigurable = Collections.disjoint(ImmutableSet.copyOf(event.config().get().node().fieldNames()), PIPELINE_CONFIGURABLE_PROTOCOLS);
            if (isNotPipelineConfigurable) {
                // Skip waiting for a pipeline if we can't support it.
                pipelineConfigured.add(deviceId);
            }
        }
    } else if (event.configClass().equals(BasicDeviceConfig.class)) {
        if (event.config().isPresent() && event.config().get().node().has(DRIVER)) {
            driverConfigured.add(deviceId);
        }
    } else if (event.configClass().equals(PiPipeconfConfig.class)) {
        if (event.config().isPresent() && event.config().get().node().has(PiPipeconfConfig.PIPIPECONFID)) {
            pipelineConfigured.add(deviceId);
        }
    }
    if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId) && pipelineConfigured.contains(deviceId)) {
        return true;
    } else {
        if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
            log.debug("Waiting for pipeline configuration for device {}", deviceId);
        } else if (pipelineConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
            log.debug("Waiting for device configuration for device {}", deviceId);
        } else if (pipelineConfigured.contains(deviceId) && deviceConfigured.contains(deviceId)) {
            log.debug("Waiting for driver configuration for device {}", deviceId);
        } else if (driverConfigured.contains(deviceId)) {
            log.debug("Only driver configuration for device {}", deviceId);
        } else if (deviceConfigured.contains(deviceId)) {
            log.debug("Only device configuration for device {}", deviceId);
        }
    }
    return false;
}
#end_block

#method_before
private void handleChannelClosed(DeviceId deviceId) {
    log.info("Disconnecting device {}, due to channel closed event", deviceId);
    doAsyncDisconnect(deviceId);
}
#method_after
private void handleChannelClosed(DeviceId deviceId) {
    log.info("Disconnecting device {}, due to channel closed event", deviceId);
    triggerDisconnect(deviceId);
}
#end_block

#method_before
private void handleMastershipResponse(DeviceId deviceId, MastershipRole response) {
    // Notify core about response.
    if (!requestedRoles.containsKey(deviceId)) {
        return;
    }
    providerService.receivedRoleReply(deviceId, requestedRoles.get(deviceId), response);
    // If not master, cancel polling tasks, otherwise start them.
    if (!response.equals(MastershipRole.MASTER)) {
        cancelStatsPolling(deviceId);
    } else if (response.equals(MastershipRole.MASTER)) {
        startStatsPolling(deviceId, false);
    }
}
#method_after
private void handleMastershipResponse(DeviceId deviceId, MastershipRole response) {
    // Notify core about response.
    if (!requestedRoles.containsKey(deviceId)) {
        return;
    }
    providerService.receivedRoleReply(deviceId, requestedRoles.get(deviceId), response);
    if (response.equals(MastershipRole.MASTER)) {
        startStatsPolling(deviceId, false);
    } else {
        cancelStatsPolling(deviceId);
    }
}
#end_block

#method_before
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    MastershipService mastershipService = getHandler().get(MastershipService.class);
    checkNotNull(deviceId, MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to remove controllers from this device", deviceId, mastershipService.getMasterFor(deviceId));
        return;
    }
    for (ControllerInfo ctrl : controllers) {
        log.info("Remove controller with {}:{}:{}", ctrl.type(), ctrl.ip().toString(), ctrl.port());
        String remCtrlUrl = CONTROLLERS_CONF_URL + "/" + ctrl.ip().toString();
        /**
         * Remove this controller.
         */
        int response = getController().delete(deviceId, remCtrlUrl, null, JSON);
        if (!checkStatusCode(response)) {
            log.error("Failed to remove controller {}:{}:{} from device {}", ctrl.type(), ctrl.ip().toString(), ctrl.port(), deviceId);
        }
    }
    return;
}
#method_after
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    MastershipService mastershipService = getHandler().get(MastershipService.class);
    checkNotNull(deviceId, MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to remove controllers from this device", deviceId, mastershipService.getMasterFor(deviceId));
        return;
    }
    for (ControllerInfo ctrl : controllers) {
        log.info("Remove controller with {}:{}:{}", ctrl.type(), ctrl.ip().toString(), ctrl.port());
        String remCtrlUrl = CONTROLLERS_CONF_URL + "/" + ctrl.ip().toString();
        // Remove this controller
        int response = getController().delete(deviceId, remCtrlUrl, null, JSON);
        if (!checkStatusCode(response)) {
            log.error("Failed to remove controller {}:{}:{} from device {}", ctrl.type(), ctrl.ip().toString(), ctrl.port(), deviceId);
        }
    }
    return;
}
#end_block

#method_before
private boolean completeFuture(CompletableFuture<Boolean> completableFuture, String topic, String action) {
    try {
        if (completableFuture.get()) {
            return true;
        } else {
            log.warn("Unable to {} {}", action, topic);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while performing {} {}: {}", action, topic, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
private boolean completeFuture(CompletableFuture<Boolean> completableFuture, String topic, String action) {
    return getFutureWithDeadline(completableFuture, format("performing %s %s", action, topic), false);
}
#end_block

#method_before
private Stream<Group> streamGroupsFromDevice(PiActionProfileId actProfId) {
    try {
        // Read PI groups and return original PD one.
        return client.dumpGroups(actProfId, pipeconf).get().stream().map(this::forgeGroupEntry).filter(Objects::nonNull);
    } catch (ExecutionException | InterruptedException e) {
        log.error("Exception while dumping groups from action profile '{}' on {}: {}", actProfId.id(), deviceId, e);
        return Stream.empty();
    }
}
#method_after
private Stream<Group> streamGroupsFromDevice(PiActionProfileId actProfId) {
    // Read PI groups and return original PD one.
    Collection<PiActionGroup> groups = getFutureWithDeadline(client.dumpGroups(actProfId, pipeconf), "dumping groups", Collections.emptyList());
    return groups.stream().map(this::forgeGroupEntry).filter(Objects::nonNull);
}
#end_block

#method_before
@Override
public Optional<DeviceSystemStats> getDeviceSystemStats() {
    Optional<DeviceCpuStats> cpuStats = getCpuUsage();
    Optional<DeviceMemoryStats> memoryStats = getMemoryUsage();
    if (cpuStats.isPresent() && memoryStats.isPresent()) {
        DeviceSystemStats systemStats = new DeviceSystemStats();
        systemStats.setCpuStats(cpuStats.get());
        systemStats.setMemoryStats(memoryStats.get());
        return Optional.of(systemStats);
    } else {
        return Optional.empty();
    }
}
#method_after
@Override
public Optional<DeviceSystemStats> getDeviceSystemStats() {
    Optional<DeviceCpuStats> cpuStats = getCpuUsage();
    Optional<DeviceMemoryStats> memoryStats = getMemoryUsage();
    if (cpuStats.isPresent() && memoryStats.isPresent()) {
        DeviceSystemStats systemStats = new DeviceSystemStats(memoryStats.get(), cpuStats.get());
        return Optional.of(systemStats);
    } else {
        return Optional.empty();
    }
}
#end_block

#method_before
public Optional<DeviceCpuStats> getDeviceCpuUsage() {
    Optional<Object> deviceCpuDataObject = ovsdbClientService.getFirstRow(SWINVENTORY_DBNAME, OvsdbTable.CPUMEMORYDATA);
    if (!deviceCpuDataObject.isPresent()) {
        log.debug("Could not find {} column in {} table", DEVICE_CPU, CPU_MEMORY_DATA);
        return Optional.empty();
    }
    CpuMemoryData deviceCpuData = (CpuMemoryData) deviceCpuDataObject.get();
    log.info("GOT CpuMemoryData as {} ", deviceCpuData);
    float freeCpuStat = deviceCpuData.getFreeCpuStats();
    DeviceCpuStats deviceCpuStats = new DeviceCpuStats();
    deviceCpuStats.setUsed(100.0f - freeCpuStat);
    return Optional.of(deviceCpuStats);
}
#method_after
public Optional<DeviceCpuStats> getDeviceCpuUsage() {
    Optional<Object> deviceCpuDataObject = ovsdbClientService.getFirstRow(SWINVENTORY_DBNAME, OvsdbTable.CPUMEMORYDATA);
    if (!deviceCpuDataObject.isPresent()) {
        log.debug("Could not find {} column in {} table", DEVICE_CPU, CPU_MEMORY_DATA);
        return Optional.empty();
    }
    CpuMemoryData deviceCpuData = (CpuMemoryData) deviceCpuDataObject.get();
    log.debug("GOT CpuMemoryData as {} ", deviceCpuData);
    float freeCpuStat = deviceCpuData.getFreeCpuStats();
    DeviceCpuStats deviceCpuStats = new DeviceCpuStats();
    deviceCpuStats.setUsed(100.0f - freeCpuStat);
    return Optional.of(deviceCpuStats);
}
#end_block

#method_before
private OvsdbQueue getOvsdbQueue(Row row) {
    DatabaseSchema dbSchema = getDatabaseSchema(DATABASENAME);
    Queue queue = (Queue) TableGenerator.getTable(dbSchema, row, OvsdbTable.QUEUE);
    if (queue == null) {
        return null;
    }
    OvsdbSet dscpOvsdbSet = ((OvsdbSet) queue.getDscpColumn().data());
    @SuppressWarnings("unchecked")
    Set<String> dscpSet = dscpOvsdbSet.set();
    Long dscp = null;
    if (dscpSet != null && !dscpSet.isEmpty()) {
        dscp = Long.valueOf((String) dscpSet.toArray()[0]);
    }
    Map<String, String> otherConfigs;
    Map<String, String> externalIds;
    otherConfigs = ((OvsdbMap) queue.getOtherConfigColumn().data()).map();
    externalIds = ((OvsdbMap) queue.getExternalIdsColumn().data()).map();
    return OvsdbQueue.builder().dscp(dscp).otherConfigs(otherConfigs).externalIds(externalIds).build();
}
#method_after
private OvsdbQueue getOvsdbQueue(Row row) {
    DatabaseSchema dbSchema = getDatabaseSchema(DATABASENAME);
    Queue queue = (Queue) TableGenerator.getTable(dbSchema, row, OvsdbTable.QUEUE);
    if (queue == null) {
        return null;
    }
    OvsdbSet dscpOvsdbSet = ((OvsdbSet) queue.getDscpColumn().data());
    Set dscpSet = dscpOvsdbSet.set();
    Long dscp = null;
    if (dscpSet != null && !dscpSet.isEmpty()) {
        dscp = Long.valueOf(dscpSet.toArray()[0].toString());
    }
    Map<String, String> otherConfigs;
    Map<String, String> externalIds;
    otherConfigs = ((OvsdbMap) queue.getOtherConfigColumn().data()).map();
    externalIds = ((OvsdbMap) queue.getExternalIdsColumn().data()).map();
    return OvsdbQueue.builder().dscp(dscp).otherConfigs(otherConfigs).externalIds(externalIds).build();
}
#end_block

#method_before
private DHCP buildDhcpReply(DHCP request, byte msgType, Ip4Address yourIp, Subnet osSubnet) {
    Ip4Address gatewayIp = clusterService.getLocalNode().ip().getIp4Address();
    int subnetPrefixLen = IpPrefix.valueOf(osSubnet.getCidr()).prefixLength();
    DHCP dhcpReply = new DHCP();
    dhcpReply.setOpCode(DHCP.OPCODE_REPLY);
    dhcpReply.setHardwareType(DHCP.HWTYPE_ETHERNET);
    dhcpReply.setHardwareAddressLength((byte) 6);
    dhcpReply.setTransactionId(request.getTransactionId());
    dhcpReply.setFlags(request.getFlags());
    dhcpReply.setYourIPAddress(yourIp.toInt());
    dhcpReply.setServerIPAddress(gatewayIp.toInt());
    dhcpReply.setClientHardwareAddress(request.getClientHardwareAddress());
    List<DhcpOption> options = Lists.newArrayList();
    // message type
    DhcpOption option = new DhcpOption();
    option.setCode(OptionCode_MessageType.getValue());
    option.setLength((byte) 1);
    byte[] optionData = { msgType };
    option.setData(optionData);
    options.add(option);
    // server identifier
    option = new DhcpOption();
    option.setCode(OptionCode_DHCPServerIp.getValue());
    option.setLength((byte) 4);
    option.setData(gatewayIp.toOctets());
    options.add(option);
    // lease time
    option = new DhcpOption();
    option.setCode(OptionCode_LeaseTime.getValue());
    option.setLength((byte) 4);
    option.setData(DHCP_DATA_LEASE_INFINITE);
    options.add(option);
    // subnet mask
    Ip4Address subnetMask = Ip4Address.makeMaskPrefix(subnetPrefixLen);
    option = new DhcpOption();
    option.setCode(OptionCode_SubnetMask.getValue());
    option.setLength((byte) 4);
    option.setData(subnetMask.toOctets());
    options.add(option);
    // broadcast address
    Ip4Address broadcast = Ip4Address.makeMaskedAddress(yourIp, subnetPrefixLen);
    option = new DhcpOption();
    option.setCode(OptionCode_BroadcastAddress.getValue());
    option.setLength((byte) 4);
    option.setData(broadcast.toOctets());
    options.add(option);
    // domain server
    option = new DhcpOption();
    option.setCode(OptionCode_DomainServer.getValue());
    option.setLength((byte) 4);
    option.setData(DEFAULT_DNS.toOctets());
    options.add(option);
    option = new DhcpOption();
    option.setCode(DHCP_OPTION_MTU);
    option.setLength((byte) 2);
    option.setData(ByteBuffer.allocate(2).putShort((short) dhcpDataMtu).array());
    options.add(option);
    // classless static route
    if (!osSubnet.getHostRoutes().isEmpty()) {
        option = new DhcpOption();
        option.setCode(OptionCode_Classless_Static_Route.getValue());
        int hostRoutesSize = hostRoutesSize(ImmutableList.copyOf(osSubnet.getHostRoutes()));
        log.trace("hostRouteSize: {}", hostRoutesSize);
        option.setLength((byte) hostRoutesSize);
        ByteBuffer hostRouteByteBuf = ByteBuffer.allocate(hostRoutesSize);
        osSubnet.getHostRoutes().forEach(h -> {
            log.debug("processing host route information: {}", h.toString());
            IpPrefix ipPrefix = IpPrefix.valueOf(h.getDestination());
            hostRouteByteBuf.put(bytesDestinationDescriptor(ipPrefix));
            hostRouteByteBuf.put(Ip4Address.valueOf(h.getNexthop()).toOctets());
        });
        option.setData(hostRouteByteBuf.array());
        options.add(option);
    }
    // router address
    option = new DhcpOption();
    option.setCode(OptionCode_RouterAddress.getValue());
    option.setLength((byte) 4);
    option.setData(Ip4Address.valueOf(osSubnet.getGateway()).toOctets());
    options.add(option);
    // end option
    option = new DhcpOption();
    option.setCode(OptionCode_END.getValue());
    option.setLength((byte) 1);
    options.add(option);
    dhcpReply.setOptions(options);
    return dhcpReply;
}
#method_after
private DHCP buildDhcpReply(DHCP request, byte msgType, Ip4Address yourIp, Subnet osSubnet) {
    Ip4Address gatewayIp = clusterService.getLocalNode().ip().getIp4Address();
    int subnetPrefixLen = IpPrefix.valueOf(osSubnet.getCidr()).prefixLength();
    DHCP dhcpReply = new DHCP();
    dhcpReply.setOpCode(DHCP.OPCODE_REPLY);
    dhcpReply.setHardwareType(DHCP.HWTYPE_ETHERNET);
    dhcpReply.setHardwareAddressLength((byte) 6);
    dhcpReply.setTransactionId(request.getTransactionId());
    dhcpReply.setFlags(request.getFlags());
    dhcpReply.setYourIPAddress(yourIp.toInt());
    dhcpReply.setServerIPAddress(gatewayIp.toInt());
    dhcpReply.setClientHardwareAddress(request.getClientHardwareAddress());
    List<DhcpOption> options = Lists.newArrayList();
    // message type
    DhcpOption option = new DhcpOption();
    option.setCode(OptionCode_MessageType.getValue());
    option.setLength((byte) 1);
    byte[] optionData = { msgType };
    option.setData(optionData);
    options.add(option);
    // server identifier
    option = new DhcpOption();
    option.setCode(OptionCode_DHCPServerIp.getValue());
    option.setLength((byte) 4);
    option.setData(gatewayIp.toOctets());
    options.add(option);
    // lease time
    option = new DhcpOption();
    option.setCode(OptionCode_LeaseTime.getValue());
    option.setLength((byte) 4);
    option.setData(DHCP_DATA_LEASE_INFINITE);
    options.add(option);
    // subnet mask
    Ip4Address subnetMask = Ip4Address.makeMaskPrefix(subnetPrefixLen);
    option = new DhcpOption();
    option.setCode(OptionCode_SubnetMask.getValue());
    option.setLength((byte) 4);
    option.setData(subnetMask.toOctets());
    options.add(option);
    // broadcast address
    Ip4Address broadcast = Ip4Address.makeMaskedAddress(yourIp, subnetPrefixLen);
    option = new DhcpOption();
    option.setCode(OptionCode_BroadcastAddress.getValue());
    option.setLength((byte) 4);
    option.setData(broadcast.toOctets());
    options.add(option);
    // domain server
    option = new DhcpOption();
    option.setCode(OptionCode_DomainServer.getValue());
    option.setLength((byte) 4);
    option.setData(DEFAULT_DNS.toOctets());
    options.add(option);
    option = new DhcpOption();
    option.setCode(DHCP_OPTION_MTU);
    option.setLength((byte) 2);
    option.setData(ByteBuffer.allocate(2).putShort((short) dhcpDataMtu).array());
    options.add(option);
    // classless static route
    if (!osSubnet.getHostRoutes().isEmpty()) {
        option = new DhcpOption();
        option.setCode(OptionCode_Classless_Static_Route.getValue());
        int hostRoutesSize = hostRoutesSize(ImmutableList.copyOf(osSubnet.getHostRoutes()));
        if (hostRoutesSize == 0) {
            throw new IllegalArgumentException("Illegal CIDR hostRoutesSize value!");
        }
        log.trace("hostRouteSize: {}", hostRoutesSize);
        option.setLength((byte) hostRoutesSize);
        ByteBuffer hostRouteByteBuf = ByteBuffer.allocate(hostRoutesSize);
        osSubnet.getHostRoutes().forEach(h -> {
            log.debug("processing host route information: {}", h.toString());
            IpPrefix ipPrefix = IpPrefix.valueOf(h.getDestination());
            hostRouteByteBuf.put(bytesDestinationDescriptor(ipPrefix));
            hostRouteByteBuf.put(Ip4Address.valueOf(h.getNexthop()).toOctets());
        });
        option.setData(hostRouteByteBuf.array());
        options.add(option);
    }
    // router address
    option = new DhcpOption();
    option.setCode(OptionCode_RouterAddress.getValue());
    option.setLength((byte) 4);
    option.setData(Ip4Address.valueOf(osSubnet.getGateway()).toOctets());
    options.add(option);
    // end option
    option = new DhcpOption();
    option.setCode(OptionCode_END.getValue());
    option.setLength((byte) 1);
    options.add(option);
    dhcpReply.setOptions(options);
    return dhcpReply;
}
#end_block

#method_before
private int hostRoutesSize(List<HostRoute> hostRoutes) {
    int size = 0;
    int preFixLen;
    for (HostRoute h : hostRoutes) {
        preFixLen = IpPrefix.valueOf(h.getDestination()).prefixLength();
        if (preFixLen <= 8) {
            size = size + 2 + 4;
        } else if (preFixLen <= 16) {
            size = size + 3 + 4;
        } else if (preFixLen <= 24) {
            size = size + 4 + 4;
        } else {
            size = size + 5 + 4;
        }
    }
    return size;
}
#method_after
private int hostRoutesSize(List<HostRoute> hostRoutes) {
    int size = 0;
    int preFixLen;
    for (HostRoute h : hostRoutes) {
        preFixLen = IpPrefix.valueOf(h.getDestination()).prefixLength();
        if (Math.max(V4_CIDR_LOWER_BOUND, preFixLen) == V4_CIDR_LOWER_BOUND || Math.min(preFixLen, V4_CIDR_UPPER_BOUND) == V4_CIDR_UPPER_BOUND) {
            throw new IllegalArgumentException("Illegal CIDR length value!");
        }
        for (int i = 1; i <= V4_BYTE_SIZE; i++) {
            if (preFixLen == Math.min(preFixLen, i * OCTET_BIT_LENGTH)) {
                size = size + i + 1 + PADDING_SIZE;
                break;
            }
        }
    }
    return size;
}
#end_block

#method_before
private byte[] bytesDestinationDescriptor(IpPrefix ipPrefix) {
    ByteBuffer byteBuffer;
    int prefixLen = ipPrefix.prefixLength();
    // retrieve ipPrefix to the destination descriptor format
    // ex) 10.1.1.0/24 -> [10,1,1,0]
    String[] ipPrefixString = ipPrefix.getIp4Prefix().toString().split("/")[0].split("\\.");
    if (prefixLen <= 8) {
        byteBuffer = ByteBuffer.allocate(2);
        byteBuffer.put((byte) prefixLen);
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[0]));
    } else if (prefixLen <= 16) {
        byteBuffer = ByteBuffer.allocate(3);
        byteBuffer.put((byte) prefixLen);
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[0]));
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[1]));
    } else if (prefixLen <= 24) {
        byteBuffer = ByteBuffer.allocate(4);
        byteBuffer.put((byte) prefixLen);
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[0]));
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[1]));
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[2]));
    } else {
        byteBuffer = ByteBuffer.allocate(5);
        byteBuffer.put((byte) prefixLen);
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[0]));
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[1]));
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[2]));
        byteBuffer.put((byte) Integer.parseInt(ipPrefixString[3]));
    }
    return byteBuffer.array();
}
#method_after
private byte[] bytesDestinationDescriptor(IpPrefix ipPrefix) {
    ByteBuffer byteBuffer;
    int prefixLen = ipPrefix.prefixLength();
    // retrieve ipPrefix to the destination descriptor format
    // ex) 10.1.1.0/24 -> [10,1,1,0]
    String[] ipPrefixString = ipPrefix.getIp4Prefix().toString().split("/")[0].split("\\.");
    // ex) 10.229.0.128/25 -> 25.10.229.0.128
    for (int i = 1; i <= V4_BYTE_SIZE; i++) {
        if (prefixLen == Math.min(prefixLen, i * OCTET_BIT_LENGTH)) {
            byteBuffer = ByteBuffer.allocate(i + 1);
            byteBuffer.put((byte) prefixLen);
            for (int j = 0; j < i; j++) {
                byteBuffer.put((byte) Integer.parseInt(ipPrefixString[j]));
            }
            return byteBuffer.array();
        }
    }
    return null;
}
#end_block

#method_before
@Test
public void testVersionCompare() {
    assertThat(VersionUtil.versionCompare("1.2.3", null), lessThan(0));
    assertThat(VersionUtil.versionCompare(null, "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.x", "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3", "1.2.y"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3", "1.2.3"), is(0));
    assertThat(VersionUtil.versionCompare("2.2.3", "1.2.3"), greaterThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3", "2.2.3"), lessThan(0));
}
#method_after
@Test
public void testVersionCompare() {
    assertThat(VersionUtil.versionCompare("1.2.3", null), lessThan(0));
    assertThat(VersionUtil.versionCompare(null, "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.x", "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3", "1.2.y"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1", "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2", "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3.4", "1.2.3"), lessThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3", "1.2.3"), is(0));
    assertThat(VersionUtil.versionCompare("2.2.3", "1.2.3"), greaterThan(0));
    assertThat(VersionUtil.versionCompare("1.2.3", "2.2.3"), lessThan(0));
}
#end_block

#method_before
public static int versionCompare(String fromVersion, String toVersion) {
    if (fromVersion == null || toVersion == null) {
        return -1;
    }
    String[] fromArr = fromVersion.split("\\.");
    String[] toArr = toVersion.split("\\.");
    if (fromArr.length < 3 || toArr.length < 3) {
        return -1;
    }
    try {
        int fromFirst = Integer.parseInt(fromArr[0]);
        int fromMiddle = Integer.parseInt(fromArr[1]);
        int fromEnd = Integer.parseInt(fromArr[2]);
        int toFirst = Integer.parseInt(toArr[0]);
        int toMiddle = Integer.parseInt(toArr[1]);
        int toEnd = Integer.parseInt(toArr[2]);
        if (fromFirst - toFirst != 0) {
            return fromFirst - toFirst;
        } else if (fromMiddle - toMiddle != 0) {
            return fromMiddle - toMiddle;
        } else {
            return fromEnd - toEnd;
        }
    } catch (NumberFormatException nfe) {
        return -1;
    }
}
#method_after
public static int versionCompare(String fromVersion, String toVersion) {
    if (fromVersion == null || toVersion == null) {
        return -1;
    }
    String[] fromArr = fromVersion.split("\\.");
    String[] toArr = toVersion.split("\\.");
    if (fromArr.length != 3 || toArr.length != 3) {
        return -1;
    }
    try {
        int fromFirst = Integer.parseInt(fromArr[0]);
        int fromMiddle = Integer.parseInt(fromArr[1]);
        int fromEnd = Integer.parseInt(fromArr[2]);
        int toFirst = Integer.parseInt(toArr[0]);
        int toMiddle = Integer.parseInt(toArr[1]);
        int toEnd = Integer.parseInt(toArr[2]);
        if (fromFirst - toFirst != 0) {
            return fromFirst - toFirst;
        } else if (fromMiddle - toMiddle != 0) {
            return fromMiddle - toMiddle;
        } else {
            return fromEnd - toEnd;
        }
    } catch (NumberFormatException nfe) {
        return -1;
    }
}
#end_block

#method_before
public void processStaticRoutes() {
    log.info("processStaticRoutes function is called");
    for (Channel ch : allChannels) {
        processStaticRoutes(ch);
    }
}
#method_after
public void processStaticRoutes() {
    log.debug("processStaticRoutes function is called");
    for (Channel ch : allChannels) {
        processStaticRoutes(ch);
    }
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.FIBER_SWITCH, DEFAULT_MANUFACTURER, DEFAULT_DESCRIPTION_DATA, DEFAULT_DESCRIPTION_DATA, DEFAULT_DESCRIPTION_DATA, new ChassisId());
    }
    String hardwareVersion = DEFAULT_DESCRIPTION_DATA;
    try {
        hardwareVersion = hardwareVersion();
    } catch (IOException e) {
        log.error("Error reading hardware version for device {} exception {}", deviceId, e);
    }
    String softwareVersion = DEFAULT_DESCRIPTION_DATA;
    try {
        softwareVersion = softwareVersion();
    } catch (IOException e) {
        log.error("Error reading software version for device {} exception {}", deviceId, e);
    }
    String serialNumber = DEFAULT_DESCRIPTION_DATA;
    try {
        serialNumber = serialNumber();
    } catch (IOException e) {
        log.error("Error reading serial number for device {} exception {}", deviceId, e);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.FIBER_SWITCH, DEFAULT_MANUFACTURER, hardwareVersion, softwareVersion, serialNumber, device.chassisId(), (SparseAnnotations) device.annotations());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.FIBER_SWITCH, DEFAULT_MANUFACTURER, DEFAULT_DESCRIPTION_DATA, DEFAULT_DESCRIPTION_DATA, DEFAULT_DESCRIPTION_DATA, new ChassisId());
    }
    String hardwareVersion = DEFAULT_DESCRIPTION_DATA;
    try {
        hardwareVersion = hardwareVersion();
    } catch (IOException e) {
        log.error("Error reading hardware version for device {} exception ", deviceId, e);
    }
    String softwareVersion = DEFAULT_DESCRIPTION_DATA;
    try {
        softwareVersion = softwareVersion();
    } catch (IOException e) {
        log.error("Error reading software version for device {} exception {}", deviceId, e);
    }
    String serialNumber = DEFAULT_DESCRIPTION_DATA;
    try {
        serialNumber = serialNumber();
    } catch (IOException e) {
        log.error("Error reading serial number for device {} exception {}", deviceId, e);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.FIBER_SWITCH, DEFAULT_MANUFACTURER, hardwareVersion, softwareVersion, serialNumber, device.chassisId(), (SparseAnnotations) device.annotations());
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    List<PortDescription> ports = Lists.newLinkedList();
    List<TableEvent> events;
    DeviceId deviceId = handler().data().deviceId();
    try {
        OID[] columnOIDs = { new OID(PORT_CURRENT_STATE_OID) };
        events = getTable(handler(), columnOIDs);
    } catch (IOException e) {
        log.error("Error reading ports table for device {} exception {}", deviceId, e);
        return ports;
    }
    if (events == null) {
        log.error("Error reading ports table for device {}", deviceId);
        return ports;
    }
    for (TableEvent event : events) {
        if (event == null) {
            log.error("Error reading event for device {}", deviceId);
            continue;
        }
        VariableBinding[] columns = event.getColumns();
        if (columns == null) {
            log.error("Error reading columns for device {}", deviceId);
            continue;
        }
        VariableBinding portColumn = columns[0];
        if (portColumn == null) {
            continue;
        }
        int port = event.getIndex().last();
        boolean enabled = (portColumn.getVariable().toInt() == 1);
        PortNumber portNumber = PortNumber.portNumber(port);
        DefaultAnnotations annotations = DefaultAnnotations.builder().build();
        PortDescription p = omsPortDescription(portNumber, enabled, Spectrum.O_BAND_MIN, Spectrum.L_BAND_MAX, Frequency.ofGHz((Spectrum.O_BAND_MIN.asGHz() - Spectrum.L_BAND_MAX.asGHz()) / POLATIS_NUM_OF_WAVELENGTHS), annotations);
        ports.add(p);
    }
    return ports;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    List<PortDescription> ports = Lists.newArrayList();
    List<TableEvent> events;
    DeviceId deviceId = handler().data().deviceId();
    try {
        OID[] columnOIDs = { new OID(PORT_CURRENT_STATE_OID) };
        events = getTable(handler(), columnOIDs);
    } catch (IOException e) {
        log.error("Error reading ports table for device {} exception {}", deviceId, e);
        return ports;
    }
    if (events == null) {
        log.error("Error reading ports table for device {}", deviceId);
        return ports;
    }
    for (TableEvent event : events) {
        if (event == null) {
            log.error("Error reading event for device {}", deviceId);
            continue;
        }
        VariableBinding[] columns = event.getColumns();
        if (columns == null) {
            log.error("Error reading columns for device {} event {}", deviceId, event);
            continue;
        }
        VariableBinding portColumn = columns[0];
        if (portColumn == null) {
            continue;
        }
        int port = event.getIndex().last();
        boolean enabled = (portColumn.getVariable().toInt() == 1);
        PortNumber portNumber = PortNumber.portNumber(port);
        DefaultAnnotations annotations = DefaultAnnotations.builder().build();
        double opticalBand = Spectrum.O_BAND_MIN.asGHz() - Spectrum.L_BAND_MAX.asGHz();
        Frequency opticalGrid = Frequency.ofGHz(opticalBand / POLATIS_NUM_OF_WAVELENGTHS);
        PortDescription p = omsPortDescription(portNumber, enabled, Spectrum.O_BAND_MIN, Spectrum.L_BAND_MAX, opticalGrid, annotations);
        ports.add(p);
    }
    return ports;
}
#end_block

#method_before
@Modified
private void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strActiveProving = Tools.get(properties, "activeProbing");
    boolean expectActiveProbing = Boolean.parseBoolean(strActiveProving);
    if (expectActiveProbing != activeProbing) {
        activeProbing = expectActiveProbing;
        log.info("{} active probing", activeProbing ? "Enabling" : "Disabling");
    }
    String strSingleHomedDown = Tools.get(properties, "singleHomedDown");
    boolean expectSingleHomedDown = Boolean.parseBoolean(strSingleHomedDown);
    if (expectSingleHomedDown != singleHomedDown) {
        singleHomedDown = expectSingleHomedDown;
        log.info("{} downing of single homed hosts for lost uplinks", singleHomedDown ? "Enabling" : "Disabling");
        if (singleHomedDown && linkHandler != null) {
            hostService.getHosts().forEach(host -> host.locations().forEach(loc -> {
                if (interfaceService.isConfigured(loc)) {
                    linkHandler.checkUplinksForHost(loc);
                }
            }));
        } else {
            log.warn("Disabling singleHomedDown does not re-enable already " + "downed ports for single-homed hosts");
        }
    }
}
#method_after
@Modified
private void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strActiveProbing = Tools.get(properties, "activeProbing");
    boolean expectActiveProbing = Boolean.parseBoolean(strActiveProbing);
    if (expectActiveProbing != activeProbing) {
        activeProbing = expectActiveProbing;
        log.info("{} active probing", activeProbing ? "Enabling" : "Disabling");
    }
    String strSingleHomedDown = Tools.get(properties, "singleHomedDown");
    boolean expectSingleHomedDown = Boolean.parseBoolean(strSingleHomedDown);
    if (expectSingleHomedDown != singleHomedDown) {
        singleHomedDown = expectSingleHomedDown;
        log.info("{} downing of single homed hosts for lost uplinks", singleHomedDown ? "Enabling" : "Disabling");
        if (singleHomedDown && linkHandler != null) {
            hostService.getHosts().forEach(host -> host.locations().forEach(loc -> {
                if (interfaceService.isConfigured(loc)) {
                    linkHandler.checkUplinksForHost(loc);
                }
            }));
        } else {
            log.warn("Disabling singleHomedDown does not re-enable already " + "downed ports for single-homed hosts");
        }
    }
    String strRespondToUnknownHosts = Tools.get(properties, "respondToUnknownHosts");
    boolean expectRespondToUnknownHosts = Boolean.parseBoolean(strRespondToUnknownHosts);
    if (expectRespondToUnknownHosts != respondToUnknownHosts) {
        respondToUnknownHosts = expectRespondToUnknownHosts;
        log.info("{} responding to ARPs/NDPs from unknown hosts", respondToUnknownHosts ? "Enabling" : "Disabling");
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    withdrawIntercepts();
    providerRegistry.unregister(this);
    packetService.removeProcessor(processor);
    deviceService.removeListener(deviceListener);
    deviceEventHandler.shutdown();
    probeEventHandler.shutdown();
    packetHandler.shutdown();
    providerService = null;
    registry.unregisterConfigFactory(hostLearningConfig);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    withdrawIntercepts();
    providerRegistry.unregister(this);
    packetService.removeProcessor(processor);
    deviceService.removeListener(deviceListener);
    deviceEventHandler.shutdown();
    probeEventHandler.shutdown();
    packetHandler.shutdown();
    providerService = null;
    registry.unregisterConfigFactory(hostLearningConfig);
    netcfgService.removeListener(cfgListener);
    log.info("Stopped");
}
#end_block

#method_before
private void processPacketInternal(PacketContext context) {
    if (context == null) {
        return;
    }
    Ethernet eth = context.inPacket().parsed();
    if (eth == null) {
        return;
    }
    MacAddress srcMac = eth.getSourceMAC();
    if (srcMac.isBroadcast() || srcMac.isMulticast()) {
        return;
    }
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    VlanId outerVlan = VlanId.vlanId(eth.getQinQVID());
    VlanId innerVlan = VlanId.NONE;
    EthType outerTpid = EthType.EtherType.UNKNOWN.ethType();
    // Set up values for double-tagged hosts
    if (outerVlan.toShort() != Ethernet.VLAN_UNTAGGED) {
        innerVlan = vlan;
        vlan = outerVlan;
        outerTpid = EthType.EtherType.lookup(eth.getQinQTPID()).ethType();
    }
    ConnectPoint heardOn = context.inPacket().receivedFrom();
    // If this arrived on control port, bail out.
    if (heardOn.port().isLogical()) {
        return;
    }
    // If this is not an edge port, bail out.
    Topology topology = topologyService.currentTopology();
    if (topologyService.isInfrastructure(topology, heardOn)) {
        return;
    }
    HostLocation hloc = new HostLocation(heardOn, System.currentTimeMillis());
    HostId hid = HostId.hostId(eth.getSourceMAC(), vlan);
    MacAddress destMac = eth.getDestinationMAC();
    // Ignore location probes
    if (multihomingEnabled && destMac.isOnos() && !MacAddress.NONE.equals(destMac)) {
        return;
    }
    HostLearningConfig cfg = netcfgService.getConfig(heardOn, HostLearningConfig.class);
    // if learning is disabled bail out.
    if ((cfg != null) && (!cfg.hostLearningEnabled())) {
        return;
    }
    // ARP: possible new hosts, update both location and IP
    if (eth.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arp = (ARP) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET, arp.getSenderProtocolAddress());
        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, ip);
    // IPv4: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV4) {
        // Update host location
        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, null);
        if (useDhcp) {
            DHCP dhcp = findDhcp(eth).orElse(null);
            // DHCP ACK: additionally update IP of DHCP client
            if (dhcp != null && dhcp.getPacketType().equals(DHCP.MsgType.DHCPACK)) {
                MacAddress hostMac = MacAddress.valueOf(dhcp.getClientHardwareAddress());
                VlanId hostVlan = VlanId.vlanId(eth.getVlanID());
                HostId hostId = HostId.hostId(hostMac, hostVlan);
                updateHostIp(hostId, IpAddress.valueOf(dhcp.getYourIPAddress()));
            }
        }
    // NeighborAdvertisement and NeighborSolicitation: possible
    // new hosts, update both location and IP.
    // 
    // IPv6: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6 = (IPv6) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET6, ipv6.getSourceAddress());
        // skip extension headers
        IPacket pkt = ipv6;
        while (pkt.getPayload() != null && pkt.getPayload() instanceof IExtensionHeader) {
            pkt = pkt.getPayload();
        }
        pkt = pkt.getPayload();
        // DHCPv6 protocol
        DHCP6 dhcp6 = findDhcp6(pkt).orElse(null);
        if (dhcp6 != null && useDhcp6) {
            createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, null);
            handleDhcp6(dhcp6, vlan);
            return;
        }
        if (pkt != null && pkt instanceof ICMP6) {
            // Neighbor Discovery Protocol
            pkt = pkt.getPayload();
            if (pkt != null) {
                // RouterSolicitation, RouterAdvertisement
                if (pkt instanceof RouterAdvertisement || pkt instanceof RouterSolicitation) {
                    return;
                }
                if (pkt instanceof NeighborSolicitation || pkt instanceof NeighborAdvertisement) {
                    // Duplicate Address Detection
                    if (ip.isZero()) {
                        return;
                    }
                    // NeighborSolicitation, NeighborAdvertisement
                    createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, ip);
                    // Also learn from the target address of NeighborAdvertisement
                    if (pkt instanceof NeighborAdvertisement) {
                        NeighborAdvertisement na = (NeighborAdvertisement) pkt;
                        Ip6Address targetAddr = Ip6Address.valueOf(na.getTargetAddress());
                        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, targetAddr);
                    }
                    return;
                }
            }
        }
        // multicast, exclude DHCPv6
        if (eth.isMulticast() && dhcp6 == null) {
            return;
        }
        // normal IPv6 packets
        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, null);
    }
}
#method_after
private void processPacketInternal(PacketContext context) {
    if (context == null) {
        return;
    }
    Ethernet eth = context.inPacket().parsed();
    if (eth == null) {
        return;
    }
    MacAddress srcMac = eth.getSourceMAC();
    if (srcMac.isBroadcast() || srcMac.isMulticast()) {
        return;
    }
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    VlanId outerVlan = VlanId.vlanId(eth.getQinQVID());
    VlanId innerVlan = VlanId.NONE;
    EthType outerTpid = EthType.EtherType.UNKNOWN.ethType();
    // Set up values for double-tagged hosts
    if (outerVlan.toShort() != Ethernet.VLAN_UNTAGGED) {
        innerVlan = vlan;
        vlan = outerVlan;
        outerTpid = EthType.EtherType.lookup(eth.getQinQTPID()).ethType();
    }
    ConnectPoint heardOn = context.inPacket().receivedFrom();
    // If this arrived on control port, bail out.
    if (heardOn.port().isLogical()) {
        return;
    }
    // If this is not an edge port, bail out.
    Topology topology = topologyService.currentTopology();
    if (topologyService.isInfrastructure(topology, heardOn)) {
        return;
    }
    HostLocation hloc = new HostLocation(heardOn, System.currentTimeMillis());
    HostId hid = HostId.hostId(eth.getSourceMAC(), vlan);
    MacAddress destMac = eth.getDestinationMAC();
    // Ignore location probes
    if (multihomingEnabled && destMac.isOnos() && !MacAddress.NONE.equals(destMac)) {
        return;
    }
    HostLearningConfig cfg = netcfgService.getConfig(heardOn, HostLearningConfig.class);
    // if learning is disabled bail out.
    if ((cfg != null) && (!cfg.hostLearningEnabled())) {
        log.debug("Learning disabled for {}, abort.", heardOn);
        return;
    }
    // ARP: possible new hosts, update both location and IP
    if (eth.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arp = (ARP) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET, arp.getSenderProtocolAddress());
        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, ip);
    // IPv4: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV4) {
        // Update host location
        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, null);
        if (useDhcp) {
            DHCP dhcp = findDhcp(eth).orElse(null);
            // DHCP ACK: additionally update IP of DHCP client
            if (dhcp != null && dhcp.getPacketType().equals(DHCP.MsgType.DHCPACK)) {
                MacAddress hostMac = MacAddress.valueOf(dhcp.getClientHardwareAddress());
                VlanId hostVlan = VlanId.vlanId(eth.getVlanID());
                HostId hostId = HostId.hostId(hostMac, hostVlan);
                updateHostIp(hostId, IpAddress.valueOf(dhcp.getYourIPAddress()));
            }
        }
    // NeighborAdvertisement and NeighborSolicitation: possible
    // new hosts, update both location and IP.
    // 
    // IPv6: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6 = (IPv6) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET6, ipv6.getSourceAddress());
        // skip extension headers
        IPacket pkt = ipv6;
        while (pkt.getPayload() != null && pkt.getPayload() instanceof IExtensionHeader) {
            pkt = pkt.getPayload();
        }
        pkt = pkt.getPayload();
        // DHCPv6 protocol
        DHCP6 dhcp6 = findDhcp6(pkt).orElse(null);
        if (dhcp6 != null && useDhcp6) {
            createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, null);
            handleDhcp6(dhcp6, vlan);
            return;
        }
        if (pkt != null && pkt instanceof ICMP6) {
            // Neighbor Discovery Protocol
            pkt = pkt.getPayload();
            if (pkt != null) {
                // RouterSolicitation, RouterAdvertisement
                if (pkt instanceof RouterAdvertisement || pkt instanceof RouterSolicitation) {
                    return;
                }
                if (pkt instanceof NeighborSolicitation || pkt instanceof NeighborAdvertisement) {
                    // Duplicate Address Detection
                    if (ip.isZero()) {
                        return;
                    }
                    // NeighborSolicitation, NeighborAdvertisement
                    createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, ip);
                    // Also learn from the target address of NeighborAdvertisement
                    if (pkt instanceof NeighborAdvertisement) {
                        NeighborAdvertisement na = (NeighborAdvertisement) pkt;
                        Ip6Address targetAddr = Ip6Address.valueOf(na.getTargetAddress());
                        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, targetAddr);
                    }
                    return;
                }
            }
        }
        // multicast, exclude DHCPv6
        if (eth.isMulticast() && dhcp6 == null) {
            return;
        }
        // normal IPv6 packets
        createOrUpdateHost(hid, srcMac, vlan, innerVlan, outerTpid, hloc, null);
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            log.trace("HostLearningConfig event of type  {}", event.type());
            // if learning enabled do nothing
            HostLearningConfig learningConfig = (HostLearningConfig) event.config().get();
            if (learningConfig.hostLearningEnabled()) {
                return;
            }
            // if learning disabled and if host not statically configure
            // vanish them or host is statically configured but does not
            // contain this connect point, remove the host
            ConnectPoint connectPoint = learningConfig.subject();
            Set<Host> connectedHosts = hostService.getConnectedHosts(connectPoint);
            for (Host host : connectedHosts) {
                BasicHostConfig hostConfig = netcfgService.getConfig(host.id(), BasicHostConfig.class);
                if ((hostConfig == null) || (!hostConfig.locations().contains(connectPoint))) {
                    providerService.hostVanished(host.id());
                }
            }
            break;
        case CONFIG_REMOVED:
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            log.debug("HostLearningConfig event of type  {}", event.type());
            // if learning enabled do nothing
            HostLearningConfig learningConfig = (HostLearningConfig) event.config().get();
            if (learningConfig.hostLearningEnabled()) {
                return;
            }
            // if host learning is disable remove this location from existing, learnt hosts
            ConnectPoint connectPoint = learningConfig.subject();
            Set<Host> connectedHosts = hostService.getConnectedHosts(connectPoint);
            for (Host host : connectedHosts) {
                BasicHostConfig hostConfig = netcfgService.getConfig(host.id(), BasicHostConfig.class);
                if ((hostConfig == null) || (!hostConfig.locations().contains(connectPoint))) {
                    // timestamp shoud not matter for comparing HostLocation and ConnectPoint
                    providerService.removeLocationFromHost(host.id(), new HostLocation(connectPoint, 1));
                }
            }
            break;
        case CONFIG_REMOVED:
        default:
            break;
    }
}
#end_block

#method_before
@Override
public boolean isValid() {
    return isBoolean(LEARNING, FieldPresence.MANDATORY);
}
#method_after
@Override
public boolean isValid() {
    return isBoolean(ENABLED, FieldPresence.MANDATORY);
}
#end_block

#method_before
public Boolean hostLearningEnabled() {
    return get(LEARNING, true);
}
#method_after
public Boolean hostLearningEnabled() {
    return get(ENABLED, true);
}
#end_block

#method_before
@Override
public List<ControllerInfo> getControllers() {
    log.debug("Arista get Controllers");
    List<ControllerInfo> controllers = new ArrayList<>();
    Optional<JsonNode> res = AristaUtils.getWithJson(handler(), SHOW_CONTROLLER_CMD);
    if (res == null) {
        return controllers;
    }
    JsonNode controllerInfo = res.get().findValue("controllersInfo");
    Iterator<JsonNode> controlleriter = controllerInfo.iterator();
    while (controlleriter.hasNext()) {
        JsonNode temp1 = controlleriter.next();
        if (temp1.has("controllerAddr")) {
            JsonNode controllerAddr = temp1.get("controllerAddr");
            if (controllerAddr.has("ip") && controllerAddr.has("port")) {
                String ip = controllerAddr.get("ip").asText();
                int port = controllerAddr.get("port").asInt();
                ControllerInfo info = new ControllerInfo(IpAddress.valueOf(ip), port, "tcp");
                controllers.add(info);
                log.debug("Controller Information {}", info.target());
            }
        }
    }
    return ImmutableList.copyOf(controllers);
}
#method_after
@Override
public List<ControllerInfo> getControllers() {
    log.debug("Arista get Controllers");
    List<ControllerInfo> controllers = new ArrayList<>();
    Optional<JsonNode> res = AristaUtils.retrieveCommandResult(handler(), SHOW_CONTROLLER_CMD);
    if (res == null) {
        return controllers;
    }
    JsonNode controllerInfo = res.get().findValue("controllersInfo");
    Iterator<JsonNode> controlleriter = controllerInfo.iterator();
    while (controlleriter.hasNext()) {
        JsonNode temp1 = controlleriter.next();
        if (temp1.has(CONTROLLER_ADDR)) {
            JsonNode controllerAddr = temp1.get(CONTROLLER_ADDR);
            if (controllerAddr.has(CONTROLLER_IP) && controllerAddr.has(CONTROLLER_PORT)) {
                String ip = controllerAddr.get(CONTROLLER_IP).asText();
                int port = controllerAddr.get(CONTROLLER_PORT).asInt();
                ControllerInfo info = new ControllerInfo(IpAddress.valueOf(ip), port, PROTOCOL_TCP);
                controllers.add(info);
                log.debug("Controller Information {}", info.target());
            }
        }
    }
    return ImmutableList.copyOf(controllers);
}
#end_block

#method_before
@Override
public void setControllers(List<ControllerInfo> controllers) {
    log.debug("Arista set Controllers");
    List<String> cmds = new ArrayList<>();
    cmds.add(CONFIGURE_TERMINAL);
    cmds.add(OPENFLOW_CMD);
    controllers.stream().limit(8).forEach(c -> cmds.add(String.format(SET_CONTROLLER_CMD, c.ip().toString(), c.port())));
    cmds.add(NO_SHUTDOWN_CMD);
    cmds.add(COPY_RUNNING_CONFIG);
    AristaUtils.retrieveCommandResult(handler(), cmds);
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    log.debug("Arista set Controllers");
    List<String> cmds = new ArrayList<>();
    cmds.add(CONFIGURE_TERMINAL);
    cmds.add(OPENFLOW_CMD);
    // The Arista switch supports up to 8 multi-controllers.
    controllers.stream().limit(MAX_CONTROLLERS).forEach(c -> cmds.add(String.format(SET_CONTROLLER_CMD, c.ip().toString(), c.port())));
    if (controllers.size() > 8) {
        log.warn(" {} Arista Switch maximun 8 controllers, not adding {} excessive ones", handler().data().deviceId(), controllers.size() - 8);
    }
    cmds.add(NO_SHUTDOWN_CMD);
    cmds.add(COPY_RUNNING_CONFIG);
    AristaUtils.retrieveCommandResult(handler(), cmds);
}
#end_block

#method_before
public static PiPipelineModel parse(URL p4InfoUrl) throws P4InfoParserException {
    final P4Info p4info;
    try {
        p4info = getP4InfoMessage(p4InfoUrl);
    } catch (IOException e) {
        throw new P4InfoParserException("Unable to parse protobuf " + p4InfoUrl.toString(), e);
    }
    // Start by parsing and mapping instances to to their integer P4Info IDs.
    // Convenient to build the table model at the end.
    // Counters.
    final Map<Integer, PiCounterModel> counterMap = Maps.newHashMap();
    counterMap.putAll(parseCounters(p4info));
    counterMap.putAll(parseDirectCounters(p4info));
    // Meters.
    final Map<Integer, PiMeterModel> meterMap = Maps.newHashMap();
    meterMap.putAll(parseMeters(p4info));
    meterMap.putAll(parseDirectMeters(p4info));
    // Registers.
    final Map<Integer, PiRegisterModel> registerMap = Maps.newHashMap();
    registerMap.putAll(parseRegisters(p4info));
    // Action profiles.
    final Map<Integer, PiActionProfileModel> actProfileMap = parseActionProfiles(p4info);
    // Actions.
    final Map<Integer, PiActionModel> actionMap = parseActions(p4info);
    // Controller packet metadatas.
    final Map<PiPacketOperationType, PiPacketOperationModel> pktOpMap = parseCtrlPktMetadatas(p4info);
    // Finally, parse tables.
    final ImmutableMap.Builder<PiTableId, PiTableModel> tableImmMapBuilder = ImmutableMap.builder();
    for (Table tableMsg : p4info.getTablesList()) {
        final PiTableId tableId = PiTableId.of(tableMsg.getPreamble().getName());
        // Parse match fields.
        final ImmutableMap.Builder<PiMatchFieldId, PiMatchFieldModel> tableFieldMapBuilder = ImmutableMap.builder();
        for (MatchField fieldMsg : tableMsg.getMatchFieldsList()) {
            final PiMatchFieldId fieldId = PiMatchFieldId.of(fieldMsg.getName());
            tableFieldMapBuilder.put(fieldId, new P4MatchFieldModel(fieldId, fieldMsg.getBitwidth(), mapMatchFieldType(fieldMsg.getMatchType())));
        }
        // Retrieve action models by inter IDs.
        final ImmutableMap.Builder<PiActionId, PiActionModel> tableActionMapBuilder = ImmutableMap.builder();
        tableMsg.getActionRefsList().stream().map(ActionRef::getId).map(actionMap::get).forEach(actionModel -> tableActionMapBuilder.put(actionModel.id(), actionModel));
        // Retrieve direct meters by integer IDs.
        final ImmutableMap.Builder<PiMeterId, PiMeterModel> tableMeterMapBuilder = ImmutableMap.builder();
        tableMsg.getDirectResourceIdsList().stream().map(meterMap::get).filter(Objects::nonNull).forEach(meterModel -> tableMeterMapBuilder.put(meterModel.id(), meterModel));
        // Retrieve direct counters by integer IDs.
        final ImmutableMap.Builder<PiCounterId, PiCounterModel> tableCounterMapBuilder = ImmutableMap.builder();
        tableMsg.getDirectResourceIdsList().stream().map(counterMap::get).filter(Objects::nonNull).forEach(counterModel -> tableCounterMapBuilder.put(counterModel.id(), counterModel));
        tableImmMapBuilder.put(tableId, new P4TableModel(PiTableId.of(tableMsg.getPreamble().getName()), tableMsg.getImplementationId() == 0 ? PiTableType.DIRECT : PiTableType.INDIRECT, actProfileMap.get(tableMsg.getImplementationId()), tableMsg.getSize(), tableCounterMapBuilder.build(), tableMeterMapBuilder.build(), tableMsg.getWithEntryTimeout(), tableFieldMapBuilder.build(), tableActionMapBuilder.build(), actionMap.get(tableMsg.getConstDefaultActionId()), tableMsg.getConstDefaultActionHasMutableParams()));
    }
    // Get a map with proper PI IDs for some of those maps we created at the beginning.
    ImmutableMap<PiCounterId, PiCounterModel> counterImmMap = ImmutableMap.copyOf(counterMap.values().stream().collect(Collectors.toMap(PiCounterModel::id, c -> c)));
    ImmutableMap<PiMeterId, PiMeterModel> meterImmMap = ImmutableMap.copyOf(meterMap.values().stream().collect(Collectors.toMap(PiMeterModel::id, m -> m)));
    ImmutableMap<PiRegisterId, PiRegisterModel> registerImmMap = ImmutableMap.copyOf(registerMap.values().stream().collect(Collectors.toMap(PiRegisterModel::id, m -> m)));
    ImmutableMap<PiActionProfileId, PiActionProfileModel> actProfileImmMap = ImmutableMap.copyOf(actProfileMap.values().stream().collect(Collectors.toMap(PiActionProfileModel::id, a -> a)));
    return new P4PipelineModel(tableImmMapBuilder.build(), counterImmMap, meterImmMap, registerImmMap, actProfileImmMap, ImmutableMap.copyOf(pktOpMap));
}
#method_after
public static PiPipelineModel parse(URL p4InfoUrl) throws P4InfoParserException {
    final P4Info p4info;
    try {
        p4info = getP4InfoMessage(p4InfoUrl);
    } catch (IOException e) {
        throw new P4InfoParserException("Unable to parse protobuf " + p4InfoUrl.toString(), e);
    }
    // Start by parsing and mapping instances to to their integer P4Info IDs.
    // Convenient to build the table model at the end.
    // Counters.
    final Map<Integer, PiCounterModel> counterMap = Maps.newHashMap();
    counterMap.putAll(parseCounters(p4info));
    counterMap.putAll(parseDirectCounters(p4info));
    // Meters.
    final Map<Integer, PiMeterModel> meterMap = Maps.newHashMap();
    meterMap.putAll(parseMeters(p4info));
    meterMap.putAll(parseDirectMeters(p4info));
    // Registers.
    final Map<Integer, PiRegisterModel> registerMap = Maps.newHashMap();
    registerMap.putAll(parseRegisters(p4info));
    // Action profiles.
    final Map<Integer, PiActionProfileModel> actProfileMap = parseActionProfiles(p4info);
    // Actions.
    final Map<Integer, PiActionModel> actionMap = parseActions(p4info);
    // Controller packet metadatas.
    final Map<PiPacketOperationType, PiPacketOperationModel> pktOpMap = parseCtrlPktMetadatas(p4info);
    // Finally, parse tables.
    final ImmutableMap.Builder<PiTableId, PiTableModel> tableImmMapBuilder = ImmutableMap.builder();
    for (Table tableMsg : p4info.getTablesList()) {
        final PiTableId tableId = PiTableId.of(tableMsg.getPreamble().getName());
        // Parse match fields.
        final ImmutableMap.Builder<PiMatchFieldId, PiMatchFieldModel> tableFieldMapBuilder = ImmutableMap.builder();
        for (MatchField fieldMsg : tableMsg.getMatchFieldsList()) {
            final PiMatchFieldId fieldId = PiMatchFieldId.of(fieldMsg.getName());
            tableFieldMapBuilder.put(fieldId, new P4MatchFieldModel(fieldId, fieldMsg.getBitwidth(), mapMatchFieldType(fieldMsg.getMatchType())));
        }
        // Retrieve action models by inter IDs.
        final ImmutableMap.Builder<PiActionId, PiActionModel> tableActionMapBuilder = ImmutableMap.builder();
        tableMsg.getActionRefsList().stream().map(ActionRef::getId).map(actionMap::get).forEach(actionModel -> tableActionMapBuilder.put(actionModel.id(), actionModel));
        // Retrieve direct meters by integer IDs.
        final ImmutableMap.Builder<PiMeterId, PiMeterModel> tableMeterMapBuilder = ImmutableMap.builder();
        tableMsg.getDirectResourceIdsList().stream().map(meterMap::get).filter(Objects::nonNull).forEach(meterModel -> tableMeterMapBuilder.put(meterModel.id(), meterModel));
        // Retrieve direct counters by integer IDs.
        final ImmutableMap.Builder<PiCounterId, PiCounterModel> tableCounterMapBuilder = ImmutableMap.builder();
        tableMsg.getDirectResourceIdsList().stream().map(counterMap::get).filter(Objects::nonNull).forEach(counterModel -> tableCounterMapBuilder.put(counterModel.id(), counterModel));
        tableImmMapBuilder.put(tableId, new P4TableModel(PiTableId.of(tableMsg.getPreamble().getName()), tableMsg.getImplementationId() == 0 ? PiTableType.DIRECT : PiTableType.INDIRECT, actProfileMap.get(tableMsg.getImplementationId()), tableMsg.getSize(), tableCounterMapBuilder.build(), tableMeterMapBuilder.build(), tableMsg.getWithEntryTimeout(), tableFieldMapBuilder.build(), tableActionMapBuilder.build(), actionMap.get(tableMsg.getConstDefaultActionId()), tableMsg.getConstDefaultActionHasMutableParams()));
    }
    // Get a map with proper PI IDs for some of those maps we created at the beginning.
    ImmutableMap<PiCounterId, PiCounterModel> counterImmMap = ImmutableMap.copyOf(counterMap.values().stream().collect(Collectors.toMap(PiCounterModel::id, c -> c)));
    ImmutableMap<PiMeterId, PiMeterModel> meterImmMap = ImmutableMap.copyOf(meterMap.values().stream().collect(Collectors.toMap(PiMeterModel::id, m -> m)));
    ImmutableMap<PiRegisterId, PiRegisterModel> registerImmMap = ImmutableMap.copyOf(registerMap.values().stream().collect(Collectors.toMap(PiRegisterModel::id, r -> r)));
    ImmutableMap<PiActionProfileId, PiActionProfileModel> actProfileImmMap = ImmutableMap.copyOf(actProfileMap.values().stream().collect(Collectors.toMap(PiActionProfileModel::id, a -> a)));
    return new P4PipelineModel(tableImmMapBuilder.build(), counterImmMap, meterImmMap, registerImmMap, actProfileImmMap, ImmutableMap.copyOf(pktOpMap));
}
#end_block

#method_before
@Override
public ObjectNode encode(DefaultL2TunnelDescription pseudowire, CodecContext context) {
    final ObjectNode result = context.mapper().createObjectNode().put(PW_ID, pseudowire.l2Tunnel().tunnelId());
    result.put(CP1, pseudowire.l2TunnelPolicy().cP1().toString());
    result.put(CP2, pseudowire.l2TunnelPolicy().cP2().toString());
    result.put(CP1_INNER_TAG, pseudowire.l2TunnelPolicy().cP1InnerTag().toString());
    result.put(CP1_OUTER_TAG, pseudowire.l2TunnelPolicy().cP1OuterTag().toString());
    result.put(CP2_INNER_TAG, pseudowire.l2TunnelPolicy().cP2InnerTag().toString());
    result.put(CP2_OUTER_TAG, pseudowire.l2TunnelPolicy().cP2OuterTag().toString());
    result.put(MODE, pseudowire.l2Tunnel().pwMode() == L2Mode.RAW ? "RAW" : "TAGGED");
    result.put(SERVICE_DELIM_TAG, pseudowire.l2Tunnel().sdTag().toString());
    result.put(PW_LABEL, pseudowire.l2Tunnel().pwLabel().toString());
    return result;
}
#method_after
@Override
public ObjectNode encode(DefaultL2TunnelDescription pseudowire, CodecContext context) {
    final ObjectNode result = context.mapper().createObjectNode().put(PW_ID, pseudowire.l2Tunnel().tunnelId());
    result.put(CP1, pseudowire.l2TunnelPolicy().cP1().toString());
    result.put(CP2, pseudowire.l2TunnelPolicy().cP2().toString());
    result.put(CP1_INNER_TAG, pseudowire.l2TunnelPolicy().cP1InnerTag().toString());
    result.put(CP1_OUTER_TAG, pseudowire.l2TunnelPolicy().cP1OuterTag().toString());
    result.put(CP2_INNER_TAG, pseudowire.l2TunnelPolicy().cP2InnerTag().toString());
    result.put(CP2_OUTER_TAG, pseudowire.l2TunnelPolicy().cP2OuterTag().toString());
    result.put(SERVICE_DELIM_TAG, pseudowire.l2Tunnel().sdTag().toString());
    result.put(MODE, pseudowire.l2Tunnel().pwMode() == L2Mode.RAW ? "RAW" : "TAGGED");
    result.put(PW_LABEL, pseudowire.l2Tunnel().pwLabel().toString());
    return result;
}
#end_block

#method_before
public Pair<List<JsonNode>, List<L2TunnelDescription>> decodePws(ArrayNode json, CodecContext context) {
    List<L2TunnelDescription> decodedPws = new ArrayList<>();
    List<JsonNode> notDecodedPws = new ArrayList<>();
    for (JsonNode node : json) {
        DefaultL2TunnelDescription l2Description;
        l2Description = decode((ObjectNode) node, context);
        if (l2Description == null) {
            notDecodedPws.add(node);
        } else {
            decodedPws.add(l2Description);
        }
    }
    return Pair.of(notDecodedPws, decodedPws);
}
#method_after
public Pair<List<Pair<JsonNode, String>>, List<L2TunnelDescription>> decodePws(ArrayNode json, CodecContext context) {
    List<L2TunnelDescription> decodedPws = new ArrayList<>();
    List<Pair<JsonNode, String>> notDecodedPws = new ArrayList<>();
    for (JsonNode node : json) {
        DefaultL2TunnelDescription l2Description;
        try {
            l2Description = decode((ObjectNode) node, context);
            decodedPws.add(l2Description);
        } catch (IllegalArgumentException e) {
            // the reason why we could not decode this pseudowire is encoded in the
            // exception, we need to store it now
            notDecodedPws.add(Pair.of(node, e.getMessage()));
        }
    }
    return Pair.of(notDecodedPws, decodedPws);
}
#end_block

#method_before
@Override
public DefaultL2TunnelDescription decode(ObjectNode json, CodecContext context) {
    String tempString;
    Integer id;
    try {
        id = parsePwId(json.path(PW_ID).asText());
    } catch (IllegalArgumentException e) {
        log.error("Pseudowire id should be an integer!");
        return null;
    }
    ConnectPoint cP1, cP2;
    try {
        tempString = json.path(CP1).asText();
        cP1 = ConnectPoint.deviceConnectPoint(tempString);
    } catch (Exception e) {
        log.error("cP1 is not a valid connect point!");
        return null;
    }
    try {
        tempString = json.path(CP2).asText();
        cP2 = ConnectPoint.deviceConnectPoint(tempString);
    } catch (Exception e) {
        log.error("cP2 is not a valid connect point!");
        return null;
    }
    VlanId cP1InnerVlan, cP1OuterVlan, cP2InnerVlan, cP2OuterVlan;
    try {
        cP1InnerVlan = parseVlan(json.path(CP1_INNER_TAG).asText());
        cP1OuterVlan = parseVlan(json.path(CP1_OUTER_TAG).asText());
        cP2InnerVlan = parseVlan(json.path(CP2_INNER_TAG).asText());
        cP2OuterVlan = parseVlan(json.path(CP2_OUTER_TAG).asText());
    } catch (IllegalArgumentException e) {
        log.error("One or more vlan for cp1 or cp2 is malformed, it shouldbe an integer / Any / None / *");
        return null;
    }
    L2Mode mode;
    try {
        mode = parseMode(json.path(MODE).asText());
    } catch (IllegalArgumentException e) {
        log.error("Mode should be RAW or TAGGED!");
        return null;
    }
    VlanId sdTag;
    try {
        sdTag = parseVlan(json.path(SERVICE_DELIM_TAG).asText());
    } catch (IllegalArgumentException e) {
        log.error("SD tag is malformed, it should be an integer / Any / None / *");
        return null;
    }
    MplsLabel pwLabel;
    try {
        pwLabel = parsePWLabel(json.path(PW_LABEL).asText());
    } catch (IllegalArgumentException e) {
        log.error("PW label is malformed, should be an integer!");
        return null;
    }
    DefaultL2Tunnel l2Tunnel;
    DefaultL2TunnelPolicy l2Policy;
    l2Tunnel = new DefaultL2Tunnel(mode, sdTag, id, pwLabel);
    l2Policy = new DefaultL2TunnelPolicy(id, cP1, cP1InnerVlan, cP1OuterVlan, cP2, cP2InnerVlan, cP2OuterVlan);
    return new DefaultL2TunnelDescription(l2Tunnel, l2Policy);
}
#method_after
@Override
public DefaultL2TunnelDescription decode(ObjectNode json, CodecContext context) {
    Integer id = parsePwId(json.path(PW_ID).asText());
    ConnectPoint cP1, cP2;
    cP1 = ConnectPoint.deviceConnectPoint(json.path(CP1).asText());
    cP2 = ConnectPoint.deviceConnectPoint(json.path(CP2).asText());
    VlanId cP1InnerVlan, cP1OuterVlan, cP2InnerVlan, cP2OuterVlan, sdTag;
    cP1InnerVlan = parseVlan(json.path(CP1_INNER_TAG).asText());
    cP1OuterVlan = parseVlan(json.path(CP1_OUTER_TAG).asText());
    cP2InnerVlan = parseVlan(json.path(CP2_INNER_TAG).asText());
    cP2OuterVlan = parseVlan(json.path(CP2_OUTER_TAG).asText());
    sdTag = parseVlan(json.path(SERVICE_DELIM_TAG).asText());
    L2Mode mode = parseMode(json.path(MODE).asText());
    MplsLabel pwLabel = parsePWLabel(json.path(PW_LABEL).asText());
    DefaultL2Tunnel l2Tunnel = new DefaultL2Tunnel(mode, sdTag, id, pwLabel);
    DefaultL2TunnelPolicy l2Policy = new DefaultL2TunnelPolicy(id, cP1, cP1InnerVlan, cP1OuterVlan, cP2, cP2InnerVlan, cP2OuterVlan);
    return new DefaultL2TunnelDescription(l2Tunnel, l2Policy);
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<Pair<DefaultL2TunnelDescription, String>> failed = new ArrayList<>();
    List<Pair<JsonNode, String>> undecoded = new ArrayList<>();
    DefaultL2TunnelDescription pseudowire = PSEUDOWIRE_CODEC.decode(pseudowireJson, this);
    if (pseudowire == null) {
        // could not decode pseudowire add it to un-decoded list.
        undecoded.add(Pair.of(pseudowireJson, "Invalid pseudowire arguments."));
    } else {
        // pseudowire decoded, try to instantiate it, if we fail
        // add it to failed list
        long tunId = pseudowire.l2Tunnel().tunnelId();
        log.debug("Creating pseudowire {} from rest api!", tunId);
        L2TunnelHandler.Result res = srService.addPseudowire(pseudowire);
        if (res != L2TunnelHandler.Result.SUCCESS) {
            log.error("Could not create pseudowire {} : {}", pseudowire.l2Tunnel().tunnelId(), res.getSpecificError());
            failed.add(Pair.of(pseudowire, res.getSpecificError()));
        }
    }
    if ((failed.size() == 0) && (undecoded.size() == 0)) {
        // pseudowire instantiated correctly
        return Response.ok().build();
    } else {
        // pseudowire failed to instantiate, return the reason
        PseudowireCodec pwCodec = new PseudowireCodec();
        ObjectNode result = pwCodec.encodeFailedPseudowires(failed, undecoded, this);
        return Response.serverError().entity(result).build();
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<Pair<DefaultL2TunnelDescription, String>> failed = new ArrayList<>();
    List<Pair<JsonNode, String>> undecoded = new ArrayList<>();
    DefaultL2TunnelDescription pseudowire;
    try {
        pseudowire = PSEUDOWIRE_CODEC.decode(pseudowireJson, this);
        // pseudowire decoded, try to instantiate it, if we fail add it to failed list
        long tunId = pseudowire.l2Tunnel().tunnelId();
        log.debug("Creating pseudowire {} from rest api!", tunId);
        L2TunnelHandler.Result res = srService.addPseudowire(pseudowire);
        if (res != L2TunnelHandler.Result.SUCCESS) {
            log.error("Could not create pseudowire {} : {}", pseudowire.l2Tunnel().tunnelId(), res.getSpecificError());
            failed.add(Pair.of(pseudowire, res.getSpecificError()));
        }
    } catch (IllegalArgumentException e) {
        log.debug("Pseudowire could not be decoded : {}", e.getMessage());
        undecoded.add(Pair.of(pseudowireJson, e.getMessage()));
    }
    if ((failed.size() == 0) && (undecoded.size() == 0)) {
        // pseudowire instantiated correctly
        return Response.ok().build();
    } else {
        // failed to decode or instantiate pseudowire, return the reason
        PseudowireCodec pwCodec = new PseudowireCodec();
        ObjectNode result = pwCodec.encodeFailedPseudowires(failed, undecoded, this);
        return Response.serverError().entity(result).build();
    }
}
#end_block

#method_before
@POST
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Pair<List<JsonNode>, List<L2TunnelDescription>> pseudowires;
    try {
        ArrayNode pseudowiresArray = nullIsIllegal((ArrayNode) pseudowireJson.get(PWS), PWS_KEY_ERROR);
        // get two lists, first one contains pseudowires that we were unable to decode
        // that have faulty arguments, second one contains pseudowires that we decoded
        // succesfully
        pseudowires = PSEUDOWIRE_CODEC.decodePws(pseudowiresArray, this);
    } catch (ItemNotFoundException e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Creating pseudowires {} from rest api!", pseudowires);
    List<Pair<DefaultL2TunnelDescription, String>> failed = new ArrayList<>();
    for (L2TunnelDescription pw : pseudowires.getRight()) {
        L2TunnelHandler.Result res = srService.addPseudowire(pw);
        if (res != L2TunnelHandler.Result.SUCCESS) {
            log.error("Could not create pseudowire {} : {}", pw.l2Tunnel().tunnelId(), res.getSpecificError());
            failed.add(Pair.of((DefaultL2TunnelDescription) pw, res.getSpecificError()));
        }
    }
    List<Pair<JsonNode, String>> undecodedPws = new ArrayList<>();
    for (JsonNode pwNode : pseudowires.getLeft()) {
        log.error("Psuedowire {} could not be decoded.", pwNode);
        undecodedPws.add(Pair.of(pwNode, "Invalid pseudowire arguments."));
    }
    if ((failed.size() == 0) && (undecodedPws.size() == 0)) {
        // all pseudowires were instantiated
        return Response.ok().build();
    } else {
        PseudowireCodec pwCodec = new PseudowireCodec();
        // some failed, need to report them to user
        ObjectNode result = pwCodec.encodeFailedPseudowires(failed, undecodedPws, this);
        return Response.serverError().entity(result).build();
    }
}
#method_after
@POST
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Pair<List<Pair<JsonNode, String>>, List<L2TunnelDescription>> pseudowires;
    try {
        ArrayNode pseudowiresArray = nullIsIllegal((ArrayNode) pseudowireJson.get(PWS), PWS_KEY_ERROR);
        // get two lists, first one contains pseudowires that we were unable to decode
        // that have faulty arguments, second one contains pseudowires that we decoded
        // succesfully
        pseudowires = PSEUDOWIRE_CODEC.decodePws(pseudowiresArray, this);
    } catch (ItemNotFoundException e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Creating pseudowires {} from rest api!", pseudowires);
    List<Pair<DefaultL2TunnelDescription, String>> failed = new ArrayList<>();
    for (L2TunnelDescription pw : pseudowires.getRight()) {
        L2TunnelHandler.Result res = srService.addPseudowire(pw);
        if (res != L2TunnelHandler.Result.SUCCESS) {
            log.error("Could not create pseudowire {} : {}", pw.l2Tunnel().tunnelId(), res.getSpecificError());
            failed.add(Pair.of((DefaultL2TunnelDescription) pw, res.getSpecificError()));
        }
    }
    List<Pair<JsonNode, String>> undecodedPws = pseudowires.getLeft();
    if ((failed.size() == 0) && (undecodedPws.size() == 0)) {
        // all pseudowires were decoded and instantiated succesfully
        return Response.ok().build();
    } else {
        PseudowireCodec pwCodec = new PseudowireCodec();
        // some failed, need to report them to user
        ObjectNode result = pwCodec.encodeFailedPseudowires(failed, undecodedPws, this);
        return Response.serverError().entity(result).build();
    }
}
#end_block

#method_before
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    L2Tunnel tun;
    L2TunnelPolicy policy;
    try {
        tun = new DefaultL2Tunnel(parseMode(mode), parseVlan(sDTag), parsePwId(pwId), parsePWLabel(pwLabel));
    } catch (Exception e) {
        print("Exception while parsing L2Tunnel : {}", e.getMessage());
        return;
    }
    try {
        policy = new DefaultL2TunnelPolicy(parsePwId(pwId), ConnectPoint.deviceConnectPoint(cP1), parseVlan(cP1InnerVlan), parseVlan(cP1OuterVlan), ConnectPoint.deviceConnectPoint(cP2), parseVlan(cP2InnerVlan), parseVlan(cP2OuterVlan));
    } catch (Exception e) {
        print("Exception while parsing L2TunnelPolicy : {}", e.getMessage());
        return;
    }
    L2TunnelDescription pw = new DefaultL2TunnelDescription(tun, policy);
    L2TunnelHandler.Result res = srService.addPseudowire(pw);
    switch(res) {
        case WRONG_PARAMETERS:
            print("Pseudowire could not be added , error in the parameters : \n\t%s", res.getSpecificError());
            break;
        case CONFIGURATION_ERROR:
            print("Pseudowire could not be added, configuration error : \n\t%s", res.getSpecificError());
            break;
        case PATH_NOT_FOUND:
            print("Pseudowire path not found : \n\t%s", res.getSpecificError());
            break;
        case INTERNAL_ERROR:
            print("Pseudowire could not be added, internal error : \n\t%s", res.getSpecificError());
            break;
        case SUCCESS:
            break;
        default:
            break;
    }
}
#method_after
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    L2Tunnel tun;
    L2TunnelPolicy policy;
    try {
        tun = new DefaultL2Tunnel(parseMode(mode), parseVlan(sDTag), parsePwId(pwId), parsePWLabel(pwLabel));
    } catch (IllegalArgumentException e) {
        log.error("Exception while parsing L2Tunnel : \n\t %s", e.getMessage());
        print("Exception while parsing L2Tunnel : \n\t %s", e.getMessage());
        return;
    }
    try {
        policy = new DefaultL2TunnelPolicy(parsePwId(pwId), ConnectPoint.deviceConnectPoint(cP1), parseVlan(cP1InnerVlan), parseVlan(cP1OuterVlan), ConnectPoint.deviceConnectPoint(cP2), parseVlan(cP2InnerVlan), parseVlan(cP2OuterVlan));
    } catch (IllegalArgumentException e) {
        log.error("Exception while parsing L2TunnelPolicy : \n\t %s", e.getMessage());
        print("Exception while parsing L2TunnelPolicy : \n\t %s", e.getMessage());
        return;
    }
    L2TunnelDescription pw = new DefaultL2TunnelDescription(tun, policy);
    L2TunnelHandler.Result res = srService.addPseudowire(pw);
    log.info("Deploying pseudowire {} via the command line.", pw);
    switch(res) {
        case WRONG_PARAMETERS:
            print("Pseudowire could not be added , error in the parameters : \n\t%s", res.getSpecificError());
            break;
        case CONFIGURATION_ERROR:
            print("Pseudowire could not be added, configuration error : \n\t%s", res.getSpecificError());
            break;
        case PATH_NOT_FOUND:
            print("Pseudowire path not found : \n\t%s", res.getSpecificError());
            break;
        case INTERNAL_ERROR:
            print("Pseudowire could not be added, internal error : \n\t%s", res.getSpecificError());
            break;
        case SUCCESS:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    // remove the pseudowire
    SegmentRoutingManager mngr = (SegmentRoutingManager) srService;
    int pwIntId;
    try {
        pwIntId = parsePwId(pwId);
    } catch (Exception e) {
        print("Exception while parsing pseudowire id : {}", e.getMessage());
        return;
    }
    L2TunnelHandler.Result res = mngr.removePseudowire(pwIntId);
    switch(res) {
        case WRONG_PARAMETERS:
            error("Pseudowire could not be removed , wrong parameters: \n\t %s\n", res.getSpecificError());
            break;
        case INTERNAL_ERROR:
            error("Pseudowire could not be removed, internal error : \n\t %s\n", res.getSpecificError());
            break;
        case SUCCESS:
            break;
        default:
            break;
    }
}
#method_after
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    // remove the pseudowire
    SegmentRoutingManager mngr = (SegmentRoutingManager) srService;
    int pwIntId;
    try {
        pwIntId = parsePwId(pwId);
    } catch (IllegalArgumentException e) {
        log.error("Exception while parsing pseudowire id : \n\t %s", e.getMessage());
        print("Exception while parsing pseudowire id : \n\t %s", e.getMessage());
        return;
    }
    log.info("Removing pseudowire {} from the command line.", pwIntId);
    L2TunnelHandler.Result res = mngr.removePseudowire(pwIntId);
    switch(res) {
        case WRONG_PARAMETERS:
            error("Pseudowire could not be removed , wrong parameters: \n\t %s\n", res.getSpecificError());
            break;
        case INTERNAL_ERROR:
            error("Pseudowire could not be removed, internal error : \n\t %s\n", res.getSpecificError());
            break;
        case SUCCESS:
            break;
        default:
            break;
    }
}
#end_block

#method_before
private Result manageIntermediateFiltering(L2TunnelDescription pw, boolean leafSpinePw) {
    // only leaf-spine-spine should need intermediate rules for now
    if (!leafSpinePw) {
        return Result.SUCCESS;
    }
    if (pw.l2Tunnel().pathUsed().size() != 2) {
        return Result.SUCCESS;
    }
    List<Link> path = pw.l2Tunnel().pathUsed();
    DeviceId intermediateSpineId = pw.l2Tunnel().pathUsed().get(0).dst().deviceId();
    L2Tunnel l2Tunnel = pw.l2Tunnel();
    log.info("Installing intermediate filtering rules for spine {} , for pseudowire {}", intermediateSpineId, pw.l2Tunnel().tunnelId());
    MacAddress dstMac;
    try {
        dstMac = srManager.deviceConfiguration().getDeviceMac(intermediateSpineId);
    } catch (Exception e) {
        log.info("Device not found in configuration, no programming of MAC address");
        dstMac = null;
    }
    PortNumber inPort;
    inPort = path.get(0).dst().port();
    log.debug("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    DefaultObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    inPort = path.get(1).src().port();
    log.debug("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    return Result.SUCCESS;
}
#method_after
private Result manageIntermediateFiltering(L2TunnelDescription pw, boolean leafSpinePw) {
    // only leaf-spine-spine should need intermediate rules for now
    if (!leafSpinePw || (pw.l2Tunnel().pathUsed().size() != 2)) {
        return Result.SUCCESS;
    }
    List<Link> path = pw.l2Tunnel().pathUsed();
    DeviceId intermediateSpineId = pw.l2Tunnel().pathUsed().get(0).dst().deviceId();
    L2Tunnel l2Tunnel = pw.l2Tunnel();
    log.debug("Installing intermediate filtering rules for spine {} , for pseudowire {}", intermediateSpineId, pw.l2Tunnel().tunnelId());
    MacAddress dstMac;
    try {
        dstMac = srManager.deviceConfiguration().getDeviceMac(intermediateSpineId);
    } catch (Exception e) {
        log.info("Device not found in configuration, no programming of MAC address");
        dstMac = null;
    }
    PortNumber inPort;
    inPort = path.get(0).dst().port();
    log.debug("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    DefaultObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    inPort = path.get(1).src().port();
    log.debug("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    return Result.SUCCESS;
}
#end_block

#method_before
private VlanId determineTransportVlan(boolean spinePw) {
    if (!spinePw) {
        log.info("Untagged transport with internal vlan {} for pseudowire!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    } else {
        for (short i = transportVlanUpper; i > transportVlanLower; i--) {
            VlanId vlanToUse = VlanId.vlanId(i);
            if (!vlanStore.contains(vlanToUse)) {
                vlanStore.add(vlanToUse);
                log.info("Transport vlan {} for pseudowire!", vlanToUse);
                return vlanToUse;
            }
        }
        log.info("No available transport vlan found, pseudowire traffic will be carried untagged " + "with internal vlan {}!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    }
}
#method_after
private VlanId determineTransportVlan(boolean spinePw) {
    if (!spinePw) {
        log.debug("Untagged transport with internal vlan {} for pseudowire!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    } else {
        for (short i = transportVlanUpper; i > transportVlanLower; i--) {
            VlanId vlanToUse = VlanId.vlanId(i);
            if (!vlanStore.contains(vlanToUse)) {
                vlanStore.add(vlanToUse);
                log.debug("Transport vlan {} for pseudowire!", vlanToUse);
                return vlanToUse;
            }
        }
        log.warn("No available transport vlan found, pseudowire traffic will be carried untagged " + "with internal vlan {}!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    }
}
#end_block

#method_before
private boolean isValidPath(List<Link> path, boolean leafSpinePw) {
    List<DeviceId> devices = getDevicesOnPath(path);
    if (devices.size() < 2) {
        log.error("Path size for pseudowire should be greater than 1!");
        return false;
    }
    try {
        if (leafSpinePw) {
            // can either be leaf-spine-spine or leaf-spine
            // first device is leaf, all other must be spines
            log.debug("Devices on path are {} for leaf to spine pseudowire", devices);
            // if first device is a leaf then all other must be spines
            if (srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                devices.remove(0);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            } else {
                // all other devices must be spines
                if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                    return false;
                }
                devices.remove(devices.size() - 1);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            }
        } else {
            // can either be leaf-leaf (paired leafs) / leaf-spine-leaf
            // or leaf-spine-spine-leaf
            log.debug("Devices on path are {} for leaf to leaf pseudowire", devices);
            // check first device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                return false;
            }
            // check last device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                return false;
            }
            // remove these devices, rest must all be spines
            devices.remove(0);
            devices.remove(devices.size() - 1);
            for (DeviceId devId : devices) {
                log.debug("Device {} should be a spine!", devId);
                if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                    return false;
                }
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.error("Device not found in configuration : {}", e);
        return false;
    }
    return true;
}
#method_after
private boolean isValidPath(List<Link> path, boolean leafSpinePw) {
    log.debug("Checking path validity for pseudowire.");
    List<DeviceId> devices = getDevicesOnPath(path);
    if (devices.size() < 2) {
        log.error("Path size for pseudowire should be greater than 1!");
        return false;
    }
    try {
        if (leafSpinePw) {
            // can either be leaf-spine-spine or leaf-spine
            // first device is leaf, all other must be spines
            log.debug("Devices on path are {} for leaf to spine pseudowire", devices);
            // if first device is a leaf then all other must be spines
            if (srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                devices.remove(0);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            } else {
                // all other devices must be spines
                if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                    return false;
                }
                devices.remove(devices.size() - 1);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            }
        } else {
            // can either be leaf-leaf (paired leafs) / leaf-spine-leaf
            // or leaf-spine-spine-leaf
            log.debug("Devices on path are {} for leaf to leaf pseudowire", devices);
            // check first device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                return false;
            }
            // check last device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                return false;
            }
            // remove these devices, rest must all be spines
            devices.remove(0);
            devices.remove(devices.size() - 1);
            for (DeviceId devId : devices) {
                log.debug("Device {} should be a spine!", devId);
                if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                    return false;
                }
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.error("Device not found in configuration : {}", e);
        return false;
    }
    return true;
}
#end_block

#method_before
public Result deployPseudowire(L2TunnelDescription pw) {
    try {
        // take the lock
        pwLock.lock();
        Result result;
        long l2TunnelId;
        log.debug("Pseudowire with {} deployment started, check log for any errors in this process!", pw.l2Tunnel().tunnelId());
        l2TunnelId = pw.l2Tunnel().tunnelId();
        // The tunnel id cannot be 0.
        if (l2TunnelId == 0) {
            log.warn("Tunnel id id must be > 0");
            return Result.WRONG_PARAMETERS.appendError("Tunnel id id must be > 0");
        }
        result = verifyGlobalValidity(pw);
        if (result != SUCCESS) {
            log.error("Global validity for pseudowire {} is wrong!", l2TunnelId);
            return result;
        }
        // leafSpinePw determines if this is a leaf-leaf
        // or leaf-spine pseudowire
        boolean leafSpinePw;
        ConnectPoint cp1 = pw.l2TunnelPolicy().cP1();
        ConnectPoint cp2 = pw.l2TunnelPolicy().cP2();
        try {
            // differentiate between leaf-leaf pseudowires and leaf-spine
            if (!srManager.deviceConfiguration().isEdgeDevice(cp1.deviceId()) && !srManager.deviceConfiguration().isEdgeDevice(cp2.deviceId())) {
                log.error("Can not deploy pseudowire from spine to spine!");
                return Result.WRONG_PARAMETERS.appendError("Can not deploy pseudowire from spine to spine!");
            } else if (srManager.deviceConfiguration().isEdgeDevice(cp1.deviceId()) && srManager.deviceConfiguration().isEdgeDevice(cp2.deviceId())) {
                leafSpinePw = false;
            } else {
                leafSpinePw = true;
            }
        } catch (DeviceConfigNotFoundException e) {
            log.error("Device for pseudowire connection points does not exist in the configuration");
            return Result.INTERNAL_ERROR.appendError("Device for pseudowire connection points does not exist in the configuration");
        }
        // reverse the policy in order for leaf switch to be at CP1
        // this will help us for re-using SRLinkWeigher for computing valid paths
        L2TunnelPolicy reversedPolicy = reverseL2TunnelPolicy(pw.l2TunnelPolicy());
        if (reversedPolicy == null) {
            log.error("Error in reversing policy, device configuration was not found!");
            return INTERNAL_ERROR.appendError("Device configuration not found when reversing the policy.");
        }
        pw.setL2TunnelPolicy(reversedPolicy);
        // get path here, need to use the same for fwd and rev direction
        List<Link> path = getPath(pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2());
        if (path == null) {
            log.error("Deploying process : No path between the connection points for pseudowire {}", l2TunnelId);
            return PATH_NOT_FOUND.appendError("No path between the connection points for pseudowire!");
        }
        Link fwdNextHop;
        Link revNextHop;
        if (!isValidPath(path, leafSpinePw)) {
            log.error("Deploying process : Path for pseudowire {} is not valid", l2TunnelId);
            return INTERNAL_ERROR.appendError("Internal error : path for pseudowire is not valid!");
        }
        // oneHope flag is used to determine if we need to
        // install transit mpls rules
        boolean oneHop = true;
        if (path.size() > 1) {
            oneHop = false;
        }
        fwdNextHop = path.get(0);
        revNextHop = reverseLink(path.get(path.size() - 1));
        pw.l2Tunnel().setPath(path);
        pw.l2Tunnel().setTransportVlan(determineTransportVlan(leafSpinePw));
        // next hops for next objectives
        log.info("Deploying process : Establishing forward direction for pseudowire {}", l2TunnelId);
        VlanId egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag());
        // We establish the tunnel.
        // result.nextId will be used in fwd
        result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, leafSpinePw, oneHop, egressVlan);
        if (result != SUCCESS) {
            log.info("Deploying process : Error in deploying pseudowire initiation for CP1");
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire initiation for CP1");
        }
        // We create the policy.
        result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), egressVlan, result.getNextId());
        if (result != SUCCESS) {
            log.info("Deploying process : Error in deploying pseudowire policy for CP1");
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire policy for CP1");
        }
        // We terminate the tunnel
        result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), egressVlan, FWD, leafSpinePw, oneHop);
        if (result != SUCCESS) {
            log.info("Deploying process : Error in deploying pseudowire termination for CP1");
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire termination for CP1");
        }
        log.info("Deploying process : Establishing reverse direction for pseudowire {}", l2TunnelId);
        egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag());
        // We establish the reverse tunnel.
        result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP1(), REV, revNextHop, leafSpinePw, oneHop, egressVlan);
        if (result != SUCCESS) {
            log.info("Deploying process : Error in deploying pseudowire initiation for CP2");
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire initiation for CP2");
        }
        result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), egressVlan, result.getNextId());
        if (result != SUCCESS) {
            log.info("Deploying process : Error in deploying policy for CP2");
            return Result.INTERNAL_ERROR.appendError("Deploying process : Error in deploying policy for CP2");
        }
        result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), egressVlan, REV, leafSpinePw, oneHop);
        if (result != SUCCESS) {
            log.info("Deploying process : Error in deploying pseudowire termination for CP2");
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire termination for CP2");
        }
        result = manageIntermediateFiltering(pw, leafSpinePw);
        if (result != SUCCESS) {
            log.info("Deploying process : Error in installing intermediate rules for tagged transport");
            return Result.INTERNAL_ERROR.appendError("Error in installing intermediate rules for tagged transport");
        }
        log.info("Deploying process : Updating relevant information for pseudowire {}", l2TunnelId);
        // Populate stores as the final step of the process
        l2TunnelStore.put(Long.toString(l2TunnelId), pw.l2Tunnel());
        l2PolicyStore.put(Long.toString(l2TunnelId), pw.l2TunnelPolicy());
        return Result.SUCCESS;
    } finally {
        // release the lock
        pwLock.unlock();
    }
}
#method_after
public Result deployPseudowire(L2TunnelDescription pw) {
    try {
        // take the lock
        pwLock.lock();
        Result result;
        long l2TunnelId;
        log.debug("Pseudowire with {} deployment started, check log for any errors in this process!", pw.l2Tunnel().tunnelId());
        l2TunnelId = pw.l2Tunnel().tunnelId();
        // The tunnel id cannot be 0.
        if (l2TunnelId == 0) {
            log.warn("Tunnel id id must be > 0 in {}", l2TunnelId);
            return Result.WRONG_PARAMETERS.appendError("Tunnel id id must be > 0");
        }
        result = verifyGlobalValidity(pw);
        if (result != SUCCESS) {
            log.error("Global validity for pseudowire {} is wrong!", l2TunnelId);
            return result;
        }
        // leafSpinePw determines if this is a leaf-leaf
        // or leaf-spine pseudowire
        boolean leafSpinePw;
        ConnectPoint cp1 = pw.l2TunnelPolicy().cP1();
        ConnectPoint cp2 = pw.l2TunnelPolicy().cP2();
        try {
            // differentiate between leaf-leaf pseudowires and leaf-spine
            if (!srManager.deviceConfiguration().isEdgeDevice(cp1.deviceId()) && !srManager.deviceConfiguration().isEdgeDevice(cp2.deviceId())) {
                log.error("Can not deploy pseudowire {} from spine to spine!", l2TunnelId);
                return Result.WRONG_PARAMETERS.appendError("Can not deploy pseudowire from spine to spine!");
            } else if (srManager.deviceConfiguration().isEdgeDevice(cp1.deviceId()) && srManager.deviceConfiguration().isEdgeDevice(cp2.deviceId())) {
                leafSpinePw = false;
            } else {
                leafSpinePw = true;
            }
        } catch (DeviceConfigNotFoundException e) {
            log.error("Device for pseudowire {} connection points does not exist in the configuration", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Device for pseudowire connection points does not exist in the configuration");
        }
        // reverse the policy in order for leaf switch to be at CP1
        // this will help us for re-using SRLinkWeigher for computing valid paths
        L2TunnelPolicy reversedPolicy = reverseL2TunnelPolicy(pw.l2TunnelPolicy());
        if (reversedPolicy == null) {
            log.error("Error in reversing policy, device configuration was not found for pseudowire {}.", l2TunnelId);
            return INTERNAL_ERROR.appendError("Device configuration not found when reversing the policy.");
        }
        pw.setL2TunnelPolicy(reversedPolicy);
        // get path here, need to use the same for fwd and rev direction
        List<Link> path = getPath(pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2());
        if (path == null) {
            log.error("Deploying process : No path between the connection points for pseudowire {}", l2TunnelId);
            return PATH_NOT_FOUND.appendError("No path between the connection points for pseudowire!");
        }
        Link fwdNextHop;
        Link revNextHop;
        if (!isValidPath(path, leafSpinePw)) {
            log.error("Deploying process : Path for pseudowire {} is not valid", l2TunnelId);
            return INTERNAL_ERROR.appendError("Internal error : path for pseudowire is not valid!");
        }
        // oneHope flag is used to determine if we need to
        // install transit mpls rules
        boolean oneHop = true;
        if (path.size() > 1) {
            oneHop = false;
        }
        fwdNextHop = path.get(0);
        revNextHop = reverseLink(path.get(path.size() - 1));
        pw.l2Tunnel().setPath(path);
        pw.l2Tunnel().setTransportVlan(determineTransportVlan(leafSpinePw));
        // next hops for next objectives
        log.info("Deploying process : Establishing forward direction for pseudowire {}", l2TunnelId);
        VlanId egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag());
        result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, leafSpinePw, oneHop, egressVlan);
        if (result != SUCCESS) {
            log.error("Deploying process : Error in deploying pseudowire {} initiation for CP1", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire initiation for CP1");
        }
        result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), egressVlan, result.getNextId());
        if (result != SUCCESS) {
            log.error("Deploying process : Error in deploying pseudowire {} policy for CP1", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire policy for CP1");
        }
        PortNumber termPort = pw.l2Tunnel().pathUsed().get(pw.l2Tunnel().pathUsed().size() - 1).dst().port();
        result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), egressVlan, FWD, leafSpinePw, oneHop, termPort);
        if (result != SUCCESS) {
            log.error("Deploying process : Error in deploying pseudowire {} termination for CP1", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire termination for CP1");
        }
        // We establish the reverse tunnel.
        log.info("Deploying process : Establishing reverse direction for pseudowire {}", l2TunnelId);
        egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag());
        result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP1(), REV, revNextHop, leafSpinePw, oneHop, egressVlan);
        if (result != SUCCESS) {
            log.error("Deploying process : Error in deploying pseudowire {} initiation for CP2", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire initiation for CP2");
        }
        result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), egressVlan, result.getNextId());
        if (result != SUCCESS) {
            log.error("Deploying process : Error in deploying policy {} for CP2", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Deploying process : Error in deploying policy for CP2");
        }
        termPort = pw.l2Tunnel().pathUsed().get(0).src().port();
        result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), egressVlan, REV, leafSpinePw, oneHop, termPort);
        if (result != SUCCESS) {
            log.error("Deploying process : Error in deploying pseudowire {} termination for CP2", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Error in deploying pseudowire termination for CP2");
        }
        result = manageIntermediateFiltering(pw, leafSpinePw);
        if (result != SUCCESS) {
            log.error("Deploying process : Error in installing intermediate rules for " + "tagged transport for pseudowire {}", l2TunnelId);
            return Result.INTERNAL_ERROR.appendError("Error in installing intermediate rules for tagged transport");
        }
        log.info("Deploying process : Updating relevant information for pseudowire {}", l2TunnelId);
        // Populate stores as the final step of the process
        l2TunnelStore.put(Long.toString(l2TunnelId), pw.l2Tunnel());
        l2PolicyStore.put(Long.toString(l2TunnelId), pw.l2TunnelPolicy());
        return Result.SUCCESS;
    } catch (StorageException.Timeout e) {
        log.error("Can not acquire distributed lock for pseudowire {}!", pw.l2Tunnel().tunnelId());
        return Result.INTERNAL_ERROR.appendError("Can not acquire distributed lock!");
    } finally {
        // release the lock
        pwLock.unlock();
    }
}
#end_block

#method_before
private Result tearDownConnectionPoints(long l2TunnelId, boolean tearDownFirst, boolean tearDownSecond, boolean pending) {
    Result res;
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    if (l2TunnelId == 0) {
        log.warn("Removal process : Tunnel id cannot be 0");
        return Result.WRONG_PARAMETERS.appendError("Pseudowire id can not be 0.");
    }
    res = checkIfPwExists(l2TunnelId, pending);
    if (res != Result.SUCCESS) {
        return res;
    }
    // remove and get the tunnel and the policy from the appropriate store
    // if null, return error.
    Versioned<L2Tunnel> l2TunnelVersioned = pending ? pendingL2TunnelStore.remove(Long.toString(l2TunnelId)) : l2TunnelStore.remove(Long.toString(l2TunnelId));
    Versioned<L2TunnelPolicy> l2TunnelPolicyVersioned = pending ? pendingL2PolicyStore.remove(Long.toString(l2TunnelId)) : l2PolicyStore.remove(Long.toString(l2TunnelId));
    if ((l2TunnelVersioned == null) || (l2TunnelPolicyVersioned == null)) {
        log.warn("Removal process : Policy and/or tunnel missing for tunnel id {}", l2TunnelId);
        return Result.INTERNAL_ERROR.appendError("Policy and/or tunnel missing for pseudowire!");
    }
    L2TunnelDescription pwToRemove = new DefaultL2TunnelDescription(l2TunnelVersioned.value(), l2TunnelPolicyVersioned.value());
    // remove the reserved transport vlan
    if (!pwToRemove.l2Tunnel().transportVlan().equals(UNTAGGED_TRANSPORT_VLAN)) {
        vlanStore.remove(pwToRemove.l2Tunnel().transportVlan());
    }
    if (pending) {
        // in pending state
        return Result.SUCCESS;
    }
    // remove flows/groups involving with this pseudowire
    if (tearDownFirst) {
        log.info("Removal process : Tearing down forward direction of pseudowire {}", l2TunnelId);
        VlanId egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag());
        deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
        fwdInitNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                // Finally we will tear down the pseudo wire.
                tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
            }
        });
        fwdTermNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP2(), null, FWD);
            }
        });
    }
    if (tearDownSecond) {
        log.info("Removal process : Tearing down reverse direction of pseudowire {}", l2TunnelId);
        VlanId egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag());
        // We do the same operations on the reverse side.
        deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
        revInitNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
            }
        });
        revTermNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP1(), null, REV);
            }
        });
    }
    return Result.SUCCESS;
}
#method_after
private Result tearDownConnectionPoints(long l2TunnelId, boolean tearDownFirst, boolean tearDownSecond, boolean pending) {
    Result res;
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    if (l2TunnelId == 0) {
        log.error("Removal process : Tunnel id cannot be 0");
        return Result.WRONG_PARAMETERS.appendError("Pseudowire id can not be 0.");
    }
    res = checkIfPwExists(l2TunnelId, pending);
    if (res != Result.SUCCESS) {
        return res;
    }
    // remove and get the tunnel and the policy from the appropriate store
    // if null, return error.
    Versioned<L2Tunnel> l2TunnelVersioned = pending ? pendingL2TunnelStore.remove(Long.toString(l2TunnelId)) : l2TunnelStore.remove(Long.toString(l2TunnelId));
    Versioned<L2TunnelPolicy> l2TunnelPolicyVersioned = pending ? pendingL2PolicyStore.remove(Long.toString(l2TunnelId)) : l2PolicyStore.remove(Long.toString(l2TunnelId));
    if ((l2TunnelVersioned == null) || (l2TunnelPolicyVersioned == null)) {
        log.warn("Removal process : Policy and/or tunnel missing for tunnel id {}", l2TunnelId);
        return Result.INTERNAL_ERROR.appendError("Policy and/or tunnel missing for pseudowire!");
    }
    L2TunnelDescription pwToRemove = new DefaultL2TunnelDescription(l2TunnelVersioned.value(), l2TunnelPolicyVersioned.value());
    // remove the reserved transport vlan
    if (!pwToRemove.l2Tunnel().transportVlan().equals(UNTAGGED_TRANSPORT_VLAN)) {
        vlanStore.remove(pwToRemove.l2Tunnel().transportVlan());
    }
    if (pending) {
        // in pending state
        return Result.SUCCESS;
    }
    // remove flows/groups involving with this pseudowire
    if (tearDownFirst) {
        log.info("Removal process : Tearing down forward direction of pseudowire {}", l2TunnelId);
        VlanId egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag());
        deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
        fwdInitNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                // Finally we will tear down the pseudo wire.
                tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
            }
        });
        fwdTermNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                PortNumber termPort = pwToRemove.l2Tunnel().pathUsed().get(pwToRemove.l2Tunnel().pathUsed().size() - 1).dst().port();
                tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP2(), null, FWD, termPort);
            }
        });
    }
    if (tearDownSecond) {
        log.info("Removal process : Tearing down reverse direction of pseudowire {}", l2TunnelId);
        VlanId egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag());
        // We do the same operations on the reverse side.
        deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
        revInitNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
            }
        });
        revTermNextFuture.thenAcceptAsync(status -> {
            if (status == null) {
                PortNumber termPort = pwToRemove.l2Tunnel().pathUsed().get(0).src().port();
                tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP1(), null, REV, termPort);
            }
        });
    }
    return Result.SUCCESS;
}
#end_block

#method_before
public Result tearDownPseudowire(long l2TunnelId) {
    try {
        // take the lock
        pwLock.lock();
        if (checkIfPwExists(l2TunnelId, true) == Result.SUCCESS) {
            return tearDownConnectionPoints(l2TunnelId, true, true, true);
        } else if (checkIfPwExists(l2TunnelId, false) == Result.SUCCESS) {
            return tearDownConnectionPoints(l2TunnelId, true, true, false);
        } else {
            return Result.WRONG_PARAMETERS.appendError("Pseudowire with " + l2TunnelId + " did not reside in any store!");
        }
    } finally {
        // release the lock
        pwLock.unlock();
    }
}
#method_after
public Result tearDownPseudowire(long l2TunnelId) {
    try {
        // take the lock
        pwLock.lock();
        if (checkIfPwExists(l2TunnelId, true) == Result.SUCCESS) {
            return tearDownConnectionPoints(l2TunnelId, true, true, true);
        } else if (checkIfPwExists(l2TunnelId, false) == Result.SUCCESS) {
            return tearDownConnectionPoints(l2TunnelId, true, true, false);
        } else {
            return Result.WRONG_PARAMETERS.appendError("Pseudowire with " + l2TunnelId + " did not reside in any store!");
        }
    } catch (StorageException.Timeout e) {
        log.error("Can not acquire distributed lock for pseudowire {}!", l2TunnelId);
        return Result.INTERNAL_ERROR.appendError("Can not acquire distributed lock!");
    } finally {
        // release the lock
        pwLock.unlock();
    }
}
#end_block

#method_before
private Result deployPolicy(long tunnelId, ConnectPoint ingress, VlanId ingressInner, VlanId ingressOuter, VlanId egressVlan, int nextId) {
    List<Objective> objectives = Lists.newArrayList();
    // We create the forwarding objective for supporting
    // the l2 tunnel.
    ForwardingObjective.Builder fwdBuilder = createInitFwdObjective(tunnelId, ingress.port(), nextId);
    // We create and add objective context.
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for tunnel {} populated", tunnelId), (objective, error) -> log.warn("Failed to populate fwdrObj " + "for tunnel {}", tunnelId, error));
    objectives.add(fwdBuilder.add(context));
    // We create the filtering objective to define the
    // permit traffic in the switch
    FilteringObjective.Builder filtBuilder = createFiltObjective(ingress.port(), ingressInner, ingressOuter);
    // We add the metadata.
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setTunnelId(tunnelId).setVlanId(egressVlan);
    filtBuilder.withMeta(treatment.build());
    // We create and add objective context.
    context = new DefaultObjectiveContext((objective) -> log.debug("FilterObj for tunnel {} populated", tunnelId), (objective, error) -> log.warn("Failed to populate filterObj for " + "tunnel {}", tunnelId, error));
    objectives.add(filtBuilder.add(context));
    for (Objective objective : objectives) {
        if (objective instanceof ForwardingObjective) {
            srManager.flowObjectiveService.forward(ingress.deviceId(), (ForwardingObjective) objective);
            log.debug("Creating new FwdObj for initiation NextObj with id={} for tunnel {}", nextId, tunnelId);
        } else {
            srManager.flowObjectiveService.filter(ingress.deviceId(), (FilteringObjective) objective);
            log.debug("Creating new FiltObj for tunnel {}", tunnelId);
        }
    }
    return SUCCESS;
}
#method_after
private Result deployPolicy(long tunnelId, ConnectPoint ingress, VlanId ingressInner, VlanId ingressOuter, VlanId egressVlan, int nextId) {
    log.debug("Starting deploying policy for pseudowire {}.", tunnelId);
    List<Objective> objectives = Lists.newArrayList();
    // We create the forwarding objective for supporting
    // the l2 tunnel.
    ForwardingObjective.Builder fwdBuilder = createInitFwdObjective(tunnelId, ingress.port(), nextId);
    // We create and add objective context.
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for tunnel {} populated", tunnelId), (objective, error) -> log.warn("Failed to populate fwdObj " + "for tunnel {} : {}", tunnelId, error));
    objectives.add(fwdBuilder.add(context));
    // We create the filtering objective to define the
    // permit traffic in the switch
    FilteringObjective.Builder filtBuilder = createFiltObjective(ingress.port(), ingressInner, ingressOuter);
    // We add the metadata.
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setTunnelId(tunnelId).setVlanId(egressVlan);
    filtBuilder.withMeta(treatment.build());
    // We create and add objective context.
    context = new DefaultObjectiveContext((objective) -> log.debug("FilterObj for tunnel {} populated", tunnelId), (objective, error) -> log.warn("Failed to populate filterObj for " + "tunnel {} : {}", tunnelId, error));
    objectives.add(filtBuilder.add(context));
    for (Objective objective : objectives) {
        if (objective instanceof ForwardingObjective) {
            srManager.flowObjectiveService.forward(ingress.deviceId(), (ForwardingObjective) objective);
            log.debug("Creating new FwdObj for initiation NextObj with id={} for tunnel {}", nextId, tunnelId);
        } else {
            srManager.flowObjectiveService.filter(ingress.deviceId(), (FilteringObjective) objective);
            log.debug("Creating new FiltObj for tunnel {}", tunnelId);
        }
    }
    return SUCCESS;
}
#end_block

#method_before
private Result deployPseudoWireInit(L2Tunnel l2Tunnel, ConnectPoint ingress, ConnectPoint egress, Direction direction, Link nextHop, boolean spinePw, boolean oneHop, VlanId termVlanId) {
    if (nextHop == null) {
        log.warn("No path between ingress and egress cps for tunnel {}", l2Tunnel.tunnelId());
        return WRONG_PARAMETERS;
    }
    // We create the next objective without the metadata
    // context and id. We check if it already exists in the
    // store. If not we store as it is in the store.
    NextObjective.Builder nextObjectiveBuilder = createNextObjective(INITIATION, nextHop.src(), nextHop.dst(), l2Tunnel, egress.deviceId(), spinePw, oneHop, termVlanId);
    if (nextObjectiveBuilder == null) {
        return INTERNAL_ERROR;
    }
    // We set the metadata. We will use this metadata
    // to inform the driver we are doing a l2 tunnel.
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchTunnelId(l2Tunnel.tunnelId()).build();
    nextObjectiveBuilder.withMeta(metadata);
    int nextId = srManager.flowObjectiveService.allocateNextId();
    if (nextId < 0) {
        log.warn("Not able to allocate a next id for initiation");
        return INTERNAL_ERROR;
    }
    nextObjectiveBuilder.withId(nextId);
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    l2InitiationNextObjStore.put(key, nextObjectiveBuilder.add());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Initiation l2 tunnel rule " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate Initiation " + "l2 tunnel rule for {}: {}", l2Tunnel.tunnelId(), error));
    NextObjective nextObjective = nextObjectiveBuilder.add(context);
    srManager.flowObjectiveService.next(ingress.deviceId(), nextObjective);
    log.debug("Initiation next objective for {} not found. Creating new NextObj with id={}", l2Tunnel.tunnelId(), nextObjective.id());
    Result result = SUCCESS;
    result.setNextId(nextObjective.id());
    return result;
}
#method_after
private Result deployPseudoWireInit(L2Tunnel l2Tunnel, ConnectPoint ingress, ConnectPoint egress, Direction direction, Link nextHop, boolean spinePw, boolean oneHop, VlanId termVlanId) {
    log.debug("Started deploying init next objectives for pseudowire {} for tunnel {} -> {}.", l2Tunnel.tunnelId(), ingress, egress);
    if (nextHop == null) {
        log.warn("No path between ingress and egress connection points for tunnel {}", l2Tunnel.tunnelId());
        return WRONG_PARAMETERS;
    }
    // We create the next objective without the metadata
    // context and id. We check if it already exists in the
    // store. If not we store as it is in the store.
    NextObjective.Builder nextObjectiveBuilder = createNextObjective(INITIATION, nextHop.src(), nextHop.dst(), l2Tunnel, egress.deviceId(), spinePw, oneHop, termVlanId);
    if (nextObjectiveBuilder == null) {
        return INTERNAL_ERROR;
    }
    // We set the metadata. We will use this metadata
    // to inform the driver we are doing a l2 tunnel.
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchTunnelId(l2Tunnel.tunnelId()).build();
    nextObjectiveBuilder.withMeta(metadata);
    int nextId = srManager.flowObjectiveService.allocateNextId();
    if (nextId < 0) {
        log.warn("Not able to allocate a next id for initiation");
        return INTERNAL_ERROR;
    }
    nextObjectiveBuilder.withId(nextId);
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    l2InitiationNextObjStore.put(key, nextObjectiveBuilder.add());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Initiation l2 tunnel rule " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate Initiation " + "l2 tunnel rule for {}: {}", l2Tunnel.tunnelId(), error));
    NextObjective nextObjective = nextObjectiveBuilder.add(context);
    srManager.flowObjectiveService.next(ingress.deviceId(), nextObjective);
    log.debug("Initiation next objective for {} not found. Creating new NextObj with id={}", l2Tunnel.tunnelId(), nextObjective.id());
    Result result = SUCCESS;
    result.setNextId(nextObjective.id());
    return result;
}
#end_block

#method_before
private Result deployPseudoWireTerm(L2Tunnel l2Tunnel, ConnectPoint egress, VlanId egressVlan, Direction direction, boolean spinePw, boolean oneHop) {
    // We create the group relative to the termination.
    NextObjective.Builder nextObjectiveBuilder = createNextObjective(TERMINATION, egress, null, l2Tunnel, egress.deviceId(), spinePw, oneHop, egressVlan);
    if (nextObjectiveBuilder == null) {
        return INTERNAL_ERROR;
    }
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(egressVlan).build();
    nextObjectiveBuilder.withMeta(metadata);
    int nextId = srManager.flowObjectiveService.allocateNextId();
    if (nextId < 0) {
        log.warn("Not able to allocate a next id for initiation");
        return INTERNAL_ERROR;
    }
    nextObjectiveBuilder.withId(nextId);
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    l2TerminationNextObjStore.put(key, nextObjectiveBuilder.add());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Termination l2 tunnel rule " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "termination l2 tunnel " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    NextObjective nextObjective = nextObjectiveBuilder.add(context);
    srManager.flowObjectiveService.next(egress.deviceId(), nextObjective);
    log.debug("Termination next objective for {} not found. Creating new NextObj with id={}", l2Tunnel.tunnelId(), nextObjective.id());
    // We create the flow relative to the termination.
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for tunnel termination {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate fwdrObj" + " for tunnel termination {}", l2Tunnel.tunnelId(), error));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.add(context));
    log.debug("Creating new FwdObj for termination NextObj with id={} for tunnel {}", nextId, l2Tunnel.tunnelId());
    if (spinePw) {
        // determine the input port at the
        PortNumber inPort;
        if (egress.deviceId().equals(l2Tunnel.pathUsed().get(0).dst().deviceId())) {
            inPort = l2Tunnel.pathUsed().get(0).dst().port();
        } else {
            inPort = l2Tunnel.pathUsed().get(0).src().port();
        }
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {}", l2Tunnel.transportVlan(), inPort, dstMac);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.add(context));
        log.debug("Creating new special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    return SUCCESS;
}
#method_after
private Result deployPseudoWireTerm(L2Tunnel l2Tunnel, ConnectPoint egress, VlanId egressVlan, Direction direction, boolean spinePw, boolean oneHop, PortNumber inputTermPort) {
    log.debug("Started deploying termination objectives for pseudowire {} , direction {}.", l2Tunnel.tunnelId(), direction == FWD ? "forward" : "reverse");
    // We create the group relative to the termination.
    NextObjective.Builder nextObjectiveBuilder = createNextObjective(TERMINATION, egress, null, l2Tunnel, egress.deviceId(), spinePw, oneHop, egressVlan);
    if (nextObjectiveBuilder == null) {
        return INTERNAL_ERROR;
    }
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(egressVlan).build();
    nextObjectiveBuilder.withMeta(metadata);
    int nextId = srManager.flowObjectiveService.allocateNextId();
    if (nextId < 0) {
        log.warn("Not able to allocate a next id for initiation");
        return INTERNAL_ERROR;
    }
    nextObjectiveBuilder.withId(nextId);
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    l2TerminationNextObjStore.put(key, nextObjectiveBuilder.add());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Termination l2 tunnel rule " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "termination l2 tunnel " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    NextObjective nextObjective = nextObjectiveBuilder.add(context);
    srManager.flowObjectiveService.next(egress.deviceId(), nextObjective);
    log.debug("Termination next objective for {} not found. Creating new NextObj with id={}", l2Tunnel.tunnelId(), nextObjective.id());
    // We create the flow relative to the termination.
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for tunnel termination {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate fwdrObj" + " for tunnel termination {} : {}", l2Tunnel.tunnelId(), error));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.add(context));
    log.debug("Creating new FwdObj for termination NextObj with id={} for tunnel {}", nextId, l2Tunnel.tunnelId());
    if (spinePw) {
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {}", l2Tunnel.transportVlan(), inputTermPort, dstMac);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inputTermPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.add(context));
        log.debug("Creating new special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inputTermPort);
    }
    return SUCCESS;
}
#end_block

#method_before
private FilteringObjective.Builder createNormalPipelineFiltObjective(PortNumber inPort, VlanId vlanId, MacAddress dstMac) {
    log.info("Creating filtering objective for pseudowire transport with vlan={}, port={}, mac={}", vlanId, inPort, dstMac);
    FilteringObjective.Builder fwdBuilder = DefaultFilteringObjective.builder().withKey(Criteria.matchInPort(inPort)).addCondition(Criteria.matchVlanId(vlanId)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).permit().fromApp(srManager.appId());
    if (dstMac != null) {
        fwdBuilder.addCondition(Criteria.matchEthDst(dstMac));
    }
    return fwdBuilder;
}
#method_after
private FilteringObjective.Builder createNormalPipelineFiltObjective(PortNumber inPort, VlanId vlanId, MacAddress dstMac) {
    log.debug("Creating filtering objective for pseudowire intermediate transport with vlan={}, port={}, mac={}", vlanId, inPort, dstMac);
    FilteringObjective.Builder fwdBuilder = DefaultFilteringObjective.builder().withKey(Criteria.matchInPort(inPort)).addCondition(Criteria.matchVlanId(vlanId)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).permit().fromApp(srManager.appId());
    if (dstMac != null) {
        fwdBuilder.addCondition(Criteria.matchEthDst(dstMac));
    }
    return fwdBuilder;
}
#end_block

#method_before
private FilteringObjective.Builder createFiltObjective(PortNumber inPort, VlanId innerTag, VlanId outerTag) {
    log.info("Creating filtering objective for vlans {} / {}", outerTag, innerTag);
    return DefaultFilteringObjective.builder().withKey(Criteria.matchInPort(inPort)).addCondition(Criteria.matchInnerVlanId(innerTag)).addCondition(Criteria.matchVlanId(outerTag)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).permit().fromApp(srManager.appId());
}
#method_after
private FilteringObjective.Builder createFiltObjective(PortNumber inPort, VlanId innerTag, VlanId outerTag) {
    log.debug("Creating connection point filtering objective for vlans {} / {}", outerTag, innerTag);
    return DefaultFilteringObjective.builder().withKey(Criteria.matchInPort(inPort)).addCondition(Criteria.matchInnerVlanId(innerTag)).addCondition(Criteria.matchVlanId(outerTag)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).permit().fromApp(srManager.appId());
}
#end_block

#method_before
private ForwardingObjective.Builder createTermFwdObjective(MplsLabel pwLabel, long tunnelId, PortNumber egressPort, int nextId) {
    TrafficSelector.Builder trafficSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder trafficTreatment = DefaultTrafficTreatment.builder();
    // The flow has to match on the pw label and bos
    trafficSelector.matchEthType(Ethernet.MPLS_UNICAST);
    trafficSelector.matchMplsLabel(pwLabel);
    trafficSelector.matchMplsBos(true);
    // The flow has to decrement ttl, restore ttl in
    // pop mpls, set tunnel id and port.
    trafficTreatment.decMplsTtl();
    trafficTreatment.copyTtlIn();
    trafficTreatment.popMpls();
    trafficTreatment.setTunnelId(tunnelId);
    trafficTreatment.setOutput(egressPort);
    return DefaultForwardingObjective.builder().fromApp(srManager.appId()).makePermanent().nextStep(nextId).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).withSelector(trafficSelector.build()).withTreatment(trafficTreatment.build()).withFlag(VERSATILE);
}
#method_after
private ForwardingObjective.Builder createTermFwdObjective(MplsLabel pwLabel, long tunnelId, PortNumber egressPort, int nextId) {
    log.debug("Creating forwarding objective for termination for tunnel {} : pwLabel {}, egressPort {}, nextId {}", tunnelId, pwLabel, egressPort, nextId);
    TrafficSelector.Builder trafficSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder trafficTreatment = DefaultTrafficTreatment.builder();
    // The flow has to match on the pw label and bos
    trafficSelector.matchEthType(Ethernet.MPLS_UNICAST);
    trafficSelector.matchMplsLabel(pwLabel);
    trafficSelector.matchMplsBos(true);
    // The flow has to decrement ttl, restore ttl in
    // pop mpls, set tunnel id and port.
    trafficTreatment.decMplsTtl();
    trafficTreatment.copyTtlIn();
    trafficTreatment.popMpls();
    trafficTreatment.setTunnelId(tunnelId);
    trafficTreatment.setOutput(egressPort);
    return DefaultForwardingObjective.builder().fromApp(srManager.appId()).makePermanent().nextStep(nextId).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).withSelector(trafficSelector.build()).withTreatment(trafficTreatment.build()).withFlag(VERSATILE);
}
#end_block

#method_before
private ForwardingObjective.Builder createInitFwdObjective(long tunnelId, PortNumber inPort, int nextId) {
    TrafficSelector.Builder trafficSelector = DefaultTrafficSelector.builder();
    // The flow has to match on the mpls logical
    // port and the tunnel id.
    trafficSelector.matchTunnelId(tunnelId);
    trafficSelector.matchInPort(inPort);
    return DefaultForwardingObjective.builder().fromApp(srManager.appId()).makePermanent().nextStep(nextId).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).withSelector(trafficSelector.build()).withFlag(VERSATILE);
}
#method_after
private ForwardingObjective.Builder createInitFwdObjective(long tunnelId, PortNumber inPort, int nextId) {
    log.debug("Creating forwarding objective for tunnel {} : Port {} , nextId {}", tunnelId, inPort, nextId);
    TrafficSelector.Builder trafficSelector = DefaultTrafficSelector.builder();
    // The flow has to match on the mpls logical
    // port and the tunnel id.
    trafficSelector.matchTunnelId(tunnelId);
    trafficSelector.matchInPort(inPort);
    return DefaultForwardingObjective.builder().fromApp(srManager.appId()).makePermanent().nextStep(nextId).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).withSelector(trafficSelector.build()).withFlag(VERSATILE);
}
#end_block

#method_before
private NextObjective.Builder createNextObjective(Pipeline pipeline, ConnectPoint srcCp, ConnectPoint dstCp, L2Tunnel l2Tunnel, DeviceId egressId, boolean leafSpinePw, boolean oneHop, VlanId termVlanId) {
    NextObjective.Builder nextObjBuilder;
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (pipeline == INITIATION) {
        nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).fromApp(srManager.appId());
        // be different -1.
        if (l2Tunnel.pwLabel().toInt() == MplsLabel.MAX_MPLS) {
            log.warn("Pw label not configured");
            return null;
        }
        treatmentBuilder.pushMpls();
        treatmentBuilder.setMpls(l2Tunnel.pwLabel());
        treatmentBuilder.setMplsBos(true);
        treatmentBuilder.copyTtlOut();
        // If the inter-co label is present we have to set the label.
        if (l2Tunnel.interCoLabel().toInt() != MplsLabel.MAX_MPLS) {
            treatmentBuilder.pushMpls();
            treatmentBuilder.setMpls(l2Tunnel.interCoLabel());
            treatmentBuilder.setMplsBos(false);
            treatmentBuilder.copyTtlOut();
        }
        // if not oneHop install transit mpls labels also
        if (!oneHop) {
            // We retrieve the sr label from the config
            // specific for pseudowire traffic
            // using the egress leaf device id.
            MplsLabel srLabel;
            try {
                srLabel = MplsLabel.mplsLabel(srManager.deviceConfiguration().getPWRoutingLabel(egressId));
            } catch (DeviceConfigNotFoundException e) {
                log.warn("Sr label for pw traffic not configured");
                return null;
            }
            treatmentBuilder.pushMpls();
            treatmentBuilder.setMpls(srLabel);
            treatmentBuilder.setMplsBos(false);
            treatmentBuilder.copyTtlOut();
        }
        // We have to rewrite the src and dst mac address.
        MacAddress ingressMac;
        try {
            ingressMac = srManager.deviceConfiguration().getDeviceMac(srcCp.deviceId());
        } catch (DeviceConfigNotFoundException e) {
            log.warn("Was not able to find the ingress mac");
            return null;
        }
        treatmentBuilder.setEthSrc(ingressMac);
        MacAddress neighborMac;
        try {
            neighborMac = srManager.deviceConfiguration().getDeviceMac(dstCp.deviceId());
        } catch (DeviceConfigNotFoundException e) {
            log.warn("Was not able to find the neighbor mac");
            return null;
        }
        treatmentBuilder.setEthDst(neighborMac);
        // we instantiate a leaf to leaf pseudowire
        if (!leafSpinePw) {
            log.info("We should carry this traffic UNTAGGED!");
            treatmentBuilder.popVlan();
        }
        // set the appropriate transport vlan from tunnel information
        treatmentBuilder.setVlanId(l2Tunnel.transportVlan());
    } else {
        // We create the next objective which
        // will be a simple l2 group.
        nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).fromApp(srManager.appId());
        // for termination point we use the outer vlan of the
        // encapsulated packet
        treatmentBuilder.setVlanId(termVlanId);
    }
    treatmentBuilder.setOutput(srcCp.port());
    nextObjBuilder.addTreatment(treatmentBuilder.build());
    return nextObjBuilder;
}
#method_after
private NextObjective.Builder createNextObjective(Pipeline pipeline, ConnectPoint srcCp, ConnectPoint dstCp, L2Tunnel l2Tunnel, DeviceId egressId, boolean leafSpinePw, boolean oneHop, VlanId termVlanId) {
    log.debug("Creating {} next objective for pseudowire {}.", pipeline == TERMINATION ? "termination" : "inititation");
    NextObjective.Builder nextObjBuilder;
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (pipeline == INITIATION) {
        nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).fromApp(srManager.appId());
        // be different -1.
        if (l2Tunnel.pwLabel().toInt() == MplsLabel.MAX_MPLS) {
            log.error("Pw label not configured");
            return null;
        }
        treatmentBuilder.pushMpls();
        treatmentBuilder.setMpls(l2Tunnel.pwLabel());
        treatmentBuilder.setMplsBos(true);
        treatmentBuilder.copyTtlOut();
        // If the inter-co label is present we have to set the label.
        if (l2Tunnel.interCoLabel().toInt() != MplsLabel.MAX_MPLS) {
            treatmentBuilder.pushMpls();
            treatmentBuilder.setMpls(l2Tunnel.interCoLabel());
            treatmentBuilder.setMplsBos(false);
            treatmentBuilder.copyTtlOut();
        }
        // if not oneHop install transit mpls labels also
        if (!oneHop) {
            // We retrieve the sr label from the config
            // specific for pseudowire traffic
            // using the egress leaf device id.
            MplsLabel srLabel;
            try {
                srLabel = MplsLabel.mplsLabel(srManager.deviceConfiguration().getPWRoutingLabel(egressId));
            } catch (DeviceConfigNotFoundException e) {
                log.error("Sr label for pw traffic not configured");
                return null;
            }
            treatmentBuilder.pushMpls();
            treatmentBuilder.setMpls(srLabel);
            treatmentBuilder.setMplsBos(false);
            treatmentBuilder.copyTtlOut();
        }
        // We have to rewrite the src and dst mac address.
        MacAddress ingressMac;
        try {
            ingressMac = srManager.deviceConfiguration().getDeviceMac(srcCp.deviceId());
        } catch (DeviceConfigNotFoundException e) {
            log.error("Was not able to find the ingress mac");
            return null;
        }
        treatmentBuilder.setEthSrc(ingressMac);
        MacAddress neighborMac;
        try {
            neighborMac = srManager.deviceConfiguration().getDeviceMac(dstCp.deviceId());
        } catch (DeviceConfigNotFoundException e) {
            log.error("Was not able to find the neighbor mac");
            return null;
        }
        treatmentBuilder.setEthDst(neighborMac);
        // we instantiate a leaf to leaf pseudowire
        if (!leafSpinePw) {
            log.debug("We should carry traffic UNTAGGED for pseudowire {}", l2Tunnel.tunnelId());
            treatmentBuilder.popVlan();
        }
        // set the appropriate transport vlan from tunnel information
        treatmentBuilder.setVlanId(l2Tunnel.transportVlan());
    } else {
        // We create the next objective which
        // will be a simple l2 group.
        nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).fromApp(srManager.appId());
        // for termination point we use the outer vlan of the
        // encapsulated packet
        treatmentBuilder.setVlanId(termVlanId);
    }
    treatmentBuilder.setOutput(srcCp.port());
    nextObjBuilder.addTreatment(treatmentBuilder.build());
    return nextObjBuilder;
}
#end_block

#method_before
private L2TunnelPolicy reverseL2TunnelPolicy(L2TunnelPolicy policy) {
    try {
        // if cp1 is a leaf, just return
        if (srManager.deviceConfiguration().isEdgeDevice(policy.cP1().deviceId())) {
            return policy;
        } else {
            // return a policy with reversed cp1 and cp2, and also with reversed tags
            return new DefaultL2TunnelPolicy(policy.tunnelId(), policy.cP2(), policy.cP2InnerTag(), policy.cP2OuterTag(), policy.cP1(), policy.cP1InnerTag(), policy.cP1OuterTag());
        }
    } catch (DeviceConfigNotFoundException e) {
        // should never come here, since it has been checked before
        log.error("Configuration for device {}, does not exist!");
        return null;
    }
}
#method_after
private L2TunnelPolicy reverseL2TunnelPolicy(L2TunnelPolicy policy) {
    log.debug("Reversing policy for pseudowire.");
    try {
        // if cp1 is a leaf, just return
        if (srManager.deviceConfiguration().isEdgeDevice(policy.cP1().deviceId())) {
            return policy;
        } else {
            // return a policy with reversed cp1 and cp2, and also with reversed tags
            return new DefaultL2TunnelPolicy(policy.tunnelId(), policy.cP2(), policy.cP2InnerTag(), policy.cP2OuterTag(), policy.cP1(), policy.cP1InnerTag(), policy.cP1OuterTag());
        }
    } catch (DeviceConfigNotFoundException e) {
        // should never come here, since it has been checked before
        log.error("Configuration for device {}, does not exist!");
        return null;
    }
}
#end_block

#method_before
private void deletePolicy(long tunnelId, ConnectPoint ingress, VlanId ingressInner, VlanId ingressOuter, VlanId egressVlan, CompletableFuture<ObjectiveError> future, Direction direction) {
    String key = generateKey(tunnelId, direction);
    if (!l2InitiationNextObjStore.containsKey(key)) {
        log.warn("Abort delete of policy for tunnel {}: next does not exist in the store", tunnelId);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    NextObjective nextObjective = l2InitiationNextObjStore.get(key).value();
    int nextId = nextObjective.id();
    List<Objective> objectives = Lists.newArrayList();
    // We create the forwarding objective.
    ForwardingObjective.Builder fwdBuilder = createInitFwdObjective(tunnelId, ingress.port(), nextId);
    ObjectiveContext context = new ObjectiveContext() {

        @Override
        public void onSuccess(Objective objective) {
            log.debug("Previous fwdObj for policy {} removed", tunnelId);
            if (future != null) {
                future.complete(null);
            }
        }

        @Override
        public void onError(Objective objective, ObjectiveError error) {
            log.warn("Failed to remove previous fwdObj for policy {}: {}", tunnelId, error);
            if (future != null) {
                future.complete(error);
            }
        }
    };
    objectives.add(fwdBuilder.remove(context));
    // We create the filtering objective to define the
    // permit traffic in the switch
    FilteringObjective.Builder filtBuilder = createFiltObjective(ingress.port(), ingressInner, ingressOuter);
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setTunnelId(tunnelId).setVlanId(egressVlan);
    filtBuilder.withMeta(treatment.build());
    context = new DefaultObjectiveContext((objective) -> log.debug("FilterObj for policy {} revoked", tunnelId), (objective, error) -> log.warn("Failed to revoke filterObj for policy {}", tunnelId, error));
    objectives.add(filtBuilder.remove(context));
    for (Objective objective : objectives) {
        if (objective instanceof ForwardingObjective) {
            srManager.flowObjectiveService.forward(ingress.deviceId(), (ForwardingObjective) objective);
        } else {
            srManager.flowObjectiveService.filter(ingress.deviceId(), (FilteringObjective) objective);
        }
    }
}
#method_after
private void deletePolicy(long tunnelId, ConnectPoint ingress, VlanId ingressInner, VlanId ingressOuter, VlanId egressVlan, CompletableFuture<ObjectiveError> future, Direction direction) {
    String key = generateKey(tunnelId, direction);
    if (!l2InitiationNextObjStore.containsKey(key)) {
        log.error("Abort delete of policy for tunnel {}: next does not exist in the store", tunnelId);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    NextObjective nextObjective = l2InitiationNextObjStore.get(key).value();
    int nextId = nextObjective.id();
    List<Objective> objectives = Lists.newArrayList();
    // We create the forwarding objective.
    ForwardingObjective.Builder fwdBuilder = createInitFwdObjective(tunnelId, ingress.port(), nextId);
    ObjectiveContext context = new ObjectiveContext() {

        @Override
        public void onSuccess(Objective objective) {
            log.debug("Previous fwdObj for policy {} removed", tunnelId);
            if (future != null) {
                future.complete(null);
            }
        }

        @Override
        public void onError(Objective objective, ObjectiveError error) {
            log.error("Failed to remove previous fwdObj for policy {}: {}", tunnelId, error);
            if (future != null) {
                future.complete(error);
            }
        }
    };
    objectives.add(fwdBuilder.remove(context));
    // We create the filtering objective to define the
    // permit traffic in the switch
    FilteringObjective.Builder filtBuilder = createFiltObjective(ingress.port(), ingressInner, ingressOuter);
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setTunnelId(tunnelId).setVlanId(egressVlan);
    filtBuilder.withMeta(treatment.build());
    context = new DefaultObjectiveContext((objective) -> log.debug("FilterObj for policy {} revoked", tunnelId), (objective, error) -> log.warn("Failed to revoke filterObj for policy {}", tunnelId, error));
    objectives.add(filtBuilder.remove(context));
    for (Objective objective : objectives) {
        if (objective instanceof ForwardingObjective) {
            srManager.flowObjectiveService.forward(ingress.deviceId(), (ForwardingObjective) objective);
        } else {
            srManager.flowObjectiveService.filter(ingress.deviceId(), (FilteringObjective) objective);
        }
    }
}
#end_block

#method_before
private void tearDownPseudoWireInit(long l2TunnelId, ConnectPoint ingress, CompletableFuture<ObjectiveError> future, Direction direction) {
    String key = generateKey(l2TunnelId, direction);
    if (!l2InitiationNextObjStore.containsKey(key)) {
        log.info("Abort delete of {} for {}: next does not exist in the store", INITIATION, key);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    // un-comment in case you want to delete groups used by the pw
    // however, this will break the update of pseudowires cause the L2 interface group can
    // not be deleted (it is referenced by other groups)
    /*
        NextObjective nextObjective = l2InitiationNextObjStore.get(key).value();
        ObjectiveContext context = new ObjectiveContext() {
            @Override
            public void onSuccess(Objective objective) {
                log.debug("Previous {} next for {} removed", INITIATION, key);
                if (future != null) {
                    future.complete(null);
                }
            }

            @Override
            public void onError(Objective objective, ObjectiveError error) {
                log.warn("Failed to remove previous {} next for {}: {}", INITIATION, key, error);
                if (future != null) {
                    future.complete(error);
                }
            }
        };
        srManager.flowObjectiveService.next(ingress.deviceId(), (NextObjective) nextObjective.copy().remove(context));
        */
    future.complete(null);
    l2InitiationNextObjStore.remove(key);
}
#method_after
private void tearDownPseudoWireInit(long l2TunnelId, ConnectPoint ingress, CompletableFuture<ObjectiveError> future, Direction direction) {
    log.debug("Starting tearing dowing initation of pseudowire {} for direction {}.", l2TunnelId, direction == FWD ? "forward" : "reverse");
    String key = generateKey(l2TunnelId, direction);
    if (!l2InitiationNextObjStore.containsKey(key)) {
        log.error("Abort delete of {} for {}: next does not exist in the store", INITIATION, key);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    // un-comment in case you want to delete groups used by the pw
    // however, this will break the update of pseudowires cause the L2 interface group can
    // not be deleted (it is referenced by other groups)
    /*
        NextObjective nextObjective = l2InitiationNextObjStore.get(key).value();
        ObjectiveContext context = new ObjectiveContext() {
            @Override
            public void onSuccess(Objective objective) {
                log.debug("Previous {} next for {} removed", INITIATION, key);
                if (future != null) {
                    future.complete(null);
                }
            }

            @Override
            public void onError(Objective objective, ObjectiveError error) {
                log.warn("Failed to remove previous {} next for {}: {}", INITIATION, key, error);
                if (future != null) {
                    future.complete(error);
                }
            }
        };
        srManager.flowObjectiveService.next(ingress.deviceId(), (NextObjective) nextObjective.copy().remove(context));
        */
    future.complete(null);
    l2InitiationNextObjStore.remove(key);
}
#end_block

#method_before
private void tearDownPseudoWireTerm(L2Tunnel l2Tunnel, ConnectPoint egress, CompletableFuture<ObjectiveError> future, Direction direction) {
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    if (!l2TerminationNextObjStore.containsKey(key)) {
        log.info("Abort delete of {} for {}: next does not exist in the store", TERMINATION, key);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    NextObjective nextObjective = l2TerminationNextObjStore.get(key).value();
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for {} {}, " + "direction {} removed", TERMINATION, l2Tunnel.tunnelId(), direction), (objective, error) -> log.warn("Failed to remove fwdObj " + "for {} {}" + ", direction {}", TERMINATION, l2Tunnel.tunnelId(), error, direction));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.remove(context));
    // spine-spine pws
    if (!l2Tunnel.transportVlan().equals(UNTAGGED_TRANSPORT_VLAN)) {
        // determine the input port at the
        PortNumber inPort;
        if (egress.deviceId().equals(l2Tunnel.pathUsed().get(0).dst().deviceId())) {
            inPort = l2Tunnel.pathUsed().get(0).dst().port();
        } else {
            inPort = l2Tunnel.pathUsed().get(0).src().port();
        }
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Removing filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {}", l2Tunnel.transportVlan(), inPort, dstMac);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} removed", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.remove(context));
        log.debug("Removing special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    l2TerminationNextObjStore.remove(key);
    future.complete(null);
}
#method_after
private void tearDownPseudoWireTerm(L2Tunnel l2Tunnel, ConnectPoint egress, CompletableFuture<ObjectiveError> future, Direction direction, PortNumber inPort) {
    log.debug("Starting tearing down termination for pseudowire {} direction {}.", l2Tunnel.tunnelId(), direction == FWD ? "forward" : "reverse");
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    if (!l2TerminationNextObjStore.containsKey(key)) {
        log.error("Abort delete of {} for {}: next does not exist in the store", TERMINATION, key);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    NextObjective nextObjective = l2TerminationNextObjStore.get(key).value();
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for {} {}, " + "direction {} removed", TERMINATION, l2Tunnel.tunnelId(), direction), (objective, error) -> log.warn("Failed to remove fwdObj " + "for {} {}" + ", direction {}", TERMINATION, l2Tunnel.tunnelId(), error, direction));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.remove(context));
    // spine-spine pws
    if (!l2Tunnel.transportVlan().equals(UNTAGGED_TRANSPORT_VLAN)) {
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.error("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Removing filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {}", l2Tunnel.transportVlan(), inPort, dstMac);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} removed", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.remove(context));
        log.debug("Removing special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    l2TerminationNextObjStore.remove(key);
    future.complete(null);
}
#end_block

#method_before
public static VlanId parseVlan(String vlan) {
    if (vlan.equals("*") || vlan.equals("Any")) {
        return VlanId.vlanId("Any");
    } else if (vlan.equals("") || vlan.equals("None")) {
        return VlanId.vlanId("None");
    } else {
        try {
            VlanId newVlan = VlanId.vlanId(vlan);
            return newVlan;
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Vlan should be an integer!");
        }
    }
}
#method_after
public static VlanId parseVlan(String vlan) {
    if (vlan.equals("*") || vlan.equals("Any")) {
        return VlanId.vlanId("Any");
    } else if (vlan.equals("") || vlan.equals("None")) {
        return VlanId.vlanId("None");
    } else {
        return VlanId.vlanId(vlan);
    }
}
#end_block

#method_before
public static L2Mode parseMode(String mode) {
    if (!mode.equals("RAW") && !mode.equals("TAGGED")) {
        throw new IllegalArgumentException("Pseudowire mode should be RAW or TAGGED!");
    }
    return L2Mode.valueOf(mode);
}
#method_after
public static L2Mode parseMode(String mode) {
    checkArgument(mode.equals("RAW") || mode.equals("TAGGED"), "Invalid pseudowire mode of operation, should be TAGGED or RAW.");
    return L2Mode.valueOf(mode);
}
#end_block

#method_before
public static MplsLabel parsePWLabel(String label) {
    try {
        MplsLabel pwLabel = MplsLabel.mplsLabel(label);
        return pwLabel;
    } catch (Exception e) {
        throw new IllegalArgumentException("Mpls label should be an integer!");
    }
}
#method_after
public static MplsLabel parsePWLabel(String label) {
    return MplsLabel.mplsLabel(label);
}
#end_block

#method_before
public static Integer parsePwId(String id) {
    try {
        return Integer.parseInt(id);
    } catch (Exception e) {
        throw new IllegalArgumentException("Pseudowire id should be an integer!");
    }
}
#method_after
public static Integer parsePwId(String id) {
    return Integer.parseInt(id);
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    try {
        Optional<JsonNode> result = AristaUtils.retrieveCommandResult(handler(), SHOW_VERSION);
        if (!result.isPresent()) {
            return null;
        }
        JsonNode jsonNode = result.get().get(1);
        String hwVer = jsonNode.get(MODEL_NAME).asText(UNKNOWN);
        String swVer = jsonNode.get(SW_VERSION).asText(UNKNOWN);
        String serialNum = jsonNode.get(SERIAL_NUMBER).asText(UNKNOWN);
        String systemMacAddress = jsonNode.get(SYSTEM_MAC_ADDRESS).asText("").replace(":", "");
        DeviceId deviceId = handler().data().deviceId();
        DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
        Device device = deviceService.getDevice(deviceId);
        ChassisId chassisId = systemMacAddress.isEmpty() ? new ChassisId() : new ChassisId(systemMacAddress);
        log.debug("systemMacAddress: {}", systemMacAddress);
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, MANUFACTURER, hwVer, swVer, serialNum, chassisId, (SparseAnnotations) device.annotations());
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
        return null;
    }
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    try {
        Optional<JsonNode> result = AristaUtils.retrieveCommandResult(handler(), SHOW_VERSION);
        if (!result.isPresent()) {
            return null;
        }
        JsonNode jsonNode = result.get().get(AristaUtils.RESULT_START_INDEX);
        String hwVer = jsonNode.get(MODEL_NAME).asText(UNKNOWN);
        String swVer = jsonNode.get(SW_VERSION).asText(UNKNOWN);
        String serialNum = jsonNode.get(SERIAL_NUMBER).asText(UNKNOWN);
        String systemMacAddress = jsonNode.get(SYSTEM_MAC_ADDRESS).asText("").replace(":", "");
        DeviceId deviceId = checkNotNull(handler().data().deviceId());
        DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
        Device device = deviceService.getDevice(deviceId);
        ChassisId chassisId = systemMacAddress.isEmpty() ? new ChassisId() : new ChassisId(systemMacAddress);
        log.debug("systemMacAddress: {}", systemMacAddress);
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, MANUFACTURER, hwVer, swVer, serialNum, chassisId, (SparseAnnotations) device.annotations());
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
        return null;
    }
}
#end_block

#method_before
private Set<LinkDescription> createLinksDescs(Optional<JsonNode> response) {
    DriverHandler handler = handler();
    DeviceId localDeviceId = handler.data().deviceId();
    DeviceService deviceService = handler.get(DeviceService.class);
    Set<LinkDescription> linkDescriptions = Sets.newHashSet();
    List<Port> ports = deviceService.getPorts(localDeviceId);
    if (ports.isEmpty() || Objects.isNull(response)) {
        return linkDescriptions;
    }
    if (!response.isPresent()) {
        return linkDescriptions;
    }
    log.debug("response: {}, {}", response, localDeviceId.toString());
    JsonNode res = response.get();
    if (res == null) {
        log.warn("result is null");
        return linkDescriptions;
    }
    JsonNode lldpNeighbors = res.findValue(LLDP_NEIGHBORS);
    if (lldpNeighbors == null) {
        log.warn("{} is null", LLDP_NEIGHBORS);
        return linkDescriptions;
    }
    Iterator<Map.Entry<String, JsonNode>> lldpNeighborsIter = lldpNeighbors.fields();
    while (lldpNeighborsIter.hasNext()) {
        Map.Entry<String, JsonNode> neighbor = lldpNeighborsIter.next();
        String lldpLocalPort = neighbor.getKey();
        JsonNode neighborValue = neighbor.getValue();
        log.debug("lldpLocalPort: {}", lldpLocalPort);
        log.debug("neighborValue: {}", neighborValue.toString());
        if (lldpLocalPort.isEmpty()) {
            continue;
        }
        JsonNode neighborInfo = neighborValue.findValue(LLDP_NEIGHBOR_INFO);
        if (neighborInfo == null) {
            log.warn("{} is null", LLDP_NEIGHBOR_INFO);
            continue;
        }
        Iterator<JsonNode> neighborInfoIter = neighborInfo.elements();
        while (neighborInfoIter.hasNext()) {
            JsonNode info = neighborInfoIter.next();
            String chassisIdType = info.get(CHASSIS_ID_TYPE).asText("");
            if (chassisIdType == null) {
                log.warn("{} is null", CHASSIS_ID_TYPE);
                continue;
            }
            if (!chassisIdType.equals(CHASSIS_ID_TYPE_MAC)) {
                log.warn("{} is not mac: {}", CHASSIS_ID_TYPE_MAC, chassisIdType);
                continue;
            }
            JsonNode remotePortNameNode = info.findValue(PORT_ID);
            if (remotePortNameNode == null) {
                continue;
            }
            String remoteChassisId = info.get(CHASSIS_ID).asText("");
            String remotePortName = remotePortNameNode.asText("");
            log.debug("{}: {}, {}: {}", CHASSIS_ID, remoteChassisId, PORT_ID, remotePortName);
            Optional<Port> localPort = findLocalPortByName(ports, lldpLocalPort);
            if (!localPort.isPresent()) {
                log.warn("local port not found. lldpLocalPort value: {}", lldpLocalPort);
                continue;
            }
            Optional<Device> remoteDevice = findRemoteDeviceByChassisId(deviceService, remoteChassisId);
            if (!remoteDevice.isPresent()) {
                log.warn("remote device not found. remoteChassisId value: {}", remoteChassisId);
                continue;
            }
            Optional<Port> remotePort = findDestinationPortByName(remotePortName, deviceService, remoteDevice.get());
            if (!remotePort.isPresent()) {
                log.warn("remote port not found. remotePortName value: {}", remotePortName);
                continue;
            }
            linkDescriptions.addAll(buildLinkPair(localDeviceId, localPort.get(), remoteDevice.get().id(), remotePort.get()));
        }
    }
    log.debug("returning linkDescriptions: {}", linkDescriptions);
    return linkDescriptions;
}
#method_after
private Set<LinkDescription> createLinksDescs(Optional<JsonNode> response) {
    DriverHandler handler = checkNotNull(handler());
    DeviceId localDeviceId = checkNotNull(handler.data().deviceId());
    DeviceService deviceService = handler.get(DeviceService.class);
    Set<LinkDescription> linkDescriptions = Sets.newHashSet();
    List<Port> ports = deviceService.getPorts(localDeviceId);
    if (ports.isEmpty() || Objects.isNull(response)) {
        return linkDescriptions;
    }
    if (!response.isPresent()) {
        return linkDescriptions;
    }
    log.debug("response: {}, {}", response, localDeviceId.toString());
    JsonNode res = response.get();
    if (res == null) {
        log.warn("result is null");
        return linkDescriptions;
    }
    JsonNode lldpNeighbors = res.findValue(LLDP_NEIGHBORS);
    if (lldpNeighbors == null) {
        log.warn("{} is null", LLDP_NEIGHBORS);
        return linkDescriptions;
    }
    Iterator<Map.Entry<String, JsonNode>> lldpNeighborsIter = lldpNeighbors.fields();
    while (lldpNeighborsIter.hasNext()) {
        Map.Entry<String, JsonNode> neighbor = lldpNeighborsIter.next();
        String lldpLocalPort = neighbor.getKey();
        JsonNode neighborValue = neighbor.getValue();
        log.debug("lldpLocalPort: {}", lldpLocalPort);
        log.debug("neighborValue: {}", neighborValue.toString());
        if (lldpLocalPort.isEmpty()) {
            continue;
        }
        JsonNode neighborInfo = neighborValue.findValue(LLDP_NEIGHBOR_INFO);
        if (neighborInfo == null) {
            log.warn("{} is null", LLDP_NEIGHBOR_INFO);
            continue;
        }
        Iterator<JsonNode> neighborInfoIter = neighborInfo.elements();
        while (neighborInfoIter.hasNext()) {
            JsonNode info = neighborInfoIter.next();
            String chassisIdType = info.get(CHASSIS_ID_TYPE).asText("");
            if (chassisIdType == null) {
                log.warn("{} is null", CHASSIS_ID_TYPE);
                continue;
            }
            if (!chassisIdType.equals(CHASSIS_ID_TYPE_MAC)) {
                log.warn("{} is not mac: {}", CHASSIS_ID_TYPE_MAC, chassisIdType);
                continue;
            }
            JsonNode remotePortNameNode = info.findValue(PORT_ID);
            if (remotePortNameNode == null) {
                continue;
            }
            String remoteChassisId = info.get(CHASSIS_ID).asText("");
            String remotePortName = remotePortNameNode.asText("");
            log.debug("{}: {}, {}: {}", CHASSIS_ID, remoteChassisId, PORT_ID, remotePortName);
            Optional<Port> localPort = findLocalPortByName(ports, lldpLocalPort);
            if (!localPort.isPresent()) {
                log.warn("local port not found. lldpLocalPort value: {}", lldpLocalPort);
                continue;
            }
            Optional<Device> remoteDevice = findRemoteDeviceByChassisId(deviceService, remoteChassisId);
            if (!remoteDevice.isPresent()) {
                log.warn("remote device not found. remoteChassisId value: {}", remoteChassisId);
                continue;
            }
            Optional<Port> remotePort = findDestinationPortByName(remotePortName, deviceService, remoteDevice.get());
            if (!remotePort.isPresent()) {
                log.warn("remote port not found. remotePortName value: {}", remotePortName);
                continue;
            }
            linkDescriptions.addAll(buildLinkPair(localDeviceId, localPort.get(), remoteDevice.get().id(), remotePort.get()));
        }
    }
    log.debug("returning linkDescriptions: {}", linkDescriptions);
    return linkDescriptions;
}
#end_block

#method_before
public static Optional<JsonNode> retrieveCommandResult(DriverHandler handler, String cmd) {
    ArrayList<String> cmds = new ArrayList<>();
    cmds.add(cmd);
    return retrieveCommandResult(handler, cmds);
}
#method_after
public static Optional<JsonNode> retrieveCommandResult(DriverHandler handler, String cmd) {
    List<String> cmds = Lists.newArrayList();
    cmds.add(cmd);
    return retrieveCommandResult(handler, cmds);
}
#end_block

#method_before
public static Optional<JsonNode> retrieveCommandResult(DriverHandler handler, List<String> cmds) {
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    String request = generate(cmds);
    log.debug("request :{}", request);
    String response = controller.post(deviceId, API_ENDPOINT, new ByteArrayInputStream(request.getBytes()), MediaType.APPLICATION_JSON_TYPE, String.class);
    log.debug("response :{}", response);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        if (node.has(ERROR)) {
            log.error("Error {}", node.get(ERROR));
            return Optional.empty();
        } else {
            return Optional.ofNullable(node.get(RESULT));
        }
    } catch (IOException e) {
        log.warn("IO exception occurred because of ", e);
    }
    return Optional.empty();
}
#method_after
public static Optional<JsonNode> retrieveCommandResult(DriverHandler handler, List<String> cmds) {
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = checkNotNull(handler.data()).deviceId();
    String request = generate(cmds);
    log.debug("request :{}", request);
    String response = controller.post(deviceId, API_ENDPOINT, new ByteArrayInputStream(request.getBytes()), MediaType.APPLICATION_JSON_TYPE, String.class);
    log.debug("response :{}", response);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        if (node.has(ERROR)) {
            log.error("Error {}", node.get(ERROR));
            return Optional.empty();
        } else {
            return Optional.ofNullable(node.get(RESULT));
        }
    } catch (IOException e) {
        log.warn("IO exception occurred because of ", e);
    }
    return Optional.empty();
}
#end_block

#method_before
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    List<String> cmds = new ArrayList<>();
    cmds.add(CONFIGURE_TERMINAL);
    cmds.add(OPENFLOW_CMD);
    controllers.stream().limit(MAX_CONTROLLERS).forEach(c -> cmds.add(String.format(REMOVE_CONTROLLER_CMD, c.ip().toString(), c.port())));
    AristaUtils.retrieveCommandResult(handler(), cmds);
}
#method_after
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    List<String> cmds = Lists.newArrayList();
    cmds.add(CONFIGURE_TERMINAL);
    cmds.add(OPENFLOW_CMD);
    controllers.stream().limit(MAX_CONTROLLERS).forEach(c -> cmds.add(String.format(REMOVE_CONTROLLER_CMD, c.ip().toString(), c.port())));
    AristaUtils.retrieveCommandResult(handler(), cmds);
}
#end_block

#method_before
@Activate
public void activate() {
    // Registers the pipeconf at component activation.
    try {
        piPipeconfService.register(buildPipeconf());
    } catch (IllegalStateException e) {
        log.error("Fail to register pipeconf\n{}", e.getMessage());
    }
}
#method_after
@Activate
public void activate() {
    // Registers the pipeconf at component activation.
    try {
        piPipeconfService.register(buildPipeconf());
    } catch (P4InfoParserException e) {
        log.error("Fail to register {} - Exception: {} - Cause: {}", PIPECONF_ID, e.getMessage(), e.getCause().getMessage());
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    piPipeconfService.remove(PIPECONF_ID);
}
#method_after
@Deactivate
public void deactivate() {
    // Unregisters the pipeconf at component deactivation.
    try {
        piPipeconfService.remove(PIPECONF_ID);
    } catch (IllegalStateException e) {
        log.warn("{} haven't been registered", PIPECONF_ID);
    }
}
#end_block

#method_before
private PiPipeconf buildPipeconf() {
    final PiPipelineModel pipelineModel;
    try {
        pipelineModel = P4InfoParser.parse(P4INFO_URL);
    } catch (P4InfoParserException e) {
        throw new IllegalStateException("Exception: " + e.getMessage() + "\nCause: " + e.getCause().getMessage());
    }
    return DefaultPiPipeconf.builder().withId(PIPECONF_ID).withPipelineModel(pipelineModel).addBehaviour(PiPipelineInterpreter.class, PipelineInterpreterImpl.class).addBehaviour(PortStatisticsDiscovery.class, PortStatisticsDiscoveryImpl.class).addBehaviour(Pipeliner.class, DefaultSingleTablePipeline.class).addExtension(P4_INFO_TEXT, P4INFO_URL).addExtension(BMV2_JSON, BMV2_JSON_URL).build();
}
#method_after
private PiPipeconf buildPipeconf() throws P4InfoParserException {
    final PiPipelineModel pipelineModel = P4InfoParser.parse(P4INFO_URL);
    return DefaultPiPipeconf.builder().withId(PIPECONF_ID).withPipelineModel(pipelineModel).addBehaviour(PiPipelineInterpreter.class, PipelineInterpreterImpl.class).addBehaviour(PortStatisticsDiscovery.class, PortStatisticsDiscoveryImpl.class).addBehaviour(Pipeliner.class, DefaultSingleTablePipeline.class).addExtension(P4_INFO_TEXT, P4INFO_URL).addExtension(BMV2_JSON, BMV2_JSON_URL).build();
}
#end_block

#method_before
@Override
public void replace(Route route) {
    routes.replaceValues(route.prefix(), Stream.of(route).collect(Collectors.toSet()));
}
#method_after
@Override
public void replace(Route route) {
    routes.replaceValues(route.prefix(), Sets.newHashSet(route));
}
#end_block

#method_before
default void replaceRoute(Route route) {
    RouteSet rs = getRoutes(route.prefix());
    for (Route r : rs.routes()) {
        removeRoute(r);
    }
    updateRoute(route);
}
#method_after
default void replaceRoute(Route route) {
    throw new NotImplementedException("replaceRoute is not implemented");
}
#end_block

#method_before
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    List<String> cmds = new ArrayList<>();
    cmds.add(OPENFLOW_CMD);
    cmds.add(DELETE_OF_CONFIG);
    cmds.add(COPY_RUNNING_CONFIG);
    String response = NxApiRequest.postClis(handler, cmds);
    if (Objects.isNull(response)) {
        throw new NullPointerException("Response is null");
    }
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        if (json.has("errors")) {
            log.error("{} Response has IllegalStateException Error", deviceId);
            return;
        }
    // TODO parse error messages.
    } catch (IOException e) {
        log.error("Exception thrown", e);
    }
}
#method_after
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    List<String> cmds = new ArrayList<>();
    cmds.add(OPENFLOW_CMD);
    cmds.add(DELETE_OF_CONFIG);
    cmds.add(COPY_RUNNING_CONFIG);
    String response = NxApiRequest.postClis(handler, cmds);
    if (Objects.isNull(response)) {
        log.error(" Device {} Response is null", deviceId);
        return;
    }
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        if (json.has("errors")) {
            log.error("{} Response has JSON Format Error {}", deviceId, json);
            return;
        }
    // TODO parse error messages.
    } catch (IOException e) {
        log.error("Exception thrown", e);
    }
}
#end_block

#method_before
private List<ControllerInfo> parseControllerInfo(String data) {
    final String regex = "(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}):(\\d{1,5})";
    Pattern pattern = Pattern.compile(regex);
    Matcher match = pattern.matcher(data);
    List<ControllerInfo> controllers = new ArrayList<ControllerInfo>();
    while (match.find()) {
        String str = match.group();
        String[] ips = str.split(":");
        ControllerInfo info = new ControllerInfo(IpAddress.valueOf(ips[0]), Integer.valueOf(ips[1]).intValue(), "tcp");
        controllers.add(info);
    }
    return controllers;
}
#method_after
private List<ControllerInfo> parseControllerInfo(String data) {
    final String regex = "(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}):(\\d{1,5})";
    Pattern pattern = Pattern.compile(regex);
    Matcher match = pattern.matcher(data);
    List<ControllerInfo> controllers = new ArrayList<ControllerInfo>();
    while (match.find()) {
        String str = match.group();
        String[] ips = str.split(":");
        ControllerInfo info = new ControllerInfo(IpAddress.valueOf(ips[0]), Integer.parseInt(ips[1]), "tcp");
        controllers.add(info);
    }
    return controllers;
}
#end_block

#method_before
private void deleteConnectionRecursively(TapiConnectionHandler connectionHandler) {
    op = Operation.DELETE;
    connectionManagerList.clear();
    // read target to be deleted
    connectionHandler.read();
    log.info("model: {}", connectionHandler.getModelObject());
    this.connection = TapiConnection.create(TapiCepPair.create(DcsBasedTapiCepRef.create(connectionHandler.getCeps().get(0)), DcsBasedTapiCepRef.create(connectionHandler.getCeps().get(1))));
    this.connectionHandler = connectionHandler;
    this.connectionHandler.getLowerConnections().forEach(lowerConnectionHandler -> {
        delegateConnectionDeletion(lowerConnectionHandler);
    });
}
#method_after
private void deleteConnectionRecursively(TapiConnectionHandler connectionHandler) {
    op = Operation.DELETE;
    connectionManagerList.clear();
    // read target to be deleted
    connectionHandler.read();
    log.info("model: {}", connectionHandler.getModelObject());
    this.connection = TapiConnection.create(TapiCepPair.create(DcsBasedTapiObjectRefFactory.create(connectionHandler.getCeps().get(0)), DcsBasedTapiObjectRefFactory.create(connectionHandler.getCeps().get(1))));
    this.connectionHandler = connectionHandler;
    this.connectionHandler.getLowerConnections().forEach(lowerConnectionHandler -> {
        delegateConnectionDeletion(lowerConnectionHandler);
    });
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_ADDED || event.type() == CONFIG_UPDATED) {
        if (event.config().orElse(null) instanceof OdtnBaseConfig) {
            return true;
        }
    }
    if (event.type() == CONFIG_REMOVED) {
        if (event.prevConfig().orElse(null) instanceof OdtnBaseConfig) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_ADDED || event.type() == CONFIG_UPDATED) {
        if (event.config().orElse(null) instanceof TerminalDeviceConfig) {
            return true;
        }
    }
    if (event.type() == CONFIG_REMOVED) {
        if (event.prevConfig().orElse(null) instanceof TerminalDeviceConfig) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private static PiHeader decodeHeader(P4Types.P4Header p4Header) {
    List<ImmutableByteSequence> bitStrings = p4Header.getBitstringsList().stream().map(bit -> ImmutableByteSequence.copyFrom(bit.asReadOnlyByteBuffer())).collect(Collectors.toList());
    return new PiHeader(p4Header.getIsValid(), bitStrings);
}
#method_after
private static PiHeader decodeHeader(P4Types.P4Header p4Header) {
    List<ImmutableByteSequence> bitStrings = p4Header.getBitstringsList().stream().map(bit -> ImmutableByteSequence.copyFrom(bit.asReadOnlyByteBuffer())).collect(Collectors.toList());
    return PiHeader.of(p4Header.getIsValid(), bitStrings);
}
#end_block

#method_before
private static P4Types.P4HeaderUnion encodeHeaderUnion(PiHeaderUnion headerUnion) {
    P4Types.P4HeaderUnion.Builder builder = P4Types.P4HeaderUnion.newBuilder();
    builder.setValidHeader(encodeHeader(headerUnion.header()));
    return builder.setValidHeaderName(headerUnion.headerName()).build();
}
#method_after
private static P4Types.P4HeaderUnion encodeHeaderUnion(PiHeaderUnion headerUnion) {
    P4Types.P4HeaderUnion.Builder builder = P4Types.P4HeaderUnion.newBuilder();
    if (headerUnion.isValid()) {
        builder.setValidHeader(encodeHeader(headerUnion.header()));
        builder.setValidHeaderName(headerUnion.headerName());
    } else {
        // An empty string indicates that none of the union members are valid and
        // valid_header must therefore be unset.
        builder.setValidHeaderName("");
    }
    return builder.build();
}
#end_block

#method_before
private static PiHeaderUnion decodeHeaderUnion(P4Types.P4HeaderUnion p4HeaderUnion) {
    return new PiHeaderUnion(p4HeaderUnion.getValidHeaderName(), decodeHeader(p4HeaderUnion.getValidHeader()));
}
#method_after
private static PiHeaderUnion decodeHeaderUnion(P4Types.P4HeaderUnion p4HeaderUnion) {
    return PiHeaderUnion.of(p4HeaderUnion.getValidHeaderName(), decodeHeader(p4HeaderUnion.getValidHeader()));
}
#end_block

#method_before
private static PiStruct decodeStruct(P4Types.P4StructLike p4StructLike) {
    return new PiStruct(p4StructLike.getMembersList().stream().map(p4Data -> decodeP4Data(p4Data)).collect(Collectors.toList()));
}
#method_after
private static PiStruct decodeStruct(P4Types.P4StructLike p4StructLike) {
    return PiStruct.of(p4StructLike.getMembersList().stream().map(p4Data -> decodeP4Data(p4Data)).collect(Collectors.toList()));
}
#end_block

#method_before
private static PiTuple decodeTuple(P4Types.P4StructLike p4StructLike) {
    return new PiTuple(p4StructLike.getMembersList().stream().map(p4Data -> decodeP4Data(p4Data)).collect(Collectors.toList()));
}
#method_after
private static PiTuple decodeTuple(P4Types.P4StructLike p4StructLike) {
    return PiTuple.of(p4StructLike.getMembersList().stream().map(p4Data -> decodeP4Data(p4Data)).collect(Collectors.toList()));
}
#end_block

#method_before
static P4Types.P4Data encodeP4Data(PiData piData) {
    P4Types.P4Data.Builder builder = P4Types.P4Data.newBuilder();
    if (piData instanceof PiBitString) {
        builder.setBitstring(ByteString.copyFrom(((PiBitString) piData).bitString().asArray()));
    } else if (piData instanceof PiBool) {
        builder.setBool(((PiBool) piData).bool());
    } else if (piData instanceof PiEnumStr) {
        builder.setEnum(((PiEnumStr) piData).enumStr());
    } else if (piData instanceof PiErrorStr) {
        builder.setError(((PiErrorStr) piData).errorStr());
    } else if (piData instanceof PiHeader) {
        builder.setHeader(encodeHeader((PiHeader) piData));
    } else if (piData instanceof PiHeaderUnion) {
        builder.setHeaderUnion(encodeHeaderUnion((PiHeaderUnion) piData));
    } else if (piData instanceof PiStruct) {
        builder.setStruct(encodeStruct((PiStruct) piData));
    } else if (piData instanceof PiTuple) {
        builder.setTuple(encodeTuple((PiTuple) piData));
    } else if (piData instanceof PiHeaderStack) {
        P4Types.P4HeaderStack.Builder headerStack = P4Types.P4HeaderStack.newBuilder();
        int i = 0;
        for (PiHeader header : ((PiHeaderStack) piData).headers()) {
            headerStack.setEntries(i, encodeHeader(header));
            i++;
        }
        builder.setHeaderStack(headerStack.build());
    } else if (piData instanceof PiHeaderUnionStack) {
        P4Types.P4HeaderUnionStack.Builder headerUnionStack = P4Types.P4HeaderUnionStack.newBuilder();
        int i = 0;
        for (PiHeaderUnion headerUnion : ((PiHeaderUnionStack) piData).headerUnions()) {
            headerUnionStack.setEntries(i, encodeHeaderUnion(headerUnion));
            i++;
        }
        builder.setHeaderUnionStack(headerUnionStack.build());
    }
    return builder.build();
}
#method_after
static P4Types.P4Data encodeP4Data(PiData piData) {
    P4Types.P4Data.Builder builder = P4Types.P4Data.newBuilder();
    switch(piData.type()) {
        case BITSTRING:
            builder.setBitstring(ByteString.copyFrom(((PiBitString) piData).bitString().asArray()));
            break;
        case ENUMSTRING:
            builder.setEnum(((PiEnumString) piData).enumString());
            break;
        case ERRORSTRING:
            builder.setError(((PiErrorString) piData).errorString());
            break;
        case BOOL:
            builder.setBool(((PiBool) piData).bool());
            break;
        case STRUCT:
            builder.setStruct(encodeStruct((PiStruct) piData));
            break;
        case TUPLE:
            builder.setTuple(encodeTuple((PiTuple) piData));
            break;
        case HEADER:
            builder.setHeader(encodeHeader((PiHeader) piData));
            break;
        case HEADERSTACK:
            P4Types.P4HeaderStack.Builder headerStack = P4Types.P4HeaderStack.newBuilder();
            int i = 0;
            for (PiHeader header : ((PiHeaderStack) piData).headers()) {
                headerStack.setEntries(i, encodeHeader(header));
                i++;
            }
            builder.setHeaderStack(headerStack.build());
            break;
        case HEADERUNION:
            builder.setHeaderUnion(encodeHeaderUnion((PiHeaderUnion) piData));
            break;
        case HEADERUNIONSTACK:
            P4Types.P4HeaderUnionStack.Builder headerUnionStack = P4Types.P4HeaderUnionStack.newBuilder();
            int j = 0;
            for (PiHeaderUnion headerUnion : ((PiHeaderUnionStack) piData).headerUnions()) {
                headerUnionStack.setEntries(j, encodeHeaderUnion(headerUnion));
                j++;
            }
            builder.setHeaderUnionStack(headerUnionStack.build());
            break;
        default:
            break;
    }
    return builder.build();
}
#end_block

#method_before
static PiData decodeP4Data(P4Types.P4Data p4Data) {
    if (p4Data.getDataCase().getNumber() == 1) {
        return new PiBitString(ImmutableByteSequence.copyFrom(p4Data.getBitstring().asReadOnlyByteBuffer()));
    } else if (p4Data.getDataCase().getNumber() == 2) {
        return new PiBool(p4Data.getBool());
    } else if (p4Data.getDataCase().getNumber() == 3) {
        return decodeTuple(p4Data.getTuple());
    } else if (p4Data.getDataCase().getNumber() == 4) {
        return decodeStruct(p4Data.getStruct());
    } else if (p4Data.getDataCase().getNumber() == 5) {
        return decodeHeader(p4Data.getHeader());
    } else if (p4Data.getDataCase().getNumber() == 6) {
        return decodeHeaderUnion(p4Data.getHeaderUnion());
    } else if (p4Data.getDataCase().getNumber() == 7) {
        return new PiHeaderStack(p4Data.getHeaderStack().getEntriesList().stream().map(p4header -> decodeHeader(p4header)).collect(Collectors.toList()));
    } else if (p4Data.getDataCase().getNumber() == 8) {
        return new PiHeaderUnionStack(p4Data.getHeaderUnionStack().getEntriesList().stream().map(p4HeaderUnion -> decodeHeaderUnion(p4HeaderUnion)).collect(Collectors.toList()));
    } else if (p4Data.getDataCase().getNumber() == 9) {
        return new PiEnumStr(p4Data.getEnum());
    } else if (p4Data.getDataCase().getNumber() == 10) {
        return new PiErrorStr(p4Data.getError());
    }
    return null;
}
#method_after
static PiData decodeP4Data(P4Types.P4Data p4Data) {
    PiData piData = null;
    switch(p4Data.getDataCase()) {
        case BITSTRING:
            piData = PiBitString.of(ImmutableByteSequence.copyFrom(p4Data.getBitstring().asReadOnlyByteBuffer()));
            break;
        case BOOL:
            piData = PiBool.of(p4Data.getBool());
            break;
        case TUPLE:
            piData = decodeTuple(p4Data.getTuple());
            break;
        case STRUCT:
            piData = decodeStruct(p4Data.getStruct());
            break;
        case HEADER:
            piData = decodeHeader(p4Data.getHeader());
            break;
        case HEADER_UNION:
            piData = decodeHeaderUnion(p4Data.getHeaderUnion());
            break;
        case HEADER_STACK:
            piData = PiHeaderStack.of(p4Data.getHeaderStack().getEntriesList().stream().map(p4header -> decodeHeader(p4header)).collect(Collectors.toList()));
            break;
        case HEADER_UNION_STACK:
            piData = PiHeaderUnionStack.of(p4Data.getHeaderUnionStack().getEntriesList().stream().map(p4HeaderUnion -> decodeHeaderUnion(p4HeaderUnion)).collect(Collectors.toList()));
            break;
        case ENUM:
            piData = PiEnumString.of(p4Data.getEnum());
            break;
        case ERROR:
            piData = PiErrorString.of(p4Data.getError());
            break;
        case DATA_NOT_SET:
            break;
        default:
            break;
    }
    return piData;
}
#end_block

#method_before
@Override
public List<ControllerInfo> getControllers() {
    List<ControllerInfo> controllers = new ArrayList<ControllerInfo>();
    DeviceId deviceId = handler().data().deviceId();
    String response;
    try {
        // "show openflow switch 1 controller" command only shows outputs with cli_ascii command type
        response = NxApiRequest.post(handler(), SHOW_OF_CONTROLLER_CMD, CommandType.CLI_ASCII);
    } catch (NullPointerException e) {
        log.error("Failed to perform {} command on the device {}", SHOW_OF_CONTROLLER_CMD, deviceId);
        return controllers;
    }
    if (Objects.isNull(response)) {
        throw new IllegalStateException("Response has Error/null");
    }
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        if (json.has("result")) {
            JsonNode res = json.get("result");
            String msg = res.findValue("msg").asText();
        } else if (json.has("error")) {
            throw new IllegalStateException("Response has Error/null");
        }
    } catch (IOException e) {
        log.error(e.toString());
    }
    return controllers;
}
#method_after
@Override
public List<ControllerInfo> getControllers() {
    List<ControllerInfo> controllers = new ArrayList<ControllerInfo>();
    DeviceId deviceId = handler().data().deviceId();
    String response;
    // "show openflow switch 1 controller" command only shows outputs with cli_ascii command type
    response = NxApiRequest.post(handler(), SHOW_OF_CONTROLLER_CMD, CommandType.CLI_ASCII);
    if (response == null) {
        log.error("Failed to perform {} command on the device {} Response has Error/null", SHOW_OF_CONTROLLER_CMD, deviceId);
        return controllers;
    }
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        if (json.has("result")) {
            JsonNode res = json.get("result");
            String msg = res.findValue("msg").asText();
        } else if (json.has("error")) {
            log.error("{} Response has IllegalStateException Error/null", deviceId);
            return controllers;
        }
    } catch (IOException e) {
        log.error("Exception thrown", e);
    }
    return controllers;
}
#end_block

#method_before
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    List<String> cmds = new ArrayList<>();
    cmds.add(OPENFLOW_CMD);
    cmds.add(DELETE_OF_CONFIG);
    cmds.add(SW1_CMD);
    cmds.add(PROTO_VER_CMD);
    cmds.add(PIPELINE_CMD);
    // can configure up to eight controllers
    controllers.stream().limit(8).forEach(c -> cmds.add(String.format(OF_CONTROLLER_CONF_CMD, c.ip().toString(), c.port(), "management")));
    cmds.add(NO_SHUTDOWN_CMD);
    cmds.add(COPY_RUNNING_CONFIG);
    String response = NxApiRequest.postClis(handler, cmds);
    if (Objects.isNull(response)) {
        throw new NullPointerException("Response is null");
    }
    if (response != null) {
        try {
            ObjectMapper om = new ObjectMapper();
            JsonNode json = om.readTree(response);
            // TODO parse error messages.
            if (json.has("error")) {
                throw new IllegalStateException("Respose has Errors");
            }
        } catch (IOException e) {
            log.error(e.toString());
        }
    } else {
        log.error("Can't reach the deviceId {}", deviceId);
    }
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    List<String> cmds = new ArrayList<>();
    cmds.add(OPENFLOW_CMD);
    cmds.add(DELETE_OF_CONFIG);
    cmds.add(SW1_CMD);
    cmds.add(PROTO_VER_CMD);
    cmds.add(PIPELINE_CMD);
    // can configure up to eight controllers
    controllers.stream().limit(8).forEach(c -> cmds.add(String.format(OF_CONTROLLER_CONF_CMD, c.ip().toString(), c.port(), "management")));
    cmds.add(NO_SHUTDOWN_CMD);
    cmds.add(COPY_RUNNING_CONFIG);
    String response = NxApiRequest.postClis(handler, cmds);
    if (Objects.isNull(response)) {
        throw new NullPointerException("Response is null");
    }
    if (response != null) {
        try {
            ObjectMapper om = new ObjectMapper();
            JsonNode json = om.readTree(response);
            // TODO parse error messages.
            if (json.has("error")) {
                log.error("{} Response has IllegalStateException Error", deviceId);
                return;
            }
        } catch (IOException e) {
            log.error("Exception thrown", e);
        }
    } else {
        log.error("Can't reach the deviceId {}", deviceId);
    }
}
#end_block

#method_before
@Override
public boolean createClient(DeviceId deviceId, long p4DeviceId, ManagedChannelBuilder channelBuilder) {
    checkNotNull(deviceId);
    checkNotNull(channelBuilder);
    deviceLocks.getUnchecked(deviceId).writeLock().lock();
    log.info("Creating client for {} (with internal device id {})...", deviceId, p4DeviceId);
    try {
        if (clients.containsKey(deviceId)) {
            log.info("A client already exists for {}", deviceId);
            return true;
        } else {
            return doCreateClient(deviceId, p4DeviceId, channelBuilder);
        }
    } finally {
        deviceLocks.getUnchecked(deviceId).writeLock().unlock();
    }
}
#method_after
@Override
public boolean createClient(DeviceId deviceId, long p4DeviceId, ManagedChannelBuilder channelBuilder) {
    checkNotNull(deviceId);
    checkNotNull(channelBuilder);
    deviceLocks.getUnchecked(deviceId).writeLock().lock();
    log.info("Creating client for {} (with internal device id {})...", deviceId, p4DeviceId);
    try {
        if (clients.containsKey(deviceId)) {
            // TODO might want to consider a more fine-grained check such as same port/p4DeviceId
            log.warn("A client already exists for {}", deviceId);
            throw new IllegalStateException(format("A client already exists for %s", deviceId));
        } else {
            return doCreateClient(deviceId, p4DeviceId, channelBuilder);
        }
    } finally {
        deviceLocks.getUnchecked(deviceId).writeLock().unlock();
    }
}
#end_block

#method_before
public void postEvent(P4RuntimeEvent event) {
    post(event);
}
#method_after
public void postEvent(P4RuntimeEvent event) {
    if (event.type().equals(P4RuntimeEvent.Type.CHANNEL_EVENT)) {
        DefaultChannelEvent channelError = (DefaultChannelEvent) event.subject();
        DeviceId deviceId = event.subject().deviceId();
        ChannelEvent channelEvent = null;
        // If disconnection is already known we propagate it.
        if (channelError.type().equals(ChannelEvent.Type.CHANNEL_DISCONNECTED)) {
            channelEvent = new ChannelEvent(ChannelEvent.Type.CHANNEL_DISCONNECTED, channelError.deviceId(), channelError.throwable());
        } else if (channelError.type().equals(ChannelEvent.Type.CHANNEL_ERROR)) {
            // If we don't know what the error is we check for reachability
            if (!isReacheable(deviceId)) {
                // if false the channel has disconnected
                channelEvent = new ChannelEvent(ChannelEvent.Type.CHANNEL_DISCONNECTED, channelError.deviceId(), channelError.throwable());
            } else {
                // else we propagate the event.
                channelEvent = new ChannelEvent(ChannelEvent.Type.CHANNEL_ERROR, channelError.deviceId(), channelError.throwable());
            }
        }
        // Ignoring CHANNEL_CONNECTED
        if (channelEvent != null && channelListeners.get(deviceId) != null) {
            for (ChannelListener listener : channelListeners.get(deviceId)) {
                listener.event(channelEvent);
            }
        }
    } else {
        post(event);
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> writeActionGroupMembers(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    return supplyInContext(() -> doWriteActionGroupMembers(group, opType, pipeconf), "writeActionGroupMembers-" + opType.name());
}
#method_after
@Override
public CompletableFuture<Boolean> writeActionGroupMembers(PiActionProfileId profileId, Collection<PiActionGroupMember> members, WriteOperationType opType, PiPipeconf pipeconf) {
    return supplyInContext(() -> doWriteActionGroupMembers(profileId, members, opType, pipeconf), "writeActionGroupMembers-" + opType.name());
}
#end_block

#method_before
/* Blocking method implementations below */
private boolean doArbitrationUpdate() {
    // it disconnects this behaviour is ok.
    if (p4RuntimeElectionId != null) {
        log.info("Election already done with success for device {}, election id {}", deviceId, p4RuntimeElectionId);
        return true;
    }
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    // TODO: currently we use 64-bit Long type for election id, should
    // we use 128-bit ?
    long nextElectId = controller.getNewMasterElectionId();
    Uint128 newElectionId = Uint128.newBuilder().setLow(nextElectId).build();
    MasterArbitrationUpdate arbitrationUpdate = MasterArbitrationUpdate.newBuilder().setDeviceId(p4DeviceId).setElectionId(newElectionId).build();
    StreamMessageRequest requestMsg = StreamMessageRequest.newBuilder().setArbitration(arbitrationUpdate).build();
    log.debug("Sending arbitration update to {} with election id {}...", deviceId, newElectionId);
    arbitrationUpdateMap.put(newElectionId, result);
    try {
        streamRequestObserver.onNext(requestMsg);
        return result.get();
    } catch (StatusRuntimeException e) {
        log.error("Unable to perform arbitration update on {}: {}", deviceId, e.getMessage());
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Arbitration update failed for {} due to {}", deviceId, e);
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    }
}
#method_after
/* Blocking method implementations below */
private boolean doArbitrationUpdate() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    // TODO: currently we use 64-bit Long type for election id, should
    // we use 128-bit ?
    long nextElectId = controller.getNewMasterElectionId();
    Uint128 newElectionId = Uint128.newBuilder().setLow(nextElectId).build();
    MasterArbitrationUpdate arbitrationUpdate = MasterArbitrationUpdate.newBuilder().setDeviceId(p4DeviceId).setElectionId(newElectionId).build();
    StreamMessageRequest requestMsg = StreamMessageRequest.newBuilder().setArbitration(arbitrationUpdate).build();
    log.debug("Sending arbitration update to {} with election id {}...", deviceId, newElectionId);
    arbitrationUpdateMap.put(newElectionId, result);
    try {
        streamRequestObserver.onNext(requestMsg);
        return result.get();
    } catch (StatusRuntimeException e) {
        log.error("Unable to perform arbitration update on {}: {}", deviceId, e.getMessage());
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Arbitration update failed for {} due to {}", deviceId, e);
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    }
}
#end_block

#method_before
private void doArbitrationUpdateFromDevice(MasterArbitrationUpdate arbitrationMsg) {
    log.debug("Received arbitration update from {}: {}", deviceId, arbitrationMsg);
    Uint128 electionId = arbitrationMsg.getElectionId();
    CompletableFuture<Boolean> mastershipFeature = arbitrationUpdateMap.remove(electionId);
    if (mastershipFeature == null) {
        log.warn("Can't find completable future of election id {}", electionId);
        return;
    }
    this.p4RuntimeElectionId = electionId;
    int statusCode = arbitrationMsg.getStatus().getCode();
    MastershipRole arbitrationRole;
    if (statusCode == Status.OK.getCode().value()) {
        mastershipFeature.complete(true);
        arbitrationRole = MastershipRole.MASTER;
    } else {
        mastershipFeature.complete(false);
        arbitrationRole = MastershipRole.STANDBY;
    }
    DefaultArbitration arbitrationEventSubject = new DefaultArbitration(arbitrationRole, electionId);
    P4RuntimeEvent event = new P4RuntimeEvent(P4RuntimeEvent.Type.ARBITRATION, arbitrationEventSubject);
    controller.postEvent(event);
}
#method_after
private void doArbitrationUpdateFromDevice(MasterArbitrationUpdate arbitrationMsg) {
    log.debug("Received arbitration update from {}: {}", deviceId, arbitrationMsg);
    Uint128 electionId = arbitrationMsg.getElectionId();
    CompletableFuture<Boolean> mastershipFeature = arbitrationUpdateMap.remove(electionId);
    if (mastershipFeature == null) {
        log.warn("Can't find completable future of election id {}", electionId);
        return;
    }
    this.p4RuntimeElectionId = electionId;
    int statusCode = arbitrationMsg.getStatus().getCode();
    MastershipRole arbitrationRole;
    if (statusCode == Status.OK.getCode().value()) {
        mastershipFeature.complete(true);
        arbitrationRole = MastershipRole.MASTER;
    } else {
        mastershipFeature.complete(false);
        arbitrationRole = MastershipRole.STANDBY;
    }
    DefaultArbitration arbitrationEventSubject = new DefaultArbitration(deviceId, arbitrationRole, electionId);
    P4RuntimeEvent event = new P4RuntimeEvent(P4RuntimeEvent.Type.ARBITRATION, arbitrationEventSubject);
    controller.postEvent(event);
}
#end_block

#method_before
private boolean doWriteActionGroupMembers(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final Collection<ActionProfileMember> actionProfileMembers = Lists.newArrayList();
    for (PiActionGroupMember member : group.members()) {
        try {
            actionProfileMembers.add(ActionProfileMemberEncoder.encode(group, member, pipeconf));
        } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
            log.warn("Unable to encode group member, aborting {} operation: {} [{}]", opType.name(), e.getMessage(), member.toString());
            return false;
        }
    }
    final Collection<Update> updateMsgs = actionProfileMembers.stream().map(actionProfileMember -> Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileMember(actionProfileMember).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        // Nothing to update.
        return true;
    }
    WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        logWriteErrors(group.members(), e, opType, "group member");
        return false;
    }
}
#method_after
private boolean doWriteActionGroupMembers(PiActionProfileId profileId, Collection<PiActionGroupMember> members, WriteOperationType opType, PiPipeconf pipeconf) {
    final Collection<ActionProfileMember> actionProfileMembers = Lists.newArrayList();
    for (PiActionGroupMember member : members) {
        try {
            actionProfileMembers.add(ActionProfileMemberEncoder.encode(profileId, member, pipeconf));
        } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
            log.warn("Unable to encode group member, aborting {} operation: {} [{}]", opType.name(), e.getMessage(), member.toString());
            return false;
        }
    }
    final Collection<Update> updateMsgs = actionProfileMembers.stream().map(actionProfileMember -> Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileMember(actionProfileMember).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        // Nothing to update.
        return true;
    }
    WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        logWriteErrors(members, e, opType, "group member");
        return false;
    }
}
#end_block

#method_before
@Override
public void onError(Throwable throwable) {
    log.warn("Error on stream channel for {}: {}", deviceId, Status.fromThrowable(throwable));
    if (!controller.isReacheable(deviceId)) {
        p4RuntimeElectionId = null;
        controller.removeClient(deviceId);
    // TODO notify core of device disconnection
    }
// FIXME: we might want to recreate the channel.
// In general, we want to be robust against any transient error and, if the channel is open, make sure the
// stream channel is always on.
}
#method_after
@Override
public void onError(Throwable throwable) {
    log.warn("Error on stream channel for {}: {}", deviceId, Status.fromThrowable(throwable));
    controller.postEvent(new P4RuntimeEvent(P4RuntimeEvent.Type.CHANNEL_EVENT, new DefaultChannelEvent(deviceId, ChannelEvent.Type.CHANNEL_ERROR, throwable)));
// FIXME: we might want to recreate the channel.
// In general, we want to be robust against any transient error and, if the channel is open, make sure the
// stream channel is always on.
}
#end_block

#method_before
@Override
public void onCompleted() {
    log.warn("Stream channel for {} has completed", deviceId);
// FIXME: same concern as before.
}
#method_after
@Override
public void onCompleted() {
    log.warn("Stream channel for {} has completed", deviceId);
    controller.postEvent(new P4RuntimeEvent(P4RuntimeEvent.Type.CHANNEL_EVENT, new DefaultChannelEvent(deviceId, ChannelEvent.Type.CHANNEL_DISCONNECTED, "Stream channel has completed")));
}
#end_block

#method_before
@Activate
public void activate() {
    providerService = providerRegistry.register(this);
    componentConfigService.registerProperties(getClass());
    coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    deviceService.addListener(deviceListener);
    handshakers.clear();
    // This will fail if ONOS has CFG and drivers which depend on this provider
    // are activated, failing due to not finding the driver.
    cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class).forEach(did -> connectionExecutor.execute(() -> connectDevice(did)));
    // Initiating a periodic check to see if any device is available again and reconnect it.
    avaliabilityCheckExecutor.scheduleAtFixedRate(this::scheduleDevicePolling, 60, deviceAvaliabilityPollFrequency, TimeUnit.SECONDS);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    providerService = providerRegistry.register(this);
    componentConfigService.registerProperties(getClass());
    coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    deviceService.addListener(deviceListener);
    handshakers.clear();
    // This will fail if ONOS has CFG and drivers which depend on this provider
    // are activated, failing due to not finding the driver.
    cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class).forEach(did -> connectionExecutor.execute(() -> connectDevice(did)));
    // Initiating a periodic check to see if any device is available again and reconnect it.
    availabilityCheckExecutor.scheduleAtFixedRate(this::scheduleDevicePolling, deviceAvailabilityPollFrequency, deviceAvailabilityPollFrequency, TimeUnit.SECONDS);
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        pollFrequency = Tools.getIntegerProperty(properties, "pollFrequency", DEFAULT_POLL_FREQUENCY_SECONDS);
        log.info("Configured. Poll frequency is configured to {} seconds", pollFrequency);
    }
    if (!scheduledTasks.isEmpty()) {
        // cancel all previous tasks
        scheduledTasks.values().forEach(task -> task.cancel(false));
        // resubmit task with new timeout.
        Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class);
        deviceSubjects.forEach(deviceId -> {
            if (!compareScheme(deviceId)) {
                // not under my scheme, skipping
                log.debug("{} is not my scheme, skipping", deviceId);
                return;
            }
            scheduledTasks.put(deviceId, scheduleStatistcsPolling(deviceId, true));
        });
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        pollFrequency = Tools.getIntegerProperty(properties, POLL_FREQUENCY, DEFAULT_POLL_FREQUENCY_SECONDS);
        log.info("Configured. Poll frequency is configured to {} seconds", pollFrequency);
    }
    if (!scheduledTasks.isEmpty()) {
        // cancel all previous tasks
        scheduledTasks.values().forEach(task -> task.cancel(false));
        // resubmit task with new timeout.
        Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class);
        deviceSubjects.forEach(deviceId -> {
            if (!compareScheme(deviceId)) {
                // not under my scheme, skipping
                log.debug("{} is not my scheme, skipping", deviceId);
                return;
            }
            scheduledTasks.put(deviceId, scheduleStatistcsPolling(deviceId, true));
        });
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    portStatsExecutor.shutdown();
    componentConfigService.unregisterProperties(getClass(), false);
    cfgService.removeListener(cfgListener);
    // Not Removing the device so they can still be used from other driver providers
    // cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class)
    // .forEach(did -> connectionExecutor.execute(() -> disconnectDevice(did)));
    connectionExecutor.shutdown();
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    handshakers.clear();
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    portStatsExecutor.shutdown();
    availabilityCheckExecutor.shutdown();
    componentConfigService.unregisterProperties(getClass(), false);
    cfgService.removeListener(cfgListener);
    // Not Removing the device so they can still be used from other driver providers
    // cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class)
    // .forEach(did -> connectionExecutor.execute(() -> disconnectDevice(did)));
    connectionExecutor.shutdown();
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    handshakers.clear();
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public boolean isReachable(DeviceId deviceId) {
    log.debug("Testing reachability for device {}", deviceId);
    DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker == null) {
        return false;
    }
    CompletableFuture<Boolean> reachable = handshaker.isReachable();
    try {
        return reachable.get(REACHABILITY_TIMEOUT, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        log.warn("Device {} is not reachable", deviceId, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
@Override
public boolean isReachable(DeviceId deviceId) {
    log.debug("Testing reachability for device {}", deviceId);
    DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker == null) {
        return false;
    }
    CompletableFuture<Boolean> reachable = handshaker.isReachable();
    try {
        return reachable.get(REACHABILITY_TIMEOUT, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        log.warn("Device {} is not reachable {}", deviceId, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
@Override
public void triggerDisconnect(DeviceId deviceId) {
    log.debug("Triggering disconnection of device {}", deviceId);
    connectionExecutor.execute(() -> {
        CompletableFuture<Boolean> disconnected = disconnectDevice(deviceId);
        disconnected.whenComplete((success, ex) -> {
            checkAndConnect(deviceId);
        });
    });
}
#method_after
@Override
public void triggerDisconnect(DeviceId deviceId) {
    log.debug("Triggering disconnection of device {}", deviceId);
    connectionExecutor.execute(() -> {
        disconnectDevice(deviceId).whenComplete((success, ex) -> {
            checkAndConnect(deviceId);
        });
    });
}
#end_block

#method_before
private void connectDevice(DeviceId deviceId) {
    // retrieve the configuration
    GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (providerConfig == null || basicDeviceConfig == null) {
        log.error("Configuration is NULL: basic config {}, general provider " + "config {}", basicDeviceConfig, providerConfig);
    } else {
        log.info("Connecting to device {} with driver {}", deviceId, basicDeviceConfig.driver());
        DeviceHandshaker handshaker = getHandshaker(deviceId);
        if (handshaker == null) {
            log.error("Device {} does not support DeviceHandshaker behaviour", deviceId);
            return;
        }
        Driver driver = handshaker.handler().driver();
        addConfigData(providerConfig, handshaker.data());
        // Connecting to the device
        CompletableFuture<Boolean> connected = handshaker.connect();
        connected.thenAcceptAsync(result -> {
            if (result) {
                // Populated with the default values obtained by the driver
                ChassisId cid = new ChassisId();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, providerConfig.protocolsInfo().keySet().toString()).build();
                DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, driver.manufacturer(), driver.hwVersion(), driver.swVersion(), UNKNOWN, cid, true, annotations);
                // Empty list of ports
                List<PortDescription> ports = new ArrayList<>();
                DeviceDescriptionDiscovery deviceDiscovery = getBehaviour(driver, DeviceDescriptionDiscovery.class, handshaker.data());
                if (deviceDiscovery != null) {
                    DeviceDescription newdescription = deviceDiscovery.discoverDeviceDetails();
                    if (newdescription != null) {
                        description = newdescription;
                    }
                    ports = deviceDiscovery.discoverPortDetails();
                } else {
                    log.info("No Device Description Discovery for device {}, no update for " + "description or ports.", deviceId);
                }
                if (!handlePipeconf(deviceId, driver, handshaker.data(), true)) {
                    // Something went wrong during handling of pipeconf.
                    // We already logged the error.
                    handshaker.disconnect();
                    return;
                }
                advertiseDevice(deviceId, description, ports);
            } else {
                log.warn("Can't connect to device {}", deviceId);
            }
        });
    }
}
#method_after
private void connectDevice(DeviceId deviceId) {
    // retrieve the configuration
    GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (providerConfig == null || basicDeviceConfig == null) {
        log.error("Configuration is NULL: basic config {}, general provider " + "config {}", basicDeviceConfig, providerConfig);
    } else {
        log.info("Connecting to device {} with driver {}", deviceId, basicDeviceConfig.driver());
        DeviceHandshaker handshaker = getHandshaker(deviceId);
        if (handshaker == null) {
            log.error("Device {} does not support DeviceHandshaker behaviour", deviceId);
            return;
        }
        Driver driver = handshaker.handler().driver();
        addConfigData(providerConfig, handshaker.data());
        // Connecting to the device
        CompletableFuture<Boolean> connected = handshaker.connect();
        connected.thenAcceptAsync(result -> {
            if (result) {
                handshaker.addChannelListener(channelListener);
                // Populated with the default values obtained by the driver
                ChassisId cid = new ChassisId();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, providerConfig.protocolsInfo().keySet().toString()).build();
                DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, driver.manufacturer(), driver.hwVersion(), driver.swVersion(), UNKNOWN, cid, true, annotations);
                // Empty list of ports
                List<PortDescription> ports = new ArrayList<>();
                DeviceDescriptionDiscovery deviceDiscovery = getBehaviour(driver, DeviceDescriptionDiscovery.class, handshaker.data());
                if (deviceDiscovery != null) {
                    DeviceDescription newdescription = deviceDiscovery.discoverDeviceDetails();
                    if (newdescription != null) {
                        description = newdescription;
                    }
                    ports = deviceDiscovery.discoverPortDetails();
                } else {
                    log.info("No Device Description Discovery for device {}, no update for " + "description or ports.", deviceId);
                }
                if (!handlePipeconf(deviceId, driver, handshaker.data(), true)) {
                    // Something went wrong during handling of pipeconf.
                    // We already logged the error.
                    handshaker.disconnect();
                    return;
                }
                advertiseDevice(deviceId, description, ports);
            } else {
                log.warn("Can't connect to device {}", deviceId);
            }
        });
    }
}
#end_block

#method_before
private void connectStandbyDevice(DeviceId deviceId) {
    // if device is pipeline programmable we merge pipeconf + base driver for every other role
    GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker == null) {
        log.error("Device {} does not support DeviceHandshaker behaviour", deviceId);
        return;
    }
    addConfigData(providerConfig, handshaker.data());
    // Connecting to the device
    handshaker.connect().thenAcceptAsync(result -> {
        if (result) {
            handlePipeconf(deviceId, handshaker.handler().driver(), handshaker.data(), false);
        }
    });
}
#method_after
private void connectStandbyDevice(DeviceId deviceId) {
    // if device is pipeline programmable we merge pipeconf + base driver for every other role
    GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker == null) {
        log.error("Device {} does not support DeviceHandshaker behaviour", deviceId);
        return;
    }
    addConfigData(providerConfig, handshaker.data());
    // Connecting to the device
    handshaker.connect().thenAcceptAsync(result -> {
        if (result) {
            handshaker.addChannelListener(channelListener);
            handlePipeconf(deviceId, handshaker.handler().driver(), handshaker.data(), false);
        }
    });
}
#end_block

#method_before
private CompletableFuture<Boolean> disconnectDevice(DeviceId deviceId) {
    log.info("Disconnecting for device {}", deviceId);
    CompletableFuture<Boolean> disconnectError = new CompletableFuture<>();
    DeviceHandshaker handshaker = handshakers.remove(deviceId);
    if (handshaker != null) {
        CompletableFuture<Boolean> disconnect = handshaker.disconnect();
        disconnect.thenAcceptAsync(result -> {
            if (result) {
                log.info("Disconnected device {}", deviceId);
                providerService.deviceDisconnected(deviceId);
                disconnectError.complete(true);
            } else {
                disconnectError.complete(false);
                log.warn("Device {} was unable to disconnect", deviceId);
            }
        });
    } else {
        // gracefully ignoring.
        log.warn("No DeviceHandshaker for device {}, no guarantees of complete " + "shutdown of communication", deviceId);
        disconnectError.complete(false);
    }
    ScheduledFuture<?> pollingStatisticsTask = scheduledTasks.get(deviceId);
    if (pollingStatisticsTask != null) {
        pollingStatisticsTask.cancel(true);
    }
    return disconnectError;
}
#method_after
private CompletableFuture<Boolean> disconnectDevice(DeviceId deviceId) {
    log.info("Disconnecting for device {}", deviceId);
    CompletableFuture<Boolean> disconnectError = new CompletableFuture<>();
    DeviceHandshaker handshaker = handshakers.remove(deviceId);
    if (handshaker != null) {
        handshaker.disconnect().thenAcceptAsync(result -> {
            if (result) {
                log.info("Disconnected device {}", deviceId);
                providerService.deviceDisconnected(deviceId);
                disconnectError.complete(true);
            } else {
                disconnectError.complete(false);
                log.warn("Device {} was unable to disconnect", deviceId);
            }
        });
    } else {
        // gracefully ignoring.
        log.warn("No DeviceHandshaker for device {}, no guarantees of complete " + "shutdown of communication", deviceId);
        disconnectError.complete(false);
    }
    ScheduledFuture<?> pollingStatisticsTask = scheduledTasks.get(deviceId);
    if (pollingStatisticsTask != null) {
        pollingStatisticsTask.cancel(true);
        scheduledTasks.remove(deviceId);
    }
    return disconnectError;
}
#end_block

#method_before
private void checkAndConnect(DeviceId deviceId) {
    // not using isReachable(deviceId) since it requires the client which we destroy.
    if ((deviceService.getDevice(deviceId) == null || (!deviceService.isAvailable(deviceId) && mastershipService.getMasterFor(deviceId) == null)) && configIsPresent(deviceId)) {
        log.info("Trying to re-connect to device {}", deviceId);
        NodeId leaderNodeId = leadershipService.runForLeadership(DEPLOY + deviceId.toString() + PIPECONF_TOPIC).leader().nodeId();
        NodeId localNodeId = clusterService.getLocalNode().id();
        if (localNodeId.equals(leaderNodeId)) {
            log.debug("{} is leader for {}, initiating the connection and deploying pipeline", leaderNodeId, deviceId);
            checkAndSubmitDeviceTask(deviceId);
        } else {
            log.debug("{} is not leader for {}, initiating connection but not deploying pipeline, {} is LEADER", localNodeId, deviceId, leaderNodeId);
            connectionExecutor.submit(exceptionSafe(() -> connectStandbyDevice(deviceId)));
            // FIXME this will be removed when config is synced
            cleanUpConfigInfo(deviceId);
        }
    }
}
#method_after
private void checkAndConnect(DeviceId deviceId) {
    if ((deviceService.getDevice(deviceId) == null || (!deviceService.isAvailable(deviceId) && mastershipService.getMasterFor(deviceId) == null)) && configIsPresent(deviceId)) {
        log.debug("Trying to re-connect to device {}", deviceId);
        NodeId leaderNodeId = leadershipService.runForLeadership(CHECK + deviceId.toString() + CONNECTION).leader().nodeId();
        NodeId localNodeId = clusterService.getLocalNode().id();
        if (localNodeId.equals(leaderNodeId)) {
            log.debug("{} is leader for {}, initiating the connection", leaderNodeId, deviceId);
            checkAndSubmitDeviceTask(deviceId);
        } else {
            log.debug("{} is not leader for {}, initiating connection, {} is LEADER", localNodeId, deviceId, leaderNodeId);
            connectionExecutor.submit(exceptionSafe(() -> connectStandbyDevice(deviceId)));
            // FIXME this will be removed when config is synced
            cleanUpConfigInfo(deviceId);
        }
    } else if ((deviceService.getDevice(deviceId) != null && deviceService.isAvailable(deviceId) && mastershipService.isLocalMaster(deviceId) && !isReachable(deviceId) && configIsPresent(deviceId))) {
        log.info("Removing available but unreachable device {}", deviceId);
        disconnectDevice(deviceId);
        providerService.deviceDisconnected(deviceId);
    }
}
#end_block

#method_before
private boolean configIsPresent(DeviceId deviceId) {
    boolean present = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class) != null && cfgService.getConfig(deviceId, BasicDeviceConfig.class) != null && cfgService.getConfig(deviceId, PiPipeconfConfig.class) != null;
    if (!present) {
        log.warn("Configuration for device {} is not complete", deviceId);
    }
    return present;
}
#method_after
private boolean configIsPresent(DeviceId deviceId) {
    boolean present = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class) != null && cfgService.getConfig(deviceId, BasicDeviceConfig.class) != null;
    if (!present) {
        log.warn("Configuration for device {} is not complete", deviceId);
    }
    return present;
}
#end_block

#method_before
@Override
public void processInitState(OpenstackNode osNode) {
    if (!isOvsdbConnected(osNode)) {
        ovsdbController.connect(osNode.managementIp(), tpPort(ovsdbPort));
        return;
    }
    if (!deviceService.isAvailable(osNode.intgBridge())) {
        createBridge(osNode, INTEGRATION_BRIDGE, osNode.intgBridge());
    }
}
#method_after
@Override
public void processInitState(OpenstackNode osNode) {
    if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
        ovsdbController.connect(osNode.managementIp(), tpPort(ovsdbPort));
        return;
    }
    if (!deviceService.isAvailable(osNode.intgBridge())) {
        createBridge(osNode, INTEGRATION_BRIDGE, osNode.intgBridge());
    }
}
#end_block

#method_before
@Override
public void processDeviceCreatedState(OpenstackNode osNode) {
    try {
        if (!isOvsdbConnected(osNode)) {
            ovsdbController.connect(osNode.managementIp(), tpPort(ovsdbPort));
            return;
        }
        if (osNode.type() == GATEWAY) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.uplinkPort(), true);
        }
        if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
            createTunnelInterface(osNode);
        }
        if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.vlanIntf(), true);
        }
        osNode.phyIntfs().forEach(i -> {
            if (!isIntfEnabled(osNode, i.intf())) {
                addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, i.intf(), true);
            }
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#method_after
@Override
public void processDeviceCreatedState(OpenstackNode osNode) {
    try {
        if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
            ovsdbController.connect(osNode.managementIp(), tpPort(ovsdbPort));
            return;
        }
        if (osNode.type() == GATEWAY) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.uplinkPort(), true);
        }
        if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
            createTunnelInterface(osNode);
        }
        if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
            addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, osNode.vlanIntf(), true);
        }
        osNode.phyIntfs().forEach(i -> {
            if (!isIntfEnabled(osNode, i.intf())) {
                addOrRemoveSystemInterface(osNode, INTEGRATION_BRIDGE, i.intf(), true);
            }
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#end_block

#method_before
@Override
public void processCompleteState(OpenstackNode osNode) {
    if (!osNodeService.vfPortsFromPortAddedMap(osNode).isEmpty()) {
        processVfPortAdded(osNode);
    }
    if (!osNodeService.vfPortsFromPortRemovedMap(osNode).isEmpty()) {
        processVfPortRemoved(osNode);
    }
    OvsdbClientService ovsdbClient = ovsdbController.getOvsdbClient(new OvsdbNodeId(osNode.managementIp(), ovsdbPort));
    if (ovsdbClient != null && ovsdbClient.isConnected()) {
        ovsdbClient.disconnect();
    }
}
#method_after
@Override
public void processCompleteState(OpenstackNode osNode) {
// Do something if needed
}
#end_block

#method_before
private boolean isCurrentStateDone(OpenstackNode osNode) {
    switch(osNode.state()) {
        case INIT:
            return deviceService.isAvailable(osNode.intgBridge());
        case DEVICE_CREATED:
            if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
                return false;
            }
            if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
                return false;
            }
            if (osNode.type() == GATEWAY && !isIntfEnabled(osNode, osNode.uplinkPort())) {
                return false;
            }
            for (OpenstackPhyInterface intf : osNode.phyIntfs()) {
                if (intf != null && !isIntfEnabled(osNode, intf.intf())) {
                    return false;
                }
            }
            return true;
        case COMPLETE:
        case INCOMPLETE:
            // run init CLI to re-trigger node bootstrap
            return false;
        default:
            return true;
    }
}
#method_after
private boolean isCurrentStateDone(OpenstackNode osNode) {
    switch(osNode.state()) {
        case INIT:
            if (!isOvsdbConnected(osNode, ovsdbPort, ovsdbController, deviceService)) {
                return false;
            }
            return deviceService.isAvailable(osNode.intgBridge());
        case DEVICE_CREATED:
            if (osNode.dataIp() != null && !isIntfEnabled(osNode, DEFAULT_TUNNEL)) {
                return false;
            }
            if (osNode.vlanIntf() != null && !isIntfEnabled(osNode, osNode.vlanIntf())) {
                return false;
            }
            if (osNode.type() == GATEWAY && !isIntfEnabled(osNode, osNode.uplinkPort())) {
                return false;
            }
            for (OpenstackPhyInterface intf : osNode.phyIntfs()) {
                if (intf != null && !isIntfEnabled(osNode, intf.intf())) {
                    return false;
                }
            }
            return true;
        case COMPLETE:
        case INCOMPLETE:
            // run init CLI to re-trigger node bootstrap
            return false;
        default:
            return true;
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    OpenstackNode osNode = osNodeService.node(device.id());
    switch(event.type()) {
        case DEVICE_AVAILABILITY_CHANGED:
        case DEVICE_ADDED:
            eventExecutor.execute(() -> {
                if (deviceService.isAvailable(device.id())) {
                    log.debug("OVSDB {} detected", device.id());
                    bootstrapNode(osNode);
                } else if (osNode.state() == COMPLETE) {
                    log.debug("Removing OVSDB {}", device.id());
                    deviceAdminService.removeDevice(device.id());
                }
            });
            break;
        case PORT_ADDED:
        case PORT_REMOVED:
        case DEVICE_REMOVED:
        default:
            // do nothing
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    OpenstackNode osNode = osNodeService.node(device.id());
    switch(event.type()) {
        case DEVICE_AVAILABILITY_CHANGED:
        case DEVICE_ADDED:
            eventExecutor.execute(() -> {
                if (deviceService.isAvailable(device.id())) {
                    log.debug("OVSDB {} detected", device.id());
                    bootstrapNode(osNode);
                }
            });
            break;
        case PORT_ADDED:
        case PORT_REMOVED:
        case DEVICE_REMOVED:
        default:
            // do nothing
            break;
    }
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    List<Port> ports;
    ports = service.ports().stream().filter(port -> port.getvNicType().equals(DIRECT)).filter(port -> port.isAdminStateUp() && !port.getVifType().equals(UNBOUND)).collect(Collectors.toList());
    print(FORMAT, "ID", "Network", "MAC", "FIXED IPs", "PCI Slot", "Interface");
    for (Port port : ports) {
        List<String> fixedIps = port.getFixedIps().stream().map(IP::getIpAddress).collect(Collectors.toList());
        Network osNet = service.network(port.getNetworkId());
        print(FORMAT, port.getId(), osNet.getName(), port.getMacAddress(), fixedIps.isEmpty() ? "" : fixedIps, port.getProfile().get(PCISLOT).toString(), getIntfNameFromPciAddress(port));
    }
}
#method_after
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    List<Port> ports = service.ports().stream().filter(port -> port.getvNicType().equals(DIRECT)).filter(port -> port.isAdminStateUp() && !port.getVifType().equals(UNBOUND)).collect(Collectors.toList());
    print(FORMAT, "ID", "Network", "MAC", "FIXED IPs", "PCI Slot", "Interface");
    for (Port port : ports) {
        List<String> fixedIps = port.getFixedIps().stream().map(IP::getIpAddress).collect(Collectors.toList());
        Network osNet = service.network(port.getNetworkId());
        print(FORMAT, port.getId(), osNet.getName(), port.getMacAddress(), fixedIps.isEmpty() ? "" : fixedIps, port.getProfile() == null ? "" : port.getProfile().get(PCISLOT).toString(), getIntfNameFromPciAddress(port));
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    osNodeStore.setDelegate(delegate);
    vfPortAddedMap = storageService.<DeviceId, Set<String>>consistentMapBuilder().withSerializer(Serializer.using(SERIALIZER_PORT_MAP)).withName("vf-portaddedmap").withApplicationId(appId).build();
    vfPortRemovedMap = storageService.<DeviceId, Set<String>>consistentMapBuilder().withSerializer(Serializer.using(SERIALIZER_PORT_MAP)).withName("vf-portremovedmap").withApplicationId(appId).build();
    leadershipService.runForLeadership(appId.name());
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    osNodeStore.setDelegate(delegate);
    leadershipService.runForLeadership(appId.name());
    log.info("Started");
}
#end_block

#method_before
private void processCompleteNode(OpenstackNode osNode) {
    deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> port.annotations().value(PORT_NAME).startsWith(PORT_NAME_PREFIX_VM) && port.isEnabled()).forEach(port -> {
        log.debug("Instance port {} is detected from {}", port.annotations().value(PORT_NAME), osNode.hostname());
        processPortAdded(port);
    });
    deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> port.annotations().value(PORT_NAME).startsWith(PORT_NAME_PREFIX_CAVIUM) && port.isEnabled()).forEach(port -> {
        log.debug("Instance port {} is detected from {}", port.annotations().value(PORT_NAME), osNode.hostname());
        processPortAdded(port);
    });
    Tools.stream(hostService.getHosts()).filter(host -> deviceService.getPort(host.location().deviceId(), host.location().port()) == null).forEach(host -> {
        log.info("Remove stale host {}", host.id());
        hostProvider.hostVanished(host.id());
    });
}
#method_after
private void processCompleteNode(OpenstackNode osNode) {
    deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> port.annotations().value(PORT_NAME).startsWith(PORT_NAME_PREFIX_VM) && port.isEnabled()).forEach(port -> {
        log.debug("Instance port {} is detected from {}", port.annotations().value(PORT_NAME), osNode.hostname());
        processPortAdded(port);
    });
    PORT_NAME_PREFIX_MAP.values().forEach(portNamePrefix -> {
        deviceService.getPorts(osNode.intgBridge()).stream().filter(port -> port.annotations().value(PORT_NAME).startsWith(portNamePrefix) && port.isEnabled()).forEach(port -> {
            log.debug("Instance port {} is detected from {}", port.annotations().value(portNamePrefix), osNode.hostname());
            processPortAdded(port);
        });
    });
    Tools.stream(hostService.getHosts()).filter(host -> deviceService.getPort(host.location().deviceId(), host.location().port()) == null).forEach(host -> {
        log.info("Remove stale host {}", host.id());
        hostProvider.hostVanished(host.id());
    });
}
#end_block

#method_before
@Override
public void updateExternalPeerRouterMac(IpAddress ipAddress, MacAddress macAddress) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> new DefaultExternalPeerRouter(ipAddress, macAddress, existing.externalPeerRouterVlanId()));
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    log.info("Updated external peer router map {}", externalPeerRouterMap.get(ipAddress.toString()).value().toString());
}
#method_after
@Override
public void updateExternalPeerRouterMac(IpAddress ipAddress, MacAddress macAddress) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> new DefaultExternalPeerRouter(ipAddress, macAddress, existing.externalPeerRouterVlanId()));
        log.info("Updated external peer router map {}", externalPeerRouterMap.get(ipAddress.toString()).value().toString());
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#end_block

#method_before
private void processPortAdded(Port port) {
    if (!port.getvNicType().equals(DIRECT)) {
        log.trace("processPortAdded passed because of unsupported vNicType: {}", port.getvNicType());
        return;
    } else if (!port.isAdminStateUp() || port.getVifType().equals(UNBOUND)) {
        log.trace("processPortAdded passed because status: {}, adminStateUp: {}, vifType: {}", port.getState(), port.isAdminStateUp(), port.getVifType());
        return;
    } else {
        InstancePort instancePort = instancePortService.instancePort(port.getId());
        if (instancePort != null) {
            return;
        }
        Optional<OpenstackNode> osNode = osNodeService.completeNodes(COMPUTE).stream().filter(node -> node.hostname().equals(port.getHostId())).findAny();
        if (!osNode.isPresent()) {
            log.trace("processPortAdded failed because openstackNode doesn't exist that matches hostname {}", port.getHostId());
            return;
        }
        log.trace("Retrieved openstackNode: {}", osNode.get().toString());
        String intfName = getIntfNameFromPciAddress(port);
        if (intfName == null) {
            log.error("Failed to execute processPortAdded because of null interface name");
            return;
        }
        log.trace("Retrieved interface name: {}", intfName);
        osNodeService.addVfPortAddedMap(osNode.get(), intfName);
    }
}
#method_after
private void processPortAdded(Port port) {
    if (!port.getvNicType().equals(DIRECT)) {
        log.trace("processPortAdded skipped because of unsupported vNicType: {}", port.getvNicType());
        return;
    } else if (!port.isAdminStateUp() || port.getVifType().equals(UNBOUND)) {
        log.trace("processPortAdded skipped because of status: {}, adminStateUp: {}, vifType: {}", port.getState(), port.isAdminStateUp(), port.getVifType());
        return;
    } else {
        InstancePort instancePort = instancePortService.instancePort(port.getId());
        // Skip this if the instance port for the port id is already created.
        if (instancePort != null) {
            return;
        }
        Optional<OpenstackNode> osNode = osNodeService.completeNodes(COMPUTE).stream().filter(node -> node.hostname().equals(port.getHostId())).findAny();
        if (!osNode.isPresent()) {
            log.error("processPortAdded failed because openstackNode doesn't exist that matches hostname {}", port.getHostId());
            return;
        }
        log.trace("Retrieved openstackNode: {}", osNode.get().toString());
        String intfName = getIntfNameFromPciAddress(port);
        if (intfName == null) {
            log.error("Failed to execute processPortAdded because of null interface name");
            return;
        }
        log.trace("Retrieved interface name: {}", intfName);
        osNodeService.addVfPort(osNode.get(), intfName);
    }
}
#end_block

#method_before
private void processPortRemoved(Port port) {
    if (!port.getvNicType().equals(DIRECT)) {
        log.trace("processPortRemoved passed because of unsupported vNicType: {}", port.getvNicType());
        return;
    } else if (instancePortService.instancePort(port.getId()) == null) {
        log.trace("processPortRemoved passed because no instance port exist for portId: {}", port.getId());
        return;
    } else {
        InstancePort instancePort = instancePortService.instancePort(port.getId());
        if (instancePort == null) {
            return;
        }
        DeviceId deviceId = instancePort.deviceId();
        if (deviceId == null) {
            return;
        }
        OpenstackNode osNode = osNodeService.node(deviceId);
        if (osNode == null) {
            return;
        }
        Optional<org.onosproject.net.Port> removedPort = deviceService.getPorts(deviceId).stream().filter(p -> Objects.equals(p.number(), instancePort.portNumber())).findAny();
        if (!removedPort.isPresent()) {
            log.error("Failed to execute processPortAdded because port number doesn't exist");
            return;
        }
        String intfName = removedPort.get().annotations().value(PORT_NAME);
        if (intfName == null) {
            log.error("Failed to execute processPortAdded because of null interface name");
            return;
        }
        log.trace("Retrieved interface name: {}", intfName);
        osNodeService.addVfPortRemovedMap(osNode, intfName);
    }
}
#method_after
private void processPortRemoved(Port port) {
    if (!port.getvNicType().equals(DIRECT)) {
        log.trace("processPortRemoved skipped because of unsupported vNicType: {}", port.getvNicType());
        return;
    } else if (instancePortService.instancePort(port.getId()) == null) {
        log.trace("processPortRemoved skipped because no instance port exist for portId: {}", port.getId());
        return;
    } else {
        InstancePort instancePort = instancePortService.instancePort(port.getId());
        if (instancePort == null) {
            return;
        }
        DeviceId deviceId = instancePort.deviceId();
        if (deviceId == null) {
            return;
        }
        OpenstackNode osNode = osNodeService.node(deviceId);
        if (osNode == null) {
            return;
        }
        Optional<org.onosproject.net.Port> removedPort = deviceService.getPorts(deviceId).stream().filter(p -> Objects.equals(p.number(), instancePort.portNumber())).findAny();
        if (!removedPort.isPresent()) {
            log.error("Failed to execute processPortAdded because port number doesn't exist");
            return;
        }
        String intfName = removedPort.get().annotations().value(PORT_NAME);
        if (intfName == null) {
            log.error("Failed to execute processPortAdded because of null interface name");
            return;
        }
        log.trace("Retrieved interface name: {}", intfName);
        osNodeService.removeVfPort(osNode, intfName);
    }
}
#end_block

#method_before
private void processYangFiles(YangCompilationParam param) throws IOException {
    YangPluginConfig config = new YangPluginConfig();
    synchronized (YangCompilerManager.class) {
        try {
            String codeGenDir = param.getCodeGenDir() + SLASH;
            String resourceGenDir = param.getMetadataGenDir() + SLASH;
            config.setCodeGenDir(codeGenDir);
            config.resourceGenDir(resourceGenDir);
            yangFileInfoSet = createYangFileInfoSet(param.getYangFiles());
            // Check if there are any file to translate, if not return.
            if (yangFileInfoSet.isEmpty()) {
                // No files to translate
                return;
            }
            // Create resource directory.
            createDirectories(resourceGenDir);
            // Resolve inter jar dependency.
            addSchemaToFileSet(dependentSchema(param.getDependentSchemas().stream().filter(path -> path.endsWith("YangMetaData.ser")).collect(Collectors.toSet())));
            // Carry out the parsing for all the YANG files.
            parseYangFileInfoSet();
            createYangNodeSet();
            // Serialize data model.
            processSerialization(resourceGenDir, param.getModelId());
            // Resolve dependencies using linker.
            try {
                resolveDependenciesUsingLinker();
            } catch (Exception e) {
                log.error("DependentSchemas: {}", dependentSchema(param.getDependentSchemas()).stream().map(YangNode::getName).collect(Collectors.toList()), e);
                throw e;
            }
            // Perform translation to JAVA.
            translateToJava(config);
            // add to generated java code map
            processGeneratedCode(codeGenDir);
            // add YANG files to JAR
            processCopyYangFile(resourceGenDir);
        } catch (IOException | ParserException e) {
            // TODO: provide unified framework for exceptions
            YangCompilerException exception = new YangCompilerException(e.getMessage(), e);
            exception.setYangFile(get(curYangFileInfo.getYangFileName()));
            if (curYangFileInfo != null && curYangFileInfo.getRootNode() != null) {
                try {
                    translatorErrorHandler(curYangFileInfo.getRootNode(), config);
                } catch (IOException ex) {
                    e.printStackTrace();
                    throw ex;
                }
            }
            throw exception;
        }
    }
}
#method_after
private void processYangFiles(YangCompilationParam param) throws IOException {
    YangPluginConfig config = new YangPluginConfig();
    synchronized (YangCompilerManager.class) {
        try {
            String codeGenDir = param.getCodeGenDir() + SLASH;
            String resourceGenDir = param.getMetadataGenDir() + SLASH;
            config.setCodeGenDir(codeGenDir);
            config.resourceGenDir(resourceGenDir);
            yangFileInfoSet = createYangFileInfoSet(param.getYangFiles());
            // Check if there are any file to translate, if not return.
            if (yangFileInfoSet.isEmpty()) {
                // No files to translate
                return;
            }
            // Create resource directory.
            createDirectories(resourceGenDir);
            // Resolve inter jar dependency.
            addSchemaToFileSet(dependentSchema(param.getDependentSchemas()));
            // Carry out the parsing for all the YANG files.
            parseYangFileInfoSet();
            createYangNodeSet();
            // Serialize data model.
            processSerialization(resourceGenDir, param.getModelId());
            // Resolve dependencies using linker.
            try {
                resolveDependenciesUsingLinker();
            } catch (Exception e) {
                log.error("DependentSchemas: {}", dependentSchema(param.getDependentSchemas()).stream().map(YangNode::getName).collect(Collectors.toList()), e);
                throw e;
            }
            // Perform translation to JAVA.
            translateToJava(config);
            // add to generated java code map
            processGeneratedCode(codeGenDir);
            // add YANG files to JAR
            processCopyYangFile(resourceGenDir);
        } catch (IOException | ParserException e) {
            // TODO: provide unified framework for exceptions
            YangCompilerException exception = new YangCompilerException(e.getMessage(), e);
            exception.setYangFile(get(curYangFileInfo.getYangFileName()));
            if (curYangFileInfo != null && curYangFileInfo.getRootNode() != null) {
                try {
                    translatorErrorHandler(curYangFileInfo.getRootNode(), config);
                } catch (IOException ex) {
                    e.printStackTrace();
                    throw ex;
                }
            }
            throw exception;
        }
    }
}
#end_block

#method_before
private Set<YangNode> dependentSchema(Set<Path> dependentSchemaPath) {
    Set<YangNode> depNodes = new LinkedHashSet<>();
    for (Path path : dependentSchemaPath) {
        log.error("from file:{}", path.getParent());
        try {
            Set<YangNode> yangNodes = getYangNodes(deSerializeDataModel(path.toString()));
            log.error(" got: {}", yangNodes.stream().map(YangNode::getName).collect(Collectors.toList()));
            depNodes.addAll(yangNodes);
        } catch (IOException e) {
            throw new YangCompilerException("Failed to fetch dependent schema from given " + "path :" + path.toString(), e);
        }
    }
    return depNodes;
}
#method_after
private Set<YangNode> dependentSchema(Set<Path> dependentSchemaPath) {
    Set<YangNode> depNodes = new LinkedHashSet<>();
    for (Path path : dependentSchemaPath) {
        log.trace("from file:{}", path.getParent());
        try {
            Set<YangNode> yangNodes = getYangNodes(deSerializeDataModel(path.toString()));
            if (log.isTraceEnabled()) {
                log.trace(" got: {}", yangNodes.stream().map(YangNode::getName).collect(Collectors.toList()));
            }
            depNodes.addAll(yangNodes);
        } catch (IOException e) {
            throw new YangCompilerException("Failed to fetch dependent schema from given " + "path :" + path.toString(), e);
        }
    }
    return depNodes;
}
#end_block

#method_before
public void processSerialization(String path, String id) throws IOException {
    List<YangNodeInfo> nodeInfo = new ArrayList<>();
    setNodeInfo(yangFileInfoSet, nodeInfo);
    model = processYangModel(path, nodeInfo, id, false);
    String serFileName = path + YANG_META_DATA;
    try (FileOutputStream fileOutputStream = new FileOutputStream(serFileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) {
        objectOutputStream.writeObject(model);
    }
}
#method_after
public void processSerialization(String path, String id) throws IOException {
    List<YangNodeInfo> nodeInfo = new ArrayList<>();
    setNodeInfo(yangFileInfoSet, nodeInfo);
    model = processYangModel(path, nodeInfo, id, false);
    String serFileName = path + YANG_META_DATA;
    try (FileOutputStream out = new FileOutputStream(serFileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new BufferedOutputStream(out))) {
        objectOutputStream.writeObject(model);
    }
}
#end_block

#method_before
private static void serializeModuleMetaData(String serFileName, YangNode node) {
    try (FileOutputStream outStream = new FileOutputStream(serFileName);
        ObjectOutputStream objOutStream = new ObjectOutputStream(outStream)) {
        objOutStream.writeObject(node);
    } catch (IOException e) {
        log.info("Error while serializing YANG node", e);
    }
}
#method_after
private static void serializeModuleMetaData(String serFileName, YangNode node) {
    try (FileOutputStream outStream = new FileOutputStream(serFileName);
        ObjectOutputStream objOutStream = new ObjectOutputStream(new BufferedOutputStream(outStream))) {
        objOutStream.writeObject(node);
    } catch (IOException e) {
        log.info("Error while serializing YANG node", e);
    }
}
#end_block

#method_before
public static YangModel deSerializeDataModel(String info) throws IOException {
    YangModel model;
    try (FileInputStream fileInputStream = new FileInputStream(info);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) {
        model = ((YangModel) objectInputStream.readObject());
    } catch (IOException | ClassNotFoundException e) {
        throw new IOException(info + " failed to fetch nodes due to " + e.getLocalizedMessage(), e);
    }
    return model;
}
#method_after
public static YangModel deSerializeDataModel(String info) throws IOException {
    YangModel model;
    try (FileInputStream fileInputStream = new FileInputStream(info);
        ObjectInputStream objectInputStream = new ObjectInputStream(new BufferedInputStream(fileInputStream))) {
        model = ((YangModel) objectInputStream.readObject());
    } catch (IOException | ClassNotFoundException e) {
        throw new IOException(info + " failed to fetch nodes due to " + e.getLocalizedMessage(), e);
    }
    return model;
}
#end_block

#method_before
public static YangModel parseJarFile(String jarFile, String directory) throws IOException {
    log.info("Searching YangModel in {}", jarFile);
    YangModel model = null;
    try (JarFile jar = new JarFile(jarFile)) {
        Enumeration<?> enumEntries = jar.entries();
        File dir = new File(directory + SLASH + YANG_RESOURCES);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        while (enumEntries.hasMoreElements()) {
            JarEntry file = (JarEntry) enumEntries.nextElement();
            if (file.getName().endsWith(YANG_META_DATA) || file.getName().endsWith(".yang")) {
                String name = getFileName(file.getName());
                File serializedFile = new File(directory + SLASH + YANG_RESOURCES + SLASH + name);
                if (file.isDirectory()) {
                    serializedFile.mkdirs();
                    continue;
                }
                try (InputStream inputStream = jar.getInputStream(file);
                    FileOutputStream fileOutputStream = new FileOutputStream(serializedFile)) {
                    while (inputStream.available() > 0) {
                        fileOutputStream.write(inputStream.read());
                    }
                    if (serializedFile.getName().endsWith(YANG_META_DATA)) {
                        model = deSerializeDataModel(serializedFile.toString());
                        log.info(" found {} at {}", model.getYangModelId(), serializedFile.getName());
                        // FIXME hack to return first mode model found
                        return model;
                    }
                }
            }
        }
    }
    return model;
}
#method_after
public static YangModel parseJarFile(String jarFile, String directory) throws IOException {
    log.trace("Searching YangModel in {}", jarFile);
    YangModel model = null;
    try (JarFile jar = new JarFile(jarFile)) {
        Enumeration<?> enumEntries = jar.entries();
        File dir = new File(directory + SLASH + YANG_RESOURCES);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        while (enumEntries.hasMoreElements()) {
            JarEntry file = (JarEntry) enumEntries.nextElement();
            if (file.getName().endsWith(YANG_META_DATA) || file.getName().endsWith(".yang")) {
                String name = getFileName(file.getName());
                File serializedFile = new File(directory + SLASH + YANG_RESOURCES + SLASH + name);
                if (file.isDirectory()) {
                    serializedFile.mkdirs();
                    continue;
                }
                try (InputStream inputStream = jar.getInputStream(file);
                    FileOutputStream fileOutputStream = new FileOutputStream(serializedFile)) {
                    IOUtils.copy(inputStream, fileOutputStream);
                    fileOutputStream.close();
                    // FIXME hack to return first model found
                    if (model == null && serializedFile.getName().endsWith(YANG_META_DATA)) {
                        model = deSerializeDataModel(serializedFile.toString());
                        log.trace(" found {} at {}", model.getYangModelId(), serializedFile.getName());
                    }
                }
            }
        }
    }
    return model;
}
#end_block

#method_before
public static File parseDepSchemaPath(String jarFile, String directory) throws IOException {
    log.info("From jarfile: {}", jarFile);
    try (JarFile jar = new JarFile(jarFile)) {
        Enumeration<?> enumEntries = jar.entries();
        File serializedFile = null;
        while (enumEntries.hasMoreElements()) {
            JarEntry file = (JarEntry) enumEntries.nextElement();
            if (file.getName().endsWith("YangMetaData.ser")) {
                Path jarRelPath = Paths.get(file.getName());
                Path outBase = Paths.get(directory);
                // inject input jar basename right before the filename.
                Path serializedPath = outBase.resolve(jarRelPath.getParent()).resolve(Paths.get(jarFile).getFileName()).resolve(jarRelPath.getFileName());
                if (Files.isDirectory(serializedPath)) {
                    Files.createDirectories(serializedPath.getParent());
                    continue;
                } else {
                    Files.createDirectories(serializedPath.getParent());
                }
                serializedFile = serializedPath.toFile();
                log.info(" writing {} to {}", file.getName(), serializedFile);
                InputStream inputStream = jar.getInputStream(file);
                FileOutputStream fileOutputStream = new FileOutputStream(serializedFile);
                IOUtils.copy(inputStream, fileOutputStream);
                fileOutputStream.close();
                inputStream.close();
                // found one then we should break the loop.
                return serializedFile;
            }
        }
    }
    // Not found
    return null;
}
#method_after
public static File parseDepSchemaPath(String jarFile, String directory) throws IOException {
    log.trace("From jarfile: {}", jarFile);
    try (JarFile jar = new JarFile(jarFile)) {
        Enumeration<?> enumEntries = jar.entries();
        File serializedFile = null;
        while (enumEntries.hasMoreElements()) {
            JarEntry file = (JarEntry) enumEntries.nextElement();
            if (file.getName().endsWith("YangMetaData.ser")) {
                Path jarRelPath = Paths.get(file.getName());
                Path outBase = Paths.get(directory);
                String inFilename = Paths.get(jarFile).getFileName().toString();
                String inBasename = inFilename.substring(0, inFilename.length() - ".jar".length());
                // inject input jar basename right before the filename.
                Path serializedPath = outBase.resolve(jarRelPath.getParent()).resolve(inBasename).resolve(jarRelPath.getFileName());
                if (Files.isDirectory(serializedPath)) {
                    Files.createDirectories(serializedPath.getParent());
                    continue;
                } else {
                    Files.createDirectories(serializedPath.getParent());
                }
                serializedFile = serializedPath.toFile();
                log.trace(" writing {} to {}", file.getName(), serializedFile);
                InputStream inputStream = jar.getInputStream(file);
                FileOutputStream fileOutputStream = new FileOutputStream(serializedFile);
                IOUtils.copy(inputStream, fileOutputStream);
                fileOutputStream.close();
                inputStream.close();
                // found one then we should break the loop.
                return serializedFile;
            }
        }
    }
    // Not found
    return null;
}
#end_block

#method_before
public void execute() throws YangParsingException {
    synchronized (YangGenerator.class) {
        log.info("modelId: {}", modelId);
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Create compiler param.
        DefaultYangCompilationParam.Builder bldr = DefaultYangCompilationParam.builder();
        // Need to get dependent schema paths to give inter jar dependencies.
        for (String jar : depJar) {
            try {
                File path = parseDepSchemaPath(jar, outputDirectory);
                if (path != null) {
                    bldr.addDependentSchema(Paths.get(path.getAbsolutePath()));
                }
            } catch (IOException e) {
                throw new YangCompilerException("Failed to parse dependent schema path", e);
            }
        }
        bldr.setCodeGenDir(Paths.get(outputDirectory));
        bldr.setMetadataGenDir(Paths.get(outputDirectory + SLASH + YANG_RESOURCES + SLASH));
        for (File file : models) {
            bldr.addYangFile(Paths.get(file.getAbsolutePath()));
        }
        bldr.setModelId(modelId);
        // Compile yang files and generate java code.
        try {
            output = compiler.compileYangFiles(bldr.build());
        } catch (IOException e) {
            throw new YangParsingException(e);
        }
    }
}
#method_after
public void execute() throws YangParsingException {
    synchronized (YangGenerator.class) {
        log.info("modelId: {}", modelId);
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Create compiler param.
        DefaultYangCompilationParam.Builder bldr = DefaultYangCompilationParam.builder();
        // Need to get dependent schema paths to give inter jar dependencies.
        for (String jar : depJar) {
            try {
                // Note: when there's multiple deps, it all gets copied to
                // same directory.
                File path = parseDepSchemaPath(jar, outputDirectory);
                if (path != null) {
                    bldr.addDependentSchema(Paths.get(path.getAbsolutePath()));
                }
            } catch (IOException e) {
                throw new YangCompilerException("Failed to parse dependent schema path", e);
            }
        }
        bldr.setCodeGenDir(Paths.get(outputDirectory));
        bldr.setMetadataGenDir(Paths.get(outputDirectory + SLASH + YANG_RESOURCES + SLASH));
        for (File file : models) {
            bldr.addYangFile(Paths.get(file.getAbsolutePath()));
        }
        bldr.setModelId(modelId);
        // Compile yang files and generate java code.
        try {
            output = compiler.compileYangFiles(bldr.build());
        } catch (IOException e) {
            throw new YangParsingException(e);
        }
    }
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    HashMap<String, MacAddress> macAddressMap = getMacAddressesByInterface();
    List<PortDescription> ports = Lists.newArrayList();
    try {
        Optional<JsonNode> result = retrieveCommandResult(SHOW_INTERFACES_STATUS);
        if (!result.isPresent()) {
            return ports;
        }
        ArrayNode arrayNode = (ArrayNode) result.get();
        JsonNode jsonNode = arrayNode.iterator().next().get(INTERFACE_STATUSES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            Long bandwidth = interfaceNode.path(BANDWIDTH).asLong() / MBPS;
            String macAddress = macAddressMap.containsKey(name) ? macAddressMap.get(name).toString() : "";
            SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.BANDWIDTH, bandwidth.toString()).set(AnnotationKeys.NAME, name).set(AnnotationKeys.PORT_NAME, name).set(AnnotationKeys.PORT_MAC, macAddress).set(LINK_STATUS, interfaceNode.path(LINK_STATUS).asText()).set(LINE_PROTOCOL_STATUS, interfaceNode.path(LINE_PROTOCOL_STATUS).asText()).set(INTERFACE_TYPE, interfaceNode.path(INTERFACE_TYPE).asText()).build();
            int portNumber;
            try {
                portNumber = getPortNumber(name);
            } catch (Exception e) {
                log.debug("Interface does not have port number: {}", name);
                return;
            }
            PortDescription portDescription = DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(portNumber)).isEnabled(true).type(Port.Type.FIBER).portSpeed(bandwidth).annotations(annotations).build();
            ports.add(portDescription);
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return ports;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    Map<String, MacAddress> macAddressMap = getMacAddressesByInterface();
    List<PortDescription> ports = Lists.newArrayList();
    try {
        Optional<JsonNode> result = retrieveCommandResult(SHOW_INTERFACES_STATUS);
        if (!result.isPresent()) {
            return ports;
        }
        ArrayNode arrayNode = (ArrayNode) result.get();
        JsonNode jsonNode = arrayNode.iterator().next().get(INTERFACE_STATUSES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            Long bandwidth = interfaceNode.path(BANDWIDTH).asLong() / MBPS;
            String macAddress = macAddressMap.containsKey(name) ? macAddressMap.get(name).toString() : "";
            SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.BANDWIDTH, bandwidth.toString()).set(AnnotationKeys.NAME, name).set(AnnotationKeys.PORT_NAME, name).set(AnnotationKeys.PORT_MAC, macAddress).set(LINK_STATUS, interfaceNode.path(LINK_STATUS).asText()).set(LINE_PROTOCOL_STATUS, interfaceNode.path(LINE_PROTOCOL_STATUS).asText()).set(INTERFACE_TYPE, interfaceNode.path(INTERFACE_TYPE).asText()).build();
            int portNumber;
            try {
                portNumber = getPortNumber(name);
            } catch (Exception e) {
                log.debug("Interface does not have port number: {}", name);
                return;
            }
            PortDescription portDescription = DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(portNumber)).isEnabled(true).type(Port.Type.FIBER).portSpeed(bandwidth).annotations(annotations).build();
            ports.add(portDescription);
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return ports;
}
#end_block

#method_before
private HashMap<String, MacAddress> getMacAddressesByInterface() {
    HashMap<String, MacAddress> macAddressMap = new HashMap();
    try {
        Optional<JsonNode> result = retrieveCommandResult(SHOW_INTERFACES);
        if (!result.isPresent()) {
            return macAddressMap;
        }
        ArrayNode arrayNode = (ArrayNode) result.get();
        JsonNode jsonNode = arrayNode.iterator().next().get(INTERFACES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            JsonNode macAddressNode = interfaceNode.get(BURNED_IN_ADDRESS);
            if (macAddressNode == null) {
                log.debug("Interface does not have {}: {}", BURNED_IN_ADDRESS, name);
                return;
            }
            String macAddress = macAddressNode.asText("");
            if (macAddress.isEmpty()) {
                macAddressNode = interfaceNode.get(PHYSICAL_ADDRESS);
                if (macAddressNode == null) {
                    log.debug("Interface does not have {}: {}", PHYSICAL_ADDRESS, name);
                    return;
                }
                macAddress = macAddressNode.asText("");
                if (macAddress.isEmpty()) {
                    log.debug("Interface does not have any mac address: {}", name);
                    return;
                }
            }
            try {
                macAddressMap.put(name, MacAddress.valueOf(macAddress));
            } catch (IllegalArgumentException e) {
                log.error("Cannot parse macAddress: {}", macAddress);
            }
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return macAddressMap;
}
#method_after
private Map<String, MacAddress> getMacAddressesByInterface() {
    Map<String, MacAddress> macAddressMap = new HashMap();
    try {
        Optional<JsonNode> result = retrieveCommandResult(SHOW_INTERFACES);
        if (!result.isPresent()) {
            return macAddressMap;
        }
        ArrayNode arrayNode = (ArrayNode) result.get();
        JsonNode jsonNode = arrayNode.iterator().next().get(INTERFACES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            JsonNode macAddressNode = interfaceNode.get(BURNED_IN_ADDRESS);
            if (macAddressNode == null) {
                log.debug("Interface does not have {}: {}", BURNED_IN_ADDRESS, name);
                return;
            }
            String macAddress = macAddressNode.asText("");
            if (macAddress.isEmpty()) {
                macAddressNode = interfaceNode.get(PHYSICAL_ADDRESS);
                if (macAddressNode == null) {
                    log.debug("Interface does not have {}: {}", PHYSICAL_ADDRESS, name);
                    return;
                }
                macAddress = macAddressNode.asText("");
                if (macAddress.isEmpty()) {
                    log.debug("Interface does not have any mac address: {}", name);
                    return;
                }
            }
            try {
                macAddressMap.put(name, MacAddress.valueOf(macAddress));
            } catch (IllegalArgumentException e) {
                log.error("Cannot parse macAddress: {}", macAddress);
            }
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return macAddressMap;
}
#end_block

#method_before
@Override
public RpcOutput createConnectivityService(RpcInput inputVar) {
    try {
        TapiCreateConnectivityInputHandler input = new TapiCreateConnectivityInputHandler();
        input.setRpcInput(inputVar);
        // TODO validation check
        log.info("input SIPs: {}", input.getSips());
        List<TapiNepRef> nepRefs = input.getSips().stream().map(sipId -> resolver.getNepRef(sipId)).collect(Collectors.toList());
        // for test
        // Map<String, String> filter = new HashMap<>();
        // filter.put(ODTN_PORT_TYPE, OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value());
        // List<TapiNepRef> nepRefs = resolver.getNepRefs(filter);
        // setup connections
        TapiBothNeps neps = TapiBothNeps.create(nepRefs.get(0), nepRefs.get(1));
        DcsBasedTapiConnectionManager connectionManager = DcsBasedTapiConnectionManager.create();
        connectionManager.createConnection(neps);
        // setup connectivity service
        TapiConnectivityServiceHandler connectivityServiceHandler = TapiConnectivityServiceHandler.create();
        connectivityServiceHandler.addConnection(connectionManager.getConnectionBuilder().getModelObject().uuid());
        neps.stream().map(nepRef -> TapiSepHandler.create().setSip(nepRef.getSipId())).forEach(sepBuilder -> {
            connectivityServiceHandler.addSep(sepBuilder.getModelObject());
        });
        // build
        connectionManager.apply();
        connectivityServiceHandler.add();
        // output
        TapiCreateConnectivityOutputHandler output = TapiCreateConnectivityOutputHandler.create().addService(connectivityServiceHandler.getModelObject());
        return new RpcOutput(RpcOutput.Status.RPC_SUCCESS, output.getDataNode());
    } catch (Throwable e) {
        log.error("Error:", e);
        return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
    }
}
#method_after
@Override
public RpcOutput createConnectivityService(RpcInput inputVar) {
    try {
        TapiCreateConnectivityInputHandler input = new TapiCreateConnectivityInputHandler();
        input.setRpcInput(inputVar);
        // TODO validation check
        log.info("input SIPs: {}", input.getSips());
        List<TapiNepRef> nepRefs = input.getSips().stream().map(sipId -> resolver.getNepRef(sipId)).collect(Collectors.toList());
        // for test
        // Map<String, String> filter = new HashMap<>();
        // filter.put(ODTN_PORT_TYPE, OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value());
        // List<TapiNepRef> nepRefs = resolver.getNepRefs(filter);
        // setup connections
        TapiNepPair neps = TapiNepPair.create(nepRefs.get(0), nepRefs.get(1));
        DcsBasedTapiConnectionManager connectionManager = DcsBasedTapiConnectionManager.create();
        connectionManager.createConnection(neps);
        // setup connectivity service
        TapiConnectivityServiceHandler connectivityServiceHandler = TapiConnectivityServiceHandler.create();
        connectivityServiceHandler.addConnection(connectionManager.getConnectionHandler().getModelObject().uuid());
        neps.stream().map(nepRef -> TapiSepHandler.create().setSip(nepRef.getSipId())).forEach(sepBuilder -> {
            connectivityServiceHandler.addSep(sepBuilder.getModelObject());
        });
        // build
        connectionManager.apply();
        connectivityServiceHandler.add();
        // output
        TapiCreateConnectivityOutputHandler output = TapiCreateConnectivityOutputHandler.create().addService(connectivityServiceHandler.getModelObject());
        return new RpcOutput(RpcOutput.Status.RPC_SUCCESS, output.getDataNode());
    } catch (Throwable e) {
        log.error("Error:", e);
        return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
    }
}
#end_block

#method_before
@Override
public RpcOutput getConnectivityServiceList(RpcInput inputVar) {
    try {
        TapiGetConnectivityListOutputHandler output = TapiGetConnectivityListOutputHandler.create();
        log.info("get list called");
        TapiContextHandler handler = TapiContextHandler.create();
        handler.read();
        log.info("model : {}", handler.getModelObject());
        log.info("conserv : {}", handler.getConnectivityService());
        handler.getConnectivityService().stream().map(TapiObjectHandler::getModelObject).forEach(output::addService);
        return new RpcOutput(RpcOutput.Status.RPC_SUCCESS, output.getDataNode());
    } catch (Throwable e) {
        log.error("Error:", e);
        return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
    }
}
#method_after
@Override
public RpcOutput getConnectivityServiceList(RpcInput inputVar) {
    try {
        TapiGetConnectivityListOutputHandler output = TapiGetConnectivityListOutputHandler.create();
        log.info("get list called");
        TapiContextHandler handler = TapiContextHandler.create();
        handler.read();
        log.info("model : {}", handler.getModelObject());
        log.info("conserv : {}", handler.getConnectivityServices());
        handler.getConnectivityServices().stream().map(TapiObjectHandler::getModelObject).forEach(output::addService);
        return new RpcOutput(RpcOutput.Status.RPC_SUCCESS, output.getDataNode());
    } catch (Throwable e) {
        log.error("Error:", e);
        return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
    }
}
#end_block

#method_before
public TapiNepRef setPortType(String portType) {
    this.portType = portType;
    return this;
}
#method_after
public TapiNepRef setPortType(String portType) {
    this.portType = Optional.ofNullable(portType).map(OdtnDeviceDescriptionDiscovery.OdtnPortType::fromValue).orElse(null);
    return this;
}
#end_block

#method_before
public boolean is(String key, String value) {
    checkNotNull(key);
    checkNotNull(value);
    switch(key) {
        case DEVICE_ID:
            if (cp == null) {
                return false;
            }
            return value.equals(cp.deviceId().toString());
        case ODTN_PORT_TYPE:
            return value.equals(portType);
        case CONNECTION_ID:
            return value.equals(connectionId);
        default:
            log.warn("Unknown key: {}", key);
            return true;
    }
}
#method_after
public boolean is(String key, String value) {
    checkNotNull(key);
    checkNotNull(value);
    switch(key) {
        case DEVICE_ID:
            return value.equals(Optional.ofNullable(cp).map(ConnectPoint::deviceId).map(DeviceId::toString).orElse(null));
        case ODTN_PORT_TYPE:
            return value.equals(Optional.ofNullable(portType).map(OdtnDeviceDescriptionDiscovery.OdtnPortType::value).orElse(null));
        case CONNECTION_ID:
            return value.equals(connectionId);
        default:
            log.warn("Unknown key: {}", key);
            return true;
    }
}
#end_block

#method_before
public String toString() {
    return toStringHelper(getClass()).add("nodeId", nodeId).add("nepId", nepId).add("sipId", sipId).add("connectPoint", cp).toString();
}
#method_after
public String toString() {
    return toStringHelper(getClass()).add("topologyId", topologyId).add("nodeId", nodeId).add("nepId", nepId).add("sipId", sipId).add("connectPoint", cp).add("portType", portType).add("connectionId", connectionId).toString();
}
#end_block

#method_before
public String toString() {
    return toStringHelper(getClass()).add("nodeId", nodeId).add("nepId", nepId).add("cepId", cepId).toString();
}
#method_after
public String toString() {
    return toStringHelper(getClass()).add("topologyId", topologyId).add("nodeId", nodeId).add("nepId", nepId).add("cepId", cepId).toString();
}
#end_block

#method_before
@Override
public void createConnection(TapiBothNeps neps) {
    op = Operation.CREATE;
    connectionManagerList.clear();
    // Calculate route
    List<TapiBothNeps> nepRoute = connectionController.pathCompute(neps);
    log.info("route size: {}", nepRoute.size());
    log.info("route: {}", nepRoute);
    TapiRouteHandler routeBuilder = TapiRouteHandler.create();
    // Create under connection, and set them into routeBuilder
    if (nepRoute.size() < 1) {
        throw new IllegalStateException();
    } else if (nepRoute.size() == 1) {
        // As only one connection is found as route, there are no under connection
        // and no need to delegate
        ceps = applyForwardingConstraint(neps);
        routeBuilder.addCep(ceps.src());
        routeBuilder.addCep(ceps.dst());
    } else {
        // Delegate to other connectionManager
        delegateConnectionCreation(nepRoute);
        connectionManagerList.forEach(manager -> {
            routeBuilder.addCep(manager.getCeps().src());
            routeBuilder.addCep(manager.getCeps().dst());
        });
        ceps = TapiBothCeps.create(routeBuilder.getRouteStart(), routeBuilder.getRouteEnd());
    }
    // 
    handler.addRoute(routeBuilder.getModelObject());
    handler.addCep(TapiCepRefHandler.create().setCep(ceps.src()).getModelObject()).addCep(TapiCepRefHandler.create().setCep(ceps.dst()).getModelObject());
    connectionManagerList.forEach(manager -> handler.addUnderConnection(manager.getConnectionBuilder().getModelObject()));
}
#method_after
@Override
public TapiConnectionHandler createConnection(TapiNepPair neps) {
    // Calculate route
    TapiConnection connection = connectionController.pathCompute(neps);
    log.info("Calculated path: {}", connection);
    createConnectionRecursively(connection);
    return connectionHandler;
}
#end_block

#method_before
@Override
public void deleteConnection(TapiConnectionHandler connectionHandler) {
    op = Operation.DELETE;
    connectionManagerList.clear();
    handler = connectionHandler;
    handler.read();
    log.info("model: {}", connectionHandler.getModelObject());
    delegateConnectionDeletion(connectionHandler.getUnderConnection());
}
#method_after
@Override
public void deleteConnection(TapiConnectionHandler connectionHandler) {
    // read target to be deleted
    this.connectionHandler = connectionHandler;
    this.connectionHandler.read();
    log.info("model: {}", connectionHandler.getModelObject());
    deleteConnectionRecursively(connectionHandler);
}
#end_block

#method_before
@Override
public void apply() {
    connectionManagerList.forEach(TapiConnectionManager::apply);
    switch(op) {
        case CREATE:
            handler.add();
            break;
        case DELETE:
            handler.remove();
            break;
        default:
            throw new FailedException("Unknown operation type.");
    }
}
#method_after
@Override
public void apply() {
    connectionManagerList.forEach(DcsBasedTapiConnectionManager::apply);
    switch(op) {
        case CREATE:
            connectionHandler.add();
            break;
        case DELETE:
            connectionHandler.remove();
            break;
        default:
            throw new FailedException("Unknown operation type.");
    }
}
#end_block

#method_before
private void delegateConnectionCreation(List<TapiBothNeps> route) {
    for (TapiBothNeps underNeps : route) {
        // TODO behaviour
        DcsBasedTapiConnectionManager manager = DcsBasedTapiConnectionManager.create();
        log.info("neps: {}", underNeps);
        manager.createConnection(underNeps);
        connectionManagerList.add(manager);
    }
}
#method_after
private void delegateConnectionCreation(TapiConnection connection) {
    log.info("ceps: {}", connection.getCeps());
    DcsBasedTapiConnectionManager manager = DcsBasedTapiConnectionManager.create();
    manager.createConnectionRecursively(connection);
    connectionManagerList.add(manager);
}
#end_block

#method_before
private void delegateConnectionDeletion(List<TapiConnectionHandler> route) {
    for (TapiConnectionHandler underConnectionHandler : route) {
        log.info("model: {}", underConnectionHandler.getModelObject());
        DcsBasedTapiConnectionManager manager = DcsBasedTapiConnectionManager.create();
        manager.deleteConnection(underConnectionHandler);
        connectionManagerList.add(manager);
    }
}
#method_after
private void delegateConnectionDeletion(TapiConnectionHandler connectionHandler) {
    log.info("model: {}", connectionHandler.getModelObject());
    DcsBasedTapiConnectionManager manager = DcsBasedTapiConnectionManager.create();
    manager.deleteConnectionRecursively(connectionHandler);
    connectionManagerList.add(manager);
}
#end_block

#method_before
@Override
public List<TapiBothNeps> pathCompute(TapiBothNeps neps) {
    log.info("Path compute with: {}", neps);
    if (neps.isSameDevice()) {
        return Arrays.asList(neps);
    }
    return pathComputeDetail(neps);
}
#method_after
@Override
public TapiConnection pathCompute(TapiNepPair neps) {
    log.info("Path compute with: {}", neps);
    return pathComputeDetail(neps);
}
#end_block

#method_before
private List<TapiBothNeps> pathComputeDetail(TapiBothNeps neps) {
    List<TapiBothNeps> route = new ArrayList<>();
    // FIXME this can work only for Phase1.0, we need some features to
    // - define Route
    // - select NodeEdgePoints
    // - with pre-defined topology and forwarding constraint of each devices or domains
    route.add(TapiBothNeps.create(neps.src(), mockPathCompute(neps.src(), neps.dst())));
    route.add(TapiBothNeps.create(neps.dst(), mockPathCompute(neps.dst(), neps.src())).invert());
    if (!validateRoute(route)) {
        log.error("Illegal route", route);
        throw new RuntimeException();
    }
    return route;
}
#method_after
private TapiConnection pathComputeDetail(TapiNepPair neps) {
    return mockPathCompute(neps);
}
#end_block

#method_before
private TapiNepRef mockPathCompute(TapiNepRef srcNepRef, TapiNepRef dstNepRef) {
    DeviceId deviceId = srcNepRef.getConnectPoint().deviceId();
    Map<String, String> filter = new HashMap<>();
    filter.put(DEVICE_ID, deviceId.toString());
    filter.put(ODTN_PORT_TYPE, OdtnDeviceDescriptionDiscovery.OdtnPortType.LINE.value());
    filter.put(CONNECTION_ID, srcNepRef.getConnectionId());
    return resolver.getNepRefs(filter).stream().findAny().get();
}
#method_after
private TapiConnection mockPathCompute(TapiNepPair neps) {
    TapiNepRef leftLineNep = mockGetTransponderLinePort(neps.left());
    TapiNepRef rightLineNep = mockGetTransponderLinePort(neps.right());
    TapiConnection leftLowerConnection = TapiConnection.create(TapiCepRef.create(neps.left(), neps.left().getCepIds().get(0)), TapiCepRef.create(leftLineNep, leftLineNep.getCepIds().get(0)));
    TapiConnection rightLowerConnection = TapiConnection.create(TapiCepRef.create(neps.right(), neps.right().getCepIds().get(0)), TapiCepRef.create(rightLineNep, rightLineNep.getCepIds().get(0)));
    TapiConnection connection = TapiConnection.create(TapiCepRef.create(neps.left(), neps.left().getCepIds().get(0)), TapiCepRef.create(neps.right(), neps.right().getCepIds().get(0)));
    connection.addLowerConnection(leftLowerConnection).addLowerConnection(rightLowerConnection);
    return connection;
}
#end_block

#method_before
@Before
public void setUp() {
    nodeRef = TapiNodeRef.create("49e2ac46-3975-44b4-b84f-8fab28222a39", "5638e8e6-ac17-40d9-86e4-7c1febab6f1a");
    nepRef = TapiNepRef.create("59e2ac46-3975-44b4-b84f-8fab28222a39", "6638e8e6-ac17-40d9-86e4-7c1febab6f1a", "cd673055-e2b2-4f67-88c8-adfae96385bc");
    nodeRefNullAttr = TapiNodeRef.create("59e2ac46-3975-44b4-b84f-8fab28222a39", "6638e8e6-ac17-40d9-86e4-7c1febab6f1a");
    nepRefNullAttr = TapiNepRef.create("69e2ac46-3975-44b4-b84f-8fab28222a39", "7638e8e6-ac17-40d9-86e4-7c1febab6f1a", "dd673055-e2b2-4f67-88c8-adfae96385bc");
    deviceId = DeviceId.deviceId("netconf:172.24.3.5:11011");
    cp = new ConnectPoint(deviceId, PortNumber.portNumber("42"));
    sipId = "01c39723-7c0d-4754-8d64-fd9ff412404c";
    portType = OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.toString();
    nodeRef.setDeviceId(deviceId);
    nepRef.setConnectPoint(cp).setSipId(sipId).setPortType(portType);
    dummyDeviceId = DeviceId.deviceId("dummy");
    dummyPort = 4;
    dummyCp = new ConnectPoint(dummyDeviceId, PortNumber.portNumber(dummyPort));
    dummySipId = "00000000-0000-0000-0000-000000000000";
    tapiResolver = new DefaultTapiResolver();
    mockTapiDataProducer = EasyMock.createMock(TapiDataProducer.class);
    mockTapiDataProducer.updateCacheRequest(tapiResolver);
    replay(mockTapiDataProducer);
    tapiResolver.dataProvider = mockTapiDataProducer;
}
#method_after
@Before
public void setUp() {
    nodeRef = TapiNodeRef.create("49e2ac46-3975-44b4-b84f-8fab28222a39", "5638e8e6-ac17-40d9-86e4-7c1febab6f1a");
    nepRef = TapiNepRef.create("59e2ac46-3975-44b4-b84f-8fab28222a39", "6638e8e6-ac17-40d9-86e4-7c1febab6f1a", "cd673055-e2b2-4f67-88c8-adfae96385bc");
    nodeRefNullAttr = TapiNodeRef.create("59e2ac46-3975-44b4-b84f-8fab28222a39", "6638e8e6-ac17-40d9-86e4-7c1febab6f1a");
    nepRefNullAttr = TapiNepRef.create("69e2ac46-3975-44b4-b84f-8fab28222a39", "7638e8e6-ac17-40d9-86e4-7c1febab6f1a", "dd673055-e2b2-4f67-88c8-adfae96385bc");
    deviceId = DeviceId.deviceId("netconf:172.24.3.5:11011");
    cp = new ConnectPoint(deviceId, PortNumber.portNumber("42"));
    sipId = "01c39723-7c0d-4754-8d64-fd9ff412404c";
    portType = OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value();
    nodeRef.setDeviceId(deviceId);
    nepRef.setConnectPoint(cp).setSipId(sipId).setPortType(portType);
    dummyDeviceId = DeviceId.deviceId("dummy");
    dummyPort = 4;
    dummyCp = new ConnectPoint(dummyDeviceId, PortNumber.portNumber(dummyPort));
    dummySipId = "00000000-0000-0000-0000-000000000000";
    tapiResolver = new DefaultTapiResolver();
    mockTapiDataProducer = EasyMock.createMock(TapiDataProducer.class);
    mockTapiDataProducer.updateCacheRequest(tapiResolver);
    replay(mockTapiDataProducer);
    tapiResolver.dataProvider = mockTapiDataProducer;
}
#end_block

#method_before
public String toString() {
    return toStringHelper(getClass()).add("nodeId", nodeId).add("deviceId", deviceId).toString();
}
#method_after
public String toString() {
    return toStringHelper(getClass()).add("topologyId", topologyId).add("nodeId", nodeId).add("deviceId", deviceId).toString();
}
#end_block

#method_before
@Override
public TapiNodeRef getNodeRef(ElementId deviceId) throws NoSuchElementException {
    updateCache();
    TapiNodeRef ret = null;
    try {
        ret = tapiNodeRefList.stream().filter(node -> node.getDeviceId() != null && node.getDeviceId().equals(deviceId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.error("Node not found associated with {}", deviceId);
        throw e;
    }
    return ret;
}
#method_after
@Override
public TapiNodeRef getNodeRef(TapiNodeRef nodeRef) throws NoSuchElementException {
    updateCache();
    TapiNodeRef ret = null;
    try {
        ret = tapiNodeRefList.stream().filter(nodeRef::equals).findFirst().get();
    } catch (NoSuchElementException e) {
        log.error("Node not found of {}", nodeRef);
        throw e;
    }
    return ret;
}
#end_block

#method_before
@Override
public TapiNepRef getNepRef(String sipId) throws NoSuchElementException {
    updateCache();
    TapiNepRef ret = null;
    try {
        ret = tapiNepRefList.stream().filter(nep -> nep.getSipId() != null && nep.getSipId().equals(sipId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.error("Nep not found associated with {}", sipId);
        throw e;
    }
    return ret;
}
#method_after
@Override
public TapiNepRef getNepRef(TapiNepRef nepRef) throws NoSuchElementException {
    updateCache();
    TapiNepRef ret = null;
    try {
        ret = tapiNepRefList.stream().filter(nepRef::equals).findFirst().get();
    } catch (NoSuchElementException e) {
        log.error("Nep not found of {}", nepRef);
        throw e;
    }
    return ret;
}
#end_block

#method_before
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    this.serviceDirectory = context.directory();
    this.deviceSetvice = serviceDirectory.get(DeviceService.class);
}
#method_after
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    this.serviceDirectory = context.directory();
    this.deviceService = serviceDirectory.get(DeviceService.class);
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective forwardObjective) {
    ForwardingObjective newFwd = forwardObjective;
    Device device = deviceSetvice.getDevice(deviceId);
    if (forwardObjective.treatment() != null && forwardObjective.treatment().clearedDeferred()) {
        log.warn("Using 'clear actions' instruction which is not supported by {} {} {} Switch" + " removing the clear deferred from the forwarding objective", device.id(), device.manufacturer(), device.hwVersion());
        newFwd = forwardingObjectiveWithoutCleardDef(forwardObjective).orElse(forwardObjective);
    }
    super.forward(newFwd);
}
#method_after
@Override
public void forward(ForwardingObjective forwardObjective) {
    ForwardingObjective newFwd = forwardObjective;
    Device device = deviceService.getDevice(deviceId);
    if (forwardObjective.treatment() != null && forwardObjective.treatment().clearedDeferred()) {
        log.warn("Using 'clear actions' instruction which is not supported by {} {} {} Switch" + " removing the clear deferred from the forwarding objective", device.id(), device.manufacturer(), device.hwVersion());
        newFwd = forwardingObjectiveWithoutCleardDef(forwardObjective).orElse(forwardObjective);
    }
    super.forward(newFwd);
}
#end_block

#method_before
private Optional<ForwardingObjective> forwardingObjectiveWithoutCleardDef(ForwardingObjective forwardingObjective) {
    TrafficTreatment treatment = trafficTreatmentWithoutClearedDeffered(forwardingObjective.treatment());
    DefaultForwardingObjective.Builder foBuilder = (DefaultForwardingObjective.Builder) forwardingObjective.copy();
    foBuilder.withTreatment(treatment);
    switch(forwardingObjective.op()) {
        case ADD:
            return Optional.of(foBuilder.add(forwardingObjective.context().orElse(null)));
        case REMOVE:
            return Optional.of(foBuilder.remove(forwardingObjective.context().orElse(null)));
        default:
            log.warn("Driver Not support other operations for forwarding objective");
            return Optional.empty();
    }
}
#method_after
private Optional<ForwardingObjective> forwardingObjectiveWithoutCleardDef(ForwardingObjective forwardingObjective) {
    TrafficTreatment treatment = trafficTreatmentWithoutClearedDeffered(forwardingObjective.treatment());
    DefaultForwardingObjective.Builder foBuilder = (DefaultForwardingObjective.Builder) forwardingObjective.copy();
    foBuilder.withTreatment(treatment);
    switch(forwardingObjective.op()) {
        case ADD:
            return Optional.of(foBuilder.add(forwardingObjective.context().orElse(null)));
        case REMOVE:
            return Optional.of(foBuilder.remove(forwardingObjective.context().orElse(null)));
        default:
            log.warn("Driver does not support other operations for forwarding objective");
            return Optional.empty();
    }
}
#end_block

#method_before
private boolean isMeterCapable(OpenFlowSwitch sw) {
    Driver driver;
    try {
        driver = driverService.getDriver(DeviceId.deviceId(Dpid.uri(sw.getDpid())));
    } catch (ItemNotFoundException e) {
        driver = driverService.getDriver(sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription());
    }
    String isMeterCapable = driver.getProperty(METER_CAPABLE);
    return isMeterCapable != null || Boolean.parseBoolean(isMeterCapable);
}
#method_after
private boolean isMeterCapable(OpenFlowSwitch sw) {
    Driver driver;
    try {
        driver = driverService.getDriver(DeviceId.deviceId(Dpid.uri(sw.getDpid())));
    } catch (ItemNotFoundException e) {
        driver = driverService.getDriver(sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription());
    }
    String isMeterCapable = driver.getProperty(METER_CAPABLE);
    return isMeterCapable == null || Boolean.parseBoolean(isMeterCapable);
}
#end_block

#method_before
@Override
public void startDriverHandshake() {
}
#method_after
@Override
public void startDriverHandshake() {
    if (factory().getVersion() == OFVersion.OF_10) {
        OFFlowAdd.Builder fmBuilder = factory().buildFlowAdd();
        fmBuilder.setPriority(LOWEST_PRIORITY);
        sendHandshakeMessage(fmBuilder.build());
    }
    log.debug("Juniper Switch Operating OF version {}", factory().getVersion());
}
#end_block

#method_before
@Override
public void processDriverHandshakeMessage(OFMessage m) {
}
#method_after
@Override
public void processDriverHandshakeMessage(OFMessage m) {
    log.debug("Juniper Switch: processDriverHandshakeMessage for sw {}", getStringId());
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    mainEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-main", "%d", log));
    hostEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-host", "%d", log));
    routeEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-route", "%d", log));
    mcastEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-mcast", "%d", log));
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    mastershipService.addListener(mastershipListener);
    clusterService.addListener(clusterListener);
    linkHandler.init();
    l2TunnelHandler.init();
    networkConfigCompletion.whenComplete((value, ex) -> {
        // setting to null for easier fall through
        networkConfigCompletion = null;
        // process all queued events
        queuedEvents.forEach(event -> {
            mainEventExecutor.execute(new InternalEventHandler(event));
        });
    });
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    mainEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-main", "%d", log));
    hostEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-host", "%d", log));
    routeEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-route", "%d", log));
    mcastEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-mcast", "%d", log));
    packetExecutor = Executors.newSingleThreadExecutor(groupedThreads("sr-packet", "%d", log));
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    mastershipService.addListener(mastershipListener);
    clusterService.addListener(clusterListener);
    linkHandler.init();
    l2TunnelHandler.init();
    networkConfigCompletion.whenComplete((value, ex) -> {
        // setting to null for easier fall through
        networkConfigCompletion = null;
        // process all queued events
        queuedEvents.forEach(event -> {
            mainEventExecutor.execute(new InternalEventHandler(event));
        });
    });
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    defaultRoutingHandler.shutdown();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    packetExecutor.shutdown();
    mainEventExecutor = null;
    hostEventExecutor = null;
    routeEventExecutor = null;
    mcastEventExecutor = null;
    packetExecutor = null;
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    defaultRoutingHandler.shutdown();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null) {
        return;
    }
    log.trace("Rcvd pktin from {}: {}", context.inPacket().receivedFrom(), ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("Received unexpected ARP packet on {}", context.inPacket().receivedFrom());
        log.trace("{}", ethernet);
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipv4Packet);
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processIcmp(ethernet, pkt.receivedFrom());
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(ipv4Packet, pkt.receivedFrom());
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
        // We deal with the packet only if the packet is a ICMP6 ECHO/REPLY
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST || icmp6Packet.getIcmpType() == ICMP6.ECHO_REPLY) {
                icmpHandler.processIcmpv6(ethernet, pkt.receivedFrom());
            } else {
                log.trace("Received ICMPv6 0x{} - not handled", Integer.toHexString(icmp6Packet.getIcmpType() & 0xff));
            }
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCPv6 packets.
        // ipHandler.processPacketIn(ipv6Packet, pkt.receivedFrom());
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    packetExecutor.execute(() -> processPacketInternal(context));
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
    checkState(xConnectHandler != null, "XConnectHandler is not initialized");
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            log.trace("Schedule Network Config event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (mainEventExecutor == null) {
        return;
    }
    checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
    checkState(xConnectHandler != null, "XConnectHandler is not initialized");
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            log.trace("Schedule Network Config event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.trace("Schedule Link event {}", event);
        if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
            mainEventExecutor.execute(new InternalEventHandler(event));
        } else {
            queuedEvents.add(event);
        }
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    if (mainEventExecutor == null) {
        return;
    }
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.trace("Schedule Link event {}", event);
        if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
            mainEventExecutor.execute(new InternalEventHandler(event));
        } else {
            queuedEvents.add(event);
        }
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_UPDATED:
        case PORT_ADDED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.trace("Schedule Device event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    if (mainEventExecutor == null) {
        return;
    }
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_UPDATED:
        case PORT_ADDED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.trace("Schedule Device event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
    }
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    switch(event.type()) {
        case TOPOLOGY_CHANGED:
            log.trace("Schedule Topology event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
    }
}
#method_after
@Override
public void event(TopologyEvent event) {
    if (mainEventExecutor == null) {
        return;
    }
    switch(event.type()) {
        case TOPOLOGY_CHANGED:
            log.trace("Schedule Topology event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
    }
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_MOVED:
        case HOST_REMOVED:
        case HOST_UPDATED:
            log.trace("Schedule Host event {}", event);
            hostEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported host event type: {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(HostEvent event) {
    if (hostEventExecutor == null) {
        return;
    }
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_MOVED:
        case HOST_REMOVED:
        case HOST_UPDATED:
            log.trace("Schedule Host event {}", event);
            hostEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported host event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCES_ADDED:
        case SOURCES_REMOVED:
        case SINKS_ADDED:
        case SINKS_REMOVED:
        case ROUTE_REMOVED:
        case ROUTE_ADDED:
            log.trace("Schedule Mcast event {}", event);
            mcastEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported mcast event type: {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(McastEvent event) {
    if (mcastEventExecutor == null) {
        return;
    }
    switch(event.type()) {
        case SOURCES_ADDED:
        case SOURCES_REMOVED:
        case SINKS_ADDED:
        case SINKS_REMOVED:
        case ROUTE_REMOVED:
        case ROUTE_ADDED:
            log.trace("Schedule Mcast event {}", event);
            mcastEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported mcast event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
@Override
public void event(RouteEvent event) {
    switch(event.type()) {
        case ROUTE_ADDED:
        case ROUTE_UPDATED:
        case ROUTE_REMOVED:
        case ALTERNATIVE_ROUTES_CHANGED:
            log.trace("Schedule Route event {}", event);
            routeEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported route event type: {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(RouteEvent event) {
    if (routeEventExecutor == null) {
        return;
    }
    switch(event.type()) {
        case ROUTE_ADDED:
        case ROUTE_UPDATED:
        case ROUTE_REMOVED:
        case ALTERNATIVE_ROUTES_CHANGED:
            log.trace("Schedule Route event {}", event);
            routeEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported route event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
@Override
public void event(MastershipEvent event) {
    switch(event.type()) {
        case MASTER_CHANGED:
            log.debug("Mastership event: {}/{}", event.subject(), event.roleInfo());
            mainEventExecutor.execute(new InternalEventHandler(event));
            break;
        case BACKUPS_CHANGED:
        case SUSPENDED:
        default:
            log.debug("Mastership event type {} not handled", event.type());
            break;
    }
}
#method_after
@Override
public void event(MastershipEvent event) {
    if (mainEventExecutor == null) {
        return;
    }
    switch(event.type()) {
        case MASTER_CHANGED:
            log.debug("Mastership event: {}/{}", event.subject(), event.roleInfo());
            mainEventExecutor.execute(new InternalEventHandler(event));
            break;
        case BACKUPS_CHANGED:
        case SUSPENDED:
        default:
            log.debug("Mastership event type {} not handled", event.type());
            break;
    }
}
#end_block

#method_before
private boolean populateIpRuleForRouter(DeviceId targetSw, IpPrefix ipPrefix, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops) {
    int segmentId1, segmentId2 = -1;
    try {
        if (ipPrefix.isIp4()) {
            segmentId1 = config.getIPv4SegmentId(destSw1);
            if (destSw2 != null) {
                segmentId2 = config.getIPv4SegmentId(destSw2);
            }
        } else {
            segmentId1 = config.getIPv6SegmentId(destSw1);
            if (destSw2 != null) {
                segmentId2 = config.getIPv6SegmentId(destSw2);
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = buildIpSelectorFromIpPrefix(ipPrefix);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    DestinationSet ds;
    TrafficTreatment treatment;
    DestinationSet.DestinationSetType dsType;
    if (destSw2 == null) {
        // single dst - create destination set based on next-hop
        // If the next hop is the same as the final destination, then MPLS
        // label is not set.
        Set<DeviceId> nhd1 = nextHops.get(destSw1);
        if (nhd1.size() == 1 && nhd1.iterator().next().equals(destSw1)) {
            tbuilder.immediate().decNwTtl();
            ds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, destSw1);
            treatment = tbuilder.build();
        } else {
            ds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, segmentId1, destSw1);
            treatment = null;
        }
    } else {
        // dst pair - IP rules for dst-pairs are always from other edge nodes
        // the destination set needs to have both destinations, even if there
        // are no next hops to one of them
        ds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, segmentId1, destSw1, segmentId2, destSw2);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(SegmentRoutingManager.INTERNAL_VLAN);
    DefaultGroupHandler grpHandler = srManager.getGroupHandler(targetSw);
    if (grpHandler == null) {
        log.warn("populateIPRuleForRouter: groupHandler for device {} " + "not found", targetSw);
        return false;
    }
    int nextId = grpHandler.getNextObjectiveId(ds, nextHops, metabuilder.build(), false);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ds: {}", targetSw, ds);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(getPriorityFromPrefix(ipPrefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective for router IP/subnet {} " + "in switch {} with nextId: {}", ipPrefix, targetSw, nextId);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP rule for router {} populated in dev:{}", ipPrefix, targetSw), (objective, error) -> log.warn("Failed to populate IP rule for router {}: {} in dev:{}", ipPrefix, error, targetSw));
    srManager.flowObjectiveService.forward(targetSw, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#method_after
private boolean populateIpRuleForRouter(DeviceId targetSw, IpPrefix ipPrefix, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops) {
    int segmentId1, segmentId2 = -1;
    try {
        if (ipPrefix.isIp4()) {
            segmentId1 = config.getIPv4SegmentId(destSw1);
            if (destSw2 != null) {
                segmentId2 = config.getIPv4SegmentId(destSw2);
            }
        } else {
            segmentId1 = config.getIPv6SegmentId(destSw1);
            if (destSw2 != null) {
                segmentId2 = config.getIPv6SegmentId(destSw2);
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = buildIpSelectorFromIpPrefix(ipPrefix);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    DestinationSet ds;
    TrafficTreatment treatment;
    DestinationSet.DestinationSetType dsType;
    if (destSw2 == null) {
        // single dst - create destination set based on next-hop
        // If the next hop is the same as the final destination, then MPLS
        // label is not set.
        Set<DeviceId> nhd1 = nextHops.get(destSw1);
        if (nhd1.size() == 1 && nhd1.iterator().next().equals(destSw1)) {
            tbuilder.immediate().decNwTtl();
            ds = DestinationSet.createTypePushNone(destSw1);
            treatment = tbuilder.build();
        } else {
            ds = DestinationSet.createTypePushBos(segmentId1, destSw1);
            treatment = null;
        }
    } else {
        // dst pair - IP rules for dst-pairs are always from other edge nodes
        // the destination set needs to have both destinations, even if there
        // are no next hops to one of them
        ds = DestinationSet.createTypePushBos(segmentId1, destSw1, segmentId2, destSw2);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(SegmentRoutingManager.INTERNAL_VLAN);
    DefaultGroupHandler grpHandler = srManager.getGroupHandler(targetSw);
    if (grpHandler == null) {
        log.warn("populateIPRuleForRouter: groupHandler for device {} " + "not found", targetSw);
        return false;
    }
    int nextId = grpHandler.getNextObjectiveId(ds, nextHops, metabuilder.build(), false);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ds: {}", targetSw, ds);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(getPriorityFromPrefix(ipPrefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective for router IP/subnet {} " + "in switch {} with nextId: {}", ipPrefix, targetSw, nextId);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP rule for router {} populated in dev:{}", ipPrefix, targetSw), (objective, error) -> log.warn("Failed to populate IP rule for router {}: {} in dev:{}", ipPrefix, error, targetSw));
    srManager.flowObjectiveService.forward(targetSw, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#end_block

#method_before
private ForwardingObjective.Builder getMplsForwardingObjective(DeviceId targetSw, Set<DeviceId> nextHops, boolean phpRequired, boolean isBos, TrafficSelector meta, IpAddress routerIp, int segmentId, DeviceId destSw) {
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    DestinationSet ds = null;
    DestinationSet.DestinationSetType dstType = null;
    boolean simple = false;
    if (phpRequired) {
        // php case - pop should always be flow-action
        log.debug("getMplsForwardingObjective: php required");
        tbuilder.deferred().copyTtlIn();
        if (isBos) {
            if (routerIp.isIp4()) {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV4.ethType());
            } else {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV6.ethType());
            }
            tbuilder.decNwTtl();
            // standard case -> BoS == True; pop results in IP packet and forwarding
            // is via an ECMP group
            ds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, destSw);
        } else {
            tbuilder.deferred().popMpls(EthType.EtherType.MPLS_UNICAST.ethType()).decMplsTtl();
            // double-label case -> BoS == False, pop results in MPLS packet
            // depending on configuration we can ECMP this packet or choose one output
            // these are pseudowire next objectives
            ds = new DestinationSet(DestinationSet.DestinationSetType.NOT_BOS, destSw);
            if (!srManager.getMplsEcmp()) {
                simple = true;
            }
        }
    } else {
        // swap with self case - SR CONTINUE
        log.debug("getMplsForwardingObjective: swap with self");
        tbuilder.deferred().decMplsTtl();
        // swap results in MPLS packet with same BoS bit regardless of bit value
        // depending on configuration we can ECMP this packet or choose one output
        // differentiate here between swap for pw (isPw = true) or swap for normal routing
        dstType = isBos ? DestinationSet.DestinationSetType.SWAP_BOS : DestinationSet.DestinationSetType.SWAP_NOT_BOS;
        ds = new DestinationSet(dstType, segmentId, destSw);
        if (!srManager.getMplsEcmp()) {
            simple = true;
        }
    }
    fwdBuilder.withTreatment(tbuilder.build());
    log.debug("Trying to get a nextObjId for mpls rule on device:{} to ds:{}", targetSw, ds);
    DefaultGroupHandler gh = srManager.getGroupHandler(targetSw);
    if (gh == null) {
        log.warn("getNextObjectiveId query - groupHandler for device {} " + "not found", targetSw);
        return null;
    }
    Map<DeviceId, Set<DeviceId>> dstNextHops = new HashMap<>();
    dstNextHops.put(destSw, nextHops);
    int nextId = gh.getNextObjectiveId(ds, dstNextHops, meta, simple);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ds: {}", targetSw, ds);
        return null;
    } else {
        log.debug("nextObjId found:{} for mpls rule on device:{} to ds:{}", nextId, targetSw, ds);
    }
    fwdBuilder.nextStep(nextId);
    return fwdBuilder;
}
#method_after
private ForwardingObjective.Builder getMplsForwardingObjective(DeviceId targetSw, Set<DeviceId> nextHops, boolean phpRequired, boolean isBos, TrafficSelector meta, IpAddress routerIp, int segmentId, DeviceId destSw) {
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    DestinationSet ds = null;
    DestinationSet.DestinationSetType dstType = null;
    boolean simple = false;
    if (phpRequired) {
        // php case - pop should always be flow-action
        log.debug("getMplsForwardingObjective: php required");
        tbuilder.deferred().copyTtlIn();
        if (isBos) {
            if (routerIp.isIp4()) {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV4.ethType());
            } else {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV6.ethType());
            }
            tbuilder.decNwTtl();
            // standard case -> BoS == True; pop results in IP packet and forwarding
            // is via an ECMP group
            ds = DestinationSet.createTypePopBos(destSw);
        } else {
            tbuilder.deferred().popMpls(EthType.EtherType.MPLS_UNICAST.ethType()).decMplsTtl();
            // double-label case -> BoS == False, pop results in MPLS packet
            // depending on configuration we can ECMP this packet or choose one output
            ds = DestinationSet.createTypePopNotBos(destSw);
            if (!srManager.getMplsEcmp()) {
                simple = true;
            }
        }
    } else {
        // swap with self case - SR CONTINUE
        log.debug("getMplsForwardingObjective: swap with self");
        tbuilder.deferred().decMplsTtl();
        // swap results in MPLS packet with same BoS bit regardless of bit value
        // depending on configuration we can ECMP this packet or choose one output
        // differentiate here between swap with not bos or swap with bos
        ds = isBos ? DestinationSet.createTypeSwapBos(segmentId, destSw) : DestinationSet.createTypeSwapNotBos(segmentId, destSw);
        if (!srManager.getMplsEcmp()) {
            simple = true;
        }
    }
    fwdBuilder.withTreatment(tbuilder.build());
    log.debug("Trying to get a nextObjId for mpls rule on device:{} to ds:{}", targetSw, ds);
    DefaultGroupHandler gh = srManager.getGroupHandler(targetSw);
    if (gh == null) {
        log.warn("getNextObjectiveId query - groupHandler for device {} " + "not found", targetSw);
        return null;
    }
    Map<DeviceId, Set<DeviceId>> dstNextHops = new HashMap<>();
    dstNextHops.put(destSw, nextHops);
    int nextId = gh.getNextObjectiveId(ds, dstNextHops, meta, simple);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ds: {}", targetSw, ds);
        return null;
    } else {
        log.debug("nextObjId found:{} for mpls rule on device:{} to ds:{}", nextId, targetSw, ds);
    }
    fwdBuilder.nextStep(nextId);
    return fwdBuilder;
}
#end_block

#method_before
private boolean processSinglePortFiltersInternal(DeviceId deviceId, PortNumber portnum, boolean pushVlan, VlanId vlanId, boolean install) {
    FilteringObjective.Builder fob = buildFilteringObjective(deviceId, portnum, pushVlan, vlanId);
    if (fob == null) {
        // error encountered during build
        return false;
    }
    log.debug("{} filtering objectives for dev/port: {}/{}", install ? "Installing" : "Removing", deviceId, portnum);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {}/{} {}", deviceId, portnum, install ? "installed" : "removed"), (objective, error) -> log.warn("Failed to {} filter for {}/{}: {}", install ? "install" : "remove", deviceId, portnum, error));
    if (install) {
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    } else {
        srManager.flowObjectiveService.filter(deviceId, fob.remove(context));
    }
    return true;
}
#method_after
private boolean processSinglePortFiltersInternal(DeviceId deviceId, PortNumber portnum, boolean pushVlan, VlanId vlanId, boolean install) {
    boolean doTMAC = true;
    if (!pushVlan) {
        // Skip the tagged vlans belonging to an interface without an IP address
        Set<Interface> ifaces = srManager.interfaceService.getInterfacesByPort(new ConnectPoint(deviceId, portnum)).stream().filter(intf -> intf.vlanTagged().contains(vlanId) && intf.ipAddressesList().isEmpty()).collect(Collectors.toSet());
        if (!ifaces.isEmpty()) {
            log.debug("processSinglePortFiltersInternal: skipping TMAC for vlan {} at {}/{} - no IP", vlanId, deviceId, portnum);
            doTMAC = false;
        }
    }
    FilteringObjective.Builder fob = buildFilteringObjective(deviceId, portnum, pushVlan, vlanId, doTMAC);
    if (fob == null) {
        // error encountered during build
        return false;
    }
    log.debug("{} filtering objectives for dev/port: {}/{}", install ? "Installing" : "Removing", deviceId, portnum);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {}/{} {}", deviceId, portnum, install ? "installed" : "removed"), (objective, error) -> log.warn("Failed to {} filter for {}/{}: {}", install ? "install" : "remove", deviceId, portnum, error));
    if (install) {
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    } else {
        srManager.flowObjectiveService.filter(deviceId, fob.remove(context));
    }
    return true;
}
#end_block

#method_before
private FilteringObjective.Builder buildFilteringObjective(DeviceId deviceId, PortNumber portnum, boolean pushVlan, VlanId vlanId) {
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Processing SinglePortFilters aborted");
        return null;
    }
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    fob.withKey(Criteria.matchInPort(portnum)).addCondition(Criteria.matchEthDst(deviceMac)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    if (pushVlan) {
        fob.addCondition(Criteria.matchVlanId(VlanId.NONE));
        tBuilder.pushVlan().setVlanId(vlanId);
    } else {
        fob.addCondition(Criteria.matchVlanId(vlanId));
    }
    // within the same VLAN on this device.
    if (noMoreEnabledPort(deviceId, vlanId)) {
        tBuilder.wipeDeferred();
    }
    fob.withMeta(tBuilder.build());
    fob.permit().fromApp(srManager.appId);
    return fob;
}
#method_after
private FilteringObjective.Builder buildFilteringObjective(DeviceId deviceId, PortNumber portnum, boolean pushVlan, VlanId vlanId, boolean doTMAC) {
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Processing SinglePortFilters aborted");
        return null;
    }
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    if (doTMAC) {
        fob.withKey(Criteria.matchInPort(portnum)).addCondition(Criteria.matchEthDst(deviceMac)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    } else {
        fob.withKey(Criteria.matchInPort(portnum)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    if (pushVlan) {
        fob.addCondition(Criteria.matchVlanId(VlanId.NONE));
        tBuilder.pushVlan().setVlanId(vlanId);
    } else {
        fob.addCondition(Criteria.matchVlanId(vlanId));
    }
    // within the same VLAN on this device.
    if (noMoreEnabledPort(deviceId, vlanId)) {
        tBuilder.wipeDeferred();
    }
    fob.withMeta(tBuilder.build());
    fob.permit().fromApp(srManager.appId);
    return fob;
}
#end_block

#method_before
public boolean notBos() {
    if ((typeOfDstSet == DestinationSetType.SWAP_NOT_BOS) || (typeOfDstSet == DestinationSetType.NOT_BOS)) {
        return true;
    }
    return false;
}
#method_after
public boolean notBos() {
    if ((typeOfDstSet == DestinationSetType.SWAP_NOT_BOS) || (typeOfDstSet == DestinationSetType.POP_NOT_BOS)) {
        return true;
    }
    return false;
}
#end_block

#method_before
public void createGroupFromDestinationSet(DestinationSet ds, Map<DeviceId, Set<DeviceId>> neighbors, TrafficSelector meta, boolean simple) {
    int nextId = flowObjectiveService.allocateNextId();
    NextObjective.Type type = (simple) ? NextObjective.Type.SIMPLE : NextObjective.Type.HASHED;
    if (neighbors == null || neighbors.isEmpty()) {
        log.warn("createGroupsFromDestinationSet: needs at least one neighbor" + "to create group in dev:{} for ds: {} with next-hops {}", deviceId, ds, neighbors);
        return;
    }
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(type).fromApp(appId);
    if (meta != null) {
        nextObjBuilder.withMeta(meta);
    }
    // create treatment buckets for each neighbor for each dst Device
    // except in the special case where we only want to pick a single
    // neighbor/port for a simple nextObj
    boolean foundSingleNeighbor = false;
    boolean treatmentAdded = false;
    Map<DeviceId, Set<DeviceId>> dstNextHops = new ConcurrentHashMap<>();
    for (DeviceId dst : ds.getDestinationSwitches()) {
        Set<DeviceId> nextHops = neighbors.get(dst);
        if (nextHops == null || nextHops.isEmpty()) {
            continue;
        }
        if (foundSingleNeighbor) {
            break;
        }
        for (DeviceId neighborId : nextHops) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).isEmpty()) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromDestinationset.");
                return;
            }
            // For each port to the neighbor, we create a new treatment
            Set<PortNumber> neighborPorts = devicePortMap.get(neighborId);
            // In this case we need a SIMPLE nextObj. We randomly pick a port
            if (simple) {
                int size = devicePortMap.get(neighborId).size();
                int index = RandomUtils.nextInt(0, size);
                neighborPorts = Collections.singleton(Iterables.get(devicePortMap.get(neighborId), index));
                foundSingleNeighbor = true;
            }
            for (PortNumber sp : neighborPorts) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                int edgeLabel = ds.getEdgeLabel(dst);
                if (edgeLabel != DestinationSet.NO_EDGE_LABEL) {
                    if (simple) {
                        // swap label case
                        tBuilder.setMpls(MplsLabel.mplsLabel(edgeLabel));
                    } else {
                        // ecmp with label push case
                        tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(edgeLabel));
                    }
                }
                if ((ds.getTypeOfDstSet() == DestinationSet.DestinationSetType.SWAP_NOT_BOS) || (ds.getTypeOfDstSet() == DestinationSet.DestinationSetType.NOT_BOS)) {
                    tBuilder.setVlanId(srManager.PSEUDOWIRE_VLAN);
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
                treatmentAdded = true;
                // update store
                Set<DeviceId> existingNeighbors = dstNextHops.get(dst);
                if (existingNeighbors == null) {
                    existingNeighbors = new HashSet<>();
                }
                existingNeighbors.add(neighborId);
                dstNextHops.put(dst, existingNeighbors);
                log.debug("creating treatment for port/label {}/{} in next:{}", sp, edgeLabel, nextId);
            }
            if (foundSingleNeighbor) {
                break;
            }
        }
    }
    if (!treatmentAdded) {
        log.warn("Could not createGroup from DestinationSet {} without any" + "next hops {}", ds, neighbors);
        return;
    }
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromDestinationSet installed " + "NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromDestinationSet failed to install" + " NextObj {} on {}: {}", nextId, deviceId, error));
    NextObjective nextObj = nextObjBuilder.add(context);
    log.debug(".. createGroupsFromDestinationSet: Submitted " + "next objective {} in device {}", nextId, deviceId);
    flowObjectiveService.next(deviceId, nextObj);
    // update store
    dsNextObjStore.put(new DestinationSetNextObjectiveStoreKey(deviceId, ds), new NextNeighbors(dstNextHops, nextId));
}
#method_after
public void createGroupFromDestinationSet(DestinationSet ds, Map<DeviceId, Set<DeviceId>> neighbors, TrafficSelector meta, boolean simple) {
    int nextId = flowObjectiveService.allocateNextId();
    NextObjective.Type type = (simple) ? NextObjective.Type.SIMPLE : NextObjective.Type.HASHED;
    if (neighbors == null || neighbors.isEmpty()) {
        log.warn("createGroupsFromDestinationSet: needs at least one neighbor" + "to create group in dev:{} for ds: {} with next-hops {}", deviceId, ds, neighbors);
        return;
    }
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(type).fromApp(appId);
    if (meta != null) {
        nextObjBuilder.withMeta(meta);
    }
    // create treatment buckets for each neighbor for each dst Device
    // except in the special case where we only want to pick a single
    // neighbor/port for a simple nextObj
    boolean foundSingleNeighbor = false;
    boolean treatmentAdded = false;
    Map<DeviceId, Set<DeviceId>> dstNextHops = new ConcurrentHashMap<>();
    for (DeviceId dst : ds.getDestinationSwitches()) {
        Set<DeviceId> nextHops = neighbors.get(dst);
        if (nextHops == null || nextHops.isEmpty()) {
            continue;
        }
        if (foundSingleNeighbor) {
            break;
        }
        for (DeviceId neighborId : nextHops) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).isEmpty()) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromDestinationset.");
                return;
            }
            // For each port to the neighbor, we create a new treatment
            Set<PortNumber> neighborPorts = devicePortMap.get(neighborId);
            // In this case we need a SIMPLE nextObj. We randomly pick a port
            if (simple) {
                int size = devicePortMap.get(neighborId).size();
                int index = RandomUtils.nextInt(0, size);
                neighborPorts = Collections.singleton(Iterables.get(devicePortMap.get(neighborId), index));
                foundSingleNeighbor = true;
            }
            for (PortNumber sp : neighborPorts) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                int edgeLabel = ds.getEdgeLabel(dst);
                if (edgeLabel != DestinationSet.NO_EDGE_LABEL) {
                    if (simple) {
                        // swap label case
                        tBuilder.setMpls(MplsLabel.mplsLabel(edgeLabel));
                    } else {
                        // ecmp with label push case
                        tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(edgeLabel));
                    }
                }
                if ((ds.getTypeOfDstSet() == DestinationSet.DestinationSetType.SWAP_NOT_BOS) || (ds.getTypeOfDstSet() == DestinationSet.DestinationSetType.POP_NOT_BOS)) {
                    tBuilder.setVlanId(srManager.PSEUDOWIRE_VLAN);
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
                treatmentAdded = true;
                // update store
                Set<DeviceId> existingNeighbors = dstNextHops.get(dst);
                if (existingNeighbors == null) {
                    existingNeighbors = new HashSet<>();
                }
                existingNeighbors.add(neighborId);
                dstNextHops.put(dst, existingNeighbors);
                log.debug("creating treatment for port/label {}/{} in next:{}", sp, edgeLabel, nextId);
            }
            if (foundSingleNeighbor) {
                break;
            }
        }
    }
    if (!treatmentAdded) {
        log.warn("Could not createGroup from DestinationSet {} without any" + "next hops {}", ds, neighbors);
        return;
    }
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromDestinationSet installed " + "NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromDestinationSet failed to install" + " NextObj {} on {}: {}", nextId, deviceId, error));
    NextObjective nextObj = nextObjBuilder.add(context);
    log.debug(".. createGroupsFromDestinationSet: Submitted " + "next objective {} in device {}", nextId, deviceId);
    flowObjectiveService.next(deviceId, nextObj);
    // update store
    dsNextObjStore.put(new DestinationSetNextObjectiveStoreKey(deviceId, ds), new NextNeighbors(dstNextHops, nextId));
}
#end_block

#method_before
@Before
public void setUp() {
    d201 = DeviceId.deviceId("of:0000000000000201");
    d202 = DeviceId.deviceId("of:0000000000000202");
    el201 = 201;
    el202 = 202;
    ds1 = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, d201);
    ds2 = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201);
    ds3 = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201, el202, d202);
    ds4 = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, DestinationSet.NO_EDGE_LABEL, d201, DestinationSet.NO_EDGE_LABEL, d202);
    // not-bos
    ds5 = new DestinationSet(DestinationSet.DestinationSetType.NOT_BOS, d201);
    // swap group
    ds6 = new DestinationSet(DestinationSet.DestinationSetType.SWAP_BOS, el201, d201);
}
#method_after
@Before
public void setUp() {
    d201 = DeviceId.deviceId("of:0000000000000201");
    d202 = DeviceId.deviceId("of:0000000000000202");
    el201 = 201;
    el202 = 202;
    ds1 = DestinationSet.createTypePushNone(d201);
    ds2 = DestinationSet.createTypePushBos(el201, d201);
    ds3 = DestinationSet.createTypePushBos(el201, d201, el202, d202);
    ds4 = DestinationSet.createTypePushBos(DestinationSet.NO_EDGE_LABEL, d201, DestinationSet.NO_EDGE_LABEL, d202);
    ds5 = DestinationSet.createTypePopNotBos(d201);
    ds6 = DestinationSet.createTypeSwapBos(el201, d201);
}
#end_block

#method_before
@Test
public void testOneDestinationWithoutLabel() {
    DestinationSet testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, d201);
    // match
    assertTrue(testds.equals(ds1));
    testds = new DestinationSet(DestinationSet.DestinationSetType.NOT_BOS, d201);
    // wrong notBos
    assertFalse(testds.equals(ds1));
    // correct notBos
    assertTrue(testds.equals(ds5));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, d202);
    // wrong device
    assertFalse(testds.equals(ds1));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201);
    // wrong label
    assertFalse(testds.equals(ds1));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d201, -1, d202);
    // 2-devs should not match
    assertFalse(testds.equals(ds1));
    testds = new DestinationSet(DestinationSet.DestinationSetType.SWAP_BOS, d201);
    // wrong swap
    assertFalse(testds.equals(ds1));
    // wrong label
    assertFalse(testds.equals(ds6));
    testds = new DestinationSet(DestinationSet.DestinationSetType.SWAP_BOS, el201, d201);
    // correct swap
    assertTrue(testds.equals(ds6));
    testds = new DestinationSet(DestinationSet.DestinationSetType.SWAP_BOS, d201);
    // wrong label
    assertFalse(testds.equals(ds6));
    testds = new DestinationSet(DestinationSet.DestinationSetType.SWAP_NOT_BOS, el201, d201);
    // wrong notbos
    assertFalse(testds.equals(ds6));
}
#method_after
@Test
public void testOneDestinationWithoutLabel() {
    DestinationSet testds = DestinationSet.createTypePushNone(d201);
    // match
    assertTrue(testds.equals(ds1));
    testds = DestinationSet.createTypePopNotBos(d201);
    // wrong notBos
    assertFalse(testds.equals(ds1));
    // correct notBos
    assertTrue(testds.equals(ds5));
    testds = DestinationSet.createTypePushNone(d202);
    // wrong device
    assertFalse(testds.equals(ds1));
    testds = DestinationSet.createTypePushBos(el201, d201);
    // wrong label
    assertFalse(testds.equals(ds1));
    testds = DestinationSet.createTypePushBos(-1, d201, -1, d202);
    // 2-devs should not match
    assertFalse(testds.equals(ds1));
    testds = DestinationSet.createTypeSwapBos(el201, d201);
    // wrong type and label
    assertFalse(testds.equals(ds1));
    // correct swap
    assertTrue(testds.equals(ds6));
    testds = DestinationSet.createTypeSwapNotBos(el201, d201);
    // wrong notbos
    assertFalse(testds.equals(ds6));
}
#end_block

#method_before
@Test
public void testOneDestinationWithLabel() {
    DestinationSet testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, 203, d202);
    // wrong label
    assertFalse(testds.equals(ds2));
    testds = new DestinationSet(DestinationSet.DestinationSetType.NOT_BOS, 201, d201);
    // wrong notBos
    assertFalse(testds.equals(ds2));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, 201, d202);
    // wrong device
    assertFalse(testds.equals(ds2));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, 201, DeviceId.deviceId("of:0000000000000201"));
    // match
    assertTrue(testds.equals(ds2));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, d201);
    // wrong label
    assertFalse(testds.equals(ds2));
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201, el202, d202);
    // 2-devs should not match
    assertFalse(testds.equals(ds1));
}
#method_after
@Test
public void testOneDestinationWithLabel() {
    DestinationSet testds = DestinationSet.createTypePushBos(203, d202);
    // wrong label
    assertFalse(testds.equals(ds2));
    testds = DestinationSet.createTypePushBos(201, d202);
    // wrong device
    assertFalse(testds.equals(ds2));
    testds = DestinationSet.createTypePushBos(201, DeviceId.deviceId("of:0000000000000201"));
    // match
    assertTrue(testds.equals(ds2));
    testds = DestinationSet.createTypePushNone(d201);
    // wrong label
    assertFalse(testds.equals(ds2));
    testds = DestinationSet.createTypePushBos(el201, d201, el202, d202);
    // 2-devs should not match
    assertFalse(testds.equals(ds1));
}
#end_block

#method_before
@Test
public void testDestPairWithLabel() {
    DestinationSet testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201, el202, d202);
    // match same switches, same order
    assertTrue(testds.equals(ds3));
    assertTrue(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el202, d202, el201, d201);
    // match same switches, order reversed
    assertTrue(testds.equals(ds3));
    assertTrue(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el202, d202);
    // one less switch should not match
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201);
    // one less switch should not match
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201, 0, DeviceId.NONE);
    // one less switch should not match
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d202, el201, d201);
    // wrong labels
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.NOT_BOS, el202, d202, el201, d201);
    // wrong not bos
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el202, d202, el201, d202);
    // wrong device
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el202, DeviceId.deviceId("of:0000000000000205"), el201, d201);
    // wrong device
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
}
#method_after
@Test
public void testDestPairWithLabel() {
    DestinationSet testds = DestinationSet.createTypePushBos(el201, d201, el202, d202);
    // match same switches, same order
    assertTrue(testds.equals(ds3));
    assertTrue(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el202, d202, el201, d201);
    // match same switches, order reversed
    assertTrue(testds.equals(ds3));
    assertTrue(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el202, d202);
    // one less switch should not match
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el201, d201);
    // one less switch should not match
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el201, d201, 0, DeviceId.NONE);
    // one less switch should not match
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el201, d202, el201, d201);
    // wrong labels
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el202, d202, el201, d202);
    // wrong device
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
    testds = DestinationSet.createTypePushBos(el202, DeviceId.deviceId("of:0000000000000205"), el201, d201);
    // wrong device
    assertFalse(testds.equals(ds3));
    assertFalse(testds.hashCode() == ds3.hashCode());
}
#end_block

#method_before
@Test
public void testDestPairWithoutLabel() {
    DestinationSet testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d201, -1, d202);
    // match same switches, same order
    assertTrue(testds.equals(ds4));
    assertTrue(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d202, -1, d201);
    // match same switches, order reversed
    assertTrue(testds.equals(ds4));
    assertTrue(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d202);
    // one less switch should not match
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d201);
    // one less switch should not match
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d201, 0, DeviceId.NONE);
    // one less switch should not match
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, el201, d201, -1, d202);
    // wrong labels
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.NOT_BOS, -1, d202, -1, d201);
    // wrong mpls set
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, d202, -1, d202);
    // wrong device
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, -1, DeviceId.deviceId("of:0000000000000205"), -1, d201);
    // wrong device
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
}
#method_after
@Test
public void testDestPairWithoutLabel() {
    DestinationSet testds = DestinationSet.createTypePushBos(-1, d201, -1, d202);
    // match same switches, same order
    assertTrue(testds.equals(ds4));
    assertTrue(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(-1, d202, -1, d201);
    // match same switches, order reversed
    assertTrue(testds.equals(ds4));
    assertTrue(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(-1, d202);
    // one less switch should not match
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(-1, d201);
    // one less switch should not match
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(-1, d201, 0, DeviceId.NONE);
    // one less switch should not match
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(el201, d201, -1, d202);
    // wrong labels
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(-1, d202, -1, d202);
    // wrong device
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
    testds = DestinationSet.createTypePushBos(-1, DeviceId.deviceId("of:0000000000000205"), -1, d201);
    // wrong device
    assertFalse(testds.equals(ds4));
    assertFalse(testds.hashCode() == ds4.hashCode());
}
#end_block

#method_before
private int createGroupsForTunnel(Tunnel tunnel) {
    Set<Integer> portNumbers;
    final int groupError = -1;
    DeviceId deviceId = config.getDeviceId(tunnel.labelIds().get(0));
    if (deviceId == null) {
        log.warn("No device found for SID {}", tunnel.labelIds().get(0));
        return groupError;
    } else if (groupHandlerMap.get(deviceId) == null) {
        log.warn("group handler not found for {}", deviceId);
        return groupError;
    }
    Set<DeviceId> deviceIds = new HashSet<>();
    int sid = tunnel.labelIds().get(1);
    if (config.isAdjacencySid(deviceId, sid)) {
        portNumbers = config.getPortsForAdjacencySid(deviceId, sid);
        for (Link link : linkService.getDeviceEgressLinks(deviceId)) {
            for (Integer port : portNumbers) {
                if (link.src().port().toLong() == port) {
                    deviceIds.add(link.dst().deviceId());
                }
            }
        }
    } else {
        deviceIds.add(config.getDeviceId(sid));
    }
    // For these NeighborSet isMpls is meaningless.
    DestinationSet ns = new DestinationSet(DestinationSet.DestinationSetType.DEFAULT, tunnel.labelIds().get(2), DeviceId.NONE);
    // should not remove the group.
    if (groupHandlerMap.get(deviceId).hasNextObjectiveId(ns)) {
        tunnel.allowToRemoveGroup(false);
    } else {
        tunnel.allowToRemoveGroup(true);
    }
    return groupHandlerMap.get(deviceId).getNextObjectiveId(ns, null, null, true);
}
#method_after
private int createGroupsForTunnel(Tunnel tunnel) {
    Set<Integer> portNumbers;
    final int groupError = -1;
    DeviceId deviceId = config.getDeviceId(tunnel.labelIds().get(0));
    if (deviceId == null) {
        log.warn("No device found for SID {}", tunnel.labelIds().get(0));
        return groupError;
    } else if (groupHandlerMap.get(deviceId) == null) {
        log.warn("group handler not found for {}", deviceId);
        return groupError;
    }
    Set<DeviceId> deviceIds = new HashSet<>();
    int sid = tunnel.labelIds().get(1);
    if (config.isAdjacencySid(deviceId, sid)) {
        portNumbers = config.getPortsForAdjacencySid(deviceId, sid);
        for (Link link : linkService.getDeviceEgressLinks(deviceId)) {
            for (Integer port : portNumbers) {
                if (link.src().port().toLong() == port) {
                    deviceIds.add(link.dst().deviceId());
                }
            }
        }
    } else {
        deviceIds.add(config.getDeviceId(sid));
    }
    // For these NeighborSet isMpls is meaningless.
    // TODO : Revisit this, the code and also the type
    DestinationSet ns = DestinationSet.createTypePushBos(tunnel.labelIds().get(2), DeviceId.NONE);
    // should not remove the group.
    if (groupHandlerMap.get(deviceId).hasNextObjectiveId(ns)) {
        tunnel.allowToRemoveGroup(false);
    } else {
        tunnel.allowToRemoveGroup(true);
    }
    return groupHandlerMap.get(deviceId).getNextObjectiveId(ns, null, null, true);
}
#end_block

#method_before
private void updateCache() {
    // FIXME: This guard causes some issues so comment out as workaround
    // Now cache update conducts every time request comes, it costs a lot,
    // Something to avoid it is needed.
    log.info("Dirty: {}, Source updated: {}", isDirty, sourceUpdated);
    if (isDirty || sourceUpdated) {
        sourceUpdated = false;
        clearCache();
        dataProvider.updateCacheRequest(this);
        log.info("Update completed: {}", tapiNodeRefList);
        isDirty = false;
    }
}
#method_after
private void updateCache() {
    log.info("Dirty: {}, Source updated: {}", isDirty, sourceUpdated);
    if (isDirty || sourceUpdated) {
        sourceUpdated = false;
        clearCache();
        dataProvider.updateCacheRequest(this);
        log.info("Update completed: {}", tapiNodeRefList);
        isDirty = false;
    }
}
#end_block

#method_before
private void clearCache() {
    tapiNodeRefList = new ArrayList<>();
    tapiNepRefList = new ArrayList<>();
}
#method_after
private void clearCache() {
    tapiNodeRefList.clear();
    tapiNepRefList.clear();
}
#end_block

#method_before
private List<TapiNepRef> getNeps(ModelObject context) {
    Augmentable augmentedContext = (Augmentable) context;
    DefaultAugmentedTapiCommonContext topologyContext = augmentedContext.augmentation(DefaultAugmentedTapiCommonContext.class);
    Topology topology = topologyContext.topology().get(0);
    if (topology.node() == null) {
        return Collections.emptyList();
    }
    List<TapiNepRef> ret = topology.node().stream().flatMap(node -> {
        if (node.ownedNodeEdgePoint() == null) {
            return null;
        }
        return node.ownedNodeEdgePoint().stream().map(nep -> {
            String onosConnectPoint = nep.name().stream().filter(kv -> kv.valueName().equals(ONOS_CP)).findFirst().map(Name::value).get();
            TapiNepRef nepRef = DcsBasedTapiNepRef.create(topology, node, nep).setConnectPoint(ConnectPoint.fromString(onosConnectPoint));
            if (nep.mappedServiceInterfacePoint() != null) {
                nep.mappedServiceInterfacePoint().stream().forEach(sip -> {
                    nepRef.setSipId(sip.serviceInterfacePointId().toString());
                });
            }
            return nepRef;
        });
    }).collect(Collectors.toList());
    System.out.println(ret);
    return ret;
}
#method_after
private List<TapiNepRef> getNeps(ModelObject context) {
    Augmentable augmentedContext = (Augmentable) context;
    DefaultAugmentedTapiCommonContext topologyContext = augmentedContext.augmentation(DefaultAugmentedTapiCommonContext.class);
    Topology topology = topologyContext.topology().get(0);
    if (topology.node() == null) {
        return Collections.emptyList();
    }
    List<TapiNepRef> ret = topology.node().stream().flatMap(node -> {
        if (node.ownedNodeEdgePoint() == null) {
            return null;
        }
        return node.ownedNodeEdgePoint().stream().map(nep -> {
            String onosConnectPoint = nep.name().stream().filter(kv -> kv.valueName().equals(ONOS_CP)).findFirst().map(Name::value).get();
            TapiNepRef nepRef = DcsBasedTapiNepRef.create(topology, node, nep).setConnectPoint(ConnectPoint.fromString(onosConnectPoint));
            if (nep.mappedServiceInterfacePoint() != null) {
                nep.mappedServiceInterfacePoint().stream().forEach(sip -> {
                    nepRef.setSipId(sip.serviceInterfacePointId().toString());
                });
            }
            return nepRef;
        });
    }).collect(Collectors.toList());
    return ret;
}
#end_block

#method_before
@Override
public void event(DynamicConfigEvent event) {
    resolver.getDirty();
    ResourceId rsId = event.subject();
    DataNode node;
    try {
        Filter filter = Filter.builder().addCriteria(rsId).build();
        node = dynConfigService.readNode(rsId, filter);
    } catch (FailedException e) {
        node = null;
    }
    switch(event.type()) {
        case NODE_ADDED:
            onDcsNodeAdded(rsId, node);
            break;
        case NODE_DELETED:
            onDcsNodeDeleted(node);
            break;
        default:
            log.warn("Unknown Event", event.type());
            break;
    }
}
#method_after
@Override
public void event(DynamicConfigEvent event) {
    resolver.makeDirty();
    ResourceId rsId = event.subject();
    DataNode node;
    try {
        Filter filter = Filter.builder().addCriteria(rsId).build();
        node = dynConfigService.readNode(rsId, filter);
    } catch (FailedException e) {
        node = null;
    }
    switch(event.type()) {
        case NODE_ADDED:
            onDcsNodeAdded(rsId, node);
            break;
        case NODE_DELETED:
            onDcsNodeDeleted(node);
            break;
        default:
            log.warn("Unknown Event", event.type());
            break;
    }
}
#end_block

#method_before
@GET
@Produces(MediaTypeRestconf.APPLICATION_YANG_DATA_JSON)
@Path("data/{identifier : .+}")
public Response handleGetRequest(@PathParam("identifier") String uriString) {
    log.debug("handleGetRequest: {}", uriString);
    URI uri = uriInfo.getRequestUri();
    try {
        ObjectNode node = service.runGetOperationOnDataResource(uri);
        if (node == null) {
            RestconfError error = RestconfError.builder(RestconfError.ErrorType.PROTOCOL, RestconfError.ErrorTag.INVALID_VALUE).errorMessage("Resource not found").errorPath(uriString).errorAppTag("handleGetRequest").build();
            return Response.status(NOT_FOUND).entity(RestconfError.wrapErrorAsJson(Arrays.asList(error))).type(MediaTypeRestconf.APPLICATION_YANG_DATA_JSON_TYPE).build();
        }
        return Response.ok(node, MediaTypeRestconf.APPLICATION_YANG_DATA_JSON_TYPE).build();
    } catch (RestconfException e) {
        log.error("ERROR: handleGetRequest: {}", e.getMessage());
        log.debug("Exception in handleGetRequest:", e);
        return Response.status(e.getResponse().getStatus()).entity(e.toRestconfErrorJson()).type(MediaTypeRestconf.APPLICATION_YANG_DATA_JSON_TYPE).build();
    } catch (Exception e) {
        RestconfError error = RestconfError.builder(RestconfError.ErrorType.APPLICATION, RestconfError.ErrorTag.OPERATION_FAILED).errorMessage(e.getMessage()).errorAppTag("handlePostRequest").build();
        return Response.status(INTERNAL_SERVER_ERROR).entity(RestconfError.wrapErrorAsJson(Arrays.asList(error))).type(MediaTypeRestconf.APPLICATION_YANG_DATA_JSON_TYPE).build();
    }
}
#method_after
@GET
@Produces(MediaTypeRestconf.APPLICATION_YANG_DATA_JSON)
@Path("data/{identifier : .+}")
public Response handleGetRequest(@PathParam("identifier") String uriString) {
    log.debug("handleGetRequest: {}", uriString);
    URI uri = uriInfo.getRequestUri();
    try {
        ObjectNode node = service.runGetOperationOnDataResource(uri);
        if (node == null) {
            RestconfError error = RestconfError.builder(RestconfError.ErrorType.PROTOCOL, RestconfError.ErrorTag.INVALID_VALUE).errorMessage("Resource not found").errorPath(uriString).errorAppTag("handleGetRequest").build();
            return Response.status(NOT_FOUND).entity(RestconfError.wrapErrorAsJson(Arrays.asList(error))).build();
        }
        return Response.ok(node).build();
    } catch (RestconfException e) {
        log.error("ERROR: handleGetRequest: {}", e.getMessage());
        log.debug("Exception in handleGetRequest:", e);
        return Response.status(e.getResponse().getStatus()).entity(e.toRestconfErrorJson()).build();
    } catch (Exception e) {
        RestconfError error = RestconfError.builder(RestconfError.ErrorType.APPLICATION, RestconfError.ErrorTag.OPERATION_FAILED).errorMessage(e.getMessage()).errorAppTag("handlePostRequest").build();
        return Response.status(INTERNAL_SERVER_ERROR).entity(RestconfError.wrapErrorAsJson(Arrays.asList(error))).build();
    }
}
#end_block

#method_before
@Override
public ObjectNode encodeCriterion(ObjectNode root, Criterion criterion) {
    final PiCriterion piCriterion = (PiCriterion) criterion;
    ArrayNode matchNodes = context.mapper().createArrayNode();
    for (PiFieldMatch fieldMatch : piCriterion.fieldMatches()) {
        switch(fieldMatch.type()) {
            case EXACT:
                ObjectNode matchExactNode = context.mapper().createObjectNode();
                matchExactNode.put(CriterionCodec.PI_MATCH_FIELD_ID, fieldMatch.fieldId().id());
                matchExactNode.put(CriterionCodec.PI_MATCH_VALUE, ((PiExactFieldMatch) fieldMatch).value().toString());
                matchNodes.add(matchExactNode);
                break;
            case LPM:
                // FIXME: how do decide which method with different type of parameters should be use?
                ObjectNode matchLpmNode = context.mapper().createObjectNode();
                matchLpmNode.put(CriterionCodec.PI_MATCH_FIELD_ID, fieldMatch.fieldId().id());
                matchLpmNode.put(CriterionCodec.PI_MATCH_VALUE, ((PiLpmFieldMatch) fieldMatch).value().toString());
                matchLpmNode.put(CriterionCodec.PI_MATCH_PREFIX, ((PiLpmFieldMatch) fieldMatch).prefixLength());
                matchNodes.add(matchLpmNode);
                break;
            case TERNARY:
                ObjectNode matchTernaryNode = context.mapper().createObjectNode();
                matchTernaryNode.put(CriterionCodec.PI_MATCH_FIELD_ID, fieldMatch.fieldId().id());
                matchTernaryNode.put(CriterionCodec.PI_MATCH_VALUE, ((PiTernaryFieldMatch) fieldMatch).value().toString());
                matchTernaryNode.put(CriterionCodec.PI_MATCH_MASK, ((PiTernaryFieldMatch) fieldMatch).mask().toString());
                matchNodes.add(matchTernaryNode);
                break;
            case RANGE:
                ObjectNode matchRangeNode = context.mapper().createObjectNode();
                matchRangeNode.put(CriterionCodec.PI_MATCH_FIELD_ID, fieldMatch.fieldId().id());
                matchRangeNode.put(CriterionCodec.PI_MATCH_HIGH_VALUE, ((PiRangeFieldMatch) fieldMatch).highValue().toString());
                matchRangeNode.put(CriterionCodec.PI_MATCH_LOW_VALUE, ((PiRangeFieldMatch) fieldMatch).lowValue().toString());
                matchNodes.add(matchRangeNode);
                break;
            case VALID:
                ObjectNode matchValidNode = context.mapper().createObjectNode();
                matchValidNode.put(CriterionCodec.PI_MATCH_FIELD_ID, fieldMatch.fieldId().id());
                matchValidNode.put(CriterionCodec.PI_MATCH_VALUE, ((PiValidFieldMatch) fieldMatch).isValid());
                matchNodes.add(matchValidNode);
                break;
            default:
                throw new IllegalArgumentException("Type " + fieldMatch.type().name() + " is unsupported");
        }
    }
    return (ObjectNode) root.set(CriterionCodec.PI_MATCHES, matchNodes);
}
#method_after
@Override
public ObjectNode encodeCriterion(ObjectNode root, Criterion criterion) {
    final PiCriterion piCriterion = (PiCriterion) criterion;
    ArrayNode matchNodes = context.mapper().createArrayNode();
    for (PiFieldMatch fieldMatch : piCriterion.fieldMatches()) {
        switch(fieldMatch.type()) {
            case EXACT:
                matchNodes.add(parsePiMatchExact((PiExactFieldMatch) fieldMatch));
                break;
            case LPM:
                matchNodes.add(parsePiMatchLpm((PiLpmFieldMatch) fieldMatch));
                break;
            case TERNARY:
                matchNodes.add(parsePiMatchTernary((PiTernaryFieldMatch) fieldMatch));
                break;
            case RANGE:
                matchNodes.add(parsePiMatchRange((PiRangeFieldMatch) fieldMatch));
                break;
            case VALID:
                matchNodes.add(parsePiMatchValid((PiValidFieldMatch) fieldMatch));
                break;
            default:
                throw new IllegalArgumentException("Type " + fieldMatch.type().name() + " is unsupported");
        }
    }
    return (ObjectNode) root.set(CriterionCodec.PI_MATCHES, matchNodes);
}
#end_block

#method_before
public Instruction decode() {
    String type = nullIsIllegal(json.get(InstructionCodec.TYPE), InstructionCodec.TYPE + InstructionCodec.ERROR_MESSAGE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        return Instructions.createOutput(getPortNumber(json));
    } else if (type.equals(Instruction.Type.NOACTION.name())) {
        return Instructions.createNoAction();
    } else if (type.equals(Instruction.Type.TABLE.name())) {
        return Instructions.transition(nullIsIllegal(json.get(InstructionCodec.TABLE_ID), InstructionCodec.TABLE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
    } else if (type.equals(Instruction.Type.GROUP.name())) {
        GroupId groupId = new GroupId(nullIsIllegal(json.get(InstructionCodec.GROUP_ID), InstructionCodec.GROUP_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
        return Instructions.createGroup(groupId);
    } else if (type.equals(Instruction.Type.METER.name())) {
        MeterId meterId = MeterId.meterId(nullIsIllegal(json.get(InstructionCodec.METER_ID), InstructionCodec.METER_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong());
        return Instructions.meterTraffic(meterId);
    } else if (type.equals(Instruction.Type.QUEUE.name())) {
        long queueId = nullIsIllegal(json.get(InstructionCodec.QUEUE_ID), InstructionCodec.QUEUE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong();
        if (json.get(InstructionCodec.PORT) == null || json.get(InstructionCodec.PORT).isNull()) {
            return Instructions.setQueue(queueId, null);
        } else {
            return Instructions.setQueue(queueId, getPortNumber(json));
        }
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    } else if (type.equals(Instruction.Type.EXTENSION.name())) {
        return decodeExtension();
    } else if (type.equals(Instruction.Type.STAT_TRIGGER.name())) {
        return decodeStatTrigger();
    } else if (type.equals(Instruction.Type.PROTOCOL_INDEPENDENT.name())) {
        decodePI();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#method_after
public Instruction decode() {
    String type = nullIsIllegal(json.get(InstructionCodec.TYPE), InstructionCodec.TYPE + InstructionCodec.ERROR_MESSAGE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        return Instructions.createOutput(getPortNumber(json));
    } else if (type.equals(Instruction.Type.NOACTION.name())) {
        return Instructions.createNoAction();
    } else if (type.equals(Instruction.Type.TABLE.name())) {
        return Instructions.transition(nullIsIllegal(json.get(InstructionCodec.TABLE_ID), InstructionCodec.TABLE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
    } else if (type.equals(Instruction.Type.GROUP.name())) {
        GroupId groupId = new GroupId(nullIsIllegal(json.get(InstructionCodec.GROUP_ID), InstructionCodec.GROUP_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
        return Instructions.createGroup(groupId);
    } else if (type.equals(Instruction.Type.METER.name())) {
        MeterId meterId = MeterId.meterId(nullIsIllegal(json.get(InstructionCodec.METER_ID), InstructionCodec.METER_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong());
        return Instructions.meterTraffic(meterId);
    } else if (type.equals(Instruction.Type.QUEUE.name())) {
        long queueId = nullIsIllegal(json.get(InstructionCodec.QUEUE_ID), InstructionCodec.QUEUE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong();
        if (json.get(InstructionCodec.PORT) == null || json.get(InstructionCodec.PORT).isNull()) {
            return Instructions.setQueue(queueId, null);
        } else {
            return Instructions.setQueue(queueId, getPortNumber(json));
        }
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    } else if (type.equals(Instruction.Type.EXTENSION.name())) {
        return decodeExtension();
    } else if (type.equals(Instruction.Type.STAT_TRIGGER.name())) {
        return decodeStatTrigger();
    } else if (type.equals(Instruction.Type.PROTOCOL_INDEPENDENT.name())) {
        return decodePi();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#end_block

#method_before
public ObjectNode encode() {
    final ObjectNode result = context.mapper().createObjectNode().put(InstructionCodec.TYPE, instruction.type().toString());
    switch(instruction.type()) {
        case OUTPUT:
            final Instructions.OutputInstruction outputInstruction = (Instructions.OutputInstruction) instruction;
            result.put(InstructionCodec.PORT, outputInstruction.port().toString());
            break;
        case NOACTION:
            break;
        case GROUP:
            final Instructions.GroupInstruction groupInstruction = (Instructions.GroupInstruction) instruction;
            result.put(InstructionCodec.GROUP_ID, groupInstruction.groupId().toString());
            break;
        case METER:
            final Instructions.MeterInstruction meterInstruction = (Instructions.MeterInstruction) instruction;
            result.put(InstructionCodec.METER_ID, meterInstruction.meterId().toString());
            break;
        case TABLE:
            final Instructions.TableTypeTransition tableTransitionInstruction = (Instructions.TableTypeTransition) instruction;
            result.put(InstructionCodec.TABLE_ID, tableTransitionInstruction.tableId().toString());
            break;
        case QUEUE:
            final Instructions.SetQueueInstruction setQueueInstruction = (Instructions.SetQueueInstruction) instruction;
            result.put(InstructionCodec.QUEUE_ID, setQueueInstruction.queueId());
            if (setQueueInstruction.port() != null) {
                result.put(InstructionCodec.PORT, setQueueInstruction.port().toString());
            }
            break;
        case L0MODIFICATION:
            encodeL0(result);
            break;
        case L1MODIFICATION:
            encodeL1(result);
            break;
        case L2MODIFICATION:
            encodeL2(result);
            break;
        case L3MODIFICATION:
            encodeL3(result);
            break;
        case L4MODIFICATION:
            encodeL4(result);
            break;
        case PROTOCOL_INDEPENDENT:
            encodePI(result);
            break;
        case EXTENSION:
            encodeExtension(result);
            break;
        default:
            log.info("Cannot convert instruction type of {}", instruction.type());
            break;
    }
    return result;
}
#method_after
public ObjectNode encode() {
    final ObjectNode result = context.mapper().createObjectNode().put(InstructionCodec.TYPE, instruction.type().toString());
    switch(instruction.type()) {
        case OUTPUT:
            final Instructions.OutputInstruction outputInstruction = (Instructions.OutputInstruction) instruction;
            result.put(InstructionCodec.PORT, outputInstruction.port().toString());
            break;
        case NOACTION:
            break;
        case GROUP:
            final Instructions.GroupInstruction groupInstruction = (Instructions.GroupInstruction) instruction;
            result.put(InstructionCodec.GROUP_ID, groupInstruction.groupId().toString());
            break;
        case METER:
            final Instructions.MeterInstruction meterInstruction = (Instructions.MeterInstruction) instruction;
            result.put(InstructionCodec.METER_ID, meterInstruction.meterId().toString());
            break;
        case TABLE:
            final Instructions.TableTypeTransition tableTransitionInstruction = (Instructions.TableTypeTransition) instruction;
            result.put(InstructionCodec.TABLE_ID, tableTransitionInstruction.tableId().toString());
            break;
        case QUEUE:
            final Instructions.SetQueueInstruction setQueueInstruction = (Instructions.SetQueueInstruction) instruction;
            result.put(InstructionCodec.QUEUE_ID, setQueueInstruction.queueId());
            if (setQueueInstruction.port() != null) {
                result.put(InstructionCodec.PORT, setQueueInstruction.port().toString());
            }
            break;
        case L0MODIFICATION:
            encodeL0(result);
            break;
        case L1MODIFICATION:
            encodeL1(result);
            break;
        case L2MODIFICATION:
            encodeL2(result);
            break;
        case L3MODIFICATION:
            encodeL3(result);
            break;
        case L4MODIFICATION:
            encodeL4(result);
            break;
        case PROTOCOL_INDEPENDENT:
            encodePi(result);
            break;
        case EXTENSION:
            encodeExtension(result);
            break;
        default:
            log.info("Cannot convert instruction type of {}", instruction.type());
            break;
    }
    return result;
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onosproject.nodemetrics");
    cfgService.registerProperties(getClass());
    metricsExecutor = Executors.newSingleThreadScheduledExecutor(Tools.groupedThreads("nodemetrics/pollingStatics", "statistics-executor-%d", log));
    localNodeId = clusterService.getLocalNode().id();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NodeMemoryUsage.class).register(NodeDiskUsage.class).register(NodeCpuUsage.class).register(Units.class);
    memoryStore = storageService.<NodeId, NodeMemoryUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, memory) -> clockService.getTimestamp()).withName("nodemetrics-memory").build();
    diskStore = storageService.<NodeId, NodeDiskUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, disk) -> clockService.getTimestamp()).withName("nodemetrics-disk").build();
    cpuStore = storageService.<NodeId, NodeCpuUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, cpu) -> clockService.getTimestamp()).withName("nodemetrics-cpu").build();
    if (context == null) {
        metricPollFrequencySeconds = DEFAULT_POLL_FREQUENCY_SECONDS;
        log.info("No component configuration");
    } else {
        Dictionary<?, ?> properties = context.getProperties();
        metricPollFrequencySeconds = getNewPollFrequency(properties, metricPollFrequencySeconds);
    }
    scheduledTask = schedulePolling();
    sigar = new Sigar();
    pollMetrics();
}
#method_after
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onosproject.nodemetrics");
    cfgService.registerProperties(getClass());
    metricsExecutor = Executors.newSingleThreadScheduledExecutor(Tools.groupedThreads("nodemetrics/pollingStatics", "statistics-executor-%d", log));
    localNodeId = clusterService.getLocalNode().id();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NodeMemoryUsage.class).register(NodeDiskUsage.class).register(NodeCpuUsage.class).register(Units.class);
    memoryStore = storageService.<NodeId, NodeMemoryUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, memory) -> clockService.getTimestamp()).withName("nodemetrics-memory").build();
    diskStore = storageService.<NodeId, NodeDiskUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, disk) -> clockService.getTimestamp()).withName("nodemetrics-disk").build();
    cpuStore = storageService.<NodeId, NodeCpuUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, cpu) -> clockService.getTimestamp()).withName("nodemetrics-cpu").build();
    modified(context);
    sigar = new Sigar();
    pollMetrics();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    scheduledTask.cancel(true);
    metricsExecutor.shutdown();
    sigar.close();
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    scheduledTask.cancel(true);
    metricsExecutor.shutdown();
    sigar.close();
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        log.info("No component configuration");
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    int newPollFrequency = getNewPollFrequency(properties, metricPollFrequencySeconds);
    if (newPollFrequency != metricPollFrequencySeconds) {
        metricPollFrequencySeconds = newPollFrequency;
        // stops the old scheduled task
        scheduledTask.cancel(true);
        // schedules new task at the new polling rate
        scheduledTask = schedulePolling();
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        log.info("No component configuration");
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    int newPollFrequency = getNewPollFrequency(properties);
    // First time call to this modified method is when app activates
    if (Objects.isNull(scheduledTask)) {
        metricPollFrequencySeconds = newPollFrequency;
        scheduledTask = schedulePolling();
    } else {
        if (newPollFrequency != metricPollFrequencySeconds) {
            metricPollFrequencySeconds = newPollFrequency;
            // stops the old scheduled task
            scheduledTask.cancel(true);
            // schedules new task at the new polling rate
            scheduledTask = schedulePolling();
        }
    }
}
#end_block

#method_before
private int getNewPollFrequency(Dictionary<?, ?> properties, int pollFrequency) {
    int newPollFrequency;
    try {
        String s = get(properties, "metricPollFrequencySeconds");
        newPollFrequency = isNullOrEmpty(s) ? pollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newPollFrequency = DEFAULT_POLL_FREQUENCY_SECONDS;
    }
    return newPollFrequency;
}
#method_after
private int getNewPollFrequency(Dictionary<?, ?> properties) {
    int newPollFrequency;
    try {
        newPollFrequency = getIntegerProperty(properties, "metricPollFrequencySeconds");
    // String s = getIntegerProperty(properties, "metricPollFrequencySeconds");
    // newPollFrequency = isNullOrEmpty(s) ? pollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newPollFrequency = DEFAULT_POLL_FREQUENCY_SECONDS;
    }
    return newPollFrequency;
}
#end_block

#method_before
private void cleanup() {
    int corruptCount = 0, failedCount = 0, stuckCount = 0, pendingCount = 0, skipped = 0;
    // will add items to the pending map.
    for (IntentData intentData : store.getPendingData(true, periodMs)) {
        log.debug("Resubmit Pending Intent: key {}, state {}, request {}", intentData.key(), intentData.state(), intentData.request());
        resubmitPendingRequest(intentData);
        pendingCount++;
    }
    for (IntentData intentData : store.getIntentData(true, periodMs)) {
        IntentData pendingIntentData = store.getPendingData(intentData.key());
        if (pendingIntentData == null) {
            switch(intentData.state()) {
                case FAILED:
                    log.debug("Resubmit Failed Intent: key {}, state {}, request {}", intentData.key(), intentData.state(), intentData.request());
                    resubmitCorrupt(intentData, false);
                    failedCount++;
                    break;
                case CORRUPT:
                    log.debug("Resubmit Corrupt Intent: key {}, state {}, request {}", intentData.key(), intentData.state(), intentData.request());
                    resubmitCorrupt(intentData, false);
                    corruptCount++;
                    break;
                // FALLTHROUGH
                case INSTALLING:
                case WITHDRAWING:
                    // Instances can have different clocks and potentially we can have problems
                    // An Intent can be submitted again before the real period of the stuck intents
                    final WallClockTimestamp time = new WallClockTimestamp(System.currentTimeMillis() - periodMsForStuck);
                    if (intentData.version().isOlderThan(time)) {
                        resubmitPendingRequest(intentData);
                        stuckCount++;
                    } else {
                        skipped++;
                    }
                    break;
                default:
                    // NOOP
                    break;
            }
        } else {
            skipped++;
        }
    }
    if (corruptCount + failedCount + stuckCount + pendingCount > 0) {
        log.debug("Intent cleanup ran and resubmitted {} corrupt, {} failed, {} stuck, and {} pending intents", corruptCount, failedCount, stuckCount, pendingCount);
    }
    if (skipped > 0) {
        log.debug("Intent cleanup skipped {} intents", skipped);
    }
}
#method_after
private void cleanup() {
    int corruptCount = 0, failedCount = 0, stuckCount = 0, pendingCount = 0, skipped = 0;
    // will add items to the pending map.
    for (IntentData intentData : store.getPendingData(true, periodMs)) {
        log.debug("Resubmit Pending Intent: key {}, state {}, request {}", intentData.key(), intentData.state(), intentData.request());
        resubmitPendingRequest(intentData);
        pendingCount++;
    }
    for (IntentData intentData : store.getIntentData(true, periodMs)) {
        IntentData pendingIntentData = store.getPendingData(intentData.key());
        if (pendingIntentData != null) {
            continue;
        }
        switch(intentData.state()) {
            case FAILED:
                log.debug("Resubmit Failed Intent: key {}, state {}, request {}", intentData.key(), intentData.state(), intentData.request());
                resubmitCorrupt(intentData, false);
                failedCount++;
                break;
            case CORRUPT:
                log.debug("Resubmit Corrupt Intent: key {}, state {}, request {}", intentData.key(), intentData.state(), intentData.request());
                resubmitCorrupt(intentData, false);
                corruptCount++;
                break;
            // FALLTHROUGH
            case INSTALLING:
            case WITHDRAWING:
                // Instances can have different clocks and potentially we can have problems
                // An Intent can be submitted again before the real period of the stuck intents
                final WallClockTimestamp time = new WallClockTimestamp(System.currentTimeMillis() - periodMsForStuck);
                if (intentData.version().isOlderThan(time)) {
                    resubmitPendingRequest(intentData);
                    stuckCount++;
                } else {
                    skipped++;
                }
                break;
            default:
                // NOOP
                break;
        }
    }
    if (corruptCount + failedCount + stuckCount + pendingCount > 0) {
        log.debug("Intent cleanup ran and resubmitted {} corrupt, {} failed, {} stuck, and {} pending intents", corruptCount, failedCount, stuckCount, pendingCount);
    }
    if (skipped > 0) {
        log.debug("Intent cleanup skipped {} intents", skipped);
    }
}
#end_block

#method_before
public boolean isSip() {
    // FIXME modify this condition to appropriate way
    return kvs.get(ONOS_CP).contains("TRANSCEIVER");
}
#method_after
public static boolean isSip(Port port) {
    // FIXME modify this method to appropriate way
    ConnectPoint cp = new ConnectPoint(port.element().id(), port.number());
    return cp.toString().contains("TRANSCEIVER");
}
#end_block

#method_before
public TapiSipBuilder setPort(Port port) {
    ConnectPoint cp = new ConnectPoint(port.element().id(), port.number());
    kvs.put("onos-cp", cp.toString());
    setGlobalClassConfig(sip, kvs);
    sip.addToLayerProtocolName(LayerProtocolName.of(DSR));
    return this;
}
#method_after
public TapiSipBuilder setPort(Port port) {
    if (!isSip(port)) {
        throw new IllegalStateException("Not allowed to use this port as SIP.");
    }
    ConnectPoint cp = new ConnectPoint(port.element().id(), port.number());
    kvs.put(ONOS_CP, cp.toString());
    sip.addToLayerProtocolName(LayerProtocolName.of(DSR));
    return this;
}
#end_block

#method_before
@Override
public ModelObjectData build() {
    if (!isSip()) {
        throw new IllegalStateException("Not allowed to use as SIP");
    }
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).build();
    return getModelObjectData(sip, objId);
}
#method_after
@Override
public ModelObjectData build() {
    setNameList(sip, kvs);
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).build();
    return getModelObjectData(sip, objId);
}
#end_block

#method_before
public TapiNepBuilder setPort(Port port) {
    ConnectPoint cp = new ConnectPoint(port.element().id(), port.number());
    kvs.put(ONOS_CP, cp.toString());
    setGlobalClassConfig(nep, kvs);
    return this;
}
#method_after
public TapiNepBuilder setPort(Port port) {
    cp = new ConnectPoint(port.element().id(), port.number());
    kvs.put(ONOS_CP, cp.toString());
    return this;
}
#end_block

#method_before
@Override
public ModelObjectData build() {
    TopologyKeys topologyKey = new TopologyKeys();
    topologyKey.uuid(topologyUuid);
    NodeKeys nodeKey = new NodeKeys();
    nodeKey.uuid(nodeUuid);
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).addChild(DefaultTopology.class, topologyKey).addChild(DefaultNode.class, nodeKey).build();
    return getModelObjectData(nep, objId);
}
#method_after
@Override
public ModelObjectData build() {
    setNameList(nep, kvs);
    TopologyKeys topologyKey = new TopologyKeys();
    topologyKey.uuid(topologyUuid);
    NodeKeys nodeKey = new NodeKeys();
    nodeKey.uuid(nodeUuid);
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).addChild(DefaultTopology.class, topologyKey).addChild(DefaultNode.class, nodeKey).build();
    return getModelObjectData(nep, objId);
}
#end_block

#method_before
@Override
public ModelObjectData build() {
    TopologyKeys topologyKey = new TopologyKeys();
    topologyKey.uuid(topologyUuid);
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).addChild(DefaultTopology.class, topologyKey).build();
    return getModelObjectData(node, objId);
}
#method_after
@Override
public ModelObjectData build() {
    setNameList(node, kvs);
    TopologyKeys topologyKey = new TopologyKeys();
    topologyKey.uuid(topologyUuid);
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).addChild(DefaultTopology.class, topologyKey).build();
    return getModelObjectData(node, objId);
}
#end_block

#method_before
@Override
public ModelObjectData build() {
    ModelObjectId objId = ModelObjectId.builder().build();
    return getModelObjectData(link, objId);
}
#method_after
@Override
public ModelObjectData build() {
    TopologyKeys topologyKey = new TopologyKeys();
    topologyKey.uuid(topologyUuid);
    ModelObjectId objId = ModelObjectId.builder().addChild(DefaultContext.class).addChild(DefaultTopology.class, topologyKey).build();
    return getModelObjectData(link, objId);
}
#end_block

#method_before
private static <T extends ModelObject> Uuid setUuid(T obj) {
    Uuid uuid = Uuid.of(UUID.randomUUID().toString());
    @SuppressWarnings("unchecked")
    Class<T> cls = (Class<T>) obj.getClass();
    try {
        Method method = cls.getMethod("uuid", Uuid.class);
        method.invoke(obj, uuid);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        e.printStackTrace();
    }
    return uuid;
}
#method_after
public static <T extends ModelObject> Uuid setUuid(T obj) {
    Uuid uuid = Uuid.of(UUID.randomUUID().toString());
    @SuppressWarnings("unchecked")
    Class<T> cls = (Class<T>) obj.getClass();
    try {
        Method method = cls.getMethod("uuid", Uuid.class);
        method.invoke(obj, uuid);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        log.error("Exception thrown", e);
    }
    return uuid;
}
#end_block

#method_before
private static <T extends ModelObject> void setNameList(T obj, Map<String, String> kvs) {
    @SuppressWarnings("unchecked")
    Class<T> cls = (Class<T>) obj.getClass();
    try {
        Method method = cls.getMethod("addToName", Name.class);
        for (Entry<String, String> kv : kvs.entrySet()) {
            DefaultName prop = new DefaultName();
            prop.valueName(kv.getKey());
            prop.value(kv.getValue());
            method.invoke(obj, prop);
        }
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        e.printStackTrace();
    }
}
#method_after
public static <T extends ModelObject> void setNameList(T obj, Map<String, String> kvs) {
    @SuppressWarnings("unchecked")
    Class<T> cls = (Class<T>) obj.getClass();
    try {
        Method method = cls.getMethod("addToName", Name.class);
        for (Entry<String, String> kv : kvs.entrySet()) {
            DefaultName prop = new DefaultName();
            prop.valueName(kv.getKey());
            prop.value(kv.getValue());
            method.invoke(obj, prop);
        }
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        log.error("Exception thrown", e);
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    log.info("Started");
    dynConfigService.addListener(dynamicConfigServiceListener);
    deviceService.addListener(deviceListener);
    linkService.addListener(linkListener);
    rpcRegistry.registerRpcService(rpcTapiConnectivity);
}
#method_after
@Activate
protected void activate() {
    log.info("Started");
    // dynConfigService.addListener(dynamicConfigServiceListener);
    deviceService.addListener(deviceListener);
    linkService.addListener(linkListener);
    rpcRegistry.registerRpcService(rpcTapiConnectivity);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopped");
    rpcRegistry.unregisterRpcService(rpcTapiConnectivity);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    dynConfigService.removeListener(dynamicConfigServiceListener);
}
#method_after
@Deactivate
protected void deactivate() {
    log.info("Stopped");
    rpcRegistry.unregisterRpcService(rpcTapiConnectivity);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
// dynConfigService.removeListener(dynamicConfigServiceListener);
}
#end_block

#method_before
@Override
public void addDevice(Device device) {
    log.info("Add device: {}", device);
    TapiNodeBuilder builder = new TapiNodeBuilder();
    addModelObjectDataToDcs(builder.setTopologyUuid(topology.uuid()).build());
    dcsResolver.addNodeUuid(device.id(), builder.getUuid());
}
#method_after
@Override
public void addDevice(Device device) {
    log.info("Add device: {}", device);
    DeviceId deviceId = device.id();
    if (tapiResolver.hasNodeRef(deviceId)) {
        return;
    }
    TapiNodeBuilder builder = TapiNodeBuilder.builder().setTopologyUuid(topology.uuid()).setDeviceId(deviceId);
    addModelObjectDataToDcs(builder.build());
    TapiNodeRef nodeRef = new TapiNodeRef(topology.uuid().toString(), builder.getUuid().toString());
    nodeRef.setDeviceId(deviceId);
    tapiResolver.addNodeRef(nodeRef);
}
#end_block

#method_before
@Override
public void addLink(Link link) {
    log.info("Add link: {}", link);
}
#method_after
@Override
public void addLink(Link link) {
    log.info("Add link: {}", link);
    // validation check
    // src nep
    addNep(link.src());
    addNep(link.dst());
    // link
    TapiNepRef srcNepRef = tapiResolver.getNepRef(link.src());
    TapiNepRef dstNepRef = tapiResolver.getNepRef(link.dst());
    TapiLinkBuilder linkBuilder = TapiLinkBuilder.builder().setTopologyUuid(topology.uuid()).setNep(srcNepRef).setNep(dstNepRef);
    addModelObjectDataToDcs(linkBuilder.build());
}
#end_block

#method_before
@Override
public void addPort(Port port) {
    log.info("Add port: {}", port);
    Uuid nodeUuid = dcsResolver.getNodeUuid(port.element().id());
    TapiNepBuilder nepBuilder = new TapiNepBuilder();
    TapiSipBuilder sipBuilder = new TapiSipBuilder();
    nepBuilder.setPort(port).setTopologyUuid(topology.uuid()).setNodeUuid(nodeUuid);
    sipBuilder.setPort(port);
    if (sipBuilder.isSip()) {
        nepBuilder.setSip(sipBuilder.getUuid());
        addModelObjectDataToDcs(sipBuilder.build());
    }
    addModelObjectDataToDcs(nepBuilder.build());
}
#method_after
@Override
public void addPort(Port port) {
    log.info("Add port: {}", port);
    if (tapiResolver.hasNepRef(new ConnectPoint(port.element().id(), port.number()))) {
        return;
    }
    TapiNodeRef nodeRef = tapiResolver.getNodeRef(port.element().id());
    String nodeId = nodeRef.getNodeId();
    // nep
    TapiNepBuilder nepBuilder = TapiNepBuilder.builder().setPort(port).setTopologyUuid(topology.uuid()).setNodeUuid(Uuid.fromString(nodeId));
    TapiNepRef nepRef = new TapiNepRef(topology.uuid().toString(), nodeId, nepBuilder.getUuid().toString());
    nepRef.setConnectPoint(nepBuilder.getConnectPoint());
    // sip
    if (TapiSipBuilder.isSip(port)) {
        TapiSipBuilder sipBuilder = TapiSipBuilder.builder().setPort(port);
        nepBuilder.setSip(sipBuilder.getUuid());
        nepRef.setSipId(sipBuilder.getUuid().toString());
        addModelObjectDataToDcs(sipBuilder.build());
    }
    addModelObjectDataToDcs(nepBuilder.build());
    tapiResolver.addNepRef(nepRef);
}
#end_block

#method_before
private void initDcsTapiContext() {
    TapiContextBuilder builder = new TapiContextBuilder(context);
    addModelObjectDataToDcs(builder.build());
}
#method_after
private void initDcsTapiContext() {
    TapiContextBuilder builder = TapiContextBuilder.builder(context);
    addModelObjectDataToDcs(builder.build());
}
#end_block

#method_before
private void initDcsTapiTopology() {
    TapiTopologyBuilder builder = new TapiTopologyBuilder(topology);
    addModelObjectDataToDcs(builder.build());
}
#method_after
private void initDcsTapiTopology() {
    TapiTopologyBuilder builder = TapiTopologyBuilder.builder(topology);
    addModelObjectDataToDcs(builder.build());
}
#end_block

#method_before
@Override
protected void execute() {
    if (nodeId != null) {
        NodeDiskUsage disk = nodeService.disk(NodeId.nodeId(nodeId));
        if (Objects.nonNull(disk)) {
            System.out.println(disk.toString());
        } else {
            System.out.println("Controller doesn't exists");
        }
    } else {
        Collection<NodeDiskUsage> disk = nodeService.disk().values();
        printDiskUsage(disk);
    }
}
#method_after
@Override
protected void execute() {
    if (nodeId != null) {
        NodeDiskUsage disk = nodeService.disk(NodeId.nodeId(nodeId));
        if (Objects.nonNull(disk)) {
            print("Disk usage : %s", disk);
        } else {
            print("Node %s doesn't exists", nodeId);
        }
    } else {
        Collection<NodeDiskUsage> disk = nodeService.disk().values();
        printDiskUsage(disk);
    }
}
#end_block

#method_before
void printDiskUsage(Collection<NodeDiskUsage> disk) {
    disk.forEach(System.out::println);
}
#method_after
private void printDiskUsage(Collection<NodeDiskUsage> diskList) {
    diskList.forEach(disk -> print("%s", disk));
}
#end_block

#method_before
@Override
protected void execute() {
    if (nodeId != null) {
        NodeCpu cpu = nodeService.cpu(NodeId.nodeId(nodeId));
        if (Objects.nonNull(cpu)) {
            System.out.println(cpu.toString());
        } else {
            System.out.println("Controller doesn't exists");
        }
    } else {
        Collection<NodeCpu> cpu = nodeService.cpu().values();
        printCpuUsage(cpu);
    }
}
#method_after
@Override
protected void execute() {
    if (nodeId != null) {
        NodeCpu cpu = nodeService.cpu(NodeId.nodeId(nodeId));
        if (Objects.nonNull(cpu)) {
            print("CPU usage : %s ", cpu);
        } else {
            print("Node %s doesn't exists", nodeId);
        }
    } else {
        Collection<NodeCpu> cpu = nodeService.cpu().values();
        printCpuUsage(cpu);
    }
}
#end_block

#method_before
void printCpuUsage(Collection<NodeCpu> cpu) {
    cpu.forEach(System.out::println);
}
#method_after
private void printCpuUsage(Collection<NodeCpu> cpuList) {
    cpuList.forEach(cpu -> print("%s", cpu));
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.nodemetrics");
    metricsExecutor = Executors.newSingleThreadScheduledExecutor(Tools.groupedThreads("nodemetrics/pollingStatics", "statistics-executor-%d", log));
    localNodeId = clusterService.getLocalNode().id();
    memoryStore = storageService.<NodeId, NodeMemory>consistentMapBuilder().withSerializer(Serializer.using(KryoNamespaces.API, NodeMemory.class, NodeId.class)).withName("nodemetrics-memory").withApplicationId(appId).build();
    mapMemory = memoryStore.asJavaMap();
    diskStore = storageService.<NodeId, NodeDiskUsage>consistentMapBuilder().withSerializer(Serializer.using(KryoNamespaces.API, NodeDiskUsage.class, NodeId.class)).withName("nodemetrics-disk").withApplicationId(appId).build();
    mapDisk = diskStore.asJavaMap();
    cpuStore = storageService.<NodeId, NodeCpu>consistentMapBuilder().withSerializer(Serializer.using(KryoNamespaces.API, NodeCpu.class, NodeId.class)).withName("nodemetrics-cpu").withApplicationId(appId).build();
    mapCpu = cpuStore.asJavaMap();
    scheduledTask = schedulePolling();
    sigar = new Sigar();
    pollMetrics();
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.nodemetrics");
    metricsExecutor = Executors.newSingleThreadScheduledExecutor(Tools.groupedThreads("nodemetrics/pollingStatics", "statistics-executor-%d", log));
    localNodeId = clusterService.getLocalNode().id();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NodeMemory.class).register(NodeDiskUsage.class).register(NodeCpu.class).register(Units.class);
    memoryStore = storageService.<NodeId, NodeMemory>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, memory) -> clockService.getTimestamp()).withName("nodemetrics-memory").build();
    diskStore = storageService.<NodeId, NodeDiskUsage>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, disk) -> clockService.getTimestamp()).withName("nodemetrics-disk").build();
    cpuStore = storageService.<NodeId, NodeCpu>eventuallyConsistentMapBuilder().withSerializer(serializer).withTimestampProvider((nodeId, cpu) -> clockService.getTimestamp()).withName("nodemetrics-cpu").build();
    scheduledTask = schedulePolling();
    sigar = new Sigar();
    pollMetrics();
}
#end_block

#method_before
@Override
public Map<NodeId, NodeMemory> memory() {
    return ImmutableMap.copyOf(mapMemory);
}
#method_after
@Override
public Map<NodeId, NodeMemory> memory() {
    return this.ecToMap(memoryStore);
}
#end_block

#method_before
@Override
public Map<NodeId, NodeDiskUsage> disk() {
    return ImmutableMap.copyOf(mapDisk);
}
#method_after
@Override
public Map<NodeId, NodeDiskUsage> disk() {
    return this.ecToMap(diskStore);
}
#end_block

#method_before
@Override
public Map<NodeId, NodeCpu> cpu() {
    return ImmutableMap.copyOf(mapCpu);
}
#method_after
@Override
public Map<NodeId, NodeCpu> cpu() {
    return this.ecToMap(cpuStore);
}
#end_block

#method_before
@Override
public NodeMemory memory(NodeId nodeid) {
    return mapMemory.get(nodeid);
}
#method_after
@Override
public NodeMemory memory(NodeId nodeid) {
    return memoryStore.get(nodeid);
}
#end_block

#method_before
@Override
public NodeDiskUsage disk(NodeId nodeid) {
    return mapDisk.get(nodeid);
}
#method_after
@Override
public NodeDiskUsage disk(NodeId nodeid) {
    return diskStore.get(nodeid);
}
#end_block

#method_before
@Override
public NodeCpu cpu(NodeId nodeid) {
    return mapCpu.get(nodeid);
}
#method_after
@Override
public NodeCpu cpu(NodeId nodeid) {
    return cpuStore.get(nodeid);
}
#end_block

#method_before
private void pollMetrics() {
    try {
        CpuPerc cpu = sigar.getCpuPerc();
        Mem mem = sigar.getMem();
        FileSystemUsage disk = sigar.getFileSystemUsage(SLASH);
        memoryNode = new NodeMemory.Builder().free(mem.getFree()).used(mem.getUsed()).total(mem.getTotal()).withUnit("bytes").withNode(localNodeId).build();
        cpuNode = new NodeCpu.Builder().withNode(localNodeId).load(cpu.getCombined() * 100.0).build();
        diskNode = new NodeDiskUsage.Builder().withNode(localNodeId).free(disk.getFree()).used(disk.getUsed()).withUnit("Kbytes").total(disk.getTotal()).build();
        diskStore.put(localNodeId, diskNode);
        memoryStore.put(localNodeId, memoryNode);
        cpuStore.put(localNodeId, cpuNode);
    } catch (SigarException e) {
        log.error("Exception occured {} ", e);
    }
}
#method_after
private void pollMetrics() {
    try {
        CpuPerc cpu = sigar.getCpuPerc();
        Mem mem = sigar.getMem();
        FileSystemUsage disk = sigar.getFileSystemUsage(SLASH);
        NodeMemory memoryNode = new NodeMemory.Builder().free(mem.getFree()).used(mem.getUsed()).total(mem.getTotal()).withUnit(Units.BYTES).withNode(localNodeId).build();
        NodeCpu cpuNode = new NodeCpu.Builder().withNode(localNodeId).usage(cpu.getCombined() * PERCENTAGE_MULTIPLIER).build();
        NodeDiskUsage diskNode = new NodeDiskUsage.Builder().withNode(localNodeId).free(disk.getFree()).used(disk.getUsed()).withUnit(Units.KBYTES).total(disk.getTotal()).build();
        diskStore.put(localNodeId, diskNode);
        memoryStore.put(localNodeId, memoryNode);
        cpuStore.put(localNodeId, cpuNode);
    } catch (SigarException e) {
        log.error("Exception occurred ", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return ReflectionToStringBuilder.toString(this);
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("node", this.node).add("usage", String.format("%.2f%s", this.usage, "%")).toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(node, load);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(node, usage);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final NodeCpu other = (NodeCpu) obj;
    return Objects.equals(this.node, other.node) || Objects.equals(this.load, other.load);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final NodeCpu other = (NodeCpu) obj;
    return Objects.equals(this.node, other.node) && Objects.equals(this.usage, other.usage);
}
#end_block

#method_before
public NodeCpu build() {
    checkNotNull(node, "Must specify an node id");
    checkNotNull(load, "Must specify a idel");
    return new NodeCpu(node, String.format("%.2f %s", load, PERCENTAGE));
}
#method_after
public NodeCpu build() {
    checkNotNull(node, "Must specify an node id");
    checkNotNull(usage, "Must specify a usage");
    return new NodeCpu(node, usage);
}
#end_block

#method_before
public String units() {
    return units;
}
#method_after
public Units units() {
    return units;
}
#end_block

#method_before
public String usage() {
    return usage;
}
#method_after
public double usage() {
    return usage;
}
#end_block

#method_before
@Override
public String toString() {
    return ReflectionToStringBuilder.toString(this);
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("node", this.node).add("free", this.free).add("used", this.used).add("total", this.total).add("units", this.units).add("usage", this.usage + "%").toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    NodeDiskUsage other = (NodeDiskUsage) obj;
    return Objects.equals(this.node, other.node) || Objects.equals(this.free, other.free) || Objects.equals(this.used, other.used) || Objects.equals(this.total, other.total) || Objects.equals(this.units, other.units) || Objects.equals(this.usage, other.usage);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    NodeDiskUsage other = (NodeDiskUsage) obj;
    return Objects.equals(this.node, other.node) && Objects.equals(this.free, other.free) && Objects.equals(this.used, other.used) && Objects.equals(this.total, other.total) && Objects.equals(this.units, other.units) && Objects.equals(this.usage, other.usage);
}
#end_block

#method_before
public Builder withUnit(final String unit) {
    this.unit = unit;
    return this;
}
#method_after
public Builder withUnit(final Units unit) {
    this.unit = unit;
    return this;
}
#end_block

#method_before
public Builder free(final long free) {
    this.free = free;
    return this;
}
#method_after
public Builder free(final Long free) {
    this.free = free;
    return this;
}
#end_block

#method_before
public Builder used(final long used) {
    this.used = used;
    return this;
}
#method_after
public Builder used(final Long used) {
    this.used = used;
    return this;
}
#end_block

#method_before
public Builder total(final long total) {
    this.total = total;
    return this;
}
#method_after
public Builder total(final Long total) {
    this.total = total;
    return this;
}
#end_block

#method_before
public NodeDiskUsage build() {
    checkNotNull(node, "Must specify an node id");
    checkNotNull(unit, "Must specify a unit");
    checkNotNull(used, "Must specify a used Diskspace");
    checkNotNull(free, "Must specify a free Diskspace");
    checkNotNull(total, "Must specify a total Diskspace");
    double calc = used * 100 / total;
    return new NodeDiskUsage(node, free, used, total, unit, String.format("%.2f %s", calc, PERCENTAGE));
}
#method_after
public NodeDiskUsage build() {
    checkNotNull(node, "Must specify an node id");
    checkNotNull(unit, "Must specify a unit");
    checkNotNull(used, "Must specify a used Diskspace");
    checkNotNull(free, "Must specify a free Diskspace");
    checkNotNull(total, "Must specify a total Diskspace");
    double usage = used * PERCENTAGE_MULTIPLIER / total;
    return new NodeDiskUsage(node, free, used, total, unit, usage);
}
#end_block

#method_before
public String units() {
    return units;
}
#method_after
public Units units() {
    return units;
}
#end_block

#method_before
public String usage() {
    return usage;
}
#method_after
public double usage() {
    return usage;
}
#end_block

#method_before
@Override
public String toString() {
    return ReflectionToStringBuilder.toString(this);
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("node", this.node).add("free", this.free).add("used", this.used).add("total", this.total).add("units", this.units.toString()).add("usage", this.usage + "%").toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    NodeMemory other = (NodeMemory) obj;
    return Objects.equals(this.node, other.node) || Objects.equals(this.free, other.free) || Objects.equals(this.used, other.used) || Objects.equals(this.total, other.total) || Objects.equals(this.units, other.units) || Objects.equals(this.usage, other.usage);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    NodeMemory other = (NodeMemory) obj;
    return Objects.equals(this.node, other.node) && Objects.equals(this.free, other.free) && Objects.equals(this.used, other.used) && Objects.equals(this.total, other.total) && Objects.equals(this.units, other.units) && Objects.equals(this.usage, other.usage);
}
#end_block

#method_before
public Builder withUnit(final String unit) {
    this.unit = unit;
    return this;
}
#method_after
public Builder withUnit(final Units unit) {
    this.unit = unit;
    return this;
}
#end_block

#method_before
public Builder free(final long free) {
    this.free = free;
    return this;
}
#method_after
public Builder free(final Long free) {
    this.free = free;
    return this;
}
#end_block

#method_before
public Builder used(final long used) {
    this.used = used;
    return this;
}
#method_after
public Builder used(final Long used) {
    this.used = used;
    return this;
}
#end_block

#method_before
public Builder total(final long total) {
    this.total = total;
    return this;
}
#method_after
public Builder total(final Long total) {
    this.total = total;
    return this;
}
#end_block

#method_before
public NodeMemory build() {
    checkNotNull(node, "Must specify an node id");
    checkNotNull(unit, "Must specify a unit");
    checkNotNull(used, "Must specify a used Diskspace");
    checkNotNull(free, "Must specify a free Diskspace");
    checkNotNull(total, "Must specify a total Diskspace");
    double calc = used * 100 / total;
    return new NodeMemory(node, unit, free, used, total, String.format("%.2f %s", calc, PERCENTAGE));
}
#method_after
public NodeMemory build() {
    checkNotNull(node, "Must specify an node id");
    checkNotNull(unit, "Must specify a unit");
    checkNotNull(used, "Must specify a used Diskspace");
    checkNotNull(free, "Must specify a free Diskspace");
    checkNotNull(total, "Must specify a total Diskspace");
    double usage = used * PERCENTAGE_MULTIPLIER / total;
    return new NodeMemory(node, unit, free, used, total, usage);
}
#end_block

#method_before
@Override
protected void execute() {
    if (nodeId != null) {
        NodeMemory memory = nodeService.memory(NodeId.nodeId(nodeId));
        if (Objects.nonNull(memory)) {
            System.out.println(memory.toString());
        } else {
            System.out.println("Controller doesn't exists");
        }
    } else {
        Collection<NodeMemory> memory = nodeService.memory().values();
        printMemory(memory);
    }
}
#method_after
@Override
protected void execute() {
    if (nodeId != null) {
        NodeMemory memory = nodeService.memory(NodeId.nodeId(nodeId));
        if (Objects.nonNull(memory)) {
            print("Memory usage : %s", memory.toString());
        } else {
            print("Node %s doesn't exists");
        }
    } else {
        Collection<NodeMemory> memory = nodeService.memory().values();
        printMemory(memory);
    }
}
#end_block

#method_before
void printMemory(Collection<NodeMemory> memory) {
    memory.forEach(System.out::println);
}
#method_after
private void printMemory(Collection<NodeMemory> memoryList) {
    memoryList.forEach(memory -> print("%s", memory));
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        enableMessageLog = Tools.isPropertyEnabled(properties, "logLevel", DEFAULT_LOG_LEVEL);
        log.info("Configured. Log of gRPC messages is enabled", enableMessageLog);
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        enableMessageLog = Tools.isPropertyEnabled(properties, "enableMessageLog", DEFAULT_LOG_LEVEL);
        log.info("Configured. Log of gRPC messages is {}", enableMessageLog ? "enabled" : "disabled");
    }
}
#end_block

#method_before
@Override
public ManagedChannel connectChannel(GrpcChannelId channelId, ManagedChannelBuilder<?> channelBuilder) throws IOException {
    checkNotNull(channelId);
    checkNotNull(channelBuilder);
    Lock lock = channelLocks.computeIfAbsent(channelId, k -> new ReentrantLock());
    lock.lock();
    try {
        if (enableMessageLog) {
            channelBuilder.intercept(new InternalLogChannelInterceptor(channelId));
        }
        ManagedChannel channel = channelBuilder.build();
        // Forced connection not yet implemented. Use workaround...
        // channel.getState(true);
        doDummyMessage(channel);
        channels.put(channelId, channel);
        return channel;
    } finally {
        lock.unlock();
    }
}
#method_after
@Override
public ManagedChannel connectChannel(GrpcChannelId channelId, ManagedChannelBuilder<?> channelBuilder) throws IOException {
    checkNotNull(channelId);
    checkNotNull(channelBuilder);
    Lock lock = channelLocks.computeIfAbsent(channelId, k -> new ReentrantLock());
    lock.lock();
    try {
        channelBuilder.intercept(new InternalLogChannelInterceptor(channelId));
        ManagedChannel channel = channelBuilder.build();
        // Forced connection not yet implemented. Use workaround...
        // channel.getState(true);
        doDummyMessage(channel);
        channels.put(channelId, channel);
        return channel;
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
@Override
public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> methodDescriptor, CallOptions callOptions, Channel channel) {
    return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(channel.newCall(methodDescriptor, callOptions.withoutWaitForReady())) {

        @Override
        public void sendMessage(ReqT message) {
            log.info("*** SENDING GRPC MESSAGE [{}]\n{}:\n{}", channelId, methodDescriptor.getFullMethodName(), message.toString());
            super.sendMessage(message);
        }

        @Override
        public void start(Listener<RespT> responseListener, Metadata headers) {
            ClientCall.Listener<RespT> listener = new ForwardingClientCallListener<RespT>() {

                @Override
                protected Listener<RespT> delegate() {
                    return responseListener;
                }

                @Override
                public void onMessage(RespT message) {
                    log.info("*** RECEIVED GRPC MESSAGE [{}]\n{}:\n{}", channelId, methodDescriptor.getFullMethodName(), message.toString());
                    super.onMessage(message);
                }
            };
            super.start(listener, headers);
        }
    };
}
#method_after
@Override
public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> methodDescriptor, CallOptions callOptions, Channel channel) {
    return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(channel.newCall(methodDescriptor, callOptions.withoutWaitForReady())) {

        @Override
        public void sendMessage(ReqT message) {
            if (enableMessageLog && !methodDescriptor.getFullMethodName().startsWith(SET_FORWARDING_PIPELINE_CONFIG_METHOD)) {
                log.info("*** SENDING GRPC MESSAGE [{}]\n{}:\n{}", channelId, methodDescriptor.getFullMethodName(), message.toString());
            }
            super.sendMessage(message);
        }

        @Override
        public void start(Listener<RespT> responseListener, Metadata headers) {
            ClientCall.Listener<RespT> listener = new ForwardingClientCallListener<RespT>() {

                @Override
                protected Listener<RespT> delegate() {
                    return responseListener;
                }

                @Override
                public void onMessage(RespT message) {
                    if (enableMessageLog) {
                        log.info("*** RECEIVED GRPC MESSAGE [{}]\n{}:\n{}", channelId, methodDescriptor.getFullMethodName(), message.toString());
                    }
                    super.onMessage(message);
                }
            };
            super.start(listener, headers);
        }
    };
}
#end_block

#method_before
public void init() {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Installing rules to drop any multicast traffic for which a tree is not programmed.
        srManager.deviceService.getAvailableDevices().forEach(device -> {
            log.debug("Programming mcast drop flows");
            addDropForUnprogrammedTrees(device.id());
        });
        srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
            log.debug("Init group {}", mcastRoute.group());
            if (!mcastUtils.isLeader(mcastRoute.group())) {
                log.debug("Skip {} due to lack of leadership", mcastRoute.group());
                return;
            }
            McastRouteData mcastRouteData = srManager.multicastRouteService.routeData(mcastRoute);
            // For each source process the mcast tree
            srManager.multicastRouteService.sources(mcastRoute).forEach(source -> {
                Map<ConnectPoint, List<ConnectPoint>> mcastPaths = Maps.newHashMap();
                Set<DeviceId> visited = Sets.newHashSet();
                List<ConnectPoint> currentPath = Lists.newArrayList(source);
                buildMcastPaths(source.deviceId(), visited, mcastPaths, currentPath, mcastRoute.group(), source);
                // Get all the sinks and process them
                Set<ConnectPoint> sinks = processSinksToBeAdded(source, mcastRoute.group(), mcastRouteData.sinks());
                // Filter out all the working sinks, we do not want to move them
                // TODO we need a better way to distinguish flows coming from different sources
                sinks = sinks.stream().filter(sink -> !mcastPaths.containsKey(sink) || !isSinkForSource(mcastRoute.group(), sink, source)).collect(Collectors.toSet());
                if (sinks.isEmpty()) {
                    log.debug("Skip {} for source {} nothing to do", mcastRoute.group(), source);
                    return;
                }
                Map<ConnectPoint, List<Path>> mcasTree = computeSinkMcastTree(source.deviceId(), sinks);
                mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastRoute.group(), paths));
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
public void init() {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Installing rules to drop any multicast traffic for which a tree is not programmed.
        srManager.deviceService.getAvailableDevices().forEach(device -> {
            log.debug("Programming mcast drop flows");
            dropUnprogrammedTrees(device.id());
        });
        srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
            log.debug("Init group {}", mcastRoute.group());
            if (!mcastUtils.isLeader(mcastRoute.group())) {
                log.debug("Skip {} due to lack of leadership", mcastRoute.group());
                return;
            }
            McastRouteData mcastRouteData = srManager.multicastRouteService.routeData(mcastRoute);
            // For each source process the mcast tree
            srManager.multicastRouteService.sources(mcastRoute).forEach(source -> {
                Map<ConnectPoint, List<ConnectPoint>> mcastPaths = Maps.newHashMap();
                Set<DeviceId> visited = Sets.newHashSet();
                List<ConnectPoint> currentPath = Lists.newArrayList(source);
                buildMcastPaths(source.deviceId(), visited, mcastPaths, currentPath, mcastRoute.group(), source);
                // Get all the sinks and process them
                Set<ConnectPoint> sinks = processSinksToBeAdded(source, mcastRoute.group(), mcastRouteData.sinks());
                // Filter out all the working sinks, we do not want to move them
                // TODO we need a better way to distinguish flows coming from different sources
                sinks = sinks.stream().filter(sink -> !mcastPaths.containsKey(sink) || !isSinkForSource(mcastRoute.group(), sink, source)).collect(Collectors.toSet());
                if (sinks.isEmpty()) {
                    log.debug("Skip {} for source {} nothing to do", mcastRoute.group(), source);
                    return;
                }
                Map<ConnectPoint, List<Path>> mcasTree = computeSinkMcastTree(source.deviceId(), sinks);
                mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastRoute.group(), paths));
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processDeviceAddedInternal(DeviceId deviceId) {
    // Irrespective of whether the local is a MASTER or not for this device,
    // we need to create a SR-group-handler instance. This is because in a
    // multi-instance setup, any instance can initiate forwarding/next-objectives
    // for any switch (even if this instance is a SLAVE or not even connected
    // to the switch). To handle this, a default-group-handler instance is necessary
    // per switch.
    log.debug("Current groupHandlerMap devs: {}", groupHandlerMap.keySet());
    if (groupHandlerMap.get(deviceId) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(deviceId, appId, deviceConfiguration, linkService, flowObjectiveService, this);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        log.debug("updating groupHandlerMap with new grpHdlr for device: {}", deviceId);
        groupHandlerMap.put(deviceId, groupHandler);
    }
    if (mastershipService.isLocalMaster(deviceId)) {
        defaultRoutingHandler.populatePortAddressingRules(deviceId);
        xConnectHandler.init(deviceId);
        DefaultGroupHandler groupHandler = groupHandlerMap.get(deviceId);
        groupHandler.createGroupsFromVlanConfig();
        routingRulePopulator.populateSubnetBroadcastRule(deviceId);
        mcastHandler.addDropForUnprogrammedTrees(deviceId);
    }
    appCfgHandler.init(deviceId);
    hostEventExecutor.execute(() -> hostHandler.init(deviceId));
    routeEventExecutor.execute(() -> routeHandler.init(deviceId));
}
#method_after
private void processDeviceAddedInternal(DeviceId deviceId) {
    // Irrespective of whether the local is a MASTER or not for this device,
    // we need to create a SR-group-handler instance. This is because in a
    // multi-instance setup, any instance can initiate forwarding/next-objectives
    // for any switch (even if this instance is a SLAVE or not even connected
    // to the switch). To handle this, a default-group-handler instance is necessary
    // per switch.
    log.debug("Current groupHandlerMap devs: {}", groupHandlerMap.keySet());
    if (groupHandlerMap.get(deviceId) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(deviceId, appId, deviceConfiguration, linkService, flowObjectiveService, this);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        log.debug("updating groupHandlerMap with new grpHdlr for device: {}", deviceId);
        groupHandlerMap.put(deviceId, groupHandler);
    }
    if (mastershipService.isLocalMaster(deviceId)) {
        defaultRoutingHandler.populatePortAddressingRules(deviceId);
        xConnectHandler.init(deviceId);
        DefaultGroupHandler groupHandler = groupHandlerMap.get(deviceId);
        groupHandler.createGroupsFromVlanConfig();
        routingRulePopulator.populateSubnetBroadcastRule(deviceId);
        mcastHandler.dropUnprogrammedTrees(deviceId);
    }
    appCfgHandler.init(deviceId);
    hostEventExecutor.execute(() -> hostHandler.init(deviceId));
    routeEventExecutor.execute(() -> routeHandler.init(deviceId));
}
#end_block

