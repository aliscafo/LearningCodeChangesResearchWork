435
#method_before
@Test
public void testTypeOf() {
    DiscreteResource discrete = Resources.discrete(D1, P1, VLAN1).resource();
    assertThat(discrete.isTypeOf(DeviceId.class), is(false));
    assertThat(discrete.isTypeOf(PortNumber.class), is(false));
    assertThat(discrete.isTypeOf(VlanId.class), is(true));
    ContinuousResource continuous = Resources.continuous(D1, P1, Bandwidth.class).resource(BW1.bps());
    assertThat(continuous.isTypeOf(DeviceId.class), is(false));
    assertThat(continuous.isTypeOf(PortNumber.class), is(false));
    assertThat(continuous.isTypeOf(Bandwidth.class), is(true));
}
#method_after
@Test
public void testTypeOf() {
    DiscreteResource discrete = Resources.discrete(D1, P1, VLAN1).resource();
    assertThat(discrete.isTypeOf(DeviceId.class), is(false));
    assertThat(discrete.isTypeOf(PortNumber.class), is(false));
    assertThat(discrete.isTypeOf(VlanId.class), is(true));
}
#end_block

#method_before
private void printResource(Resource resource, int level) {
    // TODO add an option to show only available resource
    // workaround to preserve the original behavior of ResourceService#getRegisteredResources
    Set<Resource> children;
    if (resource instanceof DiscreteResource) {
        children = resourceService.getRegisteredResources(((DiscreteResource) resource).id());
    } else {
        children = Collections.emptySet();
    }
    if (resource.equals(Resource.ROOT)) {
        print("ROOT");
    } else {
        String resourceName = resource.simpleTypeName();
        if (children.isEmpty() && !typesToPrint.isEmpty() && !typesToPrint.contains(resourceName)) {
            // This resource is target of filtering
            return;
        }
        if (resource instanceof ContinuousResource) {
            String simpleName = resource.simpleTypeName();
            print("%s%s: %f", Strings.repeat(" ", level), simpleName, // ((Class<?>) resource.last()).getSimpleName(),
            ((ContinuousResource) resource).value());
            // Continuous resource is terminal node, stop here
            return;
        } else {
            String toString = String.valueOf(resource.valueAs(Object.class));
            if (toString.startsWith(resourceName)) {
                print("%s%s", Strings.repeat(" ", level), toString);
            } else {
                print("%s%s: %s", Strings.repeat(" ", level), resourceName, toString);
            }
        }
    }
    // Classify children into aggregatable terminal resources and everything else
    Set<Class<?>> aggregatableTypes = ImmutableSet.<Class<?>>builder().add(VlanId.class).add(MplsLabel.class).build();
    // (last() resource name) -> { Resource }
    Multimap<String, Resource> aggregatables = ArrayListMultimap.create();
    List<Resource> nonAggregatable = new ArrayList<>();
    for (Resource r : children) {
        if (r instanceof ContinuousResource) {
            // non-aggregatable terminal node
            nonAggregatable.add(r);
        } else if (Iterables.any(aggregatableTypes, r::isTypeOf)) {
            // aggregatable & terminal node
            String className = r.simpleTypeName();
            if (typesToPrint.isEmpty() || typesToPrint.contains(className)) {
                aggregatables.put(className, r);
            }
        } else {
            nonAggregatable.add(r);
        }
    }
    // print aggregated (terminal)
    aggregatables.asMap().entrySet().forEach(e -> {
        // for each type...
        String resourceName = e.getKey();
        RangeSet<Long> rangeSet = TreeRangeSet.create();
        // aggregate into RangeSet
        e.getValue().stream().map(res -> {
            if (res.isTypeOf(VlanId.class)) {
                return (long) res.valueAs(VlanId.class).get().toShort();
            } else if (res.isTypeOf(MplsLabel.class)) {
                return (long) res.valueAs(MplsLabel.class).get().toInt();
            } else if (res.isTypeOf(TributarySlot.class)) {
                return res.valueAs(TributarySlot.class).get().index();
            }
            // TODO support Lambda (OchSignal types)
            return 0L;
        }).map(Range::singleton).map(range -> range.canonical(DiscreteDomain.longs())).forEach(rangeSet::add);
        print("%s%s: %s", Strings.repeat(" ", level + 1), resourceName, rangeSet);
    });
    // print non-aggregatables (recurse)
    if (sort) {
        nonAggregatable.stream().sorted((o1, o2) -> String.valueOf(o1.id()).compareTo(String.valueOf(o2.id()))).forEach(r -> printResource(r, level + 1));
    } else {
        nonAggregatable.forEach(r -> printResource(r, level + 1));
    }
}
#method_after
private void printResource(Resource resource, int level) {
    // TODO add an option to show only available resource
    // workaround to preserve the original behavior of ResourceService#getRegisteredResources
    Set<Resource> children;
    if (resource instanceof DiscreteResource) {
        children = resourceService.getRegisteredResources(((DiscreteResource) resource).id());
    } else {
        children = Collections.emptySet();
    }
    if (resource.equals(Resource.ROOT)) {
        print("ROOT");
    } else {
        if (resource instanceof ContinuousResource) {
            String s = resource.simpleTypeName();
            String simpleName = s.substring(s.lastIndexOf('.') + 1);
            print("%s%s: %f", Strings.repeat(" ", level), simpleName, // ((Class<?>) resource.last()).getSimpleName(),
            ((ContinuousResource) resource).value());
            // Continuous resource is terminal node, stop here
            return;
        } else {
            String resourceName = resource.simpleTypeName();
            String toString = String.valueOf(resource.valueAs(Object.class).orElse(""));
            if (toString.startsWith(resourceName)) {
                print("%s%s", Strings.repeat(" ", level), toString);
            } else {
                print("%s%s: %s", Strings.repeat(" ", level), resourceName, toString);
            }
        }
    }
    // Classify children into aggregatable terminal resources and everything else
    Set<Class<?>> aggregatableTypes = ImmutableSet.<Class<?>>builder().add(VlanId.class).add(MplsLabel.class).build();
    // (last() resource name) -> { Resource }
    Multimap<String, Resource> aggregatables = ArrayListMultimap.create();
    List<Resource> nonAggregatable = new ArrayList<>();
    for (Resource r : children) {
        if (!isPrintTarget(r)) {
            continue;
        }
        if (r instanceof ContinuousResource) {
            // non-aggregatable terminal node
            nonAggregatable.add(r);
        } else if (Iterables.any(aggregatableTypes, r::isTypeOf)) {
            // aggregatable & terminal node
            String className = r.simpleTypeName();
            aggregatables.put(className, r);
        } else {
            nonAggregatable.add(r);
        }
    }
    // print aggregated (terminal)
    aggregatables.asMap().entrySet().forEach(e -> {
        // for each type...
        String resourceName = e.getKey();
        RangeSet<Long> rangeSet = TreeRangeSet.create();
        // aggregate into RangeSet
        e.getValue().stream().map(res -> {
            if (res.isTypeOf(VlanId.class)) {
                return (long) res.valueAs(VlanId.class).get().toShort();
            } else if (res.isTypeOf(MplsLabel.class)) {
                return (long) res.valueAs(MplsLabel.class).get().toInt();
            } else if (res.isTypeOf(TributarySlot.class)) {
                return res.valueAs(TributarySlot.class).get().index();
            }
            // TODO support Lambda (OchSignal types)
            return 0L;
        }).map(Range::singleton).map(range -> range.canonical(DiscreteDomain.longs())).forEach(rangeSet::add);
        print("%s%s: %s", Strings.repeat(" ", level + 1), resourceName, rangeSet);
    });
    // print non-aggregatables (recurse)
    if (sort) {
        nonAggregatable.stream().sorted((o1, o2) -> String.valueOf(o1.id()).compareTo(String.valueOf(o2.id()))).forEach(r -> printResource(r, level + 1));
    } else {
        nonAggregatable.forEach(r -> printResource(r, level + 1));
    }
}
#end_block

#method_before
@Override
public <T> Optional<T> valueAs(Class<T> type) {
    checkNotNull(type);
    if (type.isAssignableFrom(type)) {
        @SuppressWarnings("unchecked")
        T value = (T) Double.valueOf(this.value);
        return Optional.of(value);
    }
    return Optional.empty();
}
#method_after
@Override
public <T> Optional<T> valueAs(Class<T> type) {
    checkNotNull(type);
    if (type == Object.class || type == double.class || type == Double.class) {
        @SuppressWarnings("unchecked")
        T value = (T) Double.valueOf(this.value);
        return Optional.of(value);
    }
    return Optional.empty();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.igmp");
    packetService.addProcessor(processor, PacketProcessor.director(1));
    networkConfig.registerConfigFactory(configFactory);
    networkConfig.registerConfigFactory(ssmTranslateConfigFactory);
    networkConfig.addListener(configListener);
    networkConfig.getSubjects(DeviceId.class, AccessDeviceConfig.class).forEach(subject -> {
        AccessDeviceConfig config = networkConfig.getConfig(subject, AccessDeviceConfig.class);
        if (config != null) {
            AccessDeviceData data = config.getOlt();
            oltData.put(data.deviceId(), data);
        }
    });
    IgmpSsmTranslateConfig ssmTranslateConfig = networkConfig.getConfig(appId, IgmpSsmTranslateConfig.class);
    if (ssmTranslateConfig != null) {
        for (McastRoute route : ssmTranslateConfig.getSsmTranslations()) {
            ssmTranslateTable.put(route.group(), route.source());
        }
    }
    oltData.keySet().stream().flatMap(did -> deviceService.getPorts(did).stream()).filter(p -> !oltData.get(p.element().id()).uplink().equals(p.number())).filter(p -> p.isEnabled()).forEach(p -> processFilterObjective((DeviceId) p.element().id(), p, false));
    deviceService.addListener(deviceListener);
    queryPacket = buildQueryPacket();
    queryTask = queryService.scheduleWithFixedDelay(SafeRecurringTask.wrap(this::querySubscribers), 0, queryPeriod, TimeUnit.SECONDS);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.igmp");
    packetService.addProcessor(processor, PacketProcessor.director(1));
    networkConfig.registerConfigFactory(configFactory);
    networkConfig.registerConfigFactory(ssmTranslateConfigFactory);
    networkConfig.addListener(configListener);
    networkConfig.getSubjects(DeviceId.class, AccessDeviceConfig.class).forEach(subject -> {
        AccessDeviceConfig config = networkConfig.getConfig(subject, AccessDeviceConfig.class);
        if (config != null) {
            AccessDeviceData data = config.getOlt();
            oltData.put(data.deviceId(), data);
        }
    });
    IgmpSsmTranslateConfig ssmTranslateConfig = networkConfig.getConfig(appId, IgmpSsmTranslateConfig.class);
    if (ssmTranslateConfig != null) {
        Collection<McastRoute> translations = ssmTranslateConfig.getSsmTranslations();
        for (McastRoute route : translations) {
            ssmTranslateTable.put(route.group(), route.source());
        }
    }
    oltData.keySet().stream().flatMap(did -> deviceService.getPorts(did).stream()).filter(p -> !oltData.get(p.element().id()).uplink().equals(p.number())).filter(p -> p.isEnabled()).forEach(p -> processFilterObjective((DeviceId) p.element().id(), p, false));
    deviceService.addListener(deviceListener);
    queryPacket = buildQueryPacket();
    queryTask = queryService.scheduleWithFixedDelay(SafeRecurringTask.wrap(this::querySubscribers), 0, queryPeriod, TimeUnit.SECONDS);
    log.info("Started");
}
#end_block

#method_before
public List<McastRoute> getSsmTranslations() {
    List<McastRoute> translations = new ArrayList();
    array.forEach(node -> translations.add(new McastRoute(IpAddress.valueOf(node.path(SOURCE).asText()), IpAddress.valueOf(node.path(GROUP).asText()), McastRoute.Type.STATIC)));
    return translations;
}
#method_after
public List<McastRoute> getSsmTranslations() {
    List<McastRoute> translations = new ArrayList();
    for (JsonNode node : array) {
        translations.add(new McastRoute(IpAddress.valueOf(node.path(SOURCE).asText().trim()), IpAddress.valueOf(node.path(GROUP).asText().trim()), McastRoute.Type.STATIC));
    }
    return translations;
}
#end_block

#method_before
private Set<VlanId> findVlanId(ConnectPoint cp) {
    return resourceService.getAvailableResources(Resources.discrete(cp.deviceId(), cp.port()).id()).stream().filter(x -> x.last() instanceof VlanId).map(x -> (VlanId) x.last()).collect(Collectors.toSet());
}
#method_after
private Set<VlanId> findVlanId(ConnectPoint cp) {
    return resourceService.getAvailableResources(Resources.discrete(cp.deviceId(), cp.port()).id()).stream().flatMap(x -> Tools.stream(x.valueAs(VlanId.class))).collect(Collectors.toSet());
}
#end_block

#method_before
public void populateSubscriberGatewayRules(Host vSgHost, Set<IpAddress> vSgIps) {
    VlanId serviceVlan = getServiceVlan(vSgHost);
    PortNumber dpPort = getDpPort(vSgHost);
    if (serviceVlan == null || dpPort == null) {
        log.warn("Failed to populate rules for vSG VM {}", vSgHost.id());
        return;
    }
    // for traffics with s-tag, strip the tag and take through the vSG VM
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(serviceVlan).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setOutput(vSgHost.location().port()).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(vSgHost.location().deviceId()).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
    // for traffics with customer vlan, tag with the service vlan based on input port with
    // lower priority to avoid conflict with WAN tag
    selector = DefaultTrafficSelector.builder().matchVlanId(VlanId.ANY).matchInPort(vSgHost.location().port()).build();
    treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(serviceVlan).setOutput(dpPort).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOW_PRIORITY).forDevice(vSgHost.location().deviceId()).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
    // for traffic coming from WAN, tag 500 and take through the vSG VM
    // based on destination ip
    vSgIps.stream().forEach(ip -> {
        TrafficSelector downstream = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip.toIpPrefix()).build();
        TrafficTreatment downstreamTreatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VLAN_WAN).setEthDst(vSgHost.mac()).setOutput(vSgHost.location().port()).build();
        FlowRule downstreamFlowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(downstream).withTreatment(downstreamTreatment).withPriority(DEFAULT_PRIORITY).forDevice(vSgHost.location().deviceId()).forTable(TABLE_DST_IP).makePermanent().build();
        processFlowRule(true, downstreamFlowRule);
    });
    // remove downstream flow rules for the vSG not shown in vSgIps
    for (FlowRule rule : flowRuleService.getFlowRulesById(appId)) {
        if (!rule.deviceId().equals(vSgHost.location().deviceId())) {
            continue;
        }
        PortNumber output = getOutputFromTreatment(rule);
        if (output == null || !output.equals(vSgHost.location().port()) || !isVlanPushFromTreatment(rule)) {
            continue;
        }
        IpPrefix dstIp = getDstIpFromSelector(rule);
        if (dstIp != null && !vSgIps.contains(dstIp.address())) {
            processFlowRule(false, rule);
        }
    }
}
#method_after
public void populateSubscriberGatewayRules(Host vSgHost, Set<IpAddress> vSgIps) {
    VlanId serviceVlan = getServiceVlan(vSgHost);
    PortNumber dpPort = getDpPort(vSgHost);
    if (serviceVlan == null || dpPort == null) {
        log.warn("Failed to populate rules for vSG VM {}", vSgHost.id());
        return;
    }
    // for traffics with s-tag, strip the tag and take through the vSG VM
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(serviceVlan).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setOutput(vSgHost.location().port()).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(vSgHost.location().deviceId()).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
    // for traffics with customer vlan, tag with the service vlan based on input port with
    // lower priority to avoid conflict with WAN tag
    selector = DefaultTrafficSelector.builder().matchInPort(vSgHost.location().port()).build();
    treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(serviceVlan).setOutput(dpPort).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOW_PRIORITY).forDevice(vSgHost.location().deviceId()).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
    // for traffic coming from WAN, tag 500 and take through the vSG VM
    // based on destination ip
    vSgIps.stream().forEach(ip -> {
        TrafficSelector downstream = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip.toIpPrefix()).build();
        TrafficTreatment downstreamTreatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VLAN_WAN).setEthDst(vSgHost.mac()).setOutput(vSgHost.location().port()).build();
        FlowRule downstreamFlowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(downstream).withTreatment(downstreamTreatment).withPriority(DEFAULT_PRIORITY).forDevice(vSgHost.location().deviceId()).forTable(TABLE_DST_IP).makePermanent().build();
        processFlowRule(true, downstreamFlowRule);
    });
    // remove downstream flow rules for the vSG not shown in vSgIps
    for (FlowRule rule : flowRuleService.getFlowRulesById(appId)) {
        if (!rule.deviceId().equals(vSgHost.location().deviceId())) {
            continue;
        }
        PortNumber output = getOutputFromTreatment(rule);
        if (output == null || !output.equals(vSgHost.location().port()) || !isVlanPushFromTreatment(rule)) {
            continue;
        }
        IpPrefix dstIp = getDstIpFromSelector(rule);
        if (dstIp != null && !vSgIps.contains(dstIp.address())) {
            processFlowRule(false, rule);
        }
    }
}
#end_block

#method_before
private void processFirstTable(DeviceId deviceId, PortNumber dpPort, IpAddress dpIp) {
    // take vxlan packet out onto the physical port
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a vxlan encap'd packet through the Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(VXLAN_UDP_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a packet to the data plane ip through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dpIp.toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take an arp packet from physical through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_ARP).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all else to the next table
    selector = DefaultTrafficSelector.builder().build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_PORT).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all vlan tagged packet to the Q_IN_Q table
    selector = DefaultTrafficSelector.builder().matchVlanId(VlanId.ANY).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_Q_IN_Q).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(VSG_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processFirstTable(DeviceId deviceId, PortNumber dpPort, IpAddress dpIp) {
    // take vxlan packet out onto the physical port
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a vxlan encap'd packet through the Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(VXLAN_UDP_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a packet to the data plane ip through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dpIp.toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take an arp packet from physical through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_ARP).matchArpTpa(dpIp.getIp4Address()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all else to the next table
    selector = DefaultTrafficSelector.builder().build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_PORT).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all vlan tagged packet to the Q_IN_Q table
    selector = DefaultTrafficSelector.builder().matchVlanId(VlanId.ANY).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_Q_IN_Q).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(VSG_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private void processQInQTable(DeviceId deviceId, PortNumber dpPort) {
    // for traffic going out to WAN, strip vid 500 and take through data plane interface
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(VLAN_WAN).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processQInQTable(DeviceId deviceId, PortNumber dpPort) {
    // for traffic going out to WAN, strip vid 500 and take through data plane interface
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(VLAN_WAN).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchVlanId(VLAN_WAN).matchEthType(Ethernet.TYPE_ARP).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_Q_IN_Q).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private void serviceVmAdded(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is detected, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.populateManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        arpProxy.addServiceIp(service.serviceIp());
        // sends gratuitous ARP here for the case of adding existing VMs
        // when ONOS or cordvtn app is restarted
        arpProxy.sendGratuitousArp(service.serviceIp(), gatewayMac, Sets.newHashSet(host));
    }
    registerDhcpLease(host, service);
    ruleInstaller.populateBasicConnectionRules(host, getTunnelIp(host), vNet);
    if (host.annotations().value(S_TAG) != null) {
        ruleInstaller.populateSubscriberGatewayRules(host, getSubscriberGatewayIps(host));
    }
}
#method_after
private void serviceVmAdded(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is detected, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.populateManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        arpProxy.addServiceIp(service.serviceIp());
        // sends gratuitous ARP here for the case of adding existing VMs
        // when ONOS or cordvtn app is restarted
        arpProxy.sendGratuitousArp(service.serviceIp(), gatewayMac, Sets.newHashSet(host));
    }
    registerDhcpLease(host, service);
    ruleInstaller.populateBasicConnectionRules(host, getTunnelIp(host), vNet);
    if (host.annotations().value(S_TAG) != null) {
        log.debug("vSG VM detected {}", host.id());
        ruleInstaller.populateSubscriberGatewayRules(host, getSubscriberGatewayIps(host));
    }
}
#end_block

#method_before
@Override
public OpenstackPort decode(ObjectNode json, CodecContext context) {
    HashMap<String, Ip4Address> fixedIpMap = new HashMap<>();
    JsonNode portInfo = json.get(PORT);
    if (portInfo == null) {
        portInfo = json;
    }
    String status = portInfo.path(STATUS).asText();
    String name = portInfo.path(NAME).asText();
    boolean adminStateUp = portInfo.path(ADMIN_STATUS).asBoolean();
    String networkId = portInfo.path(NETWORK_ID).asText();
    String tenantId = portInfo.path(TENANT_ID).asText();
    String deviceOwner = portInfo.path(DEVICE_OWNER).asText();
    String macStr = portInfo.path(MAC_ADDRESS).asText();
    ArrayNode fixedIpList = (ArrayNode) portInfo.path(FIXED_IPS);
    for (JsonNode fixedIpInfo : fixedIpList) {
        String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
        String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
        if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
            Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
            fixedIpMap.put(subnetId, ipAddress);
        }
    }
    String id = portInfo.path(ID).asText();
    ArrayNode securityGroupList = (ArrayNode) portInfo.path(SECURITY_GROUPS);
    Collection<String> securityGroupIdList = Lists.newArrayList();
    securityGroupList.forEach(securityGroup -> securityGroupIdList.add(securityGroup.asText()));
    String deviceId = portInfo.path(DEVICE_ID).asText();
    Map<IpAddress, MacAddress> addressPairs = Maps.newHashMap();
    for (JsonNode addrPair : (ArrayNode) portInfo.path(ADDRESS_PAIR)) {
        try {
            addressPairs.put(IpAddress.valueOf(addrPair.path(IP_ADDRESS).asText()), MacAddress.valueOf(addrPair.path(MAC_ADDRESS).asText()));
        } catch (IllegalArgumentException e) {
            log.debug("Invalid address pair {}", addrPair.toString());
        }
    }
    OpenstackPort.Builder openstackPortBuilder = OpenstackPort.builder();
    OpenstackPort.PortStatus portStatus = status.equals("N/A") ? OpenstackPort.PortStatus.NA : OpenstackPort.PortStatus.valueOf(status);
    openstackPortBuilder.portStatus(portStatus).name(name).adminState(adminStateUp).netwrokId(networkId).tenantId(tenantId).deviceOwner(deviceOwner).macAddress(MacAddress.valueOf(macStr)).fixedIps(fixedIpMap).id(id).deviceId(deviceId).securityGroup(securityGroupIdList);
    if (!addressPairs.isEmpty()) {
        openstackPortBuilder.allowedAddressPairs(addressPairs);
    }
    OpenstackPort openstackPort = openstackPortBuilder.build();
    return openstackPort;
}
#method_after
@Override
public OpenstackPort decode(ObjectNode json, CodecContext context) {
    HashMap<String, Ip4Address> fixedIpMap = new HashMap<>();
    JsonNode portInfo = json.get(PORT);
    if (portInfo == null) {
        portInfo = json;
    }
    String status = portInfo.path(STATUS).asText();
    String name = portInfo.path(NAME).asText();
    boolean adminStateUp = portInfo.path(ADMIN_STATUS).asBoolean();
    String networkId = portInfo.path(NETWORK_ID).asText();
    String tenantId = portInfo.path(TENANT_ID).asText();
    String deviceOwner = portInfo.path(DEVICE_OWNER).asText();
    String macStr = portInfo.path(MAC_ADDRESS).asText();
    ArrayNode fixedIpList = (ArrayNode) portInfo.path(FIXED_IPS);
    for (JsonNode fixedIpInfo : fixedIpList) {
        String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
        String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
        if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
            Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
            fixedIpMap.put(subnetId, ipAddress);
        }
    }
    String id = portInfo.path(ID).asText();
    ArrayNode securityGroupList = (ArrayNode) portInfo.path(SECURITY_GROUPS);
    Collection<String> securityGroupIdList = Lists.newArrayList();
    securityGroupList.forEach(securityGroup -> securityGroupIdList.add(securityGroup.asText()));
    String deviceId = portInfo.path(DEVICE_ID).asText();
    Map<IpAddress, MacAddress> addressPairs = Maps.newHashMap();
    for (JsonNode addrPair : (ArrayNode) portInfo.path(ADDRESS_PAIR)) {
        try {
            addressPairs.put(IpAddress.valueOf(addrPair.path(IP_ADDRESS).asText()), MacAddress.valueOf(addrPair.path(MAC_ADDRESS).asText()));
        } catch (IllegalArgumentException e) {
            log.debug("Invalid address pair {}", addrPair.toString());
        }
    }
    OpenstackPort.Builder openstackPortBuilder = OpenstackPort.builder();
    OpenstackPort.PortStatus portStatus = status.equals(NA) ? OpenstackPort.PortStatus.NA : OpenstackPort.PortStatus.valueOf(status);
    openstackPortBuilder.portStatus(portStatus).name(name).adminState(adminStateUp).netwrokId(networkId).tenantId(tenantId).deviceOwner(deviceOwner).macAddress(MacAddress.valueOf(macStr)).fixedIps(fixedIpMap).id(id).deviceId(deviceId).securityGroup(securityGroupIdList);
    if (!addressPairs.isEmpty()) {
        openstackPortBuilder.allowedAddressPairs(addressPairs);
    }
    OpenstackPort openstackPort = openstackPortBuilder.build();
    return openstackPort;
}
#end_block

#method_before
@Override
public String getConfiguration(String type) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    Preconditions.checkNotNull(controller, "Netconf controller is null");
    try {
        return controller.getDevicesMap().get(ofDeviceId).getSession().getConfig(type);
    } catch (IOException e) {
        log.error("Configuration could not be retrieved {}", e);
    }
    return UNABLE_TO_READ_CONFIG;
}
#method_after
@Override
public String getConfiguration(String type) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    Preconditions.checkNotNull(controller, "Netconf controller is null");
    try {
        return controller.getDevicesMap().get(ofDeviceId).getSession().getConfig(type);
    } catch (IOException e) {
        log.error("Configuration could not be retrieved {}", e.getMessage());
    }
    return UNABLE_TO_READ_CONFIG;
}
#end_block

#method_before
@Test
public void testTypeOf() {
    DiscreteResource discrete = Resources.discrete(D1, P1, VLAN1).resource();
    assertThat(discrete.isTypeOf(DeviceId.class), is(false));
    assertThat(discrete.isTypeOf(PortNumber.class), is(false));
    assertThat(discrete.isTypeOf(VlanId.class), is(true));
    ContinuousResource continuous = Resources.continuous(D1, P1, Bandwidth.class).resource(BW1.bps());
    assertThat(continuous.isTypeOf(DeviceId.class), is(false));
    assertThat(continuous.isTypeOf(PortNumber.class), is(false));
    assertThat(continuous.isTypeOf(Bandwidth.class), is(true));
}
#method_after
@Test
public void testTypeOf() {
    DiscreteResource discrete = Resources.discrete(D1, P1, VLAN1).resource();
    assertThat(discrete.isTypeOf(DeviceId.class), is(false));
    assertThat(discrete.isTypeOf(PortNumber.class), is(false));
    assertThat(discrete.isTypeOf(VlanId.class), is(true));
}
#end_block

#method_before
@POST
@Path("cpu_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response cpuMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    ControlMetric cm;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode cpuLoadJson = jsonTree.get("cpuLoad");
        JsonNode totalCpuTimeJson = jsonTree.get("totalCpuTime");
        JsonNode sysCpuTimeJson = jsonTree.get("sysCpuTime");
        JsonNode userCpuTimeJson = jsonTree.get("userCpuTime");
        JsonNode cpuIdleTimeJson = jsonTree.get("cpuIdleTime");
        if (cpuLoadJson != null) {
            cm = new ControlMetric(ControlMetricType.CPU_LOAD, new MetricValue.Builder().load(cpuLoadJson.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (totalCpuTimeJson != null) {
            cm = new ControlMetric(ControlMetricType.TOTAL_CPU_TIME, new MetricValue.Builder().load(totalCpuTimeJson.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (sysCpuTimeJson != null) {
            cm = new ControlMetric(ControlMetricType.SYS_CPU_TIME, new MetricValue.Builder().load(sysCpuTimeJson.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (userCpuTimeJson != null) {
            cm = new ControlMetric(ControlMetricType.USER_CPU_TIME, new MetricValue.Builder().load(userCpuTimeJson.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (cpuIdleTimeJson != null) {
            cm = new ControlMetric(ControlMetricType.CPU_IDLE_TIME, new MetricValue.Builder().load(cpuIdleTimeJson.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#method_after
@POST
@Path("cpu_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response cpuMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    ControlMetric cm;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        long cpuLoad = nullIsIllegal(jsonTree.get("cpuLoad").asLong(), INVALID_REQUEST);
        long totalCpuTime = nullIsIllegal(jsonTree.get("totalCpuTime").asLong(), INVALID_REQUEST);
        long sysCpuTime = nullIsIllegal(jsonTree.get("sysCpuTime").asLong(), INVALID_REQUEST);
        long userCpuTime = nullIsIllegal(jsonTree.get("userCpuTime").asLong(), INVALID_REQUEST);
        long cpuIdleTime = nullIsIllegal(jsonTree.get("cpuIdleTime").asLong(), INVALID_REQUEST);
        cm = new ControlMetric(ControlMetricType.CPU_LOAD, new MetricValue.Builder().load(cpuLoad).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.TOTAL_CPU_TIME, new MetricValue.Builder().load(totalCpuTime).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.SYS_CPU_TIME, new MetricValue.Builder().load(sysCpuTime).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.USER_CPU_TIME, new MetricValue.Builder().load(userCpuTime).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.CPU_IDLE_TIME, new MetricValue.Builder().load(cpuIdleTime).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#end_block

#method_before
@POST
@Path("memory_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response memoryMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    ControlMetric cm;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode memUsedPerc = jsonTree.get("memoryUsedPercentage");
        JsonNode memFreePerc = jsonTree.get("memoryFreePercentage");
        JsonNode memUsed = jsonTree.get("memoryUsed");
        JsonNode memFree = jsonTree.get("memoryFree");
        if (memUsedPerc != null) {
            cm = new ControlMetric(ControlMetricType.MEMORY_USED_PERCENTAGE, new MetricValue.Builder().load(memUsedPerc.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (memFreePerc != null) {
            cm = new ControlMetric(ControlMetricType.MEMORY_FREE_PERCENTAGE, new MetricValue.Builder().load(memFreePerc.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (memUsed != null) {
            cm = new ControlMetric(ControlMetricType.MEMORY_USED, new MetricValue.Builder().load(memUsed.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
        if (memFree != null) {
            cm = new ControlMetric(ControlMetricType.MEMORY_FREE, new MetricValue.Builder().load(memFree.asLong()).add());
            service.updateMetric(cm, UPDATE_INTERVAL, Optional.ofNullable(null));
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#method_after
@POST
@Path("memory_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response memoryMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    ControlMetric cm;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        long memUsedRatio = nullIsIllegal(jsonTree.get("memoryUsedRatio").asLong(), INVALID_REQUEST);
        long memFreeRatio = nullIsIllegal(jsonTree.get("memoryFreeRatio").asLong(), INVALID_REQUEST);
        long memUsed = nullIsIllegal(jsonTree.get("memoryUsed").asLong(), INVALID_REQUEST);
        long memFree = nullIsIllegal(jsonTree.get("memoryFree").asLong(), INVALID_REQUEST);
        cm = new ControlMetric(ControlMetricType.MEMORY_USED_RATIO, new MetricValue.Builder().load(memUsedRatio).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.MEMORY_FREE_RATIO, new MetricValue.Builder().load(memFreeRatio).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.MEMORY_USED, new MetricValue.Builder().load(memUsed).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
        cm = new ControlMetric(ControlMetricType.MEMORY_FREE, new MetricValue.Builder().load(memFree).add());
        service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, Optional.ofNullable(null));
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#end_block

#method_before
@POST
@Path("disk_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response diskMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    final ControlMetric[] cm = new ControlMetric[1];
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        ArrayNode diskRes = (ArrayNode) jsonTree.get("disks");
        diskRes.forEach(node -> {
            JsonNode resourceName = node.get("resourceName");
            nullIsIllegal(resourceName, INVALID_RESOURCE_NAME);
            JsonNode readBytes = jsonTree.get("readBytes");
            JsonNode writeBytes = jsonTree.get("writeBytes");
            if (readBytes != null) {
                cm[0] = new ControlMetric(ControlMetricType.DISK_READ_BYTES, new MetricValue.Builder().load(readBytes.asLong()).add());
                service.updateMetric(cm[0], UPDATE_INTERVAL, resourceName.asText());
            }
            if (writeBytes != null) {
                cm[0] = new ControlMetric(ControlMetricType.DISK_WRITE_BYTES, new MetricValue.Builder().load(writeBytes.asLong()).add());
                service.updateMetric(cm[0], UPDATE_INTERVAL, resourceName.asText());
            }
        });
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#method_after
@POST
@Path("disk_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response diskMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    ControlMetric cm;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        ArrayNode diskRes = (ArrayNode) jsonTree.get("disks");
        for (JsonNode node : diskRes) {
            JsonNode resourceName = node.get("resourceName");
            nullIsIllegal(resourceName, INVALID_RESOURCE_NAME);
            long readBytes = nullIsIllegal(node.get("readBytes").asLong(), INVALID_REQUEST);
            long writeBytes = nullIsIllegal(node.get("writeBytes").asLong(), INVALID_REQUEST);
            cm = new ControlMetric(ControlMetricType.DISK_READ_BYTES, new MetricValue.Builder().load(readBytes).add());
            service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, resourceName.asText());
            cm = new ControlMetric(ControlMetricType.DISK_WRITE_BYTES, new MetricValue.Builder().load(writeBytes).add());
            service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, resourceName.asText());
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#end_block

#method_before
@POST
@Path("network_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response networkMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    final ControlMetric[] cm = new ControlMetric[1];
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        ArrayNode networkRes = (ArrayNode) jsonTree.get("networks");
        networkRes.forEach(node -> {
            JsonNode resourceName = node.get("resourceName");
            nullIsIllegal(resourceName, INVALID_RESOURCE_NAME);
            JsonNode inBytes = jsonTree.get("incomingBytes");
            JsonNode outBytes = jsonTree.get("outgoingBytes");
            JsonNode inPackets = jsonTree.get("incomingPackets");
            JsonNode outPackets = jsonTree.get("outgoingPackets");
            if (inBytes != null) {
                cm[0] = new ControlMetric(ControlMetricType.NW_INCOMING_BYTES, new MetricValue.Builder().load(inBytes.asLong()).add());
                service.updateMetric(cm[0], UPDATE_INTERVAL, resourceName.asText());
            }
            if (outBytes != null) {
                cm[0] = new ControlMetric(ControlMetricType.NW_OUTGOING_BYTES, new MetricValue.Builder().load(outBytes.asLong()).add());
                service.updateMetric(cm[0], UPDATE_INTERVAL, resourceName.asText());
            }
            if (inPackets != null) {
                cm[0] = new ControlMetric(ControlMetricType.NW_INCOMING_PACKETS, new MetricValue.Builder().load(inPackets.asLong()).add());
                service.updateMetric(cm[0], UPDATE_INTERVAL, resourceName.asText());
            }
            if (outPackets != null) {
                cm[0] = new ControlMetric(ControlMetricType.NW_OUTGOING_PACKETS, new MetricValue.Builder().load(outPackets.asLong()).add());
                service.updateMetric(cm[0], UPDATE_INTERVAL, resourceName.asText());
            }
        });
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#method_after
@POST
@Path("network_metrics")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response networkMetrics(InputStream stream) {
    ObjectNode root = mapper().createObjectNode();
    ControlMetric cm;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        ArrayNode networkRes = (ArrayNode) jsonTree.get("networks");
        for (JsonNode node : networkRes) {
            JsonNode resourceName = node.get("resourceName");
            nullIsIllegal(resourceName, INVALID_RESOURCE_NAME);
            long inBytes = nullIsIllegal(node.get("incomingBytes").asLong(), INVALID_REQUEST);
            long outBytes = nullIsIllegal(node.get("outgoingBytes").asLong(), INVALID_REQUEST);
            long inPackets = nullIsIllegal(node.get("incomingPackets").asLong(), INVALID_REQUEST);
            long outPackets = nullIsIllegal(node.get("outgoingPackets").asLong(), INVALID_REQUEST);
            cm = new ControlMetric(ControlMetricType.NW_INCOMING_BYTES, new MetricValue.Builder().load(inBytes).add());
            service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, resourceName.asText());
            cm = new ControlMetric(ControlMetricType.NW_OUTGOING_BYTES, new MetricValue.Builder().load(outBytes).add());
            service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, resourceName.asText());
            cm = new ControlMetric(ControlMetricType.NW_INCOMING_PACKETS, new MetricValue.Builder().load(inPackets).add());
            service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, resourceName.asText());
            cm = new ControlMetric(ControlMetricType.NW_OUTGOING_PACKETS, new MetricValue.Builder().load(outPackets).add());
            service.updateMetric(cm, UPDATE_INTERVAL_IN_MINUTE, resourceName.asText());
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return ok(root).build();
}
#end_block

#method_before
public SystemInfo getSystemInfo() {
    return this.systemInfo;
}
#method_after
public SystemInfo getSystemInfo() {
    synchronized (systemInfo) {
        return this.systemInfo;
    }
}
#end_block

#method_before
public void setSystemInfo(SystemInfo systemInfo) {
    if (this.systemInfo == null) {
        this.systemInfo = systemInfo;
    }
}
#method_after
public void setSystemInfo(SystemInfo systemInfo) {
    synchronized (systemInfo) {
        if (this.systemInfo == null) {
            this.systemInfo = systemInfo;
        } else {
            log.warn("System information has already been set");
        }
    }
}
#end_block

#method_before
public static SystemInfoFactory getInstance() {
    if (uniqueInstance == null) {
        synchronized (SystemInfoFactory.class) {
            if (uniqueInstance == null) {
                uniqueInstance = new SystemInfoFactory();
            }
        }
    }
    return uniqueInstance;
}
#method_after
public static SystemInfoFactory getInstance() {
    return SingletonHelper.INSTANCE;
}
#end_block

#method_before
protected void registerMetrics() {
    /* CPU */
    cpuLoad = new MetricsAggregator(metricsService, ControlMetricType.CPU_LOAD);
    totalCpuTime = new MetricsAggregator(metricsService, ControlMetricType.TOTAL_CPU_TIME);
    sysCpuTime = new MetricsAggregator(metricsService, ControlMetricType.SYS_CPU_TIME);
    userCpuTime = new MetricsAggregator(metricsService, ControlMetricType.USER_CPU_TIME);
    cpuIdleTime = new MetricsAggregator(metricsService, ControlMetricType.CPU_IDLE_TIME);
    /* Memory */
    memoryFree = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_FREE);
    memoryUsed = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_USED);
    memoryFreePercentage = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_FREE_PERCENTAGE);
    memoryUsedPercentage = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_USED_PERCENTAGE);
    /* Disk I/O */
    diskReadBytes = new ConcurrentHashMap<>();
    diskWriteBytes = new ConcurrentHashMap<>();
    /* Network I/O */
    nwIncomingBytes = new ConcurrentHashMap<>();
    nwOutgoingBytes = new ConcurrentHashMap<>();
    nwIncomingPackets = new ConcurrentHashMap<>();
    nwOutgoingPackets = new ConcurrentHashMap<>();
    /* OpenFlow Messages */
    inboundPacket = new ConcurrentHashMap<>();
    outboundPacket = new ConcurrentHashMap<>();
    flowmodPacket = new ConcurrentHashMap<>();
    flowrmvPacket = new ConcurrentHashMap<>();
    requestPacket = new ConcurrentHashMap<>();
    replyPacket = new ConcurrentHashMap<>();
}
#method_after
protected void registerMetrics() {
    /* CPU */
    cpuLoad = new MetricsAggregator(metricsService, ControlMetricType.CPU_LOAD);
    totalCpuTime = new MetricsAggregator(metricsService, ControlMetricType.TOTAL_CPU_TIME);
    sysCpuTime = new MetricsAggregator(metricsService, ControlMetricType.SYS_CPU_TIME);
    userCpuTime = new MetricsAggregator(metricsService, ControlMetricType.USER_CPU_TIME);
    cpuIdleTime = new MetricsAggregator(metricsService, ControlMetricType.CPU_IDLE_TIME);
    /* Memory */
    memoryFree = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_FREE);
    memoryUsed = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_USED);
    memoryFreeRatio = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_FREE_RATIO);
    memoryUsedRatio = new MetricsAggregator(metricsService, ControlMetricType.MEMORY_USED_RATIO);
    /* Disk I/O */
    diskReadBytes = new ConcurrentHashMap<>();
    diskWriteBytes = new ConcurrentHashMap<>();
    /* Network I/O */
    nwIncomingBytes = new ConcurrentHashMap<>();
    nwOutgoingBytes = new ConcurrentHashMap<>();
    nwIncomingPackets = new ConcurrentHashMap<>();
    nwOutgoingPackets = new ConcurrentHashMap<>();
    /* OpenFlow Messages */
    inboundPacket = new ConcurrentHashMap<>();
    outboundPacket = new ConcurrentHashMap<>();
    flowmodPacket = new ConcurrentHashMap<>();
    flowrmvPacket = new ConcurrentHashMap<>();
    requestPacket = new ConcurrentHashMap<>();
    replyPacket = new ConcurrentHashMap<>();
}
#end_block

#method_before
public MetricsAggregator diskReadBytes(String partitionName) {
    return diskReadBytes.get(partitionName);
}
#method_after
public MetricsAggregator diskReadBytes(String resourceName) {
    return diskReadBytes.get(resourceName);
}
#end_block

#method_before
public MetricsAggregator diskWriteBytes(String partitionName) {
    return diskWriteBytes.get(partitionName);
}
#method_after
public MetricsAggregator diskWriteBytes(String resourceName) {
    return diskWriteBytes.get(resourceName);
}
#end_block

#method_before
public static ControlMetricsFactory getInstance(MetricsService metricsService, DeviceService deviceService) {
    if (uniqueInstance == null) {
        synchronized (ControlMetricsFactory.class) {
            if (uniqueInstance == null) {
                uniqueInstance = new ControlMetricsFactory(metricsService, deviceService);
            }
        }
    }
    return uniqueInstance;
}
#method_after
public static ControlMetricsFactory getInstance() {
    return SingletonHelper.INSTANCE;
}
#end_block

#method_before
@Test
public void testCpuMetricsPost() {
    mockControlPlaneMonitorService.updateMetric(anyObject(), anyObject(), (Optional<DeviceId>) anyObject());
    expectLastCall().times(5);
    replay(mockControlPlaneMonitorService);
    basePostTest("cpu-metrics-post.json", PREFIX + "/cpu_metrics");
}
#method_after
@Test
public void testCpuMetricsPost() {
    mockControlPlaneMonitorService.updateMetric(anyObject(), anyInt(), (Optional<DeviceId>) anyObject());
    expectLastCall().times(5);
    replay(mockControlPlaneMonitorService);
    basePostTest("cpu-metrics-post.json", PREFIX + "/cpu_metrics");
}
#end_block

#method_before
@Test
public void testMemoryMetricsPost() {
    mockControlPlaneMonitorService.updateMetric(anyObject(), anyObject(), (Optional<DeviceId>) anyObject());
    expectLastCall().times(4);
    replay(mockControlPlaneMonitorService);
    basePostTest("memory-metrics-post.json", PREFIX + "/memory_metrics");
}
#method_after
@Test
public void testMemoryMetricsPost() {
    mockControlPlaneMonitorService.updateMetric(anyObject(), anyInt(), (Optional<DeviceId>) anyObject());
    expectLastCall().times(4);
    replay(mockControlPlaneMonitorService);
    basePostTest("memory-metrics-post.json", PREFIX + "/memory_metrics");
}
#end_block

#method_before
@Override
public int cpuSpeed() {
    return this.cpuSpeed;
}
#method_after
@Override
public int cpuSpeed() {
    return this.cpuSpeedMhz;
}
#end_block

#method_before
@Override
public long totalMemory() {
    return this.totalMemory;
}
#method_after
@Override
public int totalMemory() {
    return this.totalMemoryMbytes;
}
#end_block

#method_before
@Override
public Builder cpuSpeed(int cpuSpeed) {
    this.cpuSpeed = cpuSpeed;
    return this;
}
#method_after
@Override
public Builder cpuSpeed(int cpuSpeedMhz) {
    this.cpuSpeedMHz = cpuSpeedMhz;
    return this;
}
#end_block

#method_before
@Override
public Builder totalMemory(long totalMemory) {
    this.totalMemory = totalMemory;
    return this;
}
#method_after
@Override
public Builder totalMemory(int totalMemoryBytes) {
    this.totalMemoryBytes = totalMemoryBytes;
    return this;
}
#end_block

#method_before
@Override
public DefaultSystemInfo build() {
    return new DefaultSystemInfo(numOfCores, numOfCpus, cpuSpeed, totalMemory);
}
#method_after
@Override
public DefaultSystemInfo build() {
    return new DefaultSystemInfo(numOfCores, numOfCpus, cpuSpeedMHz, totalMemoryBytes);
}
#end_block

#method_before
@Override
public <T> Optional<T> valueAs(Class<T> type) {
    checkNotNull(type);
    if (type.isAssignableFrom(type)) {
        @SuppressWarnings("unchecked")
        T value = (T) Double.valueOf(this.value);
        return Optional.of(value);
    }
    return Optional.empty();
}
#method_after
@Override
public <T> Optional<T> valueAs(Class<T> type) {
    checkNotNull(type);
    if (type == Object.class || type == double.class || type == Double.class) {
        @SuppressWarnings("unchecked")
        T value = (T) Double.valueOf(this.value);
        return Optional.of(value);
    }
    return Optional.empty();
}
#end_block

#method_before
private void printResource(Resource resource, int level) {
    // TODO add an option to show only available resource
    // workaround to preserve the original behavior of ResourceService#getRegisteredResources
    Set<Resource> children;
    if (resource instanceof DiscreteResource) {
        children = resourceService.getRegisteredResources(((DiscreteResource) resource).id());
    } else {
        children = Collections.emptySet();
    }
    if (resource.equals(Resource.ROOT)) {
        print("ROOT");
    } else {
        String resourceName = resource.last().getClass().getSimpleName();
        if (children.isEmpty() && !typesToPrint.isEmpty() && !typesToPrint.contains(resourceName)) {
            // This resource is target of filtering
            return;
        }
        if (resource instanceof ContinuousResource) {
            String s = ((String) resource.last());
            String simpleName = s.substring(s.lastIndexOf('.') + 1);
            print("%s%s: %f", Strings.repeat(" ", level), simpleName, // ((Class<?>) resource.last()).getSimpleName(),
            ((ContinuousResource) resource).value());
            // Continuous resource is terminal node, stop here
            return;
        } else {
            String toString = String.valueOf(resource.valueAs(Object.class).orElse(""));
            if (toString.startsWith(resourceName)) {
                print("%s%s", Strings.repeat(" ", level), toString);
            } else {
                print("%s%s: %s", Strings.repeat(" ", level), resourceName, toString);
            }
        }
    }
    // Classify children into aggregatable terminal resources and everything else
    Set<Class<?>> aggregatableTypes = ImmutableSet.<Class<?>>builder().add(VlanId.class).add(MplsLabel.class).build();
    // (last() resource name) -> { Resource }
    Multimap<String, Resource> aggregatables = ArrayListMultimap.create();
    List<Resource> nonAggregatable = new ArrayList<>();
    for (Resource r : children) {
        if (r instanceof ContinuousResource) {
            // non-aggregatable terminal node
            nonAggregatable.add(r);
        } else if (Iterables.any(aggregatableTypes, r::isTypeOf)) {
            // aggregatable & terminal node
            String className = r.last().getClass().getSimpleName();
            if (typesToPrint.isEmpty() || typesToPrint.contains(className)) {
                aggregatables.put(className, r);
            }
        } else {
            nonAggregatable.add(r);
        }
    }
    // print aggregated (terminal)
    aggregatables.asMap().entrySet().forEach(e -> {
        // for each type...
        String resourceName = e.getKey();
        RangeSet<Long> rangeSet = TreeRangeSet.create();
        // aggregate into RangeSet
        e.getValue().stream().map(res -> {
            if (res.isTypeOf(VlanId.class)) {
                return (long) res.valueAs(VlanId.class).get().toShort();
            } else if (res.isTypeOf(MplsLabel.class)) {
                return (long) res.valueAs(MplsLabel.class).get().toInt();
            } else if (res.isTypeOf(TributarySlot.class)) {
                return res.valueAs(TributarySlot.class).get().index();
            }
            // TODO support Lambda (OchSignal types)
            return 0L;
        }).map(Range::singleton).map(range -> range.canonical(DiscreteDomain.longs())).forEach(rangeSet::add);
        print("%s%s: %s", Strings.repeat(" ", level + 1), resourceName, rangeSet);
    });
    // print non-aggregatables (recurse)
    if (sort) {
        nonAggregatable.stream().sorted((o1, o2) -> String.valueOf(o1.id()).compareTo(String.valueOf(o2.id()))).forEach(r -> printResource(r, level + 1));
    } else {
        nonAggregatable.forEach(r -> printResource(r, level + 1));
    }
}
#method_after
private void printResource(Resource resource, int level) {
    // TODO add an option to show only available resource
    // workaround to preserve the original behavior of ResourceService#getRegisteredResources
    Set<Resource> children;
    if (resource instanceof DiscreteResource) {
        children = resourceService.getRegisteredResources(((DiscreteResource) resource).id());
    } else {
        children = Collections.emptySet();
    }
    if (resource.equals(Resource.ROOT)) {
        print("ROOT");
    } else {
        if (resource instanceof ContinuousResource) {
            String s = ((String) resource.last());
            String simpleName = s.substring(s.lastIndexOf('.') + 1);
            print("%s%s: %f", Strings.repeat(" ", level), simpleName, // ((Class<?>) resource.last()).getSimpleName(),
            ((ContinuousResource) resource).value());
            // Continuous resource is terminal node, stop here
            return;
        } else {
            String resourceName = resource.last().getClass().getSimpleName();
            String toString = String.valueOf(resource.valueAs(Object.class).orElse(""));
            if (toString.startsWith(resourceName)) {
                print("%s%s", Strings.repeat(" ", level), toString);
            } else {
                print("%s%s: %s", Strings.repeat(" ", level), resourceName, toString);
            }
        }
    }
    // Classify children into aggregatable terminal resources and everything else
    Set<Class<?>> aggregatableTypes = ImmutableSet.<Class<?>>builder().add(VlanId.class).add(MplsLabel.class).build();
    // (last() resource name) -> { Resource }
    Multimap<String, Resource> aggregatables = ArrayListMultimap.create();
    List<Resource> nonAggregatable = new ArrayList<>();
    for (Resource r : children) {
        if (!isPrintTarget(r)) {
            continue;
        }
        if (r instanceof ContinuousResource) {
            // non-aggregatable terminal node
            nonAggregatable.add(r);
        } else if (Iterables.any(aggregatableTypes, r::isTypeOf)) {
            // aggregatable & terminal node
            String className = r.last().getClass().getSimpleName();
            aggregatables.put(className, r);
        } else {
            nonAggregatable.add(r);
        }
    }
    // print aggregated (terminal)
    aggregatables.asMap().entrySet().forEach(e -> {
        // for each type...
        String resourceName = e.getKey();
        RangeSet<Long> rangeSet = TreeRangeSet.create();
        // aggregate into RangeSet
        e.getValue().stream().map(res -> {
            if (res.isTypeOf(VlanId.class)) {
                return (long) res.valueAs(VlanId.class).get().toShort();
            } else if (res.isTypeOf(MplsLabel.class)) {
                return (long) res.valueAs(MplsLabel.class).get().toInt();
            } else if (res.isTypeOf(TributarySlot.class)) {
                return res.valueAs(TributarySlot.class).get().index();
            }
            // TODO support Lambda (OchSignal types)
            return 0L;
        }).map(Range::singleton).map(range -> range.canonical(DiscreteDomain.longs())).forEach(rangeSet::add);
        print("%s%s: %s", Strings.repeat(" ", level + 1), resourceName, rangeSet);
    });
    // print non-aggregatables (recurse)
    if (sort) {
        nonAggregatable.stream().sorted((o1, o2) -> String.valueOf(o1.id()).compareTo(String.valueOf(o2.id()))).forEach(r -> printResource(r, level + 1));
    } else {
        nonAggregatable.forEach(r -> printResource(r, level + 1));
    }
}
#end_block

#method_before
private static Integer getIntegerProperty(Dictionary<?, ?> properties, String propertyName) {
    Integer value = null;
    try {
        String s = Tools.get(properties, propertyName);
        value = isNullOrEmpty(s) ? value : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        value = null;
    }
    return value;
}
#method_after
private static Integer getIntegerProperty(Dictionary<?, ?> properties, String propertyName) {
    Integer value = null;
    try {
        String s = Tools.get(properties, propertyName);
        value = isNullOrEmpty(s) ? value : Integer.parseInt(s);
    } catch (NumberFormatException | ClassCastException e) {
        value = null;
    }
    return value;
}
#end_block

#method_before
private static boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    boolean enabled = false;
    try {
        String flag = Tools.get(properties, propertyName);
        enabled = isNullOrEmpty(flag) ? enabled : flag.trim().equals("true");
    } catch (ClassCastException e) {
        // No propertyName defined.
        enabled = false;
    }
    return enabled;
}
#method_after
private static boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    boolean enabled = false;
    try {
        String flag = Tools.get(properties, propertyName);
        enabled = isNullOrEmpty(flag) ? enabled : flag.equals("true");
    } catch (ClassCastException e) {
        // No propertyName defined.
        enabled = false;
    }
    return enabled;
}
#end_block

#method_before
@PUT
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updateNetwork(InputStream input) {
    log.debug(String.format(NETWORKS_MESSAGE, "update"));
    return Response.status(Response.Status.OK).build();
}
#method_after
@PUT
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updateNetwork(@PathParam("id") String id, InputStream input) {
    log.debug(String.format(NETWORKS_MESSAGE, "update"));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@DELETE
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteNetwork(InputStream input) {
    log.debug(String.format(NETWORKS_MESSAGE, "delete"));
    return Response.status(Response.Status.OK).build();
}
#method_after
@DELETE
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response deleteNetwork(@PathParam("id") String id) {
    log.debug(String.format(NETWORKS_MESSAGE, "delete"));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@PUT
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updatePorts() {
    log.debug(String.format(PORTS_MESSAGE, "update"));
    return Response.status(Response.Status.OK).build();
}
#method_after
@PUT
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updatePorts(@PathParam("id") String id, InputStream input) {
    log.debug(String.format(PORTS_MESSAGE, "update"));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@Path("{id}")
@DELETE
public Response deletePorts() {
    log.debug(String.format(PORTS_MESSAGE, "delete"));
    return Response.status(Response.Status.OK).build();
}
#method_after
@Path("{id}")
@DELETE
@Produces(MediaType.APPLICATION_JSON)
public Response deletePorts(@PathParam("id") String id) {
    log.debug(String.format(PORTS_MESSAGE, "delete"));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@PUT
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateSubnet() {
    log.debug(String.format(SUBNETS_MESSAGE, "update"));
    return Response.status(Response.Status.OK).build();
}
#method_after
@PUT
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateSubnet(@PathParam("id") String id, InputStream input) {
    log.debug(String.format(SUBNETS_MESSAGE, "update"));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@DELETE
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response deleteSubnet() {
    log.debug(String.format(SUBNETS_MESSAGE, "delete"));
    return Response.status(Response.Status.OK).build();
}
#method_after
@DELETE
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response deleteSubnet(@PathParam("id") String id) {
    log.debug(String.format(SUBNETS_MESSAGE, "delete"));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@Override
public YangNode getDataModel(String yangFile) throws IOException, ParserException {
    /**
     * Create a char stream that reads from YANG file. Throws an exception
     * in case input YANG file is either null or non existent.
     */
    ANTLRInputStream input = null;
    try {
        input = new ANTLRFileStream(yangFile);
    } catch (IOException e) {
        e.printStackTrace();
        throw e;
    }
    // Create a lexer that feeds off of input char stream.
    GeneratedYangLexer lexer = new GeneratedYangLexer(input);
    // Create a buffer of tokens pulled from the lexer.
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    // Create a parser that feeds off the tokens buffer.
    GeneratedYangParser parser = new GeneratedYangParser(tokens);
    // Remove console error listener.
    parser.removeErrorListeners();
    // Create instance of customized error listener.
    ParseTreeErrorListener parseTreeErrorListener = new ParseTreeErrorListener();
    // Add customized error listener to catch errors during parsing.
    parser.addErrorListener(parseTreeErrorListener);
    // Begin parsing YANG file and generate parse tree.
    ParseTree tree = parser.yangfile();
    // Get the exception occurred during parsing.
    ParserException parserException = parseTreeErrorListener.getParserException();
    /**
     * Throws an parser Exception if exception flag is set i.e. exception has
     * occurred during parsing.
     */
    if (parseTreeErrorListener.isExceptionFlag()) {
        parserException.setFileName(yangFile);
        throw parserException;
    }
    // Create a walker to walk the parse tree.
    ParseTreeWalker walker = new ParseTreeWalker();
    // Create a listener implementation class object.
    TreeWalkListener treeWalker = new TreeWalkListener();
    /**
     * Walk parse tree, provide call backs to methods in listener and
     * build data model tree.
     */
    walker.walk(treeWalker, tree);
    // Create object of listener exception
    ParserException listenerException = new ParserException();
    // Throws an parser exception which has occurred during listener walk.
    if (treeWalker.getErrorInformation().isErrorFlag()) {
        listenerException.setMsg(treeWalker.getErrorInformation().getErrorMsg());
        throw listenerException;
    }
    // Returns the Root Node of the constructed data model tree.
    return treeWalker.getRootNode();
}
#method_after
@Override
public YangNode getDataModel(String yangFile) throws IOException, ParserException {
    /**
     * Create a char stream that reads from YANG file. Throws an exception
     * in case input YANG file is either null or non existent.
     */
    ANTLRInputStream input = null;
    try {
        input = new ANTLRFileStream(yangFile);
    } catch (IOException e) {
        e.printStackTrace();
        throw e;
    }
    // Create a lexer that feeds off of input char stream.
    GeneratedYangLexer lexer = new GeneratedYangLexer(input);
    // Create a buffer of tokens pulled from the lexer.
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    // Create a parser that feeds off the tokens buffer.
    GeneratedYangParser parser = new GeneratedYangParser(tokens);
    // Remove console error listener.
    parser.removeErrorListeners();
    // Create instance of customized error listener.
    ParseTreeErrorListener parseTreeErrorListener = new ParseTreeErrorListener();
    // Add customized error listener to catch errors during parsing.
    parser.addErrorListener(parseTreeErrorListener);
    // Begin parsing YANG file and generate parse tree.
    ParseTree tree = parser.yangfile();
    /**
     * Throws an parser Exception if exception flag is set i.e. exception has
     * occurred during parsing.
     */
    if (parseTreeErrorListener.isExceptionFlag()) {
        // Get the exception occurred during parsing.
        ParserException parserException = parseTreeErrorListener.getParserException();
        parserException.setFileName(yangFile);
        throw parserException;
    }
    // Create a walker to walk the parse tree.
    ParseTreeWalker walker = new ParseTreeWalker();
    // Create a listener implementation class object.
    TreeWalkListener treeWalker = new TreeWalkListener();
    /**
     * Walk parse tree, provide call backs to methods in listener and
     * build data model tree.
     */
    walker.walk(treeWalker, tree);
    // Throws an parser exception which has occurred during listener walk.
    if (treeWalker.getErrorInformation().isErrorFlag()) {
        // Create object of listener exception
        ParserException listenerException = new ParserException();
        listenerException.setMsg(treeWalker.getErrorInformation().getErrorMsg());
        listenerException.setFileName(yangFile);
        throw listenerException;
    }
    // Returns the Root Node of the constructed data model tree.
    return treeWalker.getRootNode();
}
#end_block

#method_before
public static BgpFsDestinationPortNum read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short port;
    do {
        option = (byte) cb.readByte();
        int len = (option & 0x30) >> 4;
        if ((1 << len) == 1) {
            port = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) port }));
        } else {
            port = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (port >> 8), (byte) port }));
        }
    } while ((option & 0x80) == 0);
    return new BgpFsDestinationPortNum(operatorValue);
}
#method_after
public static BgpFsDestinationPortNum read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short port;
    do {
        option = (byte) cb.readByte();
        int len = (option & Constants.BGP_FLOW_SPEC_LEN_MASK) >> 4;
        if ((1 << len) == 1) {
            port = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) port }));
        } else {
            port = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (port >> 8), (byte) port }));
        }
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsDestinationPortNum(operatorValue);
}
#end_block

#method_before
public static BgpFsFragment read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte fragment;
    do {
        option = (byte) cb.readByte();
        fragment = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) fragment }));
    } while ((option & 0x80) == 0);
    return new BgpFsFragment(operatorValue);
}
#method_after
public static BgpFsFragment read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte fragment;
    do {
        option = (byte) cb.readByte();
        fragment = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) fragment }));
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsFragment(operatorValue);
}
#end_block

#method_before
public static BgpFsPortNum read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short port;
    do {
        option = (byte) cb.readByte();
        int len = (option & 0x30) >> 4;
        if ((1 << len) == 1) {
            port = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) port }));
        } else {
            port = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (port >> 8), (byte) port }));
        }
    } while ((option & 0x80) == 0);
    return new BgpFsPortNum(operatorValue);
}
#method_after
public static BgpFsPortNum read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short port;
    do {
        option = (byte) cb.readByte();
        int len = (option & Constants.BGP_FLOW_SPEC_LEN_MASK) >> 4;
        if ((1 << len) == 1) {
            port = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) port }));
        } else {
            port = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (port >> 8), (byte) port }));
        }
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsPortNum(operatorValue);
}
#end_block

#method_before
public static BgpFsIcmpCode read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte icmpCode;
    do {
        option = (byte) cb.readByte();
        icmpCode = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) icmpCode }));
    } while ((option & 0x80) == 0);
    return new BgpFsIcmpCode(operatorValue);
}
#method_after
public static BgpFsIcmpCode read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte icmpCode;
    do {
        option = (byte) cb.readByte();
        icmpCode = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) icmpCode }));
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsIcmpCode(operatorValue);
}
#end_block

#method_before
public static BgpFsDscpValue read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte dscpValue;
    do {
        option = (byte) cb.readByte();
        dscpValue = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) dscpValue }));
    } while ((option & 0x80) == 0);
    return new BgpFsDscpValue(operatorValue);
}
#method_after
public static BgpFsDscpValue read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte dscpValue;
    do {
        option = (byte) cb.readByte();
        dscpValue = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) dscpValue }));
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsDscpValue(operatorValue);
}
#end_block

#method_before
public static BgpFsTcpFlags read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short tcpFlag;
    do {
        option = (byte) cb.readByte();
        int len = (option & 0x30) >> 4;
        if ((1 << len) == 1) {
            tcpFlag = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) tcpFlag }));
        } else {
            tcpFlag = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (tcpFlag >> 8), (byte) tcpFlag }));
        }
    } while ((option & 0x80) == 0);
    return new BgpFsTcpFlags(operatorValue);
}
#method_after
public static BgpFsTcpFlags read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short tcpFlag;
    do {
        option = (byte) cb.readByte();
        int len = (option & Constants.BGP_FLOW_SPEC_LEN_MASK) >> 4;
        if ((1 << len) == 1) {
            tcpFlag = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) tcpFlag }));
        } else {
            tcpFlag = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (tcpFlag >> 8), (byte) tcpFlag }));
        }
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsTcpFlags(operatorValue);
}
#end_block

#method_before
public static BgpFsIpProtocol read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte proto;
    do {
        option = (byte) cb.readByte();
        proto = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) proto }));
    } while ((option & 0x80) == 0);
    return new BgpFsIpProtocol(operatorValue);
}
#method_after
public static BgpFsIpProtocol read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte proto;
    do {
        option = (byte) cb.readByte();
        proto = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) proto }));
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsIpProtocol(operatorValue);
}
#end_block

#method_before
public static BgpFsIcmpType read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte icmpType;
    do {
        option = (byte) cb.readByte();
        icmpType = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) icmpType }));
    } while ((option & 0x80) == 0);
    return new BgpFsIcmpType(operatorValue);
}
#method_after
public static BgpFsIcmpType read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    byte icmpType;
    do {
        option = (byte) cb.readByte();
        icmpType = cb.readByte();
        operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) icmpType }));
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsIcmpType(operatorValue);
}
#end_block

#method_before
public static BgpFsPacketLength read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short packetLen;
    do {
        option = (byte) cb.readByte();
        int len = (option & 0x30) >> 4;
        if ((1 << len) == 1) {
            packetLen = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) packetLen }));
        } else {
            packetLen = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (packetLen >> 8), (byte) packetLen }));
        }
    } while ((option & 0x80) == 0);
    return new BgpFsPacketLength(operatorValue);
}
#method_after
public static BgpFsPacketLength read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short packetLen;
    do {
        option = (byte) cb.readByte();
        int len = (option & Constants.BGP_FLOW_SPEC_LEN_MASK) >> 4;
        if ((1 << len) == 1) {
            packetLen = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) packetLen }));
        } else {
            packetLen = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (packetLen >> 8), (byte) packetLen }));
        }
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsPacketLength(operatorValue);
}
#end_block

#method_before
public static BgpFsSourcePortNum read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short port;
    do {
        option = (byte) cb.readByte();
        int len = (option & 0x30) >> 4;
        if ((1 << len) == 1) {
            port = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) port }));
        } else {
            port = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (port >> 8), (byte) port }));
        }
    } while ((option & 0x80) == 0);
    return new BgpFsSourcePortNum(operatorValue);
}
#method_after
public static BgpFsSourcePortNum read(ChannelBuffer cb) throws BgpParseException {
    List<BgpFsOperatorValue> operatorValue = new LinkedList<>();
    byte option;
    short port;
    do {
        option = (byte) cb.readByte();
        int len = (option & Constants.BGP_FLOW_SPEC_LEN_MASK) >> 4;
        if ((1 << len) == 1) {
            port = cb.readByte();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) port }));
        } else {
            port = cb.readShort();
            operatorValue.add(new BgpFsOperatorValue(option, new byte[] { (byte) (port >> 8), (byte) port }));
        }
    } while ((option & Constants.BGP_FLOW_SPEC_END_OF_LIST_MASK) == 0);
    return new BgpFsSourcePortNum(operatorValue);
}
#end_block

#method_before
private CompletableFuture<Void> doUnicast(MessageSubject subject, byte[] payload, NodeId toNodeId) {
    ControllerNode node = clusterService.getNode(toNodeId);
    checkArgument(node != null, "Unknown nodeId: %s", toNodeId);
    Endpoint nodeEp = new Endpoint(node.ip(), node.tcpPort());
    final MeteringAgent.Context context = subjectMeteringAgent.startTimer(subject.toString() + ONE_WAY_SUFFIX);
    return messagingService.sendAsync(nodeEp, subject.value(), payload).whenComplete((r, e) -> context.stop(e));
}
#method_after
private CompletableFuture<Void> doUnicast(MessageSubject subject, byte[] payload, NodeId toNodeId) {
    ControllerNode node = clusterService.getNode(toNodeId);
    checkArgument(node != null, "Unknown nodeId: %s", toNodeId);
    Endpoint nodeEp = new Endpoint(node.ip(), node.tcpPort());
    MeteringAgent.Context context = subjectMeteringAgent.startTimer(subject.toString() + ONE_WAY_SUFFIX);
    return messagingService.sendAsync(nodeEp, subject.value(), payload).whenComplete((r, e) -> context.stop(e));
}
#end_block

#method_before
private CompletableFuture<byte[]> sendAndReceive(MessageSubject subject, byte[] payload, NodeId toNodeId) {
    ControllerNode node = clusterService.getNode(toNodeId);
    checkArgument(node != null, "Unknown nodeId: %s", toNodeId);
    Endpoint nodeEp = new Endpoint(node.ip(), node.tcpPort());
    final MeteringAgent.Context epContext = endpointMeteringAgent.startTimer(NODE_PREFIX + toNodeId.toString() + ROUND_TRIP_SUFFIX);
    final MeteringAgent.Context subjectContext = subjectMeteringAgent.startTimer(subject.toString() + ROUND_TRIP_SUFFIX);
    return messagingService.sendAndReceive(nodeEp, subject.value(), payload).whenComplete((bytes, throwable) -> {
        subjectContext.stop(throwable);
        epContext.stop(throwable);
    });
}
#method_after
private CompletableFuture<byte[]> sendAndReceive(MessageSubject subject, byte[] payload, NodeId toNodeId) {
    ControllerNode node = clusterService.getNode(toNodeId);
    checkArgument(node != null, "Unknown nodeId: %s", toNodeId);
    Endpoint nodeEp = new Endpoint(node.ip(), node.tcpPort());
    MeteringAgent.Context epContext = endpointMeteringAgent.startTimer(NODE_PREFIX + toNodeId.toString() + ROUND_TRIP_SUFFIX);
    MeteringAgent.Context subjectContext = subjectMeteringAgent.startTimer(subject.toString() + ROUND_TRIP_SUFFIX);
    return messagingService.sendAndReceive(nodeEp, subject.value(), payload).whenComplete((bytes, throwable) -> {
        subjectContext.stop(throwable);
        epContext.stop(throwable);
    });
}
#end_block

#method_before
@Override
public void addServiceVm(CordVtnNode node, ConnectPoint connectPoint) {
    Port port = deviceService.getPort(connectPoint.deviceId(), connectPoint.port());
    OpenstackPort vPort = openstackService.port(port);
    if (vPort == null) {
        log.warn("Failed to get OpenstackPort for {}", getPortName(port));
        return;
    }
    MacAddress mac = vPort.macAddress();
    HostId hostId = HostId.hostId(mac);
    Host host = hostService.getHost(hostId);
    if (host != null) {
        // Host is already known to the system, no HOST_ADDED event is triggered in this case.
        // It happens when the application is restarted.
        String vmId = host.annotations().value(OPENSTACK_VM_ID);
        if (vmId != null && vmId.equals(vPort.deviceId())) {
            serviceVmAdded(host);
            return;
        } else {
            hostProvider.hostVanished(host.id());
        }
    }
    Set<IpAddress> ip = Sets.newHashSet(vPort.fixedIps().values());
    SparseAnnotations annotations = DefaultAnnotations.builder().set(OPENSTACK_VM_ID, vPort.deviceId()).set(SERVICE_ID, vPort.networkId()).set(LOCATION_IP, node.localIp().toString()).build();
    HostDescription hostDesc = new DefaultHostDescription(mac, VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), ip, annotations);
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#method_after
@Override
public void addServiceVm(CordVtnNode node, ConnectPoint connectPoint) {
    Port port = deviceService.getPort(connectPoint.deviceId(), connectPoint.port());
    OpenstackPort vPort = openstackService.port(port);
    if (vPort == null) {
        log.warn("Failed to get OpenstackPort for {}", getPortName(port));
        return;
    }
    MacAddress mac = vPort.macAddress();
    HostId hostId = HostId.hostId(mac);
    Host host = hostService.getHost(hostId);
    if (host != null) {
        // Host is already known to the system, no HOST_ADDED event is triggered in this case.
        // It happens when the application is restarted.
        String vmId = host.annotations().value(OPENSTACK_VM_ID);
        if (vmId != null && vmId.equals(vPort.deviceId())) {
            serviceVmAdded(host);
            return;
        } else {
            hostProvider.hostVanished(host.id());
        }
    }
    Set<IpAddress> ip = Sets.newHashSet(vPort.fixedIps().values());
    SparseAnnotations annotations = DefaultAnnotations.builder().set(OPENSTACK_VM_ID, vPort.deviceId()).set(SERVICE_ID, vPort.networkId()).set(LOCATION_IP, node.dpIp().ip().toString()).build();
    HostDescription hostDesc = new DefaultHostDescription(mac, VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), ip, annotations);
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#end_block

#method_before
@POST
@Path("{tenantServiceId}/{providerServiceId}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response createServiceDependency(@PathParam("tenantServiceId") String tServiceId, @PathParam("providerServiceId") String pServiceId) {
    service.createServiceDependency(CordServiceId.of(tServiceId), CordServiceId.of(pServiceId), false);
    return Response.status(Response.Status.OK).build();
}
#method_after
@POST
@Path("{tenantServiceId}/{providerServiceId}")
@Produces(MediaType.APPLICATION_JSON)
public Response createServiceDependency(@PathParam("tenantServiceId") String tServiceId, @PathParam("providerServiceId") String pServiceId) {
    service.createServiceDependency(CordServiceId.of(tServiceId), CordServiceId.of(pServiceId), false);
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@POST
@Path("{tenantServiceId}/{providerServiceId}/{direction}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response createServiceDependency(@PathParam("tenantServiceId") String tServiceId, @PathParam("providerServiceId") String pServiceId, @PathParam("direction") String direction) {
    service.createServiceDependency(CordServiceId.of(tServiceId), CordServiceId.of(pServiceId), direction.equals(BIDIRECTION));
    return Response.status(Response.Status.OK).build();
}
#method_after
@POST
@Path("{tenantServiceId}/{providerServiceId}/{direction}")
@Produces(MediaType.APPLICATION_JSON)
public Response createServiceDependency(@PathParam("tenantServiceId") String tServiceId, @PathParam("providerServiceId") String pServiceId, @PathParam("direction") String direction) {
    service.createServiceDependency(CordServiceId.of(tServiceId), CordServiceId.of(pServiceId), direction.equals(BIDIRECTION));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
public void init(DeviceId deviceId, String phyPortName, IpAddress localIp) {
    // default is drop packets which can be accomplished without
    // a table miss entry for all table.
    PortNumber tunnelPort = getTunnelPort(deviceId);
    PortNumber phyPort = getPhyPort(deviceId, phyPortName);
    processFirstTable(deviceId, phyPort, localIp);
    processInPortTable(deviceId, tunnelPort, phyPort);
    processAccessTypeTable(deviceId, phyPort);
}
#method_after
public void init(DeviceId deviceId, String dpIntf, IpAddress dpIp) {
    // default is drop packets which can be accomplished without
    // a table miss entry for all table.
    PortNumber tunnelPort = getTunnelPort(deviceId);
    PortNumber dpPort = getDpPort(deviceId, dpIntf);
    processFirstTable(deviceId, dpPort, dpIp);
    processInPortTable(deviceId, tunnelPort, dpPort);
    processAccessTypeTable(deviceId, dpPort);
}
#end_block

#method_before
private void processFirstTable(DeviceId deviceId, PortNumber phyPort, IpAddress localIp) {
    // take vxlan packet out onto the physical port
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(phyPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a vxlan encap'd packet through the Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(phyPort).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(VXLAN_UDP_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a packet to the local ip through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(phyPort).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(localIp.toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take an arp packet from physical through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(phyPort).matchEthType(Ethernet.TYPE_ARP).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all else to the next table
    selector = DefaultTrafficSelector.builder().build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_PORT).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processFirstTable(DeviceId deviceId, PortNumber dpPort, IpAddress dpIp) {
    // take vxlan packet out onto the physical port
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a vxlan encap'd packet through the Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(VXLAN_UDP_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a packet to the data plane ip through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dpIp.toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take an arp packet from physical through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_ARP).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all else to the next table
    selector = DefaultTrafficSelector.builder().build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_PORT).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private void processAccessTypeTable(DeviceId deviceId, PortNumber phyPort) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(phyPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processAccessTypeTable(DeviceId deviceId, PortNumber dpPort) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private void processInPortTable(DeviceId deviceId, PortNumber tunnelPort, PortNumber phyPort) {
    checkNotNull(tunnelPort);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(tunnelPort).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_TUNNEL_IN).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(phyPort).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processInPortTable(DeviceId deviceId, PortNumber tunnelPort, PortNumber dpPort) {
    checkNotNull(tunnelPort);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(tunnelPort).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_TUNNEL_IN).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value("portName").contains(tunnelType)).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#method_after
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).contains(tunnelType)).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#end_block

#method_before
public IpAddress dpIp() {
    return this.dpIp;
}
#method_after
public NetworkAddress dpIp() {
    return this.dpIp;
}
#end_block

#method_before
public DeviceId ovsdbId() {
    return DeviceId.deviceId("ovsdb:" + this.mgmtIp.toString());
}
#method_after
public DeviceId ovsdbId() {
    return DeviceId.deviceId("ovsdb:" + this.hostMgmtIp.ip().toString());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof CordVtnNode) {
        CordVtnNode that = (CordVtnNode) obj;
        if (Objects.equals(hostname, that.hostname)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    // unique throughout the service.
    if (obj instanceof CordVtnNode) {
        CordVtnNode that = (CordVtnNode) obj;
        if (Objects.equals(hostname, that.hostname)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("host", hostname).add("ip", mgmtIp).add("dpIp", dpIp).add("dpIpPrefix", dpIpPrefix).add("port", ovsdbPort).add("sshInfo", sshInfo).add("bridgeId", bridgeId).add("dpIntf", dpIntf).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("hostname", hostname).add("hostMgmtIp", hostMgmtIp).add("localMgmtIp", localMgmtIp).add("dpIp", dpIp).add("port", ovsdbPort).add("sshInfo", sshInfo).add("bridgeId", bridgeId).add("dpIntf", dpIntf).toString();
}
#end_block

#method_before
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value("portName").contains(tunnelType)).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#method_after
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).contains(tunnelType)).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#end_block

#method_before
private PortNumber getDpPort(DeviceId deviceId, String dpIntf) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value("portName").contains(dpIntf) && p.isEnabled()).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#method_after
private PortNumber getDpPort(DeviceId deviceId, String dpIntf) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).contains(dpIntf) && p.isEnabled()).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#end_block

#method_before
public static boolean addIp(Session session, IpAddress ip, IpPrefix prefix, String device) {
    if (session == null || !session.isConnected()) {
        return false;
    }
    String ipAddr = ip.toString() + "/" + prefix.prefixLength();
    executeCommand(session, String.format(IP_ADDR_ADD, ipAddr, device));
    Set<IpAddress> result = getCurrentIps(session, device);
    return result.contains(ip);
}
#method_after
public static boolean addIp(Session session, NetworkAddress ip, String device) {
    if (session == null || !session.isConnected()) {
        return false;
    }
    executeCommand(session, String.format(IP_ADDR_ADD, ip.cidr(), device));
    Set<IpAddress> result = getCurrentIps(session, device);
    return result.contains(ip.ip());
}
#end_block

#method_before
public String checkNodeInitState(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist, add node first", node.hostname());
        return null;
    }
    String result = String.format("Integration bridge created/connected : %s (%s)%n" + "VXLAN interface created : %s%n" + "Data plane interface added : %s (%s)%n" + "IP address added to br-int : %s (%s/%s)", isBrIntCreated(node) ? OK : NO, DEFAULT_BRIDGE, isTunnelIntfCreated(node) ? OK : NO, isDataPlaneIntfAdded(node) ? OK : NO, node.dpIntf(), isIpAddressSet(node) ? OK : NO, node.dpIp(), node.dpIpPrefix().prefixLength());
    return result;
}
#method_after
public String checkNodeInitState(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist, add node first", node.hostname());
        return null;
    }
    Session session = RemoteIpCommandUtil.connect(node.sshInfo());
    if (session == null) {
        log.debug("Failed to SSH to {}", node.hostname());
        return null;
    }
    Set<IpAddress> intBrIps = RemoteIpCommandUtil.getCurrentIps(session, DEFAULT_BRIDGE);
    String result = String.format("Integration bridge created/connected : %s (%s)%n" + "VXLAN interface created : %s%n" + "Data plane interface added : %s (%s)%n" + "IP flushed from %s : %s%n" + "Data plane IP added to br-int : %s (%s)%n" + "Local management IP added to br-int : %s (%s)", isBrIntCreated(node) ? OK : NO, DEFAULT_BRIDGE, isTunnelIntfCreated(node) ? OK : NO, isDataPlaneIntfAdded(node) ? OK : NO, node.dpIntf(), node.dpIntf(), RemoteIpCommandUtil.getCurrentIps(session, node.dpIntf()).isEmpty() ? OK : NO, intBrIps.contains(node.dpIp().ip()) ? OK : NO, node.dpIp().cidr(), intBrIps.contains(node.localMgmtIp().ip()) ? OK : NO, node.localMgmtIp().cidr());
    RemoteIpCommandUtil.disconnect(session);
    return result;
}
#end_block

#method_before
private void postInit(CordVtnNode node) {
    disconnectOvsdb(node);
    ruleInstaller.init(node.intBrId(), node.dpIntf(), node.dpIp());
    // add existing hosts to the service
    deviceService.getPorts(node.intBrId()).stream().filter(port -> getPortName(port).startsWith(VPORT_PREFIX) && port.isEnabled()).forEach(port -> cordVtnService.addServiceVm(node, getConnectPoint(port)));
    // remove stale hosts from the service
    hostService.getHosts().forEach(host -> {
        Port port = deviceService.getPort(host.location().deviceId(), host.location().port());
        if (port == null) {
            cordVtnService.removeServiceVm(getConnectPoint(host));
        }
    });
    log.info("Finished init {}", node.hostname());
}
#method_after
private void postInit(CordVtnNode node) {
    disconnectOvsdb(node);
    ruleInstaller.init(node.intBrId(), node.dpIntf(), node.dpIp().ip());
    // add existing hosts to the service
    deviceService.getPorts(node.intBrId()).stream().filter(port -> getPortName(port).startsWith(VPORT_PREFIX) && port.isEnabled()).forEach(port -> cordVtnService.addServiceVm(node, getConnectPoint(port)));
    // remove stale hosts from the service
    hostService.getHosts().forEach(host -> {
        Port port = deviceService.getPort(host.location().deviceId(), host.location().port());
        if (port == null) {
            cordVtnService.removeServiceVm(getConnectPoint(host));
        }
    });
    log.info("Finished init {}", node.hostname());
}
#end_block

#method_before
private void connectOvsdb(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!isOvsdbConnected(node)) {
        controller.connect(node.mgmtIp(), node.ovsdbPort());
    }
}
#method_after
private void connectOvsdb(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!isOvsdbConnected(node)) {
        controller.connect(node.hostMgmtIp().ip(), node.ovsdbPort());
    }
}
#end_block

#method_before
private OvsdbClientService getOvsdbClient(CordVtnNode node) {
    checkNotNull(node);
    OvsdbClientService ovsdbClient = controller.getOvsdbClient(new OvsdbNodeId(node.mgmtIp(), node.ovsdbPort().toInt()));
    if (ovsdbClient == null) {
        log.trace("Couldn't find OVSDB client for {}", node.hostname());
    }
    return ovsdbClient;
}
#method_after
private OvsdbClientService getOvsdbClient(CordVtnNode node) {
    checkNotNull(node);
    OvsdbClientService ovsdbClient = controller.getOvsdbClient(new OvsdbNodeId(node.hostMgmtIp().ip(), node.ovsdbPort().toInt()));
    if (ovsdbClient == null) {
        log.trace("Couldn't find OVSDB client for {}", node.hostname());
    }
    return ovsdbClient;
}
#end_block

#method_before
private void setIpAddress(CordVtnNode node) {
    Session session = RemoteIpCommandUtil.connect(node.sshInfo());
    if (session == null) {
        log.debug("Failed to SSH to {}", node.hostname());
        return;
    }
    boolean result = RemoteIpCommandUtil.flushIp(session, node.dpIntf()) && RemoteIpCommandUtil.setInterfaceUp(session, node.dpIntf()) && RemoteIpCommandUtil.addIp(session, node.dpIp(), node.dpIpPrefix(), DEFAULT_BRIDGE) && RemoteIpCommandUtil.setInterfaceUp(session, DEFAULT_BRIDGE);
    RemoteIpCommandUtil.disconnect(session);
    if (result) {
        setNodeState(node, NodeState.COMPLETE);
    }
}
#method_after
private void setIpAddress(CordVtnNode node) {
    Session session = RemoteIpCommandUtil.connect(node.sshInfo());
    if (session == null) {
        log.debug("Failed to SSH to {}", node.hostname());
        return;
    }
    boolean result = RemoteIpCommandUtil.flushIp(session, node.dpIntf()) && RemoteIpCommandUtil.setInterfaceUp(session, node.dpIntf()) && RemoteIpCommandUtil.addIp(session, node.dpIp(), DEFAULT_BRIDGE) && RemoteIpCommandUtil.addIp(session, node.localMgmtIp(), DEFAULT_BRIDGE) && RemoteIpCommandUtil.setInterfaceUp(session, DEFAULT_BRIDGE);
    RemoteIpCommandUtil.disconnect(session);
    if (result) {
        setNodeState(node, NodeState.COMPLETE);
    }
}
#end_block

#method_before
private boolean isIpAddressSet(CordVtnNode node) {
    Session session = RemoteIpCommandUtil.connect(node.sshInfo());
    if (session == null) {
        log.debug("Failed to SSH to {}", node.hostname());
        return false;
    }
    boolean result = RemoteIpCommandUtil.getCurrentIps(session, node.dpIntf()).isEmpty() && RemoteIpCommandUtil.isInterfaceUp(session, node.dpIntf()) && RemoteIpCommandUtil.getCurrentIps(session, DEFAULT_BRIDGE).contains(node.dpIp()) && RemoteIpCommandUtil.isInterfaceUp(session, DEFAULT_BRIDGE);
    RemoteIpCommandUtil.disconnect(session);
    return result;
}
#method_after
private boolean isIpAddressSet(CordVtnNode node) {
    Session session = RemoteIpCommandUtil.connect(node.sshInfo());
    if (session == null) {
        log.debug("Failed to SSH to {}", node.hostname());
        return false;
    }
    Set<IpAddress> intBrIps = RemoteIpCommandUtil.getCurrentIps(session, DEFAULT_BRIDGE);
    boolean result = RemoteIpCommandUtil.getCurrentIps(session, node.dpIntf()).isEmpty() && RemoteIpCommandUtil.isInterfaceUp(session, node.dpIntf()) && intBrIps.contains(node.dpIp().ip()) && intBrIps.contains(node.localMgmtIp().ip()) && RemoteIpCommandUtil.isInterfaceUp(session, DEFAULT_BRIDGE);
    RemoteIpCommandUtil.disconnect(session);
    return result;
}
#end_block

#method_before
private void readConfiguration() {
    CordVtnConfig config = configRegistry.getConfig(appId, CordVtnConfig.class);
    if (config == null) {
        log.debug("No configuration found");
        return;
    }
    TpPort ovsdbPort = config.ovsdbPort();
    TpPort sshPort = config.sshPort();
    String sshUser = config.sshUser();
    String sshKeyFile = config.sshKeyFile();
    config.cordVtnNodes().forEach(node -> {
        CordVtnNode cordVtnNode = new CordVtnNode(node.hostname(), node.mgmtIp(), node.dpIp(), node.dpIpPrefix(), ovsdbPort, new SshAccessInfo(node.mgmtIp().getIp4Address(), sshPort, sshUser, sshKeyFile), node.bridgeId(), node.dpIntf());
        addNode(cordVtnNode);
    });
// TODO remove nodes if needed
}
#method_after
private void readConfiguration() {
    CordVtnConfig config = configRegistry.getConfig(appId, CordVtnConfig.class);
    if (config == null) {
        log.debug("No configuration found");
        return;
    }
    NetworkAddress localMgmtIp = config.localMgmtIp();
    TpPort ovsdbPort = config.ovsdbPort();
    TpPort sshPort = config.sshPort();
    String sshUser = config.sshUser();
    String sshKeyFile = config.sshKeyFile();
    config.cordVtnNodes().forEach(node -> {
        log.debug("Read node {}", node.hostname());
        CordVtnNode cordVtnNode = new CordVtnNode(node.hostname(), node.hostMgmtIp(), localMgmtIp, node.dpIp(), ovsdbPort, new SshAccessInfo(node.hostMgmtIp().ip().getIp4Address(), sshPort, sshUser, sshKeyFile), node.bridgeId(), node.dpIntf());
        addNode(cordVtnNode);
    });
// TODO remove nodes if needed
}
#end_block

#method_before
@Override
protected void execute() {
    CordVtnNodeManager nodeManager = AbstractShellCommand.get(CordVtnNodeManager.class);
    List<CordVtnNode> nodes = nodeManager.getNodes();
    Collections.sort(nodes, CordVtnNode.CORDVTN_NODE_COMPARATOR);
    if (outputJson()) {
        print("%s", json(nodeManager, nodes));
    } else {
        for (CordVtnNode node : nodes) {
            print("hostname=%s, mgmtIp=%s, dpIp=%s/%s, br-int=%s, dpIntf=%s, init=%s", node.hostname(), node.mgmtIp().toString(), node.dpIp().toString(), node.dpIpPrefix().prefixLength(), node.intBrId().toString(), node.dpIntf(), getState(nodeManager, node));
        }
        print("Total %s nodes", nodeManager.getNodeCount());
    }
}
#method_after
@Override
protected void execute() {
    CordVtnNodeManager nodeManager = AbstractShellCommand.get(CordVtnNodeManager.class);
    List<CordVtnNode> nodes = nodeManager.getNodes();
    Collections.sort(nodes, CordVtnNode.CORDVTN_NODE_COMPARATOR);
    if (outputJson()) {
        print("%s", json(nodeManager, nodes));
    } else {
        for (CordVtnNode node : nodes) {
            print("hostname=%s, hostMgmtIp=%s, dpIp=%s, br-int=%s, dpIntf=%s, init=%s", node.hostname(), node.hostMgmtIp().cidr(), node.dpIp().cidr(), node.intBrId().toString(), node.dpIntf(), getState(nodeManager, node));
        }
        print("Total %s nodes", nodeManager.getNodeCount());
    }
}
#end_block

#method_before
private JsonNode json(CordVtnNodeManager nodeManager, List<CordVtnNode> nodes) {
    ObjectMapper mapper = new ObjectMapper();
    ArrayNode result = mapper.createArrayNode();
    for (CordVtnNode node : nodes) {
        result.add(mapper.createObjectNode().put("hostname", node.hostname()).put("managementIp", node.mgmtIp().toString()).put("dataPlaneIp", node.dpIp().toString()).put("dataPlaneIpPrefix", node.dpIpPrefix().toString()).put("bridgeId", node.intBrId().toString()).put("dataPlaneInterface", node.dpIntf()).put("init", getState(nodeManager, node)));
    }
    return result;
}
#method_after
private JsonNode json(CordVtnNodeManager nodeManager, List<CordVtnNode> nodes) {
    ObjectMapper mapper = new ObjectMapper();
    ArrayNode result = mapper.createArrayNode();
    for (CordVtnNode node : nodes) {
        result.add(mapper.createObjectNode().put("hostname", node.hostname()).put("hostManagementIp", node.hostMgmtIp().cidr()).put("dataPlaneIp", node.dpIp().cidr()).put("bridgeId", node.intBrId().toString()).put("dataPlaneInterface", node.dpIntf()).put("init", getState(nodeManager, node)));
    }
    return result;
}
#end_block

#method_before
private String getState(CordVtnNodeManager nodeManager, CordVtnNode node) {
    return nodeManager.isNodeInitComplete(node) ? "COMPLETE" : "INCOMPLETE";
}
#method_after
private String getState(CordVtnNodeManager nodeManager, CordVtnNode node) {
    return nodeManager.isNodeInitComplete(node) ? COMPLETE : INCOMPLETE;
}
#end_block

#method_before
@Override
public void addServiceVm(CordVtnNode node, ConnectPoint connectPoint) {
    Port port = deviceService.getPort(connectPoint.deviceId(), connectPoint.port());
    OpenstackPort vPort = openstackService.port(port);
    if (vPort == null) {
        log.warn("Failed to get OpenstackPort for {}", getPortName(port));
        return;
    }
    MacAddress mac = vPort.macAddress();
    HostId hostId = HostId.hostId(mac);
    Host host = hostService.getHost(hostId);
    if (host != null) {
        // Host is already known to the system, no HOST_ADDED event is triggered in this case.
        // It happens when the application is restarted.
        String vmId = host.annotations().value(OPENSTACK_VM_ID);
        if (vmId != null && vmId.equals(vPort.deviceId())) {
            serviceVmAdded(host);
            return;
        } else {
            hostProvider.hostVanished(host.id());
        }
    }
    Set<IpAddress> ip = Sets.newHashSet(vPort.fixedIps().values());
    SparseAnnotations annotations = DefaultAnnotations.builder().set(OPENSTACK_VM_ID, vPort.deviceId()).set(SERVICE_ID, vPort.networkId()).set(LOCATION_IP, node.dpIp().toString()).build();
    HostDescription hostDesc = new DefaultHostDescription(mac, VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), ip, annotations);
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#method_after
@Override
public void addServiceVm(CordVtnNode node, ConnectPoint connectPoint) {
    Port port = deviceService.getPort(connectPoint.deviceId(), connectPoint.port());
    OpenstackPort vPort = openstackService.port(port);
    if (vPort == null) {
        log.warn("Failed to get OpenstackPort for {}", getPortName(port));
        return;
    }
    MacAddress mac = vPort.macAddress();
    HostId hostId = HostId.hostId(mac);
    Host host = hostService.getHost(hostId);
    if (host != null) {
        // Host is already known to the system, no HOST_ADDED event is triggered in this case.
        // It happens when the application is restarted.
        String vmId = host.annotations().value(OPENSTACK_VM_ID);
        if (vmId != null && vmId.equals(vPort.deviceId())) {
            serviceVmAdded(host);
            return;
        } else {
            hostProvider.hostVanished(host.id());
        }
    }
    Set<IpAddress> ip = Sets.newHashSet(vPort.fixedIps().values());
    SparseAnnotations annotations = DefaultAnnotations.builder().set(OPENSTACK_VM_ID, vPort.deviceId()).set(SERVICE_ID, vPort.networkId()).set(LOCATION_IP, node.dpIp().ip().toString()).build();
    HostDescription hostDesc = new DefaultHostDescription(mac, VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), ip, annotations);
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#end_block

#method_before
public Set<CordVtnNodeConfig> cordVtnNodes() {
    Set<CordVtnNodeConfig> nodes = Sets.newHashSet();
    JsonNode jsonNodes = object.get(CORDVTN_NODES);
    if (jsonNodes == null) {
        return null;
    }
    jsonNodes.forEach(jsonNode -> {
        try {
            nodes.add(new CordVtnNodeConfig(jsonNode.path(HOSTNAME).asText(), IpAddress.valueOf(jsonNode.path(MANAGEMENT_IP).asText()), IpAddress.valueOf(jsonNode.path(DATA_PLANE_IP).asText().split("/")[0]), IpPrefix.valueOf(jsonNode.path(DATA_PLANE_IP).asText()), jsonNode.path(DATA_PLANE_INTF).asText(), DeviceId.deviceId(jsonNode.path(BRIDGE_ID).asText())));
        } catch (IllegalArgumentException | NullPointerException e) {
            log.error("Failed to read {}", e.toString());
        }
    });
    return nodes;
}
#method_after
public Set<CordVtnNodeConfig> cordVtnNodes() {
    Set<CordVtnNodeConfig> nodes = Sets.newHashSet();
    JsonNode jsonNodes = object.get(CORDVTN_NODES);
    if (jsonNodes == null) {
        return null;
    }
    jsonNodes.forEach(jsonNode -> {
        try {
            nodes.add(new CordVtnNodeConfig(jsonNode.path(HOSTNAME).asText(), NetworkAddress.valueOf(jsonNode.path(HOST_MANAGEMENT_IP).asText()), NetworkAddress.valueOf(jsonNode.path(DATA_PLANE_IP).asText()), jsonNode.path(DATA_PLANE_INTF).asText(), DeviceId.deviceId(jsonNode.path(BRIDGE_ID).asText())));
        } catch (IllegalArgumentException | NullPointerException e) {
            log.error("Failed to read {}", e.toString());
        }
    });
    return nodes;
}
#end_block

#method_before
public IpAddress dpIp() {
    return this.dpIp;
}
#method_after
public NetworkAddress dpIp() {
    return this.dpIp;
}
#end_block

#method_before
@Override
public <M> CompletableFuture<Void> unicast(M message, MessageSubject subject, Function<M, byte[]> encoder, NodeId toNodeId) {
    try {
        byte[] payload = new ClusterMessage(localNodeId, subject, encode(message, encoder)).getBytes();
        return doUnicast(subject, payload, toNodeId);
    } catch (Exception e) {
        return Tools.exceptionalFuture(e);
    }
}
#method_after
@Override
public <M> CompletableFuture<Void> unicast(M message, MessageSubject subject, Function<M, byte[]> encoder, NodeId toNodeId) {
    try {
        byte[] payload = new ClusterMessage(localNodeId, subject, timeFunction(encoder, subjectMeteringAgent, SERIALIZING).apply(message)).getBytes();
        return doUnicast(subject, payload, toNodeId);
    } catch (Exception e) {
        return Tools.exceptionalFuture(e);
    }
}
#end_block

#method_before
@Override
public <M> void multicast(M message, MessageSubject subject, Function<M, byte[]> encoder, Set<NodeId> nodes) {
    byte[] payload = new ClusterMessage(localNodeId, subject, encode(message, encoder)).getBytes();
    nodes.forEach(nodeId -> doUnicast(subject, payload, nodeId));
}
#method_after
@Override
public <M> void multicast(M message, MessageSubject subject, Function<M, byte[]> encoder, Set<NodeId> nodes) {
    byte[] payload = new ClusterMessage(localNodeId, subject, timeFunction(encoder, subjectMeteringAgent, SERIALIZING).apply(message)).getBytes();
    nodes.forEach(nodeId -> doUnicast(subject, payload, nodeId));
}
#end_block

#method_before
@Override
public <M, R> CompletableFuture<R> sendAndReceive(M message, MessageSubject subject, Function<M, byte[]> encoder, Function<byte[], R> decoder, NodeId toNodeId) {
    try {
        // Timer.Context context = MetricsUtil.
        // startTimer(createTimer("clusterCommunication", "rtt", subject.toString()));
        ClusterMessage envelope = new ClusterMessage(clusterService.getLocalNode().id(), subject, encode(message, encoder));
        return sendAndReceive(subject, envelope.getBytes(), toNodeId).thenApply(bytes -> decode(bytes, decoder));
    // .whenComplete((r, throwable) -> {
    // MetricsUtil.stopTimer(context);
    // });
    } catch (Exception e) {
        return Tools.exceptionalFuture(e);
    }
}
#method_after
@Override
public <M, R> CompletableFuture<R> sendAndReceive(M message, MessageSubject subject, Function<M, byte[]> encoder, Function<byte[], R> decoder, NodeId toNodeId) {
    try {
        ClusterMessage envelope = new ClusterMessage(clusterService.getLocalNode().id(), subject, timeFunction(encoder, subjectMeteringAgent, SERIALIZING).apply(message));
        return sendAndReceive(subject, envelope.getBytes(), toNodeId).thenApply(bytes -> timeFunction(decoder, subjectMeteringAgent, DESERIALIZING).apply(bytes));
    } catch (Exception e) {
        return Tools.exceptionalFuture(e);
    }
}
#end_block

#method_before
private CompletableFuture<byte[]> sendAndReceive(MessageSubject subject, byte[] payload, NodeId toNodeId) {
    ControllerNode node = clusterService.getNode(toNodeId);
    checkArgument(node != null, "Unknown nodeId: %s", toNodeId);
    Endpoint nodeEp = new Endpoint(node.ip(), node.tcpPort());
    final MeteringAgent.Context epContext = endpointMeteringAgent.startTimer(NODE_PREFIX + toNodeId.toString() + ROUND_TRIP_SUFFIX);
    final MeteringAgent.Context subjectContext = subjectMeteringAgent.startTimer(subject.toString() + ROUND_TRIP_SUFFIX);
    return messagingService.sendAndReceive(nodeEp, subject.value(), payload).whenComplete((bytes, throwable) -> {
        subjectContext.stop(null);
        epContext.stop(null);
    });
}
#method_after
private CompletableFuture<byte[]> sendAndReceive(MessageSubject subject, byte[] payload, NodeId toNodeId) {
    ControllerNode node = clusterService.getNode(toNodeId);
    checkArgument(node != null, "Unknown nodeId: %s", toNodeId);
    Endpoint nodeEp = new Endpoint(node.ip(), node.tcpPort());
    final MeteringAgent.Context epContext = endpointMeteringAgent.startTimer(NODE_PREFIX + toNodeId.toString() + ROUND_TRIP_SUFFIX);
    final MeteringAgent.Context subjectContext = subjectMeteringAgent.startTimer(subject.toString() + ROUND_TRIP_SUFFIX);
    return messagingService.sendAndReceive(nodeEp, subject.value(), payload).whenComplete((bytes, throwable) -> {
        subjectContext.stop(throwable);
        epContext.stop(throwable);
    });
}
#end_block

#method_before
@Override
public CompletableFuture<byte[]> apply(Endpoint sender, byte[] bytes) {
    return handler.apply(decoder.apply(ClusterMessage.fromBytes(bytes).payload())).thenApply(m -> encode(m, encoder));
}
#method_after
@Override
public CompletableFuture<byte[]> apply(Endpoint sender, byte[] bytes) {
    return handler.apply(timeFunction(decoder, subjectMeteringAgent, DESERIALIZING).apply(ClusterMessage.fromBytes(bytes).payload())).thenApply(m -> timeFunction(encoder, subjectMeteringAgent, SERIALIZING).apply(m));
}
#end_block

#method_before
@Override
public void accept(Endpoint sender, byte[] bytes) {
    consumer.accept(decoder.apply(ClusterMessage.fromBytes(bytes).payload()));
}
#method_after
@Override
public void accept(Endpoint sender, byte[] bytes) {
    consumer.accept(timeFunction(decoder, subjectMeteringAgent, DESERIALIZING).apply(ClusterMessage.fromBytes(bytes).payload()));
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.API);
    deviceKeys = storageService.<DeviceKeyId, DeviceKey>consistentMapBuilder().withSerializer(Serializer.using(kryoBuilder.build())).withName("onos-device-keys").withRelaxedReadConsistency().build();
    deviceKeys.addListener(listener);
    deviceKeysMap = deviceKeys.asJavaMap();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    deviceKeys = storageService.<DeviceKeyId, DeviceKey>consistentMapBuilder().withSerializer(Serializer.using(KryoNamespaces.API)).withName("onos-device-keys").withRelaxedReadConsistency().build();
    deviceKeys.addListener(listener);
    deviceKeysMap = deviceKeys.asJavaMap();
    log.info("Started");
}
#end_block

#method_before
@Override
public void createOrUpdateDeviceKey(DeviceKey deviceKey) {
    // First check to see if the device key exists in the store.
    DeviceKey oldDeviceKey = getDeviceKey(deviceKey.deviceKeyId());
    if (oldDeviceKey != null) {
        // Remove the existing device key from the store.
        // By calling deleteDeviceKey, this will ensure that a DEVICE_KEY_REMOVED
        // event will be published to listeners.
        deleteDeviceKey(deviceKey.deviceKeyId());
    }
    // Now add the new device key to the store.
    deviceKeys.put(deviceKey.deviceKeyId(), deviceKey);
}
#method_after
@Override
public void createOrUpdateDeviceKey(DeviceKey deviceKey) {
    // Add the device key to the store, if the device key already exists
    // then it will be replaced with the new one.
    deviceKeys.put(deviceKey.deviceKeyId(), deviceKey);
}
#end_block

#method_before
@Override
public void deleteDeviceKey(DeviceKeyId deviceKeyId) {
    DeviceKey deviceKey = getDeviceKey(deviceKeyId);
    checkNotNull(deviceKey, "Attempting to remove a device key that does not exist in the store.");
    deviceKeys.remove(deviceKeyId);
}
#method_after
@Override
public void deleteDeviceKey(DeviceKeyId deviceKeyId) {
    // Remove the device key from the store if the device key identifier exists.
    deviceKeys.remove(deviceKeyId);
}
#end_block

#method_before
@Override
public DeviceKey getDeviceKey(DeviceKeyId deviceKeyId) {
    return (deviceKeysMap.get(deviceKeyId));
}
#method_after
@Override
public DeviceKey getDeviceKey(DeviceKeyId deviceKeyId) {
    return deviceKeysMap.get(deviceKeyId);
}
#end_block

#method_before
@Test
public void testAddSameKey() {
    DeviceKeyId deviceKeyId = DeviceKeyId.deviceKeyId(deviceKeyIdValue);
    DeviceKey deviceKey = DeviceKey.createDeviceKeyUsingCommunityName(deviceKeyId, deviceKeyLabel, deviceKeySnmpName);
    // Add the first device key via the device key manager
    manager.addKey(deviceKey);
    // Test the getDeviceKeys method
    Collection<DeviceKey> deviceKeys = manager.getDeviceKeys();
    assertEquals("There should be one device key in the set.", deviceKeys.size(), 1);
    // Now let's create a new device key with the same device key identifier as exists in the store.
    DeviceKey deviceKey2 = DeviceKey.createDeviceKeyUsingCommunityName(deviceKeyId, deviceKeyLabel2, deviceKeySnmpName);
    // Replace the new device key in the store
    manager.addKey(deviceKey2);
    // Test the getDeviceKeys method to ensure that only 1 device key exists in the store.
    deviceKeys = manager.getDeviceKeys();
    assertEquals("There should be one device key in the set.", deviceKeys.size(), 1);
    // Test the getDeviceKey method using the device key unique identifier
    deviceKey = manager.getDeviceKey(deviceKeyId);
    assertNotNull("The device key should not be null.", deviceKey);
    assertEquals("The device key label should match.", deviceKeyLabel2, deviceKey.label());
    // Validate that the following events were received in order,
    // DEVICE_KEY_ADDED, DEVICE_KEY_REMOVED, DEVICE_KEY_ADDED.
    validateEvents(DeviceKeyEvent.Type.DEVICE_KEY_ADDED, DeviceKeyEvent.Type.DEVICE_KEY_REMOVED, DeviceKeyEvent.Type.DEVICE_KEY_ADDED);
}
#method_after
@Test
public void testAddSameKey() {
    DeviceKeyId deviceKeyId = DeviceKeyId.deviceKeyId(deviceKeyIdValue);
    DeviceKey deviceKey = DeviceKey.createDeviceKeyUsingCommunityName(deviceKeyId, deviceKeyLabel, deviceKeySnmpName);
    // Add the first device key via the device key manager
    manager.addKey(deviceKey);
    // Test the getDeviceKeys method
    Collection<DeviceKey> deviceKeys = manager.getDeviceKeys();
    assertEquals("There should be one device key in the set.", deviceKeys.size(), 1);
    // Now let's create a new device key with the same device key identifier as exists in the store.
    DeviceKey deviceKey2 = DeviceKey.createDeviceKeyUsingCommunityName(deviceKeyId, deviceKeyLabel2, deviceKeySnmpName);
    // Replace the new device key in the store
    manager.addKey(deviceKey2);
    // Test the getDeviceKeys method to ensure that only 1 device key exists in the store.
    deviceKeys = manager.getDeviceKeys();
    assertEquals("There should be one device key in the set.", deviceKeys.size(), 1);
    // Test the getDeviceKey method using the device key unique identifier
    deviceKey = manager.getDeviceKey(deviceKeyId);
    assertNotNull("The device key should not be null.", deviceKey);
    assertEquals("The device key label should match.", deviceKeyLabel2, deviceKey.label());
    // Validate that the following events were received in order,
    // DEVICE_KEY_ADDED, DEVICE_KEY_REMOVED, DEVICE_KEY_ADDED.
    validateEvents(DeviceKeyEvent.Type.DEVICE_KEY_ADDED, DeviceKeyEvent.Type.DEVICE_KEY_UPDATED);
}
#end_block

#method_before
@Override
public FlowRule build() {
    checkArgument((flowId != null) ^ (appId != null), "Either an application" + " id or a cookie must be supplied, and should not supply two " + " values at the same time");
    checkNotNull(selector, "Traffic selector cannot be null");
    checkArgument(timeout != null || permanent != null, "Must either have " + "a timeout or be permanent");
    checkNotNull(deviceId, "Must refer to a device");
    checkNotNull(priority, "Priority cannot be null");
    checkArgument(priority >= MIN_PRIORITY, "Priority cannot be less than " + MIN_PRIORITY);
    // the flow ID directly
    if (appId != null) {
        flowId = computeFlowId(appId);
    }
    return new DefaultFlowRule(deviceId, selector, treatment, priority, flowId, permanent, timeout, tableId);
}
#method_after
@Override
public FlowRule build() {
    checkArgument((flowId != null) ^ (appId != null), "Either an application" + " id or a cookie must be supplied");
    checkNotNull(selector, "Traffic selector cannot be null");
    checkArgument(timeout != null || permanent != null, "Must either have " + "a timeout or be permanent");
    checkNotNull(deviceId, "Must refer to a device");
    checkNotNull(priority, "Priority cannot be null");
    checkArgument(priority >= MIN_PRIORITY, "Priority cannot be less than " + MIN_PRIORITY);
    // the flow ID directly
    if (appId != null) {
        flowId = computeFlowId(appId);
    }
    return new DefaultFlowRule(deviceId, selector, treatment, priority, flowId, permanent, timeout, tableId);
}
#end_block

#method_before
@Override
public void receivedRoleReply(DeviceId deviceId, MastershipRole requested, MastershipRole response) {
    // Several things can happen here:
    // 1. request and response match
    // 2. request and response don't match
    // 3. MastershipRole and requested match (and 1 or 2 are true)
    // 4. MastershipRole and requested don't match (and 1 or 2 are true)
    // 
    // 2, 4, and 3 with case 2 are failure modes.
    // FIXME: implement response to this notification
    log.debug("got reply to a role request for {}: asked for {}, and got {}", deviceId, requested, response);
    if (requested == null && response == null) {
        // something was off with DeviceProvider, maybe check channel too?
        log.warn("Failed to assert role [{}] onto Device {}", requested, deviceId);
        mastershipService.relinquishMastership(deviceId);
        return;
    }
    if (Objects.equals(requested, response)) {
        if (Objects.equals(requested, mastershipService.getLocalRole(deviceId))) {
            return;
        } else {
            log.warn("Role mismatch on {}. set to {}, but store demands {}", deviceId, response, mastershipService.getLocalRole(deviceId));
            // roleManager got the device to comply, but doesn't agree with
            // the store; use the store's view, then try to reassert.
            backgroundService.submit(() -> reassertRole(deviceId, mastershipService.getLocalRole(deviceId)));
            return;
        }
    } else {
        // we didn't get back what we asked for. Reelect someone else.
        log.warn("Failed to assert role [{}] onto Device {}", response, deviceId);
        if (response == MastershipRole.MASTER) {
            mastershipService.relinquishMastership(deviceId);
        // TODO: Shouldn't we be triggering event?
        // final Device device = getDevice(deviceId);
        // post(new DeviceEvent(DEVICE_MASTERSHIP_CHANGED, device));
        }
    }
}
#method_after
@Override
public void receivedRoleReply(DeviceId deviceId, MastershipRole requested, MastershipRole response) {
    // Several things can happen here:
    // 1. request and response match
    // 2. request and response don't match
    // 3. MastershipRole and requested match (and 1 or 2 are true)
    // 4. MastershipRole and requested don't match (and 1 or 2 are true)
    // 
    // 2, 4, and 3 with case 2 are failure modes.
    // FIXME: implement response to this notification
    log.debug("got reply to a role request for {}: asked for {}, and got {}", deviceId, requested, response);
    if (requested == null && response == null) {
        // something was off with DeviceProvider, maybe check channel too?
        log.warn("Failed to assert role onto Device {}", deviceId);
        mastershipService.relinquishMastership(deviceId);
        return;
    }
    if (Objects.equals(requested, response)) {
        if (Objects.equals(requested, mastershipService.getLocalRole(deviceId))) {
            return;
        } else {
            log.warn("Role mismatch on {}. set to {}, but store demands {}", deviceId, response, mastershipService.getLocalRole(deviceId));
            // roleManager got the device to comply, but doesn't agree with
            // the store; use the store's view, then try to reassert.
            backgroundService.submit(() -> reassertRole(deviceId, mastershipService.getLocalRole(deviceId)));
            return;
        }
    } else {
        // we didn't get back what we asked for. Reelect someone else.
        log.warn("Failed to assert role [{}] onto Device {}", response, deviceId);
        if (response == MastershipRole.MASTER) {
            mastershipService.relinquishMastership(deviceId);
        // TODO: Shouldn't we be triggering event?
        // final Device device = getDevice(deviceId);
        // post(new DeviceEvent(DEVICE_MASTERSHIP_CHANGED, device));
        }
    }
}
#end_block

#method_before
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId resource) {
    checkNotNull(resource);
    return store.getResourceAllocations(resource);
}
#method_after
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId id) {
    checkNotNull(id);
    return store.getResourceAllocations(id);
}
#end_block

#method_before
// Computational complexity: O(1) if the resource is discrete type.
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId resource) {
    checkNotNull(resource);
    checkArgument(resource instanceof DiscreteResourceId || resource instanceof ContinuousResourceId);
    if (resource instanceof DiscreteResourceId) {
        return getResourceAllocations((DiscreteResourceId) resource);
    } else {
        return getResourceAllocations((ContinuousResourceId) resource);
    }
}
#method_after
// Computational complexity: O(1) if the resource is discrete type.
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId id) {
    checkNotNull(id);
    checkArgument(id instanceof DiscreteResourceId || id instanceof ContinuousResourceId);
    if (id instanceof DiscreteResourceId) {
        return getResourceAllocations((DiscreteResourceId) id);
    } else {
        return getResourceAllocations((ContinuousResourceId) id);
    }
}
#end_block

#method_before
private List<FlowRule> manageVlanEncap(PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // List of flow rules to be installed
    List<FlowRule> rules = new LinkedList<>();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    // Tag the traffic with the new VLAN
    TrafficTreatment treat = DefaultTrafficTreatment.builder().setVlanId(vlanId).build();
    rules.add(createFlowRule(intent.selector(), treat, srcLink.dst(), link.src(), intent.priority(), true));
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            prevVlanId = egressVlanId;
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            rules.add(createFlowRule(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true));
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            // TODO: think to other cases for egress packet restoration
            Optional<VlanIdCriterion> vlanCriteria = intent.selector().criteria().stream().filter(criteria -> criteria.type() == Criterion.Type.VLAN_VID).map(criteria -> (VlanIdCriterion) criteria).findAny();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            if (vlanCriteria.isPresent()) {
                egressTreat.setVlanId(vlanCriteria.get().vlanId());
            } else {
                egressTreat.popVlan();
            }
            rules.add(createFlowRule(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true));
        }
    }
    return rules;
}
#method_after
private List<FlowRule> manageVlanEncap(PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // List of flow rules to be installed
    List<FlowRule> rules = new LinkedList<>();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    Optional<VlanIdCriterion> vlanCriterion = intent.selector().criteria().stream().filter(criterion -> criterion.type() == Criterion.Type.VLAN_VID).map(criterion -> (VlanIdCriterion) criterion).findAny();
    // Push VLAN if selector does not include VLAN
    TrafficTreatment.Builder treatBuilder = DefaultTrafficTreatment.builder();
    if (!vlanCriterion.isPresent()) {
        treatBuilder.pushVlan();
    }
    // Tag the traffic with the new encapsulation VLAN
    treatBuilder.setVlanId(vlanId);
    rules.add(createFlowRule(intent.selector(), treatBuilder.build(), srcLink.dst(), link.src(), intent.priority(), true));
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            prevVlanId = egressVlanId;
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            rules.add(createFlowRule(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true));
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            if (vlanCriterion.isPresent()) {
                egressTreat.setVlanId(vlanCriterion.get().vlanId());
            } else {
                egressTreat.popVlan();
            }
            rules.add(createFlowRule(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true));
        }
    }
    return rules;
}
#end_block

#method_before
default List<ResourceAllocation> allocate(ResourceConsumer consumer, Resource... resources) {
    checkNotNull(consumer);
    checkNotNull(resources);
    return allocate(consumer, Arrays.asList(resources));
}
#method_after
default Optional<ResourceAllocation> allocate(ResourceConsumer consumer, Resource resource) {
    checkNotNull(consumer);
    checkNotNull(resource);
    List<ResourceAllocation> allocations = allocate(consumer, ImmutableList.of(resource));
    if (allocations.isEmpty()) {
        return Optional.empty();
    }
    assert allocations.size() == 1;
    ResourceAllocation allocation = allocations.get(0);
    assert allocation.resource().equals(resource);
    // cast is ensured by the assertions above
    return Optional.of(allocation);
}
#end_block

#method_before
default boolean release(ResourceAllocation... allocations) {
    checkNotNull(allocations);
    return release(ImmutableList.copyOf(allocations));
}
#method_after
default boolean release(ResourceAllocation allocation) {
    checkNotNull(allocation);
    return release(ImmutableList.of(allocation));
}
#end_block

#method_before
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId resource) {
    if (resource instanceof ContinuousResourceId) {
        return ImmutableList.of();
    }
    DiscreteResource discrete = Resources.discrete((DiscreteResourceId) resource).resource();
    return Optional.ofNullable(assignment.get(discrete)).map(x -> ImmutableList.of(new ResourceAllocation(discrete, x))).orElse(ImmutableList.of());
}
#method_after
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId id) {
    if (id instanceof ContinuousResourceId) {
        return ImmutableList.of();
    }
    DiscreteResource discrete = Resources.discrete((DiscreteResourceId) id).resource();
    return Optional.ofNullable(assignment.get(discrete)).map(x -> ImmutableList.of(new ResourceAllocation(discrete, x))).orElse(ImmutableList.of());
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) {
    int iLenStartIndex = cb.writerIndex();
    // int valueLen;
    cb.writeByte(FLOW_SPEC_TYPE);
    for (BgpFsOperatorValue fsOperVal : operatorValue) {
        cb.writeByte(fsOperVal.option());
        cb.writeBytes(fsOperVal.value());
    }
    return cb.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer cb) {
    int iLenStartIndex = cb.writerIndex();
    cb.writeByte(FLOW_SPEC_TYPE);
    for (BgpFsOperatorValue fsOperVal : operatorValue) {
        cb.writeByte(fsOperVal.option());
        cb.writeBytes(fsOperVal.value());
    }
    return cb.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
private List<FlowRule> manageVlanEncap(PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // List of flow rules to be installed
    List<FlowRule> rules = new LinkedList<>();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    Optional<VlanIdCriterion> vlanCriteria = intent.selector().criteria().stream().filter(criteria -> criteria.type() == Criterion.Type.VLAN_VID).map(criteria -> (VlanIdCriterion) criteria).findAny();
    // Push VLAN if selector does not include VLAN
    TrafficTreatment.Builder treatBuilder = DefaultTrafficTreatment.builder();
    if (!vlanCriteria.isPresent()) {
        treatBuilder.pushVlan();
    }
    // Tag the traffic with the new encapsulation VLAN
    treatBuilder.setVlanId(vlanId);
    rules.add(createFlowRule(intent.selector(), treatBuilder.build(), srcLink.dst(), link.src(), intent.priority(), true));
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            prevVlanId = egressVlanId;
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            rules.add(createFlowRule(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true));
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            // TODO: think to other cases for egress packet restoration
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            if (vlanCriteria.isPresent()) {
                egressTreat.setVlanId(vlanCriteria.get().vlanId());
            } else {
                egressTreat.popVlan();
            }
            rules.add(createFlowRule(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true));
        }
    }
    return rules;
}
#method_after
private List<FlowRule> manageVlanEncap(PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // List of flow rules to be installed
    List<FlowRule> rules = new LinkedList<>();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    Optional<VlanIdCriterion> vlanCriterion = intent.selector().criteria().stream().filter(criterion -> criterion.type() == Criterion.Type.VLAN_VID).map(criterion -> (VlanIdCriterion) criterion).findAny();
    // Push VLAN if selector does not include VLAN
    TrafficTreatment.Builder treatBuilder = DefaultTrafficTreatment.builder();
    if (!vlanCriterion.isPresent()) {
        treatBuilder.pushVlan();
    }
    // Tag the traffic with the new encapsulation VLAN
    treatBuilder.setVlanId(vlanId);
    rules.add(createFlowRule(intent.selector(), treatBuilder.build(), srcLink.dst(), link.src(), intent.priority(), true));
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            prevVlanId = egressVlanId;
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            rules.add(createFlowRule(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true));
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            if (vlanCriterion.isPresent()) {
                egressTreat.setVlanId(vlanCriterion.get().vlanId());
            } else {
                egressTreat.popVlan();
            }
            rules.add(createFlowRule(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true));
        }
    }
    return rules;
}
#end_block

#method_before
private Map<LinkKey, VlanId> assignVlanId(PathIntent intent) {
    Set<LinkKey> linkRequest = Sets.newHashSetWithExpectedSize(intent.path().links().size() - 2);
    for (int i = 1; i <= intent.path().links().size() - 2; i++) {
        LinkKey link = linkKey(intent.path().links().get(i));
        linkRequest.add(link);
        // add the inverse link. I want that the VLANID is reserved both for
        // the direct and inverse link
        linkRequest.add(linkKey(link.dst(), link.src()));
    }
    Map<LinkKey, VlanId> vlanIds = findVlanIds(linkRequest);
    if (vlanIds.isEmpty()) {
        log.warn("No VLAN IDs available");
        return Collections.emptyMap();
    }
    // same VLANID is used for both directions
    Set<Resource> resources = vlanIds.entrySet().stream().flatMap(x -> Stream.of(Resource.discrete(x.getKey().src().deviceId(), x.getKey().src().port(), x.getValue()), Resource.discrete(x.getKey().dst().deviceId(), x.getKey().dst().port(), x.getValue()))).collect(Collectors.toSet());
    List<org.onosproject.net.newresource.ResourceAllocation> allocations = resourceService.allocate(intent.id(), ImmutableList.copyOf(resources));
    if (allocations.isEmpty()) {
        Collections.emptyMap();
    }
    return vlanIds;
}
#method_after
private Map<LinkKey, VlanId> assignVlanId(PathIntent intent) {
    Set<LinkKey> linkRequest = Sets.newHashSetWithExpectedSize(intent.path().links().size() - 2);
    for (int i = 1; i <= intent.path().links().size() - 2; i++) {
        LinkKey link = linkKey(intent.path().links().get(i));
        linkRequest.add(link);
        // add the inverse link. I want that the VLANID is reserved both for
        // the direct and inverse link
        linkRequest.add(linkKey(link.dst(), link.src()));
    }
    Map<LinkKey, VlanId> vlanIds = findVlanIds(linkRequest);
    if (vlanIds.isEmpty()) {
        log.warn("No VLAN IDs available");
        return Collections.emptyMap();
    }
    // same VLANID is used for both directions
    Set<Resource> resources = vlanIds.entrySet().stream().flatMap(x -> Stream.of(Resources.discrete(x.getKey().src().deviceId(), x.getKey().src().port(), x.getValue()).resource(), Resources.discrete(x.getKey().dst().deviceId(), x.getKey().dst().port(), x.getValue()).resource())).collect(Collectors.toSet());
    List<org.onosproject.net.newresource.ResourceAllocation> allocations = resourceService.allocate(intent.id(), ImmutableList.copyOf(resources));
    if (allocations.isEmpty()) {
        Collections.emptyMap();
    }
    return vlanIds;
}
#end_block

#method_before
private Set<VlanId> findVlanId(ConnectPoint cp) {
    return resourceService.getAvailableResources(Resource.discrete(cp.deviceId(), cp.port())).stream().filter(x -> x.last() instanceof VlanId).map(x -> (VlanId) x.last()).collect(Collectors.toSet());
}
#method_after
private Set<VlanId> findVlanId(ConnectPoint cp) {
    return resourceService.getAvailableResources(Resources.discrete(cp.deviceId(), cp.port()).resource()).stream().filter(x -> x.last() instanceof VlanId).map(x -> (VlanId) x.last()).collect(Collectors.toSet());
}
#end_block

#method_before
private boolean isPacketLayer(Device.Type type) {
    return type == Device.Type.SWITCH || type == Device.Type.ROUTER;
}
#method_after
private boolean isPacketLayer(Device.Type type) {
    return type == Device.Type.SWITCH || type == Device.Type.ROUTER || type == Device.Type.VIRTUAL;
}
#end_block

#method_before
private Map<String, Interface> setUpInterfaces() {
    Map<String, Interface> configuredInterfaces = new HashMap<>();
    InterfaceIpAddress ia1 = new InterfaceIpAddress(IpAddress.valueOf(SPEAKER1_IP), IpPrefix.valueOf(SPEAKER1_IP + PREFIX24));
    Interface intfSw1Eth1 = new Interface(INTERFACE_SW1_ETH1, SW1_ETH1, Collections.singleton(ia1), MacAddress.valueOf(MAC1), VlanId.NONE);
    configuredInterfaces.put(INTERFACE_SW1_ETH1, intfSw1Eth1);
    InterfaceIpAddress ia2 = new InterfaceIpAddress(IpAddress.valueOf(SPEAKER1_IP), IpPrefix.valueOf(SPEAKER1_IP + PREFIX24));
    Interface intfSw2Eth1 = new Interface(INTERFACE_SW2_ETH1, SW2_ETH1, Collections.singleton(ia2), MacAddress.valueOf(MAC1), VlanId.NONE);
    configuredInterfaces.put(INTERFACE_SW1_ETH1, intfSw1Eth1);
    InterfaceIpAddress ia3 = new InterfaceIpAddress(IpAddress.valueOf(NON_MATCHING_IP), IpPrefix.valueOf(NON_MATCHING_IP + PREFIX24));
    Interface intfSw3Eth1 = new Interface(INTERFACE_SW3_ETH1, SW3_ETH1, Collections.singleton(ia3), MacAddress.valueOf(MAC1), VlanId.NONE);
    configuredInterfaces.put(INTERFACE_SW3_ETH1, intfSw3Eth1);
    // Set up the related expectations
    expect(interfaceService.getInterfacesByIp(IpAddress.valueOf(SPEAKER1_IP))).andReturn(Collections.singleton(intfSw1Eth1)).anyTimes();
    // Always return the first matching even if not associated interface
    expect(interfaceService.getMatchingInterface(IpAddress.valueOf(PEER_IP))).andReturn(intfSw1Eth1).anyTimes();
    expect(interfaceService.getMatchingInterface(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(intfSw1Eth1).anyTimes();
    expect(interfaceService.getMatchingInterface(IpAddress.valueOf(NEW_PEER2_IP))).andReturn(null).anyTimes();
    expect(interfaceService.getInterfacesByPort(SW1_ETH1)).andReturn(Collections.singleton(intfSw1Eth1)).anyTimes();
    expect(interfaceService.getInterfacesByPort(SW2_ETH1)).andReturn(Collections.singleton(intfSw2Eth1)).anyTimes();
    expect(interfaceService.getInterfacesByPort(SW3_ETH1)).andReturn(Collections.singleton(intfSw3Eth1)).anyTimes();
    expect(interfaceService.getInterfacesByPort(new ConnectPoint(DeviceId.deviceId(dpidToUri("00:00:00:00:00:00:01:00")), PortNumber.portNumber(1)))).andReturn(null).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(Sets.newHashSet(configuredInterfaces.values())).anyTimes();
    replay(interfaceService);
    return configuredInterfaces;
}
#method_after
private Map<String, Interface> setUpInterfaces() {
    Map<String, Interface> configuredInterfaces = new HashMap<>();
    InterfaceIpAddress ia1 = new InterfaceIpAddress(IpAddress.valueOf(SPEAKER1_IP), IpPrefix.valueOf(SPEAKER1_IP + PREFIX24));
    intfSw1Eth1 = new Interface(INTERFACE_SW1_ETH1, SW1_ETH1, Collections.singleton(ia1), MacAddress.valueOf(MAC1), VlanId.NONE);
    configuredInterfaces.put(INTERFACE_SW1_ETH1, intfSw1Eth1);
    InterfaceIpAddress ia2 = new InterfaceIpAddress(IpAddress.valueOf(SPEAKER1_IP), IpPrefix.valueOf(SPEAKER1_IP + PREFIX24));
    Interface intfSw2Eth1 = new Interface(INTERFACE_SW2_ETH1, SW2_ETH1, Collections.singleton(ia2), MacAddress.valueOf(MAC1), VlanId.NONE);
    configuredInterfaces.put(INTERFACE_SW1_ETH1, intfSw1Eth1);
    InterfaceIpAddress ia3 = new InterfaceIpAddress(IpAddress.valueOf(NON_MATCHING_IP), IpPrefix.valueOf(NON_MATCHING_IP + PREFIX24));
    Interface intfSw3Eth1 = new Interface(INTERFACE_SW3_ETH1, SW3_ETH1, Collections.singleton(ia3), MacAddress.valueOf(MAC1), VlanId.NONE);
    configuredInterfaces.put(INTERFACE_SW3_ETH1, intfSw3Eth1);
    // Set up the related expectations
    expect(interfaceService.getInterfacesByIp(IpAddress.valueOf(SPEAKER1_IP))).andReturn(Collections.singleton(intfSw1Eth1)).anyTimes();
    // Always return the first matching even if not associated interface
    expect(interfaceService.getMatchingInterface(IpAddress.valueOf(PEER_IP))).andReturn(intfSw1Eth1).anyTimes();
    expect(interfaceService.getMatchingInterface(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(intfSw1Eth1).anyTimes();
    expect(interfaceService.getMatchingInterface(IpAddress.valueOf(NEW_PEER2_IP))).andReturn(null).anyTimes();
    expect(interfaceService.getInterfacesByPort(SW1_ETH1)).andReturn(Collections.singleton(intfSw1Eth1)).anyTimes();
    expect(interfaceService.getInterfacesByPort(SW2_ETH1)).andReturn(Collections.singleton(intfSw2Eth1)).anyTimes();
    expect(interfaceService.getInterfacesByPort(SW3_ETH1)).andReturn(Collections.singleton(intfSw3Eth1)).anyTimes();
    expect(interfaceService.getInterfacesByPort(new ConnectPoint(DeviceId.deviceId(dpidToUri("00:00:00:00:00:00:01:00")), PortNumber.portNumber(1)))).andReturn(null).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(Sets.newHashSet(configuredInterfaces.values())).anyTimes();
    replay(interfaceService);
    return configuredInterfaces;
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
// TODO: Implement the MOJO Plugin
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
// TODO: implement the MOJO plugin
}
#end_block

#method_before
public Collection<String> securityGroups() {
    return this.securityGroups;
}
#method_after
public Collection<String> securityGroups() {
    return Collections.unmodifiableCollection(this.securityGroups);
}
#end_block

#method_before
public Collection<OpenstackSecurityGroupRule> rules() {
    return rules;
}
#method_after
public Collection<OpenstackSecurityGroupRule> rules() {
    return Collections.unmodifiableCollection(rules);
}
#end_block

#method_before
@Override
public OpenstackPort decode(ObjectNode json, CodecContext context) {
    HashMap<String, Ip4Address> fixedIpMap = new HashMap<>();
    JsonNode portInfo = json.get(PORT);
    if (portInfo == null) {
        portInfo = json;
    }
    String status = portInfo.path(STATUS).asText();
    String name = portInfo.path(NAME).asText();
    boolean adminStateUp = portInfo.path(ADMIN_STATUS).asBoolean();
    String networkId = portInfo.path(NETWORK_ID).asText();
    String tenantId = portInfo.path(TENANT_ID).asText();
    String deviceOwner = portInfo.path(DEVICE_OWNER).asText();
    String macStr = portInfo.path(MAC_ADDRESS).asText();
    ArrayNode fixedIpList = (ArrayNode) portInfo.path(FIXED_IPS);
    for (JsonNode fixedIpInfo : fixedIpList) {
        String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
        String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
        if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
            Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
            fixedIpMap.put(subnetId, ipAddress);
        }
    }
    String id = portInfo.path(ID).asText();
    ArrayNode securityGroupList = (ArrayNode) portInfo.path(SECURITY_GROUPS);
    Collection<String> securityGroupIdList = Lists.newArrayList();
    for (JsonNode securityGroup : securityGroupList) {
        String securityGroupId = securityGroup.asText();
        securityGroupIdList.add(securityGroupId);
    }
    String deviceId = portInfo.path(DEVICE_ID).asText();
    OpenstackPort.Builder openstackPortBuilder = OpenstackPort.builder();
    OpenstackPort.PortStatus portStatus = status.equals("N/A") ? OpenstackPort.PortStatus.NA : OpenstackPort.PortStatus.valueOf(status);
    openstackPortBuilder.portStatus(portStatus).name(name).adminState(adminStateUp).netwrokId(networkId).tenantId(tenantId).deviceOwner(deviceOwner).macAddress(MacAddress.valueOf(macStr)).fixedIps(fixedIpMap).id(id).deviceId(deviceId).securityGroup(securityGroupIdList);
    OpenstackPort openstackPort = openstackPortBuilder.build();
    return openstackPort;
}
#method_after
@Override
public OpenstackPort decode(ObjectNode json, CodecContext context) {
    HashMap<String, Ip4Address> fixedIpMap = new HashMap<>();
    JsonNode portInfo = json.get(PORT);
    if (portInfo == null) {
        portInfo = json;
    }
    String status = portInfo.path(STATUS).asText();
    String name = portInfo.path(NAME).asText();
    boolean adminStateUp = portInfo.path(ADMIN_STATUS).asBoolean();
    String networkId = portInfo.path(NETWORK_ID).asText();
    String tenantId = portInfo.path(TENANT_ID).asText();
    String deviceOwner = portInfo.path(DEVICE_OWNER).asText();
    String macStr = portInfo.path(MAC_ADDRESS).asText();
    ArrayNode fixedIpList = (ArrayNode) portInfo.path(FIXED_IPS);
    for (JsonNode fixedIpInfo : fixedIpList) {
        String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
        String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
        if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
            Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
            fixedIpMap.put(subnetId, ipAddress);
        }
    }
    String id = portInfo.path(ID).asText();
    ArrayNode securityGroupList = (ArrayNode) portInfo.path(SECURITY_GROUPS);
    Collection<String> securityGroupIdList = Lists.newArrayList();
    securityGroupList.forEach(securityGroup -> securityGroupIdList.add(securityGroup.asText()));
    String deviceId = portInfo.path(DEVICE_ID).asText();
    OpenstackPort.Builder openstackPortBuilder = OpenstackPort.builder();
    OpenstackPort.PortStatus portStatus = status.equals("N/A") ? OpenstackPort.PortStatus.NA : OpenstackPort.PortStatus.valueOf(status);
    openstackPortBuilder.portStatus(portStatus).name(name).adminState(adminStateUp).netwrokId(networkId).tenantId(tenantId).deviceOwner(deviceOwner).macAddress(MacAddress.valueOf(macStr)).fixedIps(fixedIpMap).id(id).deviceId(deviceId).securityGroup(securityGroupIdList);
    OpenstackPort openstackPort = openstackPortBuilder.build();
    return openstackPort;
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.fixedIps().isEmpty()) {
        registerDhcpInfo(openstackPort);
    }
    // SecurityGroup test
    if (!openstackPort.securityGroups().isEmpty()) {
        openstackPort.securityGroups().forEach(sgId -> {
            OpenstackSecurityGroup sg = restHandler.getSecurityGroup(sgId);
            log.debug("SecurityGroup : {}", sg.toString());
        });
    }
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.fixedIps().isEmpty() && !openstackPort.deviceOwner().equals(DEVICE_OWNER_GATEWAY)) {
        registerDhcpInfo(openstackPort);
    }
    if (!openstackPort.securityGroups().isEmpty()) {
        openstackPort.securityGroups().forEach(sgId -> {
            OpenstackSecurityGroup sg = restHandler.getSecurityGroup(sgId);
            log.debug("SecurityGroup : {}", sg.toString());
        });
    }
}
#end_block

#method_before
@Override
public void deletePort(String uuid) {
}
#method_after
@Override
public void deletePort(String uuid) {
    // When VMs are remvoed, the flow rules for the VMs are removed using ONOS port update event.
    // But, when router is removed, no ONOS port event occurs and we need to use Neutron port event.
    // Here we should not touch any rules for VMs.
    log.debug("port {} was removed", uuid);
    String routerPortName = PORTNAME_PREFIX_ROUTER + uuid.substring(0, 11);
    OpenstackPortInfo routerPortInfo = openstackPortInfoMap.get(routerPortName);
    if (routerPortInfo != null) {
        dhcpService.removeStaticMapping(routerPortInfo.mac());
        if (!doNotPushFlows) {
            deviceService.getPorts(routerPortInfo.deviceId()).forEach(port -> {
                String pName = port.annotations().value("portName");
                if (pName.equals(routerPortName)) {
                    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
                    rulePopulator.removeSwitchingRules(doNotPushFlows, port, openstackPortInfoMap);
                    openstackPortInfoMap.remove(routerPortName);
                    return;
                }
            });
        }
    }
}
#end_block

#method_before
private void processPortUpdated(Device device, Port port) {
    if (!port.annotations().value(PORTNAME).equals(PORTNAME_PREFIX_TUNNEL) && !doNotPushFlows) {
        if (port.isEnabled() || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)) {
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.populateSwitchingRules(device, port);
            updatePortMap(device.id(), port, restHandler.getNetworks(), rulePopulator.openstackPort(port));
        // In case portupdate event is driven by vm shutoff from openstack
        } else if (!port.isEnabled() && openstackPortInfoMap.containsKey(port.annotations().value(PORTNAME))) {
            log.debug("Flowrules according to the port {} were removed", port.number().toString());
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            openstackPortInfoMap.get(port.annotations().value(PORTNAME));
            rulePopulator.removeSwitchingRules(port, openstackPortInfoMap);
            openstackPortInfoMap.remove(port.annotations().value(PORTNAME));
        }
    }
}
#method_after
private void processPortUpdated(Device device, Port port) {
    if (!port.annotations().value(PORTNAME).equals(PORTNAME_PREFIX_TUNNEL) && !doNotPushFlows) {
        if (port.isEnabled() || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)) {
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.populateSwitchingRules(doNotPushFlows, device, port);
            updatePortMap(device.id(), port, restHandler.getNetworks(), rulePopulator.openstackPort(port));
        // In case portupdate event is driven by vm shutoff from openstack
        } else if (!port.isEnabled() && openstackPortInfoMap.containsKey(port.annotations().value(PORTNAME))) {
            log.debug("Flowrules according to the port {} were removed", port.number().toString());
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.removeSwitchingRules(doNotPushFlows, port, openstackPortInfoMap);
            dhcpService.removeStaticMapping(openstackPortInfoMap.get(port.annotations().value(PORTNAME)).mac());
            openstackPortInfoMap.remove(port.annotations().value(PORTNAME));
        }
    }
}
#end_block

#method_before
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    Collection<OpenstackNetwork> networks = restHandler.getNetworks();
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_VM) || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null) {
                if (!doNotPushFlows) {
                    rulePopulator.populateSwitchingRules(device, vmPort);
                    updatePortMap(device.id(), vmPort, networks, osPort);
                }
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#method_after
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    Collection<OpenstackNetwork> networks = restHandler.getNetworks();
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_VM) || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null && !osPort.deviceOwner().equals(DEVICE_OWNER_GATEWAY)) {
                if (!doNotPushFlows) {
                    rulePopulator.populateSwitchingRules(doNotPushFlows, device, vmPort);
                    updatePortMap(device.id(), vmPort, networks, osPort);
                }
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#end_block

#method_before
private void updatePortMap(DeviceId deviceId, Port port, Collection<OpenstackNetwork> networks, OpenstackPort openstackPort) {
    long vni = Long.parseLong(networks.stream().filter(n -> n.id().equals(openstackPort.networkId())).findAny().orElse(null).segmentId());
    OpenstackPortInfo.Builder portBuilder = OpenstackPortInfo.builder().setDeviceId(deviceId).setHostIp((Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null)).setVni(vni);
    openstackPortInfoMap.putIfAbsent(port.annotations().value(PORTNAME), portBuilder.build());
}
#method_after
private void updatePortMap(DeviceId deviceId, Port port, Collection<OpenstackNetwork> networks, OpenstackPort openstackPort) {
    long vni = Long.parseLong(networks.stream().filter(n -> n.id().equals(openstackPort.networkId())).findAny().orElse(null).segmentId());
    OpenstackPortInfo.Builder portBuilder = OpenstackPortInfo.builder().setDeviceId(deviceId).setHostIp((Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null)).setHostMac(openstackPort.macAddress()).setVni(vni);
    openstackPortInfoMap.putIfAbsent(port.annotations().value(PORTNAME), portBuilder.build());
}
#end_block

#method_before
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_UPDATED:
                Port port = (Port) deviceEvent.subject();
                if (port.isEnabled()) {
                    processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                }
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public Collection<OpenstackNetwork> getNetworks() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "networks");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    log.debug("networks response:" + response);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackNetwork> openstackNetworks = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode networkList = (ArrayNode) node.path("networks");
        OpenstackNetworkCodec networkCodec = new OpenstackNetworkCodec();
        networkList.forEach(n -> openstackNetworks.add(networkCodec.decode((ObjectNode) n, null)));
    } catch (IOException e) {
        log.warn("getNetworks()", e);
    }
    openstackNetworks.removeAll(Collections.singleton(null));
    openstackNetworks.forEach(n -> log.debug("network ID: {}", n.id()));
    return openstackNetworks;
}
#method_after
public Collection<OpenstackNetwork> getNetworks() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_NETWORKS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    log.debug("networks response:" + response);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackNetwork> openstackNetworks = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode networkList = (ArrayNode) node.path(PATH_NETWORKS);
        OpenstackNetworkCodec networkCodec = new OpenstackNetworkCodec();
        networkList.forEach(n -> openstackNetworks.add(networkCodec.decode((ObjectNode) n, null)));
    } catch (IOException e) {
        log.warn("getNetworks()", e);
    }
    openstackNetworks.removeAll(Collections.singleton(null));
    openstackNetworks.forEach(n -> log.debug("network ID: {}", n.id()));
    return openstackNetworks;
}
#end_block

#method_before
public Collection<OpenstackPort> getPorts() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "ports");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackPort> openstackPorts = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode portList = (ArrayNode) node.path("ports");
        OpenstackPortCodec portCodec = new OpenstackPortCodec();
        portList.forEach(p -> openstackPorts.add(portCodec.decode((ObjectNode) p, null)));
    } catch (IOException e) {
        log.warn("getPorts()", e);
    }
    log.debug("port response:" + response);
    openstackPorts.forEach(n -> log.debug("port ID: {}", n.id()));
    return openstackPorts;
}
#method_after
public Collection<OpenstackPort> getPorts() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_PORTS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackPort> openstackPorts = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode portList = (ArrayNode) node.path(PATH_PORTS);
        OpenstackPortCodec portCodec = new OpenstackPortCodec();
        portList.forEach(p -> openstackPorts.add(portCodec.decode((ObjectNode) p, null)));
    } catch (IOException e) {
        log.warn("getPorts()", e);
    }
    log.debug("port response:" + response);
    openstackPorts.forEach(n -> log.debug("port ID: {}", n.id()));
    return openstackPorts;
}
#end_block

#method_before
public Collection<OpenstackSubnet> getSubnets() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "subnets");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackSubnet> subnets = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode subnetList = (ArrayNode) node.path("subnets");
        OpenstackSubnetCodec subnetCodec = new OpenstackSubnetCodec();
        subnetList.forEach(s -> subnets.add(subnetCodec.decode((ObjectNode) s, null)));
    } catch (IOException e) {
        log.warn("getSubnets()", e);
    }
    log.debug("subnets response:" + response);
    subnets.forEach(s -> log.debug("subnet ID: {}", s.id()));
    return subnets;
}
#method_after
public Collection<OpenstackSubnet> getSubnets() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_SUBNETS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackSubnet> subnets = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode subnetList = (ArrayNode) node.path(PATH_SUBNETS);
        OpenstackSubnetCodec subnetCodec = new OpenstackSubnetCodec();
        subnetList.forEach(s -> subnets.add(subnetCodec.decode((ObjectNode) s, null)));
    } catch (IOException e) {
        log.warn("getSubnets()", e);
    }
    log.debug("subnets response:" + response);
    subnets.forEach(s -> log.debug("subnet ID: {}", s.id()));
    return subnets;
}
#end_block

#method_before
public OpenstackSecurityGroup getSecurityGroup(String id) {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "security-groups/" + id);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    OpenstackSecurityGroup securityGroup = null;
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        OpenstackSecurityGroupCodec sgCodec = new OpenstackSecurityGroupCodec();
        securityGroup = sgCodec.decode(node, null);
    } catch (IOException e) {
        log.warn("getSecurityGroup()", e);
    }
    return securityGroup;
}
#method_after
public OpenstackSecurityGroup getSecurityGroup(String id) {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_SECURITY_GROUPS + "/" + id);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    OpenstackSecurityGroup securityGroup = null;
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        OpenstackSecurityGroupCodec sgCodec = new OpenstackSecurityGroupCodec();
        securityGroup = sgCodec.decode(node, null);
    } catch (IOException e) {
        log.warn("getSecurityGroup()", e);
    }
    return securityGroup;
}
#end_block

#method_before
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        WebResource.Builder builder = getClientBuilder(keystoneUrl + "tokens");
        String response = builder.accept(MediaType.APPLICATION_JSON).post(String.class, request);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path("access").path("token").path("id").asText();
        } catch (IOException e) {
            log.warn("getToken()", e);
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#method_after
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        WebResource.Builder builder = getClientBuilder(keystoneUrl + URI_TOKENS);
        String response = builder.accept(MediaType.APPLICATION_JSON).post(String.class, request);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path(PATH_ACCESS).path(PATH_TOKEN).path(PATH_ID).asText();
        } catch (IOException e) {
            log.warn("getToken()", e);
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#end_block

#method_before
@Override
public OpenstackSecurityGroup decode(ObjectNode json, CodecContext context) {
    JsonNode securityGroupNode = json.get(SECURITY_GROUP);
    String description = securityGroupNode.path(DESCRIPTION).asText();
    String id = securityGroupNode.path(ID).asText();
    String name = securityGroupNode.path(NAME).asText();
    ArrayNode ruleInfoList = (ArrayNode) securityGroupNode.path(SECURITY_GROUP_RULES);
    Collection<OpenstackSecurityGroupRule> rules = Lists.newArrayList();
    for (JsonNode ruleInfo : ruleInfoList) {
        String direction = ruleInfo.path(DIRECTION).asText();
        String ethertype = ruleInfo.path(EHTERTYPE).asText();
        String ruleId = ruleInfo.path(ID).asText();
        String portRangeMax = ruleInfo.path(PORT_RANGE_MAX).asText();
        String portRangeMin = ruleInfo.path(PORT_RANGE_MIN).asText();
        String protocol = ruleInfo.path(PROTOCOL).asText();
        String remoteGroupId = ruleInfo.path(REMOTE_GROUP_ID).asText();
        String remoteIpPrefix = ruleInfo.path(REMOTE_IP_PREFIX).asText();
        String securityGroupId = ruleInfo.path(SECURITY_GROUP_ID).asText();
        String tenantId = ruleInfo.path(TENAN_ID).asText();
        OpenstackSecurityGroupRule openstackSecurityGroupRule = OpenstackSecurityGroupRule.builder().direction(direction).etherType(ethertype).id(ruleId).portRangeMax(portRangeMax).portRangeMin(portRangeMin).protocol(protocol).remoteGroupId(remoteGroupId).remoteIpPrefix(remoteIpPrefix).securityGroupId(securityGroupId).tenantId(tenantId).build();
        rules.add(openstackSecurityGroupRule);
    }
    String tenantId = securityGroupNode.path(TENAN_ID).asText();
    OpenstackSecurityGroup openstackSecurityGroup = OpenstackSecurityGroup.builder().description(description).id(id).name(name).rules(rules).tenantId(tenantId).build();
    return openstackSecurityGroup;
}
#method_after
@Override
public OpenstackSecurityGroup decode(ObjectNode json, CodecContext context) {
    JsonNode securityGroupNode = json.get(SECURITY_GROUP);
    if (securityGroupNode == null) {
        log.warn("SecurityGroup Json data is null");
        return null;
    }
    String description = securityGroupNode.path(DESCRIPTION).asText();
    String id = securityGroupNode.path(ID).asText();
    String name = securityGroupNode.path(NAME).asText();
    ArrayNode ruleInfoList = (ArrayNode) securityGroupNode.path(SECURITY_GROUP_RULES);
    Collection<OpenstackSecurityGroupRule> rules = Lists.newArrayList();
    for (JsonNode ruleInfo : ruleInfoList) {
        OpenstackSecurityGroupRule openstackSecurityGroupRule = OpenstackSecurityGroupRule.builder().direction(ruleInfo.path(DIRECTION).asText()).etherType(ruleInfo.path(EHTERTYPE).asText()).id(ruleInfo.path(ID).asText()).portRangeMax(ruleInfo.path(PORT_RANGE_MAX).asText()).portRangeMin(ruleInfo.path(PORT_RANGE_MIN).asText()).protocol(ruleInfo.path(PROTOCOL).asText()).remoteGroupId(ruleInfo.path(REMOTE_GROUP_ID).asText()).remoteIpPrefix(ruleInfo.path(REMOTE_IP_PREFIX).asText()).securityGroupId(ruleInfo.path(SECURITY_GROUP_ID).asText()).tenantId(ruleInfo.path(TENAN_ID).asText()).build();
        rules.add(openstackSecurityGroupRule);
    }
    String tenantId = securityGroupNode.path(TENAN_ID).asText();
    OpenstackSecurityGroup openstackSecurityGroup = OpenstackSecurityGroup.builder().description(description).id(id).name(name).rules(rules).tenantId(tenantId).build();
    return openstackSecurityGroup;
}
#end_block

#method_before
@Test
public void testCreateDeviceKeyUsingCommunityName() {
    DeviceKeyId deviceKeyId = DeviceKeyId.deviceKeyId(deviceKeyIdValue);
    DeviceKey deviceKey = DeviceKey.createDeviceKeyUsingCommunityName(deviceKeyId, deviceKeyLabel, deviceKeySnmpName);
    assertThat(deviceKey, is(notNullValue()));
    assertThat(deviceKey.deviceKeyId(), is(deviceKeyId));
    assertThat(deviceKey.label(), is(deviceKeyLabel));
    assertThat(deviceKey.type(), is(DeviceKey.Type.COMMUNITY_NAME));
    CommunityName communityName = deviceKey.asCommunityName();
    assertThat(communityName, is(notNullValue()));
    assertThat(communityName.name(), is(deviceKeySnmpName));
}
#method_after
@Test
public void testCreateDeviceKeyUsingCommunityName() {
    DeviceKeyId deviceKeyId = DeviceKeyId.deviceKeyId(deviceKeyIdValue);
    DeviceKey deviceKey = DeviceKey.createDeviceKeyUsingCommunityName(deviceKeyId, deviceKeyLabel, deviceKeySnmpName);
    assertNotNull("The deviceKey should not be null.", deviceKey);
    assertEquals("The deviceKeyId should match as expected", deviceKeyId, deviceKey.deviceKeyId());
    assertEquals("The label should match as expected", deviceKeyLabel, deviceKey.label());
    assertEquals("The type should match as expected", DeviceKey.Type.COMMUNITY_NAME, deviceKey.type());
    CommunityName communityName = deviceKey.asCommunityName();
    assertNotNull("The communityName should not be null.", communityName);
    assertEquals("The name should match as expected", deviceKeySnmpName, communityName.name());
}
#end_block

#method_before
@Test
public void testCommunityNameNull() {
    CommunityName communityName = CommunityName.communityName(null);
    assertThat(communityName, is(notNullValue()));
    assertThat(communityName.name(), is(nullValue()));
}
#method_after
@Test
public void testCommunityNameNull() {
    CommunityName communityName = CommunityName.communityName(null);
    assertNotNull("The CommunityName should not be null.", communityName);
    assertNull("The name should be null.", communityName.name());
}
#end_block

#method_before
@Test
public void testCommunityName() {
    CommunityName communityName = CommunityName.communityName(cName);
    assertThat(communityName, is(notNullValue()));
    assertThat(communityName.name(), is(cName));
}
#method_after
@Test
public void testCommunityName() {
    CommunityName communityName = CommunityName.communityName(cName);
    assertNotNull("The CommunityName should not be null.", communityName);
    assertEquals("The name should match the expected value.", cName, communityName.name());
}
#end_block

#method_before
@Test
public void testConstruction() {
    DeviceKeyId deviceKeyId = DeviceKeyId.deviceKeyId(deviceKeyIdValue1);
    assertThat(deviceKeyId, is(notNullValue()));
    assertThat(deviceKeyId.id(), is(deviceKeyIdValue1));
}
#method_after
@Test
public void testConstruction() {
    DeviceKeyId deviceKeyId = DeviceKeyId.deviceKeyId(deviceKeyIdValue1);
    assertNotNull("The deviceKeyId should not be null.", deviceKeyId);
    assertEquals("The id should match the expected value.", deviceKeyIdValue1, deviceKeyId.id());
}
#end_block

#method_before
@Override
public void updateMetric(ControlMetric cm, int updateInterval, Optional<DeviceId> deviceId) {
    if (deviceId.isPresent()) {
        // insert a new device entry if we cannot find any
        ctrlMsgBuf.putIfAbsent(deviceId.get(), new ConcurrentHashMap<>());
        // update control message metrics
        if (CTRL_MSGS.contains(cm.metricType())) {
            // we will accumulate the metric value into buffer first
            ctrlMsgBuf.get(deviceId.get()).putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
            // we simply set and update the values into MetricsDatabase.
            if (ctrlMsgBuf.get(deviceId.get()).keySet().containsAll(CTRL_MSGS)) {
                updateControlMessages(ctrlMsgBuf.get(deviceId.get()), deviceId.get());
                ctrlMsgBuf.get(deviceId.get()).clear();
            }
        }
    } else {
        // update cpu metrics
        if (CPU_METRICS.contains(cm.metricType())) {
            cpuBuf.putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
            if (cpuBuf.keySet().containsAll(CPU_METRICS)) {
                cpuMetrics.updateMetrics(convertMap(cpuBuf));
                cpuBuf.clear();
            }
        }
        // update memory metrics
        if (MEMORY_METRICS.contains(cm.metricType())) {
            memoryBuf.putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
            if (memoryBuf.keySet().containsAll(MEMORY_METRICS)) {
                memoryMetrics.updateMetrics(convertMap(memoryBuf));
                memoryBuf.clear();
            }
        }
    }
}
#method_after
@Override
public void updateMetric(ControlMetric cm, int updateIntervalInMinutes, Optional<DeviceId> deviceId) {
    if (deviceId.isPresent()) {
        // insert a new device entry if we cannot find any
        ctrlMsgBuf.putIfAbsent(deviceId.get(), new ConcurrentHashMap<>());
        // update control message metrics
        if (CTRL_MSGS.contains(cm.metricType())) {
            // we will accumulate the metric value into buffer first
            ctrlMsgBuf.get(deviceId.get()).putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
            // we simply set and update the values into MetricsDatabase.
            if (ctrlMsgBuf.get(deviceId.get()).keySet().containsAll(CTRL_MSGS)) {
                updateControlMessages(ctrlMsgBuf.get(deviceId.get()), deviceId.get());
                ctrlMsgBuf.get(deviceId.get()).clear();
            }
        }
    } else {
        // update cpu metrics
        if (CPU_METRICS.contains(cm.metricType())) {
            cpuBuf.putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
            if (cpuBuf.keySet().containsAll(CPU_METRICS)) {
                cpuMetrics.updateMetrics(convertMap(cpuBuf));
                cpuBuf.clear();
            }
        }
        // update memory metrics
        if (MEMORY_METRICS.contains(cm.metricType())) {
            memoryBuf.putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
            if (memoryBuf.keySet().containsAll(MEMORY_METRICS)) {
                memoryMetrics.updateMetrics(convertMap(memoryBuf));
                memoryBuf.clear();
            }
        }
    }
}
#end_block

#method_before
@Override
public void updateMetric(ControlMetric cm, int updateInterval, String resourceName) {
    // update disk metrics
    if (DISK_METRICS.contains(cm.metricType())) {
        diskBuf.putIfAbsent(resourceName, new ConcurrentHashMap<>());
        diskBuf.get(resourceName).putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
        if (diskBuf.get(resourceName).keySet().containsAll(DISK_METRICS)) {
            updateDiskMetrics(diskBuf.get(resourceName), resourceName);
            diskBuf.clear();
        }
    }
    // update network metrics
    if (NETWORK_METRICS.contains(cm.metricType())) {
        networkBuf.putIfAbsent(resourceName, new ConcurrentHashMap<>());
        networkBuf.get(resourceName).putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
        if (networkBuf.get(resourceName).keySet().containsAll(NETWORK_METRICS)) {
            updateNetworkMetrics(networkBuf.get(resourceName), resourceName);
            networkBuf.clear();
        }
    }
}
#method_after
@Override
public void updateMetric(ControlMetric cm, int updateIntervalInMinutes, String resourceName) {
    // update disk metrics
    if (DISK_METRICS.contains(cm.metricType())) {
        diskBuf.putIfAbsent(resourceName, new ConcurrentHashMap<>());
        diskBuf.get(resourceName).putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
        if (diskBuf.get(resourceName).keySet().containsAll(DISK_METRICS)) {
            updateDiskMetrics(diskBuf.get(resourceName), resourceName);
            diskBuf.clear();
        }
    }
    // update network metrics
    if (NETWORK_METRICS.contains(cm.metricType())) {
        networkBuf.putIfAbsent(resourceName, new ConcurrentHashMap<>());
        networkBuf.get(resourceName).putIfAbsent(cm.metricType(), (double) cm.metricValue().getLoad());
        if (networkBuf.get(resourceName).keySet().containsAll(NETWORK_METRICS)) {
            updateNetworkMetrics(networkBuf.get(resourceName), resourceName);
            networkBuf.clear();
        }
    }
}
#end_block

#method_before
public final void init(S subject, String key, JsonNode node, ObjectMapper mapper, ConfigApplyDelegate delegate) {
    this.subject = checkNotNull(subject, "subject cannot be null");
    this.key = key;
    this.node = checkNotNull(node, "node cannot be null");
    this.object = node instanceof ObjectNode ? (ObjectNode) node : null;
    this.array = node instanceof ArrayNode ? (ArrayNode) node : null;
    this.mapper = checkNotNull(mapper, "mapper cannot be null");
    this.delegate = delegate;
}
#method_after
public final void init(S subject, String key, JsonNode node, ObjectMapper mapper, ConfigApplyDelegate delegate) {
    this.subject = checkNotNull(subject, "Subject cannot be null");
    this.key = key;
    this.node = checkNotNull(node, "Node cannot be null");
    this.object = node instanceof ObjectNode ? (ObjectNode) node : null;
    this.array = node instanceof ArrayNode ? (ArrayNode) node : null;
    this.mapper = checkNotNull(mapper, "Mapper cannot be null");
    this.delegate = delegate;
}
#end_block

#method_before
public void apply() {
    if (delegate != null) {
        delegate.onApply(this);
    }
}
#method_after
public void apply() {
    checkState(delegate != null, "Cannot apply detached config");
    delegate.onApply(this);
}
#end_block

#method_before
@Override
public void event(McastEvent event) {
    McastRoute route = event.subject().route();
    Key routeKey = setIntent(route);
    intentHashMap.put(route, routeKey);
}
#method_after
@Override
public void event(McastEvent event) {
    McastRoute route = event.subject().route();
    if (intentHashMap.containsKey(route)) {
        withdrawIntent(intentHashMap.get(route));
    }
    Key routeKey = setIntent(route);
    intentHashMap.put(route, routeKey);
}
#end_block

#method_before
private Key setIntent(McastRoute route) {
    ConnectPoint ingressPoint = mcastRouteManager.fetchSource(route);
    HashSet<ConnectPoint> egressPoints = new HashSet<>(mcastRouteManager.fetchSinks(route));
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment();
    if (ingressPoint == null) {
        log.warn("Can't set intent without an ingress or egress connect points");
        return null;
    }
    selector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(route.group().toIpPrefix()).matchIPSrc(route.source().toIpPrefix());
    SinglePointToMultiPointIntent.Builder builder = SinglePointToMultiPointIntent.builder().appId(appId).selector(selector.build()).treatment(treatment).ingressPoint(ingressPoint);
    // allowing intent to be pushed without egress points means we can drop packets.
    if (!egressPoints.isEmpty()) {
        builder.egressPoints(egressPoints);
    }
    SinglePointToMultiPointIntent intent = builder.build();
    intentService.submit(intent);
    return intent.key();
}
#method_after
private Key setIntent(McastRoute route) {
    ConnectPoint ingressPoint = mcastRouteManager.fetchSource(route);
    Set<ConnectPoint> egressPoints = new HashSet<>(mcastRouteManager.fetchSinks(route));
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment();
    if (ingressPoint == null) {
        log.warn("Can't set intent without an ingress or egress connect points");
        return null;
    }
    selector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(route.group().toIpPrefix()).matchIPSrc(route.source().toIpPrefix());
    SinglePointToMultiPointIntent.Builder builder = SinglePointToMultiPointIntent.builder().appId(appId).selector(selector.build()).treatment(treatment).ingressPoint(ingressPoint);
    // allowing intent to be pushed without egress points means we can drop packets.
    if (!egressPoints.isEmpty()) {
        builder.egressPoints(egressPoints);
    }
    SinglePointToMultiPointIntent intent = builder.build();
    intentService.submit(intent);
    return intent.key();
}
#end_block

#method_before
void reconfigure(CoreConfig coreConfig) {
    CoreConfig newCoreConfig;
    if (coreConfig == null) {
        newCoreConfig = new CoreConfig();
    } else {
        newCoreConfig = coreConfig;
    }
    linkDiscoveryMode = newCoreConfig.linkDiscoveryMode();
    if (linkDiscoveryMode == LinkDiscoveryMode.STRICT) {
        // Remove any previous links to force them to go through the strict
        // discovery process
        linkDescriptions.clear();
        links.clear();
    }
    log.debug("config set link discovery mode to {}", linkDiscoveryMode.name());
}
#method_after
void reconfigure(CoreConfig coreConfig) {
    if (coreConfig == null) {
        linkDiscoveryMode = LinkDiscoveryMode.PERMISSIVE;
    } else {
        linkDiscoveryMode = coreConfig.linkDiscoveryMode();
    }
    if (linkDiscoveryMode == LinkDiscoveryMode.STRICT) {
        // Remove any previous links to force them to go through the strict
        // discovery process
        linkDescriptions.clear();
        links.clear();
    }
    log.debug("config set link discovery mode to {}", linkDiscoveryMode.name());
}
#end_block

#method_before
public ECLinkStore.LinkDiscoveryMode linkDiscoveryMode() {
    return ECLinkStore.LinkDiscoveryMode.valueOf(getStringProperty(LINK_DISCOVERY_MODE, DEFAULT_LINK_DISCOVERY_MODE));
}
#method_after
public ECLinkStore.LinkDiscoveryMode linkDiscoveryMode() {
    return ECLinkStore.LinkDiscoveryMode.valueOf(get(LINK_DISCOVERY_MODE, DEFAULT_LINK_DISCOVERY_MODE));
}
#end_block

#method_before
@Override
public long probeRate() {
    return 3000;
}
#method_after
@Override
public long probeRate() {
    return probeRate;
}
#end_block

#method_before
@Override
public void addPending(IntentData data) {
    if (data.version() == null) {
        // recompiled intents will already have a version
        data = new IntentData(data.intent(), data.state(), new SystemClockTimestamp());
    }
    synchronized (this) {
        IntentData existingData = pending.get(data.key());
        if (existingData == null || // TODO maybe we should still make this <= to be safe?
        existingData.version().compareTo(data.version()) < 0) {
            pending.put(data.key(), data);
            checkNotNull(delegate, "Store delegate is not set").process(data);
            IntentEvent.getEvent(data).ifPresent(this::notifyDelegate);
        } else {
            log.debug("IntentData {} is older than existing: {}", data, existingData);
        }
    // TODO consider also checking the current map at this point
    }
}
#method_after
@Override
public void addPending(IntentData data) {
    if (data.version() == null) {
        // recompiled intents will already have a version
        data = new IntentData(data.intent(), data.state(), new SystemClockTimestamp());
    }
    synchronized (this) {
        IntentData existingData = pending.get(data.key());
        if (existingData == null || // TODO maybe we should still make this <= to be safe?
        existingData.version().compareTo(data.version()) < 0) {
            pending.put(data.key(), data);
            checkNotNull(delegate, "Store delegate is not set").process(new IntentData(data));
            IntentEvent.getEvent(data).ifPresent(this::notifyDelegate);
        } else {
            log.debug("IntentData {} is older than existing: {}", data, existingData);
        }
    // TODO consider also checking the current map at this point
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Resource)) {
        return false;
    }
    final Resource that = (Resource) obj;
    return Objects.equals(this.id, that.id);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (this.getClass() != obj.getClass()) {
        return false;
    }
    final Resource that = (Resource) obj;
    return Objects.equals(this.id, that.id);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(this.id(), this.value);
}
#method_after
@Override
public int hashCode() {
    return super.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Continuous)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    final Continuous other = (Continuous) obj;
    return Objects.equals(this.id(), other.id());
}
#method_after
// explicitly overriding to express that we intentionally ignore
@Override
public boolean equals(Object obj) {
    return super.equals(obj);
}
#end_block

#method_before
@Override
public boolean isAvailable(Resource resource) {
    checkNotNull(resource);
    checkArgument(resource instanceof Resource.Discrete || resource instanceof Resource.Continuous);
    if (resource instanceof Resource.Discrete) {
        return getConsumer((Resource.Discrete) resource).isEmpty();
    } else {
        return isAvailable((Resource.Continuous) resource);
    }
}
#method_after
@Override
public boolean isAvailable(Resource resource) {
    checkNotNull(resource);
    checkArgument(resource instanceof Resource.Discrete || resource instanceof Resource.Continuous);
    // check if it's registered or not.
    Versioned<Set<Resource>> v = childMap.get(resource.parent().get());
    if (v == null || !v.value().contains(resource)) {
        return false;
    }
    if (resource instanceof Resource.Discrete) {
        // check if already consumed
        return getConsumer((Resource.Discrete) resource).isEmpty();
    } else {
        Resource.Continuous requested = (Resource.Continuous) resource;
        Resource.Continuous registered = v.value().stream().filter(c -> c.equals(resource)).findFirst().map(c -> (Resource.Continuous) c).get();
        if (registered.value() < requested.value()) {
            // Capacity < requested, can never satisfy
            return false;
        }
        // check if there's enough left
        return isAvailable(requested);
    }
}
#end_block

#method_before
private void executeMonitorTask() {
    // TODO: execute monitoring task with 1 minute period
    if (cmf.isMonitor()) {
        controlMetricsObservers.forEach(observer -> {
            // feed the CPU stats
            observer.feedMetrics(cmf.cpuLoadMetric(), Optional.ofNullable(null));
            observer.feedMetrics(cmf.totalCpuTimeMetric(), Optional.ofNullable(null));
            observer.feedMetrics(cmf.sysCpuTimeMetric(), Optional.ofNullable(null));
            observer.feedMetrics(cmf.userCpuTime(), Optional.ofNullable(null));
            observer.feedMetrics(cmf.cpuIdleTime(), Optional.ofNullable(null));
            // feed the memory stats
            observer.feedMetrics(cmf.memoryFreePercentage(), Optional.ofNullable(null));
            observer.feedMetrics(cmf.memoryUsedPercentage(), Optional.ofNullable(null));
            // feed the disk I/O stats
            cmf.getDiskPartitions().forEach(v -> {
                observer.feedMetrics(cmf.diskReadBytes(v), v);
                observer.feedMetrics(cmf.diskWriteBytes(v), v);
            });
            // feed the network I/O stats
            cmf.getNetworkInterfaces().forEach(v -> {
                observer.feedMetrics(cmf.nwIncomingBytes(v), v);
                observer.feedMetrics(cmf.nwOutgoingBytes(v), v);
                observer.feedMetrics(cmf.nwIncomingPackets(v), v);
                observer.feedMetrics(cmf.nwOutgoingPackets(v), v);
            });
            // feed the control message stats
            cmf.getDeviceIds().forEach(v -> {
                observer.feedMetrics(cmf.inboundPacket(v), Optional.ofNullable(v));
                observer.feedMetrics(cmf.outboundPacket(v), Optional.ofNullable(v));
                observer.feedMetrics(cmf.flowmodPacket(v), Optional.ofNullable(v));
                observer.feedMetrics(cmf.flowrmvPacket(v), Optional.ofNullable(v));
                observer.feedMetrics(cmf.requestPacket(v), Optional.ofNullable(v));
                observer.feedMetrics(cmf.replyPacket(v), Optional.ofNullable(v));
            });
        });
    }
}
#method_after
private void executeMonitorTask() {
    // TODO: execute monitoring task with 1 minute period
    if (cmf.isMonitor()) {
        controlMetricsObservers.forEach(observer -> {
            // only OpenFlow messages are spontaneously monitored with
            // 1 minute period. Other system metrics will be pushed from
            // external monitoring agent through REST API
            // feed the control message stats
            cmf.getDeviceIds().forEach(v -> {
                observer.feedMetrics(cmf.inboundPacket(v), Optional.of(v));
                observer.feedMetrics(cmf.outboundPacket(v), Optional.of(v));
                observer.feedMetrics(cmf.flowmodPacket(v), Optional.of(v));
                observer.feedMetrics(cmf.flowrmvPacket(v), Optional.of(v));
                observer.feedMetrics(cmf.requestPacket(v), Optional.of(v));
                observer.feedMetrics(cmf.replyPacket(v), Optional.of(v));
            });
        });
    }
}
#end_block

#method_before
public Set<DeviceId> getDeviceIds() {
    return this.deviceIds;
}
#method_after
public Set<DeviceId> getDeviceIds() {
    return ImmutableSet.copyOf(this.deviceIds);
}
#end_block

#method_before
public Set<String> getDiskPartitions() {
    return this.diskPartitions;
}
#method_after
public Set<String> getDiskPartitions() {
    return ImmutableSet.copyOf(this.diskPartitions);
}
#end_block

#method_before
public Set<String> getNetworkInterfaces() {
    return this.nwInterfaces;
}
#method_after
public Set<String> getNetworkInterfaces() {
    return ImmutableSet.copyOf(this.nwInterfaces);
}
#end_block

#method_before
protected void unregisterMetrics() {
    /* CPU */
    cpuLoad.removeMetrics();
    totalCpuTime.removeMetrics();
    sysCpuTime.removeMetrics();
    userCpuTime.removeMetrics();
    cpuIdleTime.removeMetrics();
    /* Memory */
    memoryFree.removeMetrics();
    memoryUsed.removeMetrics();
    memoryFreePercentage.removeMetrics();
    memoryUsedPercentage.removeMetrics();
    /* Disk I/O */
    diskReadBytes.clear();
    diskWriteBytes.clear();
    /* Network I/O */
    nwIncomingBytes.clear();
    nwOutgoingBytes.clear();
    nwIncomingPackets.clear();
    nwOutgoingPackets.clear();
    /* OpenFlow Message */
    inboundPacket.clear();
    outboundPacket.clear();
    flowmodPacket.clear();
    flowrmvPacket.clear();
    requestPacket.clear();
    replyPacket.clear();
}
#method_after
protected void unregisterMetrics() {
    /* Disk I/O */
    diskReadBytes.clear();
    diskWriteBytes.clear();
    /* Network I/O */
    nwIncomingBytes.clear();
    nwOutgoingBytes.clear();
    nwIncomingPackets.clear();
    nwOutgoingPackets.clear();
    /* OpenFlow Message */
    inboundPacket.clear();
    outboundPacket.clear();
    flowmodPacket.clear();
    flowrmvPacket.clear();
    requestPacket.clear();
    replyPacket.clear();
}
#end_block

#method_before
public Map<DeviceId, MetricsAggregator> inboundPacket() {
    return inboundPacket;
}
#method_after
public Map<DeviceId, MetricsAggregator> inboundPacket() {
    return ImmutableMap.copyOf(inboundPacket);
}
#end_block

#method_before
public Map<DeviceId, MetricsAggregator> outboundPacket() {
    return outboundPacket;
}
#method_after
public Map<DeviceId, MetricsAggregator> outboundPacket() {
    return ImmutableMap.copyOf(outboundPacket);
}
#end_block

#method_before
public Map<DeviceId, MetricsAggregator> flowmodPacket() {
    return flowmodPacket;
}
#method_after
public Map<DeviceId, MetricsAggregator> flowmodPacket() {
    return ImmutableMap.copyOf(flowmodPacket);
}
#end_block

#method_before
public Map<DeviceId, MetricsAggregator> flowrmvPacket() {
    return flowrmvPacket;
}
#method_after
public Map<DeviceId, MetricsAggregator> flowrmvPacket() {
    return ImmutableMap.copyOf(flowrmvPacket);
}
#end_block

#method_before
public Map<DeviceId, MetricsAggregator> requestPacket() {
    return requestPacket;
}
#method_after
public Map<DeviceId, MetricsAggregator> requestPacket() {
    return ImmutableMap.copyOf(requestPacket);
}
#end_block

#method_before
public Map<DeviceId, MetricsAggregator> replyPacket() {
    return replyPacket;
}
#method_after
public Map<DeviceId, MetricsAggregator> replyPacket() {
    return ImmutableMap.copyOf(replyPacket);
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Reserve OCh ports
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    List<org.onosproject.net.newresource.ResourceAllocation> allocation = resourceService.allocate(intent.id(), srcPortResource, dstPortResource);
    if (allocation.isEmpty()) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Static or dynamic lambda allocation
    String staticLambda = srcPort.annotations().value(AnnotationKeys.STATIC_LAMBDA);
    OchPort srcOchPort = (OchPort) srcPort;
    OchPort dstOchPort = (OchPort) dstPort;
    OchSignal ochSignal;
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // FIXME: need to actually reserve the lambda for static lambda's
        if (staticLambda != null) {
            ochSignal = new OchSignal(Frequency.ofHz(Long.parseLong(staticLambda)), srcOchPort.lambda().channelSpacing(), srcOchPort.lambda().slotGranularity());
        } else if (!srcOchPort.isTunable() || !dstOchPort.isTunable()) {
            // FIXME: also check destination OCh port
            ochSignal = srcOchPort.lambda();
        } else {
            // Request and reserve lambda on path
            List<OchSignal> lambdas = assignWavelength(intent, path);
            if (lambdas.isEmpty()) {
                continue;
            }
            ochSignal = OchSignal.toFixedGrid(lambdas, ChannelSpacing.CHL_50GHZ);
        }
        // Create installable optical path intent
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    resourceService.release(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#method_after
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Reserve OCh ports
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    List<ResourceAllocation> allocation = resourceService.allocate(intent.id(), srcPortResource, dstPortResource);
    if (allocation.isEmpty()) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Static or dynamic lambda allocation
    String staticLambda = srcPort.annotations().value(AnnotationKeys.STATIC_LAMBDA);
    OchPort srcOchPort = (OchPort) srcPort;
    OchPort dstOchPort = (OchPort) dstPort;
    OchSignal ochSignal;
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // FIXME: need to actually reserve the lambda for static lambda's
        if (staticLambda != null) {
            ochSignal = new OchSignal(Frequency.ofHz(Long.parseLong(staticLambda)), srcOchPort.lambda().channelSpacing(), srcOchPort.lambda().slotGranularity());
        } else if (!srcOchPort.isTunable() || !dstOchPort.isTunable()) {
            // FIXME: also check destination OCh port
            ochSignal = srcOchPort.lambda();
        } else {
            // Request and reserve lambda on path
            List<OchSignal> lambdas = assignWavelength(intent, path);
            if (lambdas.isEmpty()) {
                continue;
            }
            ochSignal = OchSignal.toFixedGrid(lambdas, ChannelSpacing.CHL_50GHZ);
        }
        // Create installable optical path intent
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    resourceService.release(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    loadRpcConfig(context);
    loadRestConfig(context);
    try {
        remoteServiceContext = rpcService.get(URI.create(remoteUri));
    } catch (UnsupportedOperationException e) {
        LOG.error("Unsupported URI: {}", remoteUri);
        return;
    }
    providerId = new ProviderId(schemeProp, idProp);
    registerToDeviceProvider();
    NetworkConfigListener cfglistener = new InternalConfigListener();
    cfgRegistry.addListener(cfglistener);
    cfgRegistry.registerConfigFactory(xcConfigFactory);
    registerToLinkProvider();
    LOG.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    loadRpcConfig(context);
    loadRestConfig(context);
    // setup service to, and register with, providers
    try {
        remoteServiceContext = rpcService.get(URI.create(remoteUri));
    } catch (UnsupportedOperationException e) {
        LOG.warn("Unsupported URI: {}", remoteUri);
    }
    providerId = new ProviderId(schemeProp, idProp);
    registerToDeviceProvider();
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/bigswitch", "discovery-%d"));
    prepareProbe();
    registerToLinkServices();
    // start listening to config changes
    NetworkConfigListener cfglistener = new InternalConfigListener();
    cfgRegistry.addListener(cfglistener);
    cfgRegistry.registerConfigFactory(xcConfigFactory);
    LOG.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    executor.shutdownNow();
    packetService.removeProcessor(packetProcessor);
    cfgRegistry.unregisterConfigFactory(xcConfigFactory);
    cfgService.unregisterProperties(getClass(), false);
    linkProviderRegistry.unregister(this);
    unregisterFromDeviceProvider();
    // Won't hurt but necessary?
    deviceProviderService = null;
    providerId = null;
    LOG.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    packetService.removeProcessor(packetProcessor);
    cfgRegistry.unregisterConfigFactory(xcConfigFactory);
    cfgService.unregisterProperties(getClass(), false);
    unregisterFromLinkServices();
    executor.shutdownNow();
    unregisterFromDeviceProvider();
    // Won't hurt but necessary?
    deviceProviderService = null;
    providerId = null;
    LOG.info("Stopped");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    // Needs re-registration to DeviceProvider
    if (loadRpcConfig(context)) {
        // unregister from DeviceProvider with old parameters
        unregisterFromDeviceProvider();
        // register to DeviceProvider with new parameters
        registerToDeviceProvider();
        LOG.info("Re-registered to DeviceProvider");
    }
    // Needs to advertise cross-connect links
    if (loadRestConfig(context)) {
        advertiseCrossConnectLinksOnAllPorts();
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    // Needs re-registration to DeviceProvider
    if (loadRpcConfig(context)) {
        // unregister from Device and Link Providers with old parameters
        unregisterFromLinkServices();
        unregisterFromDeviceProvider();
        // register to Device and Link Providers with new parameters
        try {
            remoteServiceContext = rpcService.get(URI.create(remoteUri));
            registerToDeviceProvider();
            registerToLinkServices();
        } catch (UnsupportedOperationException e) {
            LOG.warn("Unsupported URI: {}", remoteUri);
        }
        LOG.info("Re-registered with Device and Link Providers");
    }
    // Needs to advertise cross-connect links
    if (loadRestConfig(context)) {
        advertiseCrossConnectLinksOnAllPorts();
    }
}
#end_block

#method_before
private void advertiseCrossConnectLinksOnAllPorts() {
    bigSwitchService.getPorts().stream().forEach(BigSwitchDeviceProvider.this::advertiseCrossConnectLinks);
}
#method_after
private void advertiseCrossConnectLinksOnAllPorts() {
    bigSwitchService.getPorts().forEach(BigSwitchDeviceProvider.this::advertiseCrossConnectLinks);
}
#end_block

#method_before
@Override
public void run() {
    // fingerprint shouldn't change so if we get it once, it can be stashed
    if (fingerprint == null || NO_NAME.equals(fingerprint)) {
        ClusterMetadata mdata = metadataService.getClusterMetadata();
        fingerprint = mdata == null ? NO_NAME : mdata.getName();
    }
    bigSwitchService.getPorts().forEach(p -> {
        // ID of big switch contains schema, so we're good
        ONOSLLDP lldp = ONOSLLDP.fingerprintedLLDP(bigSwitch.id().toString(), bigSwitch.chassisId(), (int) p.portNumber().toLong(), fingerprint);
        ethPacket.setPayload(lldp);
        // recover physical connect point
        ConnectPoint real = ConnectPoint.deviceConnectPoint(p.annotations().value(BigSwitchManager.REALIZED_BY));
        LOG.debug("sending probe for {}/{} through {}", bigSwitch.id(), p.portNumber(), real.toString());
        packetService.emit(new DefaultOutboundPacket(real.deviceId(), builder().setOutput(real.port()).build(), ByteBuffer.wrap(ethPacket.serialize())));
    });
}
#method_after
@Override
public void run() {
    // fingerprint shouldn't change so if we get it once, it can be stashed
    if (fingerPrint == null || NO_NAME.equals(fingerPrint)) {
        ClusterMetadata mData = metadataService.getClusterMetadata();
        fingerPrint = mData == null ? NO_NAME : mData.getName();
    }
    bigSwitchService.getPorts().forEach(p -> {
        // ID of big switch contains schema, so we're good
        ONOSLLDP lldp = ONOSLLDP.fingerprintedLLDP(bigSwitch.id().toString(), bigSwitch.chassisId(), (int) p.portNumber().toLong(), fingerPrint);
        ethPacket.setPayload(lldp);
        // recover physical connect point
        ConnectPoint real = ConnectPoint.deviceConnectPoint(p.annotations().value(BigSwitchManager.REALIZED_BY));
        LOG.debug("sending probe for {}/{} through {}", bigSwitch.id(), p.portNumber(), real.toString());
        packetService.emit(new DefaultOutboundPacket(real.deviceId(), builder().setOutput(real.port()).build(), ByteBuffer.wrap(ethPacket.serialize())));
    });
}
#end_block

#method_before
@Override
public Optional<DiscreteResource> parent() {
    return Optional.of(id.parent()).map(DiscreteResource::new);
}
#method_after
@Override
public Optional<DiscreteResource> parent() {
    return Optional.ofNullable(id.parent()).map(DiscreteResource::new);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("id", id).add("volume", volume()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("id", id).add("volume", value).toString();
}
#end_block

#method_before
@Override
ContinuousResourceId child(Class<?> child) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ContinuousResourceId child(Class<?> child) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
DiscreteResourceId parent() {
    if (components.size() == 1) {
        return ROOT;
    } else {
        return new DiscreteResourceId(components.subList(0, components.size() - 1));
    }
}
#method_after
@Override
DiscreteResourceId parent() {
    if (components.size() == 0) {
        return null;
    }
    if (components.size() == 1) {
        return ROOT;
    } else {
        return new DiscreteResourceId(components.subList(0, components.size() - 1));
    }
}
#end_block

#method_before
@Override
ContinuousResourceId child(Class<?> child) {
    checkNotNull(child);
    return new ContinuousResourceId(ImmutableList.builder().addAll(components), child);
}
#method_after
@Override
public ContinuousResourceId child(Class<?> child) {
    checkNotNull(child);
    return new ContinuousResourceId(ImmutableList.builder().addAll(components), child);
}
#end_block

#method_before
@Override
DiscreteResourceId parent() {
    if (components.size() == 1) {
        return ROOT;
    } else {
        return new DiscreteResourceId(components.subList(0, components.size() - 1));
    }
}
#method_after
@Override
DiscreteResourceId parent() {
    if (components.size() == 0) {
        return null;
    }
    if (components.size() == 1) {
        return ROOT;
    } else {
        return new DiscreteResourceId(components.subList(0, components.size() - 1));
    }
}
#end_block

#method_before
private void printResource(Resource resource, int level) {
    // TODO add an option to show only available resource
    Collection<Resource> children = resourceService.getRegisteredResources(resource);
    if (resource.equals(Resource.ROOT)) {
        print("ROOT");
    } else {
        String resourceName = resource.last().getClass().getSimpleName();
        if (children.isEmpty() && !typesToPrint.isEmpty() && !typesToPrint.contains(resourceName)) {
            // This resource is target of filtering
            return;
        }
        if (resource instanceof Resource.Continuous) {
            print("%s%s: %f", Strings.repeat(" ", level), resource.last(), ((Resource.Continuous) resource).value());
            // Continuous resource is terminal node, stop here
            return;
        } else {
            String toString = String.valueOf(resource.last());
            if (toString.startsWith(resourceName)) {
                print("%s%s", Strings.repeat(" ", level), toString);
            } else {
                print("%s%s: %s", Strings.repeat(" ", level), resourceName, toString);
            }
        }
    }
    // Classify children into aggregatable terminal resources and everything else
    Set<Class<?>> aggregatableTypes = ImmutableSet.<Class<?>>builder().add(VlanId.class).add(MplsLabel.class).build();
    // (last() resource name) -> { Resource }
    Multimap<String, Resource> aggregatables = ArrayListMultimap.create();
    List<Resource> nonAggregatable = new ArrayList<>();
    for (Resource r : children) {
        if (r instanceof Resource.Continuous) {
            // non-aggregatable terminal node
            nonAggregatable.add(r);
        } else if (aggregatableTypes.contains(r.last().getClass())) {
            // aggregatable & terminal node
            String className = r.last().getClass().getSimpleName();
            if (typesToPrint.isEmpty() || typesToPrint.contains(className)) {
                aggregatables.put(className, r);
            }
        } else {
            nonAggregatable.add(r);
        }
    }
    // print aggregated (terminal)
    aggregatables.asMap().entrySet().forEach(e -> {
        // for each type...
        String resourceName = e.getKey();
        RangeSet<Long> rangeSet = TreeRangeSet.create();
        // aggregate into RangeSet
        e.getValue().stream().map(Resource::last).map(res -> {
            if (res instanceof VlanId) {
                return (long) ((VlanId) res).toShort();
            } else if (res instanceof MplsLabel) {
                return (long) ((MplsLabel) res).toInt();
            } else if (res instanceof TributarySlot) {
                return ((TributarySlot) res).index();
            }
            // TODO support Lambda (OchSignal types)
            return 0L;
        }).map(Range::singleton).map(range -> range.canonical(DiscreteDomain.longs())).forEach(rangeSet::add);
        print("%s%s: %s", Strings.repeat(" ", level + 1), resourceName, rangeSet);
    });
    // print non-aggregatables (recurse)
    if (sort) {
        nonAggregatable.stream().sorted((o1, o2) -> String.valueOf(o1.id()).compareTo(String.valueOf(o2.id()))).forEach(r -> printResource(r, level + 1));
    } else {
        nonAggregatable.forEach(r -> printResource(r, level + 1));
    }
}
#method_after
private void printResource(Resource resource, int level) {
    // TODO add an option to show only available resource
    Collection<Resource> children = resourceService.getRegisteredResources(resource);
    if (resource.equals(Resource.ROOT)) {
        print("ROOT");
    } else {
        String resourceName = resource.last().getClass().getSimpleName();
        if (children.isEmpty() && !typesToPrint.isEmpty() && !typesToPrint.contains(resourceName)) {
            // This resource is target of filtering
            return;
        }
        if (resource instanceof ContinuousResource) {
            print("%s%s: %f", Strings.repeat(" ", level), resource.last(), ((ContinuousResource) resource).value());
            // Continuous resource is terminal node, stop here
            return;
        } else {
            String toString = String.valueOf(resource.last());
            if (toString.startsWith(resourceName)) {
                print("%s%s", Strings.repeat(" ", level), toString);
            } else {
                print("%s%s: %s", Strings.repeat(" ", level), resourceName, toString);
            }
        }
    }
    // Classify children into aggregatable terminal resources and everything else
    Set<Class<?>> aggregatableTypes = ImmutableSet.<Class<?>>builder().add(VlanId.class).add(MplsLabel.class).build();
    // (last() resource name) -> { Resource }
    Multimap<String, Resource> aggregatables = ArrayListMultimap.create();
    List<Resource> nonAggregatable = new ArrayList<>();
    for (Resource r : children) {
        if (r instanceof ContinuousResource) {
            // non-aggregatable terminal node
            nonAggregatable.add(r);
        } else if (aggregatableTypes.contains(r.last().getClass())) {
            // aggregatable & terminal node
            String className = r.last().getClass().getSimpleName();
            if (typesToPrint.isEmpty() || typesToPrint.contains(className)) {
                aggregatables.put(className, r);
            }
        } else {
            nonAggregatable.add(r);
        }
    }
    // print aggregated (terminal)
    aggregatables.asMap().entrySet().forEach(e -> {
        // for each type...
        String resourceName = e.getKey();
        RangeSet<Long> rangeSet = TreeRangeSet.create();
        // aggregate into RangeSet
        e.getValue().stream().map(Resource::last).map(res -> {
            if (res instanceof VlanId) {
                return (long) ((VlanId) res).toShort();
            } else if (res instanceof MplsLabel) {
                return (long) ((MplsLabel) res).toInt();
            } else if (res instanceof TributarySlot) {
                return ((TributarySlot) res).index();
            }
            // TODO support Lambda (OchSignal types)
            return 0L;
        }).map(Range::singleton).map(range -> range.canonical(DiscreteDomain.longs())).forEach(rangeSet::add);
        print("%s%s: %s", Strings.repeat(" ", level + 1), resourceName, rangeSet);
    });
    // print non-aggregatables (recurse)
    if (sort) {
        nonAggregatable.stream().sorted((o1, o2) -> String.valueOf(o1.id()).compareTo(String.valueOf(o2.id()))).forEach(r -> printResource(r, level + 1));
    } else {
        nonAggregatable.forEach(r -> printResource(r, level + 1));
    }
}
#end_block

#method_before
public DefaultLink build() {
    return new DefaultLink(providerId, src, dst, type, state, isExpected, annotations);
}
#method_after
public DefaultLink build() {
    checkNotNull(src, "Source connect point cannot be null");
    checkNotNull(dst, "Destination connect point cannot be null");
    checkNotNull(type, "Type cannot be null");
    checkNotNull(providerId, "Provider Id cannot be null");
    return new DefaultLink(providerId, src, dst, type, state, isExpected, annotations);
}
#end_block

#method_before
@Override
protected String noRowsMessage(ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceService ds = get(DeviceService.class);
        Device dev = ds.getDevice(DeviceId.deviceId(uri));
        // TODO: replace with a less brittle solution...
        if (!isMeterSupported(dev)) {
            return NOT_SUPPORT_MESSAGE;
        }
    }
    return NO_ROWS_MESSAGE;
}
#method_after
@Override
protected String noRowsMessage(ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceService ds = get(DeviceService.class);
        Device dev = ds.getDevice(DeviceId.deviceId(uri));
        if (meterNotSupported(dev)) {
            return NOT_SUPPORT_MESSAGE;
        }
    }
    return NO_ROWS_MESSAGE;
}
#end_block

#method_before
public OpenstackExternalGateway build() {
    return new OpenstackExternalGateway(networkId, enableSNAT);
}
#method_after
public OpenstackExternalGateway build() {
    return new OpenstackExternalGateway(networkId, enablePNAT, externalFixedIPs);
}
#end_block

#method_before
protected CompletableFuture<Void> sendAsync(Endpoint ep, InternalMessage message) {
    if (ep.equals(localEp)) {
        try {
            dispatchLocally(message);
        } catch (IOException e) {
            return Tools.exceptionalFuture(e);
        }
        return CompletableFuture.completedFuture(null);
    }
    CompletableFuture<Void> future = new CompletableFuture<>();
    try {
        CompletableFuture<Channel> completableFuture = null;
        try {
            completableFuture = channels.borrowObject(ep);
            completableFuture.whenComplete((channel, throwable) -> {
                if (throwable == null) {
                    channel.writeAndFlush(message).addListener(channelFuture -> {
                        if (!channelFuture.isSuccess()) {
                            future.completeExceptionally(channelFuture.cause());
                        } else {
                            future.complete(null);
                        }
                    });
                } else {
                    future.completeExceptionally(throwable);
                }
            });
        } finally {
            channels.returnObject(ep, completableFuture);
        }
    } catch (Exception e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
protected CompletableFuture<Void> sendAsync(Endpoint ep, InternalMessage message) {
    if (ep.equals(localEp)) {
        try {
            dispatchLocally(message);
        } catch (IOException e) {
            return Tools.exceptionalFuture(e);
        }
        return CompletableFuture.completedFuture(null);
    }
    CompletableFuture<Void> future = new CompletableFuture<>();
    try {
        Connection connection = null;
        try {
            connection = channels.borrowObject(ep);
            connection.send(message, future);
        } finally {
            channels.returnObject(ep, connection);
        }
    } catch (Exception e) {
        future.completeExceptionally(e);
    }
    return future;
}
#end_block

#method_before
@Override
public void activateObject(Endpoint endpoint, CompletableFuture<Channel> future) throws Exception {
}
#method_after
@Override
public void activateObject(Endpoint endpoint, Connection connection) throws Exception {
}
#end_block

#method_before
@Override
public void destroyObject(Endpoint ep, CompletableFuture<Channel> future) throws Exception {
    log.debug("Closing connection to {}", ep);
    // Is this the right way to destroy?
    future.cancel(false);
}
#method_after
@Override
public void destroyObject(Endpoint ep, Connection connection) throws Exception {
    log.debug("Closing connection to {}", ep);
    // Is this the right way to destroy?
    connection.destroy();
}
#end_block

#method_before
@Override
public CompletableFuture<Channel> makeObject(Endpoint ep) throws Exception {
    Bootstrap bootstrap = new Bootstrap();
    bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
    bootstrap.option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 10 * 64 * 1024);
    bootstrap.option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 10 * 32 * 1024);
    bootstrap.option(ChannelOption.SO_SNDBUF, 1048576);
    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 1000);
    bootstrap.group(clientGroup);
    // TODO: Make this faster:
    // http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#37.0
    bootstrap.channel(clientChannelClass);
    bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
    if (enableNettyTls) {
        bootstrap.handler(new SslClientCommunicationChannelInitializer());
    } else {
        bootstrap.handler(new OnosCommunicationChannelInitializer());
    }
    // Start the client.
    CompletableFuture<Channel> retFuture = new CompletableFuture<>();
    ChannelFuture f = bootstrap.connect(ep.host().toString(), ep.port());
    f.addListener(future -> {
        if (future.isSuccess()) {
            retFuture.complete(f.channel());
        } else {
            retFuture.completeExceptionally(future.cause());
        }
    });
    // now manually check if the internal future is complete
    if (!retFuture.isDone() && f.isDone()) {
        if (f.isSuccess()) {
            retFuture.complete(f.channel());
        } else {
            retFuture.completeExceptionally(f.cause());
        }
    }
    log.debug("Established a new connection to {}", ep);
    return retFuture;
}
#method_after
@Override
public Connection makeObject(Endpoint ep) throws Exception {
    Bootstrap bootstrap = new Bootstrap();
    bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
    bootstrap.option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 10 * 64 * 1024);
    bootstrap.option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 10 * 32 * 1024);
    bootstrap.option(ChannelOption.SO_SNDBUF, 1048576);
    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 1000);
    bootstrap.group(clientGroup);
    // TODO: Make this faster:
    // http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#37.0
    bootstrap.channel(clientChannelClass);
    bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
    if (enableNettyTls) {
        bootstrap.handler(new SslClientCommunicationChannelInitializer());
    } else {
        bootstrap.handler(new OnosCommunicationChannelInitializer());
    }
    // Start the client.
    CompletableFuture<Channel> retFuture = new CompletableFuture<>();
    ChannelFuture f = bootstrap.connect(ep.host().toString(), ep.port());
    f.addListener(future -> {
        if (future.isSuccess()) {
            retFuture.complete(f.channel());
        } else {
            retFuture.completeExceptionally(future.cause());
        }
    });
    log.debug("Established a new connection to {}", ep);
    return new Connection(retFuture);
}
#end_block

#method_before
@Override
public void passivateObject(Endpoint ep, CompletableFuture<Channel> channel) throws Exception {
}
#method_after
@Override
public void passivateObject(Endpoint ep, Connection connection) throws Exception {
}
#end_block

#method_before
@Override
public boolean validateObject(Endpoint ep, CompletableFuture<Channel> future) {
    return !future.isCompletedExceptionally();
}
#method_after
@Override
public boolean validateObject(Endpoint ep, Connection connection) {
    return connection.validate();
}
#end_block

#method_before
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    ConfigSetter config = h.behaviour(ConfigSetter.class);
    print(config.setConfiguration(cfgFile));
}
#method_after
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    ConfigSetter config = h.behaviour(ConfigSetter.class);
    checkNotNull(cfgFile, "Configuration file cannot be null");
    print(config.setConfiguration(cfgFile));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(hostname, ovsdbIp, ovsdbPort, bridgeId, phyPortName, localIp);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(hostname);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    // Needs re-registration to Device Provider
    if (loadRpcConfig(context)) {
        // unregister from DeviceProvider with old parameters
        unregisterFromDeviceProvider();
        // register to DeviceProvider with new parameters
        registerToDeviceProvider();
    }
    // Needs to advertise cross-connect links
    if (loadRestConfig(context)) {
        advertiseCrossConnectLinksOnAllPorts();
    }
    LOG.info("Restarted");
}
#method_after
@Modified
public void modified(ComponentContext context) {
    // Needs re-registration to DeviceProvider
    if (loadRpcConfig(context)) {
        // unregister from DeviceProvider with old parameters
        unregisterFromDeviceProvider();
        // register to DeviceProvider with new parameters
        registerToDeviceProvider();
        LOG.info("Re-registered to DeviceProvider");
    }
    // Needs to advertise cross-connect links
    if (loadRestConfig(context)) {
        advertiseCrossConnectLinksOnAllPorts();
    }
}
#end_block

#method_before
private boolean loadRpcConfig(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    boolean needsRegistration = false;
    String s = Tools.get(properties, PROP_SCHEME);
    if (!schemeProp.equals(s)) {
        schemeProp = Strings.isNullOrEmpty(s) ? DEFAULT_SCHEME : s;
        needsRegistration = true;
    }
    s = Tools.get(properties, PROP_ID);
    if (!idProp.equals(s)) {
        idProp = Strings.isNullOrEmpty(s) ? DEFAULT_ID : s;
        needsRegistration = true;
    }
    s = Tools.get(properties, PROP_REMOTE_URI);
    if (!remoteUri.equals(s)) {
        remoteUri = Strings.isNullOrEmpty(s) ? DEFAULT_REMOTE_URI : s;
        needsRegistration = true;
    }
    s = Tools.get(properties, PROP_METRO_IP);
    if (!s.equals(metroIp)) {
        metroIp = Strings.isNullOrEmpty(s) ? DEFAULT_METRO_IP : s;
        advertiseCrossConnectLinksOnAllPorts();
    }
    return needsRegistration;
}
#method_after
private boolean loadRpcConfig(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    boolean changed = false;
    // TODO When configuration value is set to null or empty, actual value will differ from configuration.
    // Any means to sync those values?
    String s = Tools.get(properties, PROP_SCHEME);
    String newValue = Strings.isNullOrEmpty(s) ? DEFAULT_SCHEME : s;
    if (!schemeProp.equals(newValue)) {
        schemeProp = newValue;
        changed = true;
    }
    s = Tools.get(properties, PROP_ID);
    newValue = Strings.isNullOrEmpty(s) ? DEFAULT_ID : s;
    if (!idProp.equals(newValue)) {
        idProp = newValue;
        changed = true;
    }
    s = Tools.get(properties, PROP_REMOTE_URI);
    newValue = Strings.isNullOrEmpty(s) ? DEFAULT_REMOTE_URI : s;
    if (!remoteUri.equals(newValue)) {
        remoteUri = newValue;
        changed = true;
    }
    return changed;
}
#end_block

#method_before
private boolean loadRestConfig(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    boolean needsAdvertise = false;
    String s = Tools.get(properties, PROP_METRO_IP);
    if (!s.equals(metroIp)) {
        metroIp = Strings.isNullOrEmpty(s) ? DEFAULT_METRO_IP : s;
        needsAdvertise = true;
    }
    return needsAdvertise;
}
#method_after
private boolean loadRestConfig(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    boolean changed = false;
    String s = Tools.get(properties, PROP_METRO_IP);
    String newValue = Strings.isNullOrEmpty(s) ? DEFAULT_METRO_IP : s;
    if (!metroIp.equals(newValue)) {
        metroIp = newValue;
        changed = true;
    }
    return changed;
}
#end_block

#method_before
private void registerToDeviceProvider() {
    RemoteServiceContext remoteServiceContext;
    try {
        remoteServiceContext = rpcService.get(URI.create(remoteUri));
    } catch (UnsupportedOperationException e) {
        LOG.error("Unsupported URI: {}", remoteUri);
        return;
    }
    providerId = new ProviderId(schemeProp, idProp);
    // Create big switch device and description
    DeviceId deviceId = DeviceId.deviceId(schemeProp + ':' + clusterService.getLocalNode().ip());
    bigSwitch = new BigSwitch(deviceId, this.id());
    bigSwitchDescription = new DefaultDeviceDescription(bigSwitch.id().uri(), bigSwitch.type(), bigSwitch.manufacturer(), bigSwitch.hwVersion(), bigSwitch.swVersion(), bigSwitch.serialNumber(), bigSwitch.chassisId());
    providerRegistry = remoteServiceContext.get(DeviceProviderRegistry.class);
    providerService = providerRegistry.register(this);
    // Start big switch service and register device
    providerService.deviceConnected(bigSwitch.id(), bigSwitchDescription);
    providerService.updatePorts(bigSwitch.id(), bigSwitchService.getPorts());
    advertiseCrossConnectLinksOnAllPorts();
    bigSwitchService.addListener(listener);
}
#method_after
private void registerToDeviceProvider() {
    RemoteServiceContext remoteServiceContext;
    // TODO Can validation of the URI be done while loading configuration?
    try {
        remoteServiceContext = rpcService.get(URI.create(remoteUri));
    } catch (UnsupportedOperationException e) {
        LOG.error("Unsupported URI: {}", remoteUri);
        return;
    }
    providerId = new ProviderId(schemeProp, idProp);
    // Create big switch device and description
    DeviceId deviceId = DeviceId.deviceId(schemeProp + ':' + clusterService.getLocalNode().ip());
    bigSwitch = new BigSwitch(deviceId, this.id());
    bigSwitchDescription = new DefaultDeviceDescription(bigSwitch.id().uri(), bigSwitch.type(), bigSwitch.manufacturer(), bigSwitch.hwVersion(), bigSwitch.swVersion(), bigSwitch.serialNumber(), bigSwitch.chassisId());
    providerRegistry = remoteServiceContext.get(DeviceProviderRegistry.class);
    providerService = providerRegistry.register(this);
    // Start big switch service and register device
    providerService.deviceConnected(bigSwitch.id(), bigSwitchDescription);
    providerService.updatePorts(bigSwitch.id(), bigSwitchService.getPorts());
    advertiseCrossConnectLinksOnAllPorts();
    bigSwitchService.addListener(listener);
}
#end_block

#method_before
private void unregisterFromDeviceProvider() {
    providerService.deviceDisconnected(bigSwitch.id());
    providerRegistry.unregister(this);
}
#method_after
private void unregisterFromDeviceProvider() {
    if (bigSwitch == null) {
        LOG.warn("Invalid unregistration.");
        return;
    }
    providerService.deviceDisconnected(bigSwitch.id());
    providerRegistry.unregister(this);
    bigSwitch = null;
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    // For VLAN cross-connect packets, use the configured VLAN
    if (vidCriterion != null) {
        if (vidCriterion.vlanId() != VlanId.NONE) {
            assignedVlan = vidCriterion.vlanId();
        // For untagged packets, assign a VLAN ID
        } else {
            if (filt.meta() == null) {
                log.error("Missing metadata in filtering objective required " + "for vlan assignment in dev {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
            for (Instruction i : filt.meta().allInstructions()) {
                if (i instanceof ModVlanIdInstruction) {
                    assignedVlan = ((ModVlanIdInstruction) i).vlanId();
                }
            }
            if (assignedVlan == null) {
                log.error("Driver requires an assigned vlan-id to tag incoming " + "untagged packets. Not processing vlan filters on " + "device {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
        }
    }
    if (ethCriterion == null) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (portCriterion == null || vidCriterion == null) {
        log.debug("filtering objective missing dstMac or port criterion, " + "cannot program VLAN Table");
    } else {
        for (FlowRule vlanRule : processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", vlanRule, deviceId);
            ops = install ? ops.add(vlanRule) : ops.remove(vlanRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    // For VLAN cross-connect packets, use the configured VLAN
    if (vidCriterion != null) {
        if (vidCriterion.vlanId() != VlanId.NONE) {
            assignedVlan = vidCriterion.vlanId();
        // For untagged packets, assign a VLAN ID
        } else {
            if (filt.meta() == null) {
                log.error("Missing metadata in filtering objective required " + "for vlan assignment in dev {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
            for (Instruction i : filt.meta().allInstructions()) {
                if (i instanceof ModVlanIdInstruction) {
                    assignedVlan = ((ModVlanIdInstruction) i).vlanId();
                }
            }
            if (assignedVlan == null) {
                log.error("Driver requires an assigned vlan-id to tag incoming " + "untagged packets. Not processing vlan filters on " + "device {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(MacAddress.NONE)) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (ethCriterion == null || vidCriterion == null) {
        log.debug("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
    } else {
        for (FlowRule vlanRule : processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", vlanRule, deviceId);
            ops = install ? ops.add(vlanRule) : ops.remove(vlanRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + Objects.hashCode(this.deviceId) + Objects.hashCode(this.vlanId);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(deviceId, vlanId);
}
#end_block

#method_before
public int getPortNextObjectiveId(PortNumber portNum, TrafficTreatment treatment, TrafficSelector meta) {
    Integer nextId = portNextObjStore.get(new PortNextObjectiveStoreKey(deviceId, portNum, treatment));
    if (nextId == null) {
        log.trace("getPortNextObjectiveId in device{}: Next objective id " + "not found for {} and {} creating", deviceId, portNum);
        createGroupFromPort(portNum, treatment, meta);
        nextId = portNextObjStore.get(new PortNextObjectiveStoreKey(deviceId, portNum, treatment));
        if (nextId == null) {
            log.warn("getPortNextObjectiveId: unable to create next obj" + "for dev:{} port{}", deviceId, portNum);
            return -1;
        }
    }
    return nextId;
}
#method_after
public int getPortNextObjectiveId(PortNumber portNum, TrafficTreatment treatment, TrafficSelector meta) {
    Integer nextId = portNextObjStore.get(new PortNextObjectiveStoreKey(deviceId, portNum, treatment));
    if (nextId == null) {
        log.trace("getPortNextObjectiveId in device{}: Next objective id " + "not found for {} and {} creating", deviceId, portNum);
        createGroupFromPort(portNum, treatment, meta);
        nextId = portNextObjStore.get(new PortNextObjectiveStoreKey(deviceId, portNum, treatment));
        if (nextId == null) {
            log.warn("getPortNextObjectiveId: unable to create next obj" + "for dev:{} port:{}", deviceId, portNum);
            return -1;
        }
    }
    return nextId;
}
#end_block

#method_before
public void createGroupsForXConnect(DeviceId deviceId) {
    Map<VlanId, List<ConnectPoint>> xConnectsForDevice = this.deviceConfig.getXConnects();
    xConnectsForDevice.forEach((vlanId, connectPoints) -> {
        // Only proceed  the xConnect for given device
        for (ConnectPoint connectPoint : connectPoints) {
            if (!connectPoint.deviceId().equals(deviceId)) {
                return;
            }
        }
        // Check if the next obj is already in the store
        XConnectNextObjectiveStoreKey key = new XConnectNextObjectiveStoreKey(deviceId, vlanId);
        if (xConnectNextObjStore.containsKey(key)) {
            log.debug("Cross-connect Broadcast group for device {} and vlanId {} exists", deviceId, vlanId);
            return;
        }
        TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(vlanId).build();
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.BROADCAST).fromApp(appId).withMeta(metadata);
        connectPoints.forEach(connectPoint -> {
            TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
            tBuilder.setOutput(connectPoint.port());
            nextObjBuilder.addTreatment(tBuilder.build());
        });
        NextObjective nextObj = nextObjBuilder.add();
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsForXConnect: Submited " + "next objective {} in device {}", nextId, deviceId);
        xConnectNextObjStore.put(key, nextId);
    });
}
#method_after
public void createGroupsForXConnect(DeviceId deviceId) {
    Map<VlanId, List<ConnectPoint>> xConnectsForDevice = deviceConfig.getXConnects();
    xConnectsForDevice.forEach((vlanId, connectPoints) -> {
        // Only proceed  the xConnect for given device
        for (ConnectPoint connectPoint : connectPoints) {
            if (!connectPoint.deviceId().equals(deviceId)) {
                return;
            }
        }
        // Check if the next obj is already in the store
        XConnectNextObjectiveStoreKey key = new XConnectNextObjectiveStoreKey(deviceId, vlanId);
        if (xConnectNextObjStore.containsKey(key)) {
            log.debug("Cross-connect Broadcast group for device {} and vlanId {} exists", deviceId, vlanId);
            return;
        }
        TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(vlanId).build();
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.BROADCAST).fromApp(appId).withMeta(metadata);
        connectPoints.forEach(connectPoint -> {
            TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
            tBuilder.setOutput(connectPoint.port());
            nextObjBuilder.addTreatment(tBuilder.build());
        });
        NextObjective nextObj = nextObjBuilder.add();
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsForXConnect: Submited next objective {} in device {}", nextId, deviceId);
        xConnectNextObjStore.put(key, nextId);
    });
}
#end_block

#method_before
// TODO: Use nextObjective APIs to handle the group chains
/*@Override
    protected void handleGroupEvent(GroupEvent event) {
        if (event.type() == GroupEvent.Type.GROUP_ADDED) {
            if (dependentGroups.get(event.subject().appCookie()) != null) {
                PolicyGroupIdentifier dependentGroupKey = dependentGroups.get(event.subject().appCookie());
                dependentGroups.remove(event.subject().appCookie());
                boolean fullyResolved = true;
                for (GroupBucketIdentifier bucketId:
                            dependentGroupKey.bucketIds()) {
                    if (bucketId.type() != BucketOutputType.GROUP) {
                        continue;
                    }
                    if (dependentGroups.containsKey(bucketId.outGroup())) {
                        fullyResolved = false;
                        break;
                    }
                }

                if (fullyResolved) {
                    List<GroupBucket> outBuckets = new ArrayList<GroupBucket>();
                    for (GroupBucketIdentifier bucketId:
                                dependentGroupKey.bucketIds()) {
                        TrafficTreatment.Builder tBuilder =
                                DefaultTrafficTreatment.builder();
                        if (bucketId.label() != NeighborSet.NO_EDGE_LABEL) {
                            tBuilder.pushMpls()
                                    .setMpls(MplsLabel.
                                             mplsLabel(bucketId.label()));
                        }
                        //TODO: BoS
                        if (bucketId.type() == BucketOutputType.PORT) {
                            DeviceId neighbor = portDeviceMap.
                                        get(bucketId.outPort());
                            tBuilder.setOutput(bucketId.outPort())
                                    .setEthDst(deviceConfig.
                                               getDeviceMac(neighbor))
                                     .setEthSrc(nodeMacAddr);
                        } else {
                            if (groupService.
                                    getGroup(deviceId,
                                             getGroupKey(bucketId.
                                                       outGroup())) == null) {
                                throw new IllegalStateException();
                            }
                            GroupId indirectGroupId = groupService.
                                    getGroup(deviceId,
                                             getGroupKey(bucketId.
                                                         outGroup())).id();
                            tBuilder.group(indirectGroupId);
                        }
                        outBuckets.add(DefaultGroupBucket.
                                       createSelectGroupBucket(tBuilder.build()));
                    }
                    GroupDescription desc = new
                            DefaultGroupDescription(deviceId,
                                                    GroupDescription.Type.SELECT,
                                                    new GroupBuckets(outBuckets));
                    groupService.addGroup(desc);
                }
            }
        }
    }*/
public PolicyGroupIdentifier generatePolicyGroupKey(String id, List<PolicyGroupParams> params) {
    List<GroupBucketIdentifier> bucketIds = new ArrayList<>();
    for (PolicyGroupParams param : params) {
        List<PortNumber> ports = param.getPorts();
        if (ports == null) {
            log.warn("generateGroupKey in sw {} with wrong " + "input parameters", deviceId);
            return null;
        }
        int labelStackSize = (param.getLabelStack() != null) ? param.getLabelStack().size() : 0;
        if (labelStackSize > 1) {
            for (PortNumber sp : ports) {
                PolicyGroupIdentifier previousGroupkey = null;
                for (int idx = 0; idx < param.getLabelStack().size(); idx++) {
                    int label = param.getLabelStack().get(idx);
                    if (idx == (labelStackSize - 1)) {
                        // Innermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        bucketIds.add(bucketId);
                    } else if (idx == 0) {
                        // Outermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        previousGroupkey = key;
                    } else {
                        // Intermediate Groups
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        previousGroupkey = key;
                    }
                }
            }
        } else {
            int label = -1;
            if (labelStackSize == 1) {
                label = param.getLabelStack().get(0);
            }
            for (PortNumber sp : ports) {
                GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                bucketIds.add(bucketId);
            }
        }
    }
    PolicyGroupIdentifier innermostGroupkey = null;
    if (!bucketIds.isEmpty()) {
        innermostGroupkey = new PolicyGroupIdentifier(id, params, bucketIds);
    }
    return innermostGroupkey;
}
#method_after
// TODO: Use nextObjective APIs to handle the group chains
/*
    @Override
    protected void handleGroupEvent(GroupEvent event) {}
    */
public PolicyGroupIdentifier generatePolicyGroupKey(String id, List<PolicyGroupParams> params) {
    List<GroupBucketIdentifier> bucketIds = new ArrayList<>();
    for (PolicyGroupParams param : params) {
        List<PortNumber> ports = param.getPorts();
        if (ports == null) {
            log.warn("generateGroupKey in sw {} with wrong " + "input parameters", deviceId);
            return null;
        }
        int labelStackSize = (param.getLabelStack() != null) ? param.getLabelStack().size() : 0;
        if (labelStackSize > 1) {
            for (PortNumber sp : ports) {
                PolicyGroupIdentifier previousGroupkey = null;
                for (int idx = 0; idx < param.getLabelStack().size(); idx++) {
                    int label = param.getLabelStack().get(idx);
                    if (idx == (labelStackSize - 1)) {
                        // Innermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        bucketIds.add(bucketId);
                    } else if (idx == 0) {
                        // Outermost Group
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        previousGroupkey = key;
                    } else {
                        // Intermediate Groups
                        GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, previousGroupkey);
                        PolicyGroupIdentifier key = new PolicyGroupIdentifier(id, Collections.singletonList(param), Collections.singletonList(bucketId));
                        previousGroupkey = key;
                    }
                }
            }
        } else {
            int label = -1;
            if (labelStackSize == 1) {
                label = param.getLabelStack().get(0);
            }
            for (PortNumber sp : ports) {
                GroupBucketIdentifier bucketId = new GroupBucketIdentifier(label, sp);
                bucketIds.add(bucketId);
            }
        }
    }
    PolicyGroupIdentifier innermostGroupkey = null;
    if (!bucketIds.isEmpty()) {
        innermostGroupkey = new PolicyGroupIdentifier(id, params, bucketIds);
    }
    return innermostGroupkey;
}
#end_block

#method_before
public VlanId getSubnetAssignedVlanId(DeviceId deviceId, Ip4Prefix subnet) {
    VlanId assignedVid = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
    if (assignedVid != null) {
        log.debug("Query for subnet:{} on device:{} returned assigned-vlan " + "{}", subnet, deviceId, assignedVid);
        return assignedVid;
    }
    // check mastership for the right to assign a vlan
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("This controller instance is not the master for device {}. " + "Cannot assign vlan-id for subnet {}", deviceId, subnet);
        return null;
    }
    // vlan assignment is expensive but done only once
    Set<Ip4Prefix> configuredSubnets = deviceConfiguration.getSubnets(deviceId);
    Set<Short> assignedVlans = new HashSet<>();
    Set<Ip4Prefix> unassignedSubnets = new HashSet<>();
    for (Ip4Prefix sub : configuredSubnets) {
        VlanId v = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, sub));
        if (v != null) {
            assignedVlans.add(v.toShort());
        } else {
            unassignedSubnets.add(sub);
        }
    }
    short nextAssignedVlan = ASSIGNED_VLAN_START;
    if (!assignedVlans.isEmpty()) {
        nextAssignedVlan = (short) (Collections.min(assignedVlans) - 1);
    }
    for (Ip4Prefix unsub : unassignedSubnets) {
        subnetVidStore.put(new SubnetAssignedVidStoreKey(deviceId, unsub), VlanId.vlanId(nextAssignedVlan--));
        log.info("Assigned vlan: {} to subnet: {} on device: {}", nextAssignedVlan + 1, unsub, deviceId);
    }
    return subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
}
#method_after
/**
 * Returns the vlan-id assigned to the subnet configured for a device.
 * If no vlan-id has been assigned, a new one is assigned out of a pool of ids,
 * if and only if this controller instance is the master for the device.
 * <p>
 * USAGE: The assigned vlans are meant to be applied to untagged packets on those
 * switches/pipelines that need this functionality. These vids are meant
 * to be used internally within a switch, and thus need to be unique only
 * on a switch level. Note that packets never go out on the wire with these
 * vlans. Currently, vlan ids are assigned from value 4093 down.
 * Vlan id 4094 expected to be used for all ports that are not assigned subnets.
 * Vlan id 4095 is reserved and unused. Only a single vlan id is assigned
 * per subnet.
 *
 * @param deviceId switch dpid
 * @param subnet IPv4 prefix for which assigned vlan is desired
 * @return VlanId assigned for the subnet on the device, or
 *         null if no vlan assignment was found and this instance is not
 *         the master for the device.
 */
public VlanId getSubnetAssignedVlanId(DeviceId deviceId, Ip4Prefix subnet) {
    VlanId assignedVid = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
    if (assignedVid != null) {
        log.debug("Query for subnet:{} on device:{} returned assigned-vlan " + "{}", subnet, deviceId, assignedVid);
        return assignedVid;
    }
    // check mastership for the right to assign a vlan
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("This controller instance is not the master for device {}. " + "Cannot assign vlan-id for subnet {}", deviceId, subnet);
        return null;
    }
    // vlan assignment is expensive but done only once
    Set<Ip4Prefix> configuredSubnets = deviceConfiguration.getSubnets(deviceId);
    Set<Short> assignedVlans = new HashSet<>();
    Set<Ip4Prefix> unassignedSubnets = new HashSet<>();
    for (Ip4Prefix sub : configuredSubnets) {
        VlanId v = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, sub));
        if (v != null) {
            assignedVlans.add(v.toShort());
        } else {
            unassignedSubnets.add(sub);
        }
    }
    short nextAssignedVlan = ASSIGNED_VLAN_START;
    if (!assignedVlans.isEmpty()) {
        nextAssignedVlan = (short) (Collections.min(assignedVlans) - 1);
    }
    for (Ip4Prefix unsub : unassignedSubnets) {
        subnetVidStore.put(new SubnetAssignedVidStoreKey(deviceId, unsub), VlanId.vlanId(nextAssignedVlan--));
        log.info("Assigned vlan: {} to subnet: {} on device: {}", nextAssignedVlan + 1, unsub, deviceId);
    }
    return subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
}
#end_block

#method_before
@Override
public Map<VlanId, List<ConnectPoint>> getXConnects() {
    return this.xConnects;
}
#method_after
@Override
public Map<VlanId, List<ConnectPoint>> getXConnects() {
    return xConnects;
}
#end_block

#method_before
public void populateXConnectVlanFilters(DeviceId deviceId) {
    Map<VlanId, List<ConnectPoint>> xConnectsForDevice = config.getXConnects();
    xConnectsForDevice.forEach((vlanId, connectPoints) -> {
        // Only proceed  the xConnect for given device
        for (ConnectPoint connectPoint : connectPoints) {
            if (!connectPoint.deviceId().equals(deviceId)) {
                return;
            }
        }
        connectPoints.forEach(connectPoint -> {
            FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
            fob.withKey(Criteria.matchInPort(connectPoint.port())).addCondition(Criteria.matchVlanId(vlanId)).withPriority(XCONNECT_PRIORITY);
            fob.permit().fromApp(srManager.appId);
            srManager.flowObjectiveService.filter(deviceId, fob.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FILTER)));
        });
    });
}
#method_after
public void populateXConnectVlanFilters(DeviceId deviceId) {
    Map<VlanId, List<ConnectPoint>> xConnectsForDevice = config.getXConnects();
    xConnectsForDevice.forEach((vlanId, connectPoints) -> {
        // Only proceed  the xConnect for given device
        for (ConnectPoint connectPoint : connectPoints) {
            if (!connectPoint.deviceId().equals(deviceId)) {
                return;
            }
        }
        connectPoints.forEach(connectPoint -> {
            FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
            fob.withKey(Criteria.matchInPort(connectPoint.port())).addCondition(Criteria.matchVlanId(vlanId)).addCondition(Criteria.matchEthDst(MacAddress.NONE)).withPriority(XCONNECT_PRIORITY);
            fob.permit().fromApp(srManager.appId);
            srManager.flowObjectiveService.filter(deviceId, fob.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FILTER)));
        });
    });
}
#end_block

#method_before
private void createL2InterfaceGroup(NextObjective nextObj) {
    // only allowed actions are vlan pop and outport
    TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
    PortNumber portNum = null;
    for (Instruction ins : nextObj.next().iterator().next().allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case VLAN_POP:
                    ttb.add(l2ins);
                    break;
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port();
            ttb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in simple nextObjectives:  {}", ins.type());
        }
    }
    VlanId vlanId = readVlanFromMeta(nextObj);
    if (vlanId == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return;
    }
    // assemble information for ofdpa l2interface group
    Integer l2groupId = L2INTERFACEMASK | (vlanId.toShort() << 16) | (int) portNum.toLong();
    // a globally unique groupkey that is different for ports in the same devices
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanId, portNum.toLong());
    final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
    // create group description for the l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(ttb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
    // create object for local and distributed storage
    Deque<GroupKey> singleKey = new ArrayDeque<>();
    singleKey.addFirst(l2groupkey);
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(singleKey), nextObj);
    // store l2groupkey for the nextObjective that depends on it
    updatePendingNextObjective(l2groupkey, ofdpaGrp);
    // send the group description to the group service
    groupService.addGroup(l2groupDescription);
}
#method_after
private void createL2InterfaceGroup(NextObjective nextObj) {
    // only allowed actions are vlan pop and outport
    TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
    PortNumber portNum = null;
    for (Instruction ins : nextObj.next().iterator().next().allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case VLAN_POP:
                    ttb.add(l2ins);
                    break;
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port();
            ttb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in simple nextObjectives:  {}", ins.type());
        }
    }
    VlanId vlanId = readVlanFromMeta(nextObj);
    if (vlanId == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanId.toShort() << 16) | (int) portNum.toLong();
    // a globally unique groupkey that is different for ports in the same devices
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanId, portNum.toLong());
    final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
    // create group description for the l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(ttb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
    // create object for local and distributed storage
    Deque<GroupKey> singleKey = new ArrayDeque<>();
    singleKey.addFirst(l2groupkey);
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(singleKey), nextObj);
    // store l2groupkey for the nextObjective that depends on it
    updatePendingNextObjective(l2groupkey, ofdpaGrp);
    // send the group description to the group service
    groupService.addGroup(l2groupDescription);
}
#end_block

#method_before
private GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    outerTtb.setEthDst(((L2ModificationInstruction.ModEtherInstruction) l2ins).mac());
                    break;
                case ETH_SRC:
                    outerTtb.setEthSrc(((L2ModificationInstruction.ModEtherInstruction) l2ins).mac());
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    Integer l2groupId = L2INTERFACEMASK | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same devices
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        Integer mplsgroupId = MPLSINTERFACEMASK | (int) portNum;
        // using mplsinterfacemask in groupkey to differentiate from l2interface
        int mplsgk = MPLSINTERFACEMASK | (0x00ffffff & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey mplsgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(mplsgk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        Integer l3groupId = L3UNICASTMASK | (int) portNum;
        int l3gk = L3UNICASTMASK | (0x0fffffff & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey l3groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3gk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#method_after
private GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    outerTtb.setEthDst(((L2ModificationInstruction.ModEtherInstruction) l2ins).mac());
                    break;
                case ETH_SRC:
                    outerTtb.setEthSrc(((L2ModificationInstruction.ModEtherInstruction) l2ins).mac());
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same devices
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        int mplsgroupId = MPLS_INTERFACE_TYPE | (int) portNum;
        // using mplsinterfacemask in groupkey to differentiate from l2interface
        int mplsgk = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey mplsgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(mplsgk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        int l3groupId = L3_UNICAST_TYPE | (int) portNum;
        int l3gk = L3_UNICAST_TYPE | (TYPE_MASK & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey l3groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3gk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#end_block

#method_before
private void processBroadcastNextObjective(NextObjective nextObj) {
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    VlanId vlanId = readVlanFromMeta(nextObj);
    if (vlanId == null) {
        log.warn("Required VLAN ID info in nextObj metadata but not found. Aborting");
        return;
    }
    // each treatment is converted to an L2 interface group
    List<GroupDescription> l2interfaceGroupDescs = new ArrayList<>();
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // assemble info for l2 interface group
        int l2gk = l2InterfaceGroupKey(deviceId, vlanId, portNum.toLong());
        final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
        Integer l2groupId = L2INTERFACEMASK | (vlanId.toShort() << 16) | (int) portNum.toLong();
        GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2interfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(l2groupkey);
        // store the info needed to create this group
        l2interfaceGroupDescs.add(l2interfaceGroupDescription);
        allGroupKeys.add(gkeyChain);
    }
    // assemble info for l2 flood group
    Integer l2floodgroupId = L2FLOODMASK | (vlanId.toShort() << 16) | nextObj.id();
    int l2floodgk = L2FLOODMASK | nextObj.id() << 12;
    final GroupKey l2floodgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = new ArrayList<>();
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    }
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, l2interfaceGroupDescs.size(), false);
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l2floodgroupkey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l2floodgroupkey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        // store all l2groupkeys with the groupChainElem for the l2floodgroup
        // that depends on it
        updatePendingGroups(l2intGrpDesc.appCookie(), gce);
        // send groups for all l2 interface groups
        groupService.addGroup(l2intGrpDesc);
    }
}
#method_after
private void processBroadcastNextObjective(NextObjective nextObj) {
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    VlanId vlanId = readVlanFromMeta(nextObj);
    if (vlanId == null) {
        log.warn("Required VLAN ID info in nextObj metadata but not found. Aborting");
        return;
    }
    // each treatment is converted to an L2 interface group
    List<GroupDescription> l2interfaceGroupDescs = new ArrayList<>();
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // assemble info for l2 interface group
        int l2gk = l2InterfaceGroupKey(deviceId, vlanId, portNum.toLong());
        final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
        int l2groupId = L2_INTERFACE_TYPE | (vlanId.toShort() << 16) | (int) portNum.toLong();
        GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2interfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(l2groupkey);
        // store the info needed to create this group
        l2interfaceGroupDescs.add(l2interfaceGroupDescription);
        allGroupKeys.add(gkeyChain);
    }
    // assemble info for l2 flood group
    Integer l2floodgroupId = L2_FLOOD_TYPE | (vlanId.toShort() << 16) | nextObj.id();
    int l2floodgk = L2_FLOOD_TYPE | nextObj.id() << 12;
    final GroupKey l2floodgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = new ArrayList<>();
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    }
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, l2interfaceGroupDescs.size(), false);
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l2floodgroupkey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l2floodgroupkey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        // store all l2groupkeys with the groupChainElem for the l2floodgroup
        // that depends on it
        updatePendingGroups(l2intGrpDesc.appCookie(), gce);
        // send groups for all l2 interface groups
        groupService.addGroup(l2intGrpDesc);
    }
}
#end_block

#method_before
private void processHashedNextObjective(NextObjective nextObj) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObj, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group
    List<GroupBucket> l3ecmpGroupBuckets = new ArrayList<>();
    for (GroupInfo gi : unsentGroups) {
        // create ECMP bucket to point to the outer group
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(gi.outerGrpDesc.givenGroupId()));
        GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
        l3ecmpGroupBuckets.add(sbucket);
    }
    int l3ecmpGroupId = L3ECMPMASK | nextObj.id() << 12;
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3ecmpGroupId));
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(l3ecmpGroupBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObj.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, l3ecmpGroupBuckets.size(), false);
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l3ecmpGroupKey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l3ecmpGroupKey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l3ecmpGroupKey, ofdpaGrp);
    log.debug("Trying L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObj.id());
    // finally we are ready to send the innermost groups
    for (GroupInfo gi : unsentGroups) {
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerGrpDesc.givenGroupId()), deviceId);
        updatePendingGroups(gi.outerGrpDesc.appCookie(), l3ecmpGce);
        groupService.addGroup(gi.innerGrpDesc);
    }
}
#method_after
private void processHashedNextObjective(NextObjective nextObj) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObj, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group
    List<GroupBucket> l3ecmpGroupBuckets = new ArrayList<>();
    for (GroupInfo gi : unsentGroups) {
        // create ECMP bucket to point to the outer group
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(gi.outerGrpDesc.givenGroupId()));
        GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
        l3ecmpGroupBuckets.add(sbucket);
    }
    int l3ecmpGroupId = L3_ECMP_TYPE | nextObj.id() << 12;
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3ecmpGroupId));
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(l3ecmpGroupBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObj.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, l3ecmpGroupBuckets.size(), false);
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l3ecmpGroupKey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l3ecmpGroupKey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l3ecmpGroupKey, ofdpaGrp);
    log.debug("Trying L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObj.id());
    // finally we are ready to send the innermost groups
    for (GroupInfo gi : unsentGroups) {
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerGrpDesc.givenGroupId()), deviceId);
        updatePendingGroups(gi.outerGrpDesc.appCookie(), l3ecmpGce);
        groupService.addGroup(gi.innerGrpDesc);
    }
}
#end_block

#method_before
private void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).mplsLabel();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.outerGrpDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.outerGrpDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpngroupId = L3VPNMASK | l3vpnindex.incrementAndGet();
            int l3vpngk = L3VPNMASK | nextObj.id() << 12 | l3vpnindex.get();
            GroupKey l3vpngroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3vpngk));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.outerGrpDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.outerGrpDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.outerGrpDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#method_after
private void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).mplsLabel();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.outerGrpDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.outerGrpDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | l3vpnindex.incrementAndGet();
            int l3vpngk = MPLS_L3VPN_SUBTYPE | nextObj.id() << 12 | l3vpnindex.get();
            GroupKey l3vpngroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3vpngk));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.outerGrpDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.outerGrpDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.outerGrpDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#end_block

#method_before
protected void addBucketToGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("AddBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        return;
    }
    if (nextObjective.next().size() > 1) {
        log.warn("Only one bucket can be added at a time");
        return;
    }
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group bucket to add
    // only one bucket, so only one group-chain
    GroupInfo gi = unsentGroups.get(0);
    TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
    ttb.group(new DefaultGroupId(gi.outerGrpDesc.givenGroupId()));
    GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
    // recreate the original L3 ECMP group id and description
    int l3ecmpGroupId = L3ECMPMASK | nextObjective.id() << 12;
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3ecmpGroupId));
    // Although GroupDescriptions are not necessary for adding buckets to
    // existing groups, we use one in the GroupChainElem. When the latter is
    // processed, the info will be extracted for the bucketAdd call to groupService
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(Collections.singletonList(sbucket)), l3ecmpGroupKey, l3ecmpGroupId, nextObjective.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, 1, true);
    // update original NextGroup with new bucket-chain
    // don't need to update pendingNextObjectives -- group already exists
    Deque<GroupKey> newBucketChain = allGroupKeys.get(0);
    newBucketChain.addFirst(l3ecmpGroupKey);
    List<Deque<GroupKey>> allOriginalKeys = OFDPA2Pipeline.appKryo.deserialize(next.data());
    allOriginalKeys.add(newBucketChain);
    flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allOriginalKeys, nextObjective));
    log.debug("Adding to L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObjective.id());
    // send the innermost group
    log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerGrpDesc.givenGroupId()), deviceId);
    updatePendingGroups(gi.outerGrpDesc.appCookie(), l3ecmpGce);
    groupService.addGroup(gi.innerGrpDesc);
}
#method_after
protected void addBucketToGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("AddBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        return;
    }
    if (nextObjective.next().size() > 1) {
        log.warn("Only one bucket can be added at a time");
        return;
    }
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group bucket to add
    // only one bucket, so only one group-chain
    GroupInfo gi = unsentGroups.get(0);
    TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
    ttb.group(new DefaultGroupId(gi.outerGrpDesc.givenGroupId()));
    GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
    // recreate the original L3 ECMP group id and description
    int l3ecmpGroupId = L3_ECMP_TYPE | nextObjective.id() << 12;
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3ecmpGroupId));
    // Although GroupDescriptions are not necessary for adding buckets to
    // existing groups, we use one in the GroupChainElem. When the latter is
    // processed, the info will be extracted for the bucketAdd call to groupService
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(Collections.singletonList(sbucket)), l3ecmpGroupKey, l3ecmpGroupId, nextObjective.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, 1, true);
    // update original NextGroup with new bucket-chain
    // don't need to update pendingNextObjectives -- group already exists
    Deque<GroupKey> newBucketChain = allGroupKeys.get(0);
    newBucketChain.addFirst(l3ecmpGroupKey);
    List<Deque<GroupKey>> allOriginalKeys = OFDPA2Pipeline.appKryo.deserialize(next.data());
    allOriginalKeys.add(newBucketChain);
    flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allOriginalKeys, nextObjective));
    log.debug("Adding to L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObjective.id());
    // send the innermost group
    log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerGrpDesc.givenGroupId()), deviceId);
    updatePendingGroups(gi.outerGrpDesc.appCookie(), l3ecmpGce);
    groupService.addGroup(gi.innerGrpDesc);
}
#end_block

#method_before
private int l2InterfaceGroupKey(DeviceId deviceId, VlanId vlanId, long portNumber) {
    // NOTE: keep the lower 6-bit for port
    // since the port number is unlikely to be larger than 64
    int portLowerBits = (int) portNumber & 0x3f;
    long portHigherBits = portNumber & 0xffffffffffffffc0L;
    int hash = Objects.hashCode(deviceId, vlanId, portHigherBits);
    return L2INTERFACEMASK | (0x0fffffff & hash << 6) | portLowerBits;
}
#method_after
private int l2InterfaceGroupKey(DeviceId deviceId, VlanId vlanId, long portNumber) {
    int portLowerBits = (int) portNumber & PORT_LOWER_BITS_MASK;
    long portHigherBits = portNumber & PORT_HIGHER_BITS_MASK;
    int hash = Objects.hashCode(deviceId, vlanId, portHigherBits);
    return L2_INTERFACE_TYPE | (TYPE_MASK & hash << 6) | portLowerBits;
}
#end_block

#method_before
@Override
public ObjectNode encode(Application app, CodecContext context) {
    checkNotNull(app, "Application cannot be null");
    ApplicationService service = context.getService(ApplicationService.class);
    return context.mapper().createObjectNode().put("name", app.id().name()).put("id", app.id().id()).put("version", app.version().toString()).put("category", app.category()).put("description", app.description()).put("readme", app.readme()).put("origin", app.origin()).put("url", app.url()).put("permissions", // FIXME: change to an array
    app.permissions().toString()).put("featuresRepo", app.featuresRepo().isPresent() ? app.featuresRepo().get().toString() : "").put("features", // FIXME: change to an array
    app.features().toString()).put("requiredApps", // FIXME: change to an array
    app.requiredApps().toString()).put("state", service.getState(app.id()).toString());
}
#method_after
@Override
public ObjectNode encode(Application app, CodecContext context) {
    checkNotNull(app, "Application cannot be null");
    ApplicationService service = context.getService(ApplicationService.class);
    return context.mapper().createObjectNode().put("name", app.id().name()).put("id", app.id().id()).put("version", app.version().toString()).put("category", app.category()).put("description", StringEscapeUtils.escapeJson(app.description())).put("readme", StringEscapeUtils.escapeJson(app.readme())).put("origin", app.origin()).put("url", app.url()).put("permissions", // FIXME: change to an array
    app.permissions().toString()).put("featuresRepo", app.featuresRepo().isPresent() ? app.featuresRepo().get().toString() : "").put("features", // FIXME: change to an array
    app.features().toString()).put("requiredApps", // FIXME: change to an array
    app.requiredApps().toString()).put("state", service.getState(app.id()).toString());
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    registerDhcpInfo(openstackPort);
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.fixedIps().isEmpty()) {
        registerDhcpInfo(openstackPort);
    }
}
#end_block

#method_before
@Override
public OpenstackPort port(Port port) {
    Collection<OpenstackPort> ports = restHandler.getPorts();
    String uuid = port.annotations().value("portName").substring(3);
    return ports.stream().filter(p -> p.id().startsWith(uuid)).findFirst().orElse(null);
}
#method_after
@Override
public OpenstackPort port(Port port) {
    Collection<OpenstackPort> ports = restHandler.getPorts();
    String uuid = port.annotations().value(PORTNAME).substring(3);
    return ports.stream().filter(p -> p.id().startsWith(uuid)).findFirst().orElse(null);
}
#end_block

#method_before
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value("portName").startsWith("tap") || port.annotations().value("portName").startsWith("qr")).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null) {
                if (!doNotPushFlows) {
                    rulePopulator.populateSwitchingRules(device, vmPort);
                }
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#method_after
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    Collection<OpenstackNetwork> networks = restHandler.getNetworks();
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_VM) || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null) {
                if (!doNotPushFlows) {
                    rulePopulator.populateSwitchingRules(device, vmPort);
                    updatePortMap(device.id(), vmPort, networks, osPort);
                }
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#end_block

#method_before
private void processHostRemoved(Host host) {
    log.debug("host {} was removed", host.toString());
    try {
        if (!doNotPushFlows) {
            IpAddress hostIp = host.ipAddresses().stream().filter(ip -> ip.isIp4()).findAny().orElse(null);
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.removeSwitchingRules(host.location().deviceId(), hostIp.getIp4Address());
        }
        dhcpService.removeStaticMapping(host.mac());
    } catch (NoSuchElementException e) {
        log.error("No IP address is assigned.");
    }
}
#method_after
private void processHostRemoved(Host host) {
    log.debug("host {} was removed", host.toString());
}
#end_block

#method_before
private void registerDhcpInfo(OpenstackPort openstackPort) {
    Ip4Address ip4Address;
    Ip4Address subnetMask;
    Ip4Address dhcpServer;
    Ip4Address gatewayIPAddress;
    Ip4Address domainServer;
    OpenstackSubnet openstackSubnet;
    ip4Address = (Ip4Address) openstackPort.fixedIps().values().toArray()[0];
    openstackSubnet = restHandler.getSubnets().stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    subnetMask = Ip4Address.valueOf(buildSubnetMask(openstackSubnet.cidr()));
    gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    dhcpServer = gatewayIPAddress;
    // TODO: supports multiple DNS servers
    if (openstackSubnet.dnsNameservers().isEmpty()) {
        domainServer = Ip4Address.valueOf("8.8.8.8");
    } else {
        domainServer = openstackSubnet.dnsNameservers().get(0);
    }
    List<Ip4Address> options = Lists.newArrayList();
    options.add(subnetMask);
    options.add(dhcpServer);
    options.add(gatewayIPAddress);
    options.add(domainServer);
    dhcpService.setStaticMapping(openstackPort.macAddress(), ip4Address, true, options);
}
#method_after
private void registerDhcpInfo(OpenstackPort openstackPort) {
    Ip4Address ip4Address;
    Ip4Address subnetMask;
    Ip4Address gatewayIPAddress;
    Ip4Address dhcpServer;
    Ip4Address domainServer;
    OpenstackSubnet openstackSubnet;
    ip4Address = (Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null);
    openstackSubnet = restHandler.getSubnets().stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    subnetMask = Ip4Address.valueOf(buildSubnetMask(openstackSubnet.cidr()));
    gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    dhcpServer = gatewayIPAddress;
    // TODO: supports multiple DNS servers
    if (openstackSubnet.dnsNameservers().isEmpty()) {
        domainServer = Ip4Address.valueOf("8.8.8.8");
    } else {
        domainServer = openstackSubnet.dnsNameservers().get(0);
    }
    List<Ip4Address> options = Lists.newArrayList();
    options.add(subnetMask);
    options.add(dhcpServer);
    options.add(gatewayIPAddress);
    options.add(domainServer);
    dhcpService.setStaticMapping(openstackPort.macAddress(), ip4Address, true, options);
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#end_block

#method_before
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_UPDATED:
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortAdded((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortAdded((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_UPDATED:
                Port port = (Port) deviceEvent.subject();
                if (port.isEnabled()) {
                    processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                }
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService);
    initializeFlowRules();
}
#method_after
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService, hostService);
    initializeFlowRules();
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        configureNetwork();
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        networkEventExcutorService.execute(this::configureNetwork);
    }
}
#end_block

#method_before
private void populateFlowRulesForTrafficToSameCnode(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value("portName"));
    String portName = port.annotations().value("portName");
    String vni = getVniForPort(portName);
    MacAddress vmMacAddress = getVmMacAddressForPort(portName);
    if (vmIp != null) {
        setFlowRuleForVMsInSameCnode(vmIp, device.id(), port, vni, vmMacAddress);
    }
}
#method_after
private void populateFlowRulesForTrafficToSameCnode(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value("portName"));
    String portName = port.annotations().value("portName");
    String vni = getVniForPort(portName);
    if (vmIp != null) {
        setFlowRuleForVMsInSameCnode(vmIp, device.id(), port, vni);
    }
}
#end_block

#method_before
private void setFlowRuleForVMsInSameCnode(Ip4Address ip4Address, DeviceId id, Port port, String vni, MacAddress vmMacAddress) {
    // For L2 Switching Case
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip4Address.toIpPrefix()).matchTunnelId(Long.parseLong(vni));
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void setFlowRuleForVMsInSameCnode(Ip4Address ip4Address, DeviceId id, Port port, String vni) {
    // For L2 Switching Case
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip4Address.toIpPrefix()).matchTunnelId(Long.parseLong(vni));
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#end_block

#method_before
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    MacAddress vmMac = getVmMacAddressForPort(portName);
    String vni = getVniForPort(portName);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(device)) {
            deviceService.getPorts(d.id()).forEach(p -> {
                String pName = p.annotations().value("portName");
                if (!p.equals(port) && vni.equals(getVniForPort(pName))) {
                    String cidx = d.annotations().value("channelId");
                    Ip4Address hostIpx = Ip4Address.valueOf(cidx.split(":")[0]);
                    MacAddress vmMacx = getVmMacAddressForPort(pName);
                    Ip4Address fixedIpx = getFixedIpAddressForPort(pName);
                    // Need to support the router port which is always disabled
                    if (port.isEnabled() || port.annotations().value("portName").startsWith("qr")) {
                        setVxLanFlowRule(vni, device.id(), hostIpx, fixedIpx, vmMacx);
                        setVxLanFlowRule(vni, d.id(), hostIpAddress, fixedIp, vmMac);
                    }
                }
            });
        }
    });
}
#method_after
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    String vni = getVniForPort(portName);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(device)) {
            deviceService.getPorts(d.id()).forEach(p -> {
                String pName = p.annotations().value("portName");
                if (!p.equals(port) && vni.equals(getVniForPort(pName))) {
                    String cidx = d.annotations().value("channelId");
                    Ip4Address hostIpx = Ip4Address.valueOf(cidx.split(":")[0]);
                    Ip4Address fixedIpx = getFixedIpAddressForPort(pName);
                    if (port.isEnabled() || port.annotations().value("portName").startsWith(OpenstackSwitchingManager.PORTNAME_PREFIX_ROUTER)) {
                        setVxLanFlowRule(vni, device.id(), hostIpx, fixedIpx);
                        setVxLanFlowRule(vni, d.id(), hostIpAddress, fixedIp);
                    }
                }
            });
        }
    });
}
#end_block

#method_before
private void setVxLanFlowRule(String vni, DeviceId id, Ip4Address hostIp, Ip4Address vmIp, MacAddress vmMac) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(vni)).matchIPDst(vmIp.toIpPrefix());
    tBuilder.extension(buildNiciraExtenstion(id, hostIp), id).setOutput(getTunnelPort(id));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void setVxLanFlowRule(String vni, DeviceId deviceId, Ip4Address hostIp, Ip4Address vmIp) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(vni)).matchIPDst(vmIp.toIpPrefix());
    tBuilder.extension(buildNiciraExtenstion(deviceId, hostIp), deviceId).setOutput(getTunnelPort(deviceId));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
public void removeSwitchingRules(DeviceId deviceId, Ip4Address vmIp) {
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp);
    deviceService.getAvailableDevices().forEach(device -> {
        if (!device.id().equals(deviceId)) {
            removeVxLanFlowRule(device.id(), vmIp);
        }
    });
}
#method_after
public void removeSwitchingRules(Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value("portName"));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = removedPort.number();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#end_block

#method_before
private void removeFlowRuleForVMsInSameCnode(DeviceId id, Ip4Address vmIp) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeFlowRuleForVMsInSameCnode(DeviceId deviceId, Ip4Address vmIp, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private void removeVxLanFlowRule(DeviceId id, Ip4Address vmIp) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    // XXX: Later, more matches will be added when multiple table is implemented.
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeVxLanFlowRule(DeviceId deviceId, Ip4Address vmIp, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchIPDst(vmIp.toIpPrefix());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private PortNumber getTunnelPort(DeviceId id) {
    Port port = deviceService.getPorts(id).stream().filter(p -> p.annotations().value("portName").equals("vxlan")).findAny().orElse(null);
    if (port == null) {
        log.error("No TunnelPort was created.");
        return null;
    }
    return port.number();
}
#method_after
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value("portName").equals(OpenstackSwitchingManager.PORTNAME_PREFIX_TUNNEL)).findAny().orElse(null);
    if (port == null) {
        log.error("No TunnelPort was created.");
        return null;
    }
    return port.number();
}
#end_block

#method_before
public MacAddress getMacaddr() {
    return macaddr;
}
#method_after
public MacAddress getMacaddr() {
    return macAddr;
}
#end_block

#method_before
public IpAddress getIpaddr() {
    return ipaddr;
}
#method_after
public IpAddress getIpaddr() {
    return ipAddr;
}
#end_block

#method_before
public void setIpaddr(IpAddress ipaddr) {
    this.ipaddr = ipaddr;
}
#method_after
public void setIpaddr(IpAddress ipAddr) {
    this.ipAddr = ipAddr;
}
#end_block

#method_before
public short getHoldtime() {
    return holdtime;
}
#method_after
public short getHoldtime() {
    return holdTime;
}
#end_block

#method_before
public void setHoldtime(short holdtime) {
    this.holdtime = holdtime;
}
#method_after
public void setHoldtime(short holdTime) {
    this.holdTime = holdTime;
}
#end_block

#method_before
public int getGenid() {
    return genid;
}
#method_after
public int getGenid() {
    return genId;
}
#end_block

#method_before
public void setGenid(int genid) {
    this.genid = genid;
}
#method_after
public void setGenid(int genId) {
    this.genId = genId;
}
#end_block

#method_before
public boolean addOptions(Map<Short, PIMHelloOption> opts) {
    boolean changed = false;
    for (PIMHelloOption opt : opts.values()) {
        Short otype = opt.getOptType();
        ByteBuffer val = ByteBuffer.wrap(opt.getValue());
        if (otype == PIMHelloOption.OPT_ADDRLIST) {
        // TODO: Must implement someday
        } else if (otype == PIMHelloOption.OPT_GENID) {
            Integer newval = val.getInt();
            if (newval != this.genid) {
                this.genid = newval;
                changed = true;
            }
        } else if (otype == PIMHelloOption.OPT_HOLDTIME) {
            Short newval = val.getShort();
            if (newval != this.holdtime) {
                this.holdtime = newval;
                changed = true;
            }
        } else if (otype == PIMHelloOption.OPT_PRIORITY) {
            Integer newval = val.getInt();
            if (newval != this.priority) {
                this.priority = newval;
                changed = true;
            }
        } else if (otype == PIMHelloOption.OPT_PRUNEDELAY) {
            Integer newval = val.getInt();
            if (newval != this.pruneDelay) {
                this.pruneDelay = newval;
                changed = true;
            }
        } else {
            log.warn("received unknown pim hello options" + otype);
        }
    }
    return changed;
}
#method_after
public boolean addOptions(Map<Short, PIMHelloOption> opts) {
    boolean changed = false;
    for (PIMHelloOption opt : opts.values()) {
        Short otype = opt.getOptType();
        ByteBuffer val = ByteBuffer.wrap(opt.getValue());
        if (otype == PIMHelloOption.OPT_ADDRLIST) {
        // TODO: Will implement someday
        } else if (otype == PIMHelloOption.OPT_GENID) {
            int newval = val.getInt();
            if (newval != genId) {
                genId = newval;
                changed = true;
            }
        } else if (otype == PIMHelloOption.OPT_HOLDTIME) {
            short newval = val.getShort();
            if (newval != holdTime) {
                holdTime = newval;
                changed = true;
            }
        } else if (otype == PIMHelloOption.OPT_PRIORITY) {
            int newval = val.getInt();
            if (newval != priority) {
                priority = newval;
                changed = true;
            }
        } else if (otype == PIMHelloOption.OPT_PRUNEDELAY) {
            int newval = val.getInt();
            if (newval != pruneDelay) {
                pruneDelay = newval;
                changed = true;
            }
        } else {
            log.warn("received unknown pim hello options" + otype);
        }
    }
    return changed;
}
#end_block

#method_before
public void refreshTimestamp() {
    this.lastReferesh = Calendar.getInstance().getTime();
}
#method_after
public void refreshTimestamp() {
    lastRefresh = Calendar.getInstance().getTime();
}
#end_block

#method_before
public Interface getInterface() {
    return this.onosInterface;
}
#method_after
public Interface getInterface() {
    return onosInterface;
}
#end_block

#method_before
public PIMInterface setInterface(Interface intf) {
    this.onosInterface = intf;
    return this;
}
#method_after
public PIMInterface setInterface(Interface intf) {
    onosInterface = intf;
    return this;
}
#end_block

#method_before
public Set<InterfaceIpAddress> getIpAddresses() {
    return this.onosInterface.ipAddresses();
}
#method_after
public Set<InterfaceIpAddress> getIpAddresses() {
    return onosInterface.ipAddresses();
}
#end_block

#method_before
public short getHoldtime() {
    return this.holdtime;
}
#method_after
public short getHoldtime() {
    return holdtime;
}
#end_block

#method_before
public int getPruneDelay() {
    return this.pruneDelay;
}
#method_after
public int getPruneDelay() {
    return pruneDelay;
}
#end_block

#method_before
public int getPriority() {
    return this.priority;
}
#method_after
public int getPriority() {
    return priority;
}
#end_block

#method_before
public int getGenid() {
    return this.genid;
}
#method_after
public int getGenid() {
    return genid;
}
#end_block

#method_before
public void processHello(Ethernet ethPkt) {
    // We'll need to save our neighbors MAC address
    MacAddress nbrmac = ethPkt.getSourceMAC();
    // And we'll need to save neighbors IP Address.
    IPv4 iphdr = (IPv4) ethPkt.getPayload();
    IpAddress srcip = IpAddress.valueOf(iphdr.getSourceAddress());
    PIM pimhdr = (PIM) iphdr.getPayload();
    if (pimhdr.getPimMsgType() != PIM.TYPE_HELLO) {
        log.error("process Hello has received a non hello packet type: " + pimhdr.getPimMsgType());
        return;
    }
    // get the DR values for later calculation
    PIMNeighbor dr = this.pimNeighbors.get(this.drIpaddress);
    checkNotNull(dr);
    IpAddress drip = this.drIpaddress;
    Integer drpri = dr.getPriority();
    // Assume we do not need to run a DR election
    boolean reElectDr = false;
    boolean genidChanged = false;
    PIMHello hello = (PIMHello) pimhdr.getPayload();
    // Determine if we already have a PIMNeighbor
    PIMNeighbor nbr = pimNeighbors.getOrDefault(srcip, null);
    if (nbr == null) {
        nbr = new PIMNeighbor(srcip, hello.getOptions());
        checkNotNull(nbr);
    } else {
        Integer previousGenid = nbr.getGenid();
        nbr.addOptions(hello.getOptions());
        if (previousGenid != nbr.getGenid()) {
            genidChanged = true;
        }
    }
    // Refresh this neighbors timestamp
    nbr.refreshTimestamp();
    /*
         * the election method will frist determine if an election
         * needs to be run, if so it will run the election.  The
         * IP address of the DR will be returned.  If the IP address
         * of the DR is different from what we already have we know a
         * new DR has been elected.
         */
    IpAddress electedIp = this.election(nbr, drip, drpri);
    if (drip.compareTo(electedIp) != 0) {
        // we have a new DR.
        this.drIpaddress = electedIp;
    }
}
#method_after
public void processHello(Ethernet ethPkt) {
    // We'll need to save our neighbors MAC address
    MacAddress nbrmac = ethPkt.getSourceMAC();
    // And we'll need to save neighbors IP Address.
    IPv4 iphdr = (IPv4) ethPkt.getPayload();
    IpAddress srcip = IpAddress.valueOf(iphdr.getSourceAddress());
    PIM pimhdr = (PIM) iphdr.getPayload();
    if (pimhdr.getPimMsgType() != PIM.TYPE_HELLO) {
        log.error("process Hello has received a non hello packet type: " + pimhdr.getPimMsgType());
        return;
    }
    // get the DR values for later calculation
    PIMNeighbor dr = pimNeighbors.get(drIpaddress);
    checkNotNull(dr);
    IpAddress drip = drIpaddress;
    int drpri = dr.getPriority();
    // Assume we do not need to run a DR election
    boolean reElectDr = false;
    boolean genidChanged = false;
    PIMHello hello = (PIMHello) pimhdr.getPayload();
    // Determine if we already have a PIMNeighbor
    PIMNeighbor nbr = pimNeighbors.getOrDefault(srcip, null);
    if (nbr == null) {
        nbr = new PIMNeighbor(srcip, hello.getOptions());
        checkNotNull(nbr);
    } else {
        Integer previousGenid = nbr.getGenid();
        nbr.addOptions(hello.getOptions());
        if (previousGenid != nbr.getGenid()) {
            genidChanged = true;
        }
    }
    // Refresh this neighbors timestamp
    nbr.refreshTimestamp();
    /*
         * the election method will frist determine if an election
         * needs to be run, if so it will run the election.  The
         * IP address of the DR will be returned.  If the IP address
         * of the DR is different from what we already have we know a
         * new DR has been elected.
         */
    IpAddress electedIp = election(nbr, drip, drpri);
    if (!drip.equals(electedIp)) {
        // we have a new DR.
        drIpaddress = electedIp;
    }
}
#end_block

#method_before
private IpAddress election(PIMNeighbor nbr, IpAddress drip, Integer drpri) {
    IpAddress nbrip = nbr.getIpaddr();
    if (nbr.getPriority() > drpri) {
        return nbrip;
    }
    if (nbrip.compareTo(drip) > 0) {
        return nbrip;
    }
    return drip;
}
#method_after
private IpAddress election(PIMNeighbor nbr, IpAddress drip, int drpri) {
    IpAddress nbrip = nbr.getIpaddr();
    if (nbr.getPriority() > drpri) {
        return nbrip;
    }
    if (nbrip.compareTo(drip) > 0) {
        return nbrip;
    }
    return drip;
}
#end_block

#method_before
private ApplicationDescription loadAppDescription(XMLConfiguration cfg) {
    String name = cfg.getString(NAME);
    Version version = Version.version(cfg.getString(VERSION));
    String desc = cfg.getString(DESCRIPTION);
    String origin = cfg.getString(ORIGIN);
    String category = cfg.getString(CATEGORY);
    String url = cfg.getString(URL);
    String readme = cfg.getString(README);
    byte[] icon = getApplicationIcon(name);
    ApplicationRole role = getRole(cfg.getString(ROLE));
    Set<Permission> perms = getPermissions(cfg);
    String featRepo = cfg.getString(FEATURES_REPO);
    URI featuresRepo = featRepo != null ? URI.create(featRepo) : null;
    List<String> features = ImmutableList.copyOf(cfg.getString(FEATURES).split(","));
    String apps = cfg.getString(APPS, "");
    List<String> requiredApps = apps.isEmpty() ? ImmutableList.of() : ImmutableList.copyOf(apps.split(","));
    return new DefaultApplicationDescription(name, version, desc, origin, category, url, readme, icon, role, perms, featuresRepo, features, requiredApps);
}
#method_after
private ApplicationDescription loadAppDescription(XMLConfiguration cfg) {
    String name = cfg.getString(NAME);
    Version version = Version.version(cfg.getString(VERSION));
    String origin = cfg.getString(ORIGIN);
    String category = cfg.getString(CATEGORY);
    String url = cfg.getString(URL);
    byte[] icon = getApplicationIcon(name);
    ApplicationRole role = getRole(cfg.getString(ROLE));
    Set<Permission> perms = getPermissions(cfg);
    String featRepo = cfg.getString(FEATURES_REPO);
    URI featuresRepo = featRepo != null ? URI.create(featRepo) : null;
    List<String> features = ImmutableList.copyOf(cfg.getString(FEATURES).split(","));
    String apps = cfg.getString(APPS, "");
    List<String> requiredApps = apps.isEmpty() ? ImmutableList.of() : ImmutableList.copyOf(apps.split(","));
    String desc = cfg.getString(DESCRIPTION);
    String readme = cfg.getString(README);
    if (readme == null) {
        readme = desc;
    } else {
        desc = compactDescription(readme);
    }
    return new DefaultApplicationDescription(name, version, desc, origin, category, url, readme, icon, role, perms, featuresRepo, features, requiredApps);
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException {
    File appFile = new File(baseDir, APP_XML);
    File featuresFile = new File(baseDir, FEATURES_XML);
    name = (String) project.getProperties().get(ONOS_APP_NAME);
    // is defined, there is nothing for this Mojo to do, so bail.
    if (!appFile.exists() && name == null) {
        return;
    }
    m2Directory = new File(localRepository.getBasedir());
    stageDirectory = new File(dstDirectory, PACKAGE_DIR);
    projectPath = M2_PREFIX + "/" + artifactDir(projectGroupId, projectArtifactId, projectVersion);
    origin = (String) project.getProperties().get(ONOS_APP_ORIGIN);
    origin = origin != null ? origin : DEFAULT_ORIGIN;
    requiredApps = (String) project.getProperties().get(ONOS_APP_REQUIRES);
    requiredApps = requiredApps == null ? "" : requiredApps.replaceAll("[\\s]", "");
    category = (String) project.getProperties().get(ONOS_APP_CATEGORY);
    category = category != null ? category : DEFAULT_CATEGORY;
    url = (String) project.getProperties().get(ONOS_APP_URL);
    url = url != null ? url : DEFAULT_URL;
    readme = (String) project.getProperties().get(ONOS_APP_README);
    readme = readme != null ? readme : projectDescription;
    projectDescription = readme != null ? firstSentence(readme) : projectDescription;
    if (appFile.exists()) {
        loadAppFile(appFile);
    } else {
        artifacts = ImmutableList.of(eval(DEFAULT_ARTIFACT));
    }
    // If there are any artifacts, stage the
    if (!artifacts.isEmpty()) {
        getLog().info("Building ONOS application package for " + name + " (v" + eval(version) + ")");
        artifacts.forEach(a -> getLog().debug("Including artifact: " + a));
        if (stageDirectory.exists() || stageDirectory.mkdirs()) {
            processAppXml(appFile);
            processFeaturesXml(featuresFile);
            processArtifacts();
            generateAppPackage();
        } else {
            throw new MojoExecutionException("Unable to create directory: " + stageDirectory);
        }
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException {
    File appFile = new File(baseDir, APP_XML);
    File featuresFile = new File(baseDir, FEATURES_XML);
    name = (String) project.getProperties().get(ONOS_APP_NAME);
    // is defined, there is nothing for this Mojo to do, so bail.
    if (!appFile.exists() && name == null) {
        return;
    }
    m2Directory = new File(localRepository.getBasedir());
    stageDirectory = new File(dstDirectory, PACKAGE_DIR);
    projectPath = M2_PREFIX + "/" + artifactDir(projectGroupId, projectArtifactId, projectVersion);
    origin = (String) project.getProperties().get(ONOS_APP_ORIGIN);
    origin = origin != null ? origin : DEFAULT_ORIGIN;
    requiredApps = (String) project.getProperties().get(ONOS_APP_REQUIRES);
    requiredApps = requiredApps == null ? "" : requiredApps.replaceAll("[\\s]", "");
    category = (String) project.getProperties().get(ONOS_APP_CATEGORY);
    category = category != null ? category : DEFAULT_CATEGORY;
    url = (String) project.getProperties().get(ONOS_APP_URL);
    url = url != null ? url : DEFAULT_URL;
    // if readme does not exist, we simply fallback to use description
    readme = (String) project.getProperties().get(ONOS_APP_README);
    readme = readme != null ? readme : projectDescription;
    if (appFile.exists()) {
        loadAppFile(appFile);
    } else {
        artifacts = ImmutableList.of(eval(DEFAULT_ARTIFACT));
    }
    // If there are any artifacts, stage the
    if (!artifacts.isEmpty()) {
        getLog().info("Building ONOS application package for " + name + " (v" + eval(version) + ")");
        artifacts.forEach(a -> getLog().debug("Including artifact: " + a));
        if (stageDirectory.exists() || stageDirectory.mkdirs()) {
            processAppXml(appFile);
            processFeaturesXml(featuresFile);
            processArtifacts();
            generateAppPackage();
        } else {
            throw new MojoExecutionException("Unable to create directory: " + stageDirectory);
        }
    }
}
#end_block

#method_before
@Override
protected String noRowsMessage() {
    return NO_ROWS_MESSAGE;
}
#method_after
@Override
protected String noRowsMessage(ObjectNode payload) {
    return NO_ROWS_MESSAGE;
}
#end_block

#method_before
@Override
protected String noRowsMessage(ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceService ds = get(DeviceService.class);
        Device dev = ds.getDevice(DeviceId.deviceId(uri));
        // DeviceFeature.GROUP/METER/...
        if (deviceProtocol(dev).equals(OF_10)) {
            return NOT_SUPPORT_MESSAGE;
        }
    }
    return NO_ROWS_MESSAGE;
}
#method_after
@Override
protected String noRowsMessage(ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceService ds = get(DeviceService.class);
        Device dev = ds.getDevice(DeviceId.deviceId(uri));
        // TODO: replace with a less brittle solution...
        if (deviceProtocol(dev).equals(OF_10)) {
            return NOT_SUPPORT_MESSAGE;
        }
    }
    return NO_ROWS_MESSAGE;
}
#end_block

#method_before
@Override
protected String noRowsMessage(ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceService ds = get(DeviceService.class);
        Device dev = ds.getDevice(DeviceId.deviceId(uri));
        // DeviceFeature.GROUP/METER/...
        if (deviceProtocol(dev).equals(OF_10)) {
            return NOT_SUPPORT_MESSAGE;
        }
    }
    return NO_ROWS_MESSAGE;
}
#method_after
@Override
protected String noRowsMessage(ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceService ds = get(DeviceService.class);
        Device dev = ds.getDevice(DeviceId.deviceId(uri));
        // TODO: replace with a less brittle solution...
        if (deviceProtocol(dev).equals(OF_10)) {
            return NOT_SUPPORT_MESSAGE;
        }
    }
    return NO_ROWS_MESSAGE;
}
#end_block

#method_before
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    PortGetter portConfig = h.behaviour(PortGetter.class);
    print(portConfig.getPorts().toString());
}
#method_after
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    PortDiscovery portConfig = h.behaviour(PortDiscovery.class);
    print(portConfig.getPorts().toString());
}
#end_block

#method_before
private void connectDevices() {
    RestProviderConfig cfg = cfgService.getConfig(appId, RestProviderConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(controller.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            cfg.getDevicesAddresses().stream().filter(device -> testDeviceConnection(device)).forEach(device -> {
                deviceAdded(device);
            });
            // Removing devices not wanted anymore
            toBeRemoved.stream().forEach(device -> deviceRemoved(device));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    log.info("REST Devices {}", controller.getDevices());
    controller.getDevices().keySet().forEach(deviceId -> {
        DriverHandler h = driverService.createHandler(deviceId);
        PortGetter portConfig = h.behaviour(PortGetter.class);
        if (portConfig != null) {
            providerService.updatePorts(deviceId, portConfig.getPorts());
        } else {
            log.warn("No portGetter behaviour for device {}", deviceId);
        }
    });
}
#method_after
private void connectDevices() {
    RestProviderConfig cfg = cfgService.getConfig(appId, RestProviderConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(controller.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            cfg.getDevicesAddresses().stream().filter(device -> testDeviceConnection(device)).forEach(device -> {
                deviceAdded(device);
            });
            // Removing devices not wanted anymore
            toBeRemoved.stream().forEach(device -> deviceRemoved(device));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    log.info("REST Devices {}", controller.getDevices());
    controller.getDevices().keySet().forEach(deviceId -> {
        DriverHandler h = driverService.createHandler(deviceId);
        PortDiscovery portConfig = h.behaviour(PortDiscovery.class);
        if (portConfig != null) {
            providerService.updatePorts(deviceId, portConfig.getPorts());
        } else {
            log.warn("No portGetter behaviour for device {}", deviceId);
        }
    });
}
#end_block

#method_before
@Test
public void testCorrectConfiguration() {
    assertTrue("Configuration contains not valid fields", SW_BDC.isValid());
    assertEquals("Wrong type", SWITCH, SW_BDC.type());
    assertEquals("Wrong driver", DRIVER, SW_BDC.driver());
    assertEquals("Wrong manufacturer", MANUFACTURER, SW_BDC.manufacturer());
    assertEquals("Wrong HwVersion", HW_VERSION, SW_BDC.hwVersion());
    assertEquals("Wrong swVersion", SW_VERSION, SW_BDC.swVersion());
    assertEquals("Wrong serial", SERIAL, SW_BDC.serial());
    assertEquals("Wrong management Address", MANAGEMENT_ADDRESS, SW_BDC.managementAddress());
}
#method_after
@Test
public void testCorrectConfiguration() {
    assertTrue("Configuration contains not valid fields", SW_BDC.isValid());
    assertEquals("Incorrect type", SWITCH, SW_BDC.type());
    assertEquals("Incorrect driver", DRIVER, SW_BDC.driver());
    assertEquals("Incorrect manufacturer", MANUFACTURER, SW_BDC.manufacturer());
    assertEquals("Incorrect HwVersion", HW_VERSION, SW_BDC.hwVersion());
    assertEquals("Incorrect swVersion", SW_VERSION, SW_BDC.swVersion());
    assertEquals("Incorrect serial", SERIAL, SW_BDC.serial());
    assertEquals("Incorrect management Address", MANAGEMENT_ADDRESS, SW_BDC.managementAddress());
}
#end_block

#method_before
@Test
public void testSetType() {
    SW_BDC.type(OTN);
    assertEquals("Wrong set type", OTN, SW_BDC.type());
}
#method_after
@Test
public void testSetType() {
    SW_BDC.type(OTN);
    assertEquals("Incorrect type", OTN, SW_BDC.type());
}
#end_block

#method_before
@Test
public void testSetDriver() {
    SW_BDC.driver(DRIVER_NEW);
    assertEquals("Wrong set driver", DRIVER_NEW, SW_BDC.driver());
}
#method_after
@Test
public void testSetDriver() {
    SW_BDC.driver(DRIVER_NEW);
    assertEquals("Incorrect driver", DRIVER_NEW, SW_BDC.driver());
}
#end_block

#method_before
@Test
public void testSetManufacturer() {
    SW_BDC.manufacturer(MANUFACTURER_NEW);
    assertEquals("Wrong set manufacturer", MANUFACTURER_NEW, SW_BDC.manufacturer());
}
#method_after
@Test
public void testSetManufacturer() {
    SW_BDC.manufacturer(MANUFACTURER_NEW);
    assertEquals("Incorrect manufacturer", MANUFACTURER_NEW, SW_BDC.manufacturer());
}
#end_block

#method_before
@Test
public void testSetHwVersion() {
    SW_BDC.hwVersion(HW_VERSION_NEW);
    assertEquals("Wrong set HwVersion", HW_VERSION_NEW, SW_BDC.hwVersion());
}
#method_after
@Test
public void testSetHwVersion() {
    SW_BDC.hwVersion(HW_VERSION_NEW);
    assertEquals("Incorrect HwVersion", HW_VERSION_NEW, SW_BDC.hwVersion());
}
#end_block

#method_before
@Test
public void testSetSwVersion() {
    SW_BDC.swVersion(SW_VERSION_NEW);
    assertEquals("Wrong set swVersion", SW_VERSION_NEW, SW_BDC.swVersion());
}
#method_after
@Test
public void testSetSwVersion() {
    SW_BDC.swVersion(SW_VERSION_NEW);
    assertEquals("Incorrect swVersion", SW_VERSION_NEW, SW_BDC.swVersion());
}
#end_block

#method_before
@Test
public void testSetSerial() {
    SW_BDC.serial(SERIAL_NEW);
    assertEquals("Wrong set serial", SERIAL_NEW, SW_BDC.serial());
}
#method_after
@Test
public void testSetSerial() {
    SW_BDC.serial(SERIAL_NEW);
    assertEquals("Incorrect serial", SERIAL_NEW, SW_BDC.serial());
}
#end_block

#method_before
@Test
public void testSetManagementAddress() {
    SW_BDC.managementAddress(MANAGEMENT_ADDRESS_NEW);
    assertEquals("Wrong set managementAddress", MANAGEMENT_ADDRESS_NEW, SW_BDC.managementAddress());
}
#method_after
@Test
public void testSetManagementAddress() {
    SW_BDC.managementAddress(MANAGEMENT_ADDRESS_NEW);
    assertEquals("Incorrect managementAddress", MANAGEMENT_ADDRESS_NEW, SW_BDC.managementAddress());
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    TableModel tm = createTableModel();
    populateTable(tm, payload);
    String sortCol = JsonUtils.string(payload, "sortCol", defaultColumnId());
    String sortDir = JsonUtils.string(payload, "sortDir", "asc");
    tm.sort(sortCol, TableModel.sortDir(sortDir));
    ObjectNode rootNode = MAPPER.createObjectNode();
    rootNode.set(nodeName, TableUtils.generateRowArrayNode(tm));
    rootNode.set(ANNOTS, TableUtils.generateAnnotObjectNode(tm));
    sendMessage(respType, 0, rootNode);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    TableModel tm = createTableModel();
    populateTable(tm, payload);
    String sortCol = JsonUtils.string(payload, "sortCol", defaultColumnId());
    String sortDir = JsonUtils.string(payload, "sortDir", "asc");
    tm.sort(sortCol, TableModel.sortDir(sortDir));
    addTableConfigAnnotations(tm);
    ObjectNode rootNode = MAPPER.createObjectNode();
    rootNode.set(nodeName, TableUtils.generateRowArrayNode(tm));
    rootNode.set(ANNOTS, TableUtils.generateAnnotObjectNode(tm));
    sendMessage(respType, 0, rootNode);
}
#end_block

#method_before
private void sendArpResponse(ARP arpRequest, MacAddress targetMac, VlanId vlanId) {
    ARP arpReply = new ARP();
    arpReply.setHardwareType(ARP.HW_TYPE_ETHERNET).setProtocolType(ARP.PROTO_TYPE_IP).setHardwareAddressLength((byte) Ethernet.DATALAYER_ADDRESS_LENGTH).setProtocolAddressLength((byte) Ip4Address.BYTE_LENGTH).setOpCode(ARP.OP_REPLY).setSenderHardwareAddress(targetMac.toBytes()).setSenderProtocolAddress(arpRequest.getTargetProtocolAddress()).setTargetHardwareAddress(arpRequest.getSenderHardwareAddress()).setTargetProtocolAddress(arpRequest.getSenderProtocolAddress());
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(arpRequest.getSenderHardwareAddress()).setSourceMACAddress(targetMac.toBytes()).setEtherType(Ethernet.TYPE_ARP).setPayload(arpReply);
    MacAddress hostMac = MacAddress.valueOf(arpReply.getTargetHardwareAddress());
    HostId dstId = HostId.hostId(hostMac, vlanId);
    Host dst = srManager.hostService.getHost(dstId);
    if (dst == null) {
        log.warn("Cannot send ARP response to device " + hostMac + "/" + vlanId.toString());
        return;
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dst.location().port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(dst.location().deviceId(), treatment, ByteBuffer.wrap(eth.serialize()));
    srManager.packetService.emit(packet);
}
#method_after
private void sendArpResponse(ARP arpRequest, MacAddress targetMac, VlanId vlanId) {
    ARP arpReply = new ARP();
    arpReply.setHardwareType(ARP.HW_TYPE_ETHERNET).setProtocolType(ARP.PROTO_TYPE_IP).setHardwareAddressLength((byte) Ethernet.DATALAYER_ADDRESS_LENGTH).setProtocolAddressLength((byte) Ip4Address.BYTE_LENGTH).setOpCode(ARP.OP_REPLY).setSenderHardwareAddress(targetMac.toBytes()).setSenderProtocolAddress(arpRequest.getTargetProtocolAddress()).setTargetHardwareAddress(arpRequest.getSenderHardwareAddress()).setTargetProtocolAddress(arpRequest.getSenderProtocolAddress());
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(arpRequest.getSenderHardwareAddress()).setSourceMACAddress(targetMac.toBytes()).setEtherType(Ethernet.TYPE_ARP).setPayload(arpReply);
    MacAddress hostMac = MacAddress.valueOf(arpReply.getTargetHardwareAddress());
    HostId dstId = HostId.hostId(hostMac, vlanId);
    Host dst = srManager.hostService.getHost(dstId);
    if (dst == null) {
        log.warn("Cannot send ARP response to host {}", dstId);
        return;
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dst.location().port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(dst.location().deviceId(), treatment, ByteBuffer.wrap(eth.serialize()));
    srManager.packetService.emit(packet);
}
#end_block

#method_before
private void processInPortTable(DeviceId deviceId, PortNumber tunnelPort, PortNumber phyPort) {
    checkNotNull(tunnelPort);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(tunnelPort).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_TUNNEL_IN).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(phyPort).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_ACCESS_TYPE).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processInPortTable(DeviceId deviceId, PortNumber tunnelPort, PortNumber phyPort) {
    checkNotNull(tunnelPort);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(tunnelPort).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_TUNNEL_IN).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(phyPort).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
@Override
public <T> T[] toArray(T[] a) {
    final MeteringAgent.Context timer = monitor.startTimer(TO_ARRAY);
    try {
        final T[] resizedArray = (T[]) Array.newInstance(a.getClass().getComponentType(), backingMap.keySet().size());
        return (T[]) backingMap.keySet().toArray(resizedArray);
    } finally {
        timer.stop(null);
    }
}
#method_after
@Override
public <T> T[] toArray(T[] a) {
    final MeteringAgent.Context timer = monitor.startTimer(TO_ARRAY);
    try {
        // TODO: Optimize this to only allocate a new array if the set size
        // is larger than the array.length. If the set size is smaller than
        // the array.length then copy the data into the array and set the
        // last element in the array to be null.
        final T[] resizedArray = (T[]) Array.newInstance(a.getClass().getComponentType(), backingMap.keySet().size());
        return (T[]) backingMap.keySet().toArray(resizedArray);
    } finally {
        timer.stop(null);
    }
}
#end_block

#method_before
@Override
public DeviceId deviceId() {
    return DeviceId.deviceId("rest:" + ip + ":" + port);
}
#method_after
@Override
public DeviceId deviceId() {
    return DeviceId.deviceId(REST + COLON + ip + COLON + port);
}
#end_block

#method_before
@Override
public void setActive(Boolean active) {
    isActive = active;
}
#method_after
@Override
public void setActive(boolean active) {
    isActive = active;
}
#end_block

#method_before
@Activate
public void activate() {
    providerService = providerRegistry.register(this);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    connectExistingDevices();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    providerService = providerRegistry.register(this);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    connectDevices();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    cfgService.removeListener(cfgLister);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public boolean isReachable(DeviceId deviceId) {
    Map<DeviceId, RestSBDevice> devices = controller.getDevices();
    RestSBDevice restDevice = null;
    for (DeviceId key : devices.keySet()) {
        if (key.equals(deviceId)) {
            restDevice = controller.getDevices().get(key);
        }
    }
    if (restDevice == null) {
        log.warn("BAD REQUEST: the requested device id: " + deviceId.toString() + "  is not associated to any REST Device");
        return false;
    }
    return restDevice.isActive();
}
#method_after
@Override
public boolean isReachable(DeviceId deviceId) {
    RestSBDevice restDevice = controller.getDevice(deviceId);
    if (restDevice == null) {
        log.warn("BAD REQUEST: the requested device id: " + deviceId.toString() + "  is not associated to any REST Device");
        return false;
    }
    return restDevice.isActive();
}
#end_block

#method_before
private void deviceAdded(RestSBDevice nodeId) {
    Preconditions.checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = nodeId.deviceId();
    ChassisId cid = new ChassisId();
    String ipAddress = nodeId.ip().toString();
    SparseAnnotations annotations = DefaultAnnotations.builder().set("ipaddress", ipAddress).build();
    DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, annotations);
    providerService.deviceConnected(deviceId, deviceDescription);
    nodeId.setActive(true);
    controller.addDevice(nodeId);
}
#method_after
private void deviceAdded(RestSBDevice nodeId) {
    Preconditions.checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = nodeId.deviceId();
    ChassisId cid = new ChassisId();
    String ipAddress = nodeId.ip().toString();
    SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).build();
    DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, annotations);
    providerService.deviceConnected(deviceId, deviceDescription);
    nodeId.setActive(true);
    controller.addDevice(nodeId);
}
#end_block

#method_before
public void deviceRemoved(RestSBDevice nodeId) {
    Preconditions.checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = nodeId.deviceId();
    providerService.deviceDisconnected(deviceId);
}
#method_after
public void deviceRemoved(RestSBDevice nodeId) {
    Preconditions.checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = nodeId.deviceId();
    providerService.deviceDisconnected(deviceId);
    controller.removeDevice(nodeId);
}
#end_block

#method_before
private void connectDevices() {
    RestProviderConfig cfg = cfgService.getConfig(appId, RestProviderConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            cfg.getDevicesAddresses().stream().filter(device -> testDeviceConnection(device)).collect(Collectors.toList()).forEach(device -> {
                deviceAdded(device);
                controller.addDevice(device);
            });
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    log.info("Devices {}", controller.getDevices());
// TODO try to connect via rest to devices then call device added
// TODO ask for ports then call update ports.
}
#method_after
private void connectDevices() {
    RestProviderConfig cfg = cfgService.getConfig(appId, RestProviderConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(controller.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            cfg.getDevicesAddresses().stream().filter(device -> testDeviceConnection(device)).forEach(device -> {
                deviceAdded(device);
            });
            // Removing devices not wanted anymore
            toBeRemoved.stream().forEach(device -> deviceRemoved(device));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    log.info("REST Devices {}", controller.getDevices());
// TODO ask for ports then call update ports.
}
#end_block

#method_before
private boolean testDeviceConnection(RestSBDevice device) {
    try {
        URL url = new URL("http://" + device.ip().toString() + ":" + device.port());
        HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
        urlConn.setConnectTimeout(1000);
        boolean open = urlConn.getResponseCode() == (HttpURLConnection.HTTP_OK);
        urlConn.disconnect();
        return open;
    } catch (IOException e) {
        log.error("Device {} not reachable, error creating HTTP connection {} ", device, e.getMessage());
    }
    return false;
}
#method_after
private boolean testDeviceConnection(RestSBDevice device) {
    try {
        URL url = new URL(device.protocol(), device.ip().toString(), device.port(), "/");
        HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
        urlConn.setConnectTimeout(TEST_CONNECT_TIMEOUT);
        boolean open = urlConn.getResponseCode() == (HttpURLConnection.HTTP_OK);
        urlConn.disconnect();
        return open;
    } catch (IOException e) {
        log.error("Device {} not reachable, error creating HTTP connection", device, e);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    // TODO refactor
    return event.configClass().equals(RestProviderConfig.class) && (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED);
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    // TODO refactor
    return event.configClass().equals(RestProviderConfig.class) && (event.type() == CONFIG_ADDED || event.type() == CONFIG_UPDATED);
}
#end_block

#method_before
@Override
public boolean post(DeviceId device, String request, String payload, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    ClientResponse response = webResource.accept("application/" + mediaType).post(ClientResponse.class, payload);
    return checkReply(response);
}
#method_after
@Override
public boolean post(DeviceId device, String request, InputStream payload, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    ClientResponse response = null;
    if (payload != null) {
        try {
            response = webResource.accept(mediaType).post(ClientResponse.class, IOUtils.toString(payload, StandardCharsets.UTF_8));
        } catch (IOException e) {
            log.error("Cannot do POST {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = webResource.accept(mediaType).post(ClientResponse.class);
    }
    return checkReply(response);
}
#end_block

#method_before
@Override
public boolean put(DeviceId device, String request, String payload, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    ClientResponse response = webResource.accept("application/" + mediaType).put(ClientResponse.class, payload);
    return checkReply(response);
}
#method_after
@Override
public boolean put(DeviceId device, String request, InputStream payload, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    ClientResponse response = null;
    if (payload != null) {
        try {
            response = webResource.accept(mediaType).put(ClientResponse.class, IOUtils.toString(payload, StandardCharsets.UTF_8));
        } catch (IOException e) {
            log.error("Cannot do PUT {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = webResource.accept(mediaType).put(ClientResponse.class);
    }
    return checkReply(response);
}
#end_block

#method_before
@Override
public JsonObject get(DeviceId device, String request) {
    WebResource webResource = getWebResource(device, request);
    String response = webResource.get(ClientResponse.class).getEntity(String.class);
    return new JsonObject(JsonObject.readFrom(response));
}
#method_after
@Override
public InputStream get(DeviceId device, String request, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    String type;
    switch(mediaType) {
        case XML:
            type = MediaType.APPLICATION_XML;
            break;
        case JSON:
            type = MediaType.APPLICATION_JSON;
            break;
        default:
            throw new IllegalArgumentException("Unsupported media type " + mediaType);
    }
    return new ByteArrayInputStream(webResource.accept(type).get(ClientResponse.class).getEntity(String.class).getBytes(StandardCharsets.UTF_8));
}
#end_block

#method_before
@Override
public boolean delete(DeviceId device, String request, String payload, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    ClientResponse response;
    if (payload.length() > 0) {
        response = webResource.accept("application/" + mediaType).delete(ClientResponse.class, payload);
    } else {
        response = webResource.accept("application/" + mediaType).delete(ClientResponse.class);
    }
    return checkReply(response);
}
#method_after
@Override
public boolean delete(DeviceId device, String request, InputStream payload, String mediaType) {
    WebResource webResource = getWebResource(device, request);
    ClientResponse response = null;
    if (payload != null) {
        try {
            response = webResource.accept(mediaType).delete(ClientResponse.class, IOUtils.toString(payload, StandardCharsets.UTF_8));
        } catch (IOException e) {
            log.error("Cannot do PUT {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = webResource.accept(mediaType).delete(ClientResponse.class);
    }
    return checkReply(response);
}
#end_block

#method_before
private WebResource getWebResource(DeviceId device, String request) {
    Client client = Client.create();
    return client.resource("http://" + deviceMap.get(device).ip().toString() + ":" + deviceMap.get(device).port() + request);
}
#method_after
private WebResource getWebResource(DeviceId device, String request) {
    return Client.create().resource(deviceMap.get(device).protocol() + COLON + DOUBLESLASH + deviceMap.get(device).ip().toString() + COLON + deviceMap.get(device).port() + SLASH + request);
}
#end_block

#method_before
private boolean checkReply(ClientResponse response) {
    if (response.getStatus() == 200 || response.getStatus() == 201 || response.getStatus() == 202) {
        String output = response.getEntity(String.class);
        return true;
    } else {
        log.error("Failed request: HTTP error code : " + response.getStatus());
        return false;
    }
}
#method_after
private boolean checkReply(ClientResponse response) {
    if (response != null) {
        if (response.getStatus() == STATUS_OK || response.getStatus() == STATUS_CREATED || response.getStatus() == STATUS_ACCEPTED) {
            return true;
        } else {
            log.error("Failed request: HTTP error code : " + response.getStatus());
            return false;
        }
    }
    log.error("Null reply from device");
    return false;
}
#end_block

#method_before
public Set<RestSBDevice> getDevicesAddresses() throws ConfigException {
    Set<RestSBDevice> devicesAddresses = Sets.newHashSet();
    try {
        for (JsonNode node : array) {
            String ip = node.path(IP).asText();
            IpAddress ipAddr = ip.isEmpty() ? null : IpAddress.valueOf(ip);
            int port = node.path(PORT).asInt(DEFAULT_HTTP_PORT);
            String name = node.path(NAME).asText();
            String password = node.path(PASSWORD).asText();
            devicesAddresses.add(new DefaultRestSBDevice(ipAddr, port, name, password, false));
        }
    } catch (IllegalArgumentException e) {
        throw new ConfigException(CONFIG_VALUE_ERROR, e);
    }
    return devicesAddresses;
}
#method_after
public Set<RestSBDevice> getDevicesAddresses() throws ConfigException {
    Set<RestSBDevice> devicesAddresses = Sets.newHashSet();
    try {
        for (JsonNode node : array) {
            String ip = node.path(IP).asText();
            IpAddress ipAddr = ip.isEmpty() ? null : IpAddress.valueOf(ip);
            int port = node.path(PORT).asInt(DEFAULT_HTTP_PORT);
            String name = node.path(NAME).asText();
            String password = node.path(PASSWORD).asText();
            String protocol = node.path(PROTOCOL).asText();
            devicesAddresses.add(new DefaultRestSBDevice(ipAddr, port, name, password, protocol, false));
        }
    } catch (IllegalArgumentException e) {
        throw new ConfigException(CONFIG_VALUE_ERROR, e);
    }
    return devicesAddresses;
}
#end_block

#method_before
private void registerDhcpInfo(OpenstackPort openstackPort) {
    Ip4Address ip4Address;
    Ip4Address subnetMask;
    Ip4Address dhcpServer;
    Ip4Address gatewayIPAddress;
    Ip4Address domainServer;
    OpenstackSubnet openstackSubnet;
    ip4Address = (Ip4Address) openstackPort.fixedIps().values().toArray()[0];
    openstackSubnet = restHandler.getSubnets().stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    subnetMask = Ip4Address.valueOf(buildSubnetMask(openstackSubnet.cidr()));
    gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    dhcpServer = gatewayIPAddress;
    // TODO: supports multiple DNS servers
    if (openstackSubnet.dnsNameservers().isEmpty()) {
        domainServer = Ip4Address.valueOf("8.8.8.8");
    } else {
        domainServer = openstackSubnet.dnsNameservers().get(0);
    }
    List<Ip4Address> options = Lists.newArrayList();
    options.add(subnetMask);
    options.add(dhcpServer);
    options.add(gatewayIPAddress);
    options.add(domainServer);
    dhcpService.setStaticMapping(openstackPort.macAddress(), ip4Address, true, options);
}
#method_after
private void registerDhcpInfo(OpenstackPort openstackPort) {
    Ip4Address ip4Address;
    Ip4Address subnetMask;
    Ip4Address dhcpServer;
    Ip4Address gatewayIPAddress;
    Ip4Address domainServer;
    OpenstackSubnet openstackSubnet;
    ip4Address = (Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null);
    openstackSubnet = restHandler.getSubnets().stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    subnetMask = Ip4Address.valueOf(buildSubnetMask(openstackSubnet.cidr()));
    gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    dhcpServer = gatewayIPAddress;
    // TODO: supports multiple DNS servers
    if (openstackSubnet.dnsNameservers().isEmpty()) {
        domainServer = Ip4Address.valueOf("8.8.8.8");
    } else {
        domainServer = openstackSubnet.dnsNameservers().get(0);
    }
    List<Ip4Address> options = Lists.newArrayList();
    options.add(subnetMask);
    options.add(dhcpServer);
    options.add(gatewayIPAddress);
    options.add(domainServer);
    dhcpService.setStaticMapping(openstackPort.macAddress(), ip4Address, true, options);
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#end_block

#method_before
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_UPDATED:
                Port port = (Port) deviceEvent.subject();
                if (port.isEnabled()) {
                    processPortAdded((Device) deviceEvent.subject(), deviceEvent.port());
                }
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortAdded((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortAdded((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_UPDATED:
                Port port = (Port) deviceEvent.subject();
                if (port.isEnabled()) {
                    processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                }
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService);
    initializeFlowRules();
}
#method_after
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService, hostService);
    initializeFlowRules();
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        configureNetwork();
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        networkEventExcutorService.execute(this::configureNetwork);
    }
}
#end_block

#method_before
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    MacAddress vmMac = getVmMacAddressForPort(portName);
    String vni = getVniForPort(portName);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(device)) {
            deviceService.getPorts(d.id()).forEach(p -> {
                String pName = p.annotations().value("portName");
                if (!p.equals(port) && vni.equals(getVniForPort(pName))) {
                    String cidx = d.annotations().value("channelId");
                    Ip4Address hostIpx = Ip4Address.valueOf(cidx.split(":")[0]);
                    MacAddress vmMacx = getVmMacAddressForPort(pName);
                    Ip4Address fixedIpx = getFixedIpAddressForPort(pName);
                    if (port.isEnabled()) {
                        setVxLanFlowRule(vni, device.id(), hostIpx, fixedIpx, vmMacx);
                        setVxLanFlowRule(vni, d.id(), hostIpAddress, fixedIp, vmMac);
                    }
                }
            });
        }
    });
}
#method_after
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    String vni = getVniForPort(portName);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(device)) {
            deviceService.getPorts(d.id()).forEach(p -> {
                String pName = p.annotations().value("portName");
                if (!p.equals(port) && vni.equals(getVniForPort(pName))) {
                    String cidx = d.annotations().value("channelId");
                    Ip4Address hostIpx = Ip4Address.valueOf(cidx.split(":")[0]);
                    Ip4Address fixedIpx = getFixedIpAddressForPort(pName);
                    if (port.isEnabled()) {
                        setVxLanFlowRule(vni, device.id(), hostIpx, fixedIpx);
                        setVxLanFlowRule(vni, d.id(), hostIpAddress, fixedIp);
                    }
                }
            });
        }
    });
}
#end_block

#method_before
private void setVxLanFlowRule(String vni, DeviceId id, Ip4Address hostIp, Ip4Address vmIp, MacAddress vmMac) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(vni)).matchIPDst(vmIp.toIpPrefix());
    tBuilder.extension(buildNiciraExtenstion(id, hostIp), id).setOutput(getTunnelPort(id));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void setVxLanFlowRule(String vni, DeviceId deviceId, Ip4Address hostIp, Ip4Address vmIp) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(vni)).matchIPDst(vmIp.toIpPrefix());
    tBuilder.extension(buildNiciraExtenstion(deviceId, hostIp), deviceId).setOutput(getTunnelPort(deviceId));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
public void removeSwitchingRules(Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value("portName"));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = openstackPortInfo.portNumber();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#method_after
public void removeSwitchingRules(Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value("portName"));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = removedPort.number();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#end_block

#method_before
private void removeFlowRuleForVMsInSameCnode(DeviceId id, Ip4Address vmIp, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeFlowRuleForVMsInSameCnode(DeviceId deviceId, Ip4Address vmIp, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private void removeFlowRuleForVMsInDiffrentCnode(Port removedPort, DeviceId deviceId, Ip4Address vmIp, long vni, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    final boolean anyPortRemainedInSameCnode = chkIfAnyPortRemainedInSameCnode(removedPort, deviceId, vni, openstackPortInfoMap);
    openstackPortInfoMap.forEach((port, portInfo) -> {
        if (portInfo.vni() == vni && !portInfo.deviceId().equals(deviceId)) {
            removeVxLanFlowRule(portInfo.deviceId(), vmIp, vni);
            if (!anyPortRemainedInSameCnode) {
                removeVxLanFlowRule(deviceId, portInfo.ip(), vni);
            }
        }
    });
}
#method_after
private void removeFlowRuleForVMsInDiffrentCnode(Port removedPort, DeviceId deviceId, Ip4Address vmIp, long vni, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    final boolean anyPortRemainedInSameCnode = checkIfAnyPortRemainedInSameCnode(removedPort, deviceId, vni, openstackPortInfoMap);
    openstackPortInfoMap.forEach((port, portInfo) -> {
        if (portInfo.vni() == vni && !portInfo.deviceId().equals(deviceId)) {
            removeVxLanFlowRule(portInfo.deviceId(), vmIp, vni);
            if (!anyPortRemainedInSameCnode) {
                removeVxLanFlowRule(deviceId, portInfo.ip(), vni);
            }
        }
    });
}
#end_block

#method_before
private void removeVxLanFlowRule(DeviceId id, Ip4Address vmIp, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchIPDst(vmIp.toIpPrefix());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeVxLanFlowRule(DeviceId deviceId, Ip4Address vmIp, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchIPDst(vmIp.toIpPrefix());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(DefaultTrafficTreatment.builder().build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(SWITCHING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private PortNumber getTunnelPort(DeviceId id) {
    Port port = deviceService.getPorts(id).stream().filter(p -> p.annotations().value("portName").equals("vxlan")).findAny().orElse(null);
    if (port == null) {
        log.error("No TunnelPort was created.");
        return null;
    }
    return port.number();
}
#method_after
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value("portName").equals("vxlan")).findAny().orElse(null);
    if (port == null) {
        log.error("No TunnelPort was created.");
        return null;
    }
    return port.number();
}
#end_block

#method_before
@Before
public void setUp() {
    sut = new PathIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    sut.resourceService = new MockResourceService();
    Intent.bindIdGenerator(idGenerator);
    intent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).path(new DefaultPath(pid, links, hops)).build();
    constraintIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(Collections.singletonList(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(PathIntent.class, sut);
    intentExtensionService.unregisterCompiler(PathIntent.class);
    sut.intentManager = intentExtensionService;
    replay(coreService, intentExtensionService);
}
#method_after
@Before
public void setUp() {
    sut = new PathIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    sut.resourceService = new MockResourceService();
    Intent.bindIdGenerator(idGenerator);
    intent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).path(new DefaultPath(pid, links, hops)).build();
    constraintIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(PathIntent.class, sut);
    intentExtensionService.unregisterCompiler(PathIntent.class);
    sut.intentManager = intentExtensionService;
    replay(coreService, intentExtensionService);
}
#end_block

#method_before
@Test
public void testEncapCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintIntent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    assertThat(rule1.deviceId(), is(d1p0.deviceId()));
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    Set<Instructions.OutputInstruction> ruleOutput = rule1.treatment().allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(d1p1.port()));
    Set<L2ModificationInstruction.ModVlanIdInstruction> vlanRules = rule1.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
    assertThat(vlanRules, hasSize(1));
    L2ModificationInstruction.ModVlanIdInstruction vlanRule = vlanRules.iterator().next();
    assertThat(vlanRule.vlanId().toShort(), greaterThan((short) 0));
    VlanId vlanToEncap = vlanRule.vlanId();
    assertThat(rule1.priority(), is(intent.priority()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    assertThat(rule2.deviceId(), is(d2p0.deviceId()));
    assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).matchVlanId(vlanToEncap).build()));
    ruleOutput = rule2.treatment().allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(d2p1.port()));
    assertThat(rule2.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).collect(Collectors.toSet()), hasSize(0));
    assertThat(rule2.priority(), is(intent.priority()));
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    assertThat(rule3.deviceId(), is(d3p1.deviceId()));
    assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).matchVlanId(vlanToEncap).build()));
    ruleOutput = rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(d3p0.port()));
    assertThat(rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).collect(Collectors.toSet()), hasSize(0));
    assertThat(rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.PopVlanInstruction).collect(Collectors.toSet()), hasSize(1));
    assertThat(rule3.priority(), is(intent.priority()));
    sut.deactivate();
}
#method_after
@Test
public void testEncapCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintIntent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    assertThat(rule1.deviceId(), is(d1p0.deviceId()));
    assertThat(rule1.priority(), is(intent.priority()));
    verifyEncapSelector(rule1.selector(), d1p0, VlanId.NONE);
    VlanId vlanToEncap = verifyEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    assertThat(rule2.deviceId(), is(d2p0.deviceId()));
    assertThat(rule2.priority(), is(intent.priority()));
    verifyEncapSelector(rule2.selector(), d2p0, vlanToEncap);
    verifyEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    assertThat(rule3.deviceId(), is(d3p1.deviceId()));
    assertThat(rule3.priority(), is(intent.priority()));
    verifyEncapSelector(rule3.selector(), d3p1, vlanToEncap);
    verifyEncapTreatment(rule3.treatment(), d3p0, false, true);
    sut.deactivate();
}
#end_block

#method_before
@Override
public List<Intent> compile(PathIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Note: right now recompile is not considered
    // TODO: implement recompile behavior
    List<Link> links = intent.path().links();
    List<FlowRule> rules = new LinkedList<>();
    Optional<EncapsulationConstraint> enacpConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    // if encapsulation or is involved only a single switch use the default behaviour
    if (!enacpConstraint.isPresent() || links.size() == 1) {
        for (int i = 0; i < links.size() - 1; i++) {
            ConnectPoint ingress = links.get(i).dst();
            ConnectPoint egress = links.get(i + 1).src();
            FlowRule rule = createFlowRule(intent.selector(), intent.treatment(), ingress, egress, intent.priority(), isLast(links, i));
            rules.add(rule);
        }
        return Collections.singletonList(new FlowRuleIntent(appId, null, rules, intent.resources()));
    } else {
        if (EncapsulationType.VLAN == enacpConstraint.get().encapType()) {
            rules = manageVlanEncap(intent);
        }
        if (EncapsulationType.MPLS == enacpConstraint.get().encapType()) {
            // TODO: to be implemented
            rules = Collections.emptyList();
        }
        return Collections.singletonList(new FlowRuleIntent(appId, null, rules, intent.resources()));
    }
}
#method_after
@Override
public List<Intent> compile(PathIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Note: right now recompile is not considered
    // TODO: implement recompile behavior
    List<Link> links = intent.path().links();
    List<FlowRule> rules = new LinkedList<>();
    Optional<EncapsulationConstraint> enacpConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    // if no encapsulation or is involved only a single switch use the default behaviour
    if (!enacpConstraint.isPresent() || links.size() == 1) {
        for (int i = 0; i < links.size() - 1; i++) {
            ConnectPoint ingress = links.get(i).dst();
            ConnectPoint egress = links.get(i + 1).src();
            FlowRule rule = createFlowRule(intent.selector(), intent.treatment(), ingress, egress, intent.priority(), isLast(links, i));
            rules.add(rule);
        }
        return ImmutableList.of(new FlowRuleIntent(appId, null, rules, intent.resources()));
    } else {
        if (EncapsulationType.VLAN == enacpConstraint.get().encapType()) {
            rules = manageVlanEncap(intent);
        }
        if (EncapsulationType.MPLS == enacpConstraint.get().encapType()) {
            // TODO: to be implemented
            rules = Collections.emptyList();
        }
        return ImmutableList.of(new FlowRuleIntent(appId, null, rules, intent.resources()));
    }
}
#end_block

#method_before
private List<FlowRule> manageVlanEncap(PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // List of flow rules to be installed
    List<FlowRule> rules = new LinkedList<>();
    // Ingress traffic
    VlanId vlanId = getVlanId(vlanIds, linkKey(link));
    checkNotNull(vlanId);
    VlanId prevVlanId = vlanId;
    // Tag the traffic with the new VLAN
    TrafficTreatment treat = DefaultTrafficTreatment.builder().setVlanId(vlanId).build();
    rules.add(createFlowRule(intent.selector(), treat, srcLink.dst(), link.src(), intent.priority(), true));
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = getVlanId(vlanIds, linkKey(link));
            checkNotNull(egressVlanId);
            prevVlanId = egressVlanId;
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            rules.add(createFlowRule(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true));
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            // TODO: think to other cases for egress packet restoration
            Optional<VlanIdCriterion> vlanCriteria = intent.selector().criteria().stream().filter(criteria -> criteria.type() == Criterion.Type.VLAN_VID).map(criteria -> (VlanIdCriterion) criteria).findAny();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            if (vlanCriteria.isPresent()) {
                egressTreat.setVlanId(vlanCriteria.get().vlanId());
            } else {
                egressTreat.popVlan();
            }
            rules.add(createFlowRule(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true));
        }
    }
    return rules;
}
#method_after
private List<FlowRule> manageVlanEncap(PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // List of flow rules to be installed
    List<FlowRule> rules = new LinkedList<>();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    // Tag the traffic with the new VLAN
    TrafficTreatment treat = DefaultTrafficTreatment.builder().setVlanId(vlanId).build();
    rules.add(createFlowRule(intent.selector(), treat, srcLink.dst(), link.src(), intent.priority(), true));
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            prevVlanId = egressVlanId;
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            rules.add(createFlowRule(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true));
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            // TODO: think to other cases for egress packet restoration
            Optional<VlanIdCriterion> vlanCriteria = intent.selector().criteria().stream().filter(criteria -> criteria.type() == Criterion.Type.VLAN_VID).map(criteria -> (VlanIdCriterion) criteria).findAny();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            if (vlanCriteria.isPresent()) {
                egressTreat.setVlanId(vlanCriteria.get().vlanId());
            } else {
                egressTreat.popVlan();
            }
            rules.add(createFlowRule(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true));
        }
    }
    return rules;
}
#end_block

#method_before
private Map<LinkKey, VlanId> assignVlanId(PathIntent intent) {
    Set<LinkKey> linkRequest = Sets.newHashSetWithExpectedSize(intent.path().links().size() - 2);
    for (int i = 1; i <= intent.path().links().size() - 2; i++) {
        LinkKey link = linkKey(intent.path().links().get(i));
        linkRequest.add(link);
        // add the inverse link. I want that the VLANID is reserved both for
        // the direct and inverse link
        linkRequest.add(linkKey(link.dst(), link.src()));
    }
    Map<LinkKey, VlanId> vlanIds = findVlanIds(linkRequest);
    if (vlanIds.isEmpty()) {
        log.warn("No VLAN IDs available.");
        return Collections.emptyMap();
    }
    // same VLANID is used for both directions
    Set<ResourcePath> resources = vlanIds.entrySet().stream().flatMap(x -> Stream.of(ResourcePath.discrete(x.getKey().src().deviceId(), x.getKey().src().port(), x.getValue()), ResourcePath.discrete(x.getKey().dst().deviceId(), x.getKey().dst().port(), x.getValue()))).collect(Collectors.toSet());
    List<org.onosproject.net.newresource.ResourceAllocation> allocations = resourceService.allocate(intent.id(), ImmutableList.copyOf(resources));
    if (allocations.isEmpty()) {
        Collections.emptyMap();
    }
    return vlanIds;
}
#method_after
private Map<LinkKey, VlanId> assignVlanId(PathIntent intent) {
    Set<LinkKey> linkRequest = Sets.newHashSetWithExpectedSize(intent.path().links().size() - 2);
    for (int i = 1; i <= intent.path().links().size() - 2; i++) {
        LinkKey link = linkKey(intent.path().links().get(i));
        linkRequest.add(link);
        // add the inverse link. I want that the VLANID is reserved both for
        // the direct and inverse link
        linkRequest.add(linkKey(link.dst(), link.src()));
    }
    Map<LinkKey, VlanId> vlanIds = findVlanIds(linkRequest);
    if (vlanIds.isEmpty()) {
        log.warn("No VLAN IDs available");
        return Collections.emptyMap();
    }
    // same VLANID is used for both directions
    Set<ResourcePath> resources = vlanIds.entrySet().stream().flatMap(x -> Stream.of(ResourcePath.discrete(x.getKey().src().deviceId(), x.getKey().src().port(), x.getValue()), ResourcePath.discrete(x.getKey().dst().deviceId(), x.getKey().dst().port(), x.getValue()))).collect(Collectors.toSet());
    List<org.onosproject.net.newresource.ResourceAllocation> allocations = resourceService.allocate(intent.id(), ImmutableList.copyOf(resources));
    if (allocations.isEmpty()) {
        Collections.emptyMap();
    }
    return vlanIds;
}
#end_block

#method_before
@Override
public Optional<ResourceAllocation> getResourceAllocation(ResourcePath resource) {
    return Optional.ofNullable(assignment.get(resource)).map(x -> new ResourceAllocation(resource, x));
}
#method_after
@Override
public List<ResourceAllocation> getResourceAllocation(ResourcePath resource) {
    return Optional.ofNullable(assignment.get(resource)).map(x -> ImmutableList.of(new ResourceAllocation(resource, x))).orElse(ImmutableList.of());
}
#end_block

#method_before
@Override
public Optional<ResourceAllocation> getResourceAllocation(ResourcePath resource) {
    checkNotNull(resource);
    Optional<ResourceConsumer> consumer = store.getConsumer(resource);
    return consumer.map(x -> new ResourceAllocation(resource, x));
}
#method_after
@Override
public List<ResourceAllocation> getResourceAllocation(ResourcePath resource) {
    checkNotNull(resource);
    List<ResourceConsumer> consumers = store.getConsumers(resource);
    return consumers.stream().map(x -> new ResourceAllocation(resource, x)).collect(GuavaCollectors.toImmutableList());
}
#end_block

#method_before
@Override
public <T> Collection<ResourceAllocation> getResourceAllocations(ResourcePath parent, Class<T> cls) {
    checkNotNull(parent);
    checkNotNull(cls);
    Collection<ResourcePath> resources = store.getAllocatedResources(parent, cls);
    List<ResourceAllocation> allocations = new ArrayList<>(resources.size());
    for (ResourcePath resource : resources) {
        // We access store twice in this method, then the store may be updated by others
        Optional<ResourceConsumer> consumer = store.getConsumer(resource);
        if (consumer.isPresent()) {
            allocations.add(new ResourceAllocation(resource, consumer.get()));
        }
    }
    return allocations;
}
#method_after
@Override
public <T> Collection<ResourceAllocation> getResourceAllocations(ResourcePath parent, Class<T> cls) {
    checkNotNull(parent);
    checkNotNull(cls);
    // We access store twice in this method, then the store may be updated by others
    Collection<ResourcePath> resources = store.getAllocatedResources(parent, cls);
    return resources.stream().flatMap(resource -> store.getConsumers(resource).stream().map(consumer -> new ResourceAllocation(resource, consumer))).collect(GuavaCollectors.toImmutableList());
}
#end_block

#method_before
private Optional<ResourceConsumer> getConsumer(ResourcePath.Discrete resource) {
    Versioned<ResourceConsumer> consumer = discreteConsumers.get(resource);
    if (consumer == null) {
        return Optional.empty();
    }
    return Optional.of(consumer.value());
}
#method_after
private List<ResourceConsumer> getConsumer(ResourcePath.Discrete resource) {
    Versioned<ResourceConsumer> consumer = discreteConsumers.get(resource);
    if (consumer == null) {
        return ImmutableList.of();
    }
    return ImmutableList.of(consumer.value());
}
#end_block

#method_before
private Optional<ResourceConsumer> getConsumer(ResourcePath.Continuous resource) {
    Versioned<ContinuousResourceAllocation> allocations = continuousConsumers.get(resource.id());
    if (allocations == null) {
        return Optional.empty();
    }
    return allocations.value().allocations.stream().filter(x -> ((ResourcePath.Continuous) x.resource()).value() == resource.value()).map(ResourceAllocation::consumer).findAny();
}
#method_after
private List<ResourceConsumer> getConsumer(ResourcePath.Continuous resource) {
    Versioned<ContinuousResourceAllocation> allocations = continuousConsumers.get(resource.id());
    if (allocations == null) {
        return ImmutableList.of();
    }
    return allocations.value().allocations().stream().filter(x -> x.resource().equals(resource)).map(ResourceAllocation::consumer).collect(GuavaCollectors.toImmutableList());
}
#end_block

#method_before
@Override
public boolean isAvailable(ResourcePath resource) {
    if (resource instanceof ResourcePath.Discrete) {
        return !getConsumer((ResourcePath.Discrete) resource).isPresent();
    } else {
        return isAvailable((ResourcePath.Continuous) resource);
    }
}
#method_after
@Override
public boolean isAvailable(ResourcePath resource) {
    checkNotNull(resource);
    checkArgument(resource instanceof ResourcePath.Discrete || resource instanceof ResourcePath.Continuous);
    if (resource instanceof ResourcePath.Discrete) {
        return getConsumer((ResourcePath.Discrete) resource).isEmpty();
    } else {
        return isAvailable((ResourcePath.Continuous) resource);
    }
}
#end_block

#method_before
@Override
public Collection<ResourcePath> getResources(ResourceConsumer consumer) {
    checkNotNull(consumer);
    // NOTE: getting all entries may become performance bottleneck
    // TODO: revisit for better backend data structure
    Stream<ResourcePath.Discrete> discreteStream = discreteConsumers.entrySet().stream().filter(x -> x.getValue().value().equals(consumer)).map(Map.Entry::getKey);
    Stream<ResourcePath.Continuous> continuousStream = continuousConsumers.values().stream().flatMap(x -> x.value().allocations().stream().map(y -> new AbstractMap.SimpleImmutableEntry<>(x.value().original(), y))).filter(x -> x.getValue().consumer().equals(consumer)).map(x -> x.getKey());
    return Stream.concat(discreteStream, continuousStream).collect(Collectors.toList());
}
#method_after
@Override
public Collection<ResourcePath> getResources(ResourceConsumer consumer) {
    checkNotNull(consumer);
    // NOTE: getting all entries may become performance bottleneck
    // TODO: revisit for better backend data structure
    Stream<ResourcePath.Discrete> discreteStream = discreteConsumers.entrySet().stream().filter(x -> x.getValue().value().equals(consumer)).map(Map.Entry::getKey);
    Stream<ResourcePath.Continuous> continuousStream = continuousConsumers.values().stream().flatMap(x -> x.value().allocations().stream().map(y -> Maps.immutableEntry(x.value().original(), y))).filter(x -> x.getValue().consumer().equals(consumer)).map(x -> x.getKey());
    return Stream.concat(discreteStream, continuousStream).collect(Collectors.toList());
}
#end_block

#method_before
private boolean appendValue(TransactionalMap<ResourceId, ContinuousResourceAllocation> map, ResourcePath.Continuous original, ResourceAllocation value) {
    ContinuousResourceAllocation oldValue = map.putIfAbsent(original.id(), new ContinuousResourceAllocation(original, ImmutableList.<ResourceAllocation>builder().add(value).build()));
    if (oldValue == null) {
        return true;
    }
    LinkedHashSet<ResourceAllocation> oldSet = new LinkedHashSet<>(oldValue.allocations());
    if (oldSet.contains(value)) {
        // don't write to map because all values are already stored
        return true;
    }
    oldSet.add(value);
    return map.replace(original.id(), oldValue, new ContinuousResourceAllocation(original, ImmutableList.<ResourceAllocation>builder().addAll(oldSet).build()));
}
#method_after
private boolean appendValue(TransactionalMap<ResourceId, ContinuousResourceAllocation> map, ResourcePath.Continuous original, ResourceAllocation value) {
    ContinuousResourceAllocation oldValue = map.putIfAbsent(original.id(), new ContinuousResourceAllocation(original, ImmutableList.of(value)));
    if (oldValue == null) {
        return true;
    }
    if (oldValue.allocations().contains(value)) {
        // don't write to map because all values are already stored
        return true;
    }
    ContinuousResourceAllocation newValue = new ContinuousResourceAllocation(original, ImmutableList.<ResourceAllocation>builder().addAll(oldValue.allocations()).add(value).build());
    return map.replace(original.id(), oldValue, newValue);
}
#end_block

#method_before
@Test
public void testOduCltPort() {
    testSerializedEquals(new OduCltPort(DEV1, P1, true, OduCltPort.SignalType.CLT_10GBE));
    testSerializedEquals(new OduCltPort(DEV1, P1, true, OduCltPort.SignalType.CLT_10GBE, A1_2));
}
#method_after
@Test
public void testOduCltPort() {
    testSerializedEquals(new OduCltPort(DEV1, P1, true, CltSignalType.CLT_10GBE));
    testSerializedEquals(new OduCltPort(DEV1, P1, true, CltSignalType.CLT_10GBE, A1_2));
}
#end_block

#method_before
@Override
public int compareTo(Bandwidth other) {
    if (other instanceof LongBandwidth) {
        ComparisonChain.start().compare(this.bps, ((LongBandwidth) other).bps).result();
    }
    return ComparisonChain.start().compare(this.bps, other.bps()).result();
}
#method_after
@Override
public int compareTo(Bandwidth other) {
    if (other instanceof LongBandwidth) {
        return ComparisonChain.start().compare(this.bps, ((LongBandwidth) other).bps).result();
    }
    return ComparisonChain.start().compare(this.bps, other.bps()).result();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof LongBandwidth)) {
        return false;
    }
    LongBandwidth that = (LongBandwidth) obj;
    return Objects.equals(this.bps, that.bps);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Bandwidth) {
        return this.compareTo((Bandwidth) obj) == 0;
    }
    return false;
}
#end_block

#method_before
@POST
@Path("filter/{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFilteringObjective(@PathParam("deviceId") String deviceId, InputStream stream) {
    URI location = null;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        if (validateDeviceId(deviceId, jsonTree)) {
            DeviceId did = DeviceId.deviceId(deviceId);
            FilteringObjective filteringObjective = codec(FilteringObjective.class).decode(jsonTree, this);
            flowObjectiveService.filter(did, filteringObjective);
            location = new URI(Integer.toString(filteringObjective.id()));
        }
    } catch (IOException | URISyntaxException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.created(location).build();
}
#method_after
@POST
@Path("{deviceId}/filter")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFilteringObjective(@PathParam("deviceId") String deviceId, InputStream stream) {
    URI location = null;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        if (validateDeviceId(deviceId, jsonTree)) {
            DeviceId did = DeviceId.deviceId(deviceId);
            FilteringObjective filteringObjective = codec(FilteringObjective.class).decode(jsonTree, this);
            flowObjectiveService.filter(did, filteringObjective);
            location = new URI(Integer.toString(filteringObjective.id()));
        }
    } catch (IOException | URISyntaxException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.created(location).build();
}
#end_block

#method_before
@POST
@Path("forward/{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createForwardingObjective(@PathParam("deviceId") String deviceId, InputStream stream) {
    URI location = null;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        if (validateDeviceId(deviceId, jsonTree)) {
            DeviceId did = DeviceId.deviceId(deviceId);
            ForwardingObjective forwardingObjective = codec(ForwardingObjective.class).decode(jsonTree, this);
            flowObjectiveService.forward(did, forwardingObjective);
            location = new URI(Integer.toString(forwardingObjective.id()));
        }
    } catch (IOException | URISyntaxException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.created(location).build();
}
#method_after
@POST
@Path("{deviceId}/forward")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createForwardingObjective(@PathParam("deviceId") String deviceId, InputStream stream) {
    URI location = null;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        if (validateDeviceId(deviceId, jsonTree)) {
            DeviceId did = DeviceId.deviceId(deviceId);
            ForwardingObjective forwardingObjective = codec(ForwardingObjective.class).decode(jsonTree, this);
            flowObjectiveService.forward(did, forwardingObjective);
            location = new URI(Integer.toString(forwardingObjective.id()));
        }
    } catch (IOException | URISyntaxException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.created(location).build();
}
#end_block

#method_before
@POST
@Path("next/{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createNextObjective(@PathParam("deviceId") String deviceId, InputStream stream) {
    URI location = null;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        if (validateDeviceId(deviceId, jsonTree)) {
            DeviceId did = DeviceId.deviceId(deviceId);
            NextObjective nextObjective = codec(NextObjective.class).decode(jsonTree, this);
            flowObjectiveService.next(did, nextObjective);
            location = new URI(Integer.toString(nextObjective.id()));
        }
    } catch (IOException | URISyntaxException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.created(location).build();
}
#method_after
@POST
@Path("{deviceId}/next")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createNextObjective(@PathParam("deviceId") String deviceId, InputStream stream) {
    URI location = null;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        if (validateDeviceId(deviceId, jsonTree)) {
            DeviceId did = DeviceId.deviceId(deviceId);
            NextObjective nextObjective = codec(NextObjective.class).decode(jsonTree, this);
            flowObjectiveService.next(did, nextObjective);
            location = new URI(Integer.toString(nextObjective.id()));
        }
    } catch (IOException | URISyntaxException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.created(location).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public void initPolicy(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode policyJson = jsonTree.get("policy");
        if (policyJson == null || policyJson.asText().isEmpty()) {
            throw new IllegalArgumentException(POLICY_INVALID);
        }
        flowObjectiveService.initPolicy(policyJson.asText());
    } catch (IOException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
@POST
@Path("policy")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public void initPolicy(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode policyJson = jsonTree.get("policy");
        if (policyJson == null || policyJson.asText().isEmpty()) {
            throw new IllegalArgumentException(POLICY_INVALID);
        }
        flowObjectiveService.initPolicy(policyJson.asText());
    } catch (IOException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    registerDhcpInfo(openstackPort);
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.fixedIps().isEmpty()) {
        registerDhcpInfo(openstackPort);
    }
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#end_block

#method_before
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService);
    initializeFlowRules();
}
#method_after
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService, hostService);
    initializeFlowRules();
}
#end_block

#method_before
public SignalType signalType() {
    return signalType;
}
#method_after
public CltSignalType signalType() {
    return signalType;
}
#end_block

#method_before
public void enableCtrlMsgMonitor() {
    isCtrlMsgMonitor = true;
    controller.addEventListener(inMsgListener);
    for (OpenFlowSwitch sw : controller.getSwitches()) {
        sw.addEventListener(outMsgListener);
    }
    LOG.info("Enable control message monitoring.");
}
#method_after
public void enableCtrlMsgMonitor() {
    isCtrlMsgMonitor = true;
    controller.addEventListener(inMsgListener);
    controller.monitorAllEvents(isCtrlMsgMonitor);
    for (OpenFlowSwitch sw : controller.getSwitches()) {
        sw.addEventListener(outMsgListener);
    }
    LOG.info("Enable control message monitoring.");
}
#end_block

#method_before
public void disableCtrlMsgMonitor() {
    isCtrlMsgMonitor = false;
    controller.removeEventListener(inMsgListener);
    for (OpenFlowSwitch sw : controller.getSwitches()) {
        sw.removeEventListener(outMsgListener);
    }
    LOG.info("Disable control message monitoring");
}
#method_after
public void disableCtrlMsgMonitor() {
    isCtrlMsgMonitor = false;
    controller.monitorAllEvents(isCtrlMsgMonitor);
    controller.removeEventListener(inMsgListener);
    for (OpenFlowSwitch sw : controller.getSwitches()) {
        sw.removeEventListener(outMsgListener);
    }
    LOG.info("Disable control message monitoring");
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isCtrlMsgMonitor) {
    // TODO: feed the control message stats via ControlMetricsServiceFactory
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isCtrlMsgMonitor) {
    // TODO: handle all incoming OF messages
    }
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isCtrlMsgMonitor) {
    // TODO: feed the control message stats via ControlMetricsServiceFactory
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isCtrlMsgMonitor) {
    // TODO: handle all outgoing OF messages
    }
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port p = deviceService.getPort(this.data().deviceId(), port);
    // Only OMS ports expose lambda resources
    if (!p.type().equals(Port.Type.OMS)) {
        return Collections.emptySet();
    }
    short lambdaCount = ((OmsPort) p).totalChannels();
    // OMS ports expose 'lambdaCount' fixed grid lambdas of 50GHz width, starting from min-frequency 191.7 THz.
    return IntStream.rangeClosed(1, lambdaCount).mapToObj(x -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, x, 4)).collect(Collectors.toSet());
}
#method_after
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port p = deviceService.getPort(this.data().deviceId(), port);
    // Only OMS ports expose lambda resources
    if (!p.type().equals(Port.Type.OMS)) {
        return Collections.emptySet();
    }
    short lambdaCount = ((OmsPort) p).totalChannels();
    // OMS ports expose 'lambdaCount' fixed grid lambdas of 50GHz width, starting from min-frequency 191.7 THz.
    return IntStream.rangeClosed(1, lambdaCount).mapToObj(x -> OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, x)).collect(Collectors.toSet());
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(SDX_L3_APP);
    // TODO fix removing intents
    applicationService.registerDeactivateHook(appId, intentSynchronizerAdmin::removeIntents);
    log.info("SDX-L3 started");
}
#method_after
@Activate
protected void activate() {
    components.forEach(name -> componentService.activate(appId, name));
    appId = coreService.registerApplication(SDX_L3_APP);
    ApplicationId routerAppId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig bgpConfig = networkConfigService.getConfig(routerAppId, RoutingService.CONFIG_CLASS);
    arpHandler = new ArpHandler(bgpConfig, edgeService, hostService, packetService, interfaceService);
    processor = new InternalPacketProcessor();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    // TODO fix removing intents
    applicationService.registerDeactivateHook(appId, intentSynchronizerAdmin::removeIntents);
    log.info("SDX-L3 started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("SDX-L3 stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    components.forEach(name -> componentService.deactivate(appId, name));
    packetService.removeProcessor(processor);
    log.info("SDX-L3 stopped");
}
#end_block

#method_before
@Override
public String doRPC(String request) throws IOException {
    String reply = doRequest(request) + "\n" + endpattern;
    return checkReply(reply) ? reply : "ERROR " + reply;
}
#method_after
@Override
public String doRPC(String request) throws IOException {
    String reply = doRequest(request + "\n" + endpattern);
    return checkReply(reply) ? reply : "ERROR " + reply;
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration uploading. Device {} will be " + "processed after config completes.", device.id());
        return;
    }
    // per switch.
    if (groupHandlerMap.get(device.id()) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore, portNextObjStore);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        groupHandlerMap.put(device.id(), groupHandler);
        // Also, in some cases, drivers may need extra
        // information to process rules (eg. Router IP/MAC); and so, we send
        // port addressing rules to the driver as well irrespective of whether
        // this instance is the master or not.
        defaultRoutingHandler.populatePortAddressingRules(device.id());
        hostListener.readInitialHosts();
    }
    if (mastershipService.isLocalMaster(device.id())) {
        DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
        groupHandler.createGroupsFromSubnetConfig();
        routingRulePopulator.populateSubnetBroadcastRule(device.id());
    }
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration uploading. Device {} will be " + "processed after config completes.", device.id());
        return;
    }
    // per switch.
    if (groupHandlerMap.get(device.id()) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore, portNextObjStore, this);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        groupHandlerMap.put(device.id(), groupHandler);
        // Also, in some cases, drivers may need extra
        // information to process rules (eg. Router IP/MAC); and so, we send
        // port addressing rules to the driver as well irrespective of whether
        // this instance is the master or not.
        defaultRoutingHandler.populatePortAddressingRules(device.id());
        hostListener.readInitialHosts();
    }
    if (mastershipService.isLocalMaster(device.id())) {
        DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
        groupHandler.createGroupsFromSubnetConfig();
        routingRulePopulator.populateSubnetBroadcastRule(device.id());
    }
}
#end_block

#method_before
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // per switch.
        if (groupHandlerMap.get(device.id()) == null) {
            DefaultGroupHandler groupHandler;
            try {
                groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore, portNextObjStore);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting configureNetwork.");
                return;
            }
            groupHandlerMap.put(device.id(), groupHandler);
            // Also, in some cases, drivers may need extra
            // information to process rules (eg. Router IP/MAC); and so, we send
            // port addressing rules to the driver as well, irrespective of whether
            // this instance is the master or not.
            defaultRoutingHandler.populatePortAddressingRules(device.id());
            hostListener.readInitialHosts();
        }
        if (mastershipService.isLocalMaster(device.id())) {
            DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
            groupHandler.createGroupsFromSubnetConfig();
            routingRulePopulator.populateSubnetBroadcastRule(device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // per switch.
        if (groupHandlerMap.get(device.id()) == null) {
            DefaultGroupHandler groupHandler;
            try {
                groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore, portNextObjStore, segmentRoutingManager);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting configureNetwork.");
                return;
            }
            groupHandlerMap.put(device.id(), groupHandler);
            // Also, in some cases, drivers may need extra
            // information to process rules (eg. Router IP/MAC); and so, we send
            // port addressing rules to the driver as well, irrespective of whether
            // this instance is the master or not.
            defaultRoutingHandler.populatePortAddressingRules(device.id());
            hostListener.readInitialHosts();
        }
        if (mastershipService.isLocalMaster(device.id())) {
            DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
            groupHandler.createGroupsFromSubnetConfig();
            routingRulePopulator.populateSubnetBroadcastRule(device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private ForwardingObjective.Builder getForwardingObjectiveBuilder(DeviceId deviceId, MacAddress mac, VlanId vlanId, PortNumber outport) {
    // match rule
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    sbuilder.matchEthDst(mac);
    sbuilder.matchVlanId(vlanId);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.immediate().popVlan();
    tbuilder.immediate().setOutput(outport);
    // for switch pipelines that need it, provide outgoing vlan as metadata
    VlanId outvlan = null;
    Ip4Prefix subnet = deviceConfiguration.getPortSubnet(deviceId, outport);
    if (subnet == null) {
        outvlan = VlanId.vlanId(ASSIGNED_VLAN_NO_SUBNET);
    } else {
        outvlan = getSubnetAssignedVlanId(deviceId, subnet);
    }
    TrafficSelector meta = DefaultTrafficSelector.builder().matchVlanId(outvlan).build();
    // All forwarding is via Groups. Drivers can re-purpose to flow-actions if needed.
    int portNextObjId = getPortNextObjectiveId(deviceId, outport, tbuilder.build(), meta);
    return DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC).withSelector(sbuilder.build()).nextStep(portNextObjId).withPriority(100).fromApp(appId).makePermanent();
}
#method_after
private ForwardingObjective.Builder getForwardingObjectiveBuilder(DeviceId deviceId, MacAddress mac, VlanId vlanId, PortNumber outport) {
    // Get assigned VLAN for the subnet
    VlanId outvlan = null;
    Ip4Prefix subnet = deviceConfiguration.getPortSubnet(deviceId, outport);
    if (subnet == null) {
        outvlan = VlanId.vlanId(ASSIGNED_VLAN_NO_SUBNET);
    } else {
        outvlan = getSubnetAssignedVlanId(deviceId, subnet);
    }
    // match rule
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    sbuilder.matchEthDst(mac);
    /*
             * Note: for untagged packets, match on the assigned VLAN.
             *       for tagged packets, match on its incoming VLAN.
             */
    if (vlanId.equals(VlanId.NONE)) {
        sbuilder.matchVlanId(outvlan);
    } else {
        sbuilder.matchVlanId(vlanId);
    }
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.immediate().popVlan();
    tbuilder.immediate().setOutput(outport);
    // for switch pipelines that need it, provide outgoing vlan as metadata
    TrafficSelector meta = DefaultTrafficSelector.builder().matchVlanId(outvlan).build();
    // All forwarding is via Groups. Drivers can re-purpose to flow-actions if needed.
    int portNextObjId = getPortNextObjectiveId(deviceId, outport, tbuilder.build(), meta);
    return DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC).withSelector(sbuilder.build()).nextStep(portNextObjId).withPriority(100).fromApp(appId).makePermanent();
}
#end_block

#method_before
private void processBroadcastNextObjective(NextObjective nextObj) {
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    // each treatment is converted to an L2 interface group
    VlanId vlanid = null;
    List<GroupDescription> l2interfaceGroupDescs = new ArrayList<>();
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // also ensure that all ports are in the same vlan
        // XXX maybe HA issue here?
        VlanId thisvlanid = port2Vlan.get(portNum);
        if (vlanid == null) {
            vlanid = thisvlanid;
        } else {
            if (!vlanid.equals(thisvlanid)) {
                log.error("Driver requires all ports in a broadcast nextObj " + "to be in the same vlan. Different vlans found " + "{} and {}. Aborting group creation", vlanid, thisvlanid);
                return;
            }
        }
        // assemble info for l2 interface group
        int l2gk = 0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum.toLong());
        final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
        Integer l2groupId = L2INTERFACEMASK | (vlanid.toShort() << 16) | (int) portNum.toLong();
        GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2interfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(l2groupkey);
        // store the info needed to create this group
        l2interfaceGroupDescs.add(l2interfaceGroupDescription);
        allGroupKeys.add(gkeyChain);
    }
    // assemble info for l2 flood group
    Integer l2floodgroupId = L2FLOODMASK | (vlanid.toShort() << 16) | nextObj.id();
    int l2floodgk = L2FLOODMASK | nextObj.id() << 12;
    final GroupKey l2floodgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = new ArrayList<>();
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    }
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, l2interfaceGroupDescs.size(), false);
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l2floodgroupkey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l2floodgroupkey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        // store all l2groupkeys with the groupChainElem for the l2floodgroup
        // that depends on it
        updatePendingGroups(l2intGrpDesc.appCookie(), gce);
        // send groups for all l2 interface groups
        groupService.addGroup(l2intGrpDesc);
    }
}
#method_after
private void processBroadcastNextObjective(NextObjective nextObj) {
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    // Read VLAN information from the metadata
    TrafficSelector metadata = nextObj.meta();
    Criterion criterion = metadata.getCriterion(Criterion.Type.VLAN_VID);
    if (criterion == null) {
        log.warn("Required VLAN ID info in nextObj metadata but not found. Aborting");
        return;
    }
    VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
    // each treatment is converted to an L2 interface group
    List<GroupDescription> l2interfaceGroupDescs = new ArrayList<>();
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // Ensure that all ports of this broadcast nextObj are in the same vlan
        // XXX maybe HA issue here?
        VlanId expectedVlanId = port2Vlan.putIfAbsent(portNum, vlanId);
        if (expectedVlanId != null && !vlanId.equals(expectedVlanId)) {
            log.error("Driver requires all ports in a broadcast nextObj " + "to be in the same vlan. Different vlans found " + "{} and {}. Aborting group creation", vlanId, expectedVlanId);
            return;
        }
        // assemble info for l2 interface group
        int l2gk = 0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum.toLong());
        final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
        Integer l2groupId = L2INTERFACEMASK | (vlanId.toShort() << 16) | (int) portNum.toLong();
        GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2interfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(l2groupkey);
        // store the info needed to create this group
        l2interfaceGroupDescs.add(l2interfaceGroupDescription);
        allGroupKeys.add(gkeyChain);
    }
    // assemble info for l2 flood group
    Integer l2floodgroupId = L2FLOODMASK | (vlanId.toShort() << 16) | nextObj.id();
    int l2floodgk = L2FLOODMASK | nextObj.id() << 12;
    final GroupKey l2floodgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = new ArrayList<>();
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    }
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, l2interfaceGroupDescs.size(), false);
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l2floodgroupkey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l2floodgroupkey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        // store all l2groupkeys with the groupChainElem for the l2floodgroup
        // that depends on it
        updatePendingGroups(l2intGrpDesc.appCookie(), gce);
        // send groups for all l2 interface groups
        groupService.addGroup(l2intGrpDesc);
    }
}
#end_block

#method_before
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
    // listen to outgoing control messages
    msgs.forEach(m -> {
        if (m.getType() == OFType.PACKET_OUT || m.getType() == OFType.FLOW_MOD || m.getType() == OFType.STATS_REQUEST) {
            executorMsgs.submit(new OFMessageHandler(dpid, m));
        }
    });
}
#method_after
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
    // listen to outgoing control messages only if listeners are registered
    if (ofOutgoingMsgListener.size() != 0) {
        msgs.forEach(m -> {
            if (m.getType() == OFType.PACKET_OUT || m.getType() == OFType.FLOW_MOD || m.getType() == OFType.STATS_REQUEST) {
                executorMsgs.submit(new OFMessageHandler(dpid, m));
            }
        });
    }
}
#end_block

#method_before
@Override
public void addEventListener(OpenFlowEventListener listener) {
    ofEventListener.add(listener);
}
#method_after
@Override
public void addEventListener(OpenFlowEventListener listener) {
    ofOutgoingMsgListener.add(listener);
}
#end_block

#method_before
@Override
public void removeEventListener(OpenFlowEventListener listener) {
    ofEventListener.remove(listener);
}
#method_after
@Override
public void removeEventListener(OpenFlowEventListener listener) {
    ofOutgoingMsgListener.remove(listener);
}
#end_block

#method_before
@Override
public void run() {
    for (OpenFlowEventListener listener : ofEventListener) {
        listener.handleMessage(dpid, msg);
    }
}
#method_after
@Override
public void run() {
    for (OpenFlowEventListener listener : ofOutgoingMsgListener) {
        listener.handleMessage(dpid, msg);
    }
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            executorPacketIn.submit(new OFMessageHandler(dpid, msg));
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case ERROR:
            log.debug("Received error message from {}: {}", dpid, msg);
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            if (monitorAllEvents) {
                executorPacketIn.submit(new OFMessageHandler(dpid, msg));
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
            if (monitorAllEvents) {
                executorFlowRemoved.submit(new OFMessageHandler(dpid, msg));
                break;
            }
        case ERROR:
            log.debug("Received error message from {}: {}", dpid, msg);
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
public double getCount() {
    return countMeter.getOneMinuteRate();
}
#method_after
public double getCount() {
    return countMeter.getOneMinuteRate() * EXECUTE_PERIOD_IN_SECOND;
}
#end_block

#method_before
// Locates the property in the component map and replaces it with an
private void set(String componentName, String name, String value) {
    Map<String, ConfigProperty> map = properties.get(componentName);
    if (map != null) {
        ConfigProperty prop = map.get(name);
        if (prop != null) {
            map.put(name, ConfigProperty.setProperty(prop, value));
            accumulator.add(componentName);
            return;
        }
    }
    // Stores non-existent property for future loadExistingValues()
    try {
        Configuration config = cfgAdmin.getConfiguration(componentName);
        if (config == null) {
            config = cfgAdmin.createFactoryConfiguration(componentName);
        }
        Dictionary<String, Object> property = config.getProperties();
        if (property == null) {
            property = new Hashtable<>();
        }
        property.put(name, value);
        config.update(property);
    } catch (IOException e) {
        log.error("Failed to create configuration for {}", componentName);
    }
}
#method_after
// Locates the property in the component map and replaces it with an
private void set(String componentName, String name, String value) {
    Map<String, ConfigProperty> map = properties.get(componentName);
    if (map != null) {
        ConfigProperty prop = map.get(name);
        if (prop != null) {
            map.put(name, ConfigProperty.setProperty(prop, value));
            accumulator.add(componentName);
            return;
        }
    }
    // If definition doesn't exist in local catalog, cache the property.
    preSet(componentName, name, value);
}
#end_block

#method_before
public void populateServiceDependencyRules(FlowInfo flowInfo, Map<DeviceId, Set<PortNumber>> inports, Map<DeviceId, GroupId> outgroups) {
    checkNotNull(flowInfo);
    populateIndirectAccessRule(flowInfo, outgroups);
    FlowInfo reverseSubnet = FlowInfo.builder().srcRange(flowInfo.dstRange()).dstRange(flowInfo.srcRange()).build();
    populateDirectAccessRule(flowInfo);
    populateDirectAccessRule(reverseSubnet);
    populateInServiceRule(inports, outgroups);
}
#method_after
public void populateServiceDependencyRules(CordService tService, CordService pService) {
    checkNotNull(tService);
    checkNotNull(pService);
    Ip4Prefix srcRange = tService.serviceIpRange().getIp4Prefix();
    Ip4Prefix dstRange = pService.serviceIpRange().getIp4Prefix();
    Ip4Address serviceIp = pService.serviceIp().getIp4Address();
    Map<DeviceId, GroupId> outGroups = Maps.newHashMap();
    Map<DeviceId, Set<PortNumber>> inPorts = Maps.newHashMap();
    for (Device device : deviceService.getAvailableDevices(SWITCH)) {
        GroupId groupId = createServiceGroup(device.id(), pService);
        outGroups.put(device.id(), groupId);
        Set<PortNumber> vms = tService.hosts().keySet().stream().filter(host -> host.location().deviceId().equals(device.id())).map(host -> host.location().port()).collect(Collectors.toSet());
        inPorts.put(device.id(), vms);
    }
    populateIndirectAccessRule(srcRange, serviceIp, outGroups);
    populateDirectAccessRule(srcRange, dstRange);
    populateInServiceRule(inPorts, outGroups);
}
#end_block

#method_before
public void removeServiceDependencyRules(FlowInfo flowInfo, Map<DeviceId, GroupId> outgroups) {
// TODO remove service dependency rules
}
#method_after
public void removeServiceDependencyRules(CordService tService, CordService pService) {
    checkNotNull(tService);
    checkNotNull(pService);
    Ip4Prefix srcRange = tService.serviceIpRange().getIp4Prefix();
    Ip4Prefix dstRange = pService.serviceIpRange().getIp4Prefix();
    IpPrefix serviceIp = pService.serviceIp().toIpPrefix();
    Map<DeviceId, GroupId> outGroups = Maps.newHashMap();
    GroupKey groupKey = new DefaultGroupKey(pService.id().id().getBytes());
    deviceService.getAvailableDevices(SWITCH).forEach(device -> {
        Group group = groupService.getGroup(device.id(), groupKey);
        if (group != null) {
            outGroups.put(device.id(), group.id());
        }
    });
    for (FlowRule flowRule : flowRuleService.getFlowRulesById(appId)) {
        IpPrefix dstIp = getDstIpFromSelector(flowRule);
        IpPrefix srcIp = getSrcIpFromSelector(flowRule);
        if (dstIp != null && dstIp.equals(serviceIp)) {
            processFlowRule(false, flowRule);
            continue;
        }
        if (dstIp != null && srcIp != null) {
            if (dstIp.equals(dstRange) && srcIp.equals(srcRange)) {
                processFlowRule(false, flowRule);
                continue;
            }
            if (dstIp.equals(srcRange) && srcIp.equals(dstRange)) {
                processFlowRule(false, flowRule);
                continue;
            }
        }
        GroupId groupId = getGroupIdFromTreatment(flowRule);
        if (groupId != null && groupId.equals(outGroups.get(flowRule.deviceId()))) {
            processFlowRule(false, flowRule);
        }
    }
// TODO remove the group if it is not in use
}
#end_block

#method_before
public GroupBuckets getServiceGroupBuckets(DeviceId deviceId, long tunnelId, Map<Host, Ip4Address> hosts) {
    List<GroupBucket> buckets = Lists.newArrayList();
    for (Map.Entry<Host, Ip4Address> entry : hosts.entrySet()) {
        Host host = entry.getKey();
        Ip4Address remoteIp = entry.getValue();
        DeviceId hostDevice = host.location().deviceId();
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(host.mac());
        if (deviceId.equals(hostDevice)) {
            tBuilder.setOutput(host.location().port());
        } else {
            ExtensionTreatment tunnelDst = getTunnelDst(deviceId, remoteIp);
            if (tunnelDst == null) {
                continue;
            }
            tBuilder.extension(tunnelDst, deviceId).setTunnelId(tunnelId).setOutput(getTunnelPort(hostDevice));
        }
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    return new GroupBuckets(buckets);
}
#method_after
private GroupBuckets getServiceGroupBuckets(DeviceId deviceId, long tunnelId, Map<Host, IpAddress> hosts) {
    List<GroupBucket> buckets = Lists.newArrayList();
    for (Map.Entry<Host, IpAddress> entry : hosts.entrySet()) {
        Host host = entry.getKey();
        Ip4Address remoteIp = entry.getValue().getIp4Address();
        DeviceId hostDevice = host.location().deviceId();
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(host.mac());
        if (deviceId.equals(hostDevice)) {
            tBuilder.setOutput(host.location().port());
        } else {
            ExtensionTreatment tunnelDst = getTunnelDst(deviceId, remoteIp);
            if (tunnelDst == null) {
                continue;
            }
            tBuilder.extension(tunnelDst, deviceId).setTunnelId(tunnelId).setOutput(getTunnelPort(hostDevice));
        }
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    return new GroupBuckets(buckets);
}
#end_block

#method_before
private void populateLocalInPortRule(DeviceId deviceId, FlowInfo flowInfo) {
    checkNotNull(flowInfo);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(flowInfo.inPort()).matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(flowInfo.ip()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_ACCESS_TYPE).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(flowInfo.inPort()).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_SERVICE).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWER_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void populateLocalInPortRule(DeviceId deviceId, PortNumber inPort, IpAddress srcIp) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_ACCESS_TYPE).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(inPort).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_SERVICE).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWER_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_PORT).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private void populateDirectAccessRule(FlowInfo flowInfo) {
    checkNotNull(flowInfo);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(flowInfo.srcRange()).matchIPDst(flowInfo.dstRange()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    for (Device device : deviceService.getAvailableDevices(SWITCH)) {
        FlowRule flowRuleDirect = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWER_PRIORITY).forDevice(device.id()).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
        processFlowRule(true, flowRuleDirect);
    }
}
#method_after
private void populateDirectAccessRule(Ip4Prefix srcRange, Ip4Prefix dstRange) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcRange).matchIPDst(dstRange).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    for (Device device : deviceService.getAvailableDevices(SWITCH)) {
        FlowRule flowRuleDirect = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWER_PRIORITY).forDevice(device.id()).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
        processFlowRule(true, flowRuleDirect);
    }
}
#end_block

#method_before
private void populateIndirectAccessRule(FlowInfo flowInfo, Map<DeviceId, GroupId> outgroups) {
    checkNotNull(flowInfo);
    checkNotNull(outgroups);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(flowInfo.srcRange().getIp4Prefix()).matchIPDst(flowInfo.serviceIp().toIpPrefix().getIp4Prefix()).build();
    for (Map.Entry<DeviceId, GroupId> outgroup : outgroups.entrySet()) {
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(outgroup.getValue()).build();
        FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(outgroup.getKey()).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
        processFlowRule(true, flowRule);
    }
}
#method_after
private void populateIndirectAccessRule(Ip4Prefix srcRange, Ip4Address serviceIp, Map<DeviceId, GroupId> outGroups) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcRange).matchIPDst(serviceIp.toIpPrefix()).build();
    for (Map.Entry<DeviceId, GroupId> outGroup : outGroups.entrySet()) {
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(outGroup.getValue()).build();
        FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(outGroup.getKey()).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
        processFlowRule(true, flowRule);
    }
}
#end_block

#method_before
private void populateInServiceRule(Map<DeviceId, Set<PortNumber>> inports, Map<DeviceId, GroupId> outgroups) {
    checkNotNull(inports);
    checkNotNull(outgroups);
    for (Map.Entry<DeviceId, Set<PortNumber>> entry : inports.entrySet()) {
        DeviceId deviceId = entry.getKey();
        Set<PortNumber> ports = entry.getValue();
        ports.stream().forEach(port -> {
            TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(port).build();
            TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(outgroups.get(deviceId)).build();
            FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_SERVICE).makePermanent().build();
            processFlowRule(true, flowRule);
        });
    }
}
#method_after
private void populateInServiceRule(Map<DeviceId, Set<PortNumber>> inPorts, Map<DeviceId, GroupId> outGroups) {
    checkNotNull(inPorts);
    checkNotNull(outGroups);
    for (Map.Entry<DeviceId, Set<PortNumber>> entry : inPorts.entrySet()) {
        Set<PortNumber> ports = entry.getValue();
        DeviceId deviceId = entry.getKey();
        GroupId groupId = outGroups.get(deviceId);
        if (groupId == null) {
            continue;
        }
        ports.stream().forEach(port -> {
            TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(port).build();
            TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
            FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_IN_SERVICE).makePermanent().build();
            processFlowRule(true, flowRule);
        });
    }
}
#end_block

#method_before
private void populateDstIpRule(DeviceId deviceId, FlowInfo flowInfo) {
    checkNotNull(flowInfo);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(flowInfo.ip()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(flowInfo.mac()).setOutput(flowInfo.inPort()).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_DST_IP).makePermanent().build();
    processFlowRule(true, flowRule);
    for (Device device : deviceService.getAvailableDevices(SWITCH)) {
        if (device.id().equals(deviceId)) {
            continue;
        }
        ExtensionTreatment tunnelDst = getTunnelDst(device.id(), flowInfo.tunnelIp());
        if (tunnelDst == null) {
            continue;
        }
        treatment = DefaultTrafficTreatment.builder().setEthDst(flowInfo.mac()).setTunnelId(flowInfo.tunnelId()).extension(tunnelDst, device.id()).setOutput(getTunnelPort(device.id())).build();
        flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(device.id()).forTable(TABLE_DST_IP).makePermanent().build();
        processFlowRule(true, flowRule);
    }
}
#method_after
private void populateDstIpRule(DeviceId deviceId, PortNumber inPort, MacAddress dstMac, IpAddress dstIp, long tunnelId, IpAddress tunnelIp) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dstIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(dstMac).setOutput(inPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_DST_IP).makePermanent().build();
    processFlowRule(true, flowRule);
    for (Device device : deviceService.getAvailableDevices(SWITCH)) {
        if (device.id().equals(deviceId)) {
            continue;
        }
        ExtensionTreatment tunnelDst = getTunnelDst(device.id(), tunnelIp.getIp4Address());
        if (tunnelDst == null) {
            continue;
        }
        treatment = DefaultTrafficTreatment.builder().setEthDst(dstMac).setTunnelId(tunnelId).extension(tunnelDst, device.id()).setOutput(getTunnelPort(device.id())).build();
        flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(device.id()).forTable(TABLE_DST_IP).makePermanent().build();
        processFlowRule(true, flowRule);
    }
}
#end_block

#method_before
private void populateTunnelInRule(DeviceId deviceId, FlowInfo flowInfo) {
    checkNotNull(flowInfo);
    TrafficSelector selector = DefaultTrafficSelector.builder().matchTunnelId(flowInfo.tunnelId()).matchEthDst(flowInfo.mac()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(flowInfo.inPort()).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_TUNNEL_IN).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void populateTunnelInRule(DeviceId deviceId, PortNumber inPort, MacAddress mac, long tunnelId) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchTunnelId(tunnelId).matchEthDst(mac).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(inPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(DEFAULT_PRIORITY).forDevice(deviceId).forTable(TABLE_TUNNEL_IN).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.cordvtn");
    nodeStore = storageService.<CordVtnNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    ruleInstaller = new CordVtnRuleInstaller(appId, flowRuleService, deviceService, driverService, DEFAULT_TUNNEL);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.cordvtn");
    nodeStore = storageService.<CordVtnNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    ruleInstaller = new CordVtnRuleInstaller(appId, flowRuleService, deviceService, driverService, groupService, mastershipService, DEFAULT_TUNNEL);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void createServiceDependency(CordServiceId tServiceId, CordServiceId pServiceId) {
    CordService tService = getCordService(tServiceId);
    CordService pService = getCordService(pServiceId);
    if (tService == null || pService == null) {
        log.error("Failed to create CordService for {}", tServiceId.id());
        return;
    }
    installServiceDependencyRules(tService, pService);
}
#method_after
@Override
public void createServiceDependency(CordServiceId tServiceId, CordServiceId pServiceId) {
    CordService tService = getCordService(tServiceId);
    CordService pService = getCordService(pServiceId);
    if (tService == null || pService == null) {
        log.error("Failed to create CordService for {}", tServiceId.id());
        return;
    }
    ruleInstaller.populateServiceDependencyRules(tService, pService);
}
#end_block

#method_before
@Override
public void removeServiceDependency(CordServiceId tServiceId, CordServiceId pServiceId) {
    CordService tService = getCordService(tServiceId);
    CordService pService = getCordService(pServiceId);
    if (tService == null || pService == null) {
        log.error("Failed to create CordService for {}", tServiceId.id());
        return;
    }
    uninstallServiceDependencyRules(tService, pService);
}
#method_after
@Override
public void removeServiceDependency(CordServiceId tServiceId, CordServiceId pServiceId) {
    CordService tService = getCordService(tServiceId);
    CordService pService = getCordService(pServiceId);
    if (tService == null || pService == null) {
        log.error("Failed to create CordService for {}", tServiceId.id());
        return;
    }
    ruleInstaller.removeServiceDependencyRules(tService, pService);
}
#end_block

#method_before
private void postInit(CordVtnNode node) {
    log.info("Initializing {}", node.hostname());
    disconnect(node);
    ruleInstaller.init(node.intBrId(), getTunnelPort(node.intBrId()));
    hostService.getConnectedHosts(node.intBrId()).stream().filter(host -> !isGateway(host)).forEach(host -> {
        OpenstackNetwork vNet = getOpenstackNetworkByHost(host);
        if (vNet != null) {
            installBasicFlowRules(host, vNet);
        // TODO get service dependency and install related rules
        }
    });
}
#method_after
private void postInit(CordVtnNode node) {
    log.info("Initializing {}", node.hostname());
    disconnect(node);
    ruleInstaller.init(node.intBrId(), getTunnelPort(node.intBrId()));
    hostService.getConnectedHosts(node.intBrId()).stream().forEach(vmHandler::connected);
}
#end_block

#method_before
private CordService getCordService(CordServiceId serviceId) {
    OpenstackNetwork vNet = openstackService.network(serviceId.id());
    if (vNet == null) {
        log.warn("Couldn't find OpenStack network for service {}", serviceId.id());
        return null;
    }
    OpenstackSubnet subnet = vNet.subnets().stream().findFirst().orElse(null);
    if (subnet == null) {
        log.warn("Couldn't find OpenStack subnet for service {}", serviceId.id());
        return null;
    }
    return new CordService(serviceId, Long.parseLong(vNet.segmentId()), CordService.ServiceType.valueOf(vNet.name().toUpperCase()), IpPrefix.valueOf(subnet.cidr()), IpAddress.valueOf(subnet.gatewayIp()), getHostsWithOpenstackNetwork(vNet));
}
#method_after
private CordService getCordService(CordServiceId serviceId) {
    OpenstackNetwork vNet = openstackService.network(serviceId.id());
    if (vNet == null) {
        log.warn("Couldn't find OpenStack network for service {}", serviceId.id());
        return null;
    }
    OpenstackSubnet subnet = vNet.subnets().stream().findFirst().orElse(null);
    if (subnet == null) {
        log.warn("Couldn't find OpenStack subnet for service {}", serviceId.id());
        return null;
    }
    Set<CordServiceId> tServices = Sets.newHashSet();
    // TODO get tenant services from XOS
    Map<Host, IpAddress> hosts = getHostsWithOpenstackNetwork(vNet).stream().collect(Collectors.toMap(host -> host, host -> getRemoteIp(host.location().deviceId())));
    return new CordService(vNet, subnet, hosts, tServices);
}
#end_block

#method_before
private CordService getCordService(CordServiceId serviceId) {
    OpenstackNetwork vNet = openstackService.network(serviceId.id());
    if (vNet == null) {
        log.warn("Couldn't find OpenStack network for service {}", serviceId.id());
        return null;
    }
    OpenstackSubnet subnet = vNet.subnets().stream().findFirst().orElse(null);
    if (subnet == null) {
        log.warn("Couldn't find OpenStack subnet for service {}", serviceId.id());
        return null;
    }
    return new CordService(serviceId, Long.parseLong(vNet.segmentId()), CordService.ServiceType.valueOf(vNet.name().toUpperCase()), IpPrefix.valueOf(subnet.cidr()), IpAddress.valueOf(subnet.gatewayIp()), getHostsWithOpenstackNetwork(vNet));
}
#method_after
private CordService getCordService(OpenstackNetwork vNet) {
    checkNotNull(vNet);
    CordServiceId serviceId = CordServiceId.of(vNet.id());
    OpenstackSubnet subnet = vNet.subnets().stream().findFirst().orElse(null);
    if (subnet == null) {
        log.warn("Couldn't find OpenStack subnet for service {}", serviceId);
        return null;
    }
    Set<CordServiceId> tServices = Sets.newHashSet();
    // TODO get tenant services from XOS
    Map<Host, IpAddress> hosts = getHostsWithOpenstackNetwork(vNet).stream().collect(Collectors.toMap(host -> host, host -> getRemoteIp(host.location().deviceId())));
    return new CordService(vNet, subnet, hosts, tServices);
}
#end_block

#method_before
public void portAdded(Port port) {
    if (!port.annotations().value("portName").contains(DEFAULT_TUNNEL)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        setNodeState(node, checkNodeState(node));
    }
}
#method_after
public void portAdded(Port port) {
    // TODO add host by updating network config
    if (!port.annotations().value("portName").contains(DEFAULT_TUNNEL)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        setNodeState(node, checkNodeState(node));
    }
}
#end_block

#method_before
public void portRemoved(Port port) {
    if (!port.annotations().value("portName").contains(DEFAULT_TUNNEL)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        log.info("Tunnel interface is removed from {}", node.hostname());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#method_after
public void portRemoved(Port port) {
    // TODO remove host by updating network config
    if (!port.annotations().value("portName").contains(DEFAULT_TUNNEL)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        log.info("Tunnel interface is removed from {}", node.hostname());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#end_block

#method_before
@Override
public void connected(Host host) {
    // TODO remove check gateway here after applying network config host provider
    if (isGateway(host)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId(host.location().deviceId());
    if (node == null || !Objects.equals(getNodeState(node), NodeState.COMPLETE)) {
        // do nothing for the host on unregistered or unprepared device
        return;
    }
    OpenstackNetwork vNet = getOpenstackNetworkByHost(host);
    if (vNet == null) {
        return;
    }
    log.info("VM {} is detected", host.id());
    installBasicFlowRules(host, vNet);
// TODO add new VM to related service group if exists
}
#method_after
@Override
public void connected(Host host) {
    // TODO remove check gateway here after applying network config host provider
    if (isGateway(host)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId(host.location().deviceId());
    if (node == null || !Objects.equals(getNodeState(node), NodeState.COMPLETE)) {
        // do nothing for the host on unregistered or unprepared device
        return;
    }
    OpenstackNetwork vNet = getOpenstackNetworkByHost(host);
    if (vNet == null) {
        return;
    }
    // TODO host ip should be set in host information after applying network config host provider
    IpAddress hostIp = getHostIpFromOpenstack(host);
    if (hostIp == null) {
        log.error("Failed to get host IP of {}", host.id());
        return;
    }
    log.info("VM {} is detected", host.id());
    hostNetMap.put(host.id(), vNet);
    ruleInstaller.populateBasicConnectionRules(host, hostIp, checkNotNull(getRemoteIp(host.location().deviceId())).getIp4Address(), vNet);
// TODO add new VM to related service group if exists
}
#end_block

#method_before
@Override
public void disconnected(Host host) {
    CordVtnNode node = getNodeByBridgeId(host.location().deviceId());
    if (node == null || !Objects.equals(getNodeState(node), NodeState.COMPLETE)) {
        // do nothing for the host on unregistered or unprepared device
        return;
    }
    log.info("VM {} is vanished", host.id());
    uninstallBasicFlowRules(host);
// TODO remove the VM from related service group if exists
}
#method_after
@Override
public void disconnected(Host host) {
    CordVtnNode node = getNodeByBridgeId(host.location().deviceId());
    if (node == null || !Objects.equals(getNodeState(node), NodeState.COMPLETE)) {
        // do nothing for the host on unregistered or unprepared device
        return;
    }
    OpenstackNetwork vNet = hostNetMap.get(host.id());
    if (vNet == null) {
        return;
    }
    log.info("VM {} is vanished", host.id());
    ruleInstaller.removeBasicConnectionRules(host);
    // TODO remove the VM from related service group if exists
    hostNetMap.remove(host.id());
}
#end_block

#method_before
public Set<Host> hosts() {
    return hosts;
}
#method_after
public Map<Host, IpAddress> hosts() {
    return hosts;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("id", id).add("segmentationId", segmentationId).add("serviceType", serviceType).add("serviceIpRange", serviceIpRange).add("serviceIp", serviceIp).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("id", id).add("segmentationId", segmentationId).add("serviceType", serviceType).add("serviceIpRange", serviceIpRange).add("serviceIp", serviceIp).add("tenantServices", tenantServices).toString();
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case DEVICE_ADDED:
            registerDeviceResource(device);
            break;
        case DEVICE_REMOVED:
            unregisterDeviceResource(device);
            break;
        case PORT_ADDED:
            registerPortResource(device, event.port());
            break;
        case PORT_REMOVED:
            unregisterPortResource(device, event.port());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case DEVICE_ADDED:
            registerDeviceResource(device);
            break;
        case DEVICE_REMOVED:
            unregisterDeviceResource(device);
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                registerDeviceResource(device);
            // TODO: do we need to walk the ports?
            } else {
                unregisterDeviceResource(device);
            }
            break;
        case PORT_ADDED:
        case PORT_UPDATED:
            if (event.port().isEnabled()) {
                registerPortResource(device, event.port());
            } else {
                unregisterPortResource(device, event.port());
            }
            break;
        case PORT_REMOVED:
            unregisterPortResource(device, event.port());
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void registerPortResource(Device device, Port port) {
    ResourcePath portPath = ResourcePath.discrete(device.id(), port.number());
    executor.submit(() -> {
        adminService.registerResources(portPath);
        // for VLAN IDs
        if (isVlanEnabled(device.id(), port.number())) {
            adminService.registerResources(Lists.transform(ENTIRE_VLAN_IDS, portPath::child));
        }
        // for MPLS labels
        if (isMplsEnabled(device.id(), port.number())) {
            adminService.registerResources(Lists.transform(ENTIRE_MPLS_LABELS, portPath::child));
        }
        // for Lambdas
        SortedSet<OchSignal> lambdas = queryLambdas(device.id(), port.number());
        if (!lambdas.isEmpty()) {
            adminService.registerResources(lambdas.stream().map(portPath::child).collect(Collectors.toList()));
        }
        // for Tributary slots
        switch(port.type()) {
            case OCH:
                // register ODU TributarySlots against the OCH port
                List<TributarySlot> tSlots = getAvailableTributarySlots(device.id(), (OchPort) port);
                if (tSlots != null) {
                    adminService.registerResources(Lists.transform(tSlots, portPath::child));
                }
                break;
            default:
                break;
        }
    });
}
#method_after
private void registerPortResource(Device device, Port port) {
    ResourcePath portPath = ResourcePath.discrete(device.id(), port.number());
    executor.submit(() -> {
        adminService.registerResources(portPath);
        // for VLAN IDs
        Set<VlanId> vlans = queryVlanIds(device.id(), port.number());
        if (!vlans.isEmpty()) {
            adminService.registerResources(vlans.stream().map(portPath::child).collect(Collectors.toList()));
        }
        // for MPLS labels
        Set<MplsLabel> mplsLabels = queryMplsLabels(device.id(), port.number());
        if (!mplsLabels.isEmpty()) {
            adminService.registerResources(mplsLabels.stream().map(portPath::child).collect(Collectors.toList()));
        }
        // for Lambdas
        Set<OchSignal> lambdas = queryLambdas(device.id(), port.number());
        if (!lambdas.isEmpty()) {
            adminService.registerResources(lambdas.stream().map(portPath::child).collect(Collectors.toList()));
        }
        // for Tributary slots
        Set<TributarySlot> tSlots = queryTributarySlots(device.id(), port.number());
        if (!tSlots.isEmpty()) {
            adminService.registerResources(tSlots.stream().map(portPath::child).collect(Collectors.toList()));
        }
    });
}
#end_block

#method_before
private SortedSet<OchSignal> queryLambdas(DeviceId did, PortNumber port) {
    try {
        DriverHandler handler = driverService.createHandler(did);
        if (handler == null) {
            return Collections.emptySortedSet();
        }
        LambdaQuery query = handler.behaviour(LambdaQuery.class);
        return query.queryLambdas(port);
    } catch (ItemNotFoundException e) {
        return Collections.emptySortedSet();
    }
}
#method_after
private Set<OchSignal> queryLambdas(DeviceId did, PortNumber port) {
    try {
        // DriverHandler does not provide a way to check if a
        // behaviour is supported.
        Driver driver = driverService.getDriver(did);
        if (driver == null || !driver.hasBehaviour(LambdaQuery.class)) {
            return Collections.emptySet();
        }
        DriverHandler handler = driverService.createHandler(did);
        if (handler == null) {
            return Collections.emptySet();
        }
        LambdaQuery query = handler.behaviour(LambdaQuery.class);
        if (query != null) {
            return query.queryLambdas(port).stream().flatMap(x -> OchSignal.toFlexGrid(x).stream()).collect(Collectors.toSet());
        } else {
            return Collections.emptySet();
        }
    } catch (ItemNotFoundException e) {
        return Collections.emptySet();
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    cfgRegistry.addListener(cfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
    SuppressionConfig cfg = cfgRegistry.getConfig(appId, SuppressionConfig.class);
    if (cfg == null) {
        // If no configuration is found, register default.
        cfg = cfgRegistry.addConfig(appId, SuppressionConfig.class);
        cfg.deviceTypes(DEFAULT_RULES.getSuppressedDeviceType()).annotation(DEFAULT_RULES.getSuppressedAnnotation()).apply();
    }
    cfgListener.reconfigureSuppressionRules(cfg);
    modified(context);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    cfgRegistry.addListener(cfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
    SuppressionConfig cfg = Tools.retryable(() -> cfgRegistry.getConfig(appId, SuppressionConfig.class), ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    if (cfg == null) {
        // If no configuration is found, register default.
        cfg = Tools.retryable(this::setDefaultSuppressionConfig, ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    }
    cfgListener.reconfigureSuppressionRules(cfg);
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    Port port = event.port();
    if (device == null) {
        log.error("Device is null.");
        return;
    }
    log.trace("{} {} {}", event.type(), event.subject(), event);
    final DeviceId deviceId = device.id();
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_UPDATED:
            updateDevice(device).ifPresent(ld -> updatePorts(ld, deviceId));
            break;
        case PORT_ADDED:
        case PORT_UPDATED:
            if (port.isEnabled()) {
                updateDevice(device).ifPresent(ld -> updatePort(ld, port));
            } else {
                log.debug("Port down {}", port);
                removePort(port);
                providerService.linksVanished(new ConnectPoint(port.element().id(), port.number()));
            }
            break;
        case PORT_REMOVED:
            log.debug("Port removed {}", port);
            removePort(port);
            providerService.linksVanished(new ConnectPoint(port.element().id(), port.number()));
            break;
        case DEVICE_REMOVED:
        case DEVICE_SUSPENDED:
            log.debug("Device removed {}", deviceId);
            removeDevice(deviceId);
            providerService.linksVanished(deviceId);
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(deviceId)) {
                log.debug("Device up {}", deviceId);
                updateDevice(device).ifPresent(ld -> updatePorts(ld, deviceId));
            } else {
                log.debug("Device down {}", deviceId);
                removeDevice(deviceId);
                providerService.linksVanished(deviceId);
            }
            break;
        case PORT_STATS_UPDATED:
            break;
        default:
            log.debug("Unknown event {}", event);
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    if (event.type() == Type.PORT_STATS_UPDATED) {
        return;
    }
    Device device = event.subject();
    Port port = event.port();
    if (device == null) {
        log.error("Device is null.");
        return;
    }
    log.trace("{} {} {}", event.type(), event.subject(), event);
    final DeviceId deviceId = device.id();
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_UPDATED:
            updateDevice(device).ifPresent(ld -> updatePorts(ld, deviceId));
            break;
        case PORT_ADDED:
        case PORT_UPDATED:
            if (port.isEnabled()) {
                updateDevice(device).ifPresent(ld -> updatePort(ld, port));
            } else {
                log.debug("Port down {}", port);
                removePort(port);
                providerService.linksVanished(new ConnectPoint(port.element().id(), port.number()));
            }
            break;
        case PORT_REMOVED:
            log.debug("Port removed {}", port);
            removePort(port);
            providerService.linksVanished(new ConnectPoint(port.element().id(), port.number()));
            break;
        case DEVICE_REMOVED:
        case DEVICE_SUSPENDED:
            log.debug("Device removed {}", deviceId);
            removeDevice(deviceId);
            providerService.linksVanished(deviceId);
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(deviceId)) {
                log.debug("Device up {}", deviceId);
                updateDevice(device).ifPresent(ld -> updatePorts(ld, deviceId));
            } else {
                log.debug("Device down {}", deviceId);
                removeDevice(deviceId);
                providerService.linksVanished(deviceId);
            }
            break;
        case PORT_STATS_UPDATED:
            break;
        default:
            log.debug("Unknown event {}", event);
    }
}
#end_block

#method_before
@Override
public String fingerprint() {
    String name = clusterMetadataService.getClusterMetadata().getName();
    return name == null ? NO_NAME : name;
}
#method_after
@Override
public String fingerprint() {
    ClusterMetadata mdata = clusterMetadataService.getClusterMetadata();
    return mdata == null ? NO_NAME : mdata.getName();
}
#end_block

#method_before
private PortDescription buildOduCltPortDescription(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    // in units of Mbps
    Long portSpeed = portSpeed(port);
    OduCltPort.SignalType sigType = null;
    switch(portSpeed.toString()) {
        case "1000":
            sigType = OduCltPort.SignalType.CLT_1GBE;
            break;
        case "10000":
            sigType = OduCltPort.SignalType.CLT_10GBE;
            break;
        case "40000":
            sigType = OduCltPort.SignalType.CLT_40GBE;
            break;
        case "100000":
            sigType = OduCltPort.SignalType.CLT_100GBE;
            break;
        default:
            throw new RuntimeException("Un recognize OduClt speed: " + portSpeed.toString());
    }
    SparseAnnotations annotations = buildOduCltAnnotation(port);
    return new OduCltPortDescription(portNo, enabled, sigType, annotations);
}
#method_after
private PortDescription buildOduCltPortDescription(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Long portSpeedInMbps = portSpeed(port);
    OduCltPort.SignalType sigType = null;
    switch(portSpeedInMbps.toString()) {
        case "1000":
            sigType = OduCltPort.SignalType.CLT_1GBE;
            break;
        case "10000":
            sigType = OduCltPort.SignalType.CLT_10GBE;
            break;
        case "40000":
            sigType = OduCltPort.SignalType.CLT_40GBE;
            break;
        case "100000":
            sigType = OduCltPort.SignalType.CLT_100GBE;
            break;
        default:
            throw new RuntimeException("Un recognize OduClt speed: " + portSpeedInMbps.toString());
    }
    SparseAnnotations annotations = buildOduCltAnnotation(port);
    return new OduCltPortDescription(portNo, enabled, sigType, annotations);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    readComponentConfiguration(context);
    if (requestIntercepts) {
        requestIntercepts();
    } else {
        withdrawIntercepts();
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    readComponentConfiguration(context);
    if (requestInterceptsEnabled) {
        requestIntercepts();
    } else {
        withdrawIntercepts();
    }
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = isPropertyEnabled(properties, "hostRemovalEnabled");
    if (flag == null) {
        log.info("Host removal on port/device down events is not configured, " + "using current value of {}", hostRemovalEnabled);
    } else {
        hostRemovalEnabled = flag;
        log.info("Configured. Host removal on port/device down events is {}", hostRemovalEnabled ? "enabled" : "disabled");
    }
    flag = isPropertyEnabled(properties, "ipv6NeighborDiscovery");
    if (flag == null) {
        log.info("Using IPv6 Neighbor Discovery is not configured, " + "using current value of {}", ipv6NeighborDiscovery);
    } else {
        ipv6NeighborDiscovery = flag;
        log.info("Configured. Using IPv6 Neighbor Discovery is {}", ipv6NeighborDiscovery ? "enabled" : "disabled");
    }
    flag = isPropertyEnabled(properties, "requestIntercepts");
    if (flag == null) {
        log.info("Request intercepts is not configured, " + "using current value of {}", requestIntercepts);
    } else {
        requestIntercepts = flag;
        log.info("Configured. Request intercepts is {}", requestIntercepts ? "enabled" : "disabled");
    }
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = isPropertyEnabled(properties, "hostRemovalEnabled");
    if (flag == null) {
        log.info("Host removal on port/device down events is not configured, " + "using current value of {}", hostRemovalEnabled);
    } else {
        hostRemovalEnabled = flag;
        log.info("Configured. Host removal on port/device down events is {}", hostRemovalEnabled ? "enabled" : "disabled");
    }
    flag = isPropertyEnabled(properties, "ipv6NeighborDiscovery");
    if (flag == null) {
        log.info("Using IPv6 Neighbor Discovery is not configured, " + "using current value of {}", ipv6NeighborDiscovery);
    } else {
        ipv6NeighborDiscovery = flag;
        log.info("Configured. Using IPv6 Neighbor Discovery is {}", ipv6NeighborDiscovery ? "enabled" : "disabled");
    }
    flag = isPropertyEnabled(properties, "requestInterceptsEnabled");
    if (flag == null) {
        log.info("Request intercepts is not configured, " + "using current value of {}", requestInterceptsEnabled);
    } else {
        requestInterceptsEnabled = flag;
        log.info("Configured. Request intercepts is {}", requestInterceptsEnabled ? "enabled" : "disabled");
    }
}
#end_block

#method_before
@Override
public Driver merge(Driver other) {
    checkArgument(parents == null || Objects.equals(parent(), other.parent()), "Parent drivers are not the same");
    // Merge the behaviours.
    Map<Class<? extends Behaviour>, Class<? extends Behaviour>> behaviours = Maps.newHashMap();
    behaviours.putAll(this.behaviours);
    other.behaviours().forEach(b -> behaviours.put(b, other.implementation(b)));
    // Merge the properties.
    ImmutableMap.Builder<String, String> properties = ImmutableMap.builder();
    properties.putAll(this.properties).putAll(other.properties());
    return new DefaultDriver(name, other.parents() == null ? new ArrayList<>() : other.parents(), manufacturer, hwVersion, swVersion, ImmutableMap.copyOf(behaviours), properties.build());
}
#method_after
@Override
public Driver merge(Driver other) {
    checkArgument(parents == null || Objects.equals(parent(), other.parent()), "Parent drivers are not the same");
    // Merge the behaviours.
    Map<Class<? extends Behaviour>, Class<? extends Behaviour>> behaviours = Maps.newHashMap();
    behaviours.putAll(this.behaviours);
    other.behaviours().forEach(b -> behaviours.put(b, other.implementation(b)));
    // Merge the properties.
    ImmutableMap.Builder<String, String> properties = ImmutableMap.builder();
    properties.putAll(this.properties).putAll(other.properties());
    return new DefaultDriver(name, other.parents(), manufacturer, hwVersion, swVersion, ImmutableMap.copyOf(behaviours), properties.build());
}
#end_block

#method_before
@Override
public <T extends Behaviour> T createBehaviour(DriverData data, Class<T> behaviourClass) {
    T behaviour = createBehaviour(data, null, behaviourClass);
    if (behaviour != null) {
        return behaviour;
    } else if (parents != null) {
        // TODO better way for performance ?
        return Iterables.getLast(parents.stream().map(parent -> parent.createBehaviour(data, behaviourClass)).collect(Collectors.toList()));
    }
    throw new IllegalArgumentException(behaviourClass.getName() + " not supported");
}
#method_after
@Override
public <T extends Behaviour> T createBehaviour(DriverData data, Class<T> behaviourClass) {
    T behaviour = createBehaviour(data, null, behaviourClass);
    if (behaviour != null) {
        return behaviour;
    } else if (parents != null) {
        for (Driver parent : Lists.reverse(parents)) {
            try {
                return parent.createBehaviour(data, behaviourClass);
            } catch (IllegalArgumentException e) {
                log.debug("Parent {} does not support behaviour {}", parent, behaviourClass);
            }
        }
    }
    throw new IllegalArgumentException(behaviourClass.getName() + " not supported");
}
#end_block

#method_before
@Override
public <T extends Behaviour> T createBehaviour(DriverHandler handler, Class<T> behaviourClass) {
    T behaviour = createBehaviour(handler.data(), handler, behaviourClass);
    if (behaviour != null) {
        return behaviour;
    } else if (parents != null) {
        return Iterables.getLast(parents.stream().map(parent -> parent.createBehaviour(handler, behaviourClass)).collect(Collectors.toList()));
    }
    throw new IllegalArgumentException(behaviourClass.getName() + " not supported");
}
#method_after
@Override
public <T extends Behaviour> T createBehaviour(DriverHandler handler, Class<T> behaviourClass) {
    T behaviour = createBehaviour(handler.data(), handler, behaviourClass);
    if (behaviour != null) {
        return behaviour;
    } else if (parents != null && !parents.isEmpty()) {
        for (Driver parent : Lists.reverse(parents)) {
            try {
                return parent.createBehaviour(handler, behaviourClass);
            } catch (IllegalArgumentException e) {
                log.debug("Parent {} does not support behaviour {}", parent, behaviourClass);
            }
        }
    }
    throw new IllegalArgumentException(behaviourClass.getName() + " not supported");
}
#end_block

#method_before
public DefaultDriver loadDriver(HierarchicalConfiguration driverCfg, DriverResolver resolver) {
    String name = driverCfg.getString(NAME);
    String parentsString = driverCfg.getString(EXTENDS, "");
    List<Driver> parents = Lists.newArrayList();
    if (!parentsString.equals("")) {
        List<String> parentsNames;
        if (parentsString.contains(",")) {
            parentsNames = Arrays.asList(parentsString.replace(" ", "").split(","));
        } else {
            parentsNames = Lists.newArrayList(parentsString);
        }
        // parentsNames.forEach(parent -> parents.add(parent != null ? resolve(parent, resolver) : null));
        parents = parentsNames.stream().map(parent -> (parent != null) ? resolve(parent, resolver) : null).collect(Collectors.toList());
    }
    String manufacturer = driverCfg.getString(MFG, "");
    String hwVersion = driverCfg.getString(HW, "");
    String swVersion = driverCfg.getString(SW, "");
    return new DefaultDriver(name, parents, manufacturer, hwVersion, swVersion, parseBehaviours(driverCfg), parseProperties(driverCfg));
}
#method_after
public DefaultDriver loadDriver(HierarchicalConfiguration driverCfg, DriverResolver resolver) {
    String name = driverCfg.getString(NAME);
    String parentsString = driverCfg.getString(EXTENDS, "");
    List<Driver> parents = Lists.newArrayList();
    if (!parentsString.equals("")) {
        List<String> parentsNames;
        if (parentsString.contains(",")) {
            parentsNames = Arrays.asList(parentsString.replace(" ", "").split(","));
        } else {
            parentsNames = Lists.newArrayList(parentsString);
        }
        parents = parentsNames.stream().map(parent -> (parent != null) ? resolve(parent, resolver) : null).collect(Collectors.toList());
    }
    String manufacturer = driverCfg.getString(MFG, "");
    String hwVersion = driverCfg.getString(HW, "");
    String swVersion = driverCfg.getString(SW, "");
    return new DefaultDriver(name, parents, manufacturer, hwVersion, swVersion, parseBehaviours(driverCfg), parseProperties(driverCfg));
}
#end_block

#method_before
@Test
public void testMeterSingleDevice() {
    setupMockMeters();
    final Set<Meter> meters1 = new HashSet<>();
    meters1.add(meter1);
    meters1.add(meter2);
    expect(mockMeterService.getMeters(anyObject())).andReturn(meters1).anyTimes();
    replay(mockMeterService);
    replay(mockDeviceService);
    final WebResource rs = resource();
    final String response = rs.path("meters/" + deviceId1.toString()).get(String.class);
    final JsonObject result = JsonObject.readFrom(response);
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("meters"));
    final JsonArray jsonFlows = result.get("meters").asArray();
    assertThat(jsonFlows, notNullValue());
    assertThat(jsonFlows, hasMeter(meter1));
    assertThat(jsonFlows, hasMeter(meter2));
}
#method_after
@Test
public void testMeterSingleDevice() {
    setupMockMeters();
    final Set<Meter> meters1 = new HashSet<>();
    meters1.add(meter1);
    meters1.add(meter2);
    expect(mockMeterService.getMeters(anyObject())).andReturn(meters1).anyTimes();
    replay(mockMeterService);
    replay(mockDeviceService);
    final WebResource rs = resource();
    final String response = rs.path("meters/" + deviceId1.toString()).get(String.class);
    final JsonObject result = JsonObject.readFrom(response);
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("meters"));
    final JsonArray jsonMeters = result.get("meters").asArray();
    assertThat(jsonMeters, notNullValue());
    assertThat(jsonMeters, hasMeter(meter1));
    assertThat(jsonMeters, hasMeter(meter2));
}
#end_block

#method_before
@Override
public String getConfiguration(String type) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    Preconditions.checkNotNull(controller, "Netconf controller is null");
    try {
        return controller.getDevicesMap().get(ofDeviceId).getSession().getConfig(type);
    } catch (IOException e) {
        e.printStackTrace();
        throw new RuntimeException("Configuration could not be retrieved.");
    }
}
#method_after
@Override
public String getConfiguration(String type) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    Preconditions.checkNotNull(controller, "Netconf controller is null");
    try {
        return controller.getDevicesMap().get(ofDeviceId).getSession().getConfig(type);
    } catch (IOException e) {
        log.error(e.getStackTrace().toString());
        throw new RuntimeException("Configuration could not be retrieved.");
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication(PROVIDER_ID);
    configService.addListener(configListener);
    configRegistry.registerConfigFactory(configFactory);
    log.info("BGP cfg provider started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication(PROVIDER_ID);
    configService.addListener(configListener);
    configRegistry.registerConfigFactory(configFactory);
    readConfiguration();
    log.info("BGP cfg provider started");
}
#end_block

#method_before
public static void checkPermission(AppPermission.Type permission) {
    SecurityManager sm = System.getSecurityManager();
    if (sm == null) {
        return;
    }
    SecurityAdminService service = SecurityServiceFactory.getInstance().getService();
    if (service == null) {
        return;
    }
    Object result = AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
        int conhash = 0;
        AccessControlContext context = AccessController.getContext();
        Field f = null;
        try {
            f = context.getClass().getDeclaredField("context");
            f.setAccessible(true);
            ProtectionDomain[] domain = (ProtectionDomain[]) f.get(context);
            for (ProtectionDomain pd : domain) {
                if (pd.getCodeSource() != null) {
                    conhash = conhash ^ pd.getCodeSource().getLocation().hashCode();
                } else {
                    return null;
                }
            }
            return conhash;
        } catch (NoSuchFieldException e) {
            return null;
        } catch (IllegalAccessException e) {
            return null;
        }
    });
    if (result == null) {
        sm.checkPermission(new AppPermission(permission));
    } else {
        int permhash = (new AppPermission(permission)).hashCode();
        int hash = ((int) result) ^ permhash;
        boolean hit = AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {
            return service.checkCache(hash);
        });
        if (!hit) {
            sm.checkPermission(new AppPermission(permission));
            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                service.updateCache(hash);
                return null;
            });
        }
    }
}
#method_after
public static void checkPermission(AppPermission.Type permission) {
    SecurityManager sm = System.getSecurityManager();
    if (sm == null) {
        return;
    }
    Object result = AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
        int contextHash = 0;
        AccessControlContext context = AccessController.getContext();
        Field f = null;
        try {
            f = context.getClass().getDeclaredField("context");
            f.setAccessible(true);
            ProtectionDomain[] domain = (ProtectionDomain[]) f.get(context);
            for (ProtectionDomain pd : domain) {
                if (pd.getCodeSource() != null) {
                    contextHash = contextHash ^ pd.getCodeSource().getLocation().hashCode();
                } else {
                    return null;
                }
            }
            return contextHash;
        } catch (NoSuchFieldException e) {
            return null;
        } catch (IllegalAccessException e) {
            return null;
        }
    });
    if (result == null) {
        sm.checkPermission(new AppPermission(permission));
    } else {
        AppPermission perm = new AppPermission(permission);
        int hash = ((int) result) ^ perm.hashCode();
        PermissionCheckCache.getInstance().checkCache(hash, perm);
    }
}
#end_block

#method_before
@Activate
public void activate() {
    eventDispatcher.addSink(SecurityModeEvent.class, listenerRegistry);
    logReaderService.addLogListener(securityLogListener);
    if (System.getSecurityManager() == null) {
        log.warn("J2EE security manager is disabled.");
        deactivate();
        return;
    }
    if (permissionAdmin == null) {
        log.warn("Permission Admin not found.");
        deactivate();
        return;
    }
    initializing = true;
    store.setDelegate(delegate);
    initializing = false;
    log.info("Security-Mode Started");
}
#method_after
@Activate
public void activate() {
    eventDispatcher.addSink(SecurityModeEvent.class, listenerRegistry);
    logReaderService.addLogListener(securityLogListener);
    if (System.getSecurityManager() == null) {
        log.warn("J2EE security manager is disabled.");
        deactivate();
        return;
    }
    if (permissionAdmin == null) {
        log.warn("Permission Admin not found.");
        deactivate();
        return;
    }
    store.setDelegate(delegate);
    log.info("Security-Mode Started");
}
#end_block

#method_before
public static org.onosproject.security.Permission getOnosPermission(Permission permission) {
    if (permission instanceof AppPermission) {
        return new org.onosproject.security.Permission(AppPermission.class.getName(), permission.getName(), "");
    } else if (permission instanceof FilePermission) {
        return new org.onosproject.security.Permission(FilePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SerializablePermission) {
        return new org.onosproject.security.Permission(SerializablePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof NetPermission) {
        return new org.onosproject.security.Permission(NetPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof RuntimePermission) {
        return new org.onosproject.security.Permission(RuntimePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SocketPermission) {
        return new org.onosproject.security.Permission(SocketPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SQLPermission) {
        return new org.onosproject.security.Permission(SQLPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof PropertyPermission) {
        return new org.onosproject.security.Permission(PropertyPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof LoggingPermission) {
        return new org.onosproject.security.Permission(LoggingPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SSLPermission) {
        return new org.onosproject.security.Permission(SSLPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AuthPermission) {
        return new org.onosproject.security.Permission(AuthPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof PrivateCredentialPermission) {
        return new org.onosproject.security.Permission(PrivateCredentialPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof DelegationPermission) {
        return new org.onosproject.security.Permission(DelegationPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof javax.security.auth.kerberos.ServicePermission) {
        return new org.onosproject.security.Permission(javax.security.auth.kerberos.ServicePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AudioPermission) {
        return new org.onosproject.security.Permission(AudioPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AdaptPermission) {
        return new org.onosproject.security.Permission(AdaptPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof BundlePermission) {
        return new org.onosproject.security.Permission(BundlePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof CapabilityPermission) {
        return new org.onosproject.security.Permission(CapabilityPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof PackagePermission) {
        return new org.onosproject.security.Permission(PackagePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof ServicePermission) {
        return new org.onosproject.security.Permission(ServicePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AdminPermission) {
        return new org.onosproject.security.Permission(AdminPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof ConfigurationPermission) {
        return new org.onosproject.security.Permission(ConfigurationPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof ReflectPermission) {
        return new org.onosproject.security.Permission(ReflectPermission.class.getName(), permission.getName(), permission.getActions());
    }
    return null;
}
#method_after
public static org.onosproject.security.Permission getOnosPermission(Permission permission) {
    if (permission instanceof AppPermission) {
        return new org.onosproject.security.Permission(AppPermission.class.getName(), permission.getName(), "");
    } else if (permission instanceof FilePermission) {
        return new org.onosproject.security.Permission(FilePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SerializablePermission) {
        return new org.onosproject.security.Permission(SerializablePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof NetPermission) {
        return new org.onosproject.security.Permission(NetPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof RuntimePermission) {
        return new org.onosproject.security.Permission(RuntimePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SocketPermission) {
        return new org.onosproject.security.Permission(SocketPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SQLPermission) {
        return new org.onosproject.security.Permission(SQLPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof PropertyPermission) {
        return new org.onosproject.security.Permission(PropertyPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof LoggingPermission) {
        return new org.onosproject.security.Permission(LoggingPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof SSLPermission) {
        return new org.onosproject.security.Permission(SSLPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AuthPermission) {
        return new org.onosproject.security.Permission(AuthPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof PrivateCredentialPermission) {
        return new org.onosproject.security.Permission(PrivateCredentialPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof DelegationPermission) {
        return new org.onosproject.security.Permission(DelegationPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof javax.security.auth.kerberos.ServicePermission) {
        return new org.onosproject.security.Permission(javax.security.auth.kerberos.ServicePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AudioPermission) {
        return new org.onosproject.security.Permission(AudioPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AdaptPermission) {
        return new org.onosproject.security.Permission(AdaptPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof BundlePermission) {
        return new org.onosproject.security.Permission(BundlePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof CapabilityPermission) {
        return new org.onosproject.security.Permission(CapabilityPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof PackagePermission) {
        return new org.onosproject.security.Permission(PackagePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof ServicePermission) {
        return new org.onosproject.security.Permission(ServicePermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof AdminPermission) {
        return new org.onosproject.security.Permission(AdminPermission.class.getName(), permission.getName(), permission.getActions());
    } else if (permission instanceof ConfigurationPermission) {
        return new org.onosproject.security.Permission(ConfigurationPermission.class.getName(), permission.getName(), permission.getActions());
    }
    return null;
}
#end_block

#method_before
@Activate
public void activate() {
    states = storageService.<ApplicationId, SecurityInfo>consistentMapBuilder().withName("smonos-sdata").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Set.class).register(ApplicationId.class).register(Permission.class).register(SecurityModeState.class).register(SecurityInfo.class).build())).build();
    states.addListener(new SecurityStateListener());
    violations = storageService.<ApplicationId, Set<Permission>>eventuallyConsistentMapBuilder().withName("smonos-rperms").withSerializer(VIOLATION_SERIALIZER).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    cache = new ConcurrentHashMap<>();
    localBundleAppDirectory = new ConcurrentHashMap<>();
    localAppBundleDirectory = new ConcurrentHashMap<>();
    active = true;
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    states = storageService.<ApplicationId, SecurityInfo>consistentMapBuilder().withName("smonos-sdata").withSerializer(STATE_SERIALIZER).build();
    states.addListener(new SecurityStateListener());
    violations = storageService.<ApplicationId, Set<Permission>>eventuallyConsistentMapBuilder().withName("smonos-rperms").withSerializer(VIOLATION_SERIALIZER).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    localBundleAppDirectory = new ConcurrentHashMap<>();
    localAppBundleDirectory = new ConcurrentHashMap<>();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    violations.destroy();
    log.info("Stopped");
    active = false;
}
#method_after
@Deactivate
public void deactivate() {
    violations.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(MapEvent<ApplicationId, SecurityInfo> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    SecurityInfo info = event.value().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        switch(info.getState()) {
            case POLICY_VIOLATED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_VIOLATED, appId));
                break;
            case SECURED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_ACCEPTED, appId));
            default:
                break;
        }
    } else if (event.type() == MapEvent.Type.REMOVE) {
        removeAppFromDirectories(appId);
    }
}
#method_after
@Override
public void event(MapEvent<ApplicationId, SecurityInfo> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    SecurityInfo info = event.value().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        switch(info.getState()) {
            case POLICY_VIOLATED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_VIOLATED, appId));
                break;
            case SECURED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_ACCEPTED, appId));
                break;
            default:
                break;
        }
    } else if (event.type() == MapEvent.Type.REMOVE) {
        removeAppFromDirectories(appId);
    }
}
#end_block

#method_before
@Override
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
    log.debug("MESSAGE IS RECEIVED.");
    if (!channel.isConnected()) {
        log.info("Channel is not connected.");
        return null;
    }
    HexDump.dump(buffer);
    BgpMessageReader<BgpMessage> reader = BgpFactories.getGenericReader();
    msgList = (List<BgpMessage>) ctx.getAttachment();
    if (msgList == null) {
        msgList = new LinkedList<BgpMessage>();
    }
    try {
        while (buffer.readableBytes() > 0) {
            buffer.markReaderIndex();
            BgpHeader bgpHeader = new BgpHeader();
            BgpMessage message = reader.readFrom(buffer, bgpHeader);
            msgList.add(message);
        }
        return msgList;
    } catch (Exception e) {
        log.debug("Protocol message decode error");
        buffer.resetReaderIndex();
        buffer.discardReadBytes();
        ctx.setAttachment(msgList);
    }
    return null;
}
#method_after
@Override
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
    log.debug("MESSAGE IS RECEIVED.");
    if (!channel.isConnected()) {
        log.info("Channel is not connected.");
        return null;
    }
    HexDump.dump(buffer);
    BgpMessageReader<BgpMessage> reader = BgpFactories.getGenericReader();
    List<BgpMessage> msgList = (List<BgpMessage>) ctx.getAttachment();
    if (msgList == null) {
        msgList = new LinkedList<>();
    }
    try {
        while (buffer.readableBytes() > 0) {
            buffer.markReaderIndex();
            BgpHeader bgpHeader = new BgpHeader();
            BgpMessage message = reader.readFrom(buffer, bgpHeader);
            msgList.add(message);
        }
        return msgList;
    } catch (Exception e) {
        log.debug("Bgp protocol message decode error");
        buffer.resetReaderIndex();
        buffer.discardReadBytes();
        ctx.setAttachment(msgList);
    }
    return null;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    classifierService = new ClassifierServiceImpl(appId);
    l2ForwardService = new L2ForwardServiceImpl(appId);
    arpService = new ArpServiceImpl(appId);
    l3ForwardService = new L3ForwardServiceImpl(appId);
    snatService = new SnatServiceImpl(appId);
    dnatService = new DnatServiceImpl(appId);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    vtnRscService.addListener(l3EventListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NetworkOfLocalHostPorts.class).register(TenantNetworkId.class).register(Host.class).register(TenantNetwork.class).register(TenantId.class).register(SubnetId.class).register(VirtualPortId.class).register(VirtualPort.State.class).register(AllowedAddressPair.class).register(FixedIp.class).register(BindingHostId.class).register(SecurityGroup.class).register(IpAddress.class).register(DefaultVirtualPort.class);
    vPortStore = storageService.<VirtualPortId, VirtualPort>eventuallyConsistentMapBuilder().withName(VIRTUALPORT).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchesOfController = storageService.<IpAddress, Boolean>eventuallyConsistentMapBuilder().withName(SWITCHES_OF_CONTROLLER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchOfLocalHostPorts = storageService.<DeviceId, NetworkOfLocalHostPorts>eventuallyConsistentMapBuilder().withName(SWITCH_OF_LOCAL_HOST_PORTS).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    hostsOfSubnet = storageService.<SubnetId, Map<HostId, Host>>eventuallyConsistentMapBuilder().withName(HOSTS_OF_SUBNET).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    routerInfFlagOfTenant = storageService.<TenantId, Boolean>eventuallyConsistentMapBuilder().withName(ROUTERINF_FLAG_OF_TENANT).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortOfDevice = storageService.<DeviceId, Port>eventuallyConsistentMapBuilder().withName(EX_PORT_OF_DEVICE).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    classifierService = new ClassifierServiceImpl(appId);
    l2ForwardService = new L2ForwardServiceImpl(appId);
    arpService = new ArpServiceImpl(appId);
    l3ForwardService = new L3ForwardServiceImpl(appId);
    snatService = new SnatServiceImpl(appId);
    dnatService = new DnatServiceImpl(appId);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    vtnRscService.addListener(l3EventListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NetworkOfLocalHostPorts.class).register(TenantNetworkId.class).register(Host.class).register(TenantNetwork.class).register(TenantId.class).register(SubnetId.class).register(VirtualPortId.class).register(VirtualPort.State.class).register(AllowedAddressPair.class).register(FixedIp.class).register(BindingHostId.class).register(SecurityGroup.class).register(IpAddress.class).register(DefaultVirtualPort.class);
    vPortStore = storageService.<VirtualPortId, VirtualPort>eventuallyConsistentMapBuilder().withName(VIRTUALPORT).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchesOfController = storageService.<IpAddress, Boolean>eventuallyConsistentMapBuilder().withName(SWITCHES_OF_CONTROLLER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchOfLocalHostPorts = storageService.<DeviceId, NetworkOfLocalHostPorts>eventuallyConsistentMapBuilder().withName(SWITCH_OF_LOCAL_HOST_PORTS).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    hostsOfSubnet = storageService.<SubnetId, Map<HostId, Host>>eventuallyConsistentMapBuilder().withName(HOSTS_OF_SUBNET).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    routerInfFlagOfTenant = storageService.<TenantId, Boolean>eventuallyConsistentMapBuilder().withName(ROUTERINF_FLAG_OF_TENANT).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortOfDevice = storageService.<DeviceId, Port>eventuallyConsistentMapBuilder().withName(EX_PORT_OF_DEVICE).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortMap = storageService.<String, String>consistentMapBuilder().withName(EX_PORT_MAP).withApplicationId(appId).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API))).build();
    log.info("Started");
}
#end_block

#method_before
@Override
public void onControllerDetected(Device controllerDevice) {
    if (controllerDevice == null) {
        log.error("The controller device is null");
        return;
    }
    while (!setExPortFlag) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            log.error("Thread sleep error:{}", e.getMessage());
        }
    }
    String localIpAddress = controllerDevice.annotations().value(CONTROLLER_IP_KEY);
    IpAddress localIp = IpAddress.valueOf(localIpAddress);
    DeviceId controllerDeviceId = controllerDevice.id();
    DriverHandler handler = driverService.createHandler(controllerDeviceId);
    if (mastershipService.isLocalMaster(controllerDeviceId)) {
        // Get DataPathIdGenerator
        String ipaddress = controllerDevice.annotations().value("ipaddress");
        DataPathIdGenerator dpidGenerator = DataPathIdGenerator.builder().addIpAddress(ipaddress).build();
        DeviceId deviceId = dpidGenerator.getDeviceId();
        String dpid = dpidGenerator.getDpId();
        // Inject pipeline driver name
        BasicDeviceConfig config = configService.addConfig(deviceId, BasicDeviceConfig.class);
        config.driver(DRIVER_NAME);
        configService.applyConfig(deviceId, BasicDeviceConfig.class, config.node());
        // Add Bridge
        VtnConfig.applyBridgeConfig(handler, dpid, exPortName);
        log.info("A new ovs is created in node {}", localIp.toString());
        switchesOfController.put(localIp, true);
    }
    // Create tunnel in br-int on all controllers
    programTunnelConfig(controllerDeviceId, localIp, handler);
}
#method_after
@Override
public void onControllerDetected(Device controllerDevice) {
    if (controllerDevice == null) {
        log.error("The controller device is null");
        return;
    }
    String localIpAddress = controllerDevice.annotations().value(CONTROLLER_IP_KEY);
    IpAddress localIp = IpAddress.valueOf(localIpAddress);
    DeviceId controllerDeviceId = controllerDevice.id();
    DriverHandler handler = driverService.createHandler(controllerDeviceId);
    if (mastershipService.isLocalMaster(controllerDeviceId)) {
        // Get DataPathIdGenerator
        String ipaddress = controllerDevice.annotations().value("ipaddress");
        DataPathIdGenerator dpidGenerator = DataPathIdGenerator.builder().addIpAddress(ipaddress).build();
        DeviceId deviceId = dpidGenerator.getDeviceId();
        String dpid = dpidGenerator.getDpId();
        // Inject pipeline driver name
        BasicDeviceConfig config = configService.addConfig(deviceId, BasicDeviceConfig.class);
        config.driver(DRIVER_NAME);
        configService.applyConfig(deviceId, BasicDeviceConfig.class, config.node());
        // Add Bridge
        Versioned<String> exPortVersioned = exPortMap.get(EX_PORT_KEY);
        if (exPortVersioned != null) {
            VtnConfig.applyBridgeConfig(handler, dpid, exPortVersioned.value());
            log.info("A new ovs is created in node {}", localIp.toString());
        }
        switchesOfController.put(localIp, true);
    }
    // Create tunnel in br-int on all controllers
    programTunnelConfig(controllerDeviceId, localIp, handler);
}
#end_block

#method_before
private Port getExPort(DeviceId deviceId) {
    List<Port> ports = deviceService.getPorts(deviceId);
    Port exPort = null;
    for (Port port : ports) {
        String portName = port.annotations().value(AnnotationKeys.PORT_NAME);
        if (portName != null && portName.equals(exPortName)) {
            exPort = port;
            break;
        }
    }
    return exPort;
}
#method_after
private Port getExPort(DeviceId deviceId) {
    List<Port> ports = deviceService.getPorts(deviceId);
    Port exPort = null;
    for (Port port : ports) {
        String portName = port.annotations().value(AnnotationKeys.PORT_NAME);
        Versioned<String> exPortVersioned = exPortMap.get(EX_PORT_KEY);
        if (portName != null && exPortVersioned != null && portName.equals(exPortVersioned.value())) {
            exPort = port;
            break;
        }
    }
    return exPort;
}
#end_block

#method_before
public static void setExPortName(String name) {
    exPortName = name;
    setExPortFlag = true;
}
#method_after
public static void setExPortName(String name) {
    exPortMap.put(EX_PORT_KEY, name);
}
#end_block

#method_before
@Override
public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
    channel = e.getChannel();
    log.info("BGP disconnected callback for bgp:{}. Cleaning up ...", getPeerInfoString());
    address = channel.getRemoteAddress();
    if (!(address instanceof InetSocketAddress)) {
        throw new IOException("Invalid peer connection.");
    }
    inetAddress = (InetSocketAddress) address;
    peerAddr = IpAddress.valueOf(inetAddress.getAddress()).toString();
    if (thisbgpId != null) {
        if (!duplicateBGPIdFound) {
            // if the disconnected peer (on this ChannelHandler)
            // was not one with a duplicate, it is safe to remove all
            // state for it at the controller. Notice that if the disconnected
            // peer was a duplicate-ip, calling the method below would clear
            // all state for the original peer (with the same ip),
            // which we obviously don't want.
            log.debug("{}:removal called", getPeerInfoString());
            if (bgpPeer != null) {
                BgpPeerImpl peer = (BgpPeerImpl) bgpPeer;
                peerManager.removeConnectedPeer(thisbgpId);
                peer.updateLocalRIBOnPeerDisconnect();
            }
            // Retry connection if connection is lost to bgp speaker/peer
            if ((channel != null) && (null != channel.getPipeline().get("ActiveHandler"))) {
                BgpConnectPeerImpl connectPeer;
                BgpPeerCfg.State peerCfgState;
                peerCfgState = bgpconfig.getPeerConnState(peerAddr);
                // on session disconnect using configuration, do not retry
                if (!peerCfgState.equals(BgpPeerCfg.State.IDLE)) {
                    log.debug("Connection reset by peer, retry, STATE:{}", peerCfgState);
                    BgpPeerConfig peerConfig = (BgpPeerConfig) bgpconfig.displayPeers(peerAddr);
                    bgpconfig.setPeerConnState(peerAddr, BgpPeerCfg.State.IDLE);
                    connectPeer = new BgpConnectPeerImpl(bgpController, peerAddr, Controller.getBgpPortNum());
                    peerConfig.setConnectPeer(connectPeer);
                }
            } else {
                bgpconfig.setPeerConnState(peerAddr, BgpPeerCfg.State.IDLE);
            }
        } else {
            // A duplicate was disconnected on this ChannelHandler,
            // this is the same peer reconnecting, but the original state was
            // not cleaned up - XXX check liveness of original ChannelHandler
            log.debug("{}:duplicate found", getPeerInfoString());
            duplicateBGPIdFound = Boolean.FALSE;
        }
        stopkeepAliveTimer();
    } else {
        bgpconfig.setPeerConnState(peerAddr, BgpPeerCfg.State.IDLE);
        log.warn("No bgp ip in channelHandler registered for " + "disconnected peer {}", getPeerInfoString());
    }
}
#method_after
@Override
public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
    channel = e.getChannel();
    log.info("BGP disconnected callback for bgp:{}. Cleaning up ...", getPeerInfoString());
    address = channel.getRemoteAddress();
    if (!(address instanceof InetSocketAddress)) {
        throw new IOException("Invalid peer connection.");
    }
    inetAddress = (InetSocketAddress) address;
    peerAddr = IpAddress.valueOf(inetAddress.getAddress()).toString();
    if (thisbgpId != null) {
        if (!duplicateBGPIdFound) {
            // if the disconnected peer (on this ChannelHandler)
            // was not one with a duplicate, it is safe to remove all
            // state for it at the controller. Notice that if the disconnected
            // peer was a duplicate-ip, calling the method below would clear
            // all state for the original peer (with the same ip),
            // which we obviously don't want.
            log.debug("{}:removal called", getPeerInfoString());
            if (bgpPeer != null) {
                BgpPeerImpl peer = (BgpPeerImpl) bgpPeer;
                peerManager.removeConnectedPeer(thisbgpId);
                peer.updateLocalRIBOnPeerDisconnect();
            }
            // Retry connection if connection is lost to bgp speaker/peer
            if ((channel != null) && (null != channel.getPipeline().get("ActiveHandler"))) {
                BgpConnectPeerImpl connectPeer;
                BgpPeerCfg.State peerCfgState;
                peerCfgState = bgpconfig.getPeerConnState(peerAddr);
                // on session disconnect using configuration, do not retry
                if (!peerCfgState.equals(BgpPeerCfg.State.IDLE)) {
                    log.debug("Connection reset by peer, retry, STATE:{}", peerCfgState);
                    BgpPeerConfig peerConfig = (BgpPeerConfig) bgpconfig.displayPeers(peerAddr);
                    bgpconfig.setPeerConnState(peerAddr, BgpPeerCfg.State.IDLE);
                    connectPeer = new BgpConnectPeerImpl(bgpController, peerAddr, Controller.getBgpPortNum());
                    peerConfig.setConnectPeer(connectPeer);
                }
            } else {
                bgpconfig.setPeerConnState(peerAddr, BgpPeerCfg.State.IDLE);
            }
        } else {
            // A duplicate was disconnected on this ChannelHandler,
            // this is the same peer reconnecting, but the original state was
            // not cleaned up - XXX check liveness of original ChannelHandler
            log.debug("{}:duplicate found", getPeerInfoString());
            duplicateBGPIdFound = Boolean.FALSE;
        }
        stopKeepAliveTimer();
    } else {
        bgpconfig.setPeerConnState(peerAddr, BgpPeerCfg.State.IDLE);
        log.warn("No bgp ip in channelHandler registered for " + "disconnected peer {}", getPeerInfoString());
    }
}
#end_block

#method_before
@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    log.info("[exceptionCaught]: " + e.toString());
    if (e.getCause() instanceof ReadTimeoutException) {
        // device timeout
        log.error("Disconnecting device {} due to read timeout", getPeerInfoString());
        sendNotification(BgpErrorType.HOLD_TIMER_EXPIRED, (byte) 0, null);
        state = ChannelState.IDLE;
        stopkeepAliveTimer();
        ctx.getChannel().close();
        return;
    } else if (e.getCause() instanceof ClosedChannelException) {
        log.debug("Channel for bgp {} already closed", getPeerInfoString());
    } else if (e.getCause() instanceof IOException) {
        log.error("Disconnecting peer {} due to IO Error: {}", getPeerInfoString(), e.getCause().getMessage());
        if (log.isDebugEnabled()) {
            // still print stack trace if debug is enabled
            log.debug("StackTrace for previous Exception: ", e.getCause());
        }
        stopkeepAliveTimer();
        ctx.getChannel().close();
    } else if (e.getCause() instanceof BgpParseException) {
        byte[] data = new byte[] {};
        BgpParseException errMsg = (BgpParseException) e.getCause();
        byte errorCode = errMsg.getErrorCode();
        byte errorSubCode = errMsg.getErrorSubCode();
        ChannelBuffer tempCb = errMsg.getData();
        if (tempCb != null) {
            int dataLength = tempCb.capacity();
            data = new byte[dataLength];
            tempCb.readBytes(data, 0, dataLength);
        }
        sendNotification(errorCode, errorSubCode, data);
    } else if (e.getCause() instanceof RejectedExecutionException) {
        log.warn("Could not process message: queue full");
    } else {
        stopkeepAliveTimer();
        log.error("Error while processing message from peer " + getPeerInfoString() + "state " + this.state);
        ctx.getChannel().close();
    }
}
#method_after
@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    log.info("[exceptionCaught]: " + e.toString());
    if (e.getCause() instanceof ReadTimeoutException) {
        // device timeout
        log.error("Disconnecting device {} due to read timeout", getPeerInfoString());
        sendNotification(BgpErrorType.HOLD_TIMER_EXPIRED, (byte) 0, null);
        state = ChannelState.IDLE;
        stopKeepAliveTimer();
        ctx.getChannel().close();
        return;
    } else if (e.getCause() instanceof ClosedChannelException) {
        log.debug("Channel for bgp {} already closed", getPeerInfoString());
    } else if (e.getCause() instanceof IOException) {
        log.error("Disconnecting peer {} due to IO Error: {}", getPeerInfoString(), e.getCause().getMessage());
        if (log.isDebugEnabled()) {
            // still print stack trace if debug is enabled
            log.debug("StackTrace for previous Exception: ", e.getCause());
        }
        stopKeepAliveTimer();
        ctx.getChannel().close();
    } else if (e.getCause() instanceof BgpParseException) {
        byte[] data = new byte[] {};
        BgpParseException errMsg = (BgpParseException) e.getCause();
        byte errorCode = errMsg.getErrorCode();
        byte errorSubCode = errMsg.getErrorSubCode();
        ChannelBuffer tempCb = errMsg.getData();
        if (tempCb != null) {
            int dataLength = tempCb.capacity();
            data = new byte[dataLength];
            tempCb.readBytes(data, 0, dataLength);
        }
        sendNotification(errorCode, errorSubCode, data);
    } else if (e.getCause() instanceof RejectedExecutionException) {
        log.warn("Could not process message: queue full");
    } else {
        stopKeepAliveTimer();
        log.error("Error while processing message from peer " + getPeerInfoString() + "state " + this.state);
        ctx.getChannel().close();
    }
}
#end_block

#method_before
@Override
public boolean add(E e) {
    boolean result = map.put(e, PRESENT) == null;
    if (result) {
        size++;
    }
    return result;
}
#method_after
@Override
public boolean add(E e) {
    return map.put(e, PRESENT) == null;
}
#end_block

#method_before
@Override
public boolean remove(E e) {
    boolean result = map.remove(e) != null;
    if (result) {
        size--;
    }
    return result;
}
#method_after
@Override
public boolean remove(E e) {
    return map.remove(e) != null;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/{appCookie}")
public Response getGroupByDeviceIdAndAppCookie(@PathParam("deviceId") String deviceId, @PathParam("appCookie") String appCookie) {
    final DeviceId deviceIdInstance = DeviceId.deviceId(deviceId);
    final GroupKey appCookieInstance = new DefaultGroupKey(appCookie.getBytes());
    Group group = groupService.getGroup(deviceIdInstance, appCookieInstance);
    groupsNode.add(codec(Group.class).encode(group, this));
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/{appCookie}")
public Response getGroupByDeviceIdAndAppCookie(@PathParam("deviceId") String deviceId, @PathParam("appCookie") String appCookie) {
    final DeviceId deviceIdInstance = DeviceId.deviceId(deviceId);
    final GroupKey appCookieInstance = new DefaultGroupKey(appCookie.getBytes());
    Group group = nullIsNotFound(groupService.getGroup(deviceIdInstance, appCookieInstance), GROUP_NOT_FOUND);
    groupsNode.add(codec(Group.class).encode(group, this));
    return ok(root).build();
}
#end_block

#method_before
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
    // try to listen to outgoing of control messages
    for (OFMessage msg : msgs) {
        switch(msg.getType()) {
            case PACKET_OUT:
                executorMsgs.submit(new OFMessageHandler(dpid, msg));
                break;
            case FLOW_MOD:
                executorMsgs.submit(new OFMessageHandler(dpid, msg));
                break;
            case STATS_REQUEST:
                executorMsgs.submit(new OFMessageHandler(dpid, msg));
                break;
            default:
        }
    }
}
#method_after
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
    // listen to outgoing control messages
    msgs.forEach(m -> {
        if (m.getType() == OFType.PACKET_OUT || m.getType() == OFType.FLOW_MOD || m.getType() == OFType.STATS_REQUEST) {
            executorMsgs.submit(new OFMessageHandler(dpid, m));
        }
    });
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    controller.removeListener(listener);
    disconnectDevices();
    providerRegistry.unregister(this);
    collectors.values().forEach(PortStatsCollector::stop);
    providerService = null;
    LOG.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    controller.removeListener(listener);
    providerRegistry.unregister(this);
    collectors.values().forEach(PortStatsCollector::stop);
    providerService = null;
    LOG.info("Stopped");
}
#end_block

#method_before
private long portSpeed(OFPortDesc port) {
    if (port.getVersion() == OFVersion.OF_13) {
        return port.getCurrSpeed() / MBPS;
    }
    PortSpeed portSpeed = PortSpeed.SPEED_NONE;
    for (OFPortFeatures feat : port.getCurr()) {
        portSpeed = PortSpeed.max(portSpeed, feat.getPortSpeed());
    }
    return portSpeed.getSpeedBps() / MBPS;
}
#method_after
private long portSpeed(OFPortDesc port) {
    if (port.getVersion() == OFVersion.OF_13) {
        // Note: getCurrSpeed() returns a value in kbps (this also applies to OF_11 and OF_12)
        return port.getCurrSpeed() / KBPS;
    }
    PortSpeed portSpeed = PortSpeed.SPEED_NONE;
    for (OFPortFeatures feat : port.getCurr()) {
        portSpeed = PortSpeed.max(portSpeed, feat.getPortSpeed());
    }
    return portSpeed.getSpeedBps() / MBPS;
}
#end_block

#method_before
private double nanoToMs(double nano) {
    return nano / 1_000_000D;
}
#method_after
private double nanoToMs(double nano) {
    return TimeUnit.MILLISECONDS.convert((long) nano, TimeUnit.NANOSECONDS);
}
#end_block

#method_before
@Override
public void run() {
    boolean done = false;
    int packetNumber = 1;
    log.info("UDP listener thread starting up");
    RADIUS inboundRadiusPacket;
    while (!done) {
        try {
            byte[] packetBuffer = new byte[RADIUS.RADIUS_MAX_LENGTH];
            DatagramPacket inboundBasePacket = new DatagramPacket(packetBuffer, packetBuffer.length);
            DatagramSocket socket = radiusSocket;
            socket.receive(inboundBasePacket);
            log.info("Packet #{} received", packetNumber++);
            try {
                inboundRadiusPacket = RADIUS.deserializer().deserialize(inboundBasePacket.getData(), 0, inboundBasePacket.getLength());
                handleRadiusPacket(inboundRadiusPacket);
            } catch (DeserializationException dex) {
                log.error("Cannot deserialize packet", dex);
            } catch (StateMachineException sme) {
                log.error("Illegal state machine operation", sme);
            } catch (Exception ex) {
                log.error("Unexpected error", ex);
            }
        } catch (IOException e) {
            log.info("Socket was closed, exiting listener thread");
            done = true;
        }
    }
}
#method_after
@Override
public void run() {
    boolean done = false;
    int packetNumber = 1;
    log.info("UDP listener thread starting up");
    RADIUS inboundRadiusPacket;
    while (!done) {
        try {
            byte[] packetBuffer = new byte[RADIUS.RADIUS_MAX_LENGTH];
            DatagramPacket inboundBasePacket = new DatagramPacket(packetBuffer, packetBuffer.length);
            DatagramSocket socket = radiusSocket;
            socket.receive(inboundBasePacket);
            log.info("Packet #{} received", packetNumber++);
            try {
                inboundRadiusPacket = RADIUS.deserializer().deserialize(inboundBasePacket.getData(), 0, inboundBasePacket.getLength());
                handleRadiusPacket(inboundRadiusPacket);
            } catch (DeserializationException dex) {
                log.error("Cannot deserialize packet", dex);
            } catch (StateMachineException sme) {
                log.error("Illegal state machine operation", sme);
            }
        } catch (IOException e) {
            log.info("Socket was closed, exiting listener thread");
            done = true;
        }
    }
}
#end_block

#method_before
@Override
protected void execute() {
    final Map<Alarm.SeverityLevel, Long> alarmCounts = AbstractShellCommand.get(AlarmService.class).getAlarmCounts(DeviceId.deviceId(deviceId));
    // Deliberately using same formatting for both ...
    GetAllAlarmsCounts.printCounts(alarmCounts);
}
#method_after
@Override
protected void execute() {
    Map<Alarm.SeverityLevel, Long> alarmCounts = AbstractShellCommand.get(AlarmService.class).getAlarmCounts(DeviceId.deviceId(deviceId));
    // Deliberately using same formatting for both ...
    GetAllAlarmsCounts.printCounts(alarmCounts);
}
#end_block

#method_before
@Override
protected void execute() {
    final Map<Alarm.SeverityLevel, Long> alarmCounts = AbstractShellCommand.get(AlarmService.class).getAlarmCounts();
    printCounts(alarmCounts);
}
#method_after
@Override
protected void execute() {
    Map<Alarm.SeverityLevel, Long> alarmCounts = AbstractShellCommand.get(AlarmService.class).getAlarmCounts();
    printCounts(alarmCounts);
}
#end_block

#method_before
@Override
public Collection<Alarm> getAlarms(ISnmpSession session, DeviceId deviceID) {
    log.info("Getting alarms for BTI 7000 device at {}", deviceID);
    final Set<Alarm> alarms = new HashSet<>();
    final NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(ActAlarmTable.class) }));
        final IActAlarmTable deviceAlarms = (IActAlarmTable) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(ActAlarmTable.class));
        if ((deviceAlarms != null) && (deviceAlarms.getActAlarmEntry() != null) && (!deviceAlarms.getActAlarmEntry().isEmpty())) {
            deviceAlarms.getActAlarmEntry().values().stream().forEach((alarm) -> {
                final DefaultAlarm.Builder alarmBuilder = new DefaultAlarm.Builder(deviceID, alarm.getActAlarmDescription(), mapAlarmSeverity(alarm.getActAlarmSeverity()), getLocalDateAndTime(alarm.getActAlarmDateAndTime(), null, null).getTime()).forSource(AlarmEntityId.alarmEntityId("other:" + alarm.getActAlarmInstanceIdx()));
                alarms.add(alarmBuilder.build());
            });
        }
        log.info("Conditions retrieved: {}", deviceAlarms);
    } catch (IOException ex) {
        log.error("Error reading alarms for device {}.", deviceID, ex);
    }
    return alarms;
}
#method_after
@Override
public Collection<Alarm> getAlarms(ISnmpSession session, DeviceId deviceID) {
    log.info("Getting alarms for BTI 7000 device at {}", deviceID);
    Set<Alarm> alarms = new HashSet<>();
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(ActAlarmTable.class) }));
        IActAlarmTable deviceAlarms = (IActAlarmTable) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(ActAlarmTable.class));
        if ((deviceAlarms != null) && (deviceAlarms.getActAlarmEntry() != null) && (!deviceAlarms.getActAlarmEntry().isEmpty())) {
            deviceAlarms.getActAlarmEntry().values().stream().forEach((alarm) -> {
                DefaultAlarm.Builder alarmBuilder = new DefaultAlarm.Builder(deviceID, alarm.getActAlarmDescription(), mapAlarmSeverity(alarm.getActAlarmSeverity()), getLocalDateAndTime(alarm.getActAlarmDateAndTime(), null, null).getTime()).forSource(AlarmEntityId.alarmEntityId("other:" + alarm.getActAlarmInstanceIdx()));
                alarms.add(alarmBuilder.build());
            });
        }
        log.info("Conditions retrieved: {}", deviceAlarms);
    } catch (IOException ex) {
        log.error("Error reading alarms for device {}.", deviceID, ex);
    }
    return alarms;
}
#end_block

#method_before
public static Date getLocalDateAndTime(String actAlarmDateAndTime, String sysInfoTimeZone, String swVersion) {
    if (StringUtils.isBlank(actAlarmDateAndTime)) {
        return null;
    }
    final GregorianCalendar decodedDateAndTimeCal = btiMakeCalendar(OctetString.fromHexString(actAlarmDateAndTime));
    if ((sysInfoTimeZone == null) || (swVersion == null)) {
        return decodedDateAndTimeCal.getTime();
    }
    final TimeZone javaTimeZone = getTimeZone();
    decodedDateAndTimeCal.setTimeZone(javaTimeZone);
    final GregorianCalendar localTime = new GregorianCalendar();
    localTime.setTimeInMillis(decodedDateAndTimeCal.getTimeInMillis());
    return localTime.getTime();
}
#method_after
public static Date getLocalDateAndTime(String actAlarmDateAndTime, String sysInfoTimeZone, String swVersion) {
    if (StringUtils.isBlank(actAlarmDateAndTime)) {
        return null;
    }
    GregorianCalendar decodedDateAndTimeCal = btiMakeCalendar(OctetString.fromHexString(actAlarmDateAndTime));
    if ((sysInfoTimeZone == null) || (swVersion == null)) {
        return decodedDateAndTimeCal.getTime();
    }
    TimeZone javaTimeZone = getTimeZone();
    decodedDateAndTimeCal.setTimeZone(javaTimeZone);
    GregorianCalendar localTime = new GregorianCalendar();
    localTime.setTimeInMillis(decodedDateAndTimeCal.getTimeInMillis());
    return localTime.getTime();
}
#end_block

#method_before
public static GregorianCalendar btiMakeCalendar(OctetString dateAndTimeValue) {
    final int year = (dateAndTimeValue.get(0) & 0xFF) * 256 + (dateAndTimeValue.get(1) & 0xFF);
    final int month = (dateAndTimeValue.get(2) & 0xFF);
    final int date = (dateAndTimeValue.get(3) & 0xFF);
    final int hour = (dateAndTimeValue.get(4) & 0xFF);
    final int minute = (dateAndTimeValue.get(5) & 0xFF);
    final int second = (dateAndTimeValue.get(6) & 0xFF);
    final int deci = (dateAndTimeValue.get(7) & 0xFF);
    final GregorianCalendar gc = new GregorianCalendar(year, month - 1, date, hour, minute, second);
    gc.set(Calendar.MILLISECOND, deci * 100);
    if (dateAndTimeValue.length() == 11) {
        final char directionOfOffset = (char) dateAndTimeValue.get(8);
        final int hoursOffset = directionOfOffset == '+' ? dateAndTimeValue.get(9) : -dateAndTimeValue.get(9);
        final org.joda.time.DateTimeZone offset = org.joda.time.DateTimeZone.forOffsetHoursMinutes(hoursOffset, dateAndTimeValue.get(10));
        final org.joda.time.DateTime dt = new org.joda.time.DateTime(year, month, date, hour, minute, second, offset);
        return dt.toGregorianCalendar();
    }
    return gc;
}
#method_after
public static GregorianCalendar btiMakeCalendar(OctetString dateAndTimeValue) {
    int year = (dateAndTimeValue.get(0) & 0xFF) * 256 + (dateAndTimeValue.get(1) & 0xFF);
    int month = (dateAndTimeValue.get(2) & 0xFF);
    int date = (dateAndTimeValue.get(3) & 0xFF);
    int hour = (dateAndTimeValue.get(4) & 0xFF);
    int minute = (dateAndTimeValue.get(5) & 0xFF);
    int second = (dateAndTimeValue.get(6) & 0xFF);
    int deci = (dateAndTimeValue.get(7) & 0xFF);
    GregorianCalendar gc = new GregorianCalendar(year, month - 1, date, hour, minute, second);
    gc.set(Calendar.MILLISECOND, deci * 100);
    if (dateAndTimeValue.length() == 11) {
        char directionOfOffset = (char) dateAndTimeValue.get(8);
        int hoursOffset = directionOfOffset == '+' ? dateAndTimeValue.get(9) : -dateAndTimeValue.get(9);
        org.joda.time.DateTimeZone offset = org.joda.time.DateTimeZone.forOffsetHoursMinutes(hoursOffset, dateAndTimeValue.get(10));
        org.joda.time.DateTime dt = new org.joda.time.DateTime(year, month, date, hour, minute, second, offset);
        return dt.toGregorianCalendar();
    }
    return gc;
}
#end_block

#method_before
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    final NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class) }));
        final com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System systemTree = (com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class));
        if (systemTree != null) {
            // TODO SNMP sys-contacts may be verbose; ONOS-GUI doesn't abbreviate fields neatly;
            // so cut it here until supported in prop displayer
            final String manufacturer = StringUtils.abbreviate(systemTree.getSysContact(), 20);
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), manufacturer, UNKNOWN, UNKNOWN, UNKNOWN, description.chassisId());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#method_after
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class) }));
        com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System systemTree = (com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class));
        if (systemTree != null) {
            // TODO SNMP sys-contacts may be verbose; ONOS-GUI doesn't abbreviate fields neatly;
            // so cut it here until supported in prop displayer
            String manufacturer = StringUtils.abbreviate(systemTree.getSysContact(), 20);
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), manufacturer, UNKNOWN, UNKNOWN, UNKNOWN, description.chassisId());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#end_block

#method_before
@Test
public void alarmCodecTestWithOptionalFieldMissing() {
    final JsonCodec<Alarm> codec = context.codec(Alarm.class);
    assertThat(codec, is(notNullValue()));
    final ObjectNode alarmJson = codec.encode(alarmMinimumFields, context);
    assertThat(alarmJson, notNullValue());
    assertThat(alarmJson, matchesAlarm(alarmMinimumFields));
}
#method_after
@Test
public void alarmCodecTestWithOptionalFieldMissing() {
    JsonCodec<Alarm> codec = context.codec(Alarm.class);
    assertThat(codec, is(notNullValue()));
    ObjectNode alarmJson = codec.encode(alarmMinimumFields, context);
    assertThat(alarmJson, notNullValue());
    assertThat(alarmJson, matchesAlarm(alarmMinimumFields));
}
#end_block

#method_before
@Test
public void alarmCodecTestWithOptionalField() {
    final JsonCodec<Alarm> codec = context.codec(Alarm.class);
    assertThat(codec, is(notNullValue()));
    final ObjectNode alarmJson = codec.encode(alarmWithSource, context);
    assertThat(alarmJson, notNullValue());
    assertThat(alarmJson, matchesAlarm(alarmWithSource));
}
#method_after
@Test
public void alarmCodecTestWithOptionalField() {
    JsonCodec<Alarm> codec = context.codec(Alarm.class);
    assertThat(codec, is(notNullValue()));
    ObjectNode alarmJson = codec.encode(alarmWithSource, context);
    assertThat(alarmJson, notNullValue());
    assertThat(alarmJson, matchesAlarm(alarmWithSource));
}
#end_block

#method_before
@Test
public void verifyMinimalAlarmIsEncoded() throws Exception {
    final JsonCodec<Alarm> alarmCodec = context.codec(Alarm.class);
    final Alarm alarm = getDecodedAlarm(alarmCodec, "alarm-minimal.json");
    assertCommon(alarm);
    assertThat(alarm.timeCleared(), nullValue());
    assertThat(alarm.assignedUser(), nullValue());
}
#method_after
@Test
public void verifyMinimalAlarmIsEncoded() throws Exception {
    JsonCodec<Alarm> alarmCodec = context.codec(Alarm.class);
    Alarm alarm = getDecodedAlarm(alarmCodec, "alarm-minimal.json");
    assertCommon(alarm);
    assertThat(alarm.timeCleared(), nullValue());
    assertThat(alarm.assignedUser(), nullValue());
}
#end_block

#method_before
@Test
public void verifyFullyLoadedAlarmIsEncoded() throws Exception {
    final JsonCodec<Alarm> alarmCodec = context.codec(Alarm.class);
    final Alarm alarm = getDecodedAlarm(alarmCodec, "alarm-full.json");
    assertCommon(alarm);
    assertThat(alarm.timeCleared(), is(2222L));
    assertThat(alarm.assignedUser(), is("foo"));
}
#method_after
@Test
public void verifyFullyLoadedAlarmIsEncoded() throws Exception {
    JsonCodec<Alarm> alarmCodec = context.codec(Alarm.class);
    Alarm alarm = getDecodedAlarm(alarmCodec, "alarm-full.json");
    assertCommon(alarm);
    assertThat(alarm.timeCleared(), is(2222L));
    assertThat(alarm.assignedUser(), is("foo"));
}
#end_block

#method_before
private void assertCommon(Alarm alarm) {
    assertThat(alarm.id(), is(new AlarmId(10L)));
    assertThat(alarm.description(), is("NE is not reachable"));
    assertThat(alarm.source(), is(AlarmEntityId.NONE));
    assertThat(alarm.timeRaised(), is(999L));
    assertThat(alarm.timeUpdated(), is(1111L));
    assertThat(alarm.severity(), is(Alarm.SeverityLevel.MAJOR));
    assertThat(alarm.serviceAffecting(), is(true));
    assertThat(alarm.acknowledged(), is(false));
    assertThat(alarm.manuallyClearable(), is(true));
}
#method_after
private void assertCommon(Alarm alarm) {
    assertThat(alarm.id(), is(AlarmId.alarmId(10L)));
    assertThat(alarm.description(), is("NE is not reachable"));
    assertThat(alarm.source(), is(AlarmEntityId.NONE));
    assertThat(alarm.timeRaised(), is(999L));
    assertThat(alarm.timeUpdated(), is(1111L));
    assertThat(alarm.severity(), is(Alarm.SeverityLevel.MAJOR));
    assertThat(alarm.serviceAffecting(), is(true));
    assertThat(alarm.acknowledged(), is(false));
    assertThat(alarm.manuallyClearable(), is(true));
}
#end_block

#method_before
private Alarm getDecodedAlarm(JsonCodec<Alarm> codec, String resourceName) throws IOException {
    try (final InputStream jsonStream = AlarmCodecTest.class.getResourceAsStream(resourceName)) {
        final JsonNode json = context.mapper().readTree(jsonStream);
        assertThat(json, notNullValue());
        final Alarm result = codec.decode((ObjectNode) json, context);
        assertThat(result, notNullValue());
        return result;
    }
}
#method_after
private Alarm getDecodedAlarm(JsonCodec<Alarm> codec, String resourceName) throws IOException {
    try (InputStream jsonStream = AlarmCodecTest.class.getResourceAsStream(resourceName)) {
        JsonNode json = context.mapper().readTree(jsonStream);
        assertThat(json, notNullValue());
        Alarm result = codec.decode((ObjectNode) json, context);
        assertThat(result, notNullValue());
        return result;
    }
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof AlarmId) {
        final AlarmId other = (AlarmId) obj;
        return Objects.equals(this.id, other.id);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof AlarmId) {
        AlarmId other = (AlarmId) obj;
        return Objects.equals(this.id, other.id);
    }
    return false;
}
#end_block

#method_before
@Override
public Collection<Alarm> getAlarms(ISnmpSession session, DeviceId deviceId) {
    final Set<Alarm> alarms = new HashSet<>();
    final NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(IfTable.class) }));
        final IfTable interfaceTable = (IfTable) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(IfTable.class));
        if (interfaceTable != null) {
            interfaceTable.getEntries().values().stream().forEach((ifEntry) -> {
                // TODO will raise alarm for each interface as a demo.
                // if (ifEntry.getIfAdminStatus() == 1 && ifEntry.getIfOperStatus() == 2){
                alarms.add(new DefaultAlarm.Builder(deviceId, "Link Down.", Alarm.SeverityLevel.CRITICAL, System.currentTimeMillis()).forSource(AlarmEntityId.alarmEntityId("port:" + ifEntry.getIfDescr())).build());
                // }
                log.info("Interface: " + ifEntry);
            });
        }
    } catch (IOException ex) {
        log.error("Error reading alarms for device {}.", deviceId, ex);
    }
    return alarms;
}
#method_after
@Override
public Collection<Alarm> getAlarms(ISnmpSession session, DeviceId deviceId) {
    Set<Alarm> alarms = new HashSet<>();
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(IfTable.class) }));
        IfTable interfaceTable = (IfTable) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(IfTable.class));
        if (interfaceTable != null) {
            interfaceTable.getEntries().values().stream().forEach((ifEntry) -> {
                // TODO will raise alarm for each interface as a demo.
                // if (ifEntry.getIfAdminStatus() == 1 && ifEntry.getIfOperStatus() == 2){
                alarms.add(new DefaultAlarm.Builder(deviceId, "Link Down.", Alarm.SeverityLevel.CRITICAL, System.currentTimeMillis()).forSource(AlarmEntityId.alarmEntityId("port:" + ifEntry.getIfDescr())).build());
                // }
                log.info("Interface: " + ifEntry);
            });
        }
    } catch (IOException ex) {
        log.error("Error reading alarms for device {}.", deviceId, ex);
    }
    return alarms;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getAlarms(@DefaultValue("false") @QueryParam("includeCleared") boolean includeCleared, @DefaultValue("") @QueryParam("devId") String devId) {
    log.info("Requesting all alarms, includeCleared={}", includeCleared);
    final AlarmService service = get(AlarmService.class);
    final Iterable<Alarm> alarms;
    if (StringUtils.isBlank(devId)) {
        alarms = includeCleared ? service.getAlarms() : service.getActiveAlarms();
    } else {
        alarms = service.getAlarms(DeviceId.deviceId(devId));
    }
    final ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("alarms", new AlarmCodec().encode(alarms, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getAlarms(@DefaultValue("false") @QueryParam("includeCleared") boolean includeCleared, @DefaultValue("") @QueryParam("devId") String devId) {
    log.info("Requesting all alarms, includeCleared={}", includeCleared);
    AlarmService service = get(AlarmService.class);
    Iterable<Alarm> alarms;
    if (StringUtils.isBlank(devId)) {
        alarms = includeCleared ? service.getAlarms() : service.getActiveAlarms();
    } else {
        alarms = service.getAlarms(DeviceId.deviceId(devId));
    }
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("alarms", new AlarmCodec().encode(alarms, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@GET
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getAlarm(@PathParam("id") String id) {
    log.info("HTTP GET alarm for id={}", id);
    final AlarmId alarmId = toAlarmId(id);
    final Alarm alarm = get(AlarmService.class).getAlarm(alarmId);
    final ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("alarm", new AlarmCodec().encode(alarm, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getAlarm(@PathParam("id") String id) {
    log.info("HTTP GET alarm for id={}", id);
    AlarmId alarmId = toAlarmId(id);
    Alarm alarm = get(AlarmService.class).getAlarm(alarmId);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("alarm", new AlarmCodec().encode(alarm, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@PUT
@Path("{alarm_id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response update(@PathParam("alarm_id") String alarmIdPath, InputStream stream) {
    log.info("PUT NEW ALARM at /{}", alarmIdPath);
    try {
        final ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        log.info("jsonTree={}", jsonTree);
        final Alarm alarm = new AlarmCodec().decode(jsonTree, this);
        final AlarmService service = get(AlarmService.class);
        if (Long.parseLong(alarmIdPath) != alarm.id().fingerprint()) {
            throw new IllegalArgumentException("id in path is " + Long.parseLong(alarmIdPath) + " but payload uses id=" + alarm.id().fingerprint());
        }
        final Alarm updated = service.update(alarm);
        final ObjectNode encoded = new AlarmCodec().encode(updated, this);
        return ok(encoded.toString()).build();
    } catch (IOException ioe) {
        throw new IllegalArgumentException(ioe);
    }
}
#method_after
@PUT
@Path("{alarm_id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response update(@PathParam("alarm_id") String alarmIdPath, InputStream stream) {
    log.info("PUT NEW ALARM at /{}", alarmIdPath);
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        log.info("jsonTree={}", jsonTree);
        Alarm alarm = new AlarmCodec().decode(jsonTree, this);
        AlarmService service = get(AlarmService.class);
        if (Long.parseLong(alarmIdPath) != alarm.id().fingerprint()) {
            throw new IllegalArgumentException("id in path is " + Long.parseLong(alarmIdPath) + " but payload uses id=" + alarm.id().fingerprint());
        }
        Alarm updated = service.updateBookkeepingFields(alarm.id(), alarm.acknowledged(), alarm.assignedUser());
        ObjectNode encoded = new AlarmCodec().encode(updated, this);
        return ok(encoded.toString()).build();
    } catch (IOException ioe) {
        throw new IllegalArgumentException(ioe);
    }
}
#end_block

#method_before
private static AlarmId toAlarmId(String id) {
    try {
        return AlarmId.valueOf(Long.parseLong(id));
    } catch (NumberFormatException ex) {
        throw new IllegalArgumentException("Alarm id should be numeric", ex);
    }
}
#method_after
private static AlarmId toAlarmId(String id) {
    try {
        return AlarmId.alarmId(Long.parseLong(id));
    } catch (NumberFormatException ex) {
        throw new IllegalArgumentException("Alarm id should be numeric", ex);
    }
}
#end_block

#method_before
@Test
public void testGettersWhenNoAlarms() {
    final AlarmsManager am = new AlarmsManager();
    assertTrue("No alarms", am.getAlarms().isEmpty());
    assertTrue("No active alarms", am.getActiveAlarms().isEmpty());
    assertTrue("No alarms gives empty map per unknown device", am.getAlarmCounts(DeviceId.NONE).keySet().isEmpty());
    assertTrue("No alarms gives empty map", am.getAlarmCounts().keySet().isEmpty());
    assertEquals("Zero alarms for that device", 0, am.getAlarms(DeviceId.NONE).size());
    assertEquals("Zero major alarms", 0, am.getAlarms(Alarm.SeverityLevel.MAJOR).size());
    try {
        assertEquals("no alarms", 0, am.getAlarm(null));
    } catch (NullPointerException ex) {
        assertThat(ex.getMessage(), containsString("cannot be null"));
    }
    try {
        assertEquals("no alarms", 0, am.getAlarm(AlarmId.valueOf(1)));
    } catch (ItemNotFoundException ex) {
        assertThat(ex.getMessage(), containsString("not found"));
    }
}
#method_after
@Test
public void testGettersWhenNoAlarms() {
    AlarmsManager am = new AlarmsManager();
    assertTrue("No alarms", am.getAlarms().isEmpty());
    assertTrue("No active alarms", am.getActiveAlarms().isEmpty());
    assertTrue("No alarms gives empty map per unknown device", am.getAlarmCounts(DeviceId.NONE).keySet().isEmpty());
    assertTrue("No alarms gives empty map", am.getAlarmCounts().keySet().isEmpty());
    assertEquals("Zero alarms for that device", 0, am.getAlarms(DeviceId.NONE).size());
    assertEquals("Zero major alarms", 0, am.getAlarms(Alarm.SeverityLevel.MAJOR).size());
    try {
        assertEquals("no alarms", 0, am.getAlarm(null));
    } catch (NullPointerException ex) {
        assertThat(ex.getMessage(), containsString("cannot be null"));
    }
    try {
        assertEquals("no alarms", 0, am.getAlarm(AlarmId.alarmId(1)));
    } catch (ItemNotFoundException ex) {
        assertThat(ex.getMessage(), containsString("not found"));
    }
}
#end_block

#method_before
@Test
public void testAlarmUpdates() {
    final AlarmsManager am = new AlarmsManager();
    assertTrue("no alarms", am.getAlarms().isEmpty());
    am.updateAlarms(new HashSet<>(), DEVICE_ID);
    assertTrue("still no alarms", am.getAlarms().isEmpty());
    final Map<Alarm.SeverityLevel, Long> zeroAlarms = new CountsMapBuilder().create();
    assertEquals(zeroAlarms, am.getAlarmCounts());
    assertEquals(zeroAlarms, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(ALARM_B, ALARM_A), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 2, 2);
    final Map<Alarm.SeverityLevel, Long> critical2 = new CountsMapBuilder().with(CRITICAL, 2L).create();
    assertEquals(critical2, am.getAlarmCounts());
    assertEquals(critical2, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(ALARM_A), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 2, 1);
    final Map<Alarm.SeverityLevel, Long> critical1cleared1 = new CountsMapBuilder().with(CRITICAL, 1L).with(CLEARED, 1L).create();
    assertEquals(critical1cleared1, am.getAlarmCounts());
    assertEquals(critical1cleared1, am.getAlarmCounts(DEVICE_ID));
    // No change map when same alarms sent
    am.updateAlarms(Sets.newHashSet(ALARM_A), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 2, 1);
    assertEquals(critical1cleared1, am.getAlarmCounts());
    assertEquals(critical1cleared1, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(ALARM_A, ALARM_A_WITHSRC), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 3, 2);
    final Map<Alarm.SeverityLevel, Long> critical2cleared1 = new CountsMapBuilder().with(CRITICAL, 2L).with(CLEARED, 1L).create();
    assertEquals(critical2cleared1, am.getAlarmCounts());
    assertEquals(critical2cleared1, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 3, 0);
    assertEquals(new CountsMapBuilder().with(CLEARED, 3L).create(), am.getAlarmCounts(DEVICE_ID));
    assertEquals("No alarms for unknown devices", zeroAlarms, am.getAlarmCounts(DeviceId.NONE));
    assertEquals("No alarms for unknown devices", zeroAlarms, am.getAlarmCounts(DeviceId.deviceId("junk:junk")));
}
#method_after
@Test
public void testAlarmUpdates() {
    AlarmsManager am = new AlarmsManager();
    assertTrue("no alarms", am.getAlarms().isEmpty());
    am.updateAlarms(new HashSet<>(), DEVICE_ID);
    assertTrue("still no alarms", am.getAlarms().isEmpty());
    Map<Alarm.SeverityLevel, Long> zeroAlarms = new CountsMapBuilder().create();
    assertEquals(zeroAlarms, am.getAlarmCounts());
    assertEquals(zeroAlarms, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(ALARM_B, ALARM_A), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 2, 2);
    Map<Alarm.SeverityLevel, Long> critical2 = new CountsMapBuilder().with(CRITICAL, 2L).create();
    assertEquals(critical2, am.getAlarmCounts());
    assertEquals(critical2, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(ALARM_A), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 2, 1);
    Map<Alarm.SeverityLevel, Long> critical1cleared1 = new CountsMapBuilder().with(CRITICAL, 1L).with(CLEARED, 1L).create();
    assertEquals(critical1cleared1, am.getAlarmCounts());
    assertEquals(critical1cleared1, am.getAlarmCounts(DEVICE_ID));
    // No change map when same alarms sent
    am.updateAlarms(Sets.newHashSet(ALARM_A), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 2, 1);
    assertEquals(critical1cleared1, am.getAlarmCounts());
    assertEquals(critical1cleared1, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(ALARM_A, ALARM_A_WITHSRC), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 3, 2);
    Map<Alarm.SeverityLevel, Long> critical2cleared1 = new CountsMapBuilder().with(CRITICAL, 2L).with(CLEARED, 1L).create();
    assertEquals(critical2cleared1, am.getAlarmCounts());
    assertEquals(critical2cleared1, am.getAlarmCounts(DEVICE_ID));
    am.updateAlarms(Sets.newHashSet(), DEVICE_ID);
    verifyGettingSetsOfAlarms(am, 3, 0);
    assertEquals(new CountsMapBuilder().with(CLEARED, 3L).create(), am.getAlarmCounts(DEVICE_ID));
    assertEquals("No alarms for unknown devices", zeroAlarms, am.getAlarmCounts(DeviceId.NONE));
    assertEquals("No alarms for unknown devices", zeroAlarms, am.getAlarmCounts(DeviceId.deviceId("junk:junk")));
}
#end_block

#method_before
@Before
public void setUp() {
    mockSessionFactory = EasyMock.createMock(ISnmpSessionFactory.class);
    mockSession = EasyMock.createMock(ISnmpSession.class);
    mockProvider = EasyMock.createMock(SnmpDeviceAlarmProvider.class);
    alarmProvider = new SnmpAlarmProviderService() {

        @Override
        protected ISnmpSessionFactory getSessionFactory() {
            return mockSessionFactory;
        }
    };
    alarmProvider.addLinkListener((AlarmEvent event) -> {
        alarmEvent = event;
    });
}
#method_after
@Before
public void setUp() {
    mockSessionFactory = EasyMock.createMock(ISnmpSessionFactory.class);
    mockSession = EasyMock.createMock(ISnmpSession.class);
    mockProvider = EasyMock.createMock(SnmpDeviceAlarmProvider.class);
    alarmProvider = new SnmpAlarmProviderService() {

        @Override
        protected ISnmpSessionFactory getSessionFactory() {
            return mockSessionFactory;
        }
    };
    alarmProvider.addAlarmListener((AlarmEvent event) -> {
        alarmEvent = event;
    });
}
#end_block

#method_before
@Test
public void shouldFindAlarms() throws UnknownHostException, IOException {
    alarmsTable = new ActAlarmTable();
    alarmsTable.createEntry("14.1.3.6.1.4.1.18070.2.2.2.2.20.0.1.13.1.3.6.1.4.1." + "18070.2.2.1.4.14.1.7.49.46.55.46.50.46.53");
    final IActAlarmEntry entry = alarmsTable.getEntries().values().iterator().next();
    entry.setActAlarmDescription("XFP Missing.");
    entry.setActAlarmDateAndTime("07:df:0c:01:03:0d:30:00");
    entry.setActAlarmSeverity(1);
    final Capture<NetworkDevice> networkDeviceCapture = new Capture<>();
    expect(mockSession.getAddress()).andReturn(InetAddress.getLoopbackAddress());
    expect(mockSession.walkDevice(capture(networkDeviceCapture), eq(Arrays.asList(new OID[] { Bti7000SnmpAlarmProvider.CLASS_REGISTRY.getClassToOidMap().get(ActAlarmTable.class) })))).andAnswer(() -> {
        networkDeviceCapture.getValue().getRootObject().setObject(alarmsTable);
        return null;
    });
    replay(mockSession);
    Collection<Alarm> alarms = alarmProvider.getAlarms(mockSession, DeviceId.deviceId("snmp:1.1.1.1"));
    assertEquals(1, alarms.size());
    assertEquals("XFP Missing.", alarms.iterator().next().description());
    verify(mockSession);
}
#method_after
@Test
public void shouldFindAlarms() throws UnknownHostException, IOException {
    alarmsTable = new ActAlarmTable();
    alarmsTable.createEntry("14.1.3.6.1.4.1.18070.2.2.2.2.20.0.1.13.1.3.6.1.4.1." + "18070.2.2.1.4.14.1.7.49.46.55.46.50.46.53");
    IActAlarmEntry entry = alarmsTable.getEntries().values().iterator().next();
    entry.setActAlarmDescription("XFP Missing.");
    entry.setActAlarmDateAndTime("07:df:0c:01:03:0d:30:00");
    entry.setActAlarmSeverity(1);
    Capture<NetworkDevice> networkDeviceCapture = new Capture<>();
    expect(mockSession.getAddress()).andReturn(InetAddress.getLoopbackAddress());
    expect(mockSession.walkDevice(capture(networkDeviceCapture), eq(Arrays.asList(new OID[] { Bti7000SnmpAlarmProvider.CLASS_REGISTRY.getClassToOidMap().get(ActAlarmTable.class) })))).andAnswer(() -> {
        networkDeviceCapture.getValue().getRootObject().setObject(alarmsTable);
        return null;
    });
    replay(mockSession);
    Collection<Alarm> alarms = alarmProvider.getAlarms(mockSession, DeviceId.deviceId("snmp:1.1.1.1"));
    assertEquals(1, alarms.size());
    assertEquals("XFP Missing.", alarms.iterator().next().description());
    verify(mockSession);
}
#end_block

#method_before
@Override
public Alarm decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    log.debug("id={}, full json={} ", json.get("id"), json);
    final Long id = json.get("id").asLong();
    final DeviceId deviceId = DeviceId.deviceId(json.get("deviceId").asText());
    final String description = json.get("description").asText();
    final Long timeRaised = json.get("timeRaised").asLong();
    final Long timeUpdated = json.get("timeUpdated").asLong();
    final JsonNode jsonTimeCleared = json.get("timeCleared");
    final Long timeCleared = jsonTimeCleared == null || jsonTimeCleared.isNull() ? null : jsonTimeCleared.asLong();
    final Alarm.SeverityLevel severity = Alarm.SeverityLevel.valueOf(json.get("severity").asText().toUpperCase());
    final Boolean serviceAffecting = json.get("serviceAffecting").asBoolean();
    final Boolean acknowledged = json.get("acknowledged").asBoolean();
    final Boolean manuallyClearable = json.get("manuallyClearable").asBoolean();
    final JsonNode jsonAssignedUser = json.get("assignedUser");
    final String assignedUser = jsonAssignedUser == null || jsonAssignedUser.isNull() ? null : jsonAssignedUser.asText();
    return new DefaultAlarm.Builder(deviceId, description, severity, timeRaised).forSource(AlarmEntityId.NONE).withId(AlarmId.valueOf(id)).withTimeUpdated(timeUpdated).withTimeCleared(timeCleared).withServiceAffecting(serviceAffecting).withAcknowledged(acknowledged).withManuallyClearable(manuallyClearable).withAssignedUser(assignedUser).build();
}
#method_after
@Override
public Alarm decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    log.debug("id={}, full json={} ", json.get("id"), json);
    Long id = json.get("id").asLong();
    DeviceId deviceId = DeviceId.deviceId(json.get("deviceId").asText());
    String description = json.get("description").asText();
    Long timeRaised = json.get("timeRaised").asLong();
    Long timeUpdated = json.get("timeUpdated").asLong();
    JsonNode jsonTimeCleared = json.get("timeCleared");
    Long timeCleared = jsonTimeCleared == null || jsonTimeCleared.isNull() ? null : jsonTimeCleared.asLong();
    Alarm.SeverityLevel severity = Alarm.SeverityLevel.valueOf(json.get("severity").asText().toUpperCase());
    Boolean serviceAffecting = json.get("serviceAffecting").asBoolean();
    Boolean acknowledged = json.get("acknowledged").asBoolean();
    Boolean manuallyClearable = json.get("manuallyClearable").asBoolean();
    JsonNode jsonAssignedUser = json.get("assignedUser");
    String assignedUser = jsonAssignedUser == null || jsonAssignedUser.isNull() ? null : jsonAssignedUser.asText();
    return new DefaultAlarm.Builder(deviceId, description, severity, timeRaised).forSource(AlarmEntityId.NONE).withId(AlarmId.alarmId(id)).withTimeUpdated(timeUpdated).withTimeCleared(timeCleared).withServiceAffecting(serviceAffecting).withAcknowledged(acknowledged).withManuallyClearable(manuallyClearable).withAssignedUser(assignedUser).build();
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    log.info("modified ...");
    if (context == null) {
        log.info("No configuration file");
        return;
    }
    final Dictionary<?, ?> properties = context.getProperties();
    log.info("properties={}", context.getProperties());
    final String deviceCfgValue = get(properties, "devConfigs");
    log.info("Settings: devConfigs={}", deviceCfgValue);
    if (!isNullOrEmpty(deviceCfgValue)) {
        addOrRemoveDevicesConfig(deviceCfgValue);
    }
    log.info("... modified");
}
#method_after
@Modified
public void modified(ComponentContext context) {
    log.info("modified ...");
    if (context == null) {
        log.info("No configuration file");
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    log.info("properties={}", context.getProperties());
    String deviceCfgValue = get(properties, "devConfigs");
    log.info("Settings: devConfigs={}", deviceCfgValue);
    if (!isNullOrEmpty(deviceCfgValue)) {
        addOrRemoveDevicesConfig(deviceCfgValue);
    }
    log.info("... modified");
}
#end_block

#method_before
private void addOrRemoveDevicesConfig(String deviceConfig) {
    for (String deviceEntry : deviceConfig.split(",")) {
        final SnmpDevice device = processDeviceEntry(deviceEntry);
        if (device != null) {
            log.info("Device Detail:host={}, port={}, state={}", new Object[] { device.getSnmpHost(), device.getSnmpPort(), device.getDeviceState().name() });
            if (device.isActive()) {
                deviceBuilder.submit(new DeviceCreator(device, true));
            } else {
                deviceBuilder.submit(new DeviceCreator(device, false));
            }
        }
    }
}
#method_after
private void addOrRemoveDevicesConfig(String deviceConfig) {
    for (String deviceEntry : deviceConfig.split(",")) {
        SnmpDevice device = processDeviceEntry(deviceEntry);
        if (device != null) {
            log.info("Device Detail:host={}, port={}, state={}", new Object[] { device.getSnmpHost(), device.getSnmpPort(), device.getDeviceState().name() });
            if (device.isActive()) {
                deviceBuilder.submit(new DeviceCreator(device, true));
            } else {
                deviceBuilder.submit(new DeviceCreator(device, false));
            }
        }
    }
}
#end_block

#method_before
private SnmpDevice processDeviceEntry(String deviceEntry) {
    if (deviceEntry == null) {
        log.info("No content for Device Entry, so cannot proceed further.");
        return null;
    }
    log.info("Trying to convert {} to a SNMP Device Object", deviceEntry);
    SnmpDevice device = null;
    try {
        final String userInfo = deviceEntry.substring(0, deviceEntry.lastIndexOf('@'));
        final String hostInfo = deviceEntry.substring(deviceEntry.lastIndexOf('@') + 1);
        String[] infoSplit = userInfo.split(":");
        final String username = infoSplit[0];
        final String password = infoSplit[1];
        infoSplit = hostInfo.split(":");
        final String hostIp = infoSplit[0];
        Integer hostPort;
        try {
            hostPort = Integer.parseInt(infoSplit[1]);
        } catch (NumberFormatException nfe) {
            log.error("Bad Configuration Data: Failed to parse host port number string: " + infoSplit[1]);
            throw nfe;
        }
        final String deviceState = infoSplit[2];
        if (isNullOrEmpty(username) || isNullOrEmpty(password) || isNullOrEmpty(hostIp) || hostPort == 0) {
            log.warn("Bad Configuration Data: both user and device information parts of Configuration " + deviceEntry + " should be non-nullable");
        } else {
            device = new SnmpDevice(hostIp, hostPort, password);
            if (!isNullOrEmpty(deviceState)) {
                if (deviceState.toUpperCase().equals(DeviceState.ACTIVE.name())) {
                    device.setDeviceState(DeviceState.ACTIVE);
                } else if (deviceState.toUpperCase().equals(DeviceState.INACTIVE.name())) {
                    device.setDeviceState(DeviceState.INACTIVE);
                } else {
                    log.warn("Device State Information can not be empty, so marking the state as INVALID");
                    device.setDeviceState(DeviceState.INVALID);
                }
            } else {
                log.warn("The device entry do not specify state information, so marking the state as INVALID");
                device.setDeviceState(DeviceState.INVALID);
            }
        }
    } catch (ArrayIndexOutOfBoundsException aie) {
        log.error("Error while reading config infromation from the config file: " + "The user, host and device state infomation should be " + "in the order 'userInfo@hostInfo:deviceState'" + deviceEntry, aie);
    } catch (Exception e) {
        log.error("Error while parsing config information for the device entry: " + deviceEntry, e);
    }
    return device;
}
#method_after
private SnmpDevice processDeviceEntry(String deviceEntry) {
    if (deviceEntry == null) {
        log.info("No content for Device Entry, so cannot proceed further.");
        return null;
    }
    log.info("Trying to convert {} to a SNMP Device Object", deviceEntry);
    SnmpDevice device = null;
    try {
        String userInfo = deviceEntry.substring(0, deviceEntry.lastIndexOf('@'));
        String hostInfo = deviceEntry.substring(deviceEntry.lastIndexOf('@') + 1);
        String[] infoSplit = userInfo.split(":");
        String username = infoSplit[0];
        String password = infoSplit[1];
        infoSplit = hostInfo.split(":");
        String hostIp = infoSplit[0];
        Integer hostPort;
        try {
            hostPort = Integer.parseInt(infoSplit[1]);
        } catch (NumberFormatException nfe) {
            log.error("Bad Configuration Data: Failed to parse host port number string: " + infoSplit[1]);
            throw nfe;
        }
        String deviceState = infoSplit[2];
        if (isNullOrEmpty(username) || isNullOrEmpty(password) || isNullOrEmpty(hostIp) || hostPort == 0) {
            log.warn("Bad Configuration Data: both user and device information parts of Configuration " + deviceEntry + " should be non-nullable");
        } else {
            device = new SnmpDevice(hostIp, hostPort, password);
            if (!isNullOrEmpty(deviceState)) {
                if (deviceState.toUpperCase().equals(DeviceState.ACTIVE.name())) {
                    device.setDeviceState(DeviceState.ACTIVE);
                } else if (deviceState.toUpperCase().equals(DeviceState.INACTIVE.name())) {
                    device.setDeviceState(DeviceState.INACTIVE);
                } else {
                    log.warn("Device State Information can not be empty, so marking the state as INVALID");
                    device.setDeviceState(DeviceState.INVALID);
                }
            } else {
                log.warn("The device entry do not specify state information, so marking the state as INVALID");
                device.setDeviceState(DeviceState.INVALID);
            }
        }
    } catch (ArrayIndexOutOfBoundsException aie) {
        log.error("Error while reading config infromation from the config file: " + "The user, host and device state infomation should be " + "in the order 'userInfo@hostInfo:deviceState'" + deviceEntry, aie);
    } catch (Exception e) {
        log.error("Error while parsing config information for the device entry: " + deviceEntry, e);
    }
    return device;
}
#end_block

#method_before
@Override
public boolean isReachable(DeviceId deviceId) {
    final SnmpDevice snmpDevice = snmpDeviceMap.get(deviceId);
    if (snmpDevice == null) {
        log.warn("BAD REQUEST: the requested device id: " + deviceId.toString() + "  is not associated to any SNMP Device");
        return false;
    }
    return snmpDevice.isReachable();
}
#method_after
@Override
public boolean isReachable(DeviceId deviceId) {
    SnmpDevice snmpDevice = snmpDeviceMap.get(deviceId);
    if (snmpDevice == null) {
        log.warn("BAD REQUEST: the requested device id: " + deviceId.toString() + "  is not associated to any SNMP Device");
        return false;
    }
    return snmpDevice.isReachable();
}
#end_block

#method_before
private void removeDevices() {
    if (device == null) {
        log.warn("The Request SNMP Device is null, cannot proceed further");
        return;
    }
    try {
        final DeviceId did = getDeviceId();
        if (!snmpDeviceMap.containsKey(did)) {
            log.error("BAD Request: 'Currently device is not discovered, " + "so cannot remove/disconnect the device: " + device.deviceInfo() + "'");
            return;
        }
        providerService.deviceDisconnected(did);
        device.disconnect();
        snmpDeviceMap.remove(did);
        delay(EVENTINTERVAL);
    } catch (URISyntaxException uriSyntaxExcpetion) {
        log.error("Syntax Error while creating URI for the device: " + device.deviceInfo() + " couldn't remove the device from the store", uriSyntaxExcpetion);
    }
}
#method_after
private void removeDevices() {
    if (device == null) {
        log.warn("The Request SNMP Device is null, cannot proceed further");
        return;
    }
    try {
        DeviceId did = getDeviceId();
        if (!snmpDeviceMap.containsKey(did)) {
            log.error("BAD Request: 'Currently device is not discovered, " + "so cannot remove/disconnect the device: " + device.deviceInfo() + "'");
            return;
        }
        providerService.deviceDisconnected(did);
        device.disconnect();
        snmpDeviceMap.remove(did);
        delay(EVENTINTERVAL);
    } catch (URISyntaxException uriSyntaxExcpetion) {
        log.error("Syntax Error while creating URI for the device: " + device.deviceInfo() + " couldn't remove the device from the store", uriSyntaxExcpetion);
    }
}
#end_block

#method_before
private void advertiseDevices() {
    try {
        if (device == null) {
            log.warn("The Request SNMP Device is null, cannot proceed further");
            return;
        }
        device.init();
        final DeviceId did = getDeviceId();
        final ChassisId cid = new ChassisId();
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.OTHER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid);
        desc = populateDescriptionFromDevice(did, desc);
        log.info("Persisting Device " + did.uri().toString());
        snmpDeviceMap.put(did, device);
        providerService.deviceConnected(did, desc);
        log.info("Done with Device Info Creation on ONOS core. Device Info: " + device.deviceInfo() + " " + did.uri().toString());
        delay(EVENTINTERVAL);
    } catch (URISyntaxException e) {
        log.error("Syntax Error while creating URI for the device: " + device.deviceInfo() + " couldn't persist the device onto the store", e);
    } catch (Exception e) {
        log.error("Error while initializing session for the device: " + (device != null ? device.deviceInfo() : null), e);
    }
}
#method_after
private void advertiseDevices() {
    try {
        if (device == null) {
            log.warn("The Request SNMP Device is null, cannot proceed further");
            return;
        }
        device.init();
        DeviceId did = getDeviceId();
        ChassisId cid = new ChassisId();
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.OTHER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid);
        desc = populateDescriptionFromDevice(did, desc);
        log.info("Persisting Device " + did.uri().toString());
        snmpDeviceMap.put(did, device);
        providerService.deviceConnected(did, desc);
        log.info("Done with Device Info Creation on ONOS core. Device Info: " + device.deviceInfo() + " " + did.uri().toString());
        delay(EVENTINTERVAL);
    } catch (URISyntaxException e) {
        log.error("Syntax Error while creating URI for the device: " + device.deviceInfo() + " couldn't persist the device onto the store", e);
    } catch (Exception e) {
        log.error("Error while initializing session for the device: " + (device != null ? device.deviceInfo() : null), e);
    }
}
#end_block

#method_before
private DeviceDescription populateDescriptionFromDevice(DeviceId did, DeviceDescription desc) {
    final String[] deviceComponents = did.toString().split(":");
    if (deviceComponents.length > 1) {
        final String ipAddress = deviceComponents[1];
        final String port = deviceComponents[2];
        final ISnmpConfiguration config = new V2cSnmpConfiguration();
        config.setPort(Integer.parseInt(port));
        try (final ISnmpSession session = sessionFactory.createSession(config, ipAddress)) {
            // Each session will be auto-closed.
            final String deviceOID = session.identifyDevice();
            if (providers.containsKey(deviceOID)) {
                desc = providers.get(deviceOID).populateDescription(session, desc);
            }
        } catch (IOException | RuntimeException ex) {
            log.error("Failed to walk device.", ex.getMessage());
            log.debug("Detailed problem was ", ex);
        }
    }
    return desc;
}
#method_after
private DeviceDescription populateDescriptionFromDevice(DeviceId did, DeviceDescription desc) {
    String[] deviceComponents = did.toString().split(":");
    if (deviceComponents.length > 1) {
        String ipAddress = deviceComponents[1];
        String port = deviceComponents[2];
        ISnmpConfiguration config = new V2cSnmpConfiguration();
        config.setPort(Integer.parseInt(port));
        try (ISnmpSession session = sessionFactory.createSession(config, ipAddress)) {
            // Each session will be auto-closed.
            String deviceOID = session.identifyDevice();
            if (providers.containsKey(deviceOID)) {
                desc = providers.get(deviceOID).populateDescription(session, desc);
            }
        } catch (IOException | RuntimeException ex) {
            log.error("Failed to walk device.", ex.getMessage());
            log.debug("Detailed problem was ", ex);
        }
    }
    return desc;
}
#end_block

#method_before
private DeviceId getDeviceId() throws URISyntaxException {
    final String additionalSSP = new StringBuilder(device.getSnmpHost()).append(":").append(device.getSnmpPort()).toString();
    return DeviceId.deviceId(new URI(SCHEME, additionalSSP, null));
}
#method_after
private DeviceId getDeviceId() throws URISyntaxException {
    String additionalSSP = new StringBuilder(device.getSnmpHost()).append(":").append(device.getSnmpPort()).toString();
    return DeviceId.deviceId(new URI(SCHEME, additionalSSP, null));
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onos.snmp");
    eventHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/alarms", "event-handler"));
    deviceService.addListener(new InternalDeviceListener());
    log.info("activated SNMP provider with appId = {} and context props {}", appId, context.getProperties());
    modified(context);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onosproject.snmp");
    eventHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/alarms", "event-handler"));
    deviceService.addListener(new InternalDeviceListener());
    log.info("activated SNMP provider with appId = {} and context props {}", appId, context.getProperties());
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.info("deactivate SNMP provider {}", appId);
    // TODO
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    log.info("deactivate SNMP provider {}", appId);
}
#end_block

#method_before
@Override
public void triggerProbe(DeviceId deviceId) {
    log.info("SNMP walk request for alarms at deviceId={}", deviceId);
    if (!isSnmpDevice(deviceId)) {
        log.info("Ignore non-snmp device!");
        return;
    }
    final String[] deviceComponents = deviceId.toString().split(":");
    final Set<Alarm> alarms = new HashSet<>(Sets.newHashSet());
    if (deviceComponents.length > 1) {
        final String ipAddress = deviceComponents[1];
        final String port = deviceComponents[2];
        final ISnmpConfiguration config = new V2cSnmpConfiguration();
        config.setPort(Integer.parseInt(port));
        try (final ISnmpSession session = getSessionFactory().createSession(config, ipAddress)) {
            // Each session will be auto-closed.
            final String deviceOID = session.identifyDevice();
            alarms.addAll(getAlarmsForDevice(deviceOID, session, deviceId));
            log.info("SNMP walk completed ok for deviceId={}", deviceId);
        } catch (IOException | RuntimeException ex) {
            log.error("Failed to walk device.", ex.getMessage());
            log.debug("Detailed problem was ", ex);
            alarms.add(buildWalkFailedAlarm(deviceId));
        }
    }
    final AlarmEvent alarmEvent = new AlarmEvent(alarms, deviceId);
    alarmEventListener.stream().forEach((listener) -> {
        listener.event(alarmEvent);
        log.info("Successfully event with discovered alarms for deviceId={} to {}", deviceId, listener);
    });
}
#method_after
@Override
public void triggerProbe(DeviceId deviceId) {
    log.info("SNMP walk request for alarms at deviceId={}", deviceId);
    if (!isSnmpDevice(deviceId)) {
        log.info("Ignore non-snmp device!");
        return;
    }
    String[] deviceComponents = deviceId.toString().split(":");
    Set<Alarm> alarms = new HashSet<>(Sets.newHashSet());
    if (deviceComponents.length > 1) {
        String ipAddress = deviceComponents[1];
        String port = deviceComponents[2];
        ISnmpConfiguration config = new V2cSnmpConfiguration();
        config.setPort(Integer.parseInt(port));
        try (ISnmpSession session = getSessionFactory().createSession(config, ipAddress)) {
            // Each session will be auto-closed.
            String deviceOID = session.identifyDevice();
            alarms.addAll(getAlarmsForDevice(deviceOID, session, deviceId));
            log.info("SNMP walk completed ok for deviceId={}", deviceId);
        } catch (IOException | RuntimeException ex) {
            log.error("Failed to walk device.", ex.getMessage());
            log.debug("Detailed problem was ", ex);
            alarms.add(buildWalkFailedAlarm(deviceId));
        }
    }
    AlarmEvent alarmEvent = new AlarmEvent(alarms, deviceId);
    alarmEventListener.stream().forEach((listener) -> {
        listener.event(alarmEvent);
        log.info("Successfully event with discovered alarms for deviceId={} to {}", deviceId, listener);
    });
}
#end_block

#method_before
private Collection<Alarm> getAlarmsForDevice(String deviceOID, final ISnmpSession session, DeviceId deviceID) throws IOException {
    final Collection<Alarm> alarms = new HashSet<>();
    if (providers.containsKey(deviceOID)) {
        alarms.addAll(providers.get(deviceOID).getAlarms(session, deviceID));
    }
    return alarms;
}
#method_after
private Collection<Alarm> getAlarmsForDevice(String deviceOID, ISnmpSession session, DeviceId deviceID) throws IOException {
    Collection<Alarm> alarms = new HashSet<>();
    if (providers.containsKey(deviceOID)) {
        alarms.addAll(providers.get(deviceOID).getAlarms(session, deviceID));
    }
    return alarms;
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    log.info("InternalDeviceListener has got event from device-service{} with ", event);
    eventHandlingExecutor.execute(() -> {
        try {
            final DeviceId deviceId = event.subject().id();
            log.info("From device {}", deviceId);
            if (!isSnmpDevice(deviceId)) {
                log.info("Ignore non-snmp device event for {}", deviceId);
                return;
            }
            switch(event.type()) {
                case DEVICE_ADDED:
                case DEVICE_UPDATED:
                case DEVICE_AVAILABILITY_CHANGED:
                    if (deviceService.isAvailable(event.subject().id())) {
                        triggerProbe(deviceId);
                    }
                    break;
                case DEVICE_REMOVED:
                case DEVICE_SUSPENDED:
                default:
                    // however for now ignore and fall through
                    break;
            }
        } catch (Exception e) {
            log.warn("Failed to process {}", event, e);
        }
    });
}
#method_after
@Override
public void event(DeviceEvent event) {
    log.info("InternalDeviceListener has got event from device-service{} with ", event);
    eventHandlingExecutor.execute(() -> {
        try {
            DeviceId deviceId = event.subject().id();
            log.info("From device {}", deviceId);
            if (!isSnmpDevice(deviceId)) {
                log.info("Ignore non-snmp device event for {}", deviceId);
                return;
            }
            switch(event.type()) {
                case DEVICE_ADDED:
                case DEVICE_UPDATED:
                case DEVICE_AVAILABILITY_CHANGED:
                    if (deviceService.isAvailable(event.subject().id())) {
                        triggerProbe(deviceId);
                    }
                    break;
                case DEVICE_REMOVED:
                case DEVICE_SUSPENDED:
                default:
                    // however for now ignore and fall through
                    break;
            }
        } catch (Exception e) {
            log.warn("Failed to process {}", event, e);
        }
    });
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    // Make sure equals() is tume with hashCode() so works ok in a hashSet !
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final DefaultAlarm other = (DefaultAlarm) obj;
    // id or timeRaised or timeUpdated may differ
    if (!Objects.equals(this.deviceId, other.deviceId)) {
        return false;
    }
    if (!Objects.equals(this.description, other.description)) {
        return false;
    }
    if (!Objects.equals(this.source, other.source)) {
        return false;
    }
    if (!Objects.equals(this.timeCleared, other.timeCleared)) {
        return false;
    }
    if (this.severity != other.severity) {
        return false;
    }
    if (this.isServiceAffecting != other.isServiceAffecting) {
        return false;
    }
    if (this.isAcknowledged != other.isAcknowledged) {
        return false;
    }
    if (this.isManuallyClearable != other.isManuallyClearable) {
        return false;
    }
    if (!Objects.equals(this.assignedUser, other.assignedUser)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(final Object obj) {
    // Make sure equals() is tune with hashCode() so works ok in a hashSet !
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final DefaultAlarm other = (DefaultAlarm) obj;
    // id or timeRaised or timeUpdated may differ
    if (!Objects.equals(this.deviceId, other.deviceId)) {
        return false;
    }
    if (!Objects.equals(this.description, other.description)) {
        return false;
    }
    if (!Objects.equals(this.source, other.source)) {
        return false;
    }
    if (!Objects.equals(this.timeCleared, other.timeCleared)) {
        return false;
    }
    if (this.severity != other.severity) {
        return false;
    }
    if (this.isServiceAffecting != other.isServiceAffecting) {
        return false;
    }
    if (this.isAcknowledged != other.isAcknowledged) {
        return false;
    }
    if (this.isManuallyClearable != other.isManuallyClearable) {
        return false;
    }
    if (!Objects.equals(this.assignedUser, other.assignedUser)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void shouldFindAlarms() throws UnknownHostException, IOException {
    interfaceTable = new IfTable();
    interfaceTable.createEntry("1");
    IIfEntry entry = interfaceTable.getEntry("1");
    entry.setIfDescr("eth1");
    entry.setIfAdminStatus(1);
    entry.setIfOperStatus(2);
    final Capture<NetworkDevice> networkDeviceCapture = new Capture<>();
    expect(mockSession.getAddress()).andReturn(InetAddress.getLoopbackAddress());
    expect(mockSession.walkDevice(capture(networkDeviceCapture), eq(Arrays.asList(new OID[] { NetSnmpAlarmProvider.CLASS_REGISTRY.getClassToOidMap().get(IfTable.class) })))).andAnswer(() -> {
        networkDeviceCapture.getValue().getRootObject().setObject(interfaceTable);
        return null;
    });
    replay(mockSession);
    Collection<Alarm> alarms = alarmProvider.getAlarms(mockSession, DeviceId.deviceId("snmp:1.1.1.1"));
    assertEquals(1, alarms.size());
    assertEquals("Link Down.", alarms.iterator().next().description());
    verify(mockSession);
}
#method_after
@Test
public void shouldFindAlarms() throws UnknownHostException, IOException {
    interfaceTable = new IfTable();
    interfaceTable.createEntry("1");
    IIfEntry entry = interfaceTable.getEntry("1");
    entry.setIfDescr("eth1");
    entry.setIfAdminStatus(1);
    entry.setIfOperStatus(2);
    Capture<NetworkDevice> networkDeviceCapture = new Capture<>();
    expect(mockSession.getAddress()).andReturn(InetAddress.getLoopbackAddress());
    expect(mockSession.walkDevice(capture(networkDeviceCapture), eq(Arrays.asList(new OID[] { NetSnmpAlarmProvider.CLASS_REGISTRY.getClassToOidMap().get(IfTable.class) })))).andAnswer(() -> {
        networkDeviceCapture.getValue().getRootObject().setObject(interfaceTable);
        return null;
    });
    replay(mockSession);
    Collection<Alarm> alarms = alarmProvider.getAlarms(mockSession, DeviceId.deviceId("snmp:1.1.1.1"));
    assertEquals(1, alarms.size());
    assertEquals("Link Down.", alarms.iterator().next().description());
    verify(mockSession);
}
#end_block

#method_before
@Test
public void testEquality() {
    final AlarmId id1 = new AlarmId(ID_A);
    final AlarmId id2 = new AlarmId(ID_A);
    assertThat(id1, is(id2));
}
#method_after
@Test
public void testEquality() {
    final AlarmId id1 = AlarmId.alarmId(ID_A);
    final AlarmId id2 = AlarmId.alarmId(ID_A);
    assertThat(id1, is(id2));
}
#end_block

#method_before
@Test
public void testNonEquality() {
    final AlarmId id1 = new AlarmId(ID_A);
    final AlarmId id2 = new AlarmId(ID_B);
    assertThat(id1, is(not(id2)));
}
#method_after
@Test
public void testNonEquality() {
    final AlarmId id1 = AlarmId.alarmId(ID_A);
    final AlarmId id2 = AlarmId.alarmId(ID_B);
    assertThat(id1, is(not(id2)));
}
#end_block

#method_before
@Test
public void valueOf() {
    final AlarmId id = new AlarmId(0xdeadbeefL);
    assertEquals("incorrect valueOf", id, AlarmId.valueOf(0xdeadbeefL));
}
#method_after
@Test
public void valueOf() {
    final AlarmId id = AlarmId.alarmId(0xdeadbeefL);
    assertEquals("incorrect valueOf", id, AlarmId.alarmId(0xdeadbeefL));
}
#end_block

#method_before
@Test
public void testEquals() {
    final AlarmId id1 = new AlarmId(11111L);
    final AlarmId sameAsId1 = new AlarmId(11111L);
    final AlarmId id2 = new AlarmId(22222L);
    new EqualsTester().addEqualityGroup(id1, sameAsId1).addEqualityGroup(id2).testEquals();
}
#method_after
@Test
public void testEquals() {
    final AlarmId id1 = AlarmId.alarmId(11111L);
    final AlarmId sameAsId1 = AlarmId.alarmId(11111L);
    final AlarmId id2 = AlarmId.alarmId(22222L);
    new EqualsTester().addEqualityGroup(id1, sameAsId1).addEqualityGroup(id2).testEquals();
}
#end_block

#method_before
@Test
public void testConstruction() {
    final AlarmId id1 = new AlarmId(ID_Z);
    assertEquals(id1.fingerprint(), ID_Z);
    // No default constructor so no need to test it !
    assertEquals(0L, AlarmId.NONE.fingerprint());
    try {
        final AlarmId bad = new AlarmId(0L);
        fail("0 is a Reserved value but we created " + bad);
    } catch (IllegalArgumentException ex) {
        assertThat(ex.getMessage(), containsString("Invalid id"));
    }
}
#method_after
@Test
public void testConstruction() {
    final AlarmId id1 = AlarmId.alarmId(ID_Z);
    assertEquals(id1.fingerprint(), ID_Z);
    // No default constructor so no need to test it !
    assertEquals(0L, AlarmId.NONE.fingerprint());
    try {
        final AlarmId bad = AlarmId.alarmId(0L);
        fail("0 is a Reserved value but we created " + bad);
    } catch (IllegalArgumentException ex) {
        assertThat(ex.getMessage(), containsString("id must be non-zero"));
    }
}
#end_block

#method_before
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    final NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class) }));
        final com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System systemTree = (com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class));
        if (systemTree != null) {
            String[] systemComponents = systemTree.getSysDescr().split(";");
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), systemComponents[0], systemComponents[2], systemComponents[3], UNKNOWN, description.chassisId());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#method_after
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class) }));
        com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System systemTree = (com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class));
        if (systemTree != null) {
            String[] systemComponents = systemTree.getSysDescr().split(";");
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), systemComponents[0], systemComponents[2], systemComponents[3], UNKNOWN, description.chassisId());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#end_block

#method_before
private AlarmId generateAlarmId() {
    return new AlarmId(alarmIdGenerator.incrementAndGet());
}
#method_after
private AlarmId generateAlarmId() {
    return AlarmId.alarmId(alarmIdGenerator.incrementAndGet());
}
#end_block

#method_before
public Alarm clear(AlarmId id) {
    final Alarm found = alarms.get(id);
    if (found == null) {
        log.warn("id {} cant be cleared as it is already gone.", id);
        return null;
    }
    final Alarm updated = new DefaultAlarm.Builder(found).clear().build();
    alarms.put(id, updated);
    return updated;
}
#method_after
public Alarm clear(AlarmId id) {
    Alarm found = alarms.get(id);
    if (found == null) {
        log.warn("id {} cant be cleared as it is already gone.", id);
        return null;
    }
    Alarm updated = new DefaultAlarm.Builder(found).clear().build();
    alarms.put(id, updated);
    return updated;
}
#end_block

#method_before
@Override
public Set<Alarm> getAlarms(DeviceId deviceId, final AlarmEntityId source) {
    return getAlarms(deviceId).stream().filter(a -> source.equals(a.source())).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Alarm> getAlarms(DeviceId deviceId, AlarmEntityId source) {
    return getAlarms(deviceId).stream().filter(a -> source.equals(a.source())).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Set<Alarm> getAlarmsForLink(ConnectPoint src, final ConnectPoint dst) {
    // TODO
    throw new UnsupportedOperationException(NOT_SUPPORTED_YET);
}
#method_after
@Override
public Set<Alarm> getAlarmsForLink(ConnectPoint src, ConnectPoint dst) {
    // TODO
    throw new UnsupportedOperationException(NOT_SUPPORTED_YET);
}
#end_block

#method_before
@Override
public void event(AlarmEvent event) {
    log.debug("AlarmsManager. InternalAlarmListener received {}", event);
    try {
        switch(event.type()) {
            case DEVICE_DISCOVERY:
                final DeviceId deviceId = checkNotNull(event.getDeviceRefreshed(), "Listener cannot be null");
                log.info("New alarm set for {} received!", deviceId);
                updateAlarms(event.subject(), deviceId);
                break;
            case NOTIFICATION:
                throw new IllegalArgumentException("Alarm Notifications (Traps) not expected or implemented yet. Received =" + event);
            default:
                break;
        }
    } catch (Exception e) {
        log.warn("Failed to process {}", event, e);
    }
}
#method_after
@Override
public void event(AlarmEvent event) {
    log.debug("AlarmsManager. InternalAlarmListener received {}", event);
    try {
        switch(event.type()) {
            case DEVICE_DISCOVERY:
                DeviceId deviceId = checkNotNull(event.getDeviceRefreshed(), "Listener cannot be null");
                log.info("New alarm set for {} received!", deviceId);
                updateAlarms(event.subject(), deviceId);
                break;
            case NOTIFICATION:
                throw new IllegalArgumentException("Alarm Notifications (Traps) not expected or implemented yet. Received =" + event);
            default:
                break;
        }
    } catch (Exception e) {
        log.warn("Failed to process {}", event, e);
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onos.faultmanagement.alarms");
    idGenerator = coreService.getIdGenerator("alarm-ids");
    log.info("Started with appId={}", appId);
    alarmProvider.addLinkListener(alarmListener);
    probeActiveDevices();
    final boolean result = modified(context);
    log.info("modified result = {}", result);
    alarmPollExecutor = newSingleThreadScheduledExecutor(groupedThreads("onos/fm", "alarms-poll-%d"));
    alarmPollExecutor.scheduleAtFixedRate(new PollAlarmsTask(), alarmPollFrequencySeconds, alarmPollFrequencySeconds, SECONDS);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onosproject.faultmanagement.alarms");
    idGenerator = coreService.getIdGenerator("alarm-ids");
    log.info("Started with appId={}", appId);
    alarmProvider.addAlarmListener(alarmListener);
    probeActiveDevices();
    boolean result = modified(context);
    log.info("modified result = {}", result);
    alarmPollExecutor = newSingleThreadScheduledExecutor(groupedThreads("onos/fm", "alarms-poll-%d"));
    alarmPollExecutor.scheduleAtFixedRate(new PollAlarmsTask(), alarmPollFrequencySeconds, alarmPollFrequencySeconds, SECONDS);
}
#end_block

#method_before
private void probeActiveDevices() {
    final Iterable<Device> devices = deviceService.getAvailableDevices();
    log.info("Refresh alarms for all available devices={} ...", devices);
    for (Device d : devices) {
        log.info("Lets tell alarm provider to refresh alarms for {} ...", d.id());
        alarmProvider.triggerProbe(d.id());
    }
}
#method_after
private void probeActiveDevices() {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    log.info("Refresh alarms for all available devices={} ...", devices);
    for (Device d : devices) {
        log.info("Lets tell alarm provider to refresh alarms for {} ...", d.id());
        alarmProvider.triggerProbe(d.id());
    }
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    log.info("Deactivate ...");
    alarmProvider.removeLinkListener(alarmListener);
    if (alarmPollExecutor != null) {
        alarmPollExecutor.shutdownNow();
    }
    alarms.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    log.info("Deactivate ...");
    alarmProvider.removeAlarmListener(alarmListener);
    if (alarmPollExecutor != null) {
        alarmPollExecutor.shutdownNow();
    }
    alarms.clear();
    log.info("Stopped");
}
#end_block

#method_before
@Modified
public boolean modified(ComponentContext context) {
    log.info("context={}", context);
    if (context == null) {
        log.info("No configuration file");
        return false;
    }
    final Dictionary<?, ?> properties = context.getProperties();
    final String clearedAlarmPurgeSeconds = get(properties, "clearedAlarmPurgeSeconds");
    log.info("Settings: clearedAlarmPurgeSeconds={}", clearedAlarmPurgeSeconds);
    return true;
}
#method_after
@Modified
public boolean modified(ComponentContext context) {
    log.info("context={}", context);
    if (context == null) {
        log.info("No configuration file");
        return false;
    }
    Dictionary<?, ?> properties = context.getProperties();
    String clearedAlarmPurgeSeconds = get(properties, "clearedAlarmPurgeSeconds");
    log.info("Settings: clearedAlarmPurgeSeconds={}", clearedAlarmPurgeSeconds);
    return true;
}
#end_block

#method_before
synchronized void updateAlarms(Set<Alarm> discoveredSet, final DeviceId deviceId) {
    final Set<Alarm> storedSet = getActiveAlarms(deviceId);
    log.trace("currentNeAlarms={}. discoveredAlarms={}", storedSet, discoveredSet);
    if (CollectionUtils.isEqualCollection(storedSet, discoveredSet)) {
        log.debug("Alarm lists are equivalent so no update for {}.", deviceId);
        return;
    }
    storedSet.stream().filter((stored) -> (!discoveredSet.contains(stored))).forEach((stored) -> {
        log.info("Alarm will be cleared as it is not on the element. Cleared alarm: {}.", stored);
        clear(stored.id());
    });
    discoveredSet.stream().filter((discovered) -> (!storedSet.contains(discovered))).forEach((discovered) -> {
        log.info("Alarm will be raised as it is missing. New alarm: {}.", discovered);
        final AlarmId id = generateAlarmId();
        alarms.put(id, new DefaultAlarm.Builder(discovered).withId(id).build());
    });
}
#method_after
synchronized void updateAlarms(Set<Alarm> discoveredSet, DeviceId deviceId) {
    Set<Alarm> storedSet = getActiveAlarms(deviceId);
    log.trace("currentNeAlarms={}. discoveredAlarms={}", storedSet, discoveredSet);
    if (CollectionUtils.isEqualCollection(storedSet, discoveredSet)) {
        log.debug("Alarm lists are equivalent so no update for {}.", deviceId);
        return;
    }
    storedSet.stream().filter((stored) -> (!discoveredSet.contains(stored))).forEach((stored) -> {
        log.info("Alarm will be cleared as it is not on the element. Cleared alarm: {}.", stored);
        clear(stored.id());
    });
    discoveredSet.stream().filter((discovered) -> (!storedSet.contains(discovered))).forEach((discovered) -> {
        log.info("Alarm will be raised as it is missing. New alarm: {}.", discovered);
        AlarmId id = generateAlarmId();
        alarms.put(id, new DefaultAlarm.Builder(discovered).withId(id).build());
    });
}
#end_block

