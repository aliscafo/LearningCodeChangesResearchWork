160
#method_before
@Override
public Cursor query(String callingPkg, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, ICancellationSignal cancellationSignal) {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        // it may not handle properly the tautology where clause we would have created.
        if (projection != null) {
            return new MatrixCursor(projection, 0);
        }
        // Null projection means all columns but we have no idea which they are.
        // However, the caller may be expecting to access them my index. Hence,
        // we have to execute the query as if allowed to get a cursor with the
        // columns. We then use the column names to return an empty cursor.
        Cursor cursor = ContentProvider.this.query(uri, projection, selection, selectionArgs, sortOrder, CancellationSignal.fromTransport(cancellationSignal));
        if (cursor == null) {
            return null;
        }
        // Return an empty cursor for all columns.
        return new MatrixCursor(cursor.getColumnNames(), 0);
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.query(uri, projection, selection, selectionArgs, sortOrder, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public Cursor query(String callingPkg, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, ICancellationSignal cancellationSignal) {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        // it may not handle properly the tautology where clause we would have created.
        if (projection != null) {
            return new MatrixCursor(projection, 0);
        }
        // Null projection means all columns but we have no idea which they are.
        // However, the caller may be expecting to access them my index. Hence,
        // we have to execute the query as if allowed to get a cursor with the
        // columns. We then use the column names to return an empty cursor.
        Cursor cursor = ContentProvider.this.query(uri, projection, selection, selectionArgs, sortOrder, CancellationSignal.fromTransport(cancellationSignal));
        if (cursor == null) {
            return null;
        }
        // Return an empty cursor for all columns.
        return new MatrixCursor(cursor.getColumnNames(), 0);
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.query(uri, projection, selection, selectionArgs, sortOrder, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public String getType(Uri uri) {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    return ContentProvider.this.getType(uri);
}
#method_after
@Override
public String getType(Uri uri) {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    return ContentProvider.this.getType(uri);
}
#end_block

#method_before
@Override
public Uri insert(String callingPkg, Uri uri, ContentValues initialValues) {
    uri = validateIncomingUri(uri);
    int userId = getUserIdFromUri(uri);
    uri = getUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return rejectInsert(uri, initialValues);
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return maybeAddUserId(ContentProvider.this.insert(uri, initialValues), userId);
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public Uri insert(String callingPkg, Uri uri, ContentValues initialValues) {
    uri = validateIncomingUri(uri);
    int userId = getUserIdFromUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return rejectInsert(uri, initialValues);
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return maybeAddUserId(ContentProvider.this.insert(uri, initialValues), userId);
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public int bulkInsert(String callingPkg, Uri uri, ContentValues[] initialValues) {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return 0;
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.bulkInsert(uri, initialValues);
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public int bulkInsert(String callingPkg, Uri uri, ContentValues[] initialValues) {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return 0;
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.bulkInsert(uri, initialValues);
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public int delete(String callingPkg, Uri uri, String selection, String[] selectionArgs) {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return 0;
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.delete(uri, selection, selectionArgs);
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public int delete(String callingPkg, Uri uri, String selection, String[] selectionArgs) {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return 0;
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.delete(uri, selection, selectionArgs);
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public int update(String callingPkg, Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return 0;
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.update(uri, values, selection, selectionArgs);
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public int update(String callingPkg, Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    if (enforceWritePermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) {
        return 0;
    }
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.update(uri, values, selection, selectionArgs);
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public ParcelFileDescriptor openFile(String callingPkg, Uri uri, String mode, ICancellationSignal cancellationSignal, IBinder callerToken) throws FileNotFoundException {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    enforceFilePermission(callingPkg, uri, mode, callerToken);
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.openFile(uri, mode, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public ParcelFileDescriptor openFile(String callingPkg, Uri uri, String mode, ICancellationSignal cancellationSignal, IBinder callerToken) throws FileNotFoundException {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    enforceFilePermission(callingPkg, uri, mode, callerToken);
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.openFile(uri, mode, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public AssetFileDescriptor openAssetFile(String callingPkg, Uri uri, String mode, ICancellationSignal cancellationSignal) throws FileNotFoundException {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    enforceFilePermission(callingPkg, uri, mode, null);
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.openAssetFile(uri, mode, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public AssetFileDescriptor openAssetFile(String callingPkg, Uri uri, String mode, ICancellationSignal cancellationSignal) throws FileNotFoundException {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    enforceFilePermission(callingPkg, uri, mode, null);
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.openAssetFile(uri, mode, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
@Override
public String[] getStreamTypes(Uri uri, String mimeTypeFilter) {
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    return ContentProvider.this.getStreamTypes(uri, mimeTypeFilter);
}
#method_after
@Override
public String[] getStreamTypes(Uri uri, String mimeTypeFilter) {
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    return ContentProvider.this.getStreamTypes(uri, mimeTypeFilter);
}
#end_block

#method_before
@Override
public AssetFileDescriptor openTypedAssetFile(String callingPkg, Uri uri, String mimeType, Bundle opts, ICancellationSignal cancellationSignal) throws FileNotFoundException {
    Bundle.setDefusable(opts, true);
    uri = validateIncomingUri(uri);
    uri = getUriWithoutUserId(uri);
    enforceFilePermission(callingPkg, uri, "r", null);
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.openTypedAssetFile(uri, mimeType, opts, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#method_after
@Override
public AssetFileDescriptor openTypedAssetFile(String callingPkg, Uri uri, String mimeType, Bundle opts, ICancellationSignal cancellationSignal) throws FileNotFoundException {
    Bundle.setDefusable(opts, true);
    uri = validateIncomingUri(uri);
    uri = maybeGetUriWithoutUserId(uri);
    enforceFilePermission(callingPkg, uri, "r", null);
    final String original = setCallingPackage(callingPkg);
    try {
        return ContentProvider.this.openTypedAssetFile(uri, mimeType, opts, CancellationSignal.fromTransport(cancellationSignal));
    } finally {
        setCallingPackage(original);
    }
}
#end_block

#method_before
public Uri validateIncomingUri(Uri uri) throws SecurityException {
    String auth = uri.getAuthority();
    int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
    if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
        throw new SecurityException("trying to query a ContentProvider in user " + mContext.getUserId() + " with a uri belonging to user " + userId);
    }
    if (!matchesOurAuthorities(getAuthorityWithoutUserId(auth))) {
        String message = "The authority of the uri " + uri + " does not match the one of the " + "contentProvider: ";
        if (mAuthority != null) {
            message += mAuthority;
        } else {
            message += Arrays.toString(mAuthorities);
        }
        throw new SecurityException(message);
    }
    // Normalize the path by removing any empty path segments, which can be
    // a source of security issues.
    final String encodedPath = uri.getEncodedPath();
    if (encodedPath != null && encodedPath.indexOf("//") != -1) {
        final Uri normalized = uri.buildUpon().encodedPath(encodedPath.replaceAll("//+", "/")).build();
        Log.w(TAG, "Normalized " + uri + " to " + normalized + " to avoid possible security issues");
        return normalized;
    } else {
        return uri;
    }
}
#method_after
public Uri validateIncomingUri(Uri uri) throws SecurityException {
    String auth = uri.getAuthority();
    if (!mSingleUser) {
        int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
        if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
            throw new SecurityException("trying to query a ContentProvider in user " + mContext.getUserId() + " with a uri belonging to user " + userId);
        }
    }
    if (!matchesOurAuthorities(getAuthorityWithoutUserId(auth))) {
        String message = "The authority of the uri " + uri + " does not match the one of the " + "contentProvider: ";
        if (mAuthority != null) {
            message += mAuthority;
        } else {
            message += Arrays.toString(mAuthorities);
        }
        throw new SecurityException(message);
    }
    // Normalize the path by removing any empty path segments, which can be
    // a source of security issues.
    final String encodedPath = uri.getEncodedPath();
    if (encodedPath != null && encodedPath.indexOf("//") != -1) {
        final Uri normalized = uri.buildUpon().encodedPath(encodedPath.replaceAll("//+", "/")).build();
        Log.w(TAG, "Normalized " + uri + " to " + normalized + " to avoid possible security issues");
        return normalized;
    } else {
        return uri;
    }
}
#end_block

#method_before
protected boolean skipAnimation() {
    return false;
}
#method_after
protected boolean skipAnimation() {
    return !mWin.isDrawnLw();
}
#end_block

#method_before
void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) {
    // Abort possibly stuck animations.
    mHandler.post(mWindowManagerFuncs::triggerAnimationFailsafe);
    if (respectKeyguard) {
        if (isKeyguardShowingAndNotOccluded()) {
            // don't launch home if keyguard showing
            return;
        } else if (mKeyguardOccluded && mKeyguardDelegate.isShowing()) {
            mKeyguardDelegate.dismiss(new KeyguardDismissCallback() {

                @Override
                public void onDismissSucceeded() throws RemoteException {
                    mHandler.post(() -> {
                        startDockOrHome(true, /*fromHomeKey*/
                        awakenFromDreams);
                    });
                }
            }, null);
            return;
        } else if (!mKeyguardOccluded && mKeyguardDelegate.isInputRestricted()) {
            // when in keyguard restricted mode, must first verify unlock
            // before launching home
            mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

                @Override
                public void onKeyguardExitResult(boolean success) {
                    if (success) {
                        startDockOrHome(true, /*fromHomeKey*/
                        awakenFromDreams);
                    }
                }
            });
            return;
        }
    }
    // no keyguard stuff to worry about, just launch home!
    if (mRecentsVisible) {
        try {
            ActivityManager.getService().stopAppSwitches();
        } catch (RemoteException e) {
        }
        // Hide Recents and notify it to launch Home
        if (awakenFromDreams) {
            awakenDreams();
        }
        hideRecentApps(false, true);
    } else if (mScreenOnFully) {
        // Otherwise, just launch Home
        startDockOrHome(true, /*fromHomeKey*/
        awakenFromDreams);
    }
}
#method_after
void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) {
    // Abort possibly stuck animations.
    mHandler.post(mWindowManagerFuncs::triggerAnimationFailsafe);
    if (respectKeyguard) {
        if (isKeyguardShowingAndNotOccluded()) {
            // don't launch home if keyguard showing
            return;
        }
        if (!mKeyguardOccluded && mKeyguardDelegate.isInputRestricted()) {
            // when in keyguard restricted mode, must first verify unlock
            // before launching home
            mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

                @Override
                public void onKeyguardExitResult(boolean success) {
                    if (success) {
                        startDockOrHome(true, /*fromHomeKey*/
                        awakenFromDreams);
                    }
                }
            });
            return;
        }
    }
    // no keyguard stuff to worry about, just launch home!
    if (mRecentsVisible) {
        try {
            ActivityManager.getService().stopAppSwitches();
        } catch (RemoteException e) {
        }
        // Hide Recents and notify it to launch Home
        if (awakenFromDreams) {
            awakenDreams();
        }
        hideRecentApps(false, true);
    } else if (mScreenOnFully) {
        // Otherwise, just launch Home
        startDockOrHome(true, /*fromHomeKey*/
        awakenFromDreams);
    }
}
#end_block

#method_before
@Override
public void beginLayoutLw(DisplayFrames displayFrames, int uiMode) {
    displayFrames.onBeginLayout();
    // TODO(multi-display): This doesn't seem right...Maybe only apply to default display?
    mSystemGestures.screenWidth = displayFrames.mUnrestricted.width();
    mSystemGestures.screenHeight = displayFrames.mUnrestricted.height();
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    vf.set(displayFrames.mDock);
    of.set(displayFrames.mDock);
    df.set(displayFrames.mDock);
    pf.set(displayFrames.mDock);
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (displayFrames.mDisplayId == DEFAULT_DISPLAY) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mKeyguardOccluded;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        boolean statusBarExpandedNotKeyguard = !isKeyguardShowing && mStatusBar != null && mStatusBar.getAttrs().height == MATCH_PARENT && mStatusBar.getAttrs().width == MATCH_PARENT;
        // nav bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mHandler.sendMessage(mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer));
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null && mStatusBar != null && canHideNavigationBar()) {
            mInputConsumer = mWindowManagerFuncs.createInputConsumer(mHandler.getLooper(), INPUT_CONSUMER_NAVIGATION, (channel, looper) -> new HideNavInputEventReceiver(channel, looper));
            // As long as mInputConsumer is active, hover events are not dispatched to the app
            // and the pointer icon is likely to become stale. Hide it to avoid confusion.
            InputManager.getInstance().setPointerIconType(PointerIcon.TYPE_NULL);
        }
        // For purposes of positioning and showing the nav bar, if we have decided that it can't
        // be hidden (because of the screen aspect ratio), then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = layoutNavigationBar(displayFrames, uiMode, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "mDock rect:" + displayFrames.mDock);
        updateSysUiVisibility |= layoutStatusBar(displayFrames, pf, df, of, vf, dcf, sysui, isKeyguardShowing);
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
    layoutScreenDecorWindows(displayFrames, pf, df, dcf);
    if (displayFrames.mDisplayCutoutSafe.top > displayFrames.mUnrestricted.top) {
        // Make sure that the zone we're avoiding for the cutout is at least as tall as the
        // status bar; otherwise fullscreen apps will end up cutting halfway into the status
        // bar.
        displayFrames.mDisplayCutoutSafe.top = Math.max(displayFrames.mDisplayCutoutSafe.top, displayFrames.mStable.top);
    }
}
#method_after
@Override
public void beginLayoutLw(DisplayFrames displayFrames, int uiMode) {
    displayFrames.onBeginLayout();
    // TODO(multi-display): This doesn't seem right...Maybe only apply to default display?
    mSystemGestures.screenWidth = displayFrames.mUnrestricted.width();
    mSystemGestures.screenHeight = displayFrames.mUnrestricted.height();
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    vf.set(displayFrames.mDock);
    of.set(displayFrames.mDock);
    df.set(displayFrames.mDock);
    pf.set(displayFrames.mDock);
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (displayFrames.mDisplayId == DEFAULT_DISPLAY) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mKeyguardOccluded;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        boolean statusBarExpandedNotKeyguard = !isKeyguardShowing && mStatusBar != null && (mStatusBar.getAttrs().privateFlags & PRIVATE_FLAG_STATUS_BAR_EXPANDED) != 0;
        // nav bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mHandler.sendMessage(mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer));
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null && mStatusBar != null && canHideNavigationBar()) {
            mInputConsumer = mWindowManagerFuncs.createInputConsumer(mHandler.getLooper(), INPUT_CONSUMER_NAVIGATION, (channel, looper) -> new HideNavInputEventReceiver(channel, looper));
            // As long as mInputConsumer is active, hover events are not dispatched to the app
            // and the pointer icon is likely to become stale. Hide it to avoid confusion.
            InputManager.getInstance().setPointerIconType(PointerIcon.TYPE_NULL);
        }
        // For purposes of positioning and showing the nav bar, if we have decided that it can't
        // be hidden (because of the screen aspect ratio), then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = layoutNavigationBar(displayFrames, uiMode, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "mDock rect:" + displayFrames.mDock);
        updateSysUiVisibility |= layoutStatusBar(displayFrames, pf, df, of, vf, dcf, sysui, isKeyguardShowing);
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
    layoutScreenDecorWindows(displayFrames, pf, df, dcf);
    if (displayFrames.mDisplayCutoutSafe.top > displayFrames.mUnrestricted.top) {
        // Make sure that the zone we're avoiding for the cutout is at least as tall as the
        // status bar; otherwise fullscreen apps will end up cutting halfway into the status
        // bar.
        displayFrames.mDisplayCutoutSafe.top = Math.max(displayFrames.mDisplayCutoutSafe.top, displayFrames.mStable.top);
    }
}
#end_block

#method_before
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached, WindowState imeTarget) {
    final boolean affectsSystemUi = win.canAffectSystemUiFlags();
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": affectsSystemUi=" + affectsSystemUi);
    applyKeyguardPolicyLw(win, imeTarget);
    final int fl = getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final int windowingMode = win.getWindowingMode();
    final boolean inFullScreenOrSplitScreenSecondaryWindowingMode = windowingMode == WINDOWING_MODE_FULLSCREEN || windowingMode == WINDOWING_MODE_SPLIT_SCREEN_SECONDARY;
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            mForceStatusBar = true;
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (attrs.isFullscreen() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
        }
    }
    // Voice interaction overrides both top fullscreen and top docked.
    if (affectsSystemUi && win.getAttrs().type == TYPE_VOICE_INTERACTION) {
        if (mTopFullscreenOpaqueWindowState == null) {
            mTopFullscreenOpaqueWindowState = win;
            if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                mTopFullscreenOpaqueOrDimmingWindowState = win;
            }
        }
        if (mTopDockedOpaqueWindowState == null) {
            mTopDockedOpaqueWindowState = win;
            if (mTopDockedOpaqueOrDimmingWindowState == null) {
                mTopDockedOpaqueOrDimmingWindowState = win;
            }
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && affectsSystemUi && appWindow && attached == null && attrs.isFullscreen() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
    // Take note if a window wants to acquire a sleep token.
    if (win.isVisibleLw() && (attrs.privateFlags & PRIVATE_FLAG_ACQUIRES_SLEEP_TOKEN) != 0 && win.canAcquireSleepToken()) {
        mWindowSleepTokenNeeded = true;
    }
}
#method_after
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached, WindowState imeTarget) {
    final boolean affectsSystemUi = win.canAffectSystemUiFlags();
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": affectsSystemUi=" + affectsSystemUi);
    applyKeyguardPolicyLw(win, imeTarget);
    final int fl = getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final int windowingMode = win.getWindowingMode();
    final boolean inFullScreenOrSplitScreenSecondaryWindowingMode = windowingMode == WINDOWING_MODE_FULLSCREEN || windowingMode == WINDOWING_MODE_SPLIT_SCREEN_SECONDARY;
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            mForceStatusBar = true;
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (attrs.isFullscreen() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
        }
    }
    // Voice interaction overrides both top fullscreen and top docked.
    if (affectsSystemUi && win.getAttrs().type == TYPE_VOICE_INTERACTION) {
        if (mTopFullscreenOpaqueWindowState == null) {
            mTopFullscreenOpaqueWindowState = win;
            if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                mTopFullscreenOpaqueOrDimmingWindowState = win;
            }
        }
        if (mTopDockedOpaqueWindowState == null) {
            mTopDockedOpaqueWindowState = win;
            if (mTopDockedOpaqueOrDimmingWindowState == null) {
                mTopDockedOpaqueOrDimmingWindowState = win;
            }
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && affectsSystemUi && appWindow && attached == null && attrs.isFullscreen() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
    // Take note if a window wants to acquire a sleep token.
    if ((attrs.privateFlags & PRIVATE_FLAG_ACQUIRES_SLEEP_TOKEN) != 0 && win.canAcquireSleepToken()) {
        mWindowSleepTokenNeeded = true;
    }
}
#end_block

#method_before
@Override
public int finishPostLayoutPolicyLw() {
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = isKeyguardShowingAndNotOccluded();
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        WindowManager.LayoutParams statusBarAttrs = mStatusBar.getAttrs();
        boolean statusBarExpanded = statusBarAttrs.height == MATCH_PARENT && statusBarAttrs.width == MATCH_PARENT;
        boolean topAppHidesStatusBar = topAppHidesStatusBar();
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent || statusBarExpanded) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if ((mForceStatusBarFromKeyguard || statusBarExpanded) && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            topIsFullscreen = topAppHidesStatusBar;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_FREEFORM) && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_SPLIT_SCREEN_PRIMARY)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
                topAppHidesStatusBar = false;
            }
        }
        mStatusBarController.setTopAppHidesStatusBar(topAppHidesStatusBar);
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    if (mShowingDream != mLastShowingDream) {
        mLastShowingDream = mShowingDream;
        mWindowManagerFuncs.notifyShowingDreamChanged();
    }
    updateWindowSleepToken();
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
#method_after
@Override
public int finishPostLayoutPolicyLw() {
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = isKeyguardShowingAndNotOccluded();
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        boolean statusBarExpanded = (mStatusBar.getAttrs().privateFlags & PRIVATE_FLAG_STATUS_BAR_EXPANDED) != 0;
        boolean topAppHidesStatusBar = topAppHidesStatusBar();
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent || statusBarExpanded) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if ((mForceStatusBarFromKeyguard || statusBarExpanded) && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            topIsFullscreen = topAppHidesStatusBar;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_FREEFORM) && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_SPLIT_SCREEN_PRIMARY)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
                topAppHidesStatusBar = false;
            }
        }
        mStatusBarController.setTopAppHidesStatusBar(topAppHidesStatusBar);
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    if (mShowingDream != mLastShowingDream) {
        mLastShowingDream = mShowingDream;
        mWindowManagerFuncs.notifyShowingDreamChanged();
    }
    updateWindowSleepToken();
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
#end_block

#method_before
@Override
public int rotationForOrientationLw(int orientation, int lastRotation, boolean defaultDisplay) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (!defaultDisplay) {
            // For secondary displays we ignore things like displays sensors, docking mode and
            // rotation lock, and always prefer a default rotation.
            preferredRotation = Surface.ROTATION_0;
        } else if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (mDemoRotationLock) {
            // Ignore sensor when demo rotation lock is enabled.
            // Note that the dock orientation and HDMI rotation lock override this.
            preferredRotation = mDemoRotation;
        } else if (mPersistentVrModeEnabled) {
            // While in VR, apps always prefer a portrait rotation. This does not change
            // any apps that explicitly set landscape, but does cause sensors be ignored,
            // and ignored any orientation lock that the user has set (this conditional
            // should remain above the ORIENTATION_LOCKED conditional below).
            preferredRotation = mPortraitRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // Rotation setting bitmask (1=0; 2=90; 4=180; 8=270)
            boolean allowed = true;
            if (mUserRotationAngles < 0) {
                // Not set by user so use these defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (1 | 2 | 4 | 8) : // All except 180
                (1 | 2 | 8);
            }
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & 1) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & 2) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & 4) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & 8) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#method_after
@Override
public int rotationForOrientationLw(int orientation, int lastRotation, boolean defaultDisplay) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0 || sensorRotation > 3) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (!defaultDisplay) {
            // For secondary displays we ignore things like displays sensors, docking mode and
            // rotation lock, and always prefer a default rotation.
            preferredRotation = Surface.ROTATION_0;
        } else if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (mDemoRotationLock) {
            // Ignore sensor when demo rotation lock is enabled.
            // Note that the dock orientation and HDMI rotation lock override this.
            preferredRotation = mDemoRotation;
        } else if (mPersistentVrModeEnabled) {
            // While in VR, apps always prefer a portrait rotation. This does not change
            // any apps that explicitly set landscape, but does cause sensors be ignored,
            // and ignored any orientation lock that the user has set (this conditional
            // should remain above the ORIENTATION_LOCKED conditional below).
            preferredRotation = mPortraitRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // Rotation setting bitmask (1=0; 2=90; 4=180; 8=270)
            boolean allowed = true;
            if (mUserRotationAngles < 0) {
                // Not set by user so use these defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (1 | 2 | 4 | 8) : // All except 180
                (1 | 2 | 8);
            }
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & 1) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & 2) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & 4) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & 8) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#end_block

#method_before
public int relayoutWindow(Session session, IWindow client, int seq, LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, long frameNumber, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration, Surface outSurface) {
    int result = 0;
    boolean configChanged;
    final boolean hasStatusBarPermission = mContext.checkCallingOrSelfPermission(permission.STATUS_BAR) == PackageManager.PERMISSION_GRANTED;
    final boolean hasStatusBarServicePermission = mContext.checkCallingOrSelfPermission(permission.STATUS_BAR_SERVICE) == PackageManager.PERMISSION_GRANTED;
    long origId = Binder.clearCallingIdentity();
    final int displayId;
    synchronized (mWindowMap) {
        WindowState win = windowForClientLocked(session, client, false);
        if (win == null) {
            return 0;
        }
        displayId = win.getDisplayId();
        WindowStateAnimator winAnimator = win.mWinAnimator;
        if (viewVisibility != View.GONE) {
            win.setRequestedSize(requestedWidth, requestedHeight);
        }
        win.setFrameNumber(frameNumber);
        int attrChanges = 0;
        int flagChanges = 0;
        if (attrs != null) {
            mPolicy.adjustWindowParamsLw(win, attrs, hasStatusBarServicePermission);
            // if they don't have the permission, mask out the status bar bits
            if (seq == win.mSeq) {
                int systemUiVisibility = attrs.systemUiVisibility | attrs.subtreeSystemUiVisibility;
                if ((systemUiVisibility & DISABLE_MASK) != 0) {
                    if (!hasStatusBarPermission) {
                        systemUiVisibility &= ~DISABLE_MASK;
                    }
                }
                win.mSystemUiVisibility = systemUiVisibility;
            }
            if (win.mAttrs.type != attrs.type) {
                throw new IllegalArgumentException("Window type can not be changed after the window is added.");
            }
            // Odd choice but less odd than embedding in copyFrom()
            if ((attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PRESERVE_GEOMETRY) != 0) {
                attrs.x = win.mAttrs.x;
                attrs.y = win.mAttrs.y;
                attrs.width = win.mAttrs.width;
                attrs.height = win.mAttrs.height;
            }
            flagChanges = win.mAttrs.flags ^= attrs.flags;
            attrChanges = win.mAttrs.copyFrom(attrs);
            if ((attrChanges & (WindowManager.LayoutParams.LAYOUT_CHANGED | WindowManager.LayoutParams.SYSTEM_UI_VISIBILITY_CHANGED)) != 0) {
                win.mLayoutNeeded = true;
            }
            if (win.mAppToken != null && ((flagChanges & FLAG_SHOW_WHEN_LOCKED) != 0 || (flagChanges & FLAG_DISMISS_KEYGUARD) != 0)) {
                win.mAppToken.checkKeyguardFlagsChanged();
            }
            if (((attrChanges & LayoutParams.ACCESSIBILITY_TITLE_CHANGED) != 0) && (mAccessibilityController != null) && (win.getDisplayId() == DEFAULT_DISPLAY)) {
                // No move or resize, but the controller checks for title changes as well
                mAccessibilityController.onSomeWindowResizedOrMovedLocked();
            }
            if ((flagChanges & PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS) != 0) {
                updateNonSystemOverlayWindowsVisibilityIfNeeded(win, win.mWinAnimator.getShown());
            }
        }
        if (DEBUG_LAYOUT)
            Slog.v(TAG_WM, "Relayout " + win + ": viewVisibility=" + viewVisibility + " req=" + requestedWidth + "x" + requestedHeight + " " + win.mAttrs);
        winAnimator.mSurfaceDestroyDeferred = (flags & RELAYOUT_DEFER_SURFACE_DESTROY) != 0;
        win.mEnforceSizeCompat = (win.mAttrs.privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0;
        if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
            winAnimator.mAlpha = attrs.alpha;
        }
        win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);
        if (win.mAttrs.surfaceInsets.left != 0 || win.mAttrs.surfaceInsets.top != 0 || win.mAttrs.surfaceInsets.right != 0 || win.mAttrs.surfaceInsets.bottom != 0) {
            winAnimator.setOpaqueLocked(false);
        }
        final int oldVisibility = win.mViewVisibility;
        // If the window is becoming visible, visibleOrAdding may change which may in turn
        // change the IME target.
        final boolean becameVisible = (oldVisibility == View.INVISIBLE || oldVisibility == View.GONE) && viewVisibility == View.VISIBLE;
        boolean imMayMove = (flagChanges & (FLAG_ALT_FOCUSABLE_IM | FLAG_NOT_FOCUSABLE)) != 0 || becameVisible;
        final boolean isDefaultDisplay = win.isDefaultDisplay();
        boolean focusMayChange = isDefaultDisplay && (win.mViewVisibility != viewVisibility || ((flagChanges & FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled));
        boolean wallpaperMayMove = win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
        wallpaperMayMove |= (flagChanges & FLAG_SHOW_WALLPAPER) != 0;
        if ((flagChanges & FLAG_SECURE) != 0 && winAnimator.mSurfaceController != null) {
            winAnimator.mSurfaceController.setSecure(isSecureLocked(win));
        }
        win.mRelayoutCalled = true;
        win.mInRelayout = true;
        win.mViewVisibility = viewVisibility;
        if (DEBUG_SCREEN_ON) {
            RuntimeException stack = new RuntimeException();
            stack.fillInStackTrace();
            Slog.i(TAG_WM, "Relayout " + win + ": oldVis=" + oldVisibility + " newVis=" + viewVisibility, stack);
        }
        win.setDisplayLayoutNeeded();
        win.mGivenInsetsPending = (flags & WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;
        // We should only relayout if the view is visible, it is a starting window, or the
        // associated appToken is not hidden.
        final boolean shouldRelayout = viewVisibility == View.VISIBLE && (win.mAppToken == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || !win.mAppToken.isClientHidden());
        // This must be called before the call to performSurfacePlacement.
        if (!shouldRelayout && winAnimator.hasSurface() && !win.mAnimatingExit) {
            if (DEBUG_VISIBILITY) {
                Slog.i(TAG_WM, "Relayout invis " + win + ": mAnimatingExit=" + win.mAnimatingExit);
            }
            result |= RELAYOUT_RES_SURFACE_CHANGED;
            if (!win.mWillReplaceWindow) {
                focusMayChange = tryStartExitingAnimation(win, winAnimator, isDefaultDisplay, focusMayChange);
            }
        }
        // We may be deferring layout passes at the moment, but since the client is interested
        // in the new out values right now we need to force a layout.
        mWindowPlacerLocked.performSurfacePlacement(true);
        if (shouldRelayout) {
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: viewVisibility_1");
            result = win.relayoutVisibleWindow(result, attrChanges, oldVisibility);
            try {
                result = createSurfaceControl(outSurface, result, win, winAnimator);
            } catch (Exception e) {
                mInputMonitor.updateInputWindowsLw(true);
                Slog.w(TAG_WM, "Exception thrown when creating surface for client " + client + " (" + win.mAttrs.getTitle() + ")", e);
                Binder.restoreCallingIdentity(origId);
                return 0;
            }
            if ((result & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                focusMayChange = isDefaultDisplay;
            }
            if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
                setInputMethodWindowLocked(win);
                imMayMove = true;
            }
            win.adjustStartingWindowFlags();
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        } else {
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: viewVisibility_2");
            winAnimator.mEnterAnimationPending = false;
            winAnimator.mEnteringAnimation = false;
            if (viewVisibility == View.VISIBLE && winAnimator.hasSurface()) {
                // We already told the client to go invisible, but the message may not be
                // handled yet, or it might want to draw a last frame. If we already have a
                // surface, let the client use that, but don't create new surface at this point.
                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: getSurface");
                winAnimator.mSurfaceController.getSurface(outSurface);
                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            } else {
                if (DEBUG_VISIBILITY)
                    Slog.i(TAG_WM, "Releasing surface in: " + win);
                try {
                    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "wmReleaseOutSurface_" + win.mAttrs.getTitle());
                    outSurface.release();
                } finally {
                    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
                }
            }
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        }
        if (focusMayChange) {
            // System.out.println("Focus may change: " + win.mAttrs.getTitle());
            if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false)) {
                imMayMove = false;
            }
        // System.out.println("Relayout " + win + ": focus=" + mCurrentFocus);
        }
        // updateFocusedWindowLocked() already assigned layers so we only need to
        // reassign them at this point if the IM window state gets shuffled
        boolean toBeDisplayed = (result & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
        final DisplayContent dc = win.getDisplayContent();
        if (imMayMove) {
            dc.computeImeTarget(true);
            if (toBeDisplayed) {
                // Little hack here -- we -should- be able to rely on the function to return
                // true if the IME has moved and needs its layer recomputed. However, if the IME
                // was hidden and isn't actually moved in the list, its layer may be out of data
                // so we make sure to recompute it.
                dc.assignWindowLayers(false);
            }
        }
        if (wallpaperMayMove) {
            win.getDisplayContent().pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        }
        if (win.mAppToken != null) {
            mUnknownAppVisibilityController.notifyRelayouted(win.mAppToken);
        }
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: updateOrientationFromAppTokens");
        configChanged = updateOrientationFromAppTokensLocked(displayId);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        if (toBeDisplayed && win.mIsWallpaper) {
            DisplayInfo displayInfo = win.getDisplayContent().getDisplayInfo();
            dc.mWallpaperController.updateWallpaperOffset(win, displayInfo.logicalWidth, displayInfo.logicalHeight, false);
        }
        if (win.mAppToken != null) {
            win.mAppToken.updateReportedVisibilityLocked();
        }
        if (winAnimator.mReportSurfaceResized) {
            winAnimator.mReportSurfaceResized = false;
            result |= WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED;
        }
        if (mPolicy.isNavBarForcedShownLw(win)) {
            result |= WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR;
        }
        if (!win.isGoneForLayoutLw()) {
            win.mResizedWhileGone = false;
        }
        // {@link MergedConfiguration}.
        if (shouldRelayout) {
            win.getMergedConfiguration(mergedConfiguration);
        } else {
            win.getLastReportedMergedConfiguration(mergedConfiguration);
        }
        win.setLastReportedMergedConfiguration(mergedConfiguration);
        // Update the last inset values here because the values are sent back to the client.
        // The last inset values represent the last client state.
        win.updateLastInsetValues();
        outFrame.set(win.mCompatFrame);
        outOverscanInsets.set(win.mOverscanInsets);
        outContentInsets.set(win.mContentInsets);
        win.mLastRelayoutContentInsets.set(win.mContentInsets);
        outVisibleInsets.set(win.mVisibleInsets);
        outStableInsets.set(win.mStableInsets);
        outCutout.set(win.mDisplayCutout.getDisplayCutout());
        outOutsets.set(win.mOutsets);
        outBackdropFrame.set(win.getBackdropFrame(win.mFrame));
        if (localLOGV)
            Slog.v(TAG_WM, "Relayout given client " + client.asBinder() + ", requestedWidth=" + requestedWidth + ", requestedHeight=" + requestedHeight + ", viewVisibility=" + viewVisibility + "\nRelayout returning frame=" + outFrame + ", surface=" + outSurface);
        if (localLOGV || DEBUG_FOCUS)
            Slog.v(TAG_WM, "Relayout of " + win + ": focusMayChange=" + focusMayChange);
        result |= mInTouchMode ? WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE : 0;
        mInputMonitor.updateInputWindowsLw(true);
        if (DEBUG_LAYOUT) {
            Slog.v(TAG_WM, "Relayout complete " + win + ": outFrame=" + outFrame.toShortString());
        }
        win.mInRelayout = false;
    }
    if (configChanged) {
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: sendNewConfiguration");
        sendNewConfiguration(displayId);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    }
    Binder.restoreCallingIdentity(origId);
    return result;
}
#method_after
public int relayoutWindow(Session session, IWindow client, int seq, LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, long frameNumber, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration, Surface outSurface) {
    int result = 0;
    boolean configChanged;
    final boolean hasStatusBarPermission = mContext.checkCallingOrSelfPermission(permission.STATUS_BAR) == PackageManager.PERMISSION_GRANTED;
    final boolean hasStatusBarServicePermission = mContext.checkCallingOrSelfPermission(permission.STATUS_BAR_SERVICE) == PackageManager.PERMISSION_GRANTED;
    long origId = Binder.clearCallingIdentity();
    final int displayId;
    synchronized (mWindowMap) {
        WindowState win = windowForClientLocked(session, client, false);
        if (win == null) {
            return 0;
        }
        displayId = win.getDisplayId();
        WindowStateAnimator winAnimator = win.mWinAnimator;
        if (viewVisibility != View.GONE) {
            win.setRequestedSize(requestedWidth, requestedHeight);
        }
        win.setFrameNumber(frameNumber);
        if (win.mPendingForcedSeamlessRotate != null && !mWaitingForConfig) {
            win.mPendingForcedSeamlessRotate.finish(win.mToken, win);
            win.mFinishForcedSeamlessRotateFrameNumber = win.getFrameNumber();
            win.mPendingForcedSeamlessRotate = null;
        }
        int attrChanges = 0;
        int flagChanges = 0;
        if (attrs != null) {
            mPolicy.adjustWindowParamsLw(win, attrs, hasStatusBarServicePermission);
            // if they don't have the permission, mask out the status bar bits
            if (seq == win.mSeq) {
                int systemUiVisibility = attrs.systemUiVisibility | attrs.subtreeSystemUiVisibility;
                if ((systemUiVisibility & DISABLE_MASK) != 0) {
                    if (!hasStatusBarPermission) {
                        systemUiVisibility &= ~DISABLE_MASK;
                    }
                }
                win.mSystemUiVisibility = systemUiVisibility;
            }
            if (win.mAttrs.type != attrs.type) {
                throw new IllegalArgumentException("Window type can not be changed after the window is added.");
            }
            // Odd choice but less odd than embedding in copyFrom()
            if ((attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PRESERVE_GEOMETRY) != 0) {
                attrs.x = win.mAttrs.x;
                attrs.y = win.mAttrs.y;
                attrs.width = win.mAttrs.width;
                attrs.height = win.mAttrs.height;
            }
            flagChanges = win.mAttrs.flags ^= attrs.flags;
            attrChanges = win.mAttrs.copyFrom(attrs);
            if ((attrChanges & (WindowManager.LayoutParams.LAYOUT_CHANGED | WindowManager.LayoutParams.SYSTEM_UI_VISIBILITY_CHANGED)) != 0) {
                win.mLayoutNeeded = true;
            }
            if (win.mAppToken != null && ((flagChanges & FLAG_SHOW_WHEN_LOCKED) != 0 || (flagChanges & FLAG_DISMISS_KEYGUARD) != 0)) {
                win.mAppToken.checkKeyguardFlagsChanged();
            }
            if (((attrChanges & LayoutParams.ACCESSIBILITY_TITLE_CHANGED) != 0) && (mAccessibilityController != null) && (win.getDisplayId() == DEFAULT_DISPLAY)) {
                // No move or resize, but the controller checks for title changes as well
                mAccessibilityController.onSomeWindowResizedOrMovedLocked();
            }
            if ((flagChanges & PRIVATE_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS) != 0) {
                updateNonSystemOverlayWindowsVisibilityIfNeeded(win, win.mWinAnimator.getShown());
            }
        }
        if (DEBUG_LAYOUT)
            Slog.v(TAG_WM, "Relayout " + win + ": viewVisibility=" + viewVisibility + " req=" + requestedWidth + "x" + requestedHeight + " " + win.mAttrs);
        winAnimator.mSurfaceDestroyDeferred = (flags & RELAYOUT_DEFER_SURFACE_DESTROY) != 0;
        win.mEnforceSizeCompat = (win.mAttrs.privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0;
        if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
            winAnimator.mAlpha = attrs.alpha;
        }
        win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);
        if (win.mAttrs.surfaceInsets.left != 0 || win.mAttrs.surfaceInsets.top != 0 || win.mAttrs.surfaceInsets.right != 0 || win.mAttrs.surfaceInsets.bottom != 0) {
            winAnimator.setOpaqueLocked(false);
        }
        final int oldVisibility = win.mViewVisibility;
        // If the window is becoming visible, visibleOrAdding may change which may in turn
        // change the IME target.
        final boolean becameVisible = (oldVisibility == View.INVISIBLE || oldVisibility == View.GONE) && viewVisibility == View.VISIBLE;
        boolean imMayMove = (flagChanges & (FLAG_ALT_FOCUSABLE_IM | FLAG_NOT_FOCUSABLE)) != 0 || becameVisible;
        final boolean isDefaultDisplay = win.isDefaultDisplay();
        boolean focusMayChange = isDefaultDisplay && (win.mViewVisibility != viewVisibility || ((flagChanges & FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled));
        boolean wallpaperMayMove = win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
        wallpaperMayMove |= (flagChanges & FLAG_SHOW_WALLPAPER) != 0;
        if ((flagChanges & FLAG_SECURE) != 0 && winAnimator.mSurfaceController != null) {
            winAnimator.mSurfaceController.setSecure(isSecureLocked(win));
        }
        win.mRelayoutCalled = true;
        win.mInRelayout = true;
        win.mViewVisibility = viewVisibility;
        if (DEBUG_SCREEN_ON) {
            RuntimeException stack = new RuntimeException();
            stack.fillInStackTrace();
            Slog.i(TAG_WM, "Relayout " + win + ": oldVis=" + oldVisibility + " newVis=" + viewVisibility, stack);
        }
        win.setDisplayLayoutNeeded();
        win.mGivenInsetsPending = (flags & WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;
        // We should only relayout if the view is visible, it is a starting window, or the
        // associated appToken is not hidden.
        final boolean shouldRelayout = viewVisibility == View.VISIBLE && (win.mAppToken == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || !win.mAppToken.isClientHidden());
        // This must be called before the call to performSurfacePlacement.
        if (!shouldRelayout && winAnimator.hasSurface() && !win.mAnimatingExit) {
            if (DEBUG_VISIBILITY) {
                Slog.i(TAG_WM, "Relayout invis " + win + ": mAnimatingExit=" + win.mAnimatingExit);
            }
            result |= RELAYOUT_RES_SURFACE_CHANGED;
            if (!win.mWillReplaceWindow) {
                focusMayChange = tryStartExitingAnimation(win, winAnimator, isDefaultDisplay, focusMayChange);
            }
        }
        // We may be deferring layout passes at the moment, but since the client is interested
        // in the new out values right now we need to force a layout.
        mWindowPlacerLocked.performSurfacePlacement(true);
        if (shouldRelayout) {
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: viewVisibility_1");
            result = win.relayoutVisibleWindow(result, attrChanges, oldVisibility);
            try {
                result = createSurfaceControl(outSurface, result, win, winAnimator);
            } catch (Exception e) {
                mInputMonitor.updateInputWindowsLw(true);
                Slog.w(TAG_WM, "Exception thrown when creating surface for client " + client + " (" + win.mAttrs.getTitle() + ")", e);
                Binder.restoreCallingIdentity(origId);
                return 0;
            }
            if ((result & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                focusMayChange = isDefaultDisplay;
            }
            if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
                setInputMethodWindowLocked(win);
                imMayMove = true;
            }
            win.adjustStartingWindowFlags();
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        } else {
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: viewVisibility_2");
            winAnimator.mEnterAnimationPending = false;
            winAnimator.mEnteringAnimation = false;
            if (viewVisibility == View.VISIBLE && winAnimator.hasSurface()) {
                // We already told the client to go invisible, but the message may not be
                // handled yet, or it might want to draw a last frame. If we already have a
                // surface, let the client use that, but don't create new surface at this point.
                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: getSurface");
                winAnimator.mSurfaceController.getSurface(outSurface);
                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            } else {
                if (DEBUG_VISIBILITY)
                    Slog.i(TAG_WM, "Releasing surface in: " + win);
                try {
                    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "wmReleaseOutSurface_" + win.mAttrs.getTitle());
                    outSurface.release();
                } finally {
                    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
                }
            }
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        }
        if (focusMayChange) {
            // System.out.println("Focus may change: " + win.mAttrs.getTitle());
            if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false)) {
                imMayMove = false;
            }
        // System.out.println("Relayout " + win + ": focus=" + mCurrentFocus);
        }
        // updateFocusedWindowLocked() already assigned layers so we only need to
        // reassign them at this point if the IM window state gets shuffled
        boolean toBeDisplayed = (result & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
        final DisplayContent dc = win.getDisplayContent();
        if (imMayMove) {
            dc.computeImeTarget(true);
            if (toBeDisplayed) {
                // Little hack here -- we -should- be able to rely on the function to return
                // true if the IME has moved and needs its layer recomputed. However, if the IME
                // was hidden and isn't actually moved in the list, its layer may be out of data
                // so we make sure to recompute it.
                dc.assignWindowLayers(false);
            }
        }
        if (wallpaperMayMove) {
            win.getDisplayContent().pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        }
        if (win.mAppToken != null) {
            mUnknownAppVisibilityController.notifyRelayouted(win.mAppToken);
        }
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: updateOrientationFromAppTokens");
        configChanged = updateOrientationFromAppTokensLocked(displayId);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        if (toBeDisplayed && win.mIsWallpaper) {
            DisplayInfo displayInfo = win.getDisplayContent().getDisplayInfo();
            dc.mWallpaperController.updateWallpaperOffset(win, displayInfo.logicalWidth, displayInfo.logicalHeight, false);
        }
        if (win.mAppToken != null) {
            win.mAppToken.updateReportedVisibilityLocked();
        }
        if (winAnimator.mReportSurfaceResized) {
            winAnimator.mReportSurfaceResized = false;
            result |= WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED;
        }
        if (mPolicy.isNavBarForcedShownLw(win)) {
            result |= WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR;
        }
        if (!win.isGoneForLayoutLw()) {
            win.mResizedWhileGone = false;
        }
        // {@link MergedConfiguration}.
        if (shouldRelayout) {
            win.getMergedConfiguration(mergedConfiguration);
        } else {
            win.getLastReportedMergedConfiguration(mergedConfiguration);
        }
        win.setLastReportedMergedConfiguration(mergedConfiguration);
        // Update the last inset values here because the values are sent back to the client.
        // The last inset values represent the last client state.
        win.updateLastInsetValues();
        outFrame.set(win.mCompatFrame);
        outOverscanInsets.set(win.mOverscanInsets);
        outContentInsets.set(win.mContentInsets);
        win.mLastRelayoutContentInsets.set(win.mContentInsets);
        outVisibleInsets.set(win.mVisibleInsets);
        outStableInsets.set(win.mStableInsets);
        outCutout.set(win.mDisplayCutout.getDisplayCutout());
        outOutsets.set(win.mOutsets);
        outBackdropFrame.set(win.getBackdropFrame(win.mFrame));
        if (localLOGV)
            Slog.v(TAG_WM, "Relayout given client " + client.asBinder() + ", requestedWidth=" + requestedWidth + ", requestedHeight=" + requestedHeight + ", viewVisibility=" + viewVisibility + "\nRelayout returning frame=" + outFrame + ", surface=" + outSurface);
        if (localLOGV || DEBUG_FOCUS)
            Slog.v(TAG_WM, "Relayout of " + win + ": focusMayChange=" + focusMayChange);
        result |= mInTouchMode ? WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE : 0;
        mInputMonitor.updateInputWindowsLw(true);
        if (DEBUG_LAYOUT) {
            Slog.v(TAG_WM, "Relayout complete " + win + ": outFrame=" + outFrame.toShortString());
        }
        win.mInRelayout = false;
    }
    if (configChanged) {
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "relayoutWindow: sendNewConfiguration");
        sendNewConfiguration(displayId);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    }
    Binder.restoreCallingIdentity(origId);
    return result;
}
#end_block

#method_before
void setPrimaryClipInternal(PerUserClipboard clipboard, ClipData clip) {
    clipboard.activePermissionOwners.clear();
    if (clip == null && clipboard.primaryClip == null) {
        return;
    }
    clipboard.primaryClip = clip;
    if (clip != null) {
        final ClipDescription description = clip.getDescription();
        if (description != null) {
            description.setTimestamp(System.currentTimeMillis());
        }
    }
    final long ident = Binder.clearCallingIdentity();
    final int n = clipboard.primaryClipListeners.beginBroadcast();
    try {
        for (int i = 0; i < n; i++) {
            try {
                ListenerInfo li = (ListenerInfo) clipboard.primaryClipListeners.getBroadcastCookie(i);
                if (clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, li.mPackageName, li.mUid, APPOP_NOTHR)) {
                    clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
                }
            } catch (RemoteException e) {
            // The RemoteCallbackList will take care of removing
            // the dead object for us.
            }
        }
    } finally {
        clipboard.primaryClipListeners.finishBroadcast();
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
void setPrimaryClipInternal(PerUserClipboard clipboard, ClipData clip) {
    clipboard.activePermissionOwners.clear();
    if (clip == null && clipboard.primaryClip == null) {
        return;
    }
    clipboard.primaryClip = clip;
    if (clip != null) {
        final ClipDescription description = clip.getDescription();
        if (description != null) {
            description.setTimestamp(System.currentTimeMillis());
        }
    }
    final long ident = Binder.clearCallingIdentity();
    final int n = clipboard.primaryClipListeners.beginBroadcast();
    try {
        for (int i = 0; i < n; i++) {
            try {
                ListenerInfo li = (ListenerInfo) clipboard.primaryClipListeners.getBroadcastCookie(i);
                if (clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, li.mPackageName, li.mUid, APPOP_NOTHROW)) {
                    clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
                }
            } catch (RemoteException e) {
            // The RemoteCallbackList will take care of removing
            // the dead object for us.
            }
        }
    } finally {
        clipboard.primaryClipListeners.finishBroadcast();
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
private boolean clipboardAccessAllowed(int op, String callingPackage, int callingUid, int AppOpMeth) {
    int checkAppOp = AppOpsManager.MODE_ALLOWED;
    // Check the AppOp. depending on specified method
    switch(AppOpMeth) {
        case APPOP_NOTE:
            checkAppOp = mAppOps.noteOp(op, callingUid, callingPackage);
        case APPOP_NOTHR:
            checkAppOp = mAppOps.checkOpNoThrow(op, callingUid, callingPackage);
        default:
            checkAppOp = mAppOps.checkOp(op, callingUid, callingPackage);
    }
    if (checkAppOp != AppOpsManager.MODE_ALLOWED) {
        return false;
    }
    try {
        // Installed apps can access the clipboard at any time.
        if (!AppGlobals.getPackageManager().isInstantApp(callingPackage, UserHandle.getUserId(callingUid))) {
            return true;
        }
        // Instant apps can only access the clipboard if they are in the foreground.
        return mAm.isAppForeground(callingUid);
    } catch (RemoteException e) {
        Slog.e("clipboard", "Failed to get Instant App status for package " + callingPackage, e);
        return false;
    }
}
#method_after
private boolean clipboardAccessAllowed(int op, String callingPackage, int callingUid, int appOpMethod) {
    int appOpResult;
    // Check the AppOp depending on specified method
    switch(appOpMethod) {
        case APPOP_NOTE:
            appOpResult = mAppOps.noteOp(op, callingUid, callingPackage);
            break;
        case APPOP_NOTHROW:
            appOpResult = mAppOps.checkOpNoThrow(op, callingUid, callingPackage);
            break;
        default:
            appOpResult = mAppOps.checkOp(op, callingUid, callingPackage);
            break;
    }
    if (appOpResult != AppOpsManager.MODE_ALLOWED) {
        return false;
    }
    try {
        // Installed apps can access the clipboard at any time.
        if (!AppGlobals.getPackageManager().isInstantApp(callingPackage, UserHandle.getUserId(callingUid))) {
            return true;
        }
        // Instant apps can only access the clipboard if they are in the foreground.
        return mAm.isAppForeground(callingUid);
    } catch (RemoteException e) {
        Slog.e("clipboard", "Failed to get Instant App status for package " + callingPackage, e);
        return false;
    }
}
#end_block

#method_before
private void doFingerprintCleanupForUser(int userId) {
    if (SystemProperties.getBoolean("ro.fingerprint.cleanup.unused", CLEANUP_UNUSED_FP)) {
        enumerateUser(userId);
    }
}
#method_after
private void doFingerprintCleanupForUser(int userId) {
    if (mCleanupUnusedFingerprints) {
        enumerateUser(userId);
    }
}
#end_block

#method_before
@Override
public void onRecordLoaded(AsyncResult ar) {
    byte[] data = (byte[]) ar.result;
    if (data == null || data.length < 10) {
        log("Invalid IMSI from EF_CSIM_IMSIM " + IccUtils.bytesToHexString(data));
        mImsi = null;
        mMin = null;
        return;
    }
    if (DBG)
        log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
    // C.S0065 section 5.2.2 for IMSI_M encoding
    // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
    boolean provisioned = ((data[7] & 0x80) == 0x80);
    if (provisioned) {
        mImsi = decodeImsi(data);
        if (null != mImsi) {
            mMin = mImsi.substring(5, 15);
        }
        log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
    } else {
        if (DBG)
            log("IMSI not provisioned in card");
    }
    // Update MccTable with the retrieved IMSI
    String operatorNumeric = getOperatorNumeric();
    if (operatorNumeric != null) {
        if (operatorNumeric.length() <= 6) {
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
        }
    }
    mImsiReadyRegistrants.notifyRegistrants();
}
#method_after
@Override
public void onRecordLoaded(AsyncResult ar) {
    byte[] data = (byte[]) ar.result;
    if (data == null || data.length < 10) {
        log("Invalid IMSI from EF_CSIM_IMSIM " + IccUtils.bytesToHexString(data));
        mImsi = null;
        mMin = null;
        return;
    }
    if (VDBG)
        log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
    // C.S0065 section 5.2.2 for IMSI_M encoding
    // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
    boolean provisioned = ((data[7] & 0x80) == 0x80);
    if (provisioned) {
        mImsi = decodeImsi(data);
        if (null != mImsi) {
            mMin = mImsi.substring(5, 15);
        }
        if (DBG)
            log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
    } else {
        if (DBG)
            log("IMSI not provisioned in card");
    }
    // Update MccTable with the retrieved IMSI
    String operatorNumeric = getOperatorNumeric();
    if (operatorNumeric != null) {
        if (operatorNumeric.length() <= 6) {
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
        }
    }
    mImsiReadyRegistrants.notifyRegistrants();
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.CAMERA_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.CAMERA_SLEEP_ON_RELEASE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.CAMERA_LAUNCH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.HOME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.BACK_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.MENU_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ASSIST_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.APP_SWITCH_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.VOLUME_ANSWER_CALL), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.CAMERA_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.CAMERA_SLEEP_ON_RELEASE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.CAMERA_LAUNCH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.HOME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.BACK_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.MENU_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ASSIST_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.APP_SWITCH_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.VOLUME_ANSWER_CALL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.KILL_APP_LONGPRESS_BACK), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
private void cancelPendingPowerKeyAction() {
    if (!mPowerKeyHandled) {
        mPowerKeyHandled = true;
        mHandler.removeMessages(MSG_POWER_LONG_PRESS);
        // See if we deferred screen wake because long press power for torch is enabled
        if (mResolvedLongPressOnPowerBehavior == LONG_PRESS_POWER_TORCH && !isScreenOn()) {
            wakeUpFromPowerKey(SystemClock.uptimeMillis());
        }
    }
    if (hasVeryLongPressOnPowerBehavior()) {
        mHandler.removeMessages(MSG_POWER_VERY_LONG_PRESS);
    }
}
#method_after
private void cancelPendingPowerKeyAction() {
    if (!mPowerKeyHandled) {
        mPowerKeyHandled = true;
        mHandler.removeMessages(MSG_POWER_LONG_PRESS);
        // See if we deferred screen wake because long press power for torch is enabled
        if (mResolvedLongPressOnPowerBehavior == LONG_PRESS_POWER_TORCH && (!isScreenOn() || isDozeMode())) {
            wakeUpFromPowerKey(SystemClock.uptimeMillis());
        }
    }
    if (hasVeryLongPressOnPowerBehavior()) {
        mHandler.removeMessages(MSG_POWER_VERY_LONG_PRESS);
    }
}
#end_block

#method_before
private int getResolvedLongPressOnPowerBehavior() {
    if (FactoryTest.isLongPressOnPowerOffEnabled()) {
        return LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;
    }
    if (mTorchLongPressPowerEnabled && !isScreenOn()) {
        return LONG_PRESS_POWER_TORCH;
    }
    return mLongPressOnPowerBehavior;
}
#method_after
private int getResolvedLongPressOnPowerBehavior() {
    if (FactoryTest.isLongPressOnPowerOffEnabled()) {
        return LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;
    }
    if (mTorchLongPressPowerEnabled && (!isScreenOn() || isDozeMode())) {
        return LONG_PRESS_POWER_TORCH;
    }
    return mLongPressOnPowerBehavior;
}
#end_block

#method_before
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case LAST_APP:
            ActionUtils.switchToLastApp(mContext);
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#method_after
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case LAST_APP:
            ActionUtils.switchToLastApp(mContext, mCurrentUserId);
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mLogger = new MetricsLogger();
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
    mCameraManager.registerTorchCallback(new TorchModeCallback(), mHandler);
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mVeryLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mVeryLongPressTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressTimeout);
    mAllowStartActivityForLongPressOnPowerDuringSetup = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowStartActivityForLongPressOnPowerInSetup);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    mDeviceHardwareKeys = mContext.getResources().getInteger(org.lineageos.platform.internal.R.integer.config_deviceHardwareKeys);
    updateKeyAssignments();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    // TODO(multi-display): Needs to be display specific.
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, long duration, long statusBarAnimationStartTime, long statusBarAnimationDuration) {
            return handleStartTransitionForKeyguardLw(transit, duration);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, 0);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }

        @Override
        public void onShowingChanged() {
            mWindowManagerFuncs.onKeyguardShowingAndNotOccludedChanged();
        }
    });
    mScreenshotHelper = new ScreenshotHelper(mContext);
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
    // Register for torch off events
    BroadcastReceiver torchReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mTorchOffPendingIntent = null;
            if (mTorchEnabled) {
                mHandler.removeMessages(MSG_TOGGLE_TORCH);
                Message msg = mHandler.obtainMessage(MSG_TOGGLE_TORCH);
                msg.setAsynchronous(true);
                msg.sendToTarget();
            }
        }
    };
    filter = new IntentFilter();
    filter.addAction(ACTION_TORCH_OFF);
    context.registerReceiver(torchReceiver, filter);
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mLogger = new MetricsLogger();
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
    mCameraManager.registerTorchCallback(new TorchModeCallback(), mHandler);
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mVeryLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mVeryLongPressTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressTimeout);
    mAllowStartActivityForLongPressOnPowerDuringSetup = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowStartActivityForLongPressOnPowerInSetup);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    mDeviceHardwareKeys = mContext.getResources().getInteger(org.lineageos.platform.internal.R.integer.config_deviceHardwareKeys);
    mBackKillTimeout = mContext.getResources().getInteger(org.lineageos.platform.internal.R.integer.config_backKillTimeout);
    updateKeyAssignments();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    // TODO(multi-display): Needs to be display specific.
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, long duration, long statusBarAnimationStartTime, long statusBarAnimationDuration) {
            return handleStartTransitionForKeyguardLw(transit, duration);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, 0);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }

        @Override
        public void onShowingChanged() {
            mWindowManagerFuncs.onKeyguardShowingAndNotOccludedChanged();
        }
    });
    mScreenshotHelper = new ScreenshotHelper(mContext);
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
    // Register for torch off events
    BroadcastReceiver torchReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mTorchOffPendingIntent = null;
            if (mTorchEnabled) {
                mHandler.removeMessages(MSG_TOGGLE_TORCH);
                Message msg = mHandler.obtainMessage(MSG_TOGGLE_TORCH);
                msg.setAsynchronous(true);
                msg.sendToTarget();
            }
        }
    };
    filter = new IntentFilter();
    filter.addAction(ACTION_TORCH_OFF);
    context.registerReceiver(torchReceiver, filter);
}
#end_block

#method_before
private void updateKeyAssignments() {
    int activeHardwareKeys = mDeviceHardwareKeys;
    if (mDevForceNavbar == 1) {
        activeHardwareKeys = 0;
    }
    final boolean hasMenu = (activeHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (activeHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (activeHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    // Initialize all assignments to sane defaults.
    mMenuPressAction = Action.MENU;
    mMenuLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnMenuBehavior));
    if (mMenuLongPressAction == Action.NOTHING && (hasMenu && !hasAssist)) {
        mMenuLongPressAction = Action.SEARCH;
    }
    mAssistPressAction = Action.SEARCH;
    mAssistLongPressAction = Action.VOICE_SEARCH;
    mAppSwitchPressAction = Action.APP_SWITCH;
    mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
    mHomeLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
    if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeLongPressAction = Action.NOTHING;
    }
    mHomeDoubleTapAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_doubleTapOnHomeBehavior));
    if (mHomeDoubleTapAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeDoubleTapAction = Action.NOTHING;
    }
    mHomeLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION, mHomeLongPressAction);
    mHomeDoubleTapAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION, mHomeDoubleTapAction);
    if (hasMenu) {
        mMenuPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_ACTION, mMenuPressAction);
        mMenuLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION, mMenuLongPressAction);
    }
    if (hasAssist) {
        mAssistPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_ACTION, mAssistPressAction);
        mAssistLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION, mAssistLongPressAction);
    }
    if (hasAppSwitch) {
        mAppSwitchPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_ACTION, mAppSwitchPressAction);
        mAppSwitchLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mAppSwitchLongPressAction);
    }
    mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
}
#method_after
private void updateKeyAssignments() {
    int activeHardwareKeys = mDeviceHardwareKeys;
    if (mForceNavbar == 1) {
        activeHardwareKeys = 0;
    }
    final boolean hasMenu = (activeHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (activeHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (activeHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    // Initialize all assignments to sane defaults.
    mMenuPressAction = Action.MENU;
    mMenuLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnMenuBehavior));
    if (mMenuLongPressAction == Action.NOTHING && (hasMenu && !hasAssist)) {
        mMenuLongPressAction = Action.SEARCH;
    }
    mAssistPressAction = Action.SEARCH;
    mAssistLongPressAction = Action.VOICE_SEARCH;
    mAppSwitchPressAction = Action.APP_SWITCH;
    mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
    mHomeLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
    if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeLongPressAction = Action.NOTHING;
    }
    mHomeDoubleTapAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_doubleTapOnHomeBehavior));
    if (mHomeDoubleTapAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeDoubleTapAction = Action.NOTHING;
    }
    mHomeLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION, mHomeLongPressAction);
    mHomeDoubleTapAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION, mHomeDoubleTapAction);
    if (hasMenu) {
        mMenuPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_ACTION, mMenuPressAction);
        mMenuLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION, mMenuLongPressAction);
    }
    if (hasAssist) {
        mAssistPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_ACTION, mAssistPressAction);
        mAssistLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION, mAssistLongPressAction);
    }
    if (hasAppSwitch) {
        mAppSwitchPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_ACTION, mAppSwitchPressAction);
    }
    mAppSwitchLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mAppSwitchLongPressAction);
    mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
}
#end_block

#method_before
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#method_after
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    mNeedsNavigationBar = mHasNavigationBar;
    mHasNavigationBar |= mForceNavbar == 1;
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#method_after
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    int mDeviceHardwareWakeKeys = mContext.getResources().getInteger(org.lineageos.platform.internal.R.integer.config_deviceHardwareWakeKeys);
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mRingHomeBehavior = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR, LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        mHomeWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_HOME) != 0);
        mBackWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.BACK_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_BACK) != 0);
        mMenuWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.MENU_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_MENU) != 0);
        mAssistWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.ASSIST_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_ASSIST) != 0);
        mAppSwitchWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.APP_SWITCH_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_APP_SWITCH) != 0);
        mVolumeWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mVolumeAnswerCall = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.VOLUME_ANSWER_CALL, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mCameraWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.CAMERA_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_CAMERA) != 0);
        mCameraSleepOnRelease = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.CAMERA_SLEEP_ON_RELEASE, 0, UserHandle.USER_CURRENT) == 1;
        mCameraLaunch = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.CAMERA_LAUNCH, 0, UserHandle.USER_CURRENT) == 1;
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar == 1);
            }
        }
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    int mDeviceHardwareWakeKeys = mContext.getResources().getInteger(org.lineageos.platform.internal.R.integer.config_deviceHardwareWakeKeys);
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mRingHomeBehavior = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR, LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        mHomeWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_HOME) != 0);
        mBackWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.BACK_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_BACK) != 0);
        mMenuWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.MENU_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_MENU) != 0);
        mAssistWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.ASSIST_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_ASSIST) != 0);
        mAppSwitchWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.APP_SWITCH_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_APP_SWITCH) != 0);
        mVolumeWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mVolumeAnswerCall = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.VOLUME_ANSWER_CALL, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mKillAppLongpressBack = LineageSettings.Secure.getInt(resolver, LineageSettings.Secure.KILL_APP_LONGPRESS_BACK, 0) == 1;
        mCameraWakeScreen = (LineageSettings.System.getIntForUser(resolver, LineageSettings.System.CAMERA_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_CAMERA) != 0);
        mCameraSleepOnRelease = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.CAMERA_SLEEP_ON_RELEASE, 0, UserHandle.USER_CURRENT) == 1;
        mCameraLaunch = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.CAMERA_LAUNCH, 0, UserHandle.USER_CURRENT) == 1;
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int forceNavbar = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (forceNavbar != mForceNavbar) {
            mForceNavbar = forceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mForceNavbar == 1);
            }
            mHasNavigationBar = mNeedsNavigationBar || mForceNavbar == 1;
        }
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // know if it is complete or not
    if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false) && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered ^ mA11yShortcutChordVolumeUpKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = (mScreenshotChordVolumeDownKeyTriggered ? mScreenshotChordVolumeDownKeyTime : mA11yShortcutChordVolumeUpKeyTime) + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // to wait a little while and try again later before dispatching.
    if (mRingerToggleChord != VOLUME_HUSH_OFF && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mA11yShortcutChordVolumeUpKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mA11yShortcutChordVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            if (mHomeDoubleTapAction != Action.APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            if ((mRingHomeBehavior & LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER) != 0) {
                final TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null && telecomManager.isRinging()) {
                    telecomManager.acceptRingingCall();
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            if (mHomeDoubleTapAction != Action.NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                performKeyAction(mHomeDoubleTapAction, event);
                if (mHomeDoubleTapAction != Action.SLEEP) {
                    mHomeConsumed = true;
                }
            } else if (mHomeLongPressAction == Action.APP_SWITCH || mHomeDoubleTapAction == Action.APP_SWITCH) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!keyguardOn && !mHomeConsumed && mHomeLongPressAction != Action.NOTHING) {
                if (mHomeLongPressAction != Action.APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                mHomePressed = true;
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                performKeyAction(mHomeLongPressAction, event);
                if (mHomeLongPressAction != Action.SLEEP) {
                    mHomeConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (virtualKey || keyguardOn) {
            // Let the app handle the key
            return 0;
        }
        if (down) {
            if (mMenuPressAction == Action.APP_SWITCH || mMenuLongPressAction == Action.APP_SWITCH) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mMenuPressed = true;
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                    return -1;
                }
            } else if (longPress) {
                if (!keyguardOn && mMenuLongPressAction != Action.NOTHING) {
                    if (mMenuLongPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mMenuLongPressAction, event);
                    mMenuPressed = false;
                    return -1;
                }
            }
        }
        if (!down && mMenuPressed) {
            if (mMenuPressAction != Action.APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            mMenuPressed = false;
            if (!canceled) {
                performKeyAction(mMenuPressAction, event);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down) {
                if (mAppSwitchPressAction == Action.APP_SWITCH || mAppSwitchLongPressAction == Action.APP_SWITCH) {
                    preloadRecentApps();
                }
                if (repeatCount == 0) {
                    mAppSwitchLongPressed = false;
                } else if (longPress) {
                    if (!keyguardOn && mAppSwitchLongPressAction != Action.NOTHING) {
                        if (mAppSwitchLongPressAction != Action.APP_SWITCH) {
                            cancelPreloadRecentApps();
                        }
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mAppSwitchLongPressAction, event);
                        mAppSwitchLongPressed = true;
                    }
                }
            } else {
                if (mAppSwitchLongPressed) {
                    mAppSwitchLongPressed = false;
                } else {
                    if (mAppSwitchPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    if (!canceled) {
                        performKeyAction(mAppSwitchPressAction, event);
                    }
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        Slog.wtf(TAG, "KEYCODE_ASSIST should be handled in interceptKeyBeforeQueueing");
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        Slog.wtf(TAG, "KEYCODE_VOICE_ASSIST should be handled in interceptKeyBeforeQueueing");
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting || mHandleVolumeKeysInWM) {
            // On TVs or when the configuration is enabled, volume keys never
            // go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
        // the audio event.
        if (mPersistentVrModeEnabled) {
            final InputDevice d = event.getDevice();
            if (d != null && !d.isExternal()) {
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_TAB && event.isMetaPressed()) {
        // Pass through keyboard navigation keys.
        return 0;
    } else if (mHasFeatureLeanback && interceptBugreportGestureTv(keyCode, down)) {
        return -1;
    } else if (mHasFeatureLeanback && interceptAccessibilityGestureTv(keyCode, down)) {
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ALL_APPS) {
        if (!down) {
            mHandler.removeMessages(MSG_HANDLE_ALL_APPS);
            Message msg = mHandler.obtainMessage(MSG_HANDLE_ALL_APPS);
            msg.setAsynchronous(true);
            msg.sendToTarget();
        }
        return -1;
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // TODO: Deprecate this behavior when we fully migrate to IME subtype-based layout rotation.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_SPACE && ((metaState & KeyEvent.META_CTRL_MASK) != 0)) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // know if it is complete or not
    if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false) && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered ^ mA11yShortcutChordVolumeUpKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = (mScreenshotChordVolumeDownKeyTriggered ? mScreenshotChordVolumeDownKeyTime : mA11yShortcutChordVolumeUpKeyTime) + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // to wait a little while and try again later before dispatching.
    if (mRingerToggleChord != VOLUME_HUSH_OFF && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mA11yShortcutChordVolumeUpKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mA11yShortcutChordVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
        mHandler.removeCallbacks(mBackLongPress);
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            if (mHomeDoubleTapAction != Action.APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            if ((mRingHomeBehavior & LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER) != 0) {
                final TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null && telecomManager.isRinging()) {
                    telecomManager.acceptRingingCall();
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            if (mHomeDoubleTapAction != Action.NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                performKeyAction(mHomeDoubleTapAction, event);
                if (mHomeDoubleTapAction != Action.SLEEP) {
                    mHomeConsumed = true;
                }
            } else if (mHomeLongPressAction == Action.APP_SWITCH || mHomeDoubleTapAction == Action.APP_SWITCH) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!keyguardOn && !mHomeConsumed && mHomeLongPressAction != Action.NOTHING) {
                if (mHomeLongPressAction != Action.APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                mHomePressed = true;
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                performKeyAction(mHomeLongPressAction, event);
                if (mHomeLongPressAction != Action.SLEEP) {
                    mHomeConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (virtualKey || keyguardOn) {
            // Let the app handle the key
            return 0;
        }
        if (down) {
            if (mMenuPressAction == Action.APP_SWITCH || mMenuLongPressAction == Action.APP_SWITCH) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mMenuPressed = true;
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                    return -1;
                }
            } else if (longPress) {
                if (!keyguardOn && mMenuLongPressAction != Action.NOTHING) {
                    if (mMenuLongPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mMenuLongPressAction, event);
                    mMenuPressed = false;
                    return -1;
                }
            }
        }
        if (!down && mMenuPressed) {
            if (mMenuPressAction != Action.APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            mMenuPressed = false;
            if (!canceled) {
                performKeyAction(mMenuPressAction, event);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down) {
                if (mAppSwitchPressAction == Action.APP_SWITCH || mAppSwitchLongPressAction == Action.APP_SWITCH) {
                    preloadRecentApps();
                }
                if (repeatCount == 0) {
                    mAppSwitchLongPressed = false;
                } else if (longPress) {
                    if (!keyguardOn && mAppSwitchLongPressAction != Action.NOTHING) {
                        if (mAppSwitchLongPressAction != Action.APP_SWITCH) {
                            cancelPreloadRecentApps();
                        }
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mAppSwitchLongPressAction, event);
                        mAppSwitchLongPressed = true;
                    }
                }
            } else {
                if (mAppSwitchLongPressed) {
                    mAppSwitchLongPressed = false;
                } else {
                    if (mAppSwitchPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    if (!canceled) {
                        performKeyAction(mAppSwitchPressAction, event);
                    }
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        Slog.wtf(TAG, "KEYCODE_ASSIST should be handled in interceptKeyBeforeQueueing");
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        Slog.wtf(TAG, "KEYCODE_VOICE_ASSIST should be handled in interceptKeyBeforeQueueing");
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting || mHandleVolumeKeysInWM) {
            // On TVs or when the configuration is enabled, volume keys never
            // go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
        // the audio event.
        if (mPersistentVrModeEnabled) {
            final InputDevice d = event.getDevice();
            if (d != null && !d.isExternal()) {
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_TAB && event.isMetaPressed()) {
        // Pass through keyboard navigation keys.
        return 0;
    } else if (mHasFeatureLeanback && interceptBugreportGestureTv(keyCode, down)) {
        return -1;
    } else if (mHasFeatureLeanback && interceptAccessibilityGestureTv(keyCode, down)) {
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ALL_APPS) {
        if (!down) {
            mHandler.removeMessages(MSG_HANDLE_ALL_APPS);
            Message msg = mHandler.obtainMessage(MSG_HANDLE_ALL_APPS);
            msg.setAsynchronous(true);
            msg.sendToTarget();
        }
        return -1;
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (mKillAppLongpressBack || unpinActivity(true)) {
            if (down && repeatCount == 0) {
                mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // TODO: Deprecate this behavior when we fully migrate to IME subtype-based layout rotation.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_SPACE && ((metaState & KeyEvent.META_CTRL_MASK) != 0)) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive, unless the user has explicitly disabled this wake key.
        result = ACTION_PASS_TO_USER;
        isWakeKey = isWakeKey && isWakeKeyEnabled(keyCode);
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // This disables volume control, music control, and "beep" on key up.
                if (isWakeKey && mVolumeWakeScreen) {
                    setVolumeWakeTriggered(keyCode, true);
                    break;
                } else if (getVolumeWakeTriggered(keyCode) && !down) {
                    result &= ~ACTION_PASS_TO_USER;
                    setVolumeWakeTriggered(keyCode, false);
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            if (mVolumeAnswerCall) {
                                telecomManager.acceptRingingCall();
                            }
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mLineageButtons.handleVolumeKey(event, interactive))
                    break;
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0 && !mVolumeWakeScreen) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_HOME:
            if (down && !interactive) {
                isWakeKey = mHomeWakeScreen;
                if (!isWakeKey) {
                    useHapticFeedback = false;
                }
            }
            break;
        case KeyEvent.KEYCODE_FOCUS:
            if (down && !interactive && mCameraSleepOnRelease) {
                mIsFocusPressed = true;
            } else if ((event.getAction() == KeyEvent.ACTION_UP) && mScreenOnFully && mIsFocusPressed) {
                // Check if screen is fully on before letting the device go to sleep
                mPowerManager.goToSleep(SystemClock.uptimeMillis());
                mIsFocusPressed = false;
            }
            break;
        case KeyEvent.KEYCODE_CAMERA:
            if (down && mIsFocusPressed) {
                mIsFocusPressed = false;
            }
            if (down) {
                mIsLongPress = false;
                KeyEvent newEvent = new KeyEvent(event.getDownTime(), event.getEventTime(), event.getAction(), keyCode, 0);
                Message msg = mHandler.obtainMessage(MSG_CAMERA_LONG_PRESS, newEvent);
                msg.setAsynchronous(true);
                mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
                // Consume key down events of all presses.
                break;
            } else {
                mHandler.removeMessages(MSG_CAMERA_LONG_PRESS);
                // Consume key up events of long presses only.
                if (mIsLongPress && mCameraLaunch) {
                    Intent intent;
                    if (keyguardActive) {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE);
                    } else {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);
                    }
                    isWakeKey = true;
                    startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if (mTopFullscreenOpaqueWindowState != null && (mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && (mAssistPressAction == Action.APP_SWITCH || mAssistLongPressAction == Action.APP_SWITCH)) {
                    preloadRecentApps();
                }
                if (down && longPressed) {
                    if (!keyguardOn() && mAssistLongPressAction != Action.NOTHING) {
                        if (mAssistLongPressAction != Action.APP_SWITCH) {
                            cancelPreloadRecentApps();
                        }
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mAssistLongPressAction, event);
                    }
                }
                if (!down && !longPressed) {
                    if (mAssistPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    if (!canceled) {
                        performKeyAction(mAssistPressAction, event);
                    }
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive, unless the user has explicitly disabled this wake key.
        result = ACTION_PASS_TO_USER;
        isWakeKey = isWakeKey && isWakeKeyEnabled(keyCode);
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // This disables volume control, music control, and "beep" on key up.
                if (isWakeKey && mVolumeWakeScreen) {
                    setVolumeWakeTriggered(keyCode, true);
                    break;
                } else if (getVolumeWakeTriggered(keyCode) && !down) {
                    result &= ~ACTION_PASS_TO_USER;
                    setVolumeWakeTriggered(keyCode, false);
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            if (mVolumeAnswerCall) {
                                telecomManager.acceptRingingCall();
                            }
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0 && !mVolumeWakeScreen) {
                    if (mLineageButtons.handleVolumeKey(event, interactive))
                        break;
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_HOME:
            if (down && !interactive) {
                isWakeKey = mHomeWakeScreen;
                if (!isWakeKey) {
                    useHapticFeedback = false;
                }
            }
            break;
        case KeyEvent.KEYCODE_FOCUS:
            if (down && !interactive && mCameraSleepOnRelease) {
                mIsFocusPressed = true;
            } else if (!down) {
                // Check if screen is fully on before letting the device go to sleep
                if (mScreenOnFully && mIsFocusPressed) {
                    mPowerManager.goToSleep(SystemClock.uptimeMillis());
                } else {
                    mFocusReleasedGoToSleep = true;
                }
                mIsFocusPressed = false;
            }
            break;
        case KeyEvent.KEYCODE_CAMERA:
            if (down && mIsFocusPressed) {
                mIsFocusPressed = false;
            }
            if (down) {
                mIsLongPress = false;
                KeyEvent newEvent = new KeyEvent(event.getDownTime(), event.getEventTime(), event.getAction(), keyCode, 0);
                Message msg = mHandler.obtainMessage(MSG_CAMERA_LONG_PRESS, newEvent);
                msg.setAsynchronous(true);
                mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
                // Consume key down events of all presses.
                break;
            } else {
                mHandler.removeMessages(MSG_CAMERA_LONG_PRESS);
                // Consume key up events of long presses only.
                if (mIsLongPress && mCameraLaunch) {
                    Intent intent;
                    if (keyguardActive) {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE);
                    } else {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);
                    }
                    isWakeKey = true;
                    startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if (mTopFullscreenOpaqueWindowState != null && (mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && (mAssistPressAction == Action.APP_SWITCH || mAssistLongPressAction == Action.APP_SWITCH)) {
                    preloadRecentApps();
                }
                if (down && longPressed) {
                    if (!keyguardOn() && mAssistLongPressAction != Action.NOTHING) {
                        if (mAssistLongPressAction != Action.APP_SWITCH) {
                            cancelPreloadRecentApps();
                        }
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mAssistLongPressAction, event);
                    }
                }
                if (!down && !longPressed) {
                    if (mAssistPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    if (!canceled) {
                        performKeyAction(mAssistPressAction, event);
                    }
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
private boolean shouldDispatchInputWhenNonInteractive(KeyEvent event) {
    final boolean displayOff = (mDisplay == null || mDisplay.getState() == STATE_OFF);
    if (displayOff && !mHasFeatureWatch) {
        return false;
    }
    // Send events to keyguard while the screen is on and it's showing.
    if (isKeyguardShowingAndNotOccluded() && !displayOff) {
        return true;
    }
    // Watches handle BACK specially
    if (mHasFeatureWatch && event != null && (event.getKeyCode() == KeyEvent.KEYCODE_BACK || event.getKeyCode() == KeyEvent.KEYCODE_STEM_PRIMARY)) {
        return false;
    }
    // Send events to a dozing dream even if the screen is off since the dream
    // is in control of the state of the screen.
    IDreamManager dreamManager = getDreamManager();
    try {
        if (dreamManager != null && dreamManager.isDreaming()) {
            return true;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "RemoteException when checking if dreaming", e);
    }
    // interacted with.
    return false;
}
#method_after
private boolean shouldDispatchInputWhenNonInteractive(KeyEvent event) {
    final boolean displayOff = (mDisplay == null || mDisplay.getState() == STATE_OFF);
    if (displayOff && !mHasFeatureWatch) {
        return false;
    }
    final boolean isDozing = isDozeMode();
    if (event != null && isVolumeKey(event) && isDozing) {
        return false;
    }
    // Send events to keyguard while the screen is on and it's showing.
    if (isKeyguardShowingAndNotOccluded() && !displayOff) {
        return true;
    }
    // Watches handle BACK specially
    if (mHasFeatureWatch && event != null && (event.getKeyCode() == KeyEvent.KEYCODE_BACK || event.getKeyCode() == KeyEvent.KEYCODE_STEM_PRIMARY)) {
        return false;
    }
    // is in control of the state of the screen.
    if (isDozing) {
        return true;
    }
    // interacted with.
    return false;
}
#end_block

#method_before
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
}
#method_after
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
    if (mFocusReleasedGoToSleep) {
        mFocusReleasedGoToSleep = false;
        mPowerManager.goToSleep(SystemClock.uptimeMillis());
    }
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar == 1;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
private String getRearFlashCameraId() throws CameraAccessException {
    if (mRearFlashCameraId != null)
        return mRearFlashCameraId;
    for (final String id : mCameraManager.getCameraIdList()) {
        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);
        boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
        int lensDirection = c.get(CameraCharacteristics.LENS_FACING);
        if (flashAvailable && lensDirection == CameraCharacteristics.LENS_FACING_BACK) {
            mRearFlashCameraId = id;
        }
    }
    return mRearFlashCameraId;
}
#method_after
private String getRearFlashCameraId() throws CameraAccessException {
    if (mRearFlashCameraId != null)
        return mRearFlashCameraId;
    for (final String id : mCameraManager.getCameraIdList()) {
        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);
        Boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
        Integer lensFacing = c.get(CameraCharacteristics.LENS_FACING);
        if (flashAvailable != null && flashAvailable && lensFacing != null && lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
            mRearFlashCameraId = id;
            break;
        }
    }
    return mRearFlashCameraId;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case LAST_APP:
            ActionUtils.switchToLastApp(mContext);
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#method_after
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case LAST_APP:
            ActionUtils.switchToLastApp(mContext, mCurrentUserId);
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void updateKeyAssignments() {
    int activeHardwareKeys = mDeviceHardwareKeys;
    if (mDevForceNavbar == 1) {
        activeHardwareKeys = 0;
    }
    final boolean hasMenu = (activeHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (activeHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (activeHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    // Initialize all assignments to sane defaults.
    mMenuPressAction = Action.MENU;
    mMenuLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnMenuBehavior));
    if (mMenuLongPressAction == Action.NOTHING && (hasMenu && !hasAssist)) {
        mMenuLongPressAction = Action.SEARCH;
    }
    mAssistPressAction = Action.SEARCH;
    mAssistLongPressAction = Action.VOICE_SEARCH;
    mAppSwitchPressAction = Action.APP_SWITCH;
    mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
    mHomeLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
    if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeLongPressAction = Action.NOTHING;
    }
    mHomeDoubleTapAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_doubleTapOnHomeBehavior));
    if (mHomeDoubleTapAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeDoubleTapAction = Action.NOTHING;
    }
    mHomeLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION, mHomeLongPressAction);
    mHomeDoubleTapAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION, mHomeDoubleTapAction);
    if (hasMenu) {
        mMenuPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_ACTION, mMenuPressAction);
        mMenuLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION, mMenuLongPressAction);
    }
    if (hasAssist) {
        mAssistPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_ACTION, mAssistPressAction);
        mAssistLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION, mAssistLongPressAction);
    }
    if (hasAppSwitch) {
        mAppSwitchPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_ACTION, mAppSwitchPressAction);
        mAppSwitchLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mAppSwitchLongPressAction);
    }
    mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
}
#method_after
private void updateKeyAssignments() {
    int activeHardwareKeys = mDeviceHardwareKeys;
    if (mForceNavbar == 1) {
        activeHardwareKeys = 0;
    }
    final boolean hasMenu = (activeHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (activeHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (activeHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    // Initialize all assignments to sane defaults.
    mMenuPressAction = Action.MENU;
    mMenuLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnMenuBehavior));
    if (mMenuLongPressAction == Action.NOTHING && (hasMenu && !hasAssist)) {
        mMenuLongPressAction = Action.SEARCH;
    }
    mAssistPressAction = Action.SEARCH;
    mAssistLongPressAction = Action.VOICE_SEARCH;
    mAppSwitchPressAction = Action.APP_SWITCH;
    mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
    mHomeLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
    if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeLongPressAction = Action.NOTHING;
    }
    mHomeDoubleTapAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_doubleTapOnHomeBehavior));
    if (mHomeDoubleTapAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeDoubleTapAction = Action.NOTHING;
    }
    mHomeLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION, mHomeLongPressAction);
    mHomeDoubleTapAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION, mHomeDoubleTapAction);
    if (hasMenu) {
        mMenuPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_ACTION, mMenuPressAction);
        mMenuLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION, mMenuLongPressAction);
    }
    if (hasAssist) {
        mAssistPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_ACTION, mAssistPressAction);
        mAssistLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION, mAssistLongPressAction);
    }
    if (hasAppSwitch) {
        mAppSwitchPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_ACTION, mAppSwitchPressAction);
        mAppSwitchLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mAppSwitchLongPressAction);
    }
    mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
}
#end_block

#method_before
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#method_after
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    mNeedsNavigationBar = mHasNavigationBar;
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#method_after
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar == 1);
            }
        }
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int forceNavbar = LineageSettings.System.getInt(resolver, LineageSettings.System.FORCE_SHOW_NAVBAR, 0);
        if (forceNavbar != mForceNavbar) {
            mForceNavbar = forceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mForceNavbar == 1);
            }
            mHasNavigationBar = mNeedsNavigationBar || mForceNavbar == 1;
        }
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mLineageButtons.handleVolumeKey(event, interactive))
                    break;
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if (mTopFullscreenOpaqueWindowState != null && (mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && (mAssistPressAction == Action.APP_SWITCH || mAssistLongPressAction == Action.APP_SWITCH)) {
                    preloadRecentApps();
                }
                if (down && longPressed) {
                    if (!keyguardOn() && mAssistLongPressAction != Action.NOTHING) {
                        if (mAssistLongPressAction != Action.APP_SWITCH) {
                            cancelPreloadRecentApps();
                        }
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mAssistLongPressAction, event);
                    }
                }
                if (!down && !longPressed) {
                    if (mAssistPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    if (!canceled) {
                        performKeyAction(mAssistPressAction, event);
                    }
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    if (mLineageButtons.handleVolumeKey(event, interactive))
                        break;
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && (mAssistPressAction == Action.APP_SWITCH || mAssistLongPressAction == Action.APP_SWITCH)) {
                    preloadRecentApps();
                }
                if (down && longPressed) {
                    if (!keyguardOn() && mAssistLongPressAction != Action.NOTHING) {
                        if (mAssistLongPressAction != Action.APP_SWITCH) {
                            cancelPreloadRecentApps();
                        }
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mAssistLongPressAction, event);
                    }
                }
                if (!down && !longPressed) {
                    if (mAssistPressAction != Action.APP_SWITCH) {
                        cancelPreloadRecentApps();
                    }
                    if (!canceled) {
                        performKeyAction(mAssistPressAction, event);
                    }
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar == 1;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
private String getRearFlashCameraId() throws CameraAccessException {
    if (mRearFlashCameraId != null)
        return mRearFlashCameraId;
    for (final String id : mCameraManager.getCameraIdList()) {
        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);
        boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
        int lensDirection = c.get(CameraCharacteristics.LENS_FACING);
        if (flashAvailable && lensDirection == CameraCharacteristics.LENS_FACING_BACK) {
            mRearFlashCameraId = id;
        }
    }
    return mRearFlashCameraId;
}
#method_after
private String getRearFlashCameraId() throws CameraAccessException {
    if (mRearFlashCameraId != null)
        return mRearFlashCameraId;
    for (final String id : mCameraManager.getCameraIdList()) {
        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);
        Boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
        Integer lensFacing = c.get(CameraCharacteristics.LENS_FACING);
        if (flashAvailable != null && flashAvailable && lensFacing != null && lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
            mRearFlashCameraId = id;
            break;
        }
    }
    return mRearFlashCameraId;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#method_after
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    mNeedsNavigationBar = mHasNavigationBar;
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#method_after
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar == 1);
            }
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int forceNavbar = LineageSettings.System.getInt(resolver, LineageSettings.System.FORCE_SHOW_NAVBAR, 0);
        if (forceNavbar != mForceNavbar) {
            mForceNavbar = forceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mForceNavbar == 1);
            }
            mHasNavigationBar = mNeedsNavigationBar || mForceNavbar == 1;
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mLineageButtons.handleVolumeKey(event, interactive))
                    break;
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    if (mLineageButtons.handleVolumeKey(event, interactive))
                        break;
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar == 1;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
private String getRearFlashCameraId() throws CameraAccessException {
    if (mRearFlashCameraId != null)
        return mRearFlashCameraId;
    for (final String id : mCameraManager.getCameraIdList()) {
        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);
        boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
        int lensDirection = c.get(CameraCharacteristics.LENS_FACING);
        if (flashAvailable && lensDirection == CameraCharacteristics.LENS_FACING_BACK) {
            mRearFlashCameraId = id;
        }
    }
    return mRearFlashCameraId;
}
#method_after
private String getRearFlashCameraId() throws CameraAccessException {
    if (mRearFlashCameraId != null)
        return mRearFlashCameraId;
    for (final String id : mCameraManager.getCameraIdList()) {
        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);
        Boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
        Integer lensFacing = c.get(CameraCharacteristics.LENS_FACING);
        if (flashAvailable != null && flashAvailable && lensFacing != null && lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
            mRearFlashCameraId = id;
            break;
        }
    }
    return mRearFlashCameraId;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#method_after
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    mNeedsNavigationBar = mHasNavigationBar;
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    // For car, ignore the dp limitation. It's physically impossible to rotate the car's screen
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isCar = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    // For TV, it's usually 960dp x 540dp, ignore the size limitation.
    // so if the orientation is forced, we need to respect that no matter what.
    final boolean isTv = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    mForceDefaultOrientation = ((longSizeDp >= 960 && shortSizeDp >= 720) || isCar || isTv) && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#method_after
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar == 1);
            }
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int forceNavbar = LineageSettings.System.getInt(resolver, LineageSettings.System.FORCE_SHOW_NAVBAR, 0);
        if (forceNavbar != mForceNavbar) {
            mForceNavbar = forceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mForceNavbar == 1);
            }
            mHasNavigationBar = mNeedsNavigationBar || mForceNavbar == 1;
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mLineageButtons.handleVolumeKey(event, interactive))
                    break;
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    if (mLineageButtons.handleVolumeKey(event, interactive))
                        break;
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar == 1;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mLogger = new MetricsLogger();
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mVeryLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mVeryLongPressTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressTimeout);
    mAllowStartActivityForLongPressOnPowerDuringSetup = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowStartActivityForLongPressOnPowerInSetup);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    // TODO(multi-display): Needs to be display specific.
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, long duration, long statusBarAnimationStartTime, long statusBarAnimationDuration) {
            return handleStartTransitionForKeyguardLw(transit, duration);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, 0);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }

        @Override
        public void onShowingChanged() {
            mWindowManagerFuncs.onKeyguardShowingAndNotOccludedChanged();
        }
    });
    mScreenshotHelper = new ScreenshotHelper(mContext);
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mLogger = new MetricsLogger();
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mVeryLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mVeryLongPressTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressTimeout);
    mAllowStartActivityForLongPressOnPowerDuringSetup = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowStartActivityForLongPressOnPowerInSetup);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    // TODO(multi-display): Needs to be display specific.
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, long duration, long statusBarAnimationStartTime, long statusBarAnimationDuration) {
            return handleStartTransitionForKeyguardLw(transit, duration);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, 0);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }

        @Override
        public void onShowingChanged() {
            mWindowManagerFuncs.onKeyguardShowingAndNotOccludedChanged();
        }
    });
    mScreenshotHelper = new ScreenshotHelper(mContext);
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#method_after
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        boolean devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar);
            }
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#end_block

#method_before
@Override
public int rotationForOrientationLw(int orientation, int lastRotation, boolean defaultDisplay) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (!defaultDisplay) {
            // For secondary displays we ignore things like displays sensors, docking mode and
            // rotation lock, and always prefer a default rotation.
            preferredRotation = Surface.ROTATION_0;
        } else if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (mDemoRotationLock) {
            // Ignore sensor when demo rotation lock is enabled.
            // Note that the dock orientation and HDMI rotation lock override this.
            preferredRotation = mDemoRotation;
        } else if (mPersistentVrModeEnabled) {
            // While in VR, apps always prefer a portrait rotation. This does not change
            // any apps that explicitly set landscape, but does cause sensors be ignored,
            // and ignored any orientation lock that the user has set (this conditional
            // should remain above the ORIENTATION_LOCKED conditional below).
            preferredRotation = mPortraitRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // Rotation setting bitmask
            // 1=0 2=90 4=180 8=270
            boolean allowed = true;
            if (mUserRotationAngles < 0) {
                // Not set by user so use these defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (1 | 2 | 4 | 8) : // All except 180
                (1 | 2 | 8);
            }
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & 1) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & 2) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & 4) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & 8) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#method_after
@Override
public int rotationForOrientationLw(int orientation, int lastRotation, boolean defaultDisplay) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (!defaultDisplay) {
            // For secondary displays we ignore things like displays sensors, docking mode and
            // rotation lock, and always prefer a default rotation.
            preferredRotation = Surface.ROTATION_0;
        } else if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (mDemoRotationLock) {
            // Ignore sensor when demo rotation lock is enabled.
            // Note that the dock orientation and HDMI rotation lock override this.
            preferredRotation = mDemoRotation;
        } else if (mPersistentVrModeEnabled) {
            // While in VR, apps always prefer a portrait rotation. This does not change
            // any apps that explicitly set landscape, but does cause sensors be ignored,
            // and ignored any orientation lock that the user has set (this conditional
            // should remain above the ORIENTATION_LOCKED conditional below).
            preferredRotation = mPortraitRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // Rotation setting bitmask (1=0; 2=90; 4=180; 8=270)
            boolean allowed = true;
            if (mUserRotationAngles < 0) {
                // Not set by user so use these defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (1 | 2 | 4 | 8) : // All except 180
                (1 | 2 | 8);
            }
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & 1) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & 2) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & 4) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & 8) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#end_block

#method_before
@Override
public void systemReady() {
    // In normal flow, systemReady is called before other system services are ready.
    // So it is better not to bind keyguard here.
    mKeyguardDelegate.onSystemReady();
    mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
    if (mVrManagerInternal != null) {
        mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
    }
    mLineageHardware = LineageHardwareManager.getInstance(mContext);
    // Ensure observe happens in systemReady() since we need
    // LineageHardwareService to be up and running
    mSettingsObserver.observe();
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
        // And keyguard should be already bound from systemBooted
        if (mSystemBooted) {
            mKeyguardDelegate.onBootCompleted();
        }
    }
    mSystemGestures.systemReady();
    mImmersiveModeConfirmation.systemReady();
    mAutofillManagerInternal = LocalServices.getService(AutofillManagerInternal.class);
}
#method_after
@Override
public void systemReady() {
    // In normal flow, systemReady is called before other system services are ready.
    // So it is better not to bind keyguard here.
    mKeyguardDelegate.onSystemReady();
    mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
    if (mVrManagerInternal != null) {
        mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
    }
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
        // And keyguard should be already bound from systemBooted
        if (mSystemBooted) {
            mKeyguardDelegate.onBootCompleted();
        }
    }
    mSystemGestures.systemReady();
    mImmersiveModeConfirmation.systemReady();
    mAutofillManagerInternal = LocalServices.getService(AutofillManagerInternal.class);
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstance) {
    super.onCreate(savedInstance);
    addPreferencesFromResource(R.xml.settings);
    PreferenceCategory securityCategory = (PreferenceCategory) findPreference("category_security");
    Preference homePage = findPreference("key_home_page");
    homePage.setSummary(PrefsUtils.getHomePage(getContext()));
    homePage.setOnPreferenceClickListener(preference -> {
        editHomePage(preference);
        return true;
    });
    Preference clearCookie = findPreference("key_cookie_clear");
    clearCookie.setOnPreferenceClickListener(preference -> {
        CookieManager.getInstance().removeAllCookies(null);
        Toast.makeText(getContext(), getString(R.string.pref_cookie_clear_done), Toast.LENGTH_LONG).show();
        return true;
    });
    SwitchPreference reachMode = (SwitchPreference) findPreference(("key_reach_mode"));
    if (UiUtils.isTablet(getContext())) {
        getPreferenceScreen().removePreference(reachMode);
    } else {
        reachMode.setOnPreferenceClickListener(preference -> {
            Intent intent = new Intent(IntentUtils.EVENT_CHANGE_UI_MODE);
            intent.putExtra(IntentUtils.EVENT_CHANGE_UI_MODE, reachMode.isChecked());
            LocalBroadcastManager.getInstance(getContext()).sendBroadcast(intent);
            return true;
        });
    }
    SwitchPreference clearTextTraffic = (SwitchPreference) findPreference("key_clear_text_traffic");
    if (NetworkSecurityPolicyUtils.isSupported()) {
        clearTextTraffic.setOnPreferenceChangeListener((preference, value) -> {
            if (value instanceof Boolean) {
                NetworkSecurityPolicyUtils.setCleartextTrafficPermitted((Boolean) value);
                return true;
            }
            return false;
        });
    } else {
        securityCategory.removePreference(clearTextTraffic);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstance) {
    super.onCreate(savedInstance);
    addPreferencesFromResource(R.xml.settings);
    PreferenceCategory securityCategory = (PreferenceCategory) findPreference("category_security");
    Preference homePage = findPreference("key_home_page");
    homePage.setSummary(PrefsUtils.getHomePage(getContext()));
    homePage.setOnPreferenceClickListener(preference -> {
        editHomePage(preference);
        return true;
    });
    Preference clearCookie = findPreference("key_cookie_clear");
    clearCookie.setOnPreferenceClickListener(preference -> {
        CookieManager.getInstance().removeAllCookies(null);
        Toast.makeText(getContext(), getString(R.string.pref_cookie_clear_done), Toast.LENGTH_LONG).show();
        return true;
    });
    SwitchPreference reachMode = (SwitchPreference) findPreference(("key_reach_mode"));
    if (UiUtils.isTablet(getContext())) {
        getPreferenceScreen().removePreference(reachMode);
    } else {
        reachMode.setOnPreferenceClickListener(preference -> {
            Intent intent = new Intent(IntentUtils.EVENT_CHANGE_UI_MODE);
            intent.putExtra(IntentUtils.EVENT_CHANGE_UI_MODE, reachMode.isChecked());
            LocalBroadcastManager.getInstance(getContext()).sendBroadcast(intent);
            return true;
        });
    }
    SwitchPreference clearTextTraffic = (SwitchPreference) findPreference("key_clear_text_traffic");
    if (NetworkSecurityPolicyUtils.isSupported()) {
        clearTextTraffic.setOnPreferenceChangeListener((preference, value) -> {
            NetworkSecurityPolicyUtils.setCleartextTrafficPermitted((Boolean) value);
            return true;
        });
    } else {
        securityCategory.removePreference(clearTextTraffic);
    }
}
#end_block

#method_before
private boolean grantSignaturePermission(String perm, PackageParser.Package pkg, BasePermission bp, PermissionsState origPermissions) {
    boolean privilegedPermission = (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0;
    boolean privappPermissionsDisable = RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_DISABLE;
    boolean platformPermission = PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage);
    boolean platformPackage = PLATFORM_PACKAGE_NAME.equals(pkg.packageName);
    if (!privappPermissionsDisable && privilegedPermission && pkg.isPrivilegedApp() && !platformPackage && platformPermission) {
        final ArraySet<String> allowedPermissions = SystemConfig.getInstance().getPrivAppPermissions(pkg.packageName);
        final boolean whitelisted = allowedPermissions != null && allowedPermissions.contains(perm);
        if (!whitelisted) {
            Slog.w(TAG, "Privileged permission " + perm + " for package " + pkg.packageName + " - not in privapp-permissions whitelist");
            // Only report violations for apps on system image
            if (!mSystemReady && !pkg.isUpdatedSystemApp()) {
                // it's only a reportable violation if the permission isn't explicitly denied
                final ArraySet<String> deniedPermissions = SystemConfig.getInstance().getPrivAppDenyPermissions(pkg.packageName);
                final boolean permissionViolation = deniedPermissions == null || !deniedPermissions.contains(perm);
                if (permissionViolation) {
                    if (mPrivappPermissionsViolations == null) {
                        mPrivappPermissionsViolations = new ArraySet<>();
                    }
                    mPrivappPermissionsViolations.add(pkg.packageName + ": " + perm);
                } else {
                    return false;
                }
            }
            if (RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_ENFORCE) {
                return false;
            }
        }
    }
    boolean allowed = (compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (mPlatformPackage != null ? compareSignatures(mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH : false) || (compareSignatures(mVendorPlatformSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
    if (!allowed && privilegedPermission) {
        if (isSystemApp(pkg)) {
            // is granted only if it had been defined by the original application.
            if (pkg.isUpdatedSystemApp()) {
                final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                if (sysPs != null && sysPs.getPermissionsState().hasInstallPermission(perm)) {
                    // update.
                    if (sysPs.isPrivileged()) {
                        allowed = true;
                    }
                } else {
                    // privileged to get it.
                    if (sysPs != null && sysPs.pkg != null && sysPs.isPrivileged()) {
                        for (int j = 0; j < sysPs.pkg.requestedPermissions.size(); j++) {
                            if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) {
                                allowed = true;
                                break;
                            }
                        }
                    }
                    // packages can also get the permission.
                    if (pkg.parentPackage != null) {
                        final PackageSetting disabledSysParentPs = mSettings.getDisabledSystemPkgLPr(pkg.parentPackage.packageName);
                        if (disabledSysParentPs != null && disabledSysParentPs.pkg != null && disabledSysParentPs.isPrivileged()) {
                            if (isPackageRequestingPermission(disabledSysParentPs.pkg, perm)) {
                                allowed = true;
                            } else if (disabledSysParentPs.pkg.childPackages != null) {
                                final int count = disabledSysParentPs.pkg.childPackages.size();
                                for (int i = 0; i < count; i++) {
                                    PackageParser.Package disabledSysChildPkg = disabledSysParentPs.pkg.childPackages.get(i);
                                    if (isPackageRequestingPermission(disabledSysChildPkg, perm)) {
                                        allowed = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                allowed = isPrivilegedApp(pkg);
            }
        }
    }
    if (!allowed) {
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRE23) != 0 && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
            // If this was a previously normal/dangerous permission that got moved
            // to a system permission as part of the runtime permission redesign, then
            // we still want to blindly grant it to old apps.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0 && pkg.packageName.equals(mRequiredInstallerPackage)) {
            // If this permission is to be granted to the system installer and
            // this app is an installer, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0 && pkg.packageName.equals(mRequiredVerifierPackage)) {
            // If this permission is to be granted to the system verifier and
            // this app is a verifier, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0 && isSystemApp(pkg)) {
            // Any pre-installed system app is allowed to get this permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
            // For development permissions, a development permission
            // is granted only if it was already granted.
            allowed = origPermissions.hasInstallPermission(perm);
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_SETUP) != 0 && pkg.packageName.equals(mSetupWizardPackage)) {
            // If this permission is to be granted to the system setup wizard and
            // this app is a setup wizard, then it gets the permission.
            allowed = true;
        }
    }
    return allowed;
}
#method_after
private boolean grantSignaturePermission(String perm, PackageParser.Package pkg, BasePermission bp, PermissionsState origPermissions) {
    boolean privilegedPermission = (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0;
    boolean privappPermissionsDisable = RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_DISABLE;
    boolean platformPermission = PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage);
    boolean platformPackage = PLATFORM_PACKAGE_NAME.equals(pkg.packageName);
    if (!privappPermissionsDisable && privilegedPermission && pkg.isPrivilegedApp() && !platformPackage && platformPermission) {
        final ArraySet<String> allowedPermissions = SystemConfig.getInstance().getPrivAppPermissions(pkg.packageName);
        final boolean whitelisted = allowedPermissions != null && allowedPermissions.contains(perm);
        if (!whitelisted) {
            Slog.w(TAG, "Privileged permission " + perm + " for package " + pkg.packageName + " - not in privapp-permissions whitelist");
            // Only report violations for apps on system image
            if (!mSystemReady && !pkg.isUpdatedSystemApp()) {
                // it's only a reportable violation if the permission isn't explicitly denied
                final ArraySet<String> deniedPermissions = SystemConfig.getInstance().getPrivAppDenyPermissions(pkg.packageName);
                final boolean permissionViolation = deniedPermissions == null || !deniedPermissions.contains(perm);
                if (permissionViolation) {
                    if (mPrivappPermissionsViolations == null) {
                        mPrivappPermissionsViolations = new ArraySet<>();
                    }
                    mPrivappPermissionsViolations.add(pkg.packageName + ": " + perm);
                } else {
                    return false;
                }
            }
            if (RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_ENFORCE) {
                return false;
            }
        }
    }
    boolean allowed = (compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (mPlatformPackage != null && compareSignatures(mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (compareSignatures(mVendorPlatformSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
    if (!allowed && privilegedPermission) {
        if (isSystemApp(pkg)) {
            // is granted only if it had been defined by the original application.
            if (pkg.isUpdatedSystemApp()) {
                final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                if (sysPs != null && sysPs.getPermissionsState().hasInstallPermission(perm)) {
                    // update.
                    if (sysPs.isPrivileged()) {
                        allowed = true;
                    }
                } else {
                    // privileged to get it.
                    if (sysPs != null && sysPs.pkg != null && sysPs.isPrivileged()) {
                        for (int j = 0; j < sysPs.pkg.requestedPermissions.size(); j++) {
                            if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) {
                                allowed = true;
                                break;
                            }
                        }
                    }
                    // packages can also get the permission.
                    if (pkg.parentPackage != null) {
                        final PackageSetting disabledSysParentPs = mSettings.getDisabledSystemPkgLPr(pkg.parentPackage.packageName);
                        if (disabledSysParentPs != null && disabledSysParentPs.pkg != null && disabledSysParentPs.isPrivileged()) {
                            if (isPackageRequestingPermission(disabledSysParentPs.pkg, perm)) {
                                allowed = true;
                            } else if (disabledSysParentPs.pkg.childPackages != null) {
                                final int count = disabledSysParentPs.pkg.childPackages.size();
                                for (int i = 0; i < count; i++) {
                                    PackageParser.Package disabledSysChildPkg = disabledSysParentPs.pkg.childPackages.get(i);
                                    if (isPackageRequestingPermission(disabledSysChildPkg, perm)) {
                                        allowed = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                allowed = isPrivilegedApp(pkg);
            }
        }
    }
    if (!allowed) {
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRE23) != 0 && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
            // If this was a previously normal/dangerous permission that got moved
            // to a system permission as part of the runtime permission redesign, then
            // we still want to blindly grant it to old apps.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0 && pkg.packageName.equals(mRequiredInstallerPackage)) {
            // If this permission is to be granted to the system installer and
            // this app is an installer, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0 && pkg.packageName.equals(mRequiredVerifierPackage)) {
            // If this permission is to be granted to the system verifier and
            // this app is a verifier, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0 && isSystemApp(pkg)) {
            // Any pre-installed system app is allowed to get this permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
            // For development permissions, a development permission
            // is granted only if it was already granted.
            allowed = origPermissions.hasInstallPermission(perm);
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_SETUP) != 0 && pkg.packageName.equals(mSetupWizardPackage)) {
            // If this permission is to be granted to the system setup wizard and
            // this app is a setup wizard, then it gets the permission.
            allowed = true;
        }
    }
    return allowed;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mLogger = new MetricsLogger();
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mVeryLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mVeryLongPressTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressTimeout);
    mAllowStartActivityForLongPressOnPowerDuringSetup = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowStartActivityForLongPressOnPowerInSetup);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    // TODO(multi-display): Needs to be display specific.
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, long duration, long statusBarAnimationStartTime, long statusBarAnimationDuration) {
            return handleStartTransitionForKeyguardLw(transit, duration);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, 0);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }

        @Override
        public void onShowingChanged() {
            mWindowManagerFuncs.onKeyguardShowingAndNotOccludedChanged();
        }
    });
    mScreenshotHelper = new ScreenshotHelper(mContext);
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mLogger = new MetricsLogger();
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mVeryLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mVeryLongPressTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_veryLongPressTimeout);
    mAllowStartActivityForLongPressOnPowerDuringSetup = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowStartActivityForLongPressOnPowerInSetup);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    // TODO(multi-display): Needs to be display specific.
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, long duration, long statusBarAnimationStartTime, long statusBarAnimationDuration) {
            return handleStartTransitionForKeyguardLw(transit, duration);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, 0);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }

        @Override
        public void onShowingChanged() {
            mWindowManagerFuncs.onKeyguardShowingAndNotOccludedChanged();
        }
    });
    mScreenshotHelper = new ScreenshotHelper(mContext);
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#method_after
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        boolean devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar);
            }
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int width = fullWidth;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            width -= getNavigationBarWidth(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        width -= displayCutout.getSafeInsetLeft() + displayCutout.getSafeInsetRight();
    }
    return width;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId, DisplayCutout displayCutout) {
    int height = fullHeight;
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            height -= getNavigationBarHeight(rotation, uiMode);
        }
    }
    if (displayCutout != null) {
        height -= displayCutout.getSafeInsetTop() + displayCutout.getSafeInsetBottom();
    }
    return height;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Specific device key handling
    if (dispatchKeyToKeyHandlers(event)) {
        return 0;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#end_block

#method_before
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    return wakeUp(wakeTime, wakeInTheaterMode, reason, false);
}
#method_after
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    mPowerManager.wakeUp(wakeTime, reason);
    return true;
}
#end_block

#method_before
@Override
public void systemReady() {
    // In normal flow, systemReady is called before other system services are ready.
    // So it is better not to bind keyguard here.
    mKeyguardDelegate.onSystemReady();
    mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
    if (mVrManagerInternal != null) {
        mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
    }
    mLineageHardware = LineageHardwareManager.getInstance(mContext);
    // Ensure observe happens in systemReady() since we need
    // LineageHardwareService to be up and running
    mSettingsObserver.observe();
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
        // And keyguard should be already bound from systemBooted
        if (mSystemBooted) {
            mKeyguardDelegate.onBootCompleted();
        }
    }
    mSystemGestures.systemReady();
    mImmersiveModeConfirmation.systemReady();
    mAutofillManagerInternal = LocalServices.getService(AutofillManagerInternal.class);
}
#method_after
@Override
public void systemReady() {
    // In normal flow, systemReady is called before other system services are ready.
    // So it is better not to bind keyguard here.
    mKeyguardDelegate.onSystemReady();
    mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
    if (mVrManagerInternal != null) {
        mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
    }
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
        // And keyguard should be already bound from systemBooted
        if (mSystemBooted) {
            mKeyguardDelegate.onBootCompleted();
        }
    }
    mSystemGestures.systemReady();
    mImmersiveModeConfirmation.systemReady();
    mAutofillManagerInternal = LocalServices.getService(AutofillManagerInternal.class);
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#end_block

#method_before
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    final String value;
    if (!restorePersistedValue || !isPersisted()) {
        value = (String) defaultValue;
        if (shouldPersist()) {
            persistString(value);
        }
    } else {
        value = getString(getKey(), (String) defaultValue);
    }
    setValue(value);
}
#method_after
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    final String value;
    if (!restorePersistedValue || !isPersisted()) {
        if (defaultValue == null) {
            return;
        }
        value = (String) defaultValue;
        if (shouldPersist()) {
            persistString(value);
        }
    } else {
        // Note: the default is not used because to have got here
        // isPersisted() must be true.
        value = getString(getKey(), null);
    }
    setValue(value);
}
#end_block

#method_before
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    final String value;
    if (!restorePersistedValue || !isPersisted()) {
        value = (String) defaultValue;
        if (shouldPersist()) {
            persistString(value);
        }
    } else {
        value = getString(getKey(), (String) defaultValue);
    }
    setValue(value);
}
#method_after
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    final String value;
    if (!restorePersistedValue || !isPersisted()) {
        if (defaultValue == null) {
            return;
        }
        value = (String) defaultValue;
        if (shouldPersist()) {
            persistString(value);
        }
    } else {
        // Note: the default is not used because to have got here
        // isPersisted() must be true.
        value = getString(getKey(), null);
    }
    setValue(value);
}
#end_block

#method_before
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    final boolean checked;
    if (!restorePersistedValue || !isPersisted()) {
        checked = (boolean) defaultValue;
        if (shouldPersist()) {
            persistBoolean(checked);
        }
    } else {
        checked = getBoolean(getKey(), (boolean) defaultValue);
    }
    setChecked(checked);
}
#method_after
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    final boolean checked;
    if (!restorePersistedValue || !isPersisted()) {
        if (defaultValue == null) {
            return;
        }
        checked = (boolean) defaultValue;
        if (shouldPersist()) {
            persistBoolean(checked);
        }
    } else {
        // Note: the default is not used because to have got here
        // isPersisted() must be true.
        checked = getBoolean(getKey(), false);
    }
    setChecked(checked);
}
#end_block

#method_before
private boolean isFalseTouch() {
    return false;
}
#method_after
private boolean isFalseTouch() {
    return !touchAboveFalsingThreshold;
}
#end_block

#method_before
public void calcLights(LedValues ledValues, int level, int status, boolean low) {
    if (DEBUG) {
        Slog.i(TAG, "calcLights input:" + " ledValues={ " + ledValues + " }" + " level=" + level + " status=" + status + " low=" + low + " mCanAdjustBrightness=" + mCanAdjustBrightness + " mHALAdjustableBrightness=" + mHALAdjustableBrightness + " mMultiColorBatteryLed=" + mMultiColorBatteryLed + " mUseSegmentedBatteryLed=" + mUseSegmentedBatteryLed + " mBatteryBrightnessLevel=" + mBatteryBrightnessLevel + " mBatteryBrightnessZenLevel=" + mBatteryBrightnessZenLevel + " mZenMode=" + mZenMode);
    }
    // The only meaningful ledValues values received by frameworks BatteryService
    // are the pulse times (for low battery). Explicitly set enabled state and
    // color to ensure that we arrive at a deterministic outcome.
    ledValues.setEnabled(false);
    ledValues.setColor(0);
    if (!mLightEnabled) {
        return;
    }
    final int brightness;
    if (mUseSegmentedBatteryLed) {
        brightness = level;
    } else if (!mCanAdjustBrightness) {
        // No brightness support available
        brightness = LedValues.LIGHT_BRIGHTNESS_MAXIMUM;
    } else if (mZenMode == Global.ZEN_MODE_OFF) {
        brightness = mBatteryBrightnessLevel;
    } else {
        brightness = mBatteryBrightnessZenLevel;
    }
    ledValues.setBrightness(brightness);
    if (low) {
        if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Battery is charging and low.
            ledValues.setColor(mBatteryLowARGB);
            ledValues.setSolid();
        } else if (mLedPulseEnabled) {
            // Battery is low, not charging and pulse is enabled
            // (pulsing values are set by frameworks BatteryService).
            ledValues.setColor(mBatteryLowARGB);
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            // Battery is full or charging and nearly full.
            ledValues.setColor(mBatteryFullARGB);
            ledValues.setSolid();
        } else {
            // Battery is charging and not nearly full.
            ledValues.setColor(mBatteryMediumARGB);
            ledValues.setSolid();
        }
    }
    // If a color was set, enable light.
    if (ledValues.getColor() != 0) {
        ledValues.setEnabled(true);
    }
    if (mCanAdjustBrightness) {
        if (!mHALAdjustableBrightness) {
            // If lights HAL does not support adjustable brightness then
            // scale color value here instead.
            ledValues.applyAlphaToBrightness();
            ledValues.applyBrightnessToColor();
        } else if (mUseSegmentedBatteryLed) {
            // For non-RGB segmented LEDs, we must set the brightness
            // as the color, since the alpha channel contains the level
            int color = 0;
            if (mZenMode == Global.ZEN_MODE_OFF) {
                color |= mBatteryBrightnessLevel;
                color |= mBatteryBrightnessLevel << 8;
                color |= mBatteryBrightnessLevel << 16;
            } else {
                color |= mBatteryBrightnessZenLevel;
                color |= mBatteryBrightnessZenLevel << 8;
                color |= mBatteryBrightnessZenLevel << 16;
            }
            ledValues.setColor(color);
        }
    }
    // (applyBrightnessToColor() changes it to 255)
    if (mUseSegmentedBatteryLed) {
        ledValues.setBrightness(brightness);
    }
    if (DEBUG) {
        Slog.i(TAG, "calcLights output: ledValues={ " + ledValues + " }");
    }
}
#method_after
public void calcLights(LedValues ledValues, int level, int status, boolean low) {
    if (DEBUG) {
        Slog.i(TAG, "calcLights input:" + " ledValues={ " + ledValues + " }" + " level=" + level + " status=" + status + " low=" + low + " mCanAdjustBrightness=" + mCanAdjustBrightness + " mHALAdjustableBrightness=" + mHALAdjustableBrightness + " mMultiColorBatteryLed=" + mMultiColorBatteryLed + " mUseSegmentedBatteryLed=" + mUseSegmentedBatteryLed + " mBatteryBrightnessLevel=" + mBatteryBrightnessLevel + " mBatteryBrightnessZenLevel=" + mBatteryBrightnessZenLevel + " mZenMode=" + mZenMode);
    }
    // The only meaningful ledValues values received by frameworks BatteryService
    // are the pulse times (for low battery). Explicitly set enabled state and
    // color to ensure that we arrive at a deterministic outcome.
    ledValues.setEnabled(false);
    ledValues.setColor(0);
    if (!mLightEnabled) {
        return;
    }
    final int brightness;
    if (mUseSegmentedBatteryLed) {
        brightness = level;
    } else if (!mCanAdjustBrightness) {
        // No brightness support available
        brightness = LedValues.LIGHT_BRIGHTNESS_MAXIMUM;
    } else if (mZenMode == Global.ZEN_MODE_OFF) {
        brightness = mBatteryBrightnessLevel;
    } else {
        brightness = mBatteryBrightnessZenLevel;
    }
    ledValues.setBrightness(brightness);
    if (low) {
        if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Battery is charging and low.
            ledValues.setColor(mBatteryLowARGB);
            ledValues.setSolid();
        } else if (mLedPulseEnabled) {
            // Battery is low, not charging and pulse is enabled
            // (pulsing values are set by frameworks BatteryService).
            ledValues.setColor(mBatteryLowARGB);
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            // Battery is full or charging and nearly full.
            ledValues.setColor(mBatteryFullARGB);
            ledValues.setSolid();
        } else {
            // Battery is charging and not nearly full.
            ledValues.setColor(mBatteryMediumARGB);
            ledValues.setSolid();
        }
    }
    // If a color was set, enable light.
    if (ledValues.getColor() != 0) {
        ledValues.setEnabled(true);
    }
    if (mCanAdjustBrightness) {
        if (!mHALAdjustableBrightness) {
            // If lights HAL does not support adjustable brightness then
            // scale color value here instead.
            ledValues.applyAlphaToBrightness();
            ledValues.applyBrightnessToColor();
        } else if (mUseSegmentedBatteryLed && !mMultiColorBatteryLed) {
            // For non-RGB segmented LEDs, we must set the brightness as the
            // color, since the alpha channel contains the battery level
            int segmentLevel = mZenMode == Global.ZEN_MODE_OFF ? mBatteryBrightnessLevel : mBatteryBrightnessZenLevel;
            ledValues.setColor(segmentLevel | (segmentLevel << 8) | (segmentLevel << 16));
        }
    }
    // (applyBrightnessToColor() changes it to 255)
    if (mUseSegmentedBatteryLed) {
        ledValues.setBrightness(brightness);
    }
    if (DEBUG) {
        Slog.i(TAG, "calcLights output: ledValues={ " + ledValues + " }");
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstance) {
    super.onCreate(savedInstance);
    setContentView(R.layout.activity_history);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    toolbar.setNavigationIcon(R.drawable.ic_back);
    toolbar.setNavigationOnClickListener(v -> finish());
    RecyclerView list = (RecyclerView) findViewById(R.id.history_list);
    mEmptyView = findViewById(R.id.history_empty_layout);
    mAdapter = new HistoryAdapter(this, (title, url) -> {
        Snackbar.make(findViewById(R.id.coordinator_layout), R.string.snackbar_history_item_deleted, Snackbar.LENGTH_LONG).setAction(android.R.string.cancel, l -> {
            HistoryProvider.addOrUpdateItem(getContentResolver(), title, url);
        }).show();
    });
    getLoaderManager().initLoader(0, null, new LoaderManager.LoaderCallbacks<Cursor>() {

        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            return new CursorLoader(HistoryActivity.this, HistoryProvider.Columns.CONTENT_URI, null, null, null, HistoryProvider.Columns.TIMESTAMP + " DESC");
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {
            mAdapter.swapCursor(cursor);
        }

        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
            mAdapter.swapCursor(null);
        }
    });
    list.setLayoutManager(new LinearLayoutManager(this));
    list.addItemDecoration(new HistoryAnimationDecorator(this));
    list.setItemAnimator(new DefaultItemAnimator());
    list.setAdapter(mAdapter);
    mAdapter.registerAdapterDataObserver(mAdapterDataObserver);
    ItemTouchHelper helper = new ItemTouchHelper(new HistoryCallBack(this));
    helper.attachToRecyclerView(list);
    int listTop = list.getTop();
    list.addOnScrollListener(new RecyclerView.OnScrollListener() {

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            super.onScrolled(recyclerView, dx, dy);
            boolean elevate = recyclerView.getChildAt(0) != null && recyclerView.getChildAt(0).getTop() < listTop;
            toolbar.setElevation(elevate ? UiUtils.dpToPx(getResources(), getResources().getDimension(R.dimen.toolbar_elevation)) : 0);
        }
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstance) {
    super.onCreate(savedInstance);
    setContentView(R.layout.activity_history);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    toolbar.setNavigationIcon(R.drawable.ic_back);
    toolbar.setNavigationOnClickListener(v -> finish());
    RecyclerView list = (RecyclerView) findViewById(R.id.history_list);
    mEmptyView = findViewById(R.id.history_empty_layout);
    mAdapter = new HistoryAdapter(this);
    getLoaderManager().initLoader(0, null, new LoaderManager.LoaderCallbacks<Cursor>() {

        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            return new CursorLoader(HistoryActivity.this, HistoryProvider.Columns.CONTENT_URI, null, null, null, HistoryProvider.Columns.TIMESTAMP + " DESC");
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {
            mAdapter.swapCursor(cursor);
        }

        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
            mAdapter.swapCursor(null);
        }
    });
    list.setLayoutManager(new LinearLayoutManager(this));
    list.addItemDecoration(new HistoryAnimationDecorator(this));
    list.setItemAnimator(new DefaultItemAnimator());
    list.setAdapter(mAdapter);
    mAdapter.registerAdapterDataObserver(mAdapterDataObserver);
    ItemTouchHelper helper = new ItemTouchHelper(new HistoryCallBack(this, values -> {
        View rootView = findViewById(R.id.coordinator_layout);
        Snackbar.make(rootView, R.string.history_snackbar_item_deleted, Snackbar.LENGTH_LONG).setAction(R.string.history_snackbar_item_deleted_message, l -> {
            getContentResolver().insert(HistoryProvider.Columns.CONTENT_URI, values);
        }).show();
    }));
    helper.attachToRecyclerView(list);
    int listTop = list.getTop();
    list.addOnScrollListener(new RecyclerView.OnScrollListener() {

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            super.onScrolled(recyclerView, dx, dy);
            boolean elevate = recyclerView.getChildAt(0) != null && recyclerView.getChildAt(0).getTop() < listTop;
            toolbar.setElevation(elevate ? UiUtils.dpToPx(getResources(), getResources().getDimension(R.dimen.toolbar_elevation)) : 0);
        }
    });
}
#end_block

#method_before
void bind(final Context context, final long id, final String title, String url, long timestamp, HistoryAdapter.Callback callback) {
    String history_title = title;
    if (history_title == null || history_title.isEmpty()) {
        history_title = url.split("/")[2];
    }
    mTitle.setText(history_title);
    mSummary.setText(new SimpleDateFormat(context.getString(R.string.history_date_format), Locale.getDefault()).format(new Date(timestamp)));
    mRootLayout.setOnClickListener(v -> {
        Intent intent = new Intent(context, MainActivity.class);
        intent.setData(Uri.parse(url));
        context.startActivity(intent);
    });
    mRootLayout.setOnLongClickListener(v -> {
        Uri uri = ContentUris.withAppendedId(HistoryProvider.Columns.CONTENT_URI, id);
        context.getContentResolver().delete(uri, null, null);
        callback.onRemoveItem(title, url);
        return true;
    });
    int background;
    switch(UiUtils.getPositionInTime(timestamp)) {
        case 0:
            background = R.color.history_last_hour;
            break;
        case 1:
            background = R.color.history_today;
            break;
        case 2:
            background = R.color.history_this_week;
            break;
        case 3:
            background = R.color.history_this_month;
            break;
        default:
            background = R.color.history_earlier;
            break;
    }
    mRootLayout.setBackground(new ColorDrawable(ContextCompat.getColor(context, background)));
}
#method_after
void bind(final Context context, String title, String url, String summary, long timestamp) {
    final String historyTitle = TextUtils.isEmpty(title) ? url.split("/")[2] : title;
    mTitle.setText(historyTitle);
    mSummary.setText(summary);
    mRootLayout.setOnClickListener(v -> {
        Intent intent = new Intent(context, MainActivity.class);
        intent.setData(Uri.parse(url));
        context.startActivity(intent);
    });
    int background;
    switch(UiUtils.getPositionInTime(timestamp)) {
        case 0:
            background = R.color.history_last_hour;
            break;
        case 1:
            background = R.color.history_today;
            break;
        case 2:
            background = R.color.history_this_week;
            break;
        case 3:
            background = R.color.history_this_month;
            break;
        default:
            background = R.color.history_earlier;
            break;
    }
    mRootLayout.setBackground(new ColorDrawable(ContextCompat.getColor(context, background)));
}
#end_block

#method_before
@Override
public void onBindViewHolder(HistoryHolder holder, int position) {
    if (!mCursor.moveToPosition(position)) {
        return;
    }
    long id = mCursor.getLong(mIdColumnIndex);
    long timestamp = mCursor.getLong(mTimestampColumnIndex);
    String title = mCursor.getString(mTitleColumnIndex);
    String url = mCursor.getString(mUrlColumnIndex);
    holder.bind(mContext, id, title, url, timestamp, mCallback);
}
#method_after
@Override
public void onBindViewHolder(HistoryHolder holder, int position) {
    if (!mCursor.moveToPosition(position)) {
        return;
    }
    long timestamp = mCursor.getLong(mTimestampColumnIndex);
    String summary = mHistoryDateFormat.format(new Date(timestamp));
    String title = mCursor.getString(mTitleColumnIndex);
    String url = mCursor.getString(mUrlColumnIndex);
    holder.bind(mContext, title, url, summary, timestamp);
}
#end_block

#method_before
@Override
public void onClick(View v) {
    delegate.callRecordClicked(isChecked);
}
#method_after
@Override
public void onClick(View v) {
    delegate.callRecordClicked(!isChecked);
}
#end_block

#method_before
private String getVendorSecurityPatchLevel() {
    String na = getContext().getResources().getString(R.string.not_available);
    String patch = SystemProperties.get(KEY_LINEAGE_VENDOR_SECURITY_PATCH, na);
    if (na.equals(patch)) {
        patch = SystemProperties.get(KEY_AOSP_VENDOR_SECURITY_PATH, na);
    }
    if (!na.equals(patch)) {
        try {
            SimpleDateFormat template = new SimpleDateFormat("yyyy-MM-dd");
            Date patchDate = template.parse(patch);
            String format = DateFormat.getBestDateTimePattern(Locale.getDefault(), "dMMMMyyyy");
            patch = DateFormat.format(format, patchDate).toString();
        } catch (ParseException e) {
        // parsing failed, use raw string
        }
    }
    return patch;
}
#method_after
private String getVendorSecurityPatchLevel() {
    String patchLevel = SystemProperties.get(KEY_AOSP_VENDOR_SECURITY_PATCH);
    if (patchLevel.isEmpty()) {
        patchLevel = SystemProperties.get(KEY_LINEAGE_VENDOR_SECURITY_PATCH);
    }
    if (!patchLevel.isEmpty()) {
        try {
            SimpleDateFormat template = new SimpleDateFormat("yyyy-MM-dd");
            Date patchLevelDate = template.parse(patchLevel);
            String format = DateFormat.getBestDateTimePattern(Locale.getDefault(), "dMMMMyyyy");
            patchLevel = DateFormat.format(format, patchLevelDate).toString();
        } catch (ParseException e) {
        // parsing failed, use raw string
        }
    }
    return patchLevel;
}
#end_block

#method_before
public Notification build(Context context, NotificationModel nm, Stopwatch stopwatch) {
    @StringRes
    final int eventLabel = R.string.label_notification;
    // Intent to load the app when the notification is tapped.
    final Intent showApp = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_SHOW_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
    final PendingIntent pendingShowApp = PendingIntent.getService(context, 0, showApp, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT);
    // Compute some values required below.
    final boolean running = stopwatch.isRunning();
    final String pname = context.getPackageName();
    final Resources res = context.getResources();
    final long base = SystemClock.elapsedRealtime() - stopwatch.getTotalTime();
    final RemoteViews content = new RemoteViews(pname, R.layout.chronometer_notif_content);
    content.setChronometer(R.id.chronometer, base, null, running);
    final List<Action> actions = new ArrayList<>(2);
    if (running) {
        // Left button: Pause
        final Intent pause = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_PAUSE_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
        @DrawableRes
        final int icon1 = R.drawable.ic_pause_24dp;
        final CharSequence title1 = res.getText(R.string.sw_pause_button);
        final PendingIntent intent1 = Utils.pendingServiceIntent(context, pause);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
        // Right button: Add Lap
        if (DataModel.getDataModel().canAddMoreLaps()) {
            final Intent lap = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_LAP_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
            @DrawableRes
            final int icon2 = R.drawable.ic_sw_lap_24dp;
            final CharSequence title2 = res.getText(R.string.sw_lap_button);
            final PendingIntent intent2 = Utils.pendingServiceIntent(context, lap);
            actions.add(new Action.Builder(icon2, title2, intent2).build());
        }
        // Show the current lap number if any laps have been recorded.
        final int lapCount = DataModel.getDataModel().getLaps().size();
        if (lapCount > 0) {
            final int lapNumber = lapCount + 1;
            final String lap = res.getString(R.string.sw_notification_lap_number, lapNumber);
            content.setTextViewText(R.id.state, lap);
            content.setViewVisibility(R.id.state, VISIBLE);
        } else {
            content.setViewVisibility(R.id.state, GONE);
        }
    } else {
        // Left button: Start
        final Intent start = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_START_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
        @DrawableRes
        final int icon1 = R.drawable.ic_start_24dp;
        final CharSequence title1 = res.getText(R.string.sw_start_button);
        final PendingIntent intent1 = Utils.pendingServiceIntent(context, start);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
        // Right button: Reset (dismisses notification and resets stopwatch)
        final Intent reset = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_RESET_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
        @DrawableRes
        final int icon2 = R.drawable.ic_reset_24dp;
        final CharSequence title2 = res.getText(R.string.sw_reset_button);
        final PendingIntent intent2 = Utils.pendingServiceIntent(context, reset);
        actions.add(new Action.Builder(icon2, title2, intent2).build());
        // Indicate the stopwatch is paused.
        content.setTextViewText(R.id.state, res.getString(R.string.swn_paused));
        content.setViewVisibility(R.id.state, VISIBLE);
    }
    final Builder notification = new NotificationCompat.Builder(context).setLocalOnly(true).setOngoing(running).setCustomContentView(content).setContentIntent(pendingShowApp).setAutoCancel(stopwatch.isPaused()).setPriority(Notification.PRIORITY_MAX).setSmallIcon(R.drawable.stat_notify_stopwatch).setStyle(new NotificationCompat.DecoratedCustomViewStyle()).setColor(ContextCompat.getColor(context, R.color.default_background));
    NotificationChannelManager.applyChannel(notification, context, Channel.EVENT_EXPIRED);
    if (Utils.isNOrLater()) {
        notification.setGroup(nm.getStopwatchNotificationGroupKey());
    }
    for (Action action : actions) {
        notification.addAction(action);
    }
    return notification.build();
}
#method_after
public Notification build(Context context, NotificationModel nm, Stopwatch stopwatch) {
    @StringRes
    final int eventLabel = R.string.label_notification;
    // Intent to load the app when the notification is tapped.
    final Intent showApp = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_SHOW_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
    final PendingIntent pendingShowApp = PendingIntent.getService(context, 0, showApp, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT);
    // Compute some values required below.
    final boolean running = stopwatch.isRunning();
    final String pname = context.getPackageName();
    final Resources res = context.getResources();
    final long base = SystemClock.elapsedRealtime() - stopwatch.getTotalTime();
    final RemoteViews content = new RemoteViews(pname, R.layout.chronometer_notif_content);
    content.setChronometer(R.id.chronometer, base, null, running);
    final List<Action> actions = new ArrayList<>(2);
    if (running) {
        // Left button: Pause
        final Intent pause = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_PAUSE_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
        @DrawableRes
        final int icon1 = R.drawable.ic_pause_24dp;
        final CharSequence title1 = res.getText(R.string.sw_pause_button);
        final PendingIntent intent1 = Utils.pendingServiceIntent(context, pause);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
        // Right button: Add Lap
        if (DataModel.getDataModel().canAddMoreLaps()) {
            final Intent lap = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_LAP_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
            @DrawableRes
            final int icon2 = R.drawable.ic_sw_lap_24dp;
            final CharSequence title2 = res.getText(R.string.sw_lap_button);
            final PendingIntent intent2 = Utils.pendingServiceIntent(context, lap);
            actions.add(new Action.Builder(icon2, title2, intent2).build());
        }
        // Show the current lap number if any laps have been recorded.
        final int lapCount = DataModel.getDataModel().getLaps().size();
        if (lapCount > 0) {
            final int lapNumber = lapCount + 1;
            final String lap = res.getString(R.string.sw_notification_lap_number, lapNumber);
            content.setTextViewText(R.id.state, lap);
            content.setViewVisibility(R.id.state, VISIBLE);
        } else {
            content.setViewVisibility(R.id.state, GONE);
        }
    } else {
        // Left button: Start
        final Intent start = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_START_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
        @DrawableRes
        final int icon1 = R.drawable.ic_start_24dp;
        final CharSequence title1 = res.getText(R.string.sw_start_button);
        final PendingIntent intent1 = Utils.pendingServiceIntent(context, start);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
        // Right button: Reset (dismisses notification and resets stopwatch)
        final Intent reset = new Intent(context, StopwatchService.class).setAction(StopwatchService.ACTION_RESET_STOPWATCH).putExtra(Events.EXTRA_EVENT_LABEL, eventLabel);
        @DrawableRes
        final int icon2 = R.drawable.ic_reset_24dp;
        final CharSequence title2 = res.getText(R.string.sw_reset_button);
        final PendingIntent intent2 = Utils.pendingServiceIntent(context, reset);
        actions.add(new Action.Builder(icon2, title2, intent2).build());
        // Indicate the stopwatch is paused.
        content.setTextViewText(R.id.state, res.getString(R.string.swn_paused));
        content.setViewVisibility(R.id.state, VISIBLE);
    }
    final Builder notification = new NotificationCompat.Builder(context).setLocalOnly(true).setOngoing(running).setCustomContentView(content).setContentIntent(pendingShowApp).setAutoCancel(stopwatch.isPaused()).setPriority(Notification.PRIORITY_MAX).setSmallIcon(R.drawable.stat_notify_stopwatch).setStyle(new NotificationCompat.DecoratedCustomViewStyle()).setColor(ContextCompat.getColor(context, R.color.default_background));
    NotificationChannelManager.applyChannel(notification, context, Channel.HIGH_NOTIFICATION);
    if (Utils.isNOrLater()) {
        notification.setGroup(nm.getStopwatchNotificationGroupKey());
    }
    for (Action action : actions) {
        notification.addAction(action);
    }
    return notification.build();
}
#end_block

#method_before
Notification buildHeadsUp(Context context, List<Timer> expired) {
    final Timer timer = expired.get(0);
    // First action intent is to reset all timers.
    @DrawableRes
    final int icon1 = R.drawable.ic_stop_24dp;
    final Intent reset = TimerService.createResetExpiredTimersIntent(context);
    final PendingIntent intent1 = Utils.pendingServiceIntent(context, reset);
    // Generate some descriptive text, a title, and an action name based on the timer count.
    final CharSequence stateText;
    final int count = expired.size();
    final List<Action> actions = new ArrayList<>(2);
    if (count == 1) {
        final String label = timer.getLabel();
        if (TextUtils.isEmpty(label)) {
            stateText = context.getString(R.string.timer_times_up);
        } else {
            stateText = label;
        }
        // Left button: Reset single timer
        final CharSequence title1 = context.getString(R.string.timer_stop);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
        // Right button: Add minute
        final Intent addTime = TimerService.createAddMinuteTimerIntent(context, timer.getId());
        final PendingIntent intent2 = Utils.pendingServiceIntent(context, addTime);
        @DrawableRes
        final int icon2 = R.drawable.ic_add_24dp;
        final CharSequence title2 = context.getString(R.string.timer_plus_1_min);
        actions.add(new Action.Builder(icon2, title2, intent2).build());
    } else {
        stateText = context.getString(R.string.timer_multi_times_up, count);
        // Left button: Reset all timers
        final CharSequence title1 = context.getString(R.string.timer_stop_all);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
    }
    final long base = getChronometerBase(timer);
    final String pname = context.getPackageName();
    // Content intent shows the timer full screen when clicked.
    final Intent content = new Intent(context, ExpiredTimersActivity.class);
    final PendingIntent contentIntent = Utils.pendingActivityIntent(context, content);
    // Full screen intent has flags so it is different than the content intent.
    final Intent fullScreen = new Intent(context, ExpiredTimersActivity.class).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    final PendingIntent pendingFullScreen = Utils.pendingActivityIntent(context, fullScreen);
    final Builder notification = new NotificationCompat.Builder(context).setOngoing(true).setLocalOnly(true).setShowWhen(false).setAutoCancel(false).setContentIntent(contentIntent).setPriority(Notification.PRIORITY_MAX).setDefaults(Notification.DEFAULT_LIGHTS).setSmallIcon(R.drawable.stat_notify_timer).setFullScreenIntent(pendingFullScreen, true).setStyle(new NotificationCompat.DecoratedCustomViewStyle()).setColor(ContextCompat.getColor(context, R.color.default_background));
    for (Action action : actions) {
        notification.addAction(action);
    }
    if (Utils.isNOrLater()) {
        notification.setCustomContentView(buildChronometer(pname, base, true, stateText));
    } else {
        final CharSequence contentTextPreN = count == 1 ? context.getString(R.string.timer_times_up) : context.getString(R.string.timer_multi_times_up, count);
        notification.setContentTitle(stateText).setContentText(contentTextPreN);
    }
    return notification.build();
}
#method_after
Notification buildHeadsUp(Context context, List<Timer> expired) {
    final Timer timer = expired.get(0);
    // First action intent is to reset all timers.
    @DrawableRes
    final int icon1 = R.drawable.ic_stop_24dp;
    final Intent reset = TimerService.createResetExpiredTimersIntent(context);
    final PendingIntent intent1 = Utils.pendingServiceIntent(context, reset);
    // Generate some descriptive text, a title, and an action name based on the timer count.
    final CharSequence stateText;
    final int count = expired.size();
    final List<Action> actions = new ArrayList<>(2);
    if (count == 1) {
        final String label = timer.getLabel();
        if (TextUtils.isEmpty(label)) {
            stateText = context.getString(R.string.timer_times_up);
        } else {
            stateText = label;
        }
        // Left button: Reset single timer
        final CharSequence title1 = context.getString(R.string.timer_stop);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
        // Right button: Add minute
        final Intent addTime = TimerService.createAddMinuteTimerIntent(context, timer.getId());
        final PendingIntent intent2 = Utils.pendingServiceIntent(context, addTime);
        @DrawableRes
        final int icon2 = R.drawable.ic_add_24dp;
        final CharSequence title2 = context.getString(R.string.timer_plus_1_min);
        actions.add(new Action.Builder(icon2, title2, intent2).build());
    } else {
        stateText = context.getString(R.string.timer_multi_times_up, count);
        // Left button: Reset all timers
        final CharSequence title1 = context.getString(R.string.timer_stop_all);
        actions.add(new Action.Builder(icon1, title1, intent1).build());
    }
    final long base = getChronometerBase(timer);
    final String pname = context.getPackageName();
    // Content intent shows the timer full screen when clicked.
    final Intent content = new Intent(context, ExpiredTimersActivity.class);
    final PendingIntent contentIntent = Utils.pendingActivityIntent(context, content);
    // Full screen intent has flags so it is different than the content intent.
    final Intent fullScreen = new Intent(context, ExpiredTimersActivity.class).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    final PendingIntent pendingFullScreen = Utils.pendingActivityIntent(context, fullScreen);
    final Builder notification = new NotificationCompat.Builder(context).setOngoing(true).setLocalOnly(true).setShowWhen(false).setAutoCancel(false).setContentIntent(contentIntent).setPriority(Notification.PRIORITY_MAX).setDefaults(Notification.DEFAULT_LIGHTS).setSmallIcon(R.drawable.stat_notify_timer).setFullScreenIntent(pendingFullScreen, true).setStyle(new NotificationCompat.DecoratedCustomViewStyle()).setColor(ContextCompat.getColor(context, R.color.default_background));
    for (Action action : actions) {
        notification.addAction(action);
    }
    NotificationChannelManager.applyChannel(notification, context, Channel.EVENT_EXPIRED);
    if (Utils.isNOrLater()) {
        notification.setCustomContentView(buildChronometer(pname, base, true, stateText));
    } else {
        final CharSequence contentTextPreN = count == 1 ? context.getString(R.string.timer_times_up) : context.getString(R.string.timer_multi_times_up, count);
        notification.setContentTitle(stateText).setContentText(contentTextPreN);
    }
    return notification.build();
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    final Context applicationContext = getApplicationContext();
    final SharedPreferences prefs = getDefaultSharedPreferences(applicationContext);
    NotificationChannelManager.getInstance().firstInitIfNeeded(this);
    DataModel.getDataModel().init(applicationContext, prefs);
    UiDataModel.getUiDataModel().init(applicationContext, prefs);
    Controller.getController().setContext(applicationContext);
    Controller.getController().addEventTracker(new LogEventTracker(applicationContext));
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    final Context applicationContext = getApplicationContext();
    final SharedPreferences prefs = getDefaultSharedPreferences(applicationContext);
    DataModel.getDataModel().init(applicationContext, prefs);
    UiDataModel.getUiDataModel().init(applicationContext, prefs);
    Controller.getController().setContext(applicationContext);
    Controller.getController().addEventTracker(new LogEventTracker(applicationContext));
}
#end_block

#method_before
@RequiresApi(26)
private NotificationChannel createChannel(Context context, @Channel String channelId) {
    Uri silentRingtone = Uri.EMPTY;
    CharSequence name;
    int importance;
    boolean canShowBadge;
    boolean lights;
    boolean vibration;
    boolean dnd;
    // int lockScreen;
    Uri sound;
    switch(channelId) {
        case Channel.EVENT_EXPIRED:
            name = context.getString(R.string.channel_expired_events);
            importance = NotificationManager.IMPORTANCE_HIGH;
            canShowBadge = false;
            lights = false;
            vibration = false;
            sound = null;
            dnd = true;
            // lockScreen = VISIBILITY_PUBLIC;
            break;
        case Channel.HIGH_NOTIFICATION:
            name = context.getString(R.string.channel_important);
            importance = NotificationManager.IMPORTANCE_HIGH;
            canShowBadge = false;
            lights = false;
            vibration = false;
            sound = null;
            dnd = true;
            // lockScreen = VISIBILITY_PUBLIC;
            break;
        case Channel.DEFAULT_NOTIFICATION:
            name = context.getString(R.string.channel_default);
            importance = NotificationManager.IMPORTANCE_LOW;
            canShowBadge = false;
            lights = false;
            vibration = false;
            sound = null;
            dnd = true;
            // lockScreen = VISIBILITY_PUBLIC;
            break;
        default:
            throw new IllegalArgumentException("Unknown channel: " + channelId);
    }
    NotificationChannel channel = new NotificationChannel(channelId, name, importance);
    channel.setShowBadge(canShowBadge);
    channel.enableVibration(vibration);
    channel.setSound(sound, null);
    channel.enableLights(lights);
    channel.setBypassDnd(dnd);
    // channel.setLockscreenVisibility(lockScreen);
    getNotificationManager(context).createNotificationChannel(channel);
    return channel;
}
#method_after
@RequiresApi(26)
private NotificationChannel createChannel(Context context, @Channel String channelId) {
    Uri silentRingtone = Uri.EMPTY;
    CharSequence name;
    int importance;
    boolean canShowBadge;
    boolean lights;
    boolean vibration;
    boolean dnd;
    Uri sound;
    switch(channelId) {
        case Channel.EVENT_EXPIRED:
            name = context.getString(R.string.channel_expired_events);
            importance = NotificationManager.IMPORTANCE_HIGH;
            canShowBadge = false;
            lights = false;
            vibration = false;
            sound = null;
            dnd = true;
            break;
        case Channel.HIGH_NOTIFICATION:
            name = context.getString(R.string.channel_important);
            importance = NotificationManager.IMPORTANCE_DEFAULT;
            canShowBadge = false;
            lights = false;
            vibration = false;
            sound = null;
            dnd = true;
            break;
        case Channel.DEFAULT_NOTIFICATION:
            name = context.getString(R.string.channel_default);
            importance = NotificationManager.IMPORTANCE_LOW;
            canShowBadge = false;
            lights = false;
            vibration = false;
            sound = null;
            dnd = true;
            break;
        default:
            throw new IllegalArgumentException("Unknown channel: " + channelId);
    }
    NotificationChannel channel = new NotificationChannel(channelId, name, importance);
    channel.setShowBadge(canShowBadge);
    channel.enableVibration(vibration);
    channel.setSound(sound, null);
    channel.enableLights(lights);
    channel.setBypassDnd(dnd);
    getNotificationManager(context).createNotificationChannel(channel);
    return channel;
}
#end_block

#method_before
public static boolean isCompatible(UpdateBaseInfo update) {
    if (update.getTimestamp() < SystemProperties.getLong(Constants.PROP_BUILD_DATE, 0)) {
        Log.d(TAG, update.getName() + " is older than current build");
        return false;
    }
    if (!update.getType().equalsIgnoreCase(SystemProperties.get(Constants.PROP_RELEASE_TYPE))) {
        Log.d(TAG, update.getName() + " has type " + update.getType());
        return false;
    }
    return true;
}
#method_after
public static boolean isCompatible(UpdateBaseInfo update) {
    if (!SystemProperties.getBoolean(Constants.PROP_UPDATER_ALLOW_DOWNGRADING, false) && update.getTimestamp() < SystemProperties.getLong(Constants.PROP_BUILD_DATE, 0)) {
        Log.d(TAG, update.getName() + " is older than current build");
        return false;
    }
    if (!update.getType().equalsIgnoreCase(SystemProperties.get(Constants.PROP_RELEASE_TYPE))) {
        Log.d(TAG, update.getName() + " has type " + update.getType());
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateTrafficDrawableColor() {
    if (mDrawable != null) {
        mDrawable.setColorFilter(mIconTint, PorterDuff.Mode.SRC_ATOP);
    }
}
#method_after
private void updateTrafficDrawableColor() {
    if (mDrawable != null) {
        mDrawable.setColorFilter(mIconTint, PorterDuff.Mode.SRC_ATOP);
    }
    setTextColor(mIconTint);
}
#end_block

#method_before
@Override
public void onStart() {
    mNotificationManager = mContext.getSystemService(NotificationManager.class);
    // Onboard
    if (!hasOnboardedUser()) {
        postOnBoardingNotification();
        return;
    }
    int selinuxStatus = getSELinuxStatus();
    if (selinuxStatus != TrustInterface.TRUST_FEATURE_LEVEL_GOOD) {
        postNotificationForFeatureInternal(TrustInterface.TRUST_FEATURE_SELINUX);
    }
    int debuggingStatus = getDebuggingStatus();
    if (debuggingStatus != TrustInterface.TRUST_FEATURE_LEVEL_GOOD) {
        postNotificationForFeatureInternal(TrustInterface.TRUST_FEATURE_DEBUGGING);
    }
    int keysStatus = getKeysStatus();
    if (keysStatus != TrustInterface.TRUST_FEATURE_LEVEL_GOOD) {
        postNotificationForFeatureInternal(TrustInterface.TRUST_FEATURE_KEYS);
    }
}
#method_after
@Override
public void onStart() {
    mNotificationManager = mContext.getSystemService(NotificationManager.class);
    // Onboard
    if (!hasOnboardedUser()) {
        postOnBoardingNotification();
        return;
    }
    int selinuxStatus = getSELinuxStatus();
    if (selinuxStatus != TrustInterface.TRUST_FEATURE_LEVEL_GOOD) {
        postNotificationForFeatureInternal(TrustInterface.TRUST_FEATURE_SELINUX);
    }
    int keysStatus = getKeysStatus();
    if (keysStatus != TrustInterface.TRUST_FEATURE_LEVEL_GOOD) {
        postNotificationForFeatureInternal(TrustInterface.TRUST_FEATURE_KEYS);
    }
}
#end_block

#method_before
/* Public methods implementation */
private boolean postNotificationForFeatureInternal(int feature) {
    if (!hasOnboardedUser() || !userAllowsTrustNotifications()) {
        return false;
    }
    Pair<Integer, Integer> strings = getNotificationStringsForFeature(feature);
    if (strings == null) {
        return false;
    }
    String title = mContext.getString(strings.first);
    String message = mContext.getString(strings.second);
    Intent intent = new Intent(INTENT_PARTS);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    PendingIntent pIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
    Notification.Builder notification = new Notification.Builder(mContext, CHANNEL_NAME).setContentTitle(title).setContentText(message).setStyle(new Notification.BigTextStyle().bigText(message)).setAutoCancel(true).setContentIntent(pIntent).setColor(mContext.getColor(R.color.color_error)).setSmallIcon(R.drawable.ic_warning);
    createNotificationChannelIfNeeded();
    mNotificationManager.notify(feature, notification.build());
    return true;
}
#method_after
/* Public methods implementation */
private boolean postNotificationForFeatureInternal(int feature) {
    if (!hasOnboardedUser() || !userAllowsTrustNotifications()) {
        return false;
    }
    Pair<Integer, Integer> strings = getNotificationStringsForFeature(feature);
    if (strings == null) {
        return false;
    }
    String title = mContext.getString(strings.first);
    String message = mContext.getString(strings.second);
    String action = mContext.getString(R.string.trust_notification_action_manage);
    Intent mainIntent = new Intent(INTENT_PARTS);
    mainIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    PendingIntent pMainIntent = PendingIntent.getActivity(mContext, 0, mainIntent, 0);
    Intent actionIntent = new Intent(INTENT_PARTS);
    actionIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    actionIntent.putExtra(":settings:fragment_args_key", "trust_category_alerts");
    PendingIntent pActionIntent = PendingIntent.getActivity(mContext, 0, actionIntent, 0);
    Notification.Builder notification = new Notification.Builder(mContext, CHANNEL_NAME).setContentTitle(title).setContentText(message).setStyle(new Notification.BigTextStyle().bigText(message)).setAutoCancel(true).setContentIntent(pMainIntent).addAction(R.drawable.ic_trust_notification_manage, action, pActionIntent).setColor(mContext.getColor(R.color.color_error)).setSmallIcon(R.drawable.ic_warning);
    createNotificationChannelIfNeeded();
    mNotificationManager.notify(feature, notification.build());
    return true;
}
#end_block

#method_before
private int getLevelForFeatureInternal(int feature) {
    switch(feature) {
        case TrustInterface.TRUST_FEATURE_SELINUX:
            return getSELinuxStatus();
        case TrustInterface.TRUST_FEATURE_ROOT:
            return getRootStatus();
        case TrustInterface.TRUST_FEATURE_PLATFORM_SECURITY_PATCH:
            return getSecurityPatchStatus(PLATFORM_SECURITY_PATCHES);
        case TrustInterface.TRUST_FEATURE_VENDOR_SECURITY_PATCH:
            return getSecurityPatchStatus(VENDOR_SECURITY_PATCHES);
        case TrustInterface.TRUST_FEATURE_ENCRYPTION:
            return getEncryptionStatus();
        case TrustInterface.TRUST_FEATURE_DEBUGGING:
            return getDebuggingStatus();
        case TrustInterface.TRUST_FEATURE_KEYS:
            return getKeysStatus();
        default:
            return TrustInterface.ERROR_UNDEFINED;
    }
}
#method_after
private int getLevelForFeatureInternal(int feature) {
    switch(feature) {
        case TrustInterface.TRUST_FEATURE_SELINUX:
            return getSELinuxStatus();
        case TrustInterface.TRUST_FEATURE_ROOT:
            return getRootStatus();
        case TrustInterface.TRUST_FEATURE_PLATFORM_SECURITY_PATCH:
            return getSecurityPatchStatus(PLATFORM_SECURITY_PATCHES);
        case TrustInterface.TRUST_FEATURE_VENDOR_SECURITY_PATCH:
            return getSecurityPatchStatus(VENDOR_SECURITY_PATCHES);
        case TrustInterface.TRUST_FEATURE_ENCRYPTION:
            return getEncryptionStatus();
        case TrustInterface.TRUST_FEATURE_KEYS:
            return getKeysStatus();
        default:
            return TrustInterface.ERROR_UNDEFINED;
    }
}
#end_block

#method_before
private Pair<Integer, Integer> getNotificationStringsForFeature(int feature) {
    int title = 0;
    int message = 0;
    switch(feature) {
        case TrustInterface.TRUST_FEATURE_SELINUX:
            title = R.string.trust_notification_title_security;
            message = R.string.trust_notification_content_selinux;
            break;
        case TrustInterface.TRUST_FEATURE_ROOT:
            title = R.string.trust_notification_title_root;
            message = R.string.trust_notification_content_root;
            break;
        case TrustInterface.TRUST_FEATURE_DEBUGGING:
            title = R.string.trust_notification_title_security;
            message = R.string.trust_notification_content_debugging;
            break;
        case TrustInterface.TRUST_FEATURE_KEYS:
            title = R.string.trust_notification_title_security;
            message = R.string.trust_notification_content_keys;
            break;
    }
    return title == 0 ? null : new Pair(title, message);
}
#method_after
private Pair<Integer, Integer> getNotificationStringsForFeature(int feature) {
    int title = 0;
    int message = 0;
    switch(feature) {
        case TrustInterface.TRUST_FEATURE_SELINUX:
            title = R.string.trust_notification_title_security;
            message = R.string.trust_notification_content_selinux;
            break;
        case TrustInterface.TRUST_FEATURE_ROOT:
            title = R.string.trust_notification_title_root;
            message = R.string.trust_notification_content_root;
            break;
        case TrustInterface.TRUST_FEATURE_KEYS:
            title = R.string.trust_notification_title_security;
            message = R.string.trust_notification_content_keys;
            break;
    }
    return title == 0 ? null : new Pair(title, message);
}
#end_block

#method_before
private int getEncryptionStatus() {
    DevicePolicyManager policyManager = mContext.getSystemService(DevicePolicyManager.class);
    if (policyManager == null) {
        return TrustInterface.ERROR_UNDEFINED;
    }
    boolean isOldDevice = mContext.getResources().getBoolean(R.bool.config_trustLegacyEncryption);
    int status = policyManager.getStorageEncryptionStatus();
    switch(status) {
        case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
        case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:
            return TrustInterface.TRUST_FEATURE_LEVEL_GOOD;
        case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY:
            return TrustInterface.TRUST_FEATURE_LEVEL_POOR;
        case DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE:
            return isOldDevice ? TrustInterface.TRUST_FEATURE_LEVEL_POOR : TrustInterface.TRUST_FEATURE_LEVEL_BAD;
        default:
            return TrustInterface.ERROR_UNDEFINED;
    }
}
#method_after
private int getEncryptionStatus() {
    DevicePolicyManager policyManager = mContext.getSystemService(DevicePolicyManager.class);
    if (policyManager == null) {
        return TrustInterface.ERROR_UNDEFINED;
    }
    boolean isOldDevice = mContext.getResources().getBoolean(R.bool.config_trustLegacyEncryption);
    int status = policyManager.getStorageEncryptionStatus();
    switch(status) {
        case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
        case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:
            return TrustInterface.TRUST_FEATURE_LEVEL_GOOD;
        case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY:
            return TrustInterface.TRUST_FEATURE_LEVEL_POOR;
        case DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE:
            return isOldDevice ? TrustInterface.TRUST_FEATURE_LEVEL_POOR : TrustInterface.TRUST_FEATURE_LEVEL_BAD;
        case DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED:
            return TrustInterface.TRUST_FEATURE_LEVEL_BAD;
        default:
            return TrustInterface.ERROR_UNDEFINED;
    }
}
#end_block

#method_before
private int getKeysStatus() {
    if (mBuildTags.contains("test-keys")) {
        return TrustInterface.TRUST_FEATURE_LEVEL_BAD;
    }
    if (mBuildTags.contains("release-keys")) {
        return TrustInterface.TRUST_FEATURE_LEVEL_GOOD;
    }
    return TrustInterface.ERROR_UNDEFINED;
}
#method_after
private int getKeysStatus() {
    String buildTags = SystemProperties.get("ro.build.tags");
    if (buildTags.contains("test-keys")) {
        return TrustInterface.TRUST_FEATURE_LEVEL_BAD;
    } else if (buildTags.contains("release-keys") || buildTags.contains("dev-keys")) {
        return TrustInterface.TRUST_FEATURE_LEVEL_GOOD;
    }
    return TrustInterface.ERROR_UNDEFINED;
}
#end_block

#method_before
public void retainPassword(String password) {
    if (LockPatternUtils.isDeviceEncryptionEnabled()) {
        if (password != null) {
            mSavePassword = password;
        } else {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }
}
#method_after
public void retainPassword(String password) {
    if (LockPatternUtils.isDeviceEncryptionEnabled()) {
        if (password != null) {
            sSavePassword = password;
        } else {
            sSavePassword = DEFAULT_PASSWORD;
        }
    }
}
#end_block

#method_before
public void sanitizePassword() {
    if (LockPatternUtils.isDeviceEncryptionEnabled()) {
        mSavePassword = DEFAULT_PASSWORD;
    }
}
#method_after
public void sanitizePassword() {
    if (LockPatternUtils.isDeviceEncryptionEnabled()) {
        sSavePassword = DEFAULT_PASSWORD;
    }
}
#end_block

#method_before
private boolean checkCryptKeeperPermissions() {
    boolean permission_err = false;
    try {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CRYPT_KEEPER, "no permission to get the password");
    } catch (SecurityException e) {
        permission_err = true;
    }
    return permission_err;
}
#method_after
private boolean checkCryptKeeperPermissions() {
    try {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CRYPT_KEEPER, "no permission to get the password");
    } catch (SecurityException e) {
        return true;
    }
    return false;
}
#end_block

#method_before
public String getPassword() {
    /**
     * if calling process does't have crypt keeper or admin permissions,
     * throw the exception.
     */
    if (checkCryptKeeperPermissions())
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_DEVICE_ADMINS, "no crypt_keeper or admin permission to get the password");
    return mSavePassword;
}
#method_after
public String getPassword() {
    /**
     * If calling process does't have crypt keeper or admin permissions,
     * throw the exception.
     */
    if (checkCryptKeeperPermissions()) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_DEVICE_ADMINS, "no crypt_keeper or admin permission to get the password");
    }
    return sSavePassword;
}
#end_block

#method_before
@Override
public void setPrimary(String number, String name, boolean nameIsNumber, String label, Drawable photo, boolean isSipCall, boolean isForwarded, boolean isContactPhotoShown, boolean isWorkCall) {
    Log.d(this, "Setting primary call");
    // set the name field.
    setPrimaryName(name, nameIsNumber);
    boolean isScreenLarge = IsLargeScreen();
    if (TextUtils.isEmpty(number) && TextUtils.isEmpty(label)) {
        mCallNumberAndLabel.setVisibility(View.GONE);
        if (!isScreenLarge) {
            mElapsedTime.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        }
    } else {
        mCallNumberAndLabel.setVisibility(View.VISIBLE);
        if (!isScreenLarge) {
            mElapsedTime.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
        }
    }
    setPrimaryPhoneNumber(number);
    // Set the label (Mobile, Work, etc)
    setPrimaryLabel(label);
    showCallType(isSipCall, isForwarded);
    setDrawableToImageViews(photo);
    showImageView(mPhotoLarge, isContactPhotoShown);
    showImageView(mWorkProfileIcon, isWorkCall);
}
#method_after
@Override
public void setPrimary(String number, String name, boolean nameIsNumber, String label, Drawable photo, boolean isSipCall, boolean isForwarded, boolean isContactPhotoShown, boolean isWorkCall) {
    Log.d(this, "Setting primary call");
    // set the name field.
    setPrimaryName(name, nameIsNumber);
    boolean elapsedTimeSingleLine = getResources().getBoolean(R.bool.caller_name_and_elapsed_time_in_one_line);
    if (TextUtils.isEmpty(number) && TextUtils.isEmpty(label)) {
        mCallNumberAndLabel.setVisibility(View.GONE);
        mElapsedTime.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
    } else {
        mCallNumberAndLabel.setVisibility(View.VISIBLE);
        if (elapsedTimeSingleLine) {
            mElapsedTime.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
        }
    }
    setPrimaryPhoneNumber(number);
    // Set the label (Mobile, Work, etc)
    setPrimaryLabel(label);
    showCallType(isSipCall, isForwarded);
    setDrawableToImageViews(photo);
    showImageView(mPhotoLarge, isContactPhotoShown);
    showImageView(mWorkProfileIcon, isWorkCall);
}
#end_block

#method_before
/**
 * Computes the bounds to fit the Activity within the bounds of the {@link Configuration}.
 */
private void computeBounds(Rect outBounds) {
    outBounds.setEmpty();
    float maxAspectRatio = info.maxAspectRatio;
    if (appInfo.targetSdkVersion < O && mLongScreen.isSupported() && mLongScreen.getApps().contains(packageName)) {
        maxAspectRatio = 0.0f;
    }
    final ActivityStack stack = getStack();
    if (task == null || stack == null || !task.mFullscreen || maxAspectRatio == 0 || isInVrUiMode(getConfiguration())) {
        // if we are in VR mode.
        return;
    }
    // We must base this on the parent configuration, because we set our override
    // configuration's appBounds based on the result of this method. If we used our own
    // configuration, it would be influenced by past invocations.
    final Configuration configuration = getParent().getConfiguration();
    final int containingAppWidth = configuration.appBounds.width();
    final int containingAppHeight = configuration.appBounds.height();
    int maxActivityWidth = containingAppWidth;
    int maxActivityHeight = containingAppHeight;
    if (containingAppWidth < containingAppHeight) {
        // Width is the shorter side, so we use that to figure-out what the max. height
        // should be given the aspect ratio.
        maxActivityHeight = (int) ((maxActivityWidth * maxAspectRatio) + 0.5f);
    } else {
        // Height is the shorter side, so we use that to figure-out what the max. width
        // should be given the aspect ratio.
        maxActivityWidth = (int) ((maxActivityHeight * maxAspectRatio) + 0.5f);
    }
    if (containingAppWidth <= maxActivityWidth && containingAppHeight <= maxActivityHeight) {
        // The display matches or is less than the activity aspect ratio, so nothing else to do.
        // Return the existing bounds. If this method is running for the first time,
        // {@link mBounds} will be empty (representing no override). If the method has run
        // before, then effect of {@link mBounds} will already have been applied to the
        // value returned from {@link getConfiguration}. Refer to
        // {@link TaskRecord#computeOverrideConfiguration}.
        outBounds.set(mBounds);
        return;
    }
    // Compute configuration based on max supported width and height.
    outBounds.set(0, 0, maxActivityWidth, maxActivityHeight);
    // Position the activity frame on the opposite side of the nav bar.
    final int navBarPosition = service.mWindowManager.getNavBarPosition();
    final int left = navBarPosition == NAV_BAR_LEFT ? configuration.appBounds.right - outBounds.width() : 0;
    outBounds.offsetTo(left, 0);
}
#method_after
/**
 * Computes the bounds to fit the Activity within the bounds of the {@link Configuration}.
 */
private void computeBounds(Rect outBounds) {
    outBounds.setEmpty();
    final float maxAspectRatio = info.maxAspectRatio;
    final ActivityStack stack = getStack();
    if (task == null || stack == null || !task.mFullscreen || maxAspectRatio == 0 || isInVrUiMode(getConfiguration())) {
        // if we are in VR mode.
        return;
    }
    // We must base this on the parent configuration, because we set our override
    // configuration's appBounds based on the result of this method. If we used our own
    // configuration, it would be influenced by past invocations.
    final Configuration configuration = getParent().getConfiguration();
    final int containingAppWidth = configuration.appBounds.width();
    final int containingAppHeight = configuration.appBounds.height();
    int maxActivityWidth = containingAppWidth;
    int maxActivityHeight = containingAppHeight;
    if (service.shouldForceLongScreen(packageName)) {
    // Use containingAppWidth/Height for maxActivityWidth/Height when force long screen
    } else if (containingAppWidth < containingAppHeight) {
        // Width is the shorter side, so we use that to figure-out what the max. height
        // should be given the aspect ratio.
        maxActivityHeight = (int) ((maxActivityWidth * maxAspectRatio) + 0.5f);
    } else {
        // Height is the shorter side, so we use that to figure-out what the max. width
        // should be given the aspect ratio.
        maxActivityWidth = (int) ((maxActivityHeight * maxAspectRatio) + 0.5f);
    }
    if (containingAppWidth <= maxActivityWidth && containingAppHeight <= maxActivityHeight) {
        // The display matches or is less than the activity aspect ratio, so nothing else to do.
        // Return the existing bounds. If this method is running for the first time,
        // {@link mBounds} will be empty (representing no override). If the method has run
        // before, then effect of {@link mBounds} will already have been applied to the
        // value returned from {@link getConfiguration}. Refer to
        // {@link TaskRecord#computeOverrideConfiguration}.
        outBounds.set(mBounds);
        return;
    }
    // Compute configuration based on max supported width and height.
    outBounds.set(0, 0, maxActivityWidth, maxActivityHeight);
    // Position the activity frame on the opposite side of the nav bar.
    final int navBarPosition = service.mWindowManager.getNavBarPosition();
    final int left = navBarPosition == NAV_BAR_LEFT ? configuration.appBounds.right - outBounds.width() : 0;
    outBounds.offsetTo(left, 0);
}
#end_block

#method_before
@Override
protected ResultContainer doInBackground(final String... params) {
    if (isCancelled()) {
        return null;
    }
    Bitmap bitmap = getBitmapInBackground(params);
    ResultContainer result = new ResultContainer();
    Bitmap output = null;
    if (bitmap != null) {
        // now create the blur bitmap
        Bitmap input = bitmap;
        // if the image is too small, scale it up before running through the blur
        if (input.getWidth() < MIN_BITMAP_SIZE || input.getHeight() < MIN_BITMAP_SIZE) {
            float multiplier = Math.max(MIN_BITMAP_SIZE / (float) input.getWidth(), MIN_BITMAP_SIZE / (float) input.getHeight());
            input = input.createScaledBitmap(bitmap, (int) (input.getWidth() * multiplier), (int) (input.getHeight() * multiplier), true);
            // since we created a new bitmap, we can re-use the bitmap for our output
            output = input;
        } else {
            // if we aren't creating a new bitmap, create a new output bitmap
            output = Bitmap.createBitmap(input.getWidth(), input.getHeight(), input.getConfig());
        }
        // run the blur multiple times
        for (int i = 0; i < NUM_BLUR_RUNS; i++) {
            try {
                final Allocation inputAlloc = Allocation.createFromBitmap(mRenderScript, input);
                final Allocation outputAlloc = Allocation.createTyped(mRenderScript, inputAlloc.getType());
                final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(mRenderScript, Element.U8_4(mRenderScript));
                script.setRadius(BLUR_RADIUS);
                script.setInput(inputAlloc);
                script.forEach(outputAlloc);
                outputAlloc.copyTo(output);
                // if we run more than 1 blur, the new input should be the old output
                input = output;
            } catch (RuntimeException e) {
            // unsupported bitmap type
            }
        }
        // Set the scrim color to be 50% gray
        result.mPaletteColor = 0x7f000000;
        // create the bitmap transition drawable
        result.mImageViewBitmapDrawable = createImageTransitionDrawable(output, ImageWorker.FADE_IN_TIME_SLOW, true, true);
        return result;
    }
    return null;
}
#method_after
@Override
protected ResultContainer doInBackground(final String... params) {
    if (isCancelled()) {
        return null;
    }
    Bitmap bitmap = getBitmapInBackground(params);
    ResultContainer result = new ResultContainer();
    Bitmap output = null;
    if (bitmap != null) {
        // now create the blur bitmap
        Bitmap input = bitmap;
        // if the image is too small, scale it up before running through the blur
        if (input.getWidth() < MIN_BITMAP_SIZE || input.getHeight() < MIN_BITMAP_SIZE) {
            float multiplier = Math.max(MIN_BITMAP_SIZE / (float) input.getWidth(), MIN_BITMAP_SIZE / (float) input.getHeight());
            input = input.createScaledBitmap(bitmap, (int) (input.getWidth() * multiplier), (int) (input.getHeight() * multiplier), true);
            // since we created a new bitmap, we can re-use the bitmap for our output
            output = input;
        } else {
            // if we aren't creating a new bitmap, create a new output bitmap
            output = Bitmap.createBitmap(input.getWidth(), input.getHeight(), input.getConfig());
        }
        // run the blur multiple times
        for (int i = 0; i < NUM_BLUR_RUNS; i++) {
            try {
                final Allocation inputAlloc = Allocation.createFromBitmap(mRenderScript, input);
                final Allocation outputAlloc = Allocation.createTyped(mRenderScript, inputAlloc.getType());
                final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(mRenderScript, Element.U8_4(mRenderScript));
                script.setRadius(BLUR_RADIUS);
                script.setInput(inputAlloc);
                script.forEach(outputAlloc);
                outputAlloc.copyTo(output);
                // if we run more than 1 blur, the new input should be the old output
                input = output;
            } catch (RuntimeException e) {
                Log.w(TAG, "Cannot blur image. " + e.getMessage());
                break;
            }
        }
        // Set the scrim color to be 50% gray
        result.mPaletteColor = 0x7f000000;
        // create the bitmap transition drawable
        result.mImageViewBitmapDrawable = createImageTransitionDrawable(output, ImageWorker.FADE_IN_TIME_SLOW, true, true);
        return result;
    }
    return null;
}
#end_block

#method_before
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
private void refreshCustomApplicationPrefs() {
    Context context = getActivity();
    if (!parsePackageList()) {
        return;
    }
    // Add the Application Preferences
    if (mApplicationPrefList != null) {
        mApplicationPrefList.removeAll();
        for (Package pkg : mPackages.values()) {
            try {
                PackageInfo info = mPackageManager.getPackageInfo(pkg.name, PackageManager.GET_META_DATA);
                ApplicationLightPreference pref = new ApplicationLightPreference(context, null, pkg.color, pkg.timeon, pkg.timeoff);
                pref.setKey(pkg.name);
                pref.setTitle(info.applicationInfo.loadLabel(mPackageManager));
                pref.setIcon(info.applicationInfo.loadIcon(mPackageManager));
                pref.setPersistent(false);
                pref.setOnPreferenceChangeListener(this);
                pref.setOnLongClickListener(this);
                mApplicationPrefList.addPreference(pref);
            } catch (NameNotFoundException e) {
            // Do nothing
            }
        }
        /* Display a pref explaining how to add apps */
        if (mApplicationPrefList.getPreferenceCount() == 0) {
            String summary = getResources().getString(R.string.notification_light_no_apps_summary);
            String useCustom = getResources().getString(R.string.notification_light_use_custom);
            Preference pref = new Preference(context);
            pref.setSummary(String.format(summary, useCustom));
            pref.setEnabled(false);
            mApplicationPrefList.addPreference(pref);
        }
    }
}
#method_after
private void refreshCustomApplicationPrefs() {
    Context context = getActivity();
    if (!parsePackageList()) {
        maybeDisplayApplicationHint(context);
        return;
    }
    // Add the Application Preferences
    if (mApplicationPrefList != null) {
        mApplicationPrefList.removeAll();
        for (Package pkg : mPackages.values()) {
            try {
                PackageInfo info = mPackageManager.getPackageInfo(pkg.name, PackageManager.GET_META_DATA);
                ApplicationLightPreference pref = new ApplicationLightPreference(context, null, pkg.color, pkg.timeon, pkg.timeoff);
                pref.setKey(pkg.name);
                pref.setTitle(info.applicationInfo.loadLabel(mPackageManager));
                pref.setIcon(info.applicationInfo.loadIcon(mPackageManager));
                pref.setPersistent(false);
                pref.setOnPreferenceChangeListener(this);
                pref.setOnLongClickListener(this);
                mApplicationPrefList.addPreference(pref);
            } catch (NameNotFoundException e) {
            // Do nothing
            }
        }
        maybeDisplayApplicationHint(context);
    }
}
#end_block

#method_before
public static boolean isEnabled() {
    try {
        if (sHasNativeSupport) {
            return LiveDisplayVendorImpl.getInstance().native_isAdaptiveBacklightEnabled();
        }
        return Integer.parseInt(FileUtils.readOneLine(FILE_CABC)) > 0;
    } catch (Exception e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return false;
}
#method_after
public static boolean isEnabled() {
    try {
        if (sHasNativeSupport) {
            return LiveDisplayVendorImpl.getInstance().isAdaptiveBacklightEnabled();
        }
        return Integer.parseInt(FileUtils.readOneLine(FILE_CABC)) > 0;
    } catch (Exception e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return false;
}
#end_block

#method_before
public static boolean setEnabled(boolean status) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_setAdaptiveBacklightEnabled(status);
    }
    return FileUtils.writeLine(FILE_CABC, status ? "1" : "0");
}
#method_after
public static boolean setEnabled(boolean status) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().setAdaptiveBacklightEnabled(status);
    }
    return FileUtils.writeLine(FILE_CABC, status ? "1" : "0");
}
#end_block

#method_before
public static DisplayMode[] getAvailableModes() {
    if (!sHasNativeSupport) {
        return new DisplayMode[0];
    }
    return LiveDisplayVendorImpl.getInstance().native_getDisplayModes();
}
#method_after
public static DisplayMode[] getAvailableModes() {
    if (!sHasNativeSupport) {
        return new DisplayMode[0];
    }
    return LiveDisplayVendorImpl.getInstance().getDisplayModes();
}
#end_block

#method_before
public static DisplayMode getCurrentMode() {
    if (!sHasNativeSupport) {
        return null;
    }
    return LiveDisplayVendorImpl.getInstance().native_getCurrentDisplayMode();
}
#method_after
public static DisplayMode getCurrentMode() {
    if (!sHasNativeSupport) {
        return null;
    }
    return LiveDisplayVendorImpl.getInstance().getCurrentDisplayMode();
}
#end_block

#method_before
public static boolean setMode(DisplayMode mode, boolean makeDefault) {
    if (!sHasNativeSupport) {
        return false;
    }
    return LiveDisplayVendorImpl.getInstance().native_setDisplayMode(mode, makeDefault);
}
#method_after
public static boolean setMode(DisplayMode mode, boolean makeDefault) {
    if (!sHasNativeSupport) {
        return false;
    }
    return LiveDisplayVendorImpl.getInstance().setDisplayMode(mode, makeDefault);
}
#end_block

#method_before
public static DisplayMode getDefaultMode() {
    if (!sHasNativeSupport) {
        return null;
    }
    return LiveDisplayVendorImpl.getInstance().native_getDefaultDisplayMode();
}
#method_after
public static DisplayMode getDefaultMode() {
    if (!sHasNativeSupport) {
        return null;
    }
    return LiveDisplayVendorImpl.getInstance().getDefaultDisplayMode();
}
#end_block

#method_before
private synchronized IColor getColorService() {
    if (mDaemon == null) {
        Log.v(TAG, "mDaemon was null, reconnect to livedisplay IColor");
        try {
            mDaemon = IColor.getService();
        } catch (java.util.NoSuchElementException e) {
        // Service doesn't exist or cannot be opened. Logged below.
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to get livedisplay IColor interface", e);
        }
        if (mDaemon == null) {
            Log.w(TAG, "livedisplay IColor HIDL not available");
            return null;
        }
        mDaemon.asBinder().linkToDeath(this, 0);
    }
    return mDaemon;
}
#method_after
private synchronized IColor getColorService() {
    if (mDaemon == null) {
        Log.v(TAG, "mDaemon was null, reconnect to LiveDisplay IColor");
        try {
            mDaemon = IColor.getService();
        } catch (java.util.NoSuchElementException e) {
        // Service doesn't exist or cannot be opened. Logged below.
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to get LiveDisplay IColor interface", e);
        }
        if (mDaemon == null) {
            Log.w(TAG, "LiveDisplay IColor HIDL not available");
            return null;
        }
        mDaemon.asBinder().linkToDeath(new DeathRecipient() {

            @Override
            public void serviceDied(long cookie) {
                Log.e(TAG, "LiveDisplay IColor HAL died");
                reset();
            }
        }, 0);
    }
    return mDaemon;
}
#end_block

#method_before
private void reset() {
    sFeatures = 0;
    synchronized (this) {
        mDaemon = null;
    }
}
#method_after
private void reset() {
    mFeatures = 0;
    synchronized (this) {
        mDaemon = null;
    }
}
#end_block

#method_before
public boolean hasNativeFeature(int feature) {
    if (sFeatures == 0) {
        IColor daemon = getColorService();
        if (daemon == null) {
            Log.e(TAG, "hasNativeFeature: no livedisplay IColor HAL!");
            return false;
        }
        try {
            sFeatures = daemon.getSupportedFeatures();
            if (sFeatures > 0) {
                Log.i(TAG, "Using livedisplay IColor backend (features: " + sFeatures + ")");
            }
        } catch (RemoteException e) {
            Log.e(TAG, "hasNativeFeature failed", e);
            return false;
        }
    }
    Log.d(TAG, "hasNativeFeature: sFeatures=" + Integer.toString(sFeatures));
    return (sFeatures & feature) != 0;
}
#method_after
public boolean hasNativeFeature(int feature) {
    if (mFeatures == 0) {
        IColor daemon = getColorService();
        if (daemon == null) {
            Log.e(TAG, "hasNativeFeature: no LiveDisplay IColor HAL!");
            return false;
        }
        try {
            mFeatures = daemon.getSupportedFeatures();
            Log.i(TAG, "Using LiveDisplay IColor backend (features: " + mFeatures + ")");
        } catch (RemoteException e) {
            Log.e(TAG, "hasNativeFeature failed", e);
            reset();
            return false;
        }
    }
    Log.d(TAG, "hasNativeFeature: mFeatures=" + Integer.toString(mFeatures));
    return (mFeatures & feature) != 0;
}
#end_block

#method_before
public static int getValue() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getColorBalance();
    }
    return 0;
}
#method_after
public static int getValue() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getColorBalance();
    }
    return 0;
}
#end_block

#method_before
public static boolean setValue(int value) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_setColorBalance(value);
    }
    return false;
}
#method_after
public static boolean setValue(int value) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().setColorBalance(value);
    }
    return false;
}
#end_block

#method_before
public static int getMinValue() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getColorBalanceRange().getLower();
    }
    return 0;
}
#method_after
public static int getMinValue() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getColorBalanceRange().getLower();
    }
    return 0;
}
#end_block

#method_before
public static int getMaxValue() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getColorBalanceRange().getUpper();
    }
    return 0;
}
#method_after
public static int getMaxValue() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getColorBalanceRange().getUpper();
    }
    return 0;
}
#end_block

#method_before
public static HSIC getHSIC() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getPictureAdjustment();
    }
    return null;
}
#method_after
public static HSIC getHSIC() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getPictureAdjustment();
    }
    return null;
}
#end_block

#method_before
public static HSIC getDefaultHSIC() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getDefaultPictureAdjustment();
    }
    return null;
}
#method_after
public static HSIC getDefaultHSIC() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getDefaultPictureAdjustment();
    }
    return null;
}
#end_block

#method_before
public static boolean setHSIC(final HSIC hsic) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_setPictureAdjustment(hsic);
    }
    return false;
}
#method_after
public static boolean setHSIC(final HSIC hsic) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().setPictureAdjustment(hsic);
    }
    return false;
}
#end_block

#method_before
public static Range<Float> getHueRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getHueRange();
    }
    return new Range(0.0f, 0.0f);
}
#method_after
public static Range<Float> getHueRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getHueRange();
    }
    return new Range(0.0f, 0.0f);
}
#end_block

#method_before
public static Range<Float> getSaturationRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getSaturationRange();
    }
    return new Range(0.0f, 0.0f);
}
#method_after
public static Range<Float> getSaturationRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getSaturationRange();
    }
    return new Range(0.0f, 0.0f);
}
#end_block

#method_before
public static Range<Float> getIntensityRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getIntensityRange();
    }
    return new Range(0.0f, 0.0f);
}
#method_after
public static Range<Float> getIntensityRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getIntensityRange();
    }
    return new Range(0.0f, 0.0f);
}
#end_block

#method_before
public static Range<Float> getContrastRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getContrastRange();
    }
    return new Range(0.0f, 0.0f);
}
#method_after
public static Range<Float> getContrastRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getContrastRange();
    }
    return new Range(0.0f, 0.0f);
}
#end_block

#method_before
public static Range<Float> getSaturationThresholdRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_getSaturationThresholdRange();
    }
    return new Range(0.0f, 0.0f);
}
#method_after
public static Range<Float> getSaturationThresholdRange() {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().getSaturationThresholdRange();
    }
    return new Range(0.0f, 0.0f);
}
#end_block

#method_before
public static boolean isEnabled() {
    try {
        if (sHasNativeSupport) {
            return LiveDisplayVendorImpl.getInstance().native_isOutdoorModeEnabled();
        }
        return Integer.parseInt(FileUtils.readOneLine(FACEMELT_PATH)) > 0;
    } catch (Exception e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return false;
}
#method_after
public static boolean isEnabled() {
    try {
        if (sHasNativeSupport) {
            return LiveDisplayVendorImpl.getInstance().isOutdoorModeEnabled();
        }
        return Integer.parseInt(FileUtils.readOneLine(FACEMELT_PATH)) > 0;
    } catch (Exception e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return false;
}
#end_block

#method_before
public static boolean setEnabled(boolean status) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().native_setOutdoorModeEnabled(status);
    }
    return FileUtils.writeLine(FACEMELT_PATH, status ? FACEMELT_MODE : "0");
}
#method_after
public static boolean setEnabled(boolean status) {
    if (sHasNativeSupport) {
        return LiveDisplayVendorImpl.getInstance().setOutdoorModeEnabled(status);
    }
    return FileUtils.writeLine(FACEMELT_PATH, status ? FACEMELT_MODE : "0");
}
#end_block

#method_before
// Binder call
@Override
public void cancelAuthentication(final IBinder token, final String opPackageName) {
    final int callingUid = Binder.getCallingUid();
    final int callingPid = Binder.getCallingPid();
    final int callingUserId = UserHandle.getCallingUserId();
    if (!canUseFingerprint(opPackageName, true, /* foregroundOnly */
    callingUid, callingPid, callingUserId)) {
        if (DEBUG)
            Slog.v(TAG, "cancelAuthentication(): reject " + opPackageName);
        return;
    }
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            ClientMonitor client = mCurrentClient;
            if (client instanceof AuthenticationClient) {
                if (client.getToken() == token) {
                    if (DEBUG)
                        Slog.v(TAG, "stop client " + client.getOwnerString());
                    final boolean notifyClient = mContext.getResources().getBoolean(com.android.internal.R.bool.config_notifyClientOnFingerprintCancelSuccess);
                    final int stopResult = client.stop(client.getToken() == token);
                    if (notifyClient && (stopResult == 0)) {
                        handleError(mHalDeviceId, FingerprintManager.FINGERPRINT_ERROR_CANCELED, 0);
                    }
                } else {
                    if (DEBUG)
                        Slog.v(TAG, "can't stop client " + client.getOwnerString() + " since tokens don't match");
                }
            } else if (client != null) {
                if (DEBUG)
                    Slog.v(TAG, "can't cancel non-authenticating client " + client.getOwnerString());
            }
        }
    });
}
#method_after
// Binder call
@Override
public void cancelAuthentication(final IBinder token, final String opPackageName) {
    final int callingUid = Binder.getCallingUid();
    final int callingPid = Binder.getCallingPid();
    final int callingUserId = UserHandle.getCallingUserId();
    if (!canUseFingerprint(opPackageName, true, /* foregroundOnly */
    callingUid, callingPid, callingUserId)) {
        if (DEBUG)
            Slog.v(TAG, "cancelAuthentication(): reject " + opPackageName);
        return;
    }
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            ClientMonitor client = mCurrentClient;
            if (client instanceof AuthenticationClient) {
                if (client.getToken() == token) {
                    if (DEBUG)
                        Slog.v(TAG, "stop client " + client.getOwnerString());
                    final int stopResult = client.stop(client.getToken() == token);
                    if (mNotifyClient && (stopResult == 0)) {
                        handleError(mHalDeviceId, FingerprintManager.FINGERPRINT_ERROR_CANCELED, 0);
                    }
                } else {
                    if (DEBUG)
                        Slog.v(TAG, "can't stop client " + client.getOwnerString() + " since tokens don't match");
                }
            } else if (client != null) {
                if (DEBUG)
                    Slog.v(TAG, "can't cancel non-authenticating client " + client.getOwnerString());
            }
        }
    });
}
#end_block

#method_before
public String[] getCameraIdList() {
    String[] cameraIds = null;
    synchronized (mLock) {
        // Try to make sure we have an up-to-date list of camera devices.
        connectCameraServiceLocked();
        boolean exposeAuxCamera = false;
        String packageName = ActivityThread.currentOpPackageName();
        String packageList = SystemProperties.get("vendor.camera.aux.packagelist");
        if (packageList.length() > 0) {
            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
            splitter.setString(packageList);
            for (String str : splitter) {
                if (packageName.equals(str)) {
                    exposeAuxCamera = true;
                    break;
                }
            }
        }
        int idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            if (!exposeAuxCamera && (i == 2))
                break;
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            idCount++;
        }
        cameraIds = new String[idCount];
        idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            if (!exposeAuxCamera && (i == 2))
                break;
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            cameraIds[idCount] = mDeviceStatus.keyAt(i);
            idCount++;
        }
    }
    return cameraIds;
}
#method_after
public String[] getCameraIdList() {
    String[] cameraIds = null;
    synchronized (mLock) {
        // Try to make sure we have an up-to-date list of camera devices.
        connectCameraServiceLocked();
        int idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            if ((i == 2) && !Camera.shouldExposeAuxCamera())
                break;
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            idCount++;
        }
        cameraIds = new String[idCount];
        idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            if ((i == 2) && !Camera.shouldExposeAuxCamera())
                break;
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            cameraIds[idCount] = mDeviceStatus.keyAt(i);
            idCount++;
        }
    }
    return cameraIds;
}
#end_block

#method_before
private void onStatusChangedLocked(int status, String id) {
    /* Force to ignore the last mono/aux camera status update
             * if the package name does not falls in this bucket
             */
    boolean exposeMonoCamera = false;
    String packageName = ActivityThread.currentOpPackageName();
    String packageList = SystemProperties.get("vendor.camera.aux.packagelist");
    if (packageList.length() > 0) {
        TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
        splitter.setString(packageList);
        for (String str : splitter) {
            if (packageName.equals(str)) {
                exposeMonoCamera = true;
                break;
            }
        }
    }
    if (exposeMonoCamera == false) {
        if (Integer.parseInt(id) >= 2) {
            Log.w(TAG, "[soar.cts] ignore the status update of camera: " + id);
            return;
        }
    }
    if (DEBUG) {
        Log.v(TAG, String.format("Camera id %s has status changed to 0x%x", id, status));
    }
    if (!validStatus(status)) {
        Log.e(TAG, String.format("Ignoring invalid device %s status 0x%x", id, status));
        return;
    }
    Integer oldStatus = mDeviceStatus.put(id, status);
    if (oldStatus != null && oldStatus == status) {
        if (DEBUG) {
            Log.v(TAG, String.format("Device status changed to 0x%x, which is what it already was", status));
        }
        return;
    }
    // not available -> not available => no new update
    if (oldStatus != null && isAvailable(status) == isAvailable(oldStatus)) {
        if (DEBUG) {
            Log.v(TAG, String.format("Device status was previously available (%b), " + " and is now again available (%b)" + "so no new client visible update will be sent", isAvailable(oldStatus), isAvailable(status)));
        }
        return;
    }
    final int callbackCount = mCallbackMap.size();
    for (int i = 0; i < callbackCount; i++) {
        Handler handler = mCallbackMap.valueAt(i);
        final AvailabilityCallback callback = mCallbackMap.keyAt(i);
        postSingleUpdate(callback, handler, id, status);
    }
}
#method_after
private void onStatusChangedLocked(int status, String id) {
    /* Force to ignore the last mono/aux camera status update
             * if the package name does not falls in this bucket
             */
    if (!Camera.shouldExposeAuxCamera()) {
        if (Integer.parseInt(id) >= 2) {
            Log.w(TAG, "[soar.cts] ignore the status update of camera: " + id);
            return;
        }
    }
    if (DEBUG) {
        Log.v(TAG, String.format("Camera id %s has status changed to 0x%x", id, status));
    }
    if (!validStatus(status)) {
        Log.e(TAG, String.format("Ignoring invalid device %s status 0x%x", id, status));
        return;
    }
    Integer oldStatus = mDeviceStatus.put(id, status);
    if (oldStatus != null && oldStatus == status) {
        if (DEBUG) {
            Log.v(TAG, String.format("Device status changed to 0x%x, which is what it already was", status));
        }
        return;
    }
    // not available -> not available => no new update
    if (oldStatus != null && isAvailable(status) == isAvailable(oldStatus)) {
        if (DEBUG) {
            Log.v(TAG, String.format("Device status was previously available (%b), " + " and is now again available (%b)" + "so no new client visible update will be sent", isAvailable(oldStatus), isAvailable(status)));
        }
        return;
    }
    final int callbackCount = mCallbackMap.size();
    for (int i = 0; i < callbackCount; i++) {
        Handler handler = mCallbackMap.valueAt(i);
        final AvailabilityCallback callback = mCallbackMap.keyAt(i);
        postSingleUpdate(callback, handler, id, status);
    }
}
#end_block

#method_before
public static int getNumberOfCameras() {
    boolean exposeAuxCamera = false;
    String packageName = ActivityThread.currentOpPackageName();
    /* Force to expose only two cameras
         * if the package name does not falls in this bucket
         */
    String packageList = SystemProperties.get("vendor.camera.aux.packagelist");
    if (packageList.length() > 0) {
        TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
        splitter.setString(packageList);
        for (String str : splitter) {
            if (packageName.equals(str)) {
                exposeAuxCamera = true;
                break;
            }
        }
    }
    int numberOfCameras = _getNumberOfCameras();
    if (exposeAuxCamera == false && (numberOfCameras > 2)) {
        numberOfCameras = 2;
    }
    return numberOfCameras;
}
#method_after
public static int getNumberOfCameras() {
    /* Force to expose only two cameras
         * if the package name does not falls in this bucket
         */
    int numberOfCameras = native_getNumberOfCameras();
    if ((numberOfCameras > 2) && !shouldExposeAuxCamera()) {
        numberOfCameras = 2;
    }
    return numberOfCameras;
}
#end_block

#method_before
public static boolean allowTrim() {
    return Process.getTotalMemory() < TRIM_ENABLE_MEMORY;
}
#method_after
private static boolean allowTrim() {
    return Process.getTotalMemory() < TRIM_ENABLE_MEMORY;
}
#end_block

#method_before
public static int computeTrimEmptyApps(int rawMaxEmptyProcesses) {
    if (USE_TRIM_SETTINGS && allowTrim()) {
        return rawMaxEmptyProcesses * TRIM_EMPTY_PERCENT / 100;
    } else {
        return rawMaxEmptyProcesses / 2;
    }
}
#method_after
private static int computeTrimEmptyApps(int rawMaxEmptyProcesses) {
    if (USE_TRIM_SETTINGS && allowTrim()) {
        return rawMaxEmptyProcesses * TRIM_EMPTY_PERCENT / 100;
    } else {
        return rawMaxEmptyProcesses / 2;
    }
}
#end_block

#method_before
public static int computeTrimCachedApps(int rawMaxEmptyProcesses, int totalProcessLimit) {
    if (USE_TRIM_SETTINGS && allowTrim()) {
        return totalProcessLimit * TRIM_CACHE_PERCENT / 100;
    } else {
        return (totalProcessLimit - rawMaxEmptyProcesses) / 3;
    }
}
#method_after
private static int computeTrimCachedApps(int rawMaxEmptyProcesses, int totalProcessLimit) {
    if (USE_TRIM_SETTINGS && allowTrim()) {
        return totalProcessLimit * TRIM_CACHE_PERCENT / 100;
    } else {
        return (totalProcessLimit - rawMaxEmptyProcesses) / 3;
    }
}
#end_block

#method_before
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mButtonBrightnessSettingDefault = pm.getDefaultButtonBrightness();
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        mScreenBrightnessForVrSettingDefault = pm.getDefaultScreenBrightnessForVrSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, mAppOps, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        mButtonsLight = mLightsManager.getLight(LightsManager.LIGHT_ID_BUTTONS);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        // Initialize proximity sensor
        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);
        mProximitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
        // Go.
        readConfigurationLocked();
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
    final ContentResolver resolver = mContext.getContentResolver();
    mConstants.start(resolver);
    mBatterySaverPolicy.start(resolver);
    // Register for settings changes.
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_FOR_VR), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOZE_ALWAYS_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_DEMO_MODE), false, mSettingsObserver, UserHandle.USER_SYSTEM);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.PROXIMITY_ON_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.BUTTON_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    IVrManager vrManager = (IVrManager) getBinderService(Context.VR_SERVICE);
    if (vrManager != null) {
        try {
            vrManager.registerListener(mVrStateCallbacks);
        } catch (RemoteException e) {
            Slog.e(TAG, "Failed to register VR mode state listener: " + e);
        }
    }
    // Register for broadcasts from other components of the system.
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
}
#method_after
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mButtonBrightnessSettingDefault = pm.getDefaultButtonBrightness();
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        mScreenBrightnessForVrSettingDefault = pm.getDefaultScreenBrightnessForVrSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, mAppOps, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        mButtonsLight = mLightsManager.getLight(LightsManager.LIGHT_ID_BUTTONS);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        // Initialize proximity sensor
        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);
        mProximitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
        // Go.
        readConfigurationLocked();
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
    final ContentResolver resolver = mContext.getContentResolver();
    mConstants.start(resolver);
    mBatterySaverPolicy.start(resolver);
    // Register for settings changes.
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_FOR_VR), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOZE_ALWAYS_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_DEMO_MODE), false, mSettingsObserver, UserHandle.USER_SYSTEM);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.PROXIMITY_ON_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.BUTTON_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.WAKE_WHEN_PLUGGED_OR_UNPLUGGED), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.BUTTON_BACKLIGHT_ONLY_WHEN_PRESSED), false, mSettingsObserver, UserHandle.USER_ALL);
    IVrManager vrManager = (IVrManager) getBinderService(Context.VR_SERVICE);
    if (vrManager != null) {
        try {
            vrManager.registerListener(mVrStateCallbacks);
        } catch (RemoteException e) {
            Slog.e(TAG, "Failed to register VR mode state listener: " + e);
        }
    }
    // Register for broadcasts from other components of the system.
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
}
#end_block

#method_before
private void readConfigurationLocked() {
    final Resources resources = mContext.getResources();
    mDecoupleHalAutoSuspendModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleAutoSuspendModeFromDisplay);
    mDecoupleHalInteractiveModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleInteractiveModeFromDisplay);
    mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(com.android.internal.R.bool.config_unplugTurnsOnScreen);
    mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig = resources.getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromUnplug);
    mSuspendWhenScreenOffDueToProximityConfig = resources.getBoolean(com.android.internal.R.bool.config_suspendWhenScreenOffDueToProximity);
    mDreamsSupportedConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsSupported);
    mDreamsEnabledByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledByDefault);
    mDreamsActivatedOnSleepByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
    mDreamsActivatedOnDockByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
    mDreamsEnabledOnBatteryConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledOnBattery);
    mDreamsBatteryLevelMinimumWhenPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenPowered);
    mDreamsBatteryLevelMinimumWhenNotPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenNotPowered);
    mDreamsBatteryLevelDrainCutoffConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelDrainCutoff);
    mDozeAfterScreenOffConfig = resources.getBoolean(com.android.internal.R.bool.config_dozeAfterScreenOff);
    mMinimumScreenOffTimeoutConfig = resources.getInteger(com.android.internal.R.integer.config_minimumScreenOffTimeout);
    mMaximumScreenDimDurationConfig = resources.getInteger(com.android.internal.R.integer.config_maximumScreenDimDuration);
    mMaximumScreenDimRatioConfig = resources.getFraction(com.android.internal.R.fraction.config_maximumScreenDimRatio, 1, 1);
    mSupportsDoubleTapWakeConfig = resources.getBoolean(com.android.internal.R.bool.config_supportDoubleTapWake);
    mProximityWakeSupported = resources.getBoolean(org.lineageos.platform.internal.R.bool.config_proximityCheckOnWake);
    mProximityWakeEnabledByDefaultConfig = resources.getBoolean(org.lineageos.platform.internal.R.bool.config_proximityCheckOnWakeEnabledByDefault);
    mProximityTimeOut = resources.getInteger(org.lineageos.platform.internal.R.integer.config_proximityCheckTimeout);
    if (mProximityWakeSupported) {
        mProximityWakeLock = mContext.getSystemService(PowerManager.class).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ProximityWakeLock");
    }
    mButtonLightOnKeypressOnly = resources.getBoolean(com.android.internal.R.bool.config_buttonLightOnKeypressOnly);
}
#method_after
private void readConfigurationLocked() {
    final Resources resources = mContext.getResources();
    mDecoupleHalAutoSuspendModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleAutoSuspendModeFromDisplay);
    mDecoupleHalInteractiveModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleInteractiveModeFromDisplay);
    mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(com.android.internal.R.bool.config_unplugTurnsOnScreen);
    mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig = resources.getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromUnplug);
    mSuspendWhenScreenOffDueToProximityConfig = resources.getBoolean(com.android.internal.R.bool.config_suspendWhenScreenOffDueToProximity);
    mDreamsSupportedConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsSupported);
    mDreamsEnabledByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledByDefault);
    mDreamsActivatedOnSleepByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
    mDreamsActivatedOnDockByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
    mDreamsEnabledOnBatteryConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledOnBattery);
    mDreamsBatteryLevelMinimumWhenPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenPowered);
    mDreamsBatteryLevelMinimumWhenNotPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenNotPowered);
    mDreamsBatteryLevelDrainCutoffConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelDrainCutoff);
    mDozeAfterScreenOffConfig = resources.getBoolean(com.android.internal.R.bool.config_dozeAfterScreenOff);
    mMinimumScreenOffTimeoutConfig = resources.getInteger(com.android.internal.R.integer.config_minimumScreenOffTimeout);
    mMaximumScreenDimDurationConfig = resources.getInteger(com.android.internal.R.integer.config_maximumScreenDimDuration);
    mMaximumScreenDimRatioConfig = resources.getFraction(com.android.internal.R.fraction.config_maximumScreenDimRatio, 1, 1);
    mSupportsDoubleTapWakeConfig = resources.getBoolean(com.android.internal.R.bool.config_supportDoubleTapWake);
    mProximityWakeSupported = resources.getBoolean(org.lineageos.platform.internal.R.bool.config_proximityCheckOnWake);
    mProximityWakeEnabledByDefaultConfig = resources.getBoolean(org.lineageos.platform.internal.R.bool.config_proximityCheckOnWakeEnabledByDefault);
    mProximityTimeOut = resources.getInteger(org.lineageos.platform.internal.R.integer.config_proximityCheckTimeout);
    if (mProximityWakeSupported) {
        mProximityWakeLock = mContext.getSystemService(PowerManager.class).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ProximityWakeLock");
    }
}
#end_block

#method_before
private void updateSettingsLocked() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDreamsEnabledSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ENABLED, mDreamsEnabledByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnSleepSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP, mDreamsActivatedOnSleepByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnDockSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK, mDreamsActivatedOnDockByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mScreenOffTimeoutSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, DEFAULT_SCREEN_OFF_TIMEOUT, UserHandle.USER_CURRENT);
    mSleepTimeoutSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.SLEEP_TIMEOUT, DEFAULT_SLEEP_TIMEOUT, UserHandle.USER_CURRENT);
    mStayOnWhilePluggedInSetting = Settings.Global.getInt(resolver, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, BatteryManager.BATTERY_PLUGGED_AC);
    mTheaterModeEnabled = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 1;
    mAlwaysOnEnabled = mAmbientDisplayConfiguration.alwaysOnEnabled(UserHandle.USER_CURRENT);
    if (mSupportsDoubleTapWakeConfig) {
        boolean doubleTapWakeEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.DOUBLE_TAP_TO_WAKE, DEFAULT_DOUBLE_TAP_TO_WAKE, UserHandle.USER_CURRENT) != 0;
        if (doubleTapWakeEnabled != mDoubleTapWakeEnabled) {
            mDoubleTapWakeEnabled = doubleTapWakeEnabled;
            nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, mDoubleTapWakeEnabled ? 1 : 0);
        }
    }
    final String retailDemoValue = UserManager.isDeviceInDemoMode(mContext) ? "1" : "0";
    if (!retailDemoValue.equals(SystemProperties.get(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED))) {
        SystemProperties.set(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED, retailDemoValue);
    }
    final int oldScreenBrightnessSetting = getCurrentBrightnessSettingLocked();
    mScreenBrightnessForVrSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_FOR_VR, mScreenBrightnessForVrSettingDefault, UserHandle.USER_CURRENT);
    mScreenBrightnessSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mScreenBrightnessSettingDefault, UserHandle.USER_CURRENT);
    if (oldScreenBrightnessSetting != getCurrentBrightnessSettingLocked()) {
        mTemporaryScreenBrightnessSettingOverride = -1;
    }
    final float oldScreenAutoBrightnessAdjustmentSetting = mScreenAutoBrightnessAdjustmentSetting;
    mScreenAutoBrightnessAdjustmentSetting = Settings.System.getFloatForUser(resolver, Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0.0f, UserHandle.USER_CURRENT);
    if (oldScreenAutoBrightnessAdjustmentSetting != mScreenAutoBrightnessAdjustmentSetting) {
        mTemporaryScreenAutoBrightnessAdjustmentSettingOverride = Float.NaN;
    }
    mScreenBrightnessModeSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT);
    final boolean lowPowerModeEnabled = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE, 0) != 0;
    final boolean autoLowPowerModeConfigured = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, 0) != 0;
    if (lowPowerModeEnabled != mLowPowerModeSetting || autoLowPowerModeConfigured != mAutoLowPowerModeConfigured) {
        mLowPowerModeSetting = lowPowerModeEnabled;
        mAutoLowPowerModeConfigured = autoLowPowerModeConfigured;
        updateLowPowerModeLocked();
    }
    mProximityWakeEnabled = LineageSettings.System.getInt(resolver, LineageSettings.System.PROXIMITY_ON_WAKE, mProximityWakeEnabledByDefaultConfig ? 1 : 0) == 1;
    mDevForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
    mButtonTimeout = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT, DEFAULT_BUTTON_ON_DURATION, UserHandle.USER_CURRENT);
    mButtonBrightness = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BRIGHTNESS, mButtonBrightnessSettingDefault, UserHandle.USER_CURRENT);
    mDirty |= DIRTY_SETTINGS;
}
#method_after
private void updateSettingsLocked() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDreamsEnabledSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ENABLED, mDreamsEnabledByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnSleepSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP, mDreamsActivatedOnSleepByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnDockSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK, mDreamsActivatedOnDockByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mScreenOffTimeoutSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, DEFAULT_SCREEN_OFF_TIMEOUT, UserHandle.USER_CURRENT);
    mSleepTimeoutSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.SLEEP_TIMEOUT, DEFAULT_SLEEP_TIMEOUT, UserHandle.USER_CURRENT);
    mStayOnWhilePluggedInSetting = Settings.Global.getInt(resolver, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, BatteryManager.BATTERY_PLUGGED_AC);
    mTheaterModeEnabled = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 1;
    mWakeUpWhenPluggedOrUnpluggedSetting = LineageSettings.Global.getInt(resolver, LineageSettings.Global.WAKE_WHEN_PLUGGED_OR_UNPLUGGED, (mWakeUpWhenPluggedOrUnpluggedConfig ? 1 : 0)) == 1;
    mAlwaysOnEnabled = mAmbientDisplayConfiguration.alwaysOnEnabled(UserHandle.USER_CURRENT);
    if (mSupportsDoubleTapWakeConfig) {
        boolean doubleTapWakeEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.DOUBLE_TAP_TO_WAKE, DEFAULT_DOUBLE_TAP_TO_WAKE, UserHandle.USER_CURRENT) != 0;
        if (doubleTapWakeEnabled != mDoubleTapWakeEnabled) {
            mDoubleTapWakeEnabled = doubleTapWakeEnabled;
            nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, mDoubleTapWakeEnabled ? 1 : 0);
        }
    }
    final String retailDemoValue = UserManager.isDeviceInDemoMode(mContext) ? "1" : "0";
    if (!retailDemoValue.equals(SystemProperties.get(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED))) {
        SystemProperties.set(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED, retailDemoValue);
    }
    final int oldScreenBrightnessSetting = getCurrentBrightnessSettingLocked();
    mScreenBrightnessForVrSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_FOR_VR, mScreenBrightnessForVrSettingDefault, UserHandle.USER_CURRENT);
    mScreenBrightnessSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mScreenBrightnessSettingDefault, UserHandle.USER_CURRENT);
    if (oldScreenBrightnessSetting != getCurrentBrightnessSettingLocked()) {
        mTemporaryScreenBrightnessSettingOverride = -1;
    }
    final float oldScreenAutoBrightnessAdjustmentSetting = mScreenAutoBrightnessAdjustmentSetting;
    mScreenAutoBrightnessAdjustmentSetting = Settings.System.getFloatForUser(resolver, Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0.0f, UserHandle.USER_CURRENT);
    if (oldScreenAutoBrightnessAdjustmentSetting != mScreenAutoBrightnessAdjustmentSetting) {
        mTemporaryScreenAutoBrightnessAdjustmentSettingOverride = Float.NaN;
    }
    mScreenBrightnessModeSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT);
    final boolean lowPowerModeEnabled = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE, 0) != 0;
    final boolean autoLowPowerModeConfigured = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, 0) != 0;
    if (lowPowerModeEnabled != mLowPowerModeSetting || autoLowPowerModeConfigured != mAutoLowPowerModeConfigured) {
        mLowPowerModeSetting = lowPowerModeEnabled;
        mAutoLowPowerModeConfigured = autoLowPowerModeConfigured;
        updateLowPowerModeLocked();
    }
    mProximityWakeEnabled = LineageSettings.System.getInt(resolver, LineageSettings.System.PROXIMITY_ON_WAKE, mProximityWakeEnabledByDefaultConfig ? 1 : 0) == 1;
    mDevForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
    mButtonTimeout = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT, DEFAULT_BUTTON_ON_DURATION, UserHandle.USER_CURRENT);
    mButtonBrightness = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BRIGHTNESS, mButtonBrightnessSettingDefault, UserHandle.USER_CURRENT);
    mButtonLightOnKeypressOnly = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.BUTTON_BACKLIGHT_ONLY_WHEN_PRESSED, 0, UserHandle.USER_CURRENT) == 1;
    mDirty |= DIRTY_SETTINGS;
}
#end_block

#method_before
private boolean shouldWakeUpWhenPluggedOrUnpluggedLocked(boolean wasPowered, int oldPlugType, boolean dockedOnWirelessCharger) {
    // Don't wake when powered unless configured to do so.
    if (!mWakeUpWhenPluggedOrUnpluggedConfig) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (wasPowered && !mIsPowered && oldPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (!wasPowered && mIsPowered && mPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS && !dockedOnWirelessCharger) {
        return false;
    }
    // If already dreaming and becoming powered, then don't wake.
    if (mIsPowered && mWakefulness == WAKEFULNESS_DREAMING) {
        return false;
    }
    // Don't wake while theater mode is enabled.
    if (mTheaterModeEnabled && !mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig) {
        return false;
    }
    // On Always On Display, SystemUI shows the charging indicator
    if (mAlwaysOnEnabled && mWakefulness == WAKEFULNESS_DOZING) {
        return false;
    }
    // Otherwise wake up!
    return true;
}
#method_after
private boolean shouldWakeUpWhenPluggedOrUnpluggedLocked(boolean wasPowered, int oldPlugType, boolean dockedOnWirelessCharger) {
    // Don't wake when powered unless configured to do so.
    if (!mWakeUpWhenPluggedOrUnpluggedSetting) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (wasPowered && !mIsPowered && oldPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (!wasPowered && mIsPowered && mPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS && !dockedOnWirelessCharger) {
        return false;
    }
    // If already dreaming and becoming powered, then don't wake.
    if (mIsPowered && mWakefulness == WAKEFULNESS_DREAMING) {
        return false;
    }
    // Don't wake while theater mode is enabled.
    if (mTheaterModeEnabled && !mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig) {
        return false;
    }
    // On Always On Display, SystemUI shows the charging indicator
    if (mAlwaysOnEnabled && mWakefulness == WAKEFULNESS_DOZING) {
        return false;
    }
    // Otherwise wake up!
    return true;
}
#end_block

#method_before
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    if (mWakefulness == WAKEFULNESS_AWAKE) {
                        int buttonBrightness;
                        if (mButtonBrightnessOverrideFromWindowManager >= 0) {
                            buttonBrightness = mButtonBrightnessOverrideFromWindowManager;
                        } else {
                            if (!mDevForceNavbar) {
                                buttonBrightness = mButtonBrightness;
                            } else {
                                buttonBrightness = 0;
                            }
                        }
                        mLastButtonActivityTime = mButtonLightOnKeypressOnly ? mLastButtonActivityTime : mLastUserActivityTime;
                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                            mButtonsLight.setBrightness(0);
                            mButtonOn = false;
                        } else {
                            if ((!mButtonLightOnKeypressOnly || mButtonPressed) && !mProximityPositive) {
                                mButtonsLight.setBrightness(buttonBrightness);
                                mButtonPressed = false;
                                if (buttonBrightness != 0 && mButtonTimeout != 0) {
                                    mButtonOn = true;
                                    if (now + mButtonTimeout < nextTimeout) {
                                        nextTimeout = now + mButtonTimeout;
                                    }
                                }
                            } else if (mButtonLightOnKeypressOnly && mButtonOn && mLastButtonActivityTime + mButtonTimeout < nextTimeout) {
                                nextTimeout = mLastButtonActivityTime + mButtonTimeout;
                            }
                        }
                    }
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                        if (mWakefulness == WAKEFULNESS_AWAKE) {
                            mButtonsLight.setBrightness(0);
                        }
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT || mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_VR) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#method_after
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    if (mWakefulness == WAKEFULNESS_AWAKE) {
                        int buttonBrightness;
                        if (mButtonBrightnessOverrideFromWindowManager >= 0) {
                            buttonBrightness = mButtonBrightnessOverrideFromWindowManager;
                        } else {
                            if (!mDevForceNavbar) {
                                buttonBrightness = mButtonBrightness;
                            } else {
                                buttonBrightness = 0;
                            }
                        }
                        mLastButtonActivityTime = mButtonLightOnKeypressOnly ? mLastButtonActivityTime : mLastUserActivityTime;
                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                            mButtonsLight.setBrightness(0);
                            mButtonOn = false;
                        } else {
                            if ((!mButtonLightOnKeypressOnly || mButtonPressed) && !mProximityPositive) {
                                mButtonsLight.setBrightness(buttonBrightness);
                                mButtonPressed = false;
                                if (buttonBrightness != 0 && mButtonTimeout != 0) {
                                    mButtonOn = true;
                                    if (now + mButtonTimeout < nextTimeout) {
                                        nextTimeout = now + mButtonTimeout;
                                    }
                                }
                            } else if (mButtonLightOnKeypressOnly && mButtonOn && mLastButtonActivityTime + mButtonTimeout < nextTimeout) {
                                nextTimeout = mLastButtonActivityTime + mButtonTimeout;
                            }
                        }
                    }
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                        if (mWakefulness == WAKEFULNESS_AWAKE) {
                            mButtonsLight.setBrightness(0);
                            mButtonOn = false;
                        }
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT || mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_VR) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#end_block

#method_before
private void updateSettingsLocked() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDreamsEnabledSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ENABLED, mDreamsEnabledByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnSleepSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP, mDreamsActivatedOnSleepByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnDockSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK, mDreamsActivatedOnDockByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mScreenOffTimeoutSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, DEFAULT_SCREEN_OFF_TIMEOUT, UserHandle.USER_CURRENT);
    mSleepTimeoutSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.SLEEP_TIMEOUT, DEFAULT_SLEEP_TIMEOUT, UserHandle.USER_CURRENT);
    mStayOnWhilePluggedInSetting = Settings.Global.getInt(resolver, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, BatteryManager.BATTERY_PLUGGED_AC);
    mTheaterModeEnabled = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 1;
    mWakeUpWhenPluggedOrUnpluggedSetting = LineageSettings.Global.getInt(resolver, LineageSettings.Global.WAKE_WHEN_PLUGGED_OR_UNPLUGGED, (mWakeUpWhenPluggedOrUnpluggedConfig ? 1 : 0));
    mAlwaysOnEnabled = mAmbientDisplayConfiguration.alwaysOnEnabled(UserHandle.USER_CURRENT);
    if (mSupportsDoubleTapWakeConfig) {
        boolean doubleTapWakeEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.DOUBLE_TAP_TO_WAKE, DEFAULT_DOUBLE_TAP_TO_WAKE, UserHandle.USER_CURRENT) != 0;
        if (doubleTapWakeEnabled != mDoubleTapWakeEnabled) {
            mDoubleTapWakeEnabled = doubleTapWakeEnabled;
            nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, mDoubleTapWakeEnabled ? 1 : 0);
        }
    }
    final String retailDemoValue = UserManager.isDeviceInDemoMode(mContext) ? "1" : "0";
    if (!retailDemoValue.equals(SystemProperties.get(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED))) {
        SystemProperties.set(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED, retailDemoValue);
    }
    final int oldScreenBrightnessSetting = getCurrentBrightnessSettingLocked();
    mScreenBrightnessForVrSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_FOR_VR, mScreenBrightnessForVrSettingDefault, UserHandle.USER_CURRENT);
    mScreenBrightnessSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mScreenBrightnessSettingDefault, UserHandle.USER_CURRENT);
    if (oldScreenBrightnessSetting != getCurrentBrightnessSettingLocked()) {
        mTemporaryScreenBrightnessSettingOverride = -1;
    }
    final float oldScreenAutoBrightnessAdjustmentSetting = mScreenAutoBrightnessAdjustmentSetting;
    mScreenAutoBrightnessAdjustmentSetting = Settings.System.getFloatForUser(resolver, Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0.0f, UserHandle.USER_CURRENT);
    if (oldScreenAutoBrightnessAdjustmentSetting != mScreenAutoBrightnessAdjustmentSetting) {
        mTemporaryScreenAutoBrightnessAdjustmentSettingOverride = Float.NaN;
    }
    mScreenBrightnessModeSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT);
    final boolean lowPowerModeEnabled = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE, 0) != 0;
    final boolean autoLowPowerModeConfigured = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, 0) != 0;
    if (lowPowerModeEnabled != mLowPowerModeSetting || autoLowPowerModeConfigured != mAutoLowPowerModeConfigured) {
        mLowPowerModeSetting = lowPowerModeEnabled;
        mAutoLowPowerModeConfigured = autoLowPowerModeConfigured;
        updateLowPowerModeLocked();
    }
    mProximityWakeEnabled = LineageSettings.System.getInt(resolver, LineageSettings.System.PROXIMITY_ON_WAKE, mProximityWakeEnabledByDefaultConfig ? 1 : 0) == 1;
    mDevForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
    mButtonTimeout = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT, DEFAULT_BUTTON_ON_DURATION, UserHandle.USER_CURRENT);
    mButtonBrightness = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BRIGHTNESS, mButtonBrightnessSettingDefault, UserHandle.USER_CURRENT);
    mDirty |= DIRTY_SETTINGS;
}
#method_after
private void updateSettingsLocked() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDreamsEnabledSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ENABLED, mDreamsEnabledByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnSleepSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP, mDreamsActivatedOnSleepByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mDreamsActivateOnDockSetting = (Settings.Secure.getIntForUser(resolver, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK, mDreamsActivatedOnDockByDefaultConfig ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    mScreenOffTimeoutSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, DEFAULT_SCREEN_OFF_TIMEOUT, UserHandle.USER_CURRENT);
    mSleepTimeoutSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.SLEEP_TIMEOUT, DEFAULT_SLEEP_TIMEOUT, UserHandle.USER_CURRENT);
    mStayOnWhilePluggedInSetting = Settings.Global.getInt(resolver, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, BatteryManager.BATTERY_PLUGGED_AC);
    mTheaterModeEnabled = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 1;
    mWakeUpWhenPluggedOrUnpluggedSetting = LineageSettings.Global.getInt(resolver, LineageSettings.Global.WAKE_WHEN_PLUGGED_OR_UNPLUGGED, (mWakeUpWhenPluggedOrUnpluggedConfig ? 1 : 0)) == 1;
    mAlwaysOnEnabled = mAmbientDisplayConfiguration.alwaysOnEnabled(UserHandle.USER_CURRENT);
    if (mSupportsDoubleTapWakeConfig) {
        boolean doubleTapWakeEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.DOUBLE_TAP_TO_WAKE, DEFAULT_DOUBLE_TAP_TO_WAKE, UserHandle.USER_CURRENT) != 0;
        if (doubleTapWakeEnabled != mDoubleTapWakeEnabled) {
            mDoubleTapWakeEnabled = doubleTapWakeEnabled;
            nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, mDoubleTapWakeEnabled ? 1 : 0);
        }
    }
    final String retailDemoValue = UserManager.isDeviceInDemoMode(mContext) ? "1" : "0";
    if (!retailDemoValue.equals(SystemProperties.get(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED))) {
        SystemProperties.set(SYSTEM_PROPERTY_RETAIL_DEMO_ENABLED, retailDemoValue);
    }
    final int oldScreenBrightnessSetting = getCurrentBrightnessSettingLocked();
    mScreenBrightnessForVrSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_FOR_VR, mScreenBrightnessForVrSettingDefault, UserHandle.USER_CURRENT);
    mScreenBrightnessSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mScreenBrightnessSettingDefault, UserHandle.USER_CURRENT);
    if (oldScreenBrightnessSetting != getCurrentBrightnessSettingLocked()) {
        mTemporaryScreenBrightnessSettingOverride = -1;
    }
    final float oldScreenAutoBrightnessAdjustmentSetting = mScreenAutoBrightnessAdjustmentSetting;
    mScreenAutoBrightnessAdjustmentSetting = Settings.System.getFloatForUser(resolver, Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0.0f, UserHandle.USER_CURRENT);
    if (oldScreenAutoBrightnessAdjustmentSetting != mScreenAutoBrightnessAdjustmentSetting) {
        mTemporaryScreenAutoBrightnessAdjustmentSettingOverride = Float.NaN;
    }
    mScreenBrightnessModeSetting = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT);
    final boolean lowPowerModeEnabled = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE, 0) != 0;
    final boolean autoLowPowerModeConfigured = Settings.Global.getInt(resolver, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, 0) != 0;
    if (lowPowerModeEnabled != mLowPowerModeSetting || autoLowPowerModeConfigured != mAutoLowPowerModeConfigured) {
        mLowPowerModeSetting = lowPowerModeEnabled;
        mAutoLowPowerModeConfigured = autoLowPowerModeConfigured;
        updateLowPowerModeLocked();
    }
    mProximityWakeEnabled = LineageSettings.System.getInt(resolver, LineageSettings.System.PROXIMITY_ON_WAKE, mProximityWakeEnabledByDefaultConfig ? 1 : 0) == 1;
    mDevForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
    mButtonTimeout = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT, DEFAULT_BUTTON_ON_DURATION, UserHandle.USER_CURRENT);
    mButtonBrightness = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.BUTTON_BRIGHTNESS, mButtonBrightnessSettingDefault, UserHandle.USER_CURRENT);
    mDirty |= DIRTY_SETTINGS;
}
#end_block

#method_before
private boolean shouldWakeUpWhenPluggedOrUnpluggedLocked(boolean wasPowered, int oldPlugType, boolean dockedOnWirelessCharger) {
    // Don't wake when powered unless configured to do so.
    if (mWakeUpWhenPluggedOrUnpluggedSetting == 0) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (wasPowered && !mIsPowered && oldPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (!wasPowered && mIsPowered && mPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS && !dockedOnWirelessCharger) {
        return false;
    }
    // If already dreaming and becoming powered, then don't wake.
    if (mIsPowered && mWakefulness == WAKEFULNESS_DREAMING) {
        return false;
    }
    // Don't wake while theater mode is enabled.
    if (mTheaterModeEnabled && !mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig) {
        return false;
    }
    // On Always On Display, SystemUI shows the charging indicator
    if (mAlwaysOnEnabled && mWakefulness == WAKEFULNESS_DOZING) {
        return false;
    }
    // Otherwise wake up!
    return true;
}
#method_after
private boolean shouldWakeUpWhenPluggedOrUnpluggedLocked(boolean wasPowered, int oldPlugType, boolean dockedOnWirelessCharger) {
    // Don't wake when powered unless configured to do so.
    if (!mWakeUpWhenPluggedOrUnpluggedSetting) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (wasPowered && !mIsPowered && oldPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS) {
        return false;
    }
    // See WirelessChargerDetector for justification.
    if (!wasPowered && mIsPowered && mPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS && !dockedOnWirelessCharger) {
        return false;
    }
    // If already dreaming and becoming powered, then don't wake.
    if (mIsPowered && mWakefulness == WAKEFULNESS_DREAMING) {
        return false;
    }
    // Don't wake while theater mode is enabled.
    if (mTheaterModeEnabled && !mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig) {
        return false;
    }
    // On Always On Display, SystemUI shows the charging indicator
    if (mAlwaysOnEnabled && mWakefulness == WAKEFULNESS_DOZING) {
        return false;
    }
    // Otherwise wake up!
    return true;
}
#end_block

#method_before
private boolean isDeviceLocked() {
    final KeyguardManager keyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    return keyguardManager != null && keyguardManager.isDeviceLocked();
}
#method_after
private boolean isDeviceLocked() {
    boolean isLocked = false;
    KeyguardManager keyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    boolean inKeyguardRestrictedInputMode = keyguardManager.inKeyguardRestrictedInputMode();
    if (inKeyguardRestrictedInputMode) {
        isLocked = true;
    } else {
        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        isLocked = !powerManager.isScreenOn();
    }
    return isLocked;
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    synchronized (mLock) {
        if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) {
            incrementBootCount();
        } else if (phase == PHASE_BOOT_COMPLETED) {
            final long now = SystemClock.uptimeMillis();
            mBootCompleted = true;
            mDirty |= DIRTY_BOOT_COMPLETED;
            userActivityNoUpdateLocked(now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);
            updatePowerStateLocked();
            if (!ArrayUtils.isEmpty(mBootCompletedRunnables)) {
                Slog.d(TAG, "Posting " + mBootCompletedRunnables.length + " delayed runnables");
                for (Runnable r : mBootCompletedRunnables) {
                    BackgroundThread.getHandler().post(r);
                }
            }
            mBootCompletedRunnables = null;
            mPerf = LocalServices.getService(PerformanceManagerInternal.class);
        }
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    synchronized (mLock) {
        if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) {
            incrementBootCount();
        } else if (phase == PHASE_BOOT_COMPLETED) {
            final long now = SystemClock.uptimeMillis();
            mBootCompleted = true;
            mDirty |= DIRTY_BOOT_COMPLETED;
            userActivityNoUpdateLocked(now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);
            updatePowerStateLocked();
            if (!ArrayUtils.isEmpty(mBootCompletedRunnables)) {
                Slog.d(TAG, "Posting " + mBootCompletedRunnables.length + " delayed runnables");
                for (Runnable r : mBootCompletedRunnables) {
                    BackgroundThread.getHandler().post(r);
                }
            }
            mBootCompletedRunnables = null;
        }
    }
}
#end_block

#method_before
private void updateLowPowerModeLocked() {
    if ((mIsPowered || !mBatteryLevelLow && !mBootCompleted) && mLowPowerModeSetting) {
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateLowPowerModeLocked: powered or booting with sufficient battery," + " turning setting off");
        }
        // Turn setting off if powered
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.LOW_POWER_MODE, 0);
        // update performance profile
        mLowPowerModeSetting = false;
    }
    final boolean autoLowPowerModeEnabled = !mIsPowered && mAutoLowPowerModeConfigured && !mAutoLowPowerModeSnoozing && mBatteryLevelLow;
    final boolean lowPowerModeEnabled = mLowPowerModeSetting || autoLowPowerModeEnabled;
    if (mLowPowerModeEnabled != lowPowerModeEnabled) {
        mLowPowerModeEnabled = lowPowerModeEnabled;
        powerHintInternal(PowerHint.LOW_POWER, lowPowerModeEnabled ? 1 : 0);
        postAfterBootCompleted(new Runnable() {

            @Override
            public void run() {
                Intent intent = new Intent(PowerManager.ACTION_POWER_SAVE_MODE_CHANGING).putExtra(PowerManager.EXTRA_POWER_SAVE_MODE, mLowPowerModeEnabled).addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                mContext.sendBroadcast(intent);
                ArrayList<PowerManagerInternal.LowPowerModeListener> listeners;
                synchronized (mLock) {
                    listeners = new ArrayList<PowerManagerInternal.LowPowerModeListener>(mLowPowerModeListeners);
                }
                for (int i = 0; i < listeners.size(); i++) {
                    final PowerManagerInternal.LowPowerModeListener listener = listeners.get(i);
                    final PowerSaveState result = mBatterySaverPolicy.getBatterySaverPolicy(listener.getServiceType(), lowPowerModeEnabled);
                    listener.onLowPowerModeChanged(result);
                }
                intent = new Intent(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
                // Send internal version that requires signature permission.
                intent = new Intent(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED_INTERNAL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL, Manifest.permission.DEVICE_POWER);
            }
        });
    }
}
#method_after
private void updateLowPowerModeLocked() {
    if ((mIsPowered || !mBatteryLevelLow && !mBootCompleted) && mLowPowerModeSetting) {
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateLowPowerModeLocked: powered or booting with sufficient battery," + " turning setting off");
        }
        // Turn setting off if powered
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.LOW_POWER_MODE, 0);
        mLowPowerModeSetting = false;
    }
    final boolean autoLowPowerModeEnabled = !mIsPowered && mAutoLowPowerModeConfigured && !mAutoLowPowerModeSnoozing && mBatteryLevelLow;
    final boolean lowPowerModeEnabled = mLowPowerModeSetting || autoLowPowerModeEnabled;
    if (mLowPowerModeEnabled != lowPowerModeEnabled) {
        mLowPowerModeEnabled = lowPowerModeEnabled;
        powerHintInternal(PowerHint.LOW_POWER, lowPowerModeEnabled ? 1 : 0);
        postAfterBootCompleted(new Runnable() {

            @Override
            public void run() {
                Intent intent = new Intent(PowerManager.ACTION_POWER_SAVE_MODE_CHANGING).putExtra(PowerManager.EXTRA_POWER_SAVE_MODE, mLowPowerModeEnabled).addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                mContext.sendBroadcast(intent);
                ArrayList<PowerManagerInternal.LowPowerModeListener> listeners;
                synchronized (mLock) {
                    listeners = new ArrayList<PowerManagerInternal.LowPowerModeListener>(mLowPowerModeListeners);
                }
                for (int i = 0; i < listeners.size(); i++) {
                    final PowerManagerInternal.LowPowerModeListener listener = listeners.get(i);
                    final PowerSaveState result = mBatterySaverPolicy.getBatterySaverPolicy(listener.getServiceType(), lowPowerModeEnabled);
                    listener.onLowPowerModeChanged(result);
                }
                intent = new Intent(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
                // Send internal version that requires signature permission.
                intent = new Intent(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED_INTERNAL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL, Manifest.permission.DEVICE_POWER);
            }
        });
    }
}
#end_block

