386
#method_before
public static BgpLinkAttrUnRsrvdLinkBandwidth read(ChannelBuffer cb, short sType) throws BGPParseException {
    float[] maxUnResBandwidth;
    short lsAttrLength = cb.readShort();
    if (lsAttrLength != MAX_BANDWIDTH_LEN * NO_OF_PRIORITY) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    maxUnResBandwidth = new float[NO_OF_PRIORITY];
    for (int i = 0; i < NO_OF_PRIORITY; i++) {
        maxUnResBandwidth[i] = ieeeToFloatRead(cb.readInt()) * NO_OF_BITS;
    }
    return new BgpLinkAttrUnRsrvdLinkBandwidth(maxUnResBandwidth, sType);
}
#method_after
public static BgpLinkAttrUnRsrvdLinkBandwidth read(ChannelBuffer cb, short sType) throws BGPParseException {
    float[] maxUnResBandwidth;
    short lsAttrLength = cb.readShort();
    if ((lsAttrLength != MAX_BANDWIDTH_LEN * NO_OF_PRIORITY) || (cb.readableBytes() < lsAttrLength)) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    maxUnResBandwidth = new float[NO_OF_PRIORITY];
    for (int i = 0; i < NO_OF_PRIORITY; i++) {
        maxUnResBandwidth[i] = ieeeToFloatRead(cb.readInt()) * NO_OF_BITS;
    }
    return new BgpLinkAttrUnRsrvdLinkBandwidth(maxUnResBandwidth, sType);
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) {
    // TODO Auto-generated method stub
    return 0;
}
#method_after
@Override
public int write(ChannelBuffer cb) {
    // TODO This will be implemented in the next version
    return 0;
}
#end_block

#method_before
private static String getSiteLocalAddress() {
    /*
         * If the IP ONOS should use is set via the environment variable we will assume it is valid and should be used.
         * Setting the IP address takes presidence over setting the interface via the environment.
         */
    String useOnosIp = System.getenv(ONOS_IP);
    if (useOnosIp != null) {
        return useOnosIp;
    }
    // Read environment variables for IP interface information or set to default
    String useOnosInterface = System.getenv(ONOS_INTERFACE);
    if (useOnosInterface == null) {
        useOnosInterface = DEFAULT_ONOS_INTERFACE;
    }
    // Capture if they want to limit IP address selection to only IPv4 (default).
    boolean allowIPv6 = (System.getenv(ONOS_ALLOW_IPV6) != null);
    Function<NetworkInterface, IpAddress> ipLookup = nif -> {
        IpAddress fallback = null;
        // nif can be null if the interface name specified doesn't exist on the node's host
        if (nif != null) {
            for (InetAddress address : Collections.list(nif.getInetAddresses())) {
                if (address.isSiteLocalAddress() && (allowIPv6 || address instanceof Inet4Address)) {
                    return IpAddress.valueOf(address);
                }
                if (fallback == null && !address.isLoopbackAddress() && !address.isMulticastAddress() && (allowIPv6 || address instanceof Inet4Address)) {
                    fallback = IpAddress.valueOf(address);
                }
            }
        }
        return fallback;
    };
    try {
        IpAddress ip = ipLookup.apply(NetworkInterface.getByName(useOnosInterface));
        if (ip != null) {
            return ip.toString();
        }
        for (NetworkInterface nif : Collections.list(getNetworkInterfaces())) {
            if (nif.getName() != useOnosInterface) {
                ip = ipLookup.apply(nif);
                if (ip != null) {
                    return ip.toString();
                }
            }
        }
    } catch (Exception e) {
        throw new IllegalStateException("Unable to get network interfaces", e);
    }
    return IpAddress.valueOf(InetAddress.getLoopbackAddress()).toString();
}
#method_after
private static String getSiteLocalAddress() {
    /*
         * If the IP ONOS should use is set via the environment variable we will assume it is valid and should be used.
         * Setting the IP address takes presidence over setting the interface via the environment.
         */
    String useOnosIp = System.getenv(ONOS_IP);
    if (useOnosIp != null) {
        return useOnosIp;
    }
    // Read environment variables for IP interface information or set to default
    String useOnosInterface = System.getenv(ONOS_INTERFACE);
    if (useOnosInterface == null) {
        useOnosInterface = DEFAULT_ONOS_INTERFACE;
    }
    // Capture if they want to limit IP address selection to only IPv4 (default).
    boolean allowIPv6 = (System.getenv(ONOS_ALLOW_IPV6) != null);
    Function<NetworkInterface, IpAddress> ipLookup = nif -> {
        IpAddress fallback = null;
        // nif can be null if the interface name specified doesn't exist on the node's host
        if (nif != null) {
            for (InetAddress address : Collections.list(nif.getInetAddresses())) {
                if (address.isSiteLocalAddress() && (allowIPv6 || address instanceof Inet4Address)) {
                    return IpAddress.valueOf(address);
                }
                if (fallback == null && !address.isLoopbackAddress() && !address.isMulticastAddress() && (allowIPv6 || address instanceof Inet4Address)) {
                    fallback = IpAddress.valueOf(address);
                }
            }
        }
        return fallback;
    };
    try {
        IpAddress ip = ipLookup.apply(NetworkInterface.getByName(useOnosInterface));
        if (ip != null) {
            return ip.toString();
        }
        for (NetworkInterface nif : Collections.list(getNetworkInterfaces())) {
            if (!nif.getName().equals(useOnosInterface)) {
                ip = ipLookup.apply(nif);
                if (ip != null) {
                    return ip.toString();
                }
            }
        }
    } catch (Exception e) {
        throw new IllegalStateException("Unable to get network interfaces", e);
    }
    return IpAddress.valueOf(InetAddress.getLoopbackAddress()).toString();
}
#end_block

#method_before
private void dispatchMessage(BGPMessage m) {
    bgpPacketStats.addInPacket();
    bgpController.processBGPPacket(thisbgpId, m);
}
#method_after
private void dispatchMessage(BGPMessage m) throws BGPParseException {
    bgpPacketStats.addInPacket();
    bgpController.processBGPPacket(thisbgpId, m);
}
#end_block

#method_before
@Override
public void writeMsg(BGPId bgpId, BGPMessage msg) {
// TODO: Send message
}
#method_after
@Override
public void writeMsg(BGPId bgpId, BGPMessage msg) {
    this.getPeer(bgpId).sendMessage(msg);
}
#end_block

#method_before
@Override
public void processBGPPacket(BGPId bgpId, BGPMessage msg) {
    switch(msg.getType()) {
        case OPEN:
            // TODO: Process Open message
            break;
        case KEEP_ALIVE:
            // TODO: Process keepalive message
            break;
        case NOTIFICATION:
            // TODO: Process notificatoin message
            break;
        case UPDATE:
            // TODO: Process update message
            break;
        default:
            // TODO: Process other message
            break;
    }
}
#method_after
@Override
public void processBGPPacket(BGPId bgpId, BGPMessage msg) throws BGPParseException {
    switch(msg.getType()) {
        case OPEN:
            // TODO: Process Open message
            break;
        case KEEP_ALIVE:
            // TODO: Process keepalive message
            break;
        case NOTIFICATION:
            // TODO: Process notificatoin message
            break;
        case UPDATE:
            // TODO: Process update message
            break;
        default:
            // TODO: Process other message
            break;
    }
}
#end_block

#method_before
public BGPPeer getBGPPeerInstance(BGPController bgpController, BGPId bgpId, BGPVersion pv, BGPPacketStats pktStats) {
    BGPPeer bgpPeer = new BGPPeerImpl(bgpController);
    bgpPeer.init(bgpId, pv, pktStats);
    return bgpPeer;
}
#method_after
public BGPPeer getBGPPeerInstance(BGPController bgpController, BgpSessionInfoImpl sessionInfo, BGPPacketStatsImpl pktStats) {
    BGPPeer bgpPeer = new BGPPeerImpl(bgpController, sessionInfo, pktStats);
    return bgpPeer;
}
#end_block

#method_before
@Override
public BGPFactory factory() {
    return BGPFactories.getFactory(sessionInfo.getRemoteBgpVersion());
}
#method_after
@Override
public BGPFactory factory() {
    return BGPFactories.getFactory(sessionInfo.remoteBgpVersion());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("channel", channelId()).add("bgpId", getBGPId()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("channel", channelId()).add("bgpId", sessionInfo().remoteBgpId()).toString();
}
#end_block

#method_before
public void start() {
    applicationService.addListener(appListener);
}
#method_after
public void start() {
}
#end_block

#method_before
public void stop() {
    synchronized (this) {
        // Stop the thread(s)
        bgpIntentsSynchronizerExecutor.shutdownNow();
        log.info("BGP Intents Synchronizer Executor shutdown completed");
    }
}
#method_after
public void stop() {
    synchronized (this) {
        // Stop the thread(s)
        intentsSynchronizerExecutor.shutdownNow();
        log.info("Intents Synchronizer Executor shutdown completed");
    }
}
#end_block

#method_before
private void removeIntents() {
    if (!isElectedLeader) {
        // only leader will withdraw and purge intents
        return;
    }
    log.info("I am sdn-ip leader");
    log.debug("SDN-IP Intent Synchronizer shutdown: " + "withdrawing and purging all intents...");
    Set<Key> keys = intents.keySet();
    CountDownLatch withdrawLatch = new CountDownLatch(intents.size());
    IntentListener listener = null;
    listener = (IntentEvent event) -> {
        if (keys.contains(event.subject().key())) {
            if (event.type() == IntentEvent.Type.WITHDRAWN || event.type() == IntentEvent.Type.FAILED) {
                withdrawLatch.countDown();
                keys.remove(event.subject().key());
            }
        }
    };
    intentService.addListener(listener);
    // withdraw intents
    for (Entry<Key, Intent> entry : intents.entrySet()) {
        intentService.withdraw(entry.getValue());
        log.debug("SDN-IP Intent Synchronizer withdrawing intent: {}", entry.getValue());
    }
    // waiting intent withdraw events for a certain time
    try {
        withdrawLatch.await(10, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        log.debug("Time out waiting for intents withdraw. We still have " + "not received the following intent withdraw events :" + " {}", keys);
    }
    // purge intents
    for (Entry<Key, Intent> entry : intents.entrySet()) {
        if (CAN_PURGE.contains(intentService.getIntentState(entry.getKey()))) {
            intentService.purge(entry.getValue());
            log.debug("SDN-IP Intent Synchronizer purging intent: {}", entry.getValue());
        }
    }
    intents.clear();
    log.info("Tried to clean all the SDN-IP relative intents");
}
#method_after
public void removeIntents() {
    if (!isElectedLeader) {
        // only leader will withdraw intents
        return;
    }
    log.debug("Intent Synchronizer shutdown: withdrawing all intents...");
    for (Entry<Key, Intent> entry : intents.entrySet()) {
        intentService.withdraw(entry.getValue());
        log.debug("Intent Synchronizer withdrawing intent: {}", entry.getValue());
    }
    intents.clear();
    log.info("Tried to clean all intents");
}
#end_block

#method_before
@Override
public void submit(Intent intent) {
    synchronized (this) {
        intents.put(intent.key(), intent);
        if (isElectedLeader && isActivatedLeader) {
            log.trace("SDN-IP Submitting intent: {}", intent);
            intentService.submit(intent);
        }
    }
}
#method_after
@Override
public void submit(Intent intent) {
    synchronized (this) {
        intents.put(intent.key(), intent);
        if (isElectedLeader && isActivatedLeader) {
            log.trace("Submitting intent: {}", intent);
            intentService.submit(intent);
        }
    }
}
#end_block

#method_before
@Override
public void withdraw(Intent intent) {
    synchronized (this) {
        intents.remove(intent.key(), intent);
        if (isElectedLeader && isActivatedLeader) {
            log.trace("SDN-IP Withdrawing intent: {}", intent);
            intentService.withdraw(intent);
        }
    }
}
#method_after
@Override
public void withdraw(Intent intent) {
    synchronized (this) {
        intents.remove(intent.key(), intent);
        if (isElectedLeader && isActivatedLeader) {
            log.trace("Withdrawing intent: {}", intent);
            intentService.withdraw(intent);
        }
    }
}
#end_block

#method_before
public void leaderChanged(boolean isLeader) {
    log.debug("SDN-IP Leader changed: {}", isLeader);
    if (!isLeader) {
        this.isElectedLeader = false;
        this.isActivatedLeader = false;
        // Nothing to do
        return;
    }
    this.isActivatedLeader = false;
    this.isElectedLeader = true;
    // Run the synchronization method off-thread
    bgpIntentsSynchronizerExecutor.execute(this::synchronizeIntents);
}
#method_after
public void leaderChanged(boolean isLeader) {
    log.debug("Leader changed: {}", isLeader);
    if (!isLeader) {
        this.isElectedLeader = false;
        this.isActivatedLeader = false;
        // Nothing to do
        return;
    }
    this.isActivatedLeader = false;
    this.isElectedLeader = true;
    // Run the synchronization method off-thread
    intentsSynchronizerExecutor.execute(this::synchronizeIntents);
}
#end_block

#method_before
private void synchronizeIntents() {
    Map<Key, Intent> serviceIntents = new HashMap<>();
    intentService.getIntents().forEach(i -> {
        if (i.appId().equals(appId)) {
            serviceIntents.put(i.key(), i);
        }
    });
    List<Intent> intentsToAdd = new LinkedList<>();
    List<Intent> intentsToRemove = new LinkedList<>();
    for (Intent localIntent : intents.values()) {
        Intent serviceIntent = serviceIntents.remove(localIntent.key());
        if (serviceIntent == null) {
            intentsToAdd.add(localIntent);
        } else {
            IntentState state = intentService.getIntentState(serviceIntent.key());
            if (!IntentUtils.equals(serviceIntent, localIntent) || state == null || state == IntentState.WITHDRAW_REQ || state == IntentState.WITHDRAWING || state == IntentState.WITHDRAWN) {
                intentsToAdd.add(localIntent);
            }
        }
    }
    for (Intent serviceIntent : serviceIntents.values()) {
        IntentState state = intentService.getIntentState(serviceIntent.key());
        if (state != null && state != IntentState.WITHDRAW_REQ && state != IntentState.WITHDRAWING && state != IntentState.WITHDRAWN) {
            intentsToRemove.add(serviceIntent);
        }
    }
    log.debug("SDN-IP Intent Synchronizer: submitting {}, withdrawing {}", intentsToAdd.size(), intentsToRemove.size());
    // Withdraw Intents
    for (Intent intent : intentsToRemove) {
        intentService.withdraw(intent);
        log.trace("SDN-IP Intent Synchronizer: withdrawing intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("SDN-IP Intent Synchronizer: cannot withdraw intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    // Add Intents
    for (Intent intent : intentsToAdd) {
        intentService.submit(intent);
        log.trace("SDN-IP Intent Synchronizer: submitting intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("SDN-IP Intent Synchronizer: cannot submit intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    if (isElectedLeader) {
        // Allow push of Intents
        isActivatedLeader = true;
    } else {
        isActivatedLeader = false;
    }
    log.debug("SDN-IP intent synchronization completed");
}
#method_after
private void synchronizeIntents() {
    Map<Key, Intent> serviceIntents = new HashMap<>();
    intentService.getIntents().forEach(i -> {
        if (i.appId().equals(appId)) {
            serviceIntents.put(i.key(), i);
        }
    });
    List<Intent> intentsToAdd = new LinkedList<>();
    List<Intent> intentsToRemove = new LinkedList<>();
    for (Intent localIntent : intents.values()) {
        Intent serviceIntent = serviceIntents.remove(localIntent.key());
        if (serviceIntent == null) {
            intentsToAdd.add(localIntent);
        } else {
            IntentState state = intentService.getIntentState(serviceIntent.key());
            if (!IntentUtils.equals(serviceIntent, localIntent) || state == null || state == IntentState.WITHDRAW_REQ || state == IntentState.WITHDRAWING || state == IntentState.WITHDRAWN) {
                intentsToAdd.add(localIntent);
            }
        }
    }
    for (Intent serviceIntent : serviceIntents.values()) {
        IntentState state = intentService.getIntentState(serviceIntent.key());
        if (state != null && state != IntentState.WITHDRAW_REQ && state != IntentState.WITHDRAWING && state != IntentState.WITHDRAWN) {
            intentsToRemove.add(serviceIntent);
        }
    }
    log.debug("Intent Synchronizer: submitting {}, withdrawing {}", intentsToAdd.size(), intentsToRemove.size());
    // Withdraw Intents
    for (Intent intent : intentsToRemove) {
        intentService.withdraw(intent);
        log.trace("Intent Synchronizer: withdrawing intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("Intent Synchronizer: cannot withdraw intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    // Add Intents
    for (Intent intent : intentsToAdd) {
        intentService.submit(intent);
        log.trace("Intent Synchronizer: submitting intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("Intent Synchronizer: cannot submit intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    if (isElectedLeader) {
        // Allow push of Intents
        isActivatedLeader = true;
    } else {
        isActivatedLeader = false;
    }
    log.debug("Intent synchronization completed");
}
#end_block

#method_before
@Activate
protected void activate() {
    log.info("SDN-IP started");
    appId = coreService.registerApplication(SDN_IP_APP);
    localControllerNode = clusterService.getLocalNode();
    intentSynchronizer = new IntentSynchronizer(appId, intentService, applicationService, leadershipService);
    intentSynchronizer.start();
    peerConnectivity = new PeerConnectivityManager(appId, intentSynchronizer, networkConfigService, coreService.getAppId(RoutingService.ROUTER_APP_ID), interfaceService);
    peerConnectivity.start();
    fib = new SdnIpFib(appId, interfaceService, intentSynchronizer);
    routingService.addFibListener(fib);
    routingService.start();
    leadershipService.addListener(leadershipEventListener);
    leadershipService.runForLeadership(appId.name());
}
#method_after
@Activate
protected void activate() {
    log.info("SDN-IP started");
    appId = coreService.registerApplication(SDN_IP_APP);
    localControllerNode = clusterService.getLocalNode();
    intentSynchronizer = new IntentSynchronizer(appId, intentService);
    intentSynchronizer.start();
    peerConnectivity = new PeerConnectivityManager(appId, intentSynchronizer, networkConfigService, coreService.getAppId(RoutingService.ROUTER_APP_ID), interfaceService);
    peerConnectivity.start();
    fib = new SdnIpFib(appId, interfaceService, intentSynchronizer);
    routingService.addFibListener(fib);
    routingService.start();
    leadershipService.addListener(leadershipEventListener);
    leadershipService.runForLeadership(appId.name());
    applicationService.registerDeactivateHook(appId, intentSynchronizer::removeIntents);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    routingService.stop();
    peerConnectivity.stop();
    intentSynchronizer.stop();
    leadershipService.removeListener(leadershipEventListener);
    log.info("SDN-IP Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    routingService.stop();
    peerConnectivity.stop();
    intentSynchronizer.stop();
    leadershipService.withdraw(appId.name());
    leadershipService.removeListener(leadershipEventListener);
    log.info("SDN-IP Stopped");
}
#end_block

#method_before
public static MpUnReachNlri read(ChannelBuffer cb) throws BGPParseException {
    ChannelBuffer tempBuf = cb;
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    int len = parseFlags.isShort() ? parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempBuf.readBytes(len);
    if (!parseFlags.getFirstBit() | parseFlags.getSecondBit() | parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    if (cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    LinkedList<BGPLSNlri> mpUnReachNlri = new LinkedList<>();
    BGPLSNlri bgpLSNlri = null;
    short afi = 0;
    byte safi = 0;
    ChannelBuffer tempCb = cb.readBytes(parseFlags.getLength());
    while (tempCb.readableBytes() > 0) {
        afi = tempCb.readShort();
        safi = tempCb.readByte();
        // Supporting only for AFI 16388 / SAFI 71
        if ((afi == Constants.AFI_VALUE) && (safi == Constants.SAFI_VALUE) || (afi == Constants.AFI_VALUE) && (safi == Constants.VPN_SAFI_VALUE)) {
            while (tempCb.readableBytes() > 0) {
                short nlriType = tempCb.readShort();
                short totNlriLen = tempCb.readShort();
                if (tempCb.readableBytes() < totNlriLen) {
                    Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, totNlriLen);
                }
                tempBuf = tempCb.readBytes(totNlriLen);
                switch(nlriType) {
                    case BGPNodeLSNlriVer4.NODE_NLRITYPE:
                        bgpLSNlri = BGPNodeLSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    case LINK_NLRITYPE:
                        // TODO: to be merged later
                        break;
                    case BGPPrefixIPv4LSNlriVer4.PREFIX_IPV4_NLRITYPE:
                        bgpLSNlri = BGPPrefixIPv4LSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    default:
                        log.debug("nlriType not supported" + nlriType);
                }
                mpUnReachNlri.add(bgpLSNlri);
            }
        } else {
            // TODO: check with the values got from capability
            throw new BGPParseException("Not Supporting afi " + afi + "safi " + safi);
        }
    }
    return new MpUnReachNlri(mpUnReachNlri, afi, safi, parseFlags.getLength());
}
#method_after
public static MpUnReachNlri read(ChannelBuffer cb) throws BGPParseException {
    ChannelBuffer tempBuf = cb.copy();
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    int len = parseFlags.isShort() ? parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempBuf.readBytes(len);
    if (!parseFlags.getFirstBit() && parseFlags.getSecondBit() && parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    if (cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    LinkedList<BGPLSNlri> mpUnReachNlri = new LinkedList<>();
    BGPLSNlri bgpLSNlri = null;
    short afi = 0;
    byte safi = 0;
    ChannelBuffer tempCb = cb.readBytes(parseFlags.getLength());
    while (tempCb.readableBytes() > 0) {
        afi = tempCb.readShort();
        safi = tempCb.readByte();
        // Supporting only for AFI 16388 / SAFI 71
        if ((afi == Constants.AFI_VALUE) && (safi == Constants.SAFI_VALUE) || (afi == Constants.AFI_VALUE) && (safi == Constants.VPN_SAFI_VALUE)) {
            while (tempCb.readableBytes() > 0) {
                short nlriType = tempCb.readShort();
                short totNlriLen = tempCb.readShort();
                if (tempCb.readableBytes() < totNlriLen) {
                    Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, totNlriLen);
                }
                tempBuf = tempCb.readBytes(totNlriLen);
                switch(nlriType) {
                    case BGPNodeLSNlriVer4.NODE_NLRITYPE:
                        bgpLSNlri = BGPNodeLSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    case LINK_NLRITYPE:
                        // TODO: to be merged later
                        break;
                    case BGPPrefixIPv4LSNlriVer4.PREFIX_IPV4_NLRITYPE:
                        bgpLSNlri = BGPPrefixIPv4LSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    default:
                        log.debug("nlriType not supported" + nlriType);
                }
                mpUnReachNlri.add(bgpLSNlri);
            }
        } else {
            // TODO: check with the values got from capability
            throw new BGPParseException("Not Supporting afi " + afi + "safi " + safi);
        }
    }
    return new MpUnReachNlri(mpUnReachNlri, afi, safi, parseFlags.getLength());
}
#end_block

#method_before
public static MpReachNlri read(ChannelBuffer cb) throws BGPParseException {
    ChannelBuffer tempBuf = cb;
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    int len = parseFlags.isShort() ? parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempBuf.readBytes(len);
    if (cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    if (!parseFlags.getFirstBit() | parseFlags.getSecondBit() | parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    BGPLSNlri bgpLSNlri = null;
    LinkedList<BGPLSNlri> mpReachNlri = new LinkedList<>();
    ChannelBuffer tempCb = cb.readBytes(parseFlags.getLength());
    short afi = 0;
    byte safi = 0;
    Ip4Address ipNextHop = null;
    while (tempCb.readableBytes() > 0) {
        afi = tempCb.readShort();
        safi = tempCb.readByte();
        // Supporting for AFI 16388 / SAFI 71 and VPN AFI 16388 / SAFI 128
        if ((afi == Constants.AFI_VALUE) && (safi == Constants.SAFI_VALUE) || (afi == Constants.AFI_VALUE) && (safi == Constants.VPN_SAFI_VALUE)) {
            byte nextHopLen = tempCb.readByte();
            InetAddress ipAddress = (InetAddress) cb.readBytes(nextHopLen);
            if (ipAddress.isMulticastAddress()) {
                throw new BGPParseException("Multicast not supported");
            }
            ipNextHop = Ip4Address.valueOf(ipAddress);
            byte reserved = tempCb.readByte();
            while (tempCb.readableBytes() > 0) {
                short nlriType = tempCb.readShort();
                short totNlriLen = tempCb.readShort();
                if (tempCb.readableBytes() < totNlriLen) {
                    Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, totNlriLen);
                }
                tempBuf = tempCb.readBytes(totNlriLen);
                switch(nlriType) {
                    case BGPNodeLSNlriVer4.NODE_NLRITYPE:
                        bgpLSNlri = BGPNodeLSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    case LINK_NLRITYPE:
                        // TODO: To be merged later
                        break;
                    case BGPPrefixIPv4LSNlriVer4.PREFIX_IPV4_NLRITYPE:
                        bgpLSNlri = BGPPrefixIPv4LSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    default:
                        log.debug("nlriType not supported" + nlriType);
                }
                mpReachNlri.add(bgpLSNlri);
            }
        } else {
            // TODO: check with the values got from capability
            throw new BGPParseException("Not Supporting afi " + afi + "safi " + safi);
        }
    }
    return new MpReachNlri(mpReachNlri, afi, safi, ipNextHop, parseFlags.getLength());
}
#method_after
public static MpReachNlri read(ChannelBuffer cb) throws BGPParseException {
    ChannelBuffer tempBuf = cb.copy();
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    int len = parseFlags.isShort() ? parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + Constants.TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempBuf.readBytes(len);
    if (cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    if (!parseFlags.getFirstBit() && parseFlags.getSecondBit() && parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    BGPLSNlri bgpLSNlri = null;
    List<BGPLSNlri> mpReachNlri = new LinkedList<>();
    ChannelBuffer tempCb = cb.readBytes(parseFlags.getLength());
    short afi = 0;
    byte safi = 0;
    Ip4Address ipNextHop = null;
    while (tempCb.readableBytes() > 0) {
        afi = tempCb.readShort();
        safi = tempCb.readByte();
        // Supporting for AFI 16388 / SAFI 71 and VPN AFI 16388 / SAFI 128
        if ((afi == Constants.AFI_VALUE) && (safi == Constants.SAFI_VALUE) || (afi == Constants.AFI_VALUE) && (safi == Constants.VPN_SAFI_VALUE)) {
            byte nextHopLen = tempCb.readByte();
            // TODO: use Validation.toInetAddress once Validation is merged
            InetAddress ipAddress = (InetAddress) cb.readBytes(nextHopLen);
            if (ipAddress.isMulticastAddress()) {
                throw new BGPParseException("Multicast not supported");
            }
            ipNextHop = Ip4Address.valueOf(ipAddress);
            byte reserved = tempCb.readByte();
            while (tempCb.readableBytes() > 0) {
                short nlriType = tempCb.readShort();
                short totNlriLen = tempCb.readShort();
                if (tempCb.readableBytes() < totNlriLen) {
                    Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, totNlriLen);
                }
                tempBuf = tempCb.readBytes(totNlriLen);
                switch(nlriType) {
                    case BGPNodeLSNlriVer4.NODE_NLRITYPE:
                        bgpLSNlri = BGPNodeLSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    case LINK_NLRITYPE:
                        // TODO: To be merged later
                        break;
                    case BGPPrefixIPv4LSNlriVer4.PREFIX_IPV4_NLRITYPE:
                        bgpLSNlri = BGPPrefixIPv4LSNlriVer4.read(tempBuf, afi, safi);
                        break;
                    default:
                        log.debug("nlriType not supported" + nlriType);
                }
                mpReachNlri.add(bgpLSNlri);
            }
        } else {
            // TODO: check with the values got from capability
            throw new BGPParseException("Not Supporting afi " + afi + "safi " + safi);
        }
    }
    return new MpReachNlri(mpReachNlri, afi, safi, ipNextHop, parseFlags.getLength());
}
#end_block

#method_before
public static BgpLinkAttrOpaqLnkAttrib read(ChannelBuffer cb) throws BGPParseException {
    byte[] opaqueLinkAttribute;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    opaqueLinkAttribute = new byte[lsAttrLength];
    cb.readBytes(opaqueLinkAttribute);
    return new BgpLinkAttrOpaqLnkAttrib(opaqueLinkAttribute);
}
#method_after
public static BgpLinkAttrOpaqLnkAttrib read(ChannelBuffer cb) throws BGPParseException {
    byte[] opaqueLinkAttribute;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    opaqueLinkAttribute = new byte[lsAttrLength];
    cb.readBytes(opaqueLinkAttribute);
    return BgpLinkAttrOpaqLnkAttrib.of(opaqueLinkAttribute);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(opaqueLinkAttribute);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(opaqueLinkAttribute);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpLinkAttrOpaqLnkAttrib) {
        BgpLinkAttrOpaqLnkAttrib other = (BgpLinkAttrOpaqLnkAttrib) obj;
        return Objects.equals(opaqueLinkAttribute, other.opaqueLinkAttribute);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpLinkAttrOpaqLnkAttrib) {
        BgpLinkAttrOpaqLnkAttrib other = (BgpLinkAttrOpaqLnkAttrib) obj;
        return Arrays.equals(opaqueLinkAttribute, other.opaqueLinkAttribute);
    }
    return false;
}
#end_block

#method_before
private Map<FlowId, Set<StoredFlowEntry>> getFlowTable(DeviceId deviceId) {
    if (persistenceEnabled) {
        return flowEntries.computeIfAbsent(deviceId, id -> persistenceService.<FlowId, Set<StoredFlowEntry>>persistentMapBuilder().withName("FlowID:" + deviceId.toString()).withSerializer(new Serializer() {

            @Override
            public <T> byte[] encode(T object) {
                return SERIALIZER.encode(object);
            }

            @Override
            public <T> T decode(byte[] bytes) {
                return SERIALIZER.decode(bytes);
            }
        }).build());
    } else {
        return flowEntries.computeIfAbsent(deviceId, id -> Maps.newConcurrentMap());
    }
}
#method_after
private Map<FlowId, Set<StoredFlowEntry>> getFlowTable(DeviceId deviceId) {
    if (persistenceEnabled) {
        return flowEntries.computeIfAbsent(deviceId, id -> persistenceService.<FlowId, Set<StoredFlowEntry>>persistentMapBuilder().withName("FlowTable:" + deviceId.toString()).withSerializer(new Serializer() {

            @Override
            public <T> byte[] encode(T object) {
                return SERIALIZER.encode(object);
            }

            @Override
            public <T> T decode(byte[] bytes) {
                return SERIALIZER.decode(bytes);
            }
        }).build());
    } else {
        return flowEntries.computeIfAbsent(deviceId, id -> Maps.newConcurrentMap());
    }
}
#end_block

#method_before
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    List<BgpConfig.BgpSpeakerConfig> bgpSpeakers = Lists.newArrayList(config.bgpSpeakers());
    if (config == null) {
        print(NO_CONFIGURATION);
    }
    for (BgpConfig.BgpSpeakerConfig s : bgpSpeakers) {
        if (s.name().isPresent() && s.name().get().equals(name)) {
            log.debug("Speaker already exists: {}", name);
            return;
        }
    }
    addSpeakertoConfig(config);
}
#method_after
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.addConfig(appId, BgpConfig.class);
    BgpConfig.BgpSpeakerConfig speaker = config.getSpeakerWithName(name);
    if (speaker != null) {
        log.debug("Speaker already exists: {}", name);
        return;
    }
    addSpeakerToConf(config);
    configService.applyConfig(appId, BgpConfig.class, config.node());
    print(SPEAKER_ADD_SUCCESS);
}
#end_block

#method_before
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    List<BgpConfig.BgpSpeakerConfig> bgpSpeakers = Lists.newArrayList(config.bgpSpeakers());
    if (config == null || config.bgpSpeakers().isEmpty()) {
        print(NO_CONFIGURATION);
        return;
    }
    for (BgpConfig.BgpSpeakerConfig s : bgpSpeakers) {
        if (s.name().isPresent() && s.name().get().equals(name)) {
            if (!s.peers().isEmpty()) {
                // Removal is not allowed when peering connections exist.
                print(PEERS_EXIST, name);
                return;
            }
            removeSpeakerFromConfig(config);
            return;
        }
    }
    print(SPEAKER_NOT_FOUND, name);
}
#method_after
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    if (config == null || config.bgpSpeakers().isEmpty()) {
        print(NO_CONFIGURATION);
        return;
    }
    BgpConfig.BgpSpeakerConfig speaker = config.getSpeakerWithName(name);
    if (speaker == null) {
        print(SPEAKER_NOT_FOUND, name);
        return;
    } else {
        if (!speaker.peers().isEmpty()) {
            // Removal not allowed when peer connections exist.
            print(PEERS_EXIST, name);
            return;
        }
    }
    removeSpeakerFromConf(config);
    configService.applyConfig(appId, BgpConfig.class, config.node());
    print(SPEAKER_REMOVE_SUCCESS);
}
#end_block

#method_before
@Override
protected void execute() {
    sdnIp = (SdnIp) get(SdnIpService.class);
    peerAddress = IpAddress.valueOf(ip);
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    List<BgpConfig.BgpSpeakerConfig> bgpSpeakers = Lists.newArrayList(config.bgpSpeakers());
    if (config == null || config.bgpSpeakers().isEmpty()) {
        print(NO_CONFIGURATION);
        return;
    }
    peerAddress = IpAddress.valueOf(ip);
    for (BgpConfig.BgpSpeakerConfig s : bgpSpeakers) {
        if (s.peers().contains(peerAddress)) {
            log.debug("Modify speaker configuration to exclude peer: {}", peerAddress);
            config.removePeerFromSpeaker(s, peerAddress);
            destroyConnectivity();
            return;
        }
    }
    print(PEER_NOT_FOUND, ip);
}
#method_after
@Override
protected void execute() {
    peerAddress = IpAddress.valueOf(ip);
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    if (config == null || config.bgpSpeakers().isEmpty()) {
        print(NO_CONFIGURATION);
        return;
    }
    peerAddress = IpAddress.valueOf(ip);
    BgpConfig.BgpSpeakerConfig speaker = config.getSpeakerFromPeer(peerAddress);
    if (speaker == null) {
        print(PEER_NOT_FOUND, ip);
        return;
    }
    removePeerFromSpeakerConf(speaker, config);
    configService.applyConfig(appId, BgpConfig.class, config.node());
    print(PEER_REMOVE_SUCCESS);
}
#end_block

#method_before
// TODO add methods for updating config
public Set<BgpSpeakerConfig> bgpSpeakers() {
    Set<BgpSpeakerConfig> speakers = Sets.newHashSet();
    JsonNode speakersNode = object.get(SPEAKERS);
    speakersNode.forEach(jsonNode -> {
        Set<IpAddress> listenAddresses = Sets.newHashSet();
        jsonNode.path(PEERS).forEach(addressNode -> listenAddresses.add(IpAddress.valueOf(addressNode.asText())));
        Optional<String> name;
        if (jsonNode.get(NAME) == null) {
            name = Optional.empty();
        } else {
            name = Optional.of(jsonNode.get(NAME).asText());
        }
        speakers.add(new BgpSpeakerConfig(name, ConnectPoint.deviceConnectPoint(jsonNode.path(CONNECT_POINT).asText()), listenAddresses));
    });
    return speakers;
}
#method_after
// TODO add methods for updating config
public Set<BgpSpeakerConfig> bgpSpeakers() {
    Set<BgpSpeakerConfig> speakers = Sets.newHashSet();
    JsonNode speakersNode = object.get(SPEAKERS);
    if (speakersNode == null) {
        return speakers;
    }
    speakersNode.forEach(jsonNode -> {
        Set<IpAddress> listenAddresses = Sets.newHashSet();
        jsonNode.path(PEERS).forEach(addressNode -> listenAddresses.add(IpAddress.valueOf(addressNode.asText())));
        Optional<String> name;
        if (jsonNode.get(NAME) == null) {
            name = Optional.empty();
        } else {
            name = Optional.of(jsonNode.get(NAME).asText());
        }
        speakers.add(new BgpSpeakerConfig(name, ConnectPoint.deviceConnectPoint(jsonNode.path(CONNECT_POINT).asText()), listenAddresses));
    });
    return speakers;
}
#end_block

#method_before
public void addSpeaker(BgpSpeakerConfig speaker) {
    ArrayNode speakersNode = (ArrayNode) object.get(SPEAKERS);
    ObjectNode speakerNode = JsonNodeFactory.instance.objectNode();
    speakerNode.put(NAME, speaker.name().get());
    speakerNode.put(CONNECT_POINT, speaker.connectPoint().elementId().toString() + "/" + speaker.connectPoint().port().toString());
    ArrayNode peersNode = speakerNode.putArray(PEERS);
    for (IpAddress peerAddress : speaker.peers()) {
        peersNode.add(peerAddress.toString());
    }
    speakersNode.add(speakerNode);
}
#method_after
public void addSpeaker(BgpSpeakerConfig speaker) {
    ObjectNode speakerNode = JsonNodeFactory.instance.objectNode();
    speakerNode.put(NAME, speaker.name().get());
    speakerNode.put(CONNECT_POINT, speaker.connectPoint().elementId().toString() + "/" + speaker.connectPoint().port().toString());
    ArrayNode peersNode = speakerNode.putArray(PEERS);
    for (IpAddress peerAddress : speaker.peers()) {
        peersNode.add(peerAddress.toString());
    }
    ArrayNode speakersArray = bgpSpeakers().isEmpty() ? initBgpConfiguration() : (ArrayNode) object.get(SPEAKERS);
    speakersArray.add(speakerNode);
}
#end_block

#method_before
public void removeSpeaker(String speakerName) {
    ArrayNode speakersNode = (ArrayNode) object.get(SPEAKERS);
    for (int i = 0; i < speakersNode.size(); i++) {
        if (speakersNode.get(i).hasNonNull(NAME) && speakersNode.get(i).get(NAME).asText().equals(speakerName)) {
            speakersNode.remove(i);
            return;
        }
    }
}
#method_after
public void removeSpeaker(String speakerName) {
    ArrayNode speakersArray = (ArrayNode) object.get(SPEAKERS);
    for (int i = 0; i < speakersArray.size(); i++) {
        if (speakersArray.get(i).hasNonNull(NAME) && speakersArray.get(i).get(NAME).asText().equals(speakerName)) {
            speakersArray.remove(i);
            return;
        }
    }
}
#end_block

#method_before
public void addPeerToSpeaker(BgpSpeakerConfig speaker, IpAddress peerAddress) {
    JsonNode speakersNode = object.get(SPEAKERS);
    speakersNode.forEach(jsonNode -> {
        if (jsonNode.hasNonNull(NAME) && jsonNode.get(NAME).asText().equals(speaker.name().get())) {
            ArrayNode peersNode = (ArrayNode) jsonNode.get(PEERS);
            for (int i = 0; i < peersNode.size(); i++) {
                if (peersNode.get(i).toString().replaceAll("\"", "").equals(peerAddress.toString().replaceAll("\"", ""))) {
                    // Peer already exists.
                    return;
                }
            }
            peersNode.add(peerAddress.toString());
        }
    });
}
#method_after
public void addPeerToSpeaker(String speakerName, IpAddress peerAddress) {
    JsonNode speakersNode = object.get(SPEAKERS);
    speakersNode.forEach(jsonNode -> {
        if (jsonNode.hasNonNull(NAME) && jsonNode.get(NAME).asText().equals(speakerName)) {
            ArrayNode peersNode = (ArrayNode) jsonNode.get(PEERS);
            for (int i = 0; i < peersNode.size(); i++) {
                if (peersNode.get(i).asText().equals(peerAddress.toString())) {
                    // Peer already exists.
                    return;
                }
            }
            peersNode.add(peerAddress.toString());
        }
    });
}
#end_block

#method_before
public void removePeerFromSpeaker(BgpSpeakerConfig speaker, IpAddress peerAddress) {
    JsonNode speakersNode = object.get(SPEAKERS);
    speakersNode.forEach(jsonNode -> {
        if (jsonNode.hasNonNull(NAME) && jsonNode.get(NAME).asText().equals(speaker.name().get())) {
            ArrayNode peersNode = (ArrayNode) jsonNode.get(PEERS);
            for (int i = 0; i < peersNode.size(); i++) {
                if (peersNode.get(i).toString().replaceAll("\"", "").equals(peerAddress.toString().replaceAll("\"", ""))) {
                    peersNode.remove(i);
                }
            }
        }
    });
}
#method_after
public void removePeerFromSpeaker(BgpSpeakerConfig speaker, IpAddress peerAddress) {
    JsonNode speakersNode = object.get(SPEAKERS);
    speakersNode.forEach(jsonNode -> {
        if (jsonNode.hasNonNull(NAME) && jsonNode.get(NAME).asText().equals(speaker.name().get())) {
            ArrayNode peersNode = (ArrayNode) jsonNode.get(PEERS);
            for (int i = 0; i < peersNode.size(); i++) {
                if (peersNode.get(i).asText().equals(peerAddress.toString())) {
                    peersNode.remove(i);
                    return;
                }
            }
        }
    });
}
#end_block

#method_before
@Override
protected void execute() {
    sdnIp = (SdnIp) get(SdnIpService.class);
    peeringInterface = getPeeringInterface();
    peerAddress = IpAddress.valueOf(ip);
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    List<BgpConfig.BgpSpeakerConfig> bgpSpeakers = Lists.newArrayList(config.bgpSpeakers());
    if (config == null || config.bgpSpeakers().isEmpty()) {
        print(NO_CONFIGURATION);
        return;
    }
    for (BgpConfig.BgpSpeakerConfig s : bgpSpeakers) {
        if (s.name().isPresent() && s.name().get().equals(name)) {
            log.debug("Modify speaker configuration to include peer: {}", ip);
            config.addPeerToSpeaker(s, peerAddress);
            setUpConnectivity(s);
            return;
        }
    }
    print(SPEAKER_NOT_FOUND, name);
}
#method_after
@Override
protected void execute() {
    peerAddress = IpAddress.valueOf(ip);
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.getConfig(appId, BgpConfig.class);
    if (config == null || config.bgpSpeakers().isEmpty()) {
        print(NO_CONFIGURATION);
        return;
    }
    BgpConfig.BgpSpeakerConfig speaker = config.getSpeakerWithName(name);
    if (speaker == null) {
        print(SPEAKER_NOT_FOUND, name);
        return;
    } else {
        if (speaker.isConnectedToPeer(peerAddress)) {
            // Peering already exists.
            return;
        }
    }
    InterfaceService interfaceService = get(InterfaceService.class);
    if (interfaceService.getMatchingInterface(peerAddress) == null) {
        print(NO_INTERFACE, ip);
        return;
    }
    addPeerToSpeakerConf(config);
    configService.applyConfig(appId, BgpConfig.class, config.node());
    print(PEER_ADD_SUCCESS);
}
#end_block

#method_before
public String networkType() {
    return this.networkType;
}
#method_after
public NetworkType networkType() {
    return this.networkType;
}
#end_block

#method_before
public Builder networkType(String type) {
    this.networkType = type;
    return this;
}
#method_after
public Builder networkType(NetworkType type) {
    this.networkType = type;
    return this;
}
#end_block

#method_before
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        byte[] srcMacAddress = arp.getSenderHardwareAddress();
        byte[] dstMacAddress = arp.getTargetHardwareAddress();
        byte[] srcIPAddress = arp.getSenderProtocolAddress();
        byte[] dstIPAddress = arp.getTargetProtocolAddress();
        log.warn("Received an ARP packet {}", arp.toString());
        log.warn("ARP SrcMAC: {} DstMAC: {}", new MacAddress(srcMacAddress).toString(), new MacAddress(dstMacAddress).toString());
        // Searches the Dst MAC Address based on openstackPortMap
        MacAddress macAddress = null;
        for (OpenstackPort openstackPort : openstackPortHashMap.values()) {
            if (openstackPort.fixedIps().containsValue(Ip4Address.valueOf(dstIPAddress))) {
                macAddress = openstackPort.macAddress();
                log.warn("Found MACAddress: {}", macAddress.toString());
                break;
            }
        }
        if (macAddress == null) {
            return;
        }
        // Creates a response packet
        ARP arpReply = new ARP();
        arpReply.setOpCode(ARP.OP_REPLY).setHardwareAddressLength(arp.getHardwareAddressLength()).setHardwareType(arp.getHardwareType()).setProtocolAddressLength(arp.getProtocolAddressLength()).setProtocolType(arp.getProtocolType()).setSenderHardwareAddress(macAddress.toBytes()).setSenderProtocolAddress(dstIPAddress).setTargetHardwareAddress(srcMacAddress).setTargetProtocolAddress(srcIPAddress);
        // Sends a response packet
        ethernet.setDestinationMACAddress(srcMacAddress).setSourceMACAddress(macAddress).setEtherType(Ethernet.TYPE_ARP).setPayload(arpReply);
        TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
        builder.setOutput(pkt.receivedFrom().port());
        OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), builder.build(), ByteBuffer.wrap(ethernet.serialize()));
        packetService.emit(packet);
        log.warn("Transmitted ARP packet {}", arpReply.toString());
    }
}
#method_after
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        byte[] srcMacAddress = arp.getSenderHardwareAddress();
        byte[] srcIPAddress = arp.getSenderProtocolAddress();
        byte[] dstIPAddress = arp.getTargetProtocolAddress();
        // Searches the Dst MAC Address based on openstackPortMap
        MacAddress macAddress = null;
        OpenstackPort openstackPort = openstackPortMap.values().stream().filter(e -> e.fixedIps().containsValue(Ip4Address.valueOf(dstIPAddress))).findAny().orElse(null);
        if (openstackPort != null) {
            macAddress = openstackPort.macAddress();
            log.debug("Found MACAddress: {}", macAddress.toString());
        } else {
            return;
        }
        // Creates a response packet
        ARP arpReply = new ARP();
        arpReply.setOpCode(ARP.OP_REPLY).setHardwareAddressLength(arp.getHardwareAddressLength()).setHardwareType(arp.getHardwareType()).setProtocolAddressLength(arp.getProtocolAddressLength()).setProtocolType(arp.getProtocolType()).setSenderHardwareAddress(macAddress.toBytes()).setSenderProtocolAddress(dstIPAddress).setTargetHardwareAddress(srcMacAddress).setTargetProtocolAddress(srcIPAddress);
        // Sends a response packet
        ethernet.setDestinationMACAddress(srcMacAddress).setSourceMACAddress(macAddress).setEtherType(Ethernet.TYPE_ARP).setPayload(arpReply);
        TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
        builder.setOutput(pkt.receivedFrom().port());
        OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), builder.build(), ByteBuffer.wrap(ethernet.serialize()));
        packetService.emit(packet);
    }
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    openstackPortMap.put(openstackPort.id(), openstackPort);
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    // For DHCP purpose
    // registerDhcpInfo(openstackPort);
    openstackPortMap.put(openstackPort.id(), openstackPort);
}
#end_block

#method_before
@Override
public void deletePorts() {
}
#method_after
/*
    private void registerDhcpInfo(OpenstackPort openstackPort) {
        Ip4Address ip4Address;
        Ip4Address subnetMask;
        Ip4Address dhcpServer;
        Ip4Address gatewayIPAddress;
        Ip4Address domainServer;
        OpenstackSubnet openstackSubnet;

        ip4Address = (Ip4Address) openstackPort.fixedIps().values().toArray()[0];

        openstackSubnet = openstackSubnetMap.values().stream()
                .filter(n -> n.networkId().equals(openstackPort.networkId()))
                .findFirst().get();

        int prefix;
        String[] parts = openstackSubnet.cidr().split("/");
        prefix = Integer.parseInt(parts[1]);
        int mask = 0xffffffff << (32 - prefix);
        byte[] bytes = new byte[]{(byte) (mask >>> 24),
                (byte) (mask >> 16 & 0xff), (byte) (mask >> 8 & 0xff), (byte) (mask & 0xff)};

        subnetMask = Ip4Address.valueOf(bytes);
        gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
        dhcpServer = gatewayIPAddress;
        domainServer = Ip4Address.valueOf("8.8.8.8");

        dhcpService.setStaticMappingOpenstack(openstackPort.macAddress(),
                ip4Address, subnetMask, dhcpServer, gatewayIPAddress, domainServer);
    }
    */
@Override
public void deletePorts() {
}
#end_block

#method_before
@Override
public void createSubnet(OpenstackSubnet openstackSubnet) {
    openstackSubnetMap.put(openstackSubnet.id(), openstackSubnet);
}
#method_after
@Override
public void createSubnet(OpenstackSubnet openstackSubnet) {
    openstackSubnetMap.put(openstackSubnet.id(), openstackSubnet);
    log.debug("Added Subnet Info {}", openstackNetworkMap.get(openstackSubnet.id()));
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.warn("device {} is added", device.id());
    rulePopulator.populateDefaultRules(device.id());
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("device {} is added", device.id());
    rulePopulator.populateDefaultRules(device.id());
}
#end_block

#method_before
private void processPortAdded(Device device, Port port) {
    // TODO: All the logics need to be processed inside of the rulePopulator class
    synchronized (vniPortMap) {
        log.warn("port {} is updated", port.toString());
        updatePortMaps(device, port);
        if (!port.annotations().value("portName").equals("vxlan")) {
            populateFlowRulesForTrafficToSameCnode(device, port);
            populateFlowRulesForTrafficToDifferentCnode(device, port);
        }
    }
}
#method_after
private void processPortAdded(Device device, Port port) {
    // TODO: All the logics need to be processed inside of the rulePopulator class
    synchronized (vniPortMap) {
        log.debug("port {} is updated", port.toString());
        updatePortMaps(device, port);
        if (!port.annotations().value("portName").equals("vxlan")) {
            populateFlowRulesForTrafficToSameCnode(device, port);
            populateFlowRulesForTrafficToDifferentCnode(device, port);
        }
    }
}
#end_block

#method_before
private void processPortRemoved(Device device, Port port) {
    log.warn("port {} is removed", port.toString());
// TODO: need to update the vniPortMap
}
#method_after
private void processPortRemoved(Device device, Port port) {
    log.debug("port {} is removed", port.toString());
// TODO: need to update the vniPortMap
}
#end_block

#method_before
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    // (possibly avoided by flowrule subsystem?)
    if (tunnelPortMap.get(hostIpAddress) == null) {
        log.warn("There is no tunnel port information");
        return;
    }
    String vni = getVniForPort(portName);
    MacAddress vmMac = getVmMacAddressForPort(portName);
    if (!vniPortMap.isEmpty() && vniPortMap.get(vni) != null) {
        for (PortInfo portInfo : vniPortMap.get(vni)) {
            if (!portInfo.portName.equals(portName) && !portInfo.hostIp.equals(hostIpAddress)) {
                MacAddress vmMacx = getVmMacAddressForPort(portInfo.portName);
                rulePopulator.populateForwardingRuleForOtherCnode(vni, device.id(), portInfo.hostIp, portInfo.fixedIp, vmMacx, tunnelPortMap.get(hostIpAddress).number(), portInfo.deviceId, hostIpAddress, fixedIp, vmMac, tunnelPortMap.get(portInfo.hostIp).number());
            }
        }
    }
}
#method_after
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    // (possibly avoided by flowrule subsystem?)
    if (tunnelPortMap.get(hostIpAddress) == null) {
        log.debug("There is no tunnel port information");
        return;
    }
    String vni = getVniForPort(portName);
    MacAddress vmMac = getVmMacAddressForPort(portName);
    if (!vniPortMap.isEmpty() && vniPortMap.get(vni) != null) {
        for (PortInfo portInfo : vniPortMap.get(vni)) {
            if (!portInfo.portName.equals(portName) && !portInfo.hostIp.equals(hostIpAddress)) {
                MacAddress vmMacx = getVmMacAddressForPort(portInfo.portName);
                rulePopulator.populateForwardingRuleForOtherCnode(vni, device.id(), portInfo.hostIp, portInfo.fixedIp, vmMacx, tunnelPortMap.get(hostIpAddress).number(), portInfo.deviceId, hostIpAddress, fixedIp, vmMac, tunnelPortMap.get(portInfo.hostIp).number());
            }
        }
    }
}
#end_block

#method_before
private Ip4Prefix getCidrForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    OpenstackSubnet subnet = openstackSubnetMap.values().stream().filter(s -> s.networkId().equals(port.networkId())).findFirst().get();
    if (subnet == null) {
        log.warn("No subnet information for network {}", subnet.id());
        return null;
    }
    return Ip4Prefix.valueOf(subnet.cidr());
}
#method_after
private Ip4Prefix getCidrForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.debug("No port information for port {}", portName);
        return null;
    }
    OpenstackSubnet subnet = openstackSubnetMap.values().stream().filter(s -> s.networkId().equals(port.networkId())).findFirst().get();
    if (subnet == null) {
        log.debug("No subnet information for network {}", subnet.id());
        return null;
    }
    return Ip4Prefix.valueOf(subnet.cidr());
}
#end_block

#method_before
private String getVniForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkMap.values().stream().filter(n -> n.id().equals(port.networkId())).findFirst().get();
    if (network == null) {
        log.warn("No VNI information for network {}", network.id());
        return null;
    }
    return network.segmentId();
}
#method_after
private String getVniForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.debug("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkMap.values().stream().filter(n -> n.id().equals(port.networkId())).findFirst().get();
    if (network == null) {
        log.debug("No VNI information for network {}", network.id());
        return null;
    }
    return network.segmentId();
}
#end_block

#method_before
@Override
public void removeHost(HostId hostId) {
    checkNotNull(hostId, HOST_ID_NULL);
    HostEvent event = store.removeHost(hostId);
}
#method_after
@Override
public void removeHost(HostId hostId) {
    checkNotNull(hostId, HOST_ID_NULL);
    store.removeHost(hostId);
}
#end_block

#method_before
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    HostEvent event = store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
}
#method_after
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
}
#end_block

#method_before
@Override
public void hostVanished(HostId hostId) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    HostEvent event = store.removeHost(hostId);
}
#method_after
@Override
public void hostVanished(HostId hostId) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    store.removeHost(hostId);
}
#end_block

#method_before
@Override
public void removeIpFromHost(HostId hostId, IpAddress ipAddress) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    HostEvent event = store.removeIp(hostId, ipAddress);
}
#method_after
@Override
public void removeIpFromHost(HostId hostId, IpAddress ipAddress) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    store.removeIp(hostId, ipAddress);
}
#end_block

#method_before
public static BgpPrefixAttrOpaqueData read(ChannelBuffer cb) throws BGPParseException {
    byte[] opaquePrefixAttribute;
    short lsAttrLength = cb.readShort();
    opaquePrefixAttribute = new byte[lsAttrLength];
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    cb.readBytes(opaquePrefixAttribute);
    return new BgpPrefixAttrOpaqueData(opaquePrefixAttribute);
}
#method_after
public static BgpPrefixAttrOpaqueData read(ChannelBuffer cb) throws BGPParseException {
    byte[] opaquePrefixAttribute;
    short lsAttrLength = cb.readShort();
    opaquePrefixAttribute = new byte[lsAttrLength];
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    cb.readBytes(opaquePrefixAttribute);
    return BgpPrefixAttrOpaqueData.of(opaquePrefixAttribute);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(opaquePrefixAttribute);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(opaquePrefixAttribute);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpPrefixAttrOpaqueData) {
        BgpPrefixAttrOpaqueData other = (BgpPrefixAttrOpaqueData) obj;
        return Objects.equals(opaquePrefixAttribute, other.opaquePrefixAttribute);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpPrefixAttrOpaqueData) {
        BgpPrefixAttrOpaqueData other = (BgpPrefixAttrOpaqueData) obj;
        return Arrays.equals(opaquePrefixAttribute, other.opaquePrefixAttribute);
    }
    return false;
}
#end_block

#method_before
private void replyInternal(MessageContext context) {
    checkNotNull(context);
    checkArgument(context.type() == MessageType.REQUEST, MSG_NOT_REQUEST);
    if (hasIpAddress(context.inPort())) {
        // If the request came from outside the network, only reply if it was
        // for one of our external addresses.
        interfaceService.getInterfacesByPort(context.inPort()).stream().filter(intf -> intf.ipAddresses().stream().anyMatch(ia -> ia.ipAddress().equals(context.target()))).forEach(intf -> buildAndSendReply(context, intf.mac()));
        // Stop here and don't proxy ARPs if the port has an IP address
        return;
    }
    // See if we have the target host in the host store
    Set<Host> hosts = hostService.getHostsByIp(context.target());
    Host dst = null;
    Host src = hostService.getHost(hostId(context.srcMac(), context.vlan()));
    for (Host host : hosts) {
        if (host.vlan().equals(context.vlan())) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        buildAndSendReply(context, dst.mac());
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct port.
    boolean matched = false;
    Set<Interface> interfaces = interfaceService.getInterfacesByIp(context.sender());
    for (Interface intf : interfaces) {
        if (intf.vlan().equals(context.vlan())) {
            matched = true;
            sendTo(context.packet(), intf.connectPoint());
            break;
        }
    }
    if (matched) {
        return;
    }
    // If the packets has a vlanId look if there are some other
    // interfaces in the configuration on the same vlan and broadcast
    // the packet out just of through those interfaces.
    VlanId vlanId = context.vlan();
    Set<Interface> filteredVlanInterfaces = filterVlanInterfacesNoIp(interfaceService.getInterfacesByVlan(vlanId));
    if (!vlanId.equals(VlanId.NONE) && !vlanId.equals(null) && confContainsVlans(vlanId, context.inPort())) {
        vlanFlood(context.packet(), filteredVlanInterfaces, context.inPort);
        return;
    }
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming port.
    flood(context.packet(), context.inPort());
}
#method_after
private void replyInternal(MessageContext context) {
    checkNotNull(context);
    checkArgument(context.type() == MessageType.REQUEST, MSG_NOT_REQUEST);
    if (hasIpAddress(context.inPort())) {
        // If the request came from outside the network, only reply if it was
        // for one of our external addresses.
        interfaceService.getInterfacesByPort(context.inPort()).stream().filter(intf -> intf.ipAddresses().stream().anyMatch(ia -> ia.ipAddress().equals(context.target()))).forEach(intf -> buildAndSendReply(context, intf.mac()));
        // Stop here and don't proxy ARPs if the port has an IP address
        return;
    }
    // See if we have the target host in the host store
    Set<Host> hosts = hostService.getHostsByIp(context.target());
    Host dst = null;
    Host src = hostService.getHost(hostId(context.srcMac(), context.vlan()));
    for (Host host : hosts) {
        if (host.vlan().equals(context.vlan())) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        buildAndSendReply(context, dst.mac());
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct port.
    boolean matched = false;
    Set<Interface> interfaces = interfaceService.getInterfacesByIp(context.sender());
    for (Interface intf : interfaces) {
        if (intf.vlan().equals(context.vlan())) {
            matched = true;
            sendTo(context.packet(), intf.connectPoint());
            break;
        }
    }
    if (matched) {
        return;
    }
    // If the packets has a vlanId look if there are some other
    // interfaces in the configuration on the same vlan and broadcast
    // the packet out just of through those interfaces.
    VlanId vlanId = context.vlan();
    Set<Interface> filteredVlanInterfaces = filterVlanInterfacesNoIp(interfaceService.getInterfacesByVlan(vlanId));
    if (vlanId != null && !vlanId.equals(VlanId.NONE) && confContainsVlans(vlanId, context.inPort())) {
        vlanFlood(context.packet(), filteredVlanInterfaces, context.inPort);
        return;
    }
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming port.
    flood(context.packet(), context.inPort());
}
#end_block

#method_before
private boolean confContainsVlans(VlanId vlanId, ConnectPoint connectPoint) {
    Set<Interface> vlanInterfaces = interfaceService.getInterfacesByVlan(vlanId);
    boolean found = false;
    for (Interface intf : vlanInterfaces) {
        // with no ips configured.
        if (intf.connectPoint().equals(connectPoint) && intf.ipAddresses().isEmpty()) {
            found = true;
            break;
        }
    }
    if (vlanInterfaces.size() > 1 && found) {
        return true;
    }
    return false;
}
#method_after
private boolean confContainsVlans(VlanId vlanId, ConnectPoint connectPoint) {
    Set<Interface> vlanInterfaces = interfaceService.getInterfacesByVlan(vlanId);
    return interfaceService.getInterfacesByVlan(vlanId).stream().anyMatch(intf -> intf.connectPoint().equals(connectPoint) && intf.ipAddresses().isEmpty()) && vlanInterfaces.size() > 1;
}
#end_block

#method_before
@Test
public void testConstruction() {
    final String routerIdValue = "s";
    final RouterId routerId = RouterId.valueOf(routerIdValue);
    assertThat(routerId, is(notNullValue()));
    assertThat(routerId.valueOf(), is(routerIdValue));
}
#method_after
@Test
public void testConstruction() {
    final String routerIdValue = "s";
    final RouterId routerId = RouterId.valueOf(routerIdValue);
    assertThat(routerId, is(notNullValue()));
    assertThat(routerId.routerId(), is(routerIdValue));
}
#end_block

#method_before
public Iterable<FixedIp> externalFixedIps() {
    return externalFixedIps;
}
#method_after
public Collection<FixedIp> externalFixedIps() {
    return externalFixedIps;
}
#end_block

#method_before
@Test
public void testConstruction() {
    RouterGateway routerGateway = RouterGateway.routerGateway(networkId1, true, fixedIpSet1);
    assertThat(fixedIpSet1, is(notNullValue()));
    assertThat(fixedIpSet1, is(routerGateway.externalFixedIps()));
    assertThat(networkId1, is(notNullValue()));
    assertThat(networkId1, is(routerGateway.networkId()));
    assertThat(true, is(routerGateway.enableSnat()));
}
#method_after
@Test
public void testConstruction() {
    RouterGateway routerGateway = RouterGateway.routerGateway(networkId1, true, fixedIpSet1);
    assertThat(fixedIpSet1, is(notNullValue()));
    assertThat(fixedIpSet1, is(routerGateway.externalFixedIps()));
    assertThat(networkId1, is(notNullValue()));
    assertThat(networkId1, is(routerGateway.networkId()));
    assertThat(routerGateway.enableSnat(), is(true));
}
#end_block

#method_before
public static DefaultGroupHandler createGroupHandler(DeviceId deviceId, ApplicationId appId, DeviceProperties config, LinkService linkService, FlowObjectiveService flowObjService, EventuallyConsistentMap<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjStore, EventuallyConsistentMap<SubnetNextObjectiveStoreKey, Integer> subnetNextObjStore) {
    if (config.isEdgeDevice(deviceId)) {
        return new DefaultEdgeGroupHandler(deviceId, appId, config, linkService, flowObjService, nsNextObjStore, subnetNextObjStore);
    } else {
        return new DefaultTransitGroupHandler(deviceId, appId, config, linkService, flowObjService, nsNextObjStore, subnetNextObjStore);
    }
}
#method_after
public static DefaultGroupHandler createGroupHandler(DeviceId deviceId, ApplicationId appId, DeviceProperties config, LinkService linkService, FlowObjectiveService flowObjService, EventuallyConsistentMap<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjStore, EventuallyConsistentMap<SubnetNextObjectiveStoreKey, Integer> subnetNextObjStore) throws DeviceConfigNotFoundException {
    // handle possible exception in the caller
    if (config.isEdgeDevice(deviceId)) {
        return new DefaultEdgeGroupHandler(deviceId, appId, config, linkService, flowObjService, nsNextObjStore, subnetNextObjStore);
    } else {
        return new DefaultTransitGroupHandler(deviceId, appId, config, linkService, flowObjService, nsNextObjStore, subnetNextObjStore);
    }
}
#end_block

#method_before
public void linkUp(Link newLink) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.debug("Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    log.trace("linkUp: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the new bucket to be updated
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(newLink.src().port()).setEthDst(deviceConfig.getDeviceMac(newLink.dst().deviceId())).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            NextObjective nextObjective = nextObjBuilder.add(new SRNextObjectiveContext(deviceId));
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
}
#method_after
public void linkUp(Link newLink) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    MacAddress dstMac;
    try {
        dstMac = deviceConfig.getDeviceMac(newLink.dst().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting linkUp.");
        return;
    }
    log.debug("Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    log.trace("linkUp: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the new bucket to be updated
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(newLink.src().port()).setEthDst(dstMac).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            NextObjective nextObjective = nextObjBuilder.add(new SRNextObjectiveContext(deviceId));
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
}
#end_block

#method_before
public void portDown(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    log.trace("portDown: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the bucket to be removed
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(port).setEthDst(deviceConfig.getDeviceMac(portDeviceMap.get(port))).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).withId(nextId).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            NextObjective nextObjective = nextObjBuilder.remove(new SRNextObjectiveContext(deviceId));
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#method_after
public void portDown(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    MacAddress dstMac;
    try {
        dstMac = deviceConfig.getDeviceMac(portDeviceMap.get(port));
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting portDown.");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    log.trace("portDown: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        // Create the bucket to be removed
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(port).setEthDst(dstMac).setEthSrc(nodeMacAddr);
        if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
            tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
        }
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(NextObjective.Type.SIMPLE).withId(nextId).fromApp(appId);
            nextObjBuilder.addTreatment(tBuilder.build());
            log.debug("portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            NextObjective nextObjective = nextObjBuilder.remove(new SRNextObjectiveContext(deviceId));
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#end_block

#method_before
private boolean isSegmentIdSameAsNodeSegmentId(DeviceId deviceId, int sId) {
    return (deviceConfig.getSegmentId(deviceId) == sId);
}
#method_after
private boolean isSegmentIdSameAsNodeSegmentId(DeviceId deviceId, int sId) {
    int segmentId;
    try {
        segmentId = deviceConfig.getSegmentId(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting isSegmentIdSameAsNodeSegmentId.");
        return false;
    }
    return segmentId == sId;
}
#end_block

#method_before
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId d : ns.getDeviceIds()) {
            if (devicePortMap.get(d) == null) {
                log.warn("Device {} is not in the port map yet", d);
                return;
            } else if (devicePortMap.get(d).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", d);
                return;
            }
            for (PortNumber sp : devicePortMap.get(d)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(sp).setEthDst(deviceConfig.getDeviceMac(d)).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        NextObjective nextObj = nextObjBuilder.add(new SRNextObjectiveContext(deviceId));
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#method_after
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId d : ns.getDeviceIds()) {
            if (devicePortMap.get(d) == null) {
                log.warn("Device {} is not in the port map yet", d);
                return;
            } else if (devicePortMap.get(d).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", d);
                return;
            }
            MacAddress deviceMac;
            try {
                deviceMac = deviceConfig.getDeviceMac(d);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(d)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setOutput(sp).setEthDst(deviceMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        NextObjective nextObj = nextObjBuilder.add(new SRNextObjectiveContext(deviceId));
        flowObjectiveService.next(deviceId, nextObj);
        log.debug("createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#end_block

#method_before
public Ip4Address getRouterIp(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ip);
        return srinfo.ip;
    } else {
        String message = "getRouterIp fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#method_after
@Override
public Ip4Address getRouterIp(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ip);
        return srinfo.ip;
    } else {
        String message = "getRouterIp fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
public static SetQueueInstruction setQueue(final long queueId) {
    checkNotNull(queueId, "queue ID cannot be null");
    return new SetQueueInstruction(queueId);
}
#method_after
public static SetQueueInstruction setQueue(final long queueId, final PortNumber port) {
    checkNotNull(queueId, "queue ID cannot be null");
    return new SetQueueInstruction(queueId, port);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(type().toString()).add("queueId", queueId).toString();
}
#method_after
@Override
public String toString() {
    MoreObjects.ToStringHelper toStringHelper = toStringHelper(type().toString());
    toStringHelper.add("queueId", queueId);
    if (port() != null) {
        toStringHelper.add("port", port);
    }
    return toStringHelper.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(type().ordinal(), queueId);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type().ordinal(), queueId, port);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof SetQueueInstruction) {
        SetQueueInstruction that = (SetQueueInstruction) obj;
        return Objects.equals(queueId, that.queueId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof SetQueueInstruction) {
        SetQueueInstruction that = (SetQueueInstruction) obj;
        return Objects.equals(queueId, that.queueId) && Objects.equals(port, that.port);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(linkDescriptor.hashCode(), localNodeDescriptors, remoteNodeDescriptors);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(linkDescriptor, localNodeDescriptors, remoteNodeDescriptors);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("localNodeDescriptors", localNodeDescriptors).add("remoteNodeDescriptors", remoteNodeDescriptors).add("linkDescriptor", linkDescriptor).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("localNodeDescriptors", localNodeDescriptors).add("remoteNodeDescriptors", remoteNodeDescriptors).add("linkDescriptor", linkDescriptor).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PortChainId) {
        final PortChainId other = (PortChainId) obj;
        return Objects.equal(this.portChainId, other.portChainId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PortChainId) {
        final PortChainId other = (PortChainId) obj;
        return Objects.equals(this.portChainId, other.portChainId);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("portChainId", portChainId.toString()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("portChainId", portChainId).toString();
}
#end_block

#method_before
@Test
public void openMessageTest1() throws BGPParseException {
    // Open message without optional parameter
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1d, 0x01, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest1() throws BGPParseException {
    // Open message without optional parameter
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1d, 0x01, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    byte[] testOpenMsg;
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest2() throws BGPParseException {
    // OPEN Message (MultiProtocolExtension-CAPABILITY).
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x25, // BGP Header
    0x01, // Version
    0X04, // AS Number
    (byte) 0x00, // AS Number
    (byte) 0xc8, // Hold time
    0x00, // Hold time
    (byte) 0xb4, (byte) 0xb6, (byte) 0x02, 0x5d, // BGP Identifier
    (byte) 0xc8, // Opt Parameter length
    0x08, // Opt Parameter length
    0x02, // Opt Parameter length
    0x06, 0x01, 0x04, 0x00, 0x00, 0x00, // Multiprotocol CAPABILITY
    (byte) 0xc8 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest2() throws BGPParseException {
    // OPEN Message (MultiProtocolExtension-CAPABILITY).
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x25, // BGP Header
    0x01, // Version
    0X04, // AS Number
    (byte) 0x00, // AS Number
    (byte) 0xc8, // Hold time
    0x00, // Hold time
    (byte) 0xb4, (byte) 0xb6, (byte) 0x02, 0x5d, // BGP Identifier
    (byte) 0xc8, // Opt Parameter length
    0x08, // Opt Parameter length
    0x02, // Opt Parameter length
    0x06, 0x01, 0x04, 0x00, 0x00, 0x00, // Multiprotocol CAPABILITY
    (byte) 0xc8 };
    byte[] testOpenMsg;
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest3() throws BGPParseException {
    // OPEN Message (Four-Octet AS number capability).
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x25, // BGPHeader
    0x01, // Version
    0X04, // AS Number
    (byte) 0x00, // AS Number
    (byte) 0xc8, // Hold Time
    0x00, // Hold Time
    (byte) 0xb4, (byte) 0xb6, (byte) 0x02, 0x5d, // BGP Identifier
    (byte) 0xc8, // Opt Parameter Length
    0x08, // Opt Parameter Length
    0x02, // Opt Parameter Length
    0x06, 0x41, 0x04, 0x00, 0x01, 0x00, // Four Octet AS Number-CAPABILITY-TLV
    0x01 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest3() throws BGPParseException {
    // OPEN Message (Four-Octet AS number capability).
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x25, // BGPHeader
    0x01, // Version
    0X04, // AS Number
    (byte) 0x00, // AS Number
    (byte) 0xc8, // Hold Time
    0x00, // Hold Time
    (byte) 0xb4, (byte) 0xb6, (byte) 0x02, 0x5d, // BGP Identifier
    (byte) 0xc8, // Opt Parameter Length
    0x08, // Opt Parameter Length
    0x02, // Opt Parameter Length
    0x06, 0x41, 0x04, 0x00, 0x01, 0x00, // Four Octet AS Number-CAPABILITY-TLV
    0x01 };
    byte[] testOpenMsg;
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest4() throws BGPParseException {
    // OPEN Message with capabilities.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x2b, // BGPHeader
    0x01, // Version
    0X04, // AS Number
    (byte) 0x00, // AS Number
    (byte) 0xc8, // Hold Time
    0x00, // Hold Time
    (byte) 0xb4, // BGP Identifier
    (byte) 0xb6, // BGP Identifier
    (byte) 0x02, // BGP Identifier
    0x5d, // BGP Identifier
    (byte) 0xc8, // Opt Parameter Length
    0x0e, // Opt Parameter Length
    0x02, // Opt Parameter Length
    0x0c, // Multiprotocol extension capability
    0x01, // Multiprotocol extension capability
    0x04, // Multiprotocol extension capability
    0x00, // Multiprotocol extension capability
    0x00, // Multiprotocol extension capability
    0x00, // Multiprotocol extension capability
    (byte) 0xc8, 0x41, 0x04, 0x00, 0x01, 0x00, // Four Octet AS Number-CAPABILITY-TLV
    0x01 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest4() throws BGPParseException {
    // OPEN Message with capabilities.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x2b, // BGPHeader
    0x01, // Version
    0X04, // AS Number
    (byte) 0x00, // AS Number
    (byte) 0xc8, // Hold Time
    0x00, // Hold Time
    (byte) 0xb4, // BGP Identifier
    (byte) 0xb6, // BGP Identifier
    (byte) 0x02, // BGP Identifier
    0x5d, // BGP Identifier
    (byte) 0xc8, // Opt Parameter Length
    0x0e, // Opt Parameter Length
    0x02, // Opt Parameter Length
    0x0c, // Multiprotocol extension capability
    0x01, // Multiprotocol extension capability
    0x04, // Multiprotocol extension capability
    0x00, // Multiprotocol extension capability
    0x00, // Multiprotocol extension capability
    0x00, // Multiprotocol extension capability
    (byte) 0xc8, 0x41, 0x04, 0x00, 0x01, 0x00, // Four Octet AS Number-CAPABILITY-TLV
    0x01 };
    byte[] testOpenMsg;
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test(expected = BGPParseException.class)
public void openMessageTest5() throws BGPParseException {
    // OPEN Message with invalid version number.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1d, 0x01, 0X05, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#method_after
@Test(expected = BGPParseException.class)
public void openMessageTest5() throws BGPParseException {
    // OPEN Message with invalid version number.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1d, 0x01, 0X05, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#end_block

#method_before
@Test(expected = BGPParseException.class)
public void openMessageTest6() throws BGPParseException {
    // OPEN Message with marker set to 0.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x00, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x00, 0x1d, 0x01, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#method_after
@Test(expected = BGPParseException.class)
public void openMessageTest6() throws BGPParseException {
    // OPEN Message with marker set to 0.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x00, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x00, 0x1d, 0x01, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#end_block

#method_before
@Test(expected = BGPParseException.class)
public void openMessageTest7() throws BGPParseException {
    // OPEN Message with invalid header length.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1e, 0x01, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#method_after
@Test(expected = BGPParseException.class)
public void openMessageTest7() throws BGPParseException {
    // OPEN Message with invalid header length.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1e, 0x01, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#end_block

#method_before
@Test(expected = BGPParseException.class)
public void openMessageTest8() throws BGPParseException {
    // OPEN Message with invalid message type.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1d, 0x05, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message = null;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#method_after
@Test(expected = BGPParseException.class)
public void openMessageTest8() throws BGPParseException {
    // OPEN Message with invalid message type.
    byte[] openMsg = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, 0x00, 0x1d, 0x05, 0X04, (byte) 0xfe, 0x09, 0x00, (byte) 0xb4, (byte) 0xc0, (byte) 0xa8, 0x00, 0x0f, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    BGPMessageReader<BGPMessage> reader = BGPFactories.getGenericReader();
    BGPMessage message;
    BGPHeader bgpHeader = new BGPHeader();
    message = reader.readFrom(buffer, bgpHeader);
    assertThat(message, instanceOf(BGPOpenMsg.class));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv6AddressTlv) {
        IPv6AddressTlv other = (IPv6AddressTlv) obj;
        return Objects.equals(this.address, other.address);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv6AddressTlv) {
        IPv6AddressTlv other = (IPv6AddressTlv) obj;
        return Objects.equals(this.address, other.address) && Objects.equals(this.type, other.type);
    }
    return false;
}
#end_block

#method_before
public static IPv6AddressTlv read(ChannelBuffer cb, short type) throws BGPParseException {
    InetAddress ipAddress = (InetAddress) cb.readBytes(LENGTH);
    if (ipAddress.isMulticastAddress()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
    Ip6Address address = Ip6Address.valueOf(ipAddress);
    return IPv6AddressTlv.of(address, type);
}
#method_after
public static IPv6AddressTlv read(ChannelBuffer cb, short type) throws BGPParseException {
    // TODO: use Validation.toInetAddress once Validation is merged
    InetAddress ipAddress = (InetAddress) cb.readBytes(LENGTH);
    if (ipAddress.isMulticastAddress()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
    Ip6Address address = Ip6Address.valueOf(ipAddress);
    return IPv6AddressTlv.of(address, type);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", type).add("Length", LENGTH).add("IPv6 Interface Address", address).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("type", type).add("LENGTH", LENGTH).add("address", address).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", LENGTH).add("linkLocalIdentifer", linkLocalIdentifer).add("linkRemoteIdentifer", linkRemoteIdentifer).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("TYPE", TYPE).add("LENGTH", LENGTH).add("linkLocalIdentifer", linkLocalIdentifer).add("linkRemoteIdentifer", linkRemoteIdentifer).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv4AddressTlv) {
        IPv4AddressTlv other = (IPv4AddressTlv) obj;
        return Objects.equals(this.address, other.address);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv4AddressTlv) {
        IPv4AddressTlv other = (IPv4AddressTlv) obj;
        return Objects.equals(this.address, other.address) && Objects.equals(this.type, other.type);
    }
    return false;
}
#end_block

#method_before
public static IPv4AddressTlv read(ChannelBuffer cb, short type) throws BGPParseException {
    InetAddress ipAddress = (InetAddress) cb.readBytes(LENGTH);
    if (ipAddress.isMulticastAddress()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
    Ip4Address address = Ip4Address.valueOf(ipAddress);
    return IPv4AddressTlv.of(address, type);
}
#method_after
public static IPv4AddressTlv read(ChannelBuffer cb, short type) throws BGPParseException {
    // TODO: use Validation.toInetAddress once Validation is merged
    InetAddress ipAddress = (InetAddress) cb.readBytes(LENGTH);
    if (ipAddress.isMulticastAddress()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
    Ip4Address address = Ip4Address.valueOf(ipAddress);
    return IPv4AddressTlv.of(address, type);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", type).add("Length", LENGTH).add("IPv4 Interface address", address).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("type", type).add("LENGTH", LENGTH).add("address", address).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PortPairGroupId) {
        final PortPairGroupId other = (PortPairGroupId) obj;
        return Objects.equal(this.portPairGroupId, other.portPairGroupId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PortPairGroupId) {
        final PortPairGroupId other = (PortPairGroupId) obj;
        return Objects.equals(this.portPairGroupId, other.portPairGroupId);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("portPairGroupId", portPairGroupId.toString()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("portPairGroupId", portPairGroupId).toString();
}
#end_block

#method_before
@Test
public void testConstruction() {
    final String portPairIdValue = "dace4513-24fc-4fae-af4b-321c5e2eb3d1";
    final PortPairId portPairId = PortPairId.portPairId(portPairIdValue);
    assertThat(portPairId, is(notNullValue()));
    assertThat(portPairId.value(), is(UUID.fromString(portPairIdValue)));
}
#method_after
@Test
public void testConstruction() {
    final String portPairIdValue = "dace4513-24fc-4fae-af4b-321c5e2eb3d1";
    final PortPairId portPairId = PortPairId.of(portPairIdValue);
    assertThat(portPairId, is(notNullValue()));
    assertThat(portPairId.value(), is(UUID.fromString(portPairIdValue)));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PortPairId) {
        final PortPairId other = (PortPairId) obj;
        return Objects.equal(this.portPairId, other.portPairId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PortPairId) {
        final PortPairId other = (PortPairId) obj;
        return Objects.equals(this.portPairId, other.portPairId);
    }
    return false;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortChains() {
    Iterable<PortChain> portChains = service.getPortChains();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_chains", new PortChainCodec().encode(portChains, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortChains() {
    Iterable<PortChain> portChains = service.getPortChains();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_chains", new PortChainCodec().encode(portChains, this));
    return ok(result).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortChain(InputStream stream) {
    URI location;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortChain portChain = codec(PortChain.class).decode(jsonTree, this);
        service.createPortChain(portChain);
        location = new URI(portChain.portChainId().toString());
    } catch (IOException | URISyntaxException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.created(location).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortChain(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortChain portChain = codec(PortChain.class).decode(jsonTree, this);
        Boolean issuccess = nullIsNotFound(service.createPortChain(portChain), PORT_CHAIN_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port chain {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroups() {
    Iterable<PortPairGroup> portPairGroups = service.getPortPairGroups();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair_groups", new PortPairGroupCodec().encode(portPairGroups, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroups() {
    Iterable<PortPairGroup> portPairGroups = service.getPortPairGroups();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair_groups", new PortPairGroupCodec().encode(portPairGroups, this));
    return ok(result).build();
}
#end_block

#method_before
@GET
@Path("{group_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroup(@PathParam("group_id") String id) {
    if (!service.hasPortPairGroup(PortPairGroupId.portPairGroupId(id))) {
        return Response.status(NOT_FOUND).entity(PORT_PAIR_GROUP_NOT_FOUND).build();
    }
    PortPairGroup portPairGroup = nullIsNotFound(service.getPortPairGroup(PortPairGroupId.portPairGroupId(id)), PORT_PAIR_GROUP_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair_group", new PortPairGroupCodec().encode(portPairGroup, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{group_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroup(@PathParam("group_id") String id) {
    if (!service.exists(PortPairGroupId.portPairGroupId(id))) {
        return Response.status(NOT_FOUND).entity(PORT_PAIR_GROUP_NOT_FOUND).build();
    }
    PortPairGroup portPairGroup = nullIsNotFound(service.getPortPairGroup(PortPairGroupId.portPairGroupId(id)), PORT_PAIR_GROUP_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair_group", new PortPairGroupCodec().encode(portPairGroup, this));
    return ok(result).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortPairGroup(InputStream stream) {
    URI location;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortPairGroup portPairGroup = codec(PortPairGroup.class).decode(jsonTree, this);
        service.createPortPairGroup(portPairGroup);
        location = new URI(portPairGroup.portPairGroupId().toString());
    } catch (IOException | URISyntaxException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.created(location).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortPairGroup(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortPairGroup portPairGroup = codec(PortPairGroup.class).decode(jsonTree, this);
        Boolean issuccess = nullIsNotFound(service.createPortPairGroup(portPairGroup), PORT_PAIR_GROUP_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port pair group {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    portPairGroupStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairs() {
    Iterable<PortPair> portPairs = service.getPortPairs();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pairs", new PortPairCodec().encode(portPairs, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairs() {
    Iterable<PortPair> portPairs = service.getPortPairs();
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pairs", new PortPairCodec().encode(portPairs, this));
    return ok(result).build();
}
#end_block

#method_before
@GET
@Path("{pair_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPair(@PathParam("portPairId") String id) {
    if (!service.hasPortPair(PortPairId.valueOf(id))) {
        return ok("The port pair does not exist").build();
    }
    PortPair pp = nullIsNotFound(service.getPortPair(PortPairId.valueOf(id)), PORT_PAIR_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair", new PortPairCodec().encode(pp, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{pair_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPair(@PathParam("portPairId") String id) {
    if (!service.exists(PortPairId.portPairId(id))) {
        return Response.status(NOT_FOUND).entity(PORT_PAIR_NOT_FOUND).build();
    }
    PortPair portPair = nullIsNotFound(service.getPortPair(PortPairId.portPairId(id)), PORT_PAIR_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair", new PortPairCodec().encode(portPair, this));
    return ok(result).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortPair(InputStream stream) {
    URI location;
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortPair portPair = codec(PortPair.class).decode(jsonTree, this);
        service.createPortPair(portPair);
        location = new URI(portPair.portPairId().toString());
    } catch (IOException | URISyntaxException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.created(location).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortPair(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortPair portPair = codec(PortPair.class).decode(jsonTree, this);
        Boolean isSuccess = nullIsNotFound(service.createPortPair(portPair), PORT_PAIR_NOT_FOUND);
        return Response.status(OK).entity(isSuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port pair {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@PUT
@Path("{pair_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updatePortPair(@PathParam("pair_id") String id, final InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortPair portPair = codec(PortPair.class).decode(jsonTree, this);
        Boolean result = nullIsNotFound(service.updatePortPair(portPair), PORT_PAIR_NOT_FOUND);
        if (!result) {
            return Response.status(204).entity(PORT_PAIR_NOT_FOUND).build();
        }
        return Response.status(203).entity(result.toString()).build();
    } catch (Exception e) {
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@PUT
@Path("{pair_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updatePortPair(@PathParam("pair_id") String id, final InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        PortPair portPair = codec(PortPair.class).decode(jsonTree, this);
        Boolean isSuccess = nullIsNotFound(service.updatePortPair(portPair), PORT_PAIR_NOT_FOUND);
        return Response.status(OK).entity(isSuccess.toString()).build();
    } catch (IOException e) {
        log.error("Update port pair failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Path("{pair_id}")
@DELETE
public Response deletePortPair(@PathParam("pair_id") String id) throws IOException {
    try {
        PortPairId portPairId = PortPairId.valueOf(id);
        service.removePortPair(portPairId);
        return Response.status(201).entity("SUCCESS").build();
    } catch (Exception e) {
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@Path("{pair_id}")
@DELETE
public void deletePortPair(@PathParam("pair_id") String id) {
    PortPairId portPairId = PortPairId.portPairId(id);
    Boolean isSuccess = nullIsNotFound(service.removePortPair(portPairId), PORT_PAIR_NOT_FOUND);
    if (!isSuccess) {
        log.debug("Port pair identifier {} does not exist", id);
    }
}
#end_block

#method_before
@Override
public Builder add(Instruction instruction) {
    switch(instruction.type()) {
        case DROP:
        case NOACTION:
        case OUTPUT:
        case GROUP:
        case QUEUE:
        case L0MODIFICATION:
        case L2MODIFICATION:
        case L3MODIFICATION:
        case L4MODIFICATION:
            current.add(instruction);
            break;
        case TABLE:
            table = (Instructions.TableTypeTransition) instruction;
            break;
        case METADATA:
            meta = (Instructions.MetadataInstruction) instruction;
            break;
        case METER:
            meter = (Instructions.MeterInstruction) instruction;
            break;
        default:
            throw new IllegalArgumentException("Unknown instruction type: " + instruction.type());
    }
    return this;
}
#method_after
@Override
public Builder add(Instruction instruction) {
    switch(instruction.type()) {
        case DROP:
        case NOACTION:
        case OUTPUT:
        case GROUP:
        case QUEUE:
        case L0MODIFICATION:
        case L1MODIFICATION:
        case L2MODIFICATION:
        case L3MODIFICATION:
        case L4MODIFICATION:
        case EXTENSION:
            current.add(instruction);
            break;
        case TABLE:
            table = (Instructions.TableTypeTransition) instruction;
            break;
        case METADATA:
            meta = (Instructions.MetadataInstruction) instruction;
            break;
        case METER:
            meter = (Instructions.MeterInstruction) instruction;
            break;
        default:
            throw new IllegalArgumentException("Unknown instruction type: " + instruction.type());
    }
    return this;
}
#end_block

#method_before
private TrafficTreatment.Builder buildActions(List<OFAction> actions, TrafficTreatment.Builder builder) {
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    short lambda = ((OFOxmOchSigidBasic) ct.getField()).getValue().getChannelNumber();
                    builder.add(Instructions.modL0Lambda(Lambda.indexedLambda(lambda)));
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField.getField());
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls((short) popMpls.getEthertype().getValue());
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new DefaultGroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                builder.pushVlan();
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#method_after
private TrafficTreatment.Builder buildActions(List<OFAction> actions, TrafficTreatment.Builder builder) {
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    short lambda = ((OFOxmOchSigidBasic) ct.getField()).getValue().getChannelNumber();
                    builder.add(Instructions.modL0Lambda(Lambda.indexedLambda(lambda)));
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls((short) popMpls.getEthertype().getValue());
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new DefaultGroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                builder.pushVlan();
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#end_block

#method_before
private void handleSetField(TrafficTreatment.Builder builder, OFOxm<?> oxm) {
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#method_after
private void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action) {
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            DriverHandler driver = getDriver(dpid);
            ExtensionInterpreter interpreter = driver.behaviour(ExtensionInterpreter.class);
            if (interpreter != null) {
                builder.extension(interpreter.mapAction(action), DeviceId.deviceId(Dpid.uri(dpid)));
            }
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                if (ethType == EthType.VLAN_FRAME.getValue()) {
                    builder.matchVlanId(VlanId.ANY);
                } else {
                    builder.matchEthType((short) ethType);
                }
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(PortPair.class);
    portPairStore = storageService.<PortPairId, PortPair>eventuallyConsistentMapBuilder().withName("portpareirsto").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(PortPair.class);
    portPairStore = storageService.<PortPairId, PortPair>eventuallyConsistentMapBuilder().withName("portpairstore").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    portPairStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
public IpAddress getIpAddress() {
    return this.ipAddress;
}
#method_after
public IpAddress getIpAddress() {
    if (theInterface.ipAddresses().isEmpty()) {
        return null;
    }
    // We will just assume the first interface on the list
    IpAddress ipaddr = null;
    for (InterfaceIpAddress ifipaddr : theInterface.ipAddresses()) {
        ipaddr = ifipaddr.ipAddress();
        break;
    }
    return ipaddr;
}
#end_block

#method_before
public boolean areWeDr() {
    return (designatedRouter != null && designatedRouter.getPrimaryAddr().equals(ipAddress));
}
#method_after
public boolean areWeDr() {
    return (designatedRouter != null && designatedRouter.getPrimaryAddr().equals(this.getIpAddress()));
}
#end_block

#method_before
public void addNeighbor(PIMNeighbor nbr) {
    if (neighbors.containsKey(nbr.getPrimaryAddr())) {
        // TODO: Hmmm, how should this be handled?
        log.debug("We are adding a neighbor that already exists: {}", nbr.toString());
        neighbors.remove(nbr.getPrimaryAddr(), nbr);
    }
    neighbors.put(nbr.getPrimaryAddr(), nbr);
}
#method_after
public void addNeighbor(PIMNeighbor nbr) {
    if (neighbors.containsKey(nbr.getPrimaryAddr())) {
        log.debug("We are adding a neighbor that already exists: {}", nbr.toString());
        neighbors.remove(nbr.getPrimaryAddr());
    }
    neighbors.put(nbr.getPrimaryAddr(), nbr);
}
#end_block

#method_before
public void removeNeighbor(IpAddress ipaddr) {
    boolean reelect = (designatedRouter == null || designatedRouter.getPrimaryAddr().equals(ipaddr));
    if (neighbors.containsKey(ipaddr)) {
        neighbors.remove(ipaddr);
    }
    this.electDR();
}
#method_after
public void removeNeighbor(IpAddress ipaddr) {
    if (neighbors.containsKey(ipaddr)) {
        neighbors.remove(ipaddr);
    }
    this.electDR();
}
#end_block

#method_before
public void removeNeighbor(PIMNeighbor nbr) {
    boolean reelect = (designatedRouter == null || nbr.isDr());
    neighbors.remove(nbr.getPrimaryAddr(), nbr);
    this.electDR();
}
#method_after
public void removeNeighbor(PIMNeighbor nbr) {
    neighbors.remove(nbr.getPrimaryAddr(), nbr);
    this.electDR();
}
#end_block

#method_before
public void processHello(Ethernet ethPkt, ConnectPoint cp) {
    checkNotNull(ethPkt);
    checkNotNull(cp);
    MacAddress srcmac = ethPkt.getSourceMAC();
    IPv4 ip = (IPv4) ethPkt.getPayload();
    Ip4Address srcip = Ip4Address.valueOf(ip.getSourceAddress());
    PIM pim = (PIM) ip.getPayload();
    checkNotNull(pim);
    PIMHello hello = (PIMHello) pim.getPayload();
    checkNotNull(hello);
    PIMNeighbor nbr = this.findOrCreate(srcip, srcmac);
    if (nbr == null) {
        log.error("Could not create a neighbor for: {1}", srcip.toString());
        return;
    }
    if (cp != this.connectPoint) {
        log.error("PIM Hello message received from {} on incorrect interface {}", nbr.getPrimaryAddr(), this.toString());
    }
    nbr.refresh(hello);
}
#method_after
public void processHello(Ethernet ethPkt, ConnectPoint cp) {
    checkNotNull(ethPkt);
    checkNotNull(cp);
    MacAddress srcmac = ethPkt.getSourceMAC();
    IPv4 ip = (IPv4) ethPkt.getPayload();
    Ip4Address srcip = Ip4Address.valueOf(ip.getSourceAddress());
    PIM pim = (PIM) ip.getPayload();
    checkNotNull(pim);
    PIMHello hello = (PIMHello) pim.getPayload();
    checkNotNull(hello);
    PIMNeighbor nbr = this.findOrCreate(srcip, srcmac);
    if (nbr == null) {
        log.error("Could not create a neighbor for: {1}", srcip.toString());
        return;
    }
    ConnectPoint icp = theInterface.connectPoint();
    checkNotNull(icp);
    if (!cp.equals(icp)) {
        log.error("PIM Hello message received from {} on incorrect interface {}", nbr.getPrimaryAddr(), this.toString());
        return;
    }
    nbr.refresh(hello);
}
#end_block

#method_before
@Override
public String toString() {
    String out = "PIM Neighbors: ";
    if (this.ipAddress != null) {
        out += "IP: " + this.ipAddress.toString();
    } else {
        out += "IP: *Null*";
    }
    out += "\tPR: " + String.valueOf(this.priority) + "\n";
    return out;
}
#method_after
@Override
public String toString() {
    IpAddress ipaddr = this.getIpAddress();
    String out = "PIM Neighbors: ";
    if (ipaddr != null) {
        out += "IP: " + ipaddr.toString();
    } else {
        out += "IP: *Null*";
    }
    out += "\tPR: " + String.valueOf(this.priority) + "\n";
    return out;
}
#end_block

#method_before
public static Collection<PIMInterface> getInterfaces() {
    return interfaces.values();
}
#method_after
public Collection<PIMInterface> getInterfaces() {
    return interfaces.values();
}
#end_block

#method_before
public static String printInterfaces() {
    String str = "";
    for (PIMInterface pi : interfaces.values()) {
        str += pi.toString();
    }
    return str;
}
#method_after
public String printInterfaces() {
    String str = "";
    for (PIMInterface pi : interfaces.values()) {
        str += pi.toString();
    }
    return str;
}
#end_block

#method_before
public void refresh(PIMHello hello) {
    checkNotNull(hello);
    for (PIMHelloOption opt : hello.getOptions().values()) {
        int len = opt.getOptLength();
        byte[] value = new byte[len];
        ByteBuffer bb = ByteBuffer.wrap(value);
        switch(opt.getOptType()) {
            case PIMHelloOption.OPT_GENID:
                int newid = bb.getInt();
                if (this.genId != newid) {
                    // TODO: we have a newly rebooted neighbor.  Send them our joins.
                    this.genId = newid;
                }
                break;
            case PIMHelloOption.OPT_PRIORITY:
                int newpri = bb.getInt();
                if (this.priority != newpri) {
                    // The priorities have changed.  We may need to re-elect a new DR?
                    if (this.isDr || pimInterface.getDesignatedRouter().getPriority() < priority) {
                        reelect = true;
                    }
                    this.priority = newpri;
                }
                break;
            case PIMHelloOption.OPT_HOLDTIME:
                short holdtime = bb.getShort();
                if (this.holdtime != holdtime) {
                    this.holdtime = holdtime;
                    if (holdtime == 0) {
                        // We have a neighbor going down.  We can remove all joins
                        // we have learned from them.
                        // TODO: What else do we need to do when a neighbor goes down?
                        log.debug("PIM Neighbor has timed out: {}", this.primaryAddr.toString());
                        return;
                    }
                }
                break;
            case PIMHelloOption.OPT_PRUNEDELAY:
            case PIMHelloOption.OPT_ADDRLIST:
            default:
                log.debug("PIM Hello option type: {} not yet supported or unknown.", opt.getOptType());
                break;
        }
    }
    if (reelect) {
        pimInterface.electDR(this);
    }
    // Reset the next timeout timer
    this.resetTimeout();
}
#method_after
public void refresh(PIMHello hello) {
    checkNotNull(hello);
    boolean reelect = false;
    for (PIMHelloOption opt : hello.getOptions().values()) {
        int len = opt.getOptLength();
        ByteBuffer bb = ByteBuffer.wrap(opt.getValue());
        switch(opt.getOptType()) {
            case PIMHelloOption.OPT_GENID:
                int newid = bb.getInt();
                if (this.genId != newid) {
                    // We have a newly rebooted neighbor, this is where we would
                    // send them our joins.
                    this.genId = newid;
                }
                break;
            case PIMHelloOption.OPT_PRIORITY:
                int newpri = bb.getInt();
                if (this.priority != newpri) {
                    // The priorities have changed.  We may need to re-elect a new DR?
                    if (this.isDr || pimInterface.getDesignatedRouter().getPriority() < priority) {
                        reelect = true;
                    }
                    this.priority = newpri;
                }
                break;
            case PIMHelloOption.OPT_HOLDTIME:
                short holdtime = bb.getShort();
                if (this.holdtime != holdtime) {
                    this.holdtime = holdtime;
                    if (holdtime == 0) {
                        // We have a neighbor going down.  We can remove all joins
                        // we have learned from them.
                        log.debug("PIM Neighbor has timed out: {}", this.primaryAddr.toString());
                        return;
                    }
                }
                break;
            case PIMHelloOption.OPT_PRUNEDELAY:
            case PIMHelloOption.OPT_ADDRLIST:
            default:
                log.debug("PIM Hello option type: {} not yet supported or unknown.", opt.getOptType());
                break;
        }
    }
    if (reelect) {
        pimInterface.electDR(this);
    }
    // Reset the next timeout timer
    this.resetTimeout();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.pim");
    packetService.addProcessor(processor, PacketProcessor.director(1));
    // Build a traffic selector for all multicast traffic
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPProtocol(IPv4.PROTOCOL_PIM);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, appId);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.pim");
    // Initialize the Packet Handler class
    pimPacketHandler = PIMPacketHandler.getInstance();
    pimPacketHandler.initialize(packetService, appId);
    // Initialize the Interface class
    pimInterfaces = PIMInterfaces.getInstance();
    pimInterfaces.initialize(configService, interfaceService);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    packetService.removeProcessor(processor);
    processor = null;
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    PIMPacketHandler.getInstance().stop();
    log.info("Stopped");
}
#end_block

#method_before
// prints either the json or cli version of the hash map connect point
@Override
protected void execute() {
    // grab connect point neighbors hash map to send in to json encoder.
    Collection<PIMInterface> pimIntfs = PIMInterfaces.getInterfaces();
    if (outputJson()) {
        print("%s", json(pimIntfs));
    } else {
        print(PIMInterfaces.printInterfaces());
    }
}
#method_after
// prints either the json or cli version of the hash map connect point
@Override
protected void execute() {
    // grab connect point neighbors hash map to send in to json encoder.
    Collection<PIMInterface> pimIntfs = PIMInterfaces.getInstance().getInterfaces();
    if (outputJson()) {
        print("%s", json(pimIntfs));
    } else {
        print(PIMInterfaces.getInstance().printInterfaces());
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public boolean commit() {
    // TODO: rework commit implementation to be more intuitive
    checkState(isOpen, TX_NOT_OPEN_ERROR);
    CommitResponse response = null;
    try {
        List<DatabaseUpdate> updates = Lists.newLinkedList();
        txMaps.values().forEach(m -> updates.addAll(m.prepareDatabaseUpdates()));
        Transaction transaction = new DefaultTransaction(transactionId, updates);
        response = Futures.getUnchecked(database.prepareAndCommit(transaction));
    } finally {
        if (response != null && !response.success()) {
            abort();
            isOpen = false;
            return false;
        }
        isOpen = false;
        return true;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean commit() {
    // TODO: rework commit implementation to be more intuitive
    checkState(isOpen, TX_NOT_OPEN_ERROR);
    CommitResponse response = null;
    try {
        List<DatabaseUpdate> updates = Lists.newLinkedList();
        txMaps.values().forEach(m -> updates.addAll(m.prepareDatabaseUpdates()));
        Transaction transaction = new DefaultTransaction(transactionId, updates);
        response = Futures.getUnchecked(database.prepareAndCommit(transaction));
        return response.success();
    } catch (Exception e) {
        abort();
        return false;
    } finally {
        isOpen = false;
    }
}
#end_block

#method_before
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // Irrespective of whether the local is a MASTER or not for this device,
        // we need to create a SR-group-handler instance. This is because in a
        // multi-instance setup, any instance can initiate forwarding/next-objectives
        // for any switch (even if this instance is a SLAVE or not even connected
        // to the switch). To handle this, a default-group-handler instance is necessary
        // per switch.
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        // Also, in some cases, drivers may need extra
        // information to process rules (eg. Router IP/MAC); and so, we send
        // port addressing rules to the driver as well irrespective of whether
        // this instance is the master or not.
        defaultRoutingHandler.populatePortAddressingRules(device.id());
        if (mastershipService.isLocalMaster(device.id())) {
            groupHandler.createGroupsFromSubnetConfig();
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // Irrespective of whether the local is a MASTER or not for this device,
        // we need to create a SR-group-handler instance. This is because in a
        // multi-instance setup, any instance can initiate forwarding/next-objectives
        // for any switch (even if this instance is a SLAVE or not even connected
        // to the switch). To handle this, a default-group-handler instance is necessary
        // per switch.
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        // Also, in some cases, drivers may need extra
        // information to process rules (eg. Router IP/MAC); and so, we send
        // port addressing rules to the driver as well, irrespective of whether
        // this instance is the master or not.
        defaultRoutingHandler.populatePortAddressingRules(device.id());
        if (mastershipService.isLocalMaster(device.id())) {
            groupHandler.createGroupsFromSubnetConfig();
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
public void populateRouterIpPunts(DeviceId deviceId) {
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    ForwardingObjective.Builder puntIp = DefaultForwardingObjective.builder();
    List<Ip4Address> gws = config.getPortIPs(deviceId);
    gws.add(config.getRouterIp(deviceId));
    for (Ip4Address ipaddr : gws) {
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchIPDst(IpPrefix.valueOf(ipaddr, IpPrefix.MAX_INET_MASK_LENGTH));
        treatment.setOutput(PortNumber.CONTROLLER);
        puntIp.withSelector(selector.build());
        puntIp.withTreatment(treatment.build());
        puntIp.withFlag(Flag.VERSATILE).withPriority(HIGHEST_PRIORITY).makePermanent().fromApp(srManager.appId);
        log.debug("Installing forwarding objective to punt port IP addresses");
        srManager.flowObjectiveService.forward(deviceId, puntIp.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    }
}
#method_after
public void populateRouterIpPunts(DeviceId deviceId) {
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    ForwardingObjective.Builder puntIp = DefaultForwardingObjective.builder();
    Set<Ip4Address> allIps = new HashSet<Ip4Address>(config.getPortIPs(deviceId));
    allIps.add(config.getRouterIp(deviceId));
    for (Ip4Address ipaddr : allIps) {
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchIPDst(IpPrefix.valueOf(ipaddr, IpPrefix.MAX_INET_MASK_LENGTH));
        treatment.setOutput(PortNumber.CONTROLLER);
        puntIp.withSelector(selector.build());
        puntIp.withTreatment(treatment.build());
        puntIp.withFlag(Flag.VERSATILE).withPriority(HIGHEST_PRIORITY).makePermanent().fromApp(srManager.appId);
        log.debug("Installing forwarding objective to punt port IP addresses");
        srManager.flowObjectiveService.forward(deviceId, puntIp.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    }
}
#end_block

#method_before
@Override
public BGPMessage readFrom(ChannelBuffer cb, BGPHeader bgpHeader) throws BGPParseException {
    if (cb.readableBytes() < MINIMUM_COMMON_HEADER_LENGTH) {
        log.debug("Error: Packet should have minimum length.");
        Validation.validateLen(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, cb.readableBytes());
    }
    if (cb.readableBytes() > MAXIMUM_PACKET_LENGTH) {
        log.debug("Error: Packet should have length is more than 4096.");
        Validation.validateLen(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, cb.readableBytes());
    }
    try {
        // fixed value property version == 4
        byte[] marker = new byte[BGPHeader.MARKER_LENGTH];
        cb.readBytes(marker, 0, BGPHeader.MARKER_LENGTH);
        bgpHeader.setMarker(marker);
        for (int i = 0; i < BGPHeader.MARKER_LENGTH; i++) {
            if (marker[i] != (byte) 0xff) {
                throw new BGPParseException(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.CONNECTION_NOT_SYNCHRONIZED, null);
            }
        }
        short length = cb.readShort();
        if (length != (cb.readableBytes() + HEADER_AND_MSG_LEN)) {
            Validation.validateLen(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, length);
        }
        bgpHeader.setLength(length);
        byte type = cb.readByte();
        bgpHeader.setType(type);
        log.debug("reading update message of type " + type);
        int len = length - MINIMUM_COMMON_HEADER_LENGTH;
        switch(type) {
            case OPEN_MSG_TYPE:
                log.debug("OPEN MESSAGE is received");
                return BGPOpenMsgVer4.READER.readFrom(cb.readBytes(len), bgpHeader);
            case KEEPALIVE_MSG_TYPE:
                log.debug("KEEPALIVE MESSAGE is received");
                return BGPKeepaliveMsgVer4.READER.readFrom(cb.readBytes(len), bgpHeader);
            case UPDATE_MSG_TYPE:
                log.debug("UPDATE MESSAGE is received");
            // TODO: Update message version 4
            case NOTIFICATION_MSG_TYPE:
                log.debug("NOTIFICATION MESSAGE is received");
                return BGPNotificationMsgVer4.READER.readFrom(cb.readBytes(len), bgpHeader);
            default:
                byte[] errType = Ints.toByteArray(length);
                ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
                buffer.writeBytes(errType);
                throw new BGPParseException(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_TYPE, buffer);
        }
    } catch (IndexOutOfBoundsException e) {
        throw new BGPParseException("IndexOutOfBoundsException");
    }
}
#method_after
@Override
public BGPMessage readFrom(ChannelBuffer cb, BGPHeader bgpHeader) throws BGPParseException {
    if (cb.readableBytes() < MINIMUM_COMMON_HEADER_LENGTH) {
        log.error("Packet should have minimum length.");
        Validation.validateLen(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, cb.readableBytes());
    }
    if (cb.readableBytes() > MAXIMUM_PACKET_LENGTH) {
        log.error("Packet length should not exceed {}.", MAXIMUM_PACKET_LENGTH);
        Validation.validateLen(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, cb.readableBytes());
    }
    try {
        // fixed value property version == 4
        byte[] marker = new byte[BGPHeader.MARKER_LENGTH];
        cb.readBytes(marker, 0, BGPHeader.MARKER_LENGTH);
        bgpHeader.setMarker(marker);
        for (int i = 0; i < BGPHeader.MARKER_LENGTH; i++) {
            if (marker[i] != (byte) 0xff) {
                throw new BGPParseException(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.CONNECTION_NOT_SYNCHRONIZED, null);
            }
        }
        short length = cb.readShort();
        if (length != (cb.readableBytes() + HEADER_AND_MSG_LEN)) {
            Validation.validateLen(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, length);
        }
        bgpHeader.setLength(length);
        byte type = cb.readByte();
        bgpHeader.setType(type);
        log.debug("Reading update message of type " + type);
        int len = length - MINIMUM_COMMON_HEADER_LENGTH;
        switch(type) {
            case OPEN_MSG_TYPE:
                log.debug("OPEN MESSAGE is received");
                return BGPOpenMsgVer4.READER.readFrom(cb.readBytes(len), bgpHeader);
            case KEEPALIVE_MSG_TYPE:
                log.debug("KEEPALIVE MESSAGE is received");
                return BGPKeepaliveMsgVer4.READER.readFrom(cb.readBytes(len), bgpHeader);
            case UPDATE_MSG_TYPE:
                log.debug("UPDATE MESSAGE is received");
            // TODO: Update message version 4
            case NOTIFICATION_MSG_TYPE:
                log.debug("NOTIFICATION MESSAGE is received");
                return BGPNotificationMsgVer4.READER.readFrom(cb.readBytes(len), bgpHeader);
            default:
                Validation.validateType(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_TYPE, type);
                return null;
        }
    } catch (IndexOutOfBoundsException e) {
        throw new BGPParseException(BGPErrorType.MESSAGE_HEADER_ERROR, BGPErrorType.BAD_MESSAGE_LENGTH, null);
    }
}
#end_block

#method_before
public static Origin read(ChannelBuffer cb) throws BGPParseException {
    ChannelBuffer tempCb = cb;
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    int len = parseFlags.isShort() ? parseFlags.getLength() + TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if ((parseFlags.getLength() > ORIGIN_VALUE_LEN) || (cb.readableBytes() < parseFlags.getLength())) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    if (parseFlags.getFirstBit() || parseFlags.getSecondBit() || parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    byte originValue;
    originValue = cb.readByte();
    if ((originValue != ORIGINTYPE.INCOMPLETE.value) || (originValue != ORIGINTYPE.IGP.value) || (originValue != ORIGINTYPE.EGP.value)) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.INVALID_ORIGIN_ATTRIBUTE, data);
    }
    return new Origin(originValue);
}
#method_after
public static Origin read(ChannelBuffer cb) throws BGPParseException {
    ChannelBuffer tempCb = cb.copy();
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    int len = parseFlags.isShort() ? parseFlags.getLength() + TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if ((parseFlags.getLength() > ORIGIN_VALUE_LEN) || (cb.readableBytes() < parseFlags.getLength())) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    if (parseFlags.getFirstBit() && !parseFlags.getSecondBit() && parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    byte originValue;
    originValue = cb.readByte();
    if ((originValue != ORIGINTYPE.INCOMPLETE.value) || (originValue != ORIGINTYPE.IGP.value) || (originValue != ORIGINTYPE.EGP.value)) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.INVALID_ORIGIN_ATTRIBUTE, data);
    }
    return new Origin(originValue);
}
#end_block

#method_before
public static As4Path read(ChannelBuffer cb) throws BGPParseException {
    LinkedList<Integer> as4pathSET = new LinkedList<>();
    LinkedList<Integer> as4pathSEQ = new LinkedList<>();
    ChannelBuffer tempCb = cb;
    Validation validation = Validation.parseAttributeHeader(cb);
    if (cb.readableBytes() < validation.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, validation.getLength());
    }
    // if fourth bit is set length is read as short otherwise as byte , len includes type, length and value
    int len = validation.isShort() ? validation.getLength() + TYPE_AND_LEN_AS_SHORT : validation.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (validation.getFirstBit() || !validation.getSecondBit() || validation.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    ChannelBuffer tempBuf = cb.readBytes(validation.getLength());
    while (tempBuf.readableBytes() > 0) {
        byte pathSegType = tempBuf.readByte();
        // no of ASes
        byte pathSegLen = tempBuf.readByte();
        // length = no of Ases * ASnum size (4 bytes)
        int length = pathSegLen * ASNUM_SIZE;
        if (tempBuf.readableBytes() < length) {
            Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, length);
        }
        ChannelBuffer aspathBuf = tempBuf.readBytes(length);
        while (aspathBuf.readableBytes() > 0) {
            int asNum;
            asNum = aspathBuf.readInt();
            switch(pathSegType) {
                case AsPath.ASPATH_SET_TYPE:
                    as4pathSET.add(asNum);
                    break;
                case AsPath.ASPATH_SEQ_TYPE:
                    as4pathSEQ.add(asNum);
                    break;
                default:
                    log.debug("Other type Not Supported:" + pathSegType);
            }
        }
    }
    return new As4Path(as4pathSET, as4pathSEQ);
}
#method_after
public static As4Path read(ChannelBuffer cb) throws BGPParseException {
    List<Integer> as4pathSet = new ArrayList<>();
    List<Integer> as4pathSeq = new ArrayList<>();
    ChannelBuffer tempCb = cb.copy();
    Validation validation = Validation.parseAttributeHeader(cb);
    if (cb.readableBytes() < validation.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, validation.getLength());
    }
    // if fourth bit is set length is read as short otherwise as byte , len includes type, length and value
    int len = validation.isShort() ? validation.getLength() + TYPE_AND_LEN_AS_SHORT : validation.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (validation.getFirstBit() && !validation.getSecondBit() && validation.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    ChannelBuffer tempBuf = cb.readBytes(validation.getLength());
    while (tempBuf.readableBytes() > 0) {
        byte pathSegType = tempBuf.readByte();
        // no of ASes
        byte pathSegLen = tempBuf.readByte();
        // length = no of Ases * ASnum size (4 bytes)
        int length = pathSegLen * ASNUM_SIZE;
        if (tempBuf.readableBytes() < length) {
            Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, length);
        }
        ChannelBuffer aspathBuf = tempBuf.readBytes(length);
        while (aspathBuf.readableBytes() > 0) {
            int asNum;
            asNum = aspathBuf.readInt();
            switch(pathSegType) {
                case AsPath.ASPATH_SET_TYPE:
                    as4pathSet.add(asNum);
                    break;
                case AsPath.ASPATH_SEQ_TYPE:
                    as4pathSeq.add(asNum);
                    break;
                default:
                    log.debug("Other type Not Supported:" + pathSegType);
            }
        }
    }
    return new As4Path(as4pathSet, as4pathSeq);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(as4pathSET, as4pathSEQ);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(as4pathSet, as4pathSeq);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof As4Path) {
        As4Path other = (As4Path) obj;
        return Objects.equals(as4pathSET, other.as4pathSET) && Objects.equals(as4pathSEQ, other.as4pathSEQ);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof As4Path) {
        As4Path other = (As4Path) obj;
        return Objects.equals(as4pathSet, other.as4pathSet) && Objects.equals(as4pathSeq, other.as4pathSeq);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("aspathSet", as4pathSET).add("aspathSequence", as4pathSEQ).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("as4pathSet", as4pathSet).add("as4pathSeq", as4pathSeq).toString();
}
#end_block

#method_before
public static LocalPref read(ChannelBuffer cb) throws BGPParseException {
    int localPref;
    ChannelBuffer tempCb = cb;
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    if ((parseFlags.getLength() > LOCAL_PREF_MAX_LEN) || cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    int len = parseFlags.isShort() ? parseFlags.getLength() + TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (parseFlags.getFirstBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    localPref = cb.readInt();
    return new LocalPref(localPref);
}
#method_after
public static LocalPref read(ChannelBuffer cb) throws BGPParseException {
    int localPref;
    ChannelBuffer tempCb = cb.copy();
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    if ((parseFlags.getLength() > LOCAL_PREF_MAX_LEN) || cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    int len = parseFlags.isShort() ? parseFlags.getLength() + TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (parseFlags.getFirstBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    localPref = cb.readInt();
    return new LocalPref(localPref);
}
#end_block

#method_before
public static NextHop read(ChannelBuffer cb) throws BGPParseException {
    Ip4Address nextHop;
    ChannelBuffer tempCb = cb;
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    if (cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    int len = parseFlags.isShort() ? parseFlags.getLength() + TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (parseFlags.getFirstBit() || !parseFlags.getSecondBit() || parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    InetAddress ipAddress = (InetAddress) cb.readBytes(parseFlags.getLength());
    if (ipAddress.isMulticastAddress()) {
        throw new BGPParseException("Multicast address is not supported");
    }
    nextHop = Ip4Address.valueOf(ipAddress);
    return new NextHop(nextHop);
}
#method_after
public static NextHop read(ChannelBuffer cb) throws BGPParseException {
    Ip4Address nextHop;
    ChannelBuffer tempCb = cb.copy();
    Validation parseFlags = Validation.parseAttributeHeader(cb);
    if (cb.readableBytes() < parseFlags.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, parseFlags.getLength());
    }
    int len = parseFlags.isShort() ? parseFlags.getLength() + TYPE_AND_LEN_AS_SHORT : parseFlags.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (parseFlags.getFirstBit() && !parseFlags.getSecondBit() && parseFlags.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    // TODO: use Validation.toInetAddress once Validation is merged
    InetAddress ipAddress = (InetAddress) cb.readBytes(parseFlags.getLength());
    if (ipAddress.isMulticastAddress()) {
        throw new BGPParseException("Multicast address is not supported");
    }
    nextHop = Ip4Address.valueOf(ipAddress);
    return new NextHop(nextHop);
}
#end_block

#method_before
public static AsPath read(ChannelBuffer cb) throws BGPParseException {
    LinkedList<Short> aspathSET = new LinkedList<>();
    LinkedList<Short> aspathSEQ = new LinkedList<>();
    ChannelBuffer tempCb = cb;
    Validation validation = Validation.parseAttributeHeader(cb);
    if (cb.readableBytes() < validation.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, validation.getLength());
    }
    // if fourth bit is set, length is read as short otherwise as byte , len includes type, length and value
    int len = validation.isShort() ? validation.getLength() + TYPE_AND_LEN_AS_SHORT : validation.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (validation.getFirstBit() || !validation.getSecondBit() || validation.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    ChannelBuffer tempBuf = cb.readBytes(validation.getLength());
    while (tempBuf.readableBytes() > 0) {
        byte pathSegType = tempBuf.readByte();
        // no of ASes
        byte pathSegLen = tempBuf.readByte();
        int length = pathSegLen * ASNUM_SIZE;
        if (tempBuf.readableBytes() < length) {
            Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, length);
        }
        ChannelBuffer aspathBuf = tempBuf.readBytes(length);
        while (aspathBuf.readableBytes() > 0) {
            short asNum;
            asNum = aspathBuf.readShort();
            switch(pathSegType) {
                case ASPATH_SET_TYPE:
                    aspathSET.add(asNum);
                    break;
                case ASPATH_SEQ_TYPE:
                    aspathSEQ.add(asNum);
                    break;
                default:
                    log.debug("Other type Not Supported:" + pathSegType);
            }
        }
    }
    return new AsPath(aspathSET, aspathSEQ);
}
#method_after
public static AsPath read(ChannelBuffer cb) throws BGPParseException {
    List<Short> aspathSet = new ArrayList<>();
    List<Short> aspathSeq = new ArrayList<>();
    ChannelBuffer tempCb = cb.copy();
    Validation validation = Validation.parseAttributeHeader(cb);
    if (cb.readableBytes() < validation.getLength()) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, validation.getLength());
    }
    // if fourth bit is set, length is read as short otherwise as byte , len includes type, length and value
    int len = validation.isShort() ? validation.getLength() + TYPE_AND_LEN_AS_SHORT : validation.getLength() + TYPE_AND_LEN_AS_BYTE;
    ChannelBuffer data = tempCb.readBytes(len);
    if (validation.getFirstBit() && !validation.getSecondBit() && validation.getThirdBit()) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_FLAGS_ERROR, data);
    }
    ChannelBuffer tempBuf = cb.readBytes(validation.getLength());
    while (tempBuf.readableBytes() > 0) {
        byte pathSegType = tempBuf.readByte();
        // no of ASes
        byte pathSegLen = tempBuf.readByte();
        int length = pathSegLen * ASNUM_SIZE;
        if (tempBuf.readableBytes() < length) {
            Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, length);
        }
        ChannelBuffer aspathBuf = tempBuf.readBytes(length);
        while (aspathBuf.readableBytes() > 0) {
            short asNum;
            asNum = aspathBuf.readShort();
            switch(pathSegType) {
                case ASPATH_SET_TYPE:
                    aspathSet.add(asNum);
                    break;
                case ASPATH_SEQ_TYPE:
                    aspathSeq.add(asNum);
                    break;
                default:
                    log.debug("Other type Not Supported:" + pathSegType);
            }
        }
    }
    return new AsPath(aspathSet, aspathSeq);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(aspathSET, aspathSEQ);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(aspathSet, aspathSeq);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof AsPath) {
        AsPath other = (AsPath) obj;
        return Objects.equals(aspathSET, other.aspathSET) && Objects.equals(aspathSEQ, other.aspathSEQ);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof AsPath) {
        AsPath other = (AsPath) obj;
        return Objects.equals(aspathSet, other.aspathSet) && Objects.equals(aspathSeq, other.aspathSeq);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("aspathSet", aspathSET).add("aspathSequence", aspathSEQ).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("aspathSet", aspathSet).add("aspathSeq", aspathSeq).toString();
}
#end_block

#method_before
public static BgpPrefixAttrMetric read(ChannelBuffer cb) throws BGPParseException {
    int linkPfxMetric;
    // 4 Bytes
    short lsAttrLength = cb.readShort();
    if ((lsAttrLength != ATTR_PREFIX_LEN) || (cb.readableBytes() < lsAttrLength)) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    linkPfxMetric = cb.readInt();
    return new BgpPrefixAttrMetric(linkPfxMetric);
}
#method_after
public static BgpPrefixAttrMetric read(ChannelBuffer cb) throws BGPParseException {
    int linkPfxMetric;
    // 4 Bytes
    short lsAttrLength = cb.readShort();
    if ((lsAttrLength != ATTR_PREFIX_LEN) || (cb.readableBytes() < lsAttrLength)) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    linkPfxMetric = cb.readInt();
    return BgpPrefixAttrMetric.of(linkPfxMetric);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof FlowClassifierId) {
        final FlowClassifierId other = (FlowClassifierId) obj;
        return Objects.equal(this.flowClassifierId, other.flowClassifierId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof FlowClassifierId) {
        final FlowClassifierId other = (FlowClassifierId) obj;
        return Objects.equals(this.flowClassifierId, other.flowClassifierId);
    }
    return false;
}
#end_block

#method_before
private Optional<MplsLabel> findMplsLabel(Link link) {
    Iterable<ResourceRequest> freeLabels = resourceService.getAvailableResources(link);
    return ImmutableSet.copyOf(freeLabels).stream().filter(x -> x instanceof MplsLabelResourceRequest).map(x -> (MplsLabelResourceRequest) x).map(MplsLabelResourceRequest::mplsLabel).findFirst();
}
#method_after
private Optional<MplsLabel> findMplsLabel(Link link) {
    Iterable<ResourceRequest> freeLabels = resourceService.getAvailableResources(link);
    return StreamSupport.stream(freeLabels.spliterator(), false).filter(x -> x instanceof MplsLabelResourceRequest).map(x -> (MplsLabelResourceRequest) x).map(MplsLabelResourceRequest::mplsLabel).findFirst();
}
#end_block

#method_before
public Set<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        return new HashSet<>(srinfo.subnets.values());
    }
    return null;
}
#method_after
public Set<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        return ImmutableSet.copyOf(srinfo.subnets.values());
    }
    return null;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("mplsLabel", mplsLabel).toString();
}
#end_block

#method_before
@Test
public void testImplicitConstraintsAreAdded() {
    final BandwidthConstraint other = bandwidthConstraint(1, DataRateUnit.GBPS);
    final HostToHostIntent intent = HostToHostIntent.builder().appId(APPID).one(id1).two(id2).selector(selector).treatment(treatment).constraints(ImmutableList.of(other)).build();
    assertThat(intent.constraints(), hasItem(HostToHostIntent.NOT_OPTICAL));
}
#method_after
@Test
public void testImplicitConstraintsAreAdded() {
    final Constraint other = BandwidthConstraint.of(1, DataRateUnit.GBPS);
    final HostToHostIntent intent = HostToHostIntent.builder().appId(APPID).one(id1).two(id2).selector(selector).treatment(treatment).constraints(ImmutableList.of(other)).build();
    assertThat(intent.constraints(), hasItem(HostToHostIntent.NOT_OPTICAL));
}
#end_block

#method_before
private void addGroup(NextObjective nextObjective) {
    log.debug("addGroup with type{} for nextObjective id {}", nextObjective.type(), nextObjective.id());
    List<GroupBucket> buckets;
    switch(nextObjective.type()) {
        case SIMPLE:
            log.debug("processing SIMPLE next objective");
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() == 1) {
                TrafficTreatment treatment = treatments.iterator().next();
                GroupBucket bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket)), key, null, nextObjective.appId());
                log.debug("Creating SIMPLE group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case HASHED:
            log.debug("processing HASHED next objective");
            buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createSelectGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(buckets), key, null, nextObjective.appId());
                log.debug("Creating HASHED group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case BROADCAST:
            log.debug("processing BROADCAST next objective");
            buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createAllGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(buckets), key, null, nextObjective.appId());
                log.debug("Creating BROADCAST group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case FAILOVER:
            log.debug("BROADCAST and FAILOVER next objectives not supported");
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            log.warn("Unsupported next objective type {}", nextObjective.type());
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#method_after
private void addGroup(NextObjective nextObjective) {
    log.debug("addGroup with type{} for nextObjective id {}", nextObjective.type(), nextObjective.id());
    List<GroupBucket> buckets;
    switch(nextObjective.type()) {
        case SIMPLE:
            log.debug("processing SIMPLE next objective");
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() == 1) {
                TrafficTreatment treatment = treatments.iterator().next();
                GroupBucket bucket = DefaultGroupBucket.createIndirectGroupBucket(treatment);
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(bucket)), key, null, nextObjective.appId());
                log.debug("Creating SIMPLE group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case HASHED:
            log.debug("processing HASHED next objective");
            buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createSelectGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(buckets), key, null, nextObjective.appId());
                log.debug("Creating HASHED group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case BROADCAST:
            log.debug("processing BROADCAST next objective");
            buckets = nextObjective.next().stream().map((treatment) -> DefaultGroupBucket.createAllGroupBucket(treatment)).collect(Collectors.toList());
            if (!buckets.isEmpty()) {
                final GroupKey key = new DefaultGroupKey(appKryo.serialize(nextObjective.id()));
                GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(buckets), key, null, nextObjective.appId());
                log.debug("Creating BROADCAST group for next objective id {}", nextObjective.id());
                groupService.addGroup(groupDescription);
                pendingGroups.put(key, nextObjective);
            }
            break;
        case FAILOVER:
            log.debug("FAILOVER next objectives not supported");
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            log.warn("Unsupported next objective type {}", nextObjective.type());
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#end_block

#method_before
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            log.debug("Adding OUTGROUP action");
        }
    } else {
        log.warn("VERSATILE forwarding objective need next objective ID.");
        return Collections.emptySet();
    }
    TrafficTreatment treatment = treatmentBuilder.build();
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    TrafficTreatment treatment = null;
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            treatment = treatmentBuilder.build();
            log.debug("Adding OUTGROUP action");
        }
    } else if (fwd.treatment() != null) {
        if (fwd.treatment().allInstructions().size() == 1 && fwd.treatment().allInstructions().get(0).type() == Instruction.Type.OUTPUT) {
            OutputInstruction o = (OutputInstruction) fwd.treatment().allInstructions().get(0);
            if (o.port() == PortNumber.CONTROLLER) {
                log.warn("Punts to the controller are handled by misses in" + " the TMAC, IP and MPLS tables.");
                return Collections.emptySet();
            }
        }
        treatment = fwd.treatment();
    } else {
        log.warn("VERSATILE forwarding objective needs next objective ID " + "or treatment.");
        return Collections.emptySet();
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            log.debug("adding rule for IP: {}", ip.ip());
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ip.ip());
            treatment.transition(aclTableId);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(ipv4UnicastTableId).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules for segment router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules for segment router", deviceId);
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            log.debug("driver does not process IP filtering rules as it " + "sends all misses in the IP table to the controller");
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules for segment router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules for segment router", deviceId);
        }
    }));
}
#end_block

#method_before
public GroupKey key() {
    return key;
}
#method_after
@SuppressWarnings("unused")
public GroupKey key() {
    return key;
}
#end_block

#method_before
@Override
public int getSegmentId(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getSegmentId for device{} is {}", deviceId, deviceConfigMap.get(deviceId).nodeSid);
        return deviceConfigMap.get(deviceId).nodeSid;
    } else {
        log.warn("getSegmentId for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
@Override
public int getSegmentId(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSegmentId for device{} is {}", deviceId, srinfo.nodeSid);
        return srinfo.nodeSid;
    } else {
        log.warn("getSegmentId for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public MacAddress getDeviceMac(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getDeviceMac for device{} is {}", deviceId, deviceConfigMap.get(deviceId).mac);
        return deviceConfigMap.get(deviceId).mac;
    } else {
        log.warn("getDeviceMac for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
@Override
public MacAddress getDeviceMac(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceMac for device{} is {}", deviceId, srinfo.mac);
        return srinfo.mac;
    } else {
        log.warn("getDeviceMac for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
public Ip4Address getRouterIp(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, deviceConfigMap.get(deviceId).ip);
        return deviceConfigMap.get(deviceId).ip;
    } else {
        log.warn("getRouterIp for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
public Ip4Address getRouterIp(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ip);
        return srinfo.ip;
    } else {
        log.warn("getRouterIp for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public boolean isEdgeDevice(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("isEdgeDevice for device{} is {}", deviceId, deviceConfigMap.get(deviceId).isEdge);
        return deviceConfigMap.get(deviceId).isEdge;
    } else {
        log.warn("isEdgeDevice for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
@Override
public boolean isEdgeDevice(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("isEdgeDevice for device{} is {}", deviceId, srinfo.isEdge);
        return srinfo.isEdge;
    } else {
        log.warn("isEdgeDevice for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
public List<Ip4Prefix> getSubnets(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getSubnets for device{} is {}", deviceId, deviceConfigMap.get(deviceId).subnets.values());
        return new ArrayList<>(deviceConfigMap.get(deviceId).subnets.values());
    } else {
        return null;
    }
}
#method_after
public List<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        return new ArrayList<>(srinfo.subnets.values());
    }
    return null;
}
#end_block

#method_before
public List<Integer> getPortsForAdjacencySid(DeviceId deviceId, int sid) {
    if (deviceConfigMap.get(deviceId) != null) {
        for (AdjacencySid asid : deviceConfigMap.get(deviceId).adjacencySids) {
            if (asid.getAsid() == sid) {
                return asid.getPorts();
            }
        }
    }
    return Lists.newArrayList();
}
#method_after
public List<Integer> getPortsForAdjacencySid(DeviceId deviceId, int sid) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        for (AdjacencySid asid : srinfo.adjacencySids) {
            if (asid.getAsid() == sid) {
                return asid.getPorts();
            }
        }
    }
    return Lists.newArrayList();
}
#end_block

#method_before
public boolean isAdjacencySid(DeviceId deviceId, int sid) {
    if (deviceConfigMap.get(deviceId) != null) {
        if (deviceConfigMap.get(deviceId).adjacencySids.isEmpty()) {
            return false;
        } else {
            for (AdjacencySid asid : deviceConfigMap.get(deviceId).adjacencySids) {
                if (asid.getAsid() == sid) {
                    return true;
                }
            }
            return false;
        }
    }
    return false;
}
#method_after
public boolean isAdjacencySid(DeviceId deviceId, int sid) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        if (srinfo.adjacencySids.isEmpty()) {
            return false;
        } else {
            for (AdjacencySid asid : srinfo.adjacencySids) {
                if (asid.getAsid() == sid) {
                    return true;
                }
            }
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class, ConnectPoint.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map portnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(cfgFactory);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, SubnetNextObjectiveStoreKey.class, SubnetAssignedVidStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class, VlanId.class, Ip4Address.class, Ip4Prefix.class, IpAddress.Version.class, ConnectPoint.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(cfgFactory);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler dgh = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
    groupHandlerMap.put(device.id(), dgh);
    dgh.createGroupsFromSubnetConfig();
    defaultRoutingHandler.populateTtpRules(device.id());
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
    groupHandlerMap.put(device.id(), groupHandler);
    defaultRoutingHandler.populatePortAddressingRules(device.id());
    if (mastershipService.isLocalMaster(device.id())) {
        groupHandler.createGroupsFromSubnetConfig();
    }
}
#end_block

#method_before
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
}
#method_after
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populatePortAddressingRules(device.id());
        if (mastershipService.isLocalMaster(device.id())) {
            groupHandler.createGroupsFromSubnetConfig();
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private LambdaResource findFirstLambda(Set<LambdaResource> lambdas) {
    return lambdas.stream().sorted((e1, e2) -> Integer.compare(e1.toInt(), e2.toInt())).findFirst().get();
}
#method_after
private LambdaResource findFirstLambda(Set<LambdaResource> lambdas) {
    return lambdas.stream().findFirst().get();
}
#end_block

#method_before
default List<ResourceAllocation> allocate(ResourceConsumer consumer, ResourcePath... resources) {
    checkNotNull(consumer);
    checkNotNull(resources);
    return allocate(consumer, Arrays.asList(resources));
}
#method_after
default Optional<ResourceAllocation> allocate(ResourceConsumer consumer, ResourcePath resource) {
    checkNotNull(consumer);
    checkNotNull(resource);
    List<ResourceAllocation> allocations = allocate(consumer, ImmutableList.of(resource));
    if (allocations.isEmpty()) {
        return Optional.empty();
    }
    assert allocations.size() == 1;
    ResourceAllocation allocation = allocations.get(0);
    assert allocation.resource().equals(resource);
    // cast is ensured by the assertions above
    return Optional.of(allocation);
}
#end_block

#method_before
default boolean release(ResourceAllocation... allocations) {
    checkNotNull(allocations);
    return release(ImmutableList.copyOf(allocations));
}
#method_after
default boolean release(ResourceAllocation allocation) {
    checkNotNull(allocation);
    return release(ImmutableList.of(allocation));
}
#end_block

#method_before
@Override
public int getSegmentId(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getSegmentId for device{} is {}", deviceId, deviceConfigMap.get(deviceId).nodeSid);
        return deviceConfigMap.get(deviceId).nodeSid;
    } else {
        log.warn("getSegmentId for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
@Override
public int getSegmentId(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSegmentId for device{} is {}", deviceId, srinfo.nodeSid);
        return srinfo.nodeSid;
    } else {
        log.warn("getSegmentId for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public MacAddress getDeviceMac(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getDeviceMac for device{} is {}", deviceId, deviceConfigMap.get(deviceId).mac);
        return deviceConfigMap.get(deviceId).mac;
    } else {
        log.warn("getDeviceMac for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
@Override
public MacAddress getDeviceMac(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceMac for device{} is {}", deviceId, srinfo.mac);
        return srinfo.mac;
    } else {
        log.warn("getDeviceMac for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
public Ip4Address getRouterIp(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, deviceConfigMap.get(deviceId).ip);
        return deviceConfigMap.get(deviceId).ip;
    } else {
        log.warn("getRouterIp for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
public Ip4Address getRouterIp(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ip);
        return srinfo.ip;
    } else {
        log.warn("getRouterIp for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public boolean isEdgeDevice(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("isEdgeDevice for device{} is {}", deviceId, deviceConfigMap.get(deviceId).isEdge);
        return deviceConfigMap.get(deviceId).isEdge;
    } else {
        log.warn("isEdgeDevice for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#method_after
@Override
public boolean isEdgeDevice(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("isEdgeDevice for device{} is {}", deviceId, srinfo.isEdge);
        return srinfo.isEdge;
    } else {
        log.warn("isEdgeDevice for device {} " + "throwing IllegalStateException " + "because device does not exist in config", deviceId);
        throw new IllegalStateException();
    }
}
#end_block

#method_before
public List<Ip4Address> getPortIPs(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getSubnetGatewayIps for device{} is {}", deviceId, deviceConfigMap.get(deviceId).gatewayIps.values());
        return new ArrayList<>(deviceConfigMap.get(deviceId).gatewayIps.values());
    } else {
        return null;
    }
}
#method_after
public List<Ip4Address> getPortIPs(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnetGatewayIps for device{} is {}", deviceId, srinfo.gatewayIps.values());
        return new ArrayList<>(srinfo.gatewayIps.values());
    }
    return null;
}
#end_block

#method_before
public Map<PortNumber, Ip4Address> getPortIPMap(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        return deviceConfigMap.get(deviceId).gatewayIps;
    }
    return null;
}
#method_after
public Map<PortNumber, Ip4Address> getPortIPMap(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        return srinfo.gatewayIps;
    }
    return null;
}
#end_block

#method_before
public List<Ip4Prefix> getSubnets(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getSubnets for device{} is {}", deviceId, deviceConfigMap.get(deviceId).subnets.values());
        return new ArrayList<>(deviceConfigMap.get(deviceId).subnets.values());
    } else {
        return null;
    }
}
#method_after
public List<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        return new ArrayList<>(srinfo.subnets.values());
    }
    return null;
}
#end_block

#method_before
public Ip4Prefix getPortSubnet(DeviceId deviceId, PortNumber pnum) {
    if (deviceConfigMap.get(deviceId) != null) {
        Map<PortNumber, Ip4Prefix> portSubnets = deviceConfigMap.get(deviceId).subnets;
        return portSubnets.get(pnum);
    }
    return null;
}
#method_after
public Ip4Prefix getPortSubnet(DeviceId deviceId, PortNumber pnum) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        return srinfo.subnets.get(pnum);
    }
    return null;
}
#end_block

#method_before
public List<Integer> getPortsForAdjacencySid(DeviceId deviceId, int sid) {
    if (deviceConfigMap.get(deviceId) != null) {
        for (AdjacencySid asid : deviceConfigMap.get(deviceId).adjacencySids) {
            if (asid.getAsid() == sid) {
                return asid.getPorts();
            }
        }
    }
    return Lists.newArrayList();
}
#method_after
public List<Integer> getPortsForAdjacencySid(DeviceId deviceId, int sid) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        for (AdjacencySid asid : srinfo.adjacencySids) {
            if (asid.getAsid() == sid) {
                return asid.getPorts();
            }
        }
    }
    return Lists.newArrayList();
}
#end_block

#method_before
public boolean isAdjacencySid(DeviceId deviceId, int sid) {
    if (deviceConfigMap.get(deviceId) != null) {
        if (deviceConfigMap.get(deviceId).adjacencySids.isEmpty()) {
            return false;
        } else {
            for (AdjacencySid asid : deviceConfigMap.get(deviceId).adjacencySids) {
                if (asid.getAsid() == sid) {
                    return true;
                }
            }
            return false;
        }
    }
    return false;
}
#method_after
public boolean isAdjacencySid(DeviceId deviceId, int sid) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        if (srinfo.adjacencySids.isEmpty()) {
            return false;
        } else {
            for (AdjacencySid asid : srinfo.adjacencySids) {
                if (asid.getAsid() == sid) {
                    return true;
                }
            }
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Criterion decodeCriterion(ObjectNode json) {
    JsonNode oduSignalId = nullIsIllegal(json.get(CriterionCodec.ODU_SIGNAL_ID), CriterionCodec.TRIBUTARY_PORT_NUMBER + MISSING_MEMBER_MESSAGE);
    int tributaryPortNumber = nullIsIllegal(oduSignalId.get(CriterionCodec.TRIBUTARY_PORT_NUMBER), CriterionCodec.TRIBUTARY_PORT_NUMBER + MISSING_MEMBER_MESSAGE).asInt();
    int tributarySlotLen = nullIsIllegal(oduSignalId.get(CriterionCodec.TRIBUTARY_SLOT_LEN), CriterionCodec.TRIBUTARY_SLOT_LEN + MISSING_MEMBER_MESSAGE).asInt();
    List<Byte> tsbm = new ArrayList<Byte>();
    final JsonNode tributarySlotArray = oduSignalId.get(CriterionCodec.TRIBUTARY_SLOT_BITMAP);
    nullIsIllegal(tributarySlotArray, CriterionCodec.TRIBUTARY_SLOT_BITMAP + MISSING_MEMBER_MESSAGE);
    Iterator it = tributarySlotArray.elements();
    while (it.hasNext()) {
        tsbm.add(Byte.valueOf(it.next().toString()));
    }
    byte[] tributarySlotBitmap = new byte[tsbm.size()];
    for (int i = 0; i < tsbm.size(); i++) {
        tributarySlotBitmap[i] = tsbm.get(i);
    }
    return Criteria.matchOduSignalId(OduSignalId.oduSignalId(tributaryPortNumber, tributarySlotLen, tributarySlotBitmap));
}
#method_after
@Override
public Criterion decodeCriterion(ObjectNode json) {
    JsonNode oduSignalId = nullIsIllegal(json.get(CriterionCodec.ODU_SIGNAL_ID), CriterionCodec.TRIBUTARY_PORT_NUMBER + MISSING_MEMBER_MESSAGE);
    int tributaryPortNumber = nullIsIllegal(oduSignalId.get(CriterionCodec.TRIBUTARY_PORT_NUMBER), CriterionCodec.TRIBUTARY_PORT_NUMBER + MISSING_MEMBER_MESSAGE).asInt();
    int tributarySlotLen = nullIsIllegal(oduSignalId.get(CriterionCodec.TRIBUTARY_SLOT_LEN), CriterionCodec.TRIBUTARY_SLOT_LEN + MISSING_MEMBER_MESSAGE).asInt();
    byte[] tributarySlotBitmap = HexString.fromHexString(nullIsIllegal(oduSignalId.get(CriterionCodec.TRIBUTARY_SLOT_BITMAP), CriterionCodec.TRIBUTARY_SLOT_BITMAP + MISSING_MEMBER_MESSAGE).asText());
    return Criteria.matchOduSignalId(OduSignalId.oduSignalId(tributaryPortNumber, tributarySlotLen, tributarySlotBitmap));
}
#end_block

#method_before
private Instruction decodeL1() {
    String subType = json.get(InstructionCodec.SUBTYPE).asText();
    if (subType.equals(L1ModificationInstruction.L1SubType.ODU_SIGID.name())) {
        int tributaryPortNumber = nullIsIllegal(json.get(InstructionCodec.TRIBUTARY_PORT_NUMBER), InstructionCodec.TRIBUTARY_PORT_NUMBER + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt();
        int tributarySlotLen = nullIsIllegal(json.get(InstructionCodec.TRIBUTARY_SLOT_LEN), InstructionCodec.TRIBUTARY_SLOT_LEN + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt();
        byte[] tributarySlotBitmap = null;
        try {
            tributarySlotBitmap = nullIsIllegal(json.get(InstructionCodec.TRIBUTARY_SLOT_BITMAP), InstructionCodec.TRIBUTARY_SLOT_BITMAP + InstructionCodec.MISSING_MEMBER_MESSAGE).binaryValue();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return Instructions.modL1OduSignalId(OduSignalId.oduSignalId(tributaryPortNumber, tributarySlotLen, tributarySlotBitmap));
    }
    throw new IllegalArgumentException("L1 Instruction subtype " + subType + " is not supported");
}
#method_after
private Instruction decodeL1() {
    String subType = json.get(InstructionCodec.SUBTYPE).asText();
    if (subType.equals(L1ModificationInstruction.L1SubType.ODU_SIGID.name())) {
        int tributaryPortNumber = nullIsIllegal(json.get(InstructionCodec.TRIBUTARY_PORT_NUMBER), InstructionCodec.TRIBUTARY_PORT_NUMBER + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt();
        int tributarySlotLen = nullIsIllegal(json.get(InstructionCodec.TRIBUTARY_SLOT_LEN), InstructionCodec.TRIBUTARY_SLOT_LEN + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt();
        byte[] tributarySlotBitmap = null;
        tributarySlotBitmap = HexString.fromHexString(nullIsIllegal(json.get(InstructionCodec.TRIBUTARY_SLOT_BITMAP), InstructionCodec.TRIBUTARY_SLOT_BITMAP + InstructionCodec.MISSING_MEMBER_MESSAGE).asText());
        return Instructions.modL1OduSignalId(OduSignalId.oduSignalId(tributaryPortNumber, tributarySlotLen, tributarySlotBitmap));
    }
    throw new IllegalArgumentException("L1 Instruction subtype " + subType + " is not supported");
}
#end_block

#method_before
public Instruction decode() {
    String type = json.get(InstructionCodec.TYPE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        PortNumber portNumber = PortNumber.portNumber(nullIsIllegal(json.get(InstructionCodec.PORT), InstructionCodec.PORT + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong());
        return Instructions.createOutput(portNumber);
    } else if (type.equals(Instruction.Type.DROP.name())) {
        return Instructions.createDrop();
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#method_after
public Instruction decode() {
    String type = json.get(InstructionCodec.TYPE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        PortNumber portNumber = PortNumber.portNumber(nullIsIllegal(json.get(InstructionCodec.PORT), InstructionCodec.PORT + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong());
        return Instructions.createOutput(portNumber);
    } else if (type.equals(Instruction.Type.DROP.name())) {
        return Instructions.createDrop();
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#end_block

#method_before
private void encodeL1(ObjectNode result) {
    L1ModificationInstruction instruction = (L1ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, instruction.subtype().name());
    switch(instruction.subtype()) {
        case ODU_SIGID:
            final L1ModificationInstruction.ModOduSignalIdInstruction oduSignalIdInstruction = (L1ModificationInstruction.ModOduSignalIdInstruction) instruction;
            OduSignalId oduSignalId = oduSignalIdInstruction.oduSignalId();
            /*          result.put(InstructionCodec.TRIBUTARY_PORT_NUMBER, oduSignalId.tributaryPortNumber());
            result.put(InstructionCodec.TRIBUTARY_SLOT_LEN, oduSignalId.tributarySlotLength());
            result.put(InstructionCodec.TRIBUTARY_SLOT_BITMAP, oduSignalId.tributarySlotBitmap());*/
            result.put("oduSignalId", oduSignalId.toString());
            break;
        default:
            log.info("Cannot convert L1 subtype of {}", instruction.subtype());
            break;
    }
}
#method_after
private void encodeL1(ObjectNode result) {
    L1ModificationInstruction instruction = (L1ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, instruction.subtype().name());
    switch(instruction.subtype()) {
        case ODU_SIGID:
            final L1ModificationInstruction.ModOduSignalIdInstruction oduSignalIdInstruction = (L1ModificationInstruction.ModOduSignalIdInstruction) instruction;
            OduSignalId oduSignalId = oduSignalIdInstruction.oduSignalId();
            ObjectNode child = result.putObject("oduSignalId");
            child.put(InstructionCodec.TRIBUTARY_PORT_NUMBER, oduSignalId.tributaryPortNumber());
            child.put(InstructionCodec.TRIBUTARY_SLOT_LEN, oduSignalId.tributarySlotLength());
            child.put(InstructionCodec.TRIBUTARY_SLOT_BITMAP, HexString.toHexString(oduSignalId.tributarySlotBitmap()));
            break;
        default:
            log.info("Cannot convert L1 subtype of {}", instruction.subtype());
            break;
    }
}
#end_block

#method_before
private boolean matchCriterion(OduSignalIdCriterion criterion) {
    final String oduSignalId = criterion.oduSignalId().toString();
    final String jsonOduSignalId = jsonCriterion.get("oduSignalId").textValue();
    if (!oduSignalId.equals(jsonOduSignalId)) {
        description.appendText("oduSignalId was " + oduSignalId);
        return false;
    }
    return true;
}
#method_after
private boolean matchCriterion(OduSignalIdCriterion criterion) {
    final OduSignalId oduSignal = criterion.oduSignalId();
    final JsonNode jsonOduSignal = jsonCriterion.get(CriterionCodec.ODU_SIGNAL_ID);
    int jsonTpn = jsonOduSignal.get(CriterionCodec.TRIBUTARY_PORT_NUMBER).intValue();
    int jsonTsLen = jsonOduSignal.get(CriterionCodec.TRIBUTARY_SLOT_LEN).intValue();
    byte[] jsonTributaryBitMap = HexString.fromHexString(jsonOduSignal.get(CriterionCodec.TRIBUTARY_SLOT_BITMAP).asText());
    OduSignalId jsonOduSignalId = OduSignalId.oduSignalId(jsonTpn, jsonTsLen, jsonTributaryBitMap);
    if (!oduSignal.equals(jsonOduSignalId)) {
        description.appendText("oduSignalId was " + criterion);
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void modOduSignalIdInstructionTest() {
    OduSignalId oduSignalId = OduSignalId.oduSignalId(1, 8, new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 });
    L1ModificationInstruction.ModOduSignalIdInstruction instruction = (L1ModificationInstruction.ModOduSignalIdInstruction) Instructions.modL1OduSignalId(oduSignalId);
    ObjectNode instructionJson = instructionCodec.encode(instruction, context);
    assertThat(instructionJson, matchesInstruction(instruction));
}
#method_after
@Test
public void modOduSignalIdInstructionTest() {
    OduSignalId oduSignalId = OduSignalId.oduSignalId(1, 8, new byte[] { 8, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
    L1ModificationInstruction.ModOduSignalIdInstruction instruction = (L1ModificationInstruction.ModOduSignalIdInstruction) Instructions.modL1OduSignalId(oduSignalId);
    ObjectNode instructionJson = instructionCodec.encode(instruction, context);
    assertThat(instructionJson, matchesInstruction(instruction));
}
#end_block

#method_before
private boolean matchModOduSingalIdInstruction(JsonNode instructionJson, Description description) {
    ModOduSignalIdInstruction instructionToMatch = (ModOduSignalIdInstruction) instruction;
    String jsonSubType = instructionJson.get("subtype").textValue();
    if (!instructionToMatch.subtype().name().equals(jsonSubType)) {
        description.appendText("subtype was " + jsonSubType);
        return false;
    }
    String jsonType = instructionJson.get("type").textValue();
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    /*        int jsonTributaryPortNumber = instructionJson.get("tributaryPortNumber").intValue();
        if (instructionToMatch.oduSignalId().tributaryPortNumber() != jsonTributaryPortNumber) {
            description.appendText("tributaryPortNumber was " + jsonTributaryPortNumber);
            return false;
        }

        int jsonTributarySlotLen = instructionJson.get("tributarySlotLength").intValue();
        if (instructionToMatch.oduSignalId().tributarySlotLength() != jsonTributarySlotLen) {
            description.appendText("tributarySlotLen was " + jsonTributarySlotLen);
            return false;
        }

        byte[] jsonTributarySlotBitmap = null;
        try {
            jsonTributarySlotBitmap = instructionJson.get("tributarySlotBitmap").binaryValue();
        } catch (IOException e) {
          throw new RuntimeException();
        }
        if (instructionToMatch.oduSignalId().tributarySlotBitmap() != jsonTributarySlotBitmap) {
            description.appendText("tributarySlotBitmap was " + jsonTributarySlotBitmap);
            return false;
        }*/
    final String oduSignalId = instructionToMatch.oduSignalId().toString();
    final String jsonOduSignalId = instructionJson.get("oduSignalId").textValue();
    if (!oduSignalId.equals(jsonOduSignalId)) {
        description.appendText("oduSignalId was " + oduSignalId);
        return false;
    }
    return true;
}
#method_after
private boolean matchModOduSingalIdInstruction(JsonNode instructionJson, Description description) {
    ModOduSignalIdInstruction instructionToMatch = (ModOduSignalIdInstruction) instruction;
    String jsonSubType = instructionJson.get("subtype").textValue();
    if (!instructionToMatch.subtype().name().equals(jsonSubType)) {
        description.appendText("subtype was " + jsonSubType);
        return false;
    }
    String jsonType = instructionJson.get("type").textValue();
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    final JsonNode jsonOduSignal = instructionJson.get("oduSignalId");
    int jsonTpn = jsonOduSignal.get("tributaryPortNumber").intValue();
    int jsonTsLen = jsonOduSignal.get("tributarySlotLength").intValue();
    byte[] tributaryBitMap = HexString.fromHexString(jsonOduSignal.get("tributarySlotBitmap").asText());
    OduSignalId jsonOduSignalId = OduSignalId.oduSignalId(jsonTpn, jsonTsLen, tributaryBitMap);
    if (!instructionToMatch.oduSignalId().equals(jsonOduSignalId)) {
        description.appendText("oduSignalId was " + instructionToMatch);
        return false;
    }
    return true;
}
#end_block

#method_before
public static TrafficSelector revertTreatmentSelector(TrafficTreatment trafficTreatment, TrafficSelector trafficSelector) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    Map<Criterion.Type, Criterion> criterionMap = new HashMap<>();
    for (Criterion criterion : trafficSelector.criteria()) {
        criterionMap.put(criterion.type(), criterion);
    }
    for (Instruction instruction : trafficTreatment.allInstructions()) {
        switch(instruction.type()) {
            case DROP:
                return null;
            case OUTPUT:
                break;
            case GROUP:
                break;
            case L0MODIFICATION:
                {
                    L0ModificationInstruction l0 = (L0ModificationInstruction) instruction;
                    switch(l0.subtype()) {
                        case LAMBDA:
                            if (criterionMap.containsKey(Criterion.Type.OCH_SIGID)) {
                                if (((LambdaCriterion) criterionMap.get((Criterion.Type.OCH_SIGID))).lambda() == ((L0ModificationInstruction.ModLambdaInstruction) l0).lambda()) {
                                    criterionMap.remove(Criterion.Type.OCH_SIGID);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case OCH:
                            if (criterionMap.containsKey(Criterion.Type.OCH_SIGID)) {
                                if (((OchSignalCriterion) criterionMap.get((Criterion.Type.OCH_SIGID))).lambda().equals(((L0ModificationInstruction.ModOchSignalInstruction) l0).lambda())) {
                                    criterionMap.remove(Criterion.Type.OCH_SIGID);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        default:
                            break;
                    }
                    break;
                }
            case L1MODIFICATION:
                {
                    L1ModificationInstruction l1 = (L1ModificationInstruction) instruction;
                    switch(l1.subtype()) {
                        case ODU_SIGID:
                            if (criterionMap.containsKey(Criterion.Type.ODU_SIGID)) {
                                if (((OduSignalIdCriterion) criterionMap.get((Criterion.Type.ODU_SIGID))).oduSignalId().equals(((L1ModificationInstruction.ModOduSignalIdInstruction) l1).oduSignalId())) {
                                    criterionMap.remove(Criterion.Type.ODU_SIGID);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        default:
                            break;
                    }
                    break;
                }
            case L2MODIFICATION:
                {
                    L2ModificationInstruction l2 = (L2ModificationInstruction) instruction;
                    switch(l2.subtype()) {
                        case ETH_SRC:
                            if (criterionMap.containsKey(Criterion.Type.ETH_SRC)) {
                                if (((EthCriterion) criterionMap.get((Criterion.Type.ETH_SRC))).mac().equals(((L2ModificationInstruction.ModEtherInstruction) l2).mac())) {
                                    criterionMap.remove(Criterion.Type.ETH_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case ETH_DST:
                            if (criterionMap.containsKey(Criterion.Type.ETH_DST)) {
                                if (((EthCriterion) criterionMap.get((Criterion.Type.ETH_DST))).mac().equals(((L2ModificationInstruction.ModEtherInstruction) l2).mac())) {
                                    criterionMap.remove(Criterion.Type.ETH_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case VLAN_ID:
                            if (criterionMap.containsKey(Criterion.Type.VLAN_VID)) {
                                if (((VlanIdCriterion) criterionMap.get((Criterion.Type.VLAN_VID))).vlanId().equals(((L2ModificationInstruction.ModVlanIdInstruction) l2).vlanId())) {
                                    criterionMap.remove(Criterion.Type.VLAN_VID);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case VLAN_PCP:
                            if (criterionMap.containsKey(Criterion.Type.VLAN_PCP)) {
                                if (((VlanPcpCriterion) criterionMap.get((Criterion.Type.VLAN_PCP))).priority() == ((L2ModificationInstruction.ModVlanPcpInstruction) l2).vlanPcp()) {
                                    criterionMap.remove(Criterion.Type.VLAN_PCP);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case MPLS_LABEL:
                            if (criterionMap.containsKey(Criterion.Type.MPLS_LABEL)) {
                                if (((MplsCriterion) criterionMap.get((Criterion.Type.MPLS_LABEL))).label().equals(((L2ModificationInstruction.ModMplsLabelInstruction) l2).mplsLabel())) {
                                    criterionMap.remove(Criterion.Type.ETH_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        default:
                            break;
                    }
                    break;
                }
            case TABLE:
                break;
            case L3MODIFICATION:
                {
                    L3ModificationInstruction l3 = (L3ModificationInstruction) instruction;
                    switch(l3.subtype()) {
                        case IPV4_SRC:
                            if (criterionMap.containsKey(Criterion.Type.IPV4_SRC)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV4_SRC)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV4_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV4_DST:
                            if (criterionMap.containsKey(Criterion.Type.IPV4_DST)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV4_DST)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV4_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV6_SRC:
                            if (criterionMap.containsKey(Criterion.Type.IPV6_SRC)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV6_SRC)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV6_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV6_DST:
                            if (criterionMap.containsKey(Criterion.Type.IPV6_DST)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV6_DST)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV6_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV6_FLABEL:
                            if (criterionMap.containsKey(Criterion.Type.IPV6_FLABEL)) {
                                if (((IPv6FlowLabelCriterion) criterionMap.get(Criterion.Type.IPV6_FLABEL)).flowLabel() == (((L3ModificationInstruction.ModIPv6FlowLabelInstruction) l3).flowLabel())) {
                                    criterionMap.remove(Criterion.Type.IPV4_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        default:
                            break;
                    }
                    break;
                }
            case METADATA:
                break;
            default:
                break;
        }
    }
    for (Criterion criterion : criterionMap.values()) {
        selectorBuilder.add(criterion);
    }
    return selectorBuilder.build();
}
#method_after
public static TrafficSelector revertTreatmentSelector(TrafficTreatment trafficTreatment, TrafficSelector trafficSelector) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    Map<Criterion.Type, Criterion> criterionMap = new HashMap<>();
    for (Criterion criterion : trafficSelector.criteria()) {
        criterionMap.put(criterion.type(), criterion);
    }
    for (Instruction instruction : trafficTreatment.allInstructions()) {
        switch(instruction.type()) {
            case DROP:
                return null;
            case OUTPUT:
                break;
            case GROUP:
                break;
            case L0MODIFICATION:
                {
                    L0ModificationInstruction l0 = (L0ModificationInstruction) instruction;
                    switch(l0.subtype()) {
                        case LAMBDA:
                            if (criterionMap.containsKey(Criterion.Type.OCH_SIGID)) {
                                if (((LambdaCriterion) criterionMap.get((Criterion.Type.OCH_SIGID))).lambda() == ((L0ModificationInstruction.ModLambdaInstruction) l0).lambda()) {
                                    criterionMap.remove(Criterion.Type.OCH_SIGID);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case OCH:
                            if (criterionMap.containsKey(Criterion.Type.OCH_SIGID)) {
                                if (((OchSignalCriterion) criterionMap.get((Criterion.Type.OCH_SIGID))).lambda().equals(((L0ModificationInstruction.ModOchSignalInstruction) l0).lambda())) {
                                    criterionMap.remove(Criterion.Type.OCH_SIGID);
                                } else {
                                    return null;
                                }
                            }
                        default:
                            break;
                    }
                    break;
                }
            case L1MODIFICATION:
                {
                    L1ModificationInstruction l1 = (L1ModificationInstruction) instruction;
                    switch(l1.subtype()) {
                        case ODU_SIGID:
                            if (criterionMap.containsKey(Criterion.Type.ODU_SIGID)) {
                                if (((OduSignalIdCriterion) criterionMap.get((Criterion.Type.ODU_SIGID))).oduSignalId().equals(((L1ModificationInstruction.ModOduSignalIdInstruction) l1).oduSignalId())) {
                                    criterionMap.remove(Criterion.Type.ODU_SIGID);
                                } else {
                                    return null;
                                }
                            }
                        default:
                            break;
                    }
                    break;
                }
            case L2MODIFICATION:
                {
                    L2ModificationInstruction l2 = (L2ModificationInstruction) instruction;
                    switch(l2.subtype()) {
                        case ETH_SRC:
                            if (criterionMap.containsKey(Criterion.Type.ETH_SRC)) {
                                if (((EthCriterion) criterionMap.get((Criterion.Type.ETH_SRC))).mac().equals(((L2ModificationInstruction.ModEtherInstruction) l2).mac())) {
                                    criterionMap.remove(Criterion.Type.ETH_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case ETH_DST:
                            if (criterionMap.containsKey(Criterion.Type.ETH_DST)) {
                                if (((EthCriterion) criterionMap.get((Criterion.Type.ETH_DST))).mac().equals(((L2ModificationInstruction.ModEtherInstruction) l2).mac())) {
                                    criterionMap.remove(Criterion.Type.ETH_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case VLAN_ID:
                            if (criterionMap.containsKey(Criterion.Type.VLAN_VID)) {
                                if (((VlanIdCriterion) criterionMap.get((Criterion.Type.VLAN_VID))).vlanId().equals(((L2ModificationInstruction.ModVlanIdInstruction) l2).vlanId())) {
                                    criterionMap.remove(Criterion.Type.VLAN_VID);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case VLAN_PCP:
                            if (criterionMap.containsKey(Criterion.Type.VLAN_PCP)) {
                                if (((VlanPcpCriterion) criterionMap.get((Criterion.Type.VLAN_PCP))).priority() == ((L2ModificationInstruction.ModVlanPcpInstruction) l2).vlanPcp()) {
                                    criterionMap.remove(Criterion.Type.VLAN_PCP);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case MPLS_LABEL:
                            if (criterionMap.containsKey(Criterion.Type.MPLS_LABEL)) {
                                if (((MplsCriterion) criterionMap.get((Criterion.Type.MPLS_LABEL))).label().equals(((L2ModificationInstruction.ModMplsLabelInstruction) l2).mplsLabel())) {
                                    criterionMap.remove(Criterion.Type.ETH_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        default:
                            break;
                    }
                    break;
                }
            case TABLE:
                break;
            case L3MODIFICATION:
                {
                    L3ModificationInstruction l3 = (L3ModificationInstruction) instruction;
                    switch(l3.subtype()) {
                        case IPV4_SRC:
                            if (criterionMap.containsKey(Criterion.Type.IPV4_SRC)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV4_SRC)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV4_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV4_DST:
                            if (criterionMap.containsKey(Criterion.Type.IPV4_DST)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV4_DST)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV4_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV6_SRC:
                            if (criterionMap.containsKey(Criterion.Type.IPV6_SRC)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV6_SRC)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV6_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV6_DST:
                            if (criterionMap.containsKey(Criterion.Type.IPV6_DST)) {
                                if (((IPCriterion) criterionMap.get(Criterion.Type.IPV6_DST)).ip().contains(((L3ModificationInstruction.ModIPInstruction) l3).ip())) {
                                    criterionMap.remove(Criterion.Type.IPV6_DST);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        case IPV6_FLABEL:
                            if (criterionMap.containsKey(Criterion.Type.IPV6_FLABEL)) {
                                if (((IPv6FlowLabelCriterion) criterionMap.get(Criterion.Type.IPV6_FLABEL)).flowLabel() == (((L3ModificationInstruction.ModIPv6FlowLabelInstruction) l3).flowLabel())) {
                                    criterionMap.remove(Criterion.Type.IPV4_SRC);
                                } else {
                                    return null;
                                }
                            } else {
                                break;
                            }
                        default:
                            break;
                    }
                    break;
                }
            case METADATA:
                break;
            default:
                break;
        }
    }
    for (Criterion criterion : criterionMap.values()) {
        selectorBuilder.add(criterion);
    }
    return selectorBuilder.build();
}
#end_block

#method_before
@Override
public Builder add(Instruction instruction) {
    switch(instruction.type()) {
        case DROP:
        case NOACTION:
        case OUTPUT:
        case GROUP:
        case L0MODIFICATION:
        case L1MODIFICATION:
        case L2MODIFICATION:
        case L3MODIFICATION:
        case L4MODIFICATION:
            current.add(instruction);
            break;
        case TABLE:
            table = (Instructions.TableTypeTransition) instruction;
            break;
        case METADATA:
            meta = (Instructions.MetadataInstruction) instruction;
            break;
        case METER:
            meter = (Instructions.MeterInstruction) instruction;
            break;
        default:
            throw new IllegalArgumentException("Unknown instruction type: " + instruction.type());
    }
    return this;
}
#method_after
@Override
public Builder add(Instruction instruction) {
    switch(instruction.type()) {
        case DROP:
        case NOACTION:
        case OUTPUT:
        case GROUP:
        case QUEUE:
        case L0MODIFICATION:
        case L1MODIFICATION:
        case L2MODIFICATION:
        case L3MODIFICATION:
        case L4MODIFICATION:
            current.add(instruction);
            break;
        case TABLE:
            table = (Instructions.TableTypeTransition) instruction;
            break;
        case METADATA:
            meta = (Instructions.MetadataInstruction) instruction;
            break;
        case METER:
            meter = (Instructions.MeterInstruction) instruction;
            break;
        default:
            throw new IllegalArgumentException("Unknown instruction type: " + instruction.type());
    }
    return this;
}
#end_block

#method_before
@Test
public void codecCriteriaFlowTest() throws Exception {
    FlowRule rule = getRule("criteria-flow.json");
    checkCommonData(rule);
    assertThat(rule.selector().criteria().size(), is(36));
    rule.selector().criteria().stream().forEach(criterion -> criteria.put(criterion.type().name(), criterion));
    Criterion criterion;
    criterion = getCriterion(Criterion.Type.ETH_TYPE);
    assertThat(((EthTypeCriterion) criterion).ethType(), is(new EthType(2054)));
    criterion = getCriterion(Criterion.Type.ETH_DST);
    assertThat(((EthCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:55")));
    criterion = getCriterion(Criterion.Type.ETH_SRC);
    assertThat(((EthCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:55")));
    criterion = getCriterion(Criterion.Type.IN_PORT);
    assertThat(((PortCriterion) criterion).port(), is(PortNumber.portNumber(23)));
    criterion = getCriterion(Criterion.Type.IN_PHY_PORT);
    assertThat(((PortCriterion) criterion).port(), is(PortNumber.portNumber(44)));
    criterion = getCriterion(Criterion.Type.VLAN_VID);
    assertThat(((VlanIdCriterion) criterion).vlanId(), is(VlanId.vlanId((short) 777)));
    criterion = getCriterion(Criterion.Type.VLAN_PCP);
    assertThat(((VlanPcpCriterion) criterion).priority(), is(((byte) 3)));
    criterion = getCriterion(Criterion.Type.IP_DSCP);
    assertThat(((IPDscpCriterion) criterion).ipDscp(), is(((byte) 2)));
    criterion = getCriterion(Criterion.Type.IP_ECN);
    assertThat(((IPEcnCriterion) criterion).ipEcn(), is(((byte) 1)));
    criterion = getCriterion(Criterion.Type.IP_PROTO);
    assertThat(((IPProtocolCriterion) criterion).protocol(), is(((short) 4)));
    criterion = getCriterion(Criterion.Type.IPV4_SRC);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("1.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.IPV4_DST);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("2.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.IPV6_SRC);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("3.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.IPV6_DST);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("4.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.TCP_SRC);
    assertThat(((TcpPortCriterion) criterion).tcpPort().toInt(), is(80));
    criterion = getCriterion(Criterion.Type.TCP_DST);
    assertThat(((TcpPortCriterion) criterion).tcpPort().toInt(), is(443));
    criterion = getCriterion(Criterion.Type.UDP_SRC);
    assertThat(((UdpPortCriterion) criterion).udpPort().toInt(), is(180));
    criterion = getCriterion(Criterion.Type.UDP_DST);
    assertThat(((UdpPortCriterion) criterion).udpPort().toInt(), is(1443));
    criterion = getCriterion(Criterion.Type.SCTP_SRC);
    assertThat(((SctpPortCriterion) criterion).sctpPort().toInt(), is(280));
    criterion = getCriterion(Criterion.Type.SCTP_DST);
    assertThat(((SctpPortCriterion) criterion).sctpPort().toInt(), is(2443));
    criterion = getCriterion(Criterion.Type.ICMPV4_TYPE);
    assertThat(((IcmpTypeCriterion) criterion).icmpType(), is((short) 24));
    criterion = getCriterion(Criterion.Type.ICMPV4_CODE);
    assertThat(((IcmpCodeCriterion) criterion).icmpCode(), is((short) 16));
    criterion = getCriterion(Criterion.Type.ICMPV6_TYPE);
    assertThat(((Icmpv6TypeCriterion) criterion).icmpv6Type(), is((short) 14));
    criterion = getCriterion(Criterion.Type.ICMPV6_CODE);
    assertThat(((Icmpv6CodeCriterion) criterion).icmpv6Code(), is((short) 6));
    criterion = getCriterion(Criterion.Type.IPV6_FLABEL);
    assertThat(((IPv6FlowLabelCriterion) criterion).flowLabel(), is(8));
    criterion = getCriterion(Criterion.Type.IPV6_ND_TARGET);
    assertThat(((IPv6NDTargetAddressCriterion) criterion).targetAddress().toString(), is("1111:2222:3333:4444:5555:6666:7777:8888"));
    criterion = getCriterion(Criterion.Type.IPV6_ND_SLL);
    assertThat(((IPv6NDLinkLayerAddressCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:56")));
    criterion = getCriterion(Criterion.Type.IPV6_ND_TLL);
    assertThat(((IPv6NDLinkLayerAddressCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:57")));
    criterion = getCriterion(Criterion.Type.MPLS_LABEL);
    assertThat(((MplsCriterion) criterion).label(), is(MplsLabel.mplsLabel(123)));
    criterion = getCriterion(Criterion.Type.IPV6_EXTHDR);
    assertThat(((IPv6ExthdrFlagsCriterion) criterion).exthdrFlags(), is(99));
    criterion = getCriterion(Criterion.Type.OCH_SIGID);
    assertThat(((IndexedLambdaCriterion) criterion).lambda(), is(Lambda.indexedLambda(122)));
    criterion = getCriterion(Criterion.Type.TUNNEL_ID);
    assertThat(((TunnelIdCriterion) criterion).tunnelId(), is(100L));
    criterion = getCriterion(Criterion.Type.OCH_SIGTYPE);
    assertThat(((OchSignalTypeCriterion) criterion).signalType(), is(OchSignalType.FIXED_GRID));
    criterion = getCriterion(Criterion.Type.ODU_SIGTYPE);
    assertThat(((OduSignalTypeCriterion) criterion).signalType(), is(OduSignalType.ODU4));
    criterion = getCriterion(Criterion.Type.ODU_SIGID);
    assertThat(((OduSignalIdCriterion) criterion).oduSignalId().tributaryPortNumber(), is(1));
    criterion = getCriterion(Criterion.Type.ODU_SIGID);
    assertThat(((OduSignalIdCriterion) criterion).oduSignalId().tributarySlotLength(), is(80));
    criterion = getCriterion(Criterion.Type.ODU_SIGID);
    assertThat(((OduSignalIdCriterion) criterion).oduSignalId().tributarySlotBitmap(), is(new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }));
}
#method_after
@Test
public void codecCriteriaFlowTest() throws Exception {
    FlowRule rule = getRule("criteria-flow.json");
    checkCommonData(rule);
    assertThat(rule.selector().criteria().size(), is(36));
    rule.selector().criteria().stream().forEach(criterion -> criteria.put(criterion.type().name(), criterion));
    Criterion criterion;
    criterion = getCriterion(Criterion.Type.ETH_TYPE);
    assertThat(((EthTypeCriterion) criterion).ethType(), is(new EthType(2054)));
    criterion = getCriterion(Criterion.Type.ETH_DST);
    assertThat(((EthCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:55")));
    criterion = getCriterion(Criterion.Type.ETH_SRC);
    assertThat(((EthCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:55")));
    criterion = getCriterion(Criterion.Type.IN_PORT);
    assertThat(((PortCriterion) criterion).port(), is(PortNumber.portNumber(23)));
    criterion = getCriterion(Criterion.Type.IN_PHY_PORT);
    assertThat(((PortCriterion) criterion).port(), is(PortNumber.portNumber(44)));
    criterion = getCriterion(Criterion.Type.VLAN_VID);
    assertThat(((VlanIdCriterion) criterion).vlanId(), is(VlanId.vlanId((short) 777)));
    criterion = getCriterion(Criterion.Type.VLAN_PCP);
    assertThat(((VlanPcpCriterion) criterion).priority(), is(((byte) 3)));
    criterion = getCriterion(Criterion.Type.IP_DSCP);
    assertThat(((IPDscpCriterion) criterion).ipDscp(), is(((byte) 2)));
    criterion = getCriterion(Criterion.Type.IP_ECN);
    assertThat(((IPEcnCriterion) criterion).ipEcn(), is(((byte) 1)));
    criterion = getCriterion(Criterion.Type.IP_PROTO);
    assertThat(((IPProtocolCriterion) criterion).protocol(), is(((short) 4)));
    criterion = getCriterion(Criterion.Type.IPV4_SRC);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("1.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.IPV4_DST);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("2.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.IPV6_SRC);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("3.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.IPV6_DST);
    assertThat(((IPCriterion) criterion).ip(), is((IpPrefix.valueOf("4.2.0.0/32"))));
    criterion = getCriterion(Criterion.Type.TCP_SRC);
    assertThat(((TcpPortCriterion) criterion).tcpPort().toInt(), is(80));
    criterion = getCriterion(Criterion.Type.TCP_DST);
    assertThat(((TcpPortCriterion) criterion).tcpPort().toInt(), is(443));
    criterion = getCriterion(Criterion.Type.UDP_SRC);
    assertThat(((UdpPortCriterion) criterion).udpPort().toInt(), is(180));
    criterion = getCriterion(Criterion.Type.UDP_DST);
    assertThat(((UdpPortCriterion) criterion).udpPort().toInt(), is(1443));
    criterion = getCriterion(Criterion.Type.SCTP_SRC);
    assertThat(((SctpPortCriterion) criterion).sctpPort().toInt(), is(280));
    criterion = getCriterion(Criterion.Type.SCTP_DST);
    assertThat(((SctpPortCriterion) criterion).sctpPort().toInt(), is(2443));
    criterion = getCriterion(Criterion.Type.ICMPV4_TYPE);
    assertThat(((IcmpTypeCriterion) criterion).icmpType(), is((short) 24));
    criterion = getCriterion(Criterion.Type.ICMPV4_CODE);
    assertThat(((IcmpCodeCriterion) criterion).icmpCode(), is((short) 16));
    criterion = getCriterion(Criterion.Type.ICMPV6_TYPE);
    assertThat(((Icmpv6TypeCriterion) criterion).icmpv6Type(), is((short) 14));
    criterion = getCriterion(Criterion.Type.ICMPV6_CODE);
    assertThat(((Icmpv6CodeCriterion) criterion).icmpv6Code(), is((short) 6));
    criterion = getCriterion(Criterion.Type.IPV6_FLABEL);
    assertThat(((IPv6FlowLabelCriterion) criterion).flowLabel(), is(8));
    criterion = getCriterion(Criterion.Type.IPV6_ND_TARGET);
    assertThat(((IPv6NDTargetAddressCriterion) criterion).targetAddress().toString(), is("1111:2222:3333:4444:5555:6666:7777:8888"));
    criterion = getCriterion(Criterion.Type.IPV6_ND_SLL);
    assertThat(((IPv6NDLinkLayerAddressCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:56")));
    criterion = getCriterion(Criterion.Type.IPV6_ND_TLL);
    assertThat(((IPv6NDLinkLayerAddressCriterion) criterion).mac(), is(MacAddress.valueOf("00:11:22:33:44:57")));
    criterion = getCriterion(Criterion.Type.MPLS_LABEL);
    assertThat(((MplsCriterion) criterion).label(), is(MplsLabel.mplsLabel(123)));
    criterion = getCriterion(Criterion.Type.IPV6_EXTHDR);
    assertThat(((IPv6ExthdrFlagsCriterion) criterion).exthdrFlags(), is(99));
    criterion = getCriterion(Criterion.Type.OCH_SIGID);
    assertThat(((IndexedLambdaCriterion) criterion).lambda(), is(Lambda.indexedLambda(122)));
    criterion = getCriterion(Criterion.Type.TUNNEL_ID);
    assertThat(((TunnelIdCriterion) criterion).tunnelId(), is(100L));
    criterion = getCriterion(Criterion.Type.OCH_SIGTYPE);
    assertThat(((OchSignalTypeCriterion) criterion).signalType(), is(OchSignalType.FIXED_GRID));
    criterion = getCriterion(Criterion.Type.ODU_SIGTYPE);
    assertThat(((OduSignalTypeCriterion) criterion).signalType(), is(OduSignalType.ODU4));
    criterion = getCriterion(Criterion.Type.ODU_SIGID);
    assertThat(((OduSignalIdCriterion) criterion).oduSignalId().tributaryPortNumber(), is(1));
    assertThat(((OduSignalIdCriterion) criterion).oduSignalId().tributarySlotLength(), is(80));
    assertThat(((OduSignalIdCriterion) criterion).oduSignalId().tributarySlotBitmap(), is(new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }));
}
#end_block

#method_before
@GET
@Path("{flow_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getFlowClassifier(@PathParam("flow_id") String id) {
    if (!service.hasFlowClassifier(FlowClassifierId.flowClassifierId(id))) {
        return Response.status(NOT_FOUND).entity(FLOW_CLASSIFIER_NOT_FOUND).build();
    }
    FlowClassifier flowClassifier = nullIsNotFound(service.getFlowClassifier(FlowClassifierId.flowClassifierId(id)), FLOW_CLASSIFIER_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("flow_classifier", new FlowClassifierCodec().encode(flowClassifier, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{flow_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getFlowClassifier(@PathParam("flow_id") String id) {
    if (!service.hasFlowClassifier(FlowClassifierId.flowClassifierId(UUID.fromString(id)))) {
        return Response.status(NOT_FOUND).entity(FLOW_CLASSIFIER_NOT_FOUND).build();
    }
    FlowClassifier flowClassifier = nullIsNotFound(service.getFlowClassifier(FlowClassifierId.flowClassifierId(UUID.fromString(id))), FLOW_CLASSIFIER_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("flow_classifier", new FlowClassifierCodec().encode(flowClassifier, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@Path("{flow_id}")
@DELETE
public Response deleteFlowClassifier(@PathParam("flow_id") String id) throws IOException {
    try {
        FlowClassifierId flowClassifierId = FlowClassifierId.flowClassifierId(id);
        service.removeFlowClassifier(flowClassifierId);
        return Response.status(201).entity("SUCCESS").build();
    } catch (Exception e) {
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@Path("{flow_id}")
@DELETE
public Response deleteFlowClassifier(@PathParam("flow_id") String id) throws IOException {
    try {
        FlowClassifierId flowClassifierId = FlowClassifierId.flowClassifierId(UUID.fromString(id));
        service.removeFlowClassifier(flowClassifierId);
        return Response.status(201).entity("SUCCESS").build();
    } catch (Exception e) {
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
public void populateIpRuleForHost(DeviceId deviceId, Ip4Address hostIp, MacAddress hostMac, PortNumber outPort) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    sbuilder.matchIPDst(IpPrefix.valueOf(hostIp, 32));
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(config.getDeviceMac(deviceId)).setOutput(outPort);
    TrafficTreatment treatment = tbuilder.build();
    TrafficSelector selector = sbuilder.build();
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().withSelector(selector).withTreatment(treatment).withPriority(100).withFlag(ForwardingObjective.Flag.SPECIFIC);
    log.debug("Installing IPv4 forwarding objective " + "for host {} in switch {}", hostIp, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
}
#method_after
public void populateIpRuleForHost(DeviceId deviceId, Ip4Address hostIp, MacAddress hostMac, PortNumber outPort) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    sbuilder.matchIPDst(IpPrefix.valueOf(hostIp, IpPrefix.MAX_INET_MASK_LENGTH));
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(config.getDeviceMac(deviceId)).setOutput(outPort);
    TrafficTreatment treatment = tbuilder.build();
    TrafficSelector selector = sbuilder.build();
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().withSelector(selector).withTreatment(treatment).withPriority(100).withFlag(ForwardingObjective.Flag.SPECIFIC);
    log.debug("Installing IPv4 forwarding objective " + "for host {} in switch {}", hostIp, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
}
#end_block

#method_before
public void populateRouterMacVlanFilters(DeviceId deviceId) {
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    fob.withKey(Criteria.matchInPort(PortNumber.ALL)).addCondition(Criteria.matchEthDst(config.getDeviceMac(deviceId))).addCondition(Criteria.matchVlanId(VlanId.NONE)).addCondition(Criteria.matchIPDst(IpPrefix.valueOf(config.getRouterIp(deviceId), 32)));
    fob.permit().fromApp(srManager.appId);
    log.debug("Installing filtering objective for untagged packets");
    srManager.flowObjectiveService.filter(deviceId, fob.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FILTER)));
}
#method_after
public void populateRouterMacVlanFilters(DeviceId deviceId) {
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    fob.withKey(Criteria.matchInPort(PortNumber.ALL)).addCondition(Criteria.matchEthDst(config.getDeviceMac(deviceId))).addCondition(Criteria.matchVlanId(VlanId.NONE)).addCondition(Criteria.matchIPDst(IpPrefix.valueOf(config.getRouterIp(deviceId), IpPrefix.MAX_INET_MASK_LENGTH)));
    fob.permit().fromApp(srManager.appId);
    log.debug("Installing filtering objective for untagged packets");
    srManager.flowObjectiveService.filter(deviceId, fob.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FILTER)));
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler dgh = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
    groupHandlerMap.put(device.id(), dgh);
    defaultRoutingHandler.populateFilteringRules(device.id());
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler dgh = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
    groupHandlerMap.put(device.id(), dgh);
    defaultRoutingHandler.populatePortAddressingRules(device.id());
}
#end_block

#method_before
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populateFilteringRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populatePortAddressingRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
@Override
protected void initializePipeline() {
    processPortTable();
    // processVlanTable();
    processTmacTable();
    processIpTable();
    // processMcastTable();
    processBridgingTable();
    processAclTable();
// processGroupTable();
}
#method_after
@Override
protected void initializePipeline() {
    processPortTable();
    processTmacTable();
    processIpTable();
    processBridgingTable();
    processAclTable();
// XXX implement table miss entries and default groups
// processVlanTable();
// processMPLSTable();
// processGroupTable();
}
#end_block

#method_before
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            log.debug("Adding OUTGROUP action");
        }
    } else {
        log.warn("VERSATILE forwarding objective need next objective ID.");
        return Collections.emptySet();
    }
    TrafficTreatment treatment = treatmentBuilder.build();
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    TrafficTreatment treatment = null;
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            treatment = treatmentBuilder.build();
            log.debug("Adding OUTGROUP action");
        }
    } else if (fwd.treatment() != null) {
        if (fwd.treatment().allInstructions().size() == 1 && fwd.treatment().allInstructions().get(0).type() == Instruction.Type.OUTPUT) {
            OutputInstruction o = (OutputInstruction) fwd.treatment().allInstructions().get(0);
            if (o.port() == PortNumber.CONTROLLER) {
                log.warn("Punts to the controller are handled by misses in" + " the TMAC, IP and MPLS tables.");
                return Collections.emptySet();
            }
        }
        treatment = fwd.treatment();
    } else {
        log.warn("VERSATILE forwarding objective needs next objective ID " + "or treatment.");
        return Collections.emptySet();
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            log.debug("driver does not process IP filtering rules as it " + "sends all misses in the IP table to the controller");
        /*
                IPCriterion ip = (IPCriterion) c;
                log.debug("adding rule for IP: {}", ip.ip());
                TrafficSelector.Builder selector = DefaultTrafficSelector
                        .builder();
                TrafficTreatment.Builder treatment = DefaultTrafficTreatment
                        .builder();
                selector.matchEthType(Ethernet.TYPE_IPV4);
                selector.matchIPDst(ip.ip());
                treatment.transition(aclTableId);
                FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId)
                        .withSelector(selector.build())
                        .withTreatment(treatment.build())
                        .withPriority(filt.priority()).fromApp(applicationId)
                        .makePermanent().forTable(ipv4UnicastTableId).build();
                ops = install ? ops.add(rule) : ops.remove(rule);*/
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules for segment router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules for segment router", deviceId);
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            for (FlowRule rule : processEthDstFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            for (FlowRule rule : processVlanIdFilter(c, filt, applicationId)) {
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            log.debug("driver does not process IP filtering rules as it " + "sends all misses in the IP table to the controller");
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules for segment router", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules for segment router", deviceId);
        }
    }));
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion p = null;
    EthCriterion e = null;
    VlanIdCriterion v = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        p = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            e = (EthCriterion) c;
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            v = (VlanIdCriterion) c;
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) c);
        } else {
            log.error("Unsupported filter {}", c);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    if (e == null) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(p, e, v, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (e == null || v == null) {
        log.debug("filtering objective missing dstMac or vlan, cannot program" + "Vlan Table");
    } else {
        for (FlowRule vlanRule : processVlanIdFilter(p, v, applicationId)) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", vlanRule, deviceId);
            ops = install ? ops.add(vlanRule) : ops.remove(vlanRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    if (ethCriterion == null) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (ethCriterion == null || vidCriterion == null) {
        log.debug("filtering objective missing dstMac or vlan, cannot program" + "Vlan Table");
    } else {
        for (FlowRule vlanRule : processVlanIdFilter(portCriterion, vidCriterion, applicationId)) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", vlanRule, deviceId);
            ops = install ? ops.add(vlanRule) : ops.remove(vlanRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilter(PortCriterion p, VlanIdCriterion v, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<FlowRule>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchVlanId(v.vlanId());
    if (v.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        treatment.pushVlan().setVlanId(VlanId.vlanId(UNTAGGED_ASSIGNED_VLAN));
    // XXX ofdpa may require an additional vlan match on the assigned vlan
    // and it may not require the push.
    }
    treatment.transition(TMAC_TABLE);
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<PortNumber>();
    if (p.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(p.port());
    }
    for (PortNumber pnum : portnums) {
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<FlowRule>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchVlanId(vidCriterion.vlanId());
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        treatment.pushVlan().setVlanId(VlanId.vlanId(UNTAGGED_ASSIGNED_VLAN));
    // XXX ofdpa may require an additional vlan match on the assigned vlan
    // and it may not require the push.
    }
    treatment.transition(TMAC_TABLE);
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<PortNumber>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
protected List<FlowRule> processEthDstFilter(PortCriterion p, EthCriterion e, VlanIdCriterion v, ApplicationId applicationId) {
    // handling untagged packets via assigned VLAN
    if (v.vlanId() == VlanId.NONE) {
        v = (VlanIdCriterion) Criteria.matchVlanId(VlanId.vlanId(UNTAGGED_ASSIGNED_VLAN));
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<PortNumber>();
    if (p.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(p.port());
    }
    List<FlowRule> rules = new ArrayList<FlowRule>();
    for (PortNumber pnum : portnums) {
        // for unicast IP packets
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(v.vlanId());
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(e.mac());
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        // for MPLS packets
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(v.vlanId());
        selector.matchEthType(Ethernet.MPLS_UNICAST);
        selector.matchEthDst(e.mac());
        treatment.transition(MPLS_TABLE_0);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, ApplicationId applicationId) {
    // handling untagged packets via assigned VLAN
    if (vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(VlanId.vlanId(UNTAGGED_ASSIGNED_VLAN));
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<PortNumber>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    List<FlowRule> rules = new ArrayList<FlowRule>();
    for (PortNumber pnum : portnums) {
        // for unicast IP packets
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        // for MPLS packets
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.MPLS_UNICAST);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(MPLS_TABLE_0);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    if (ethType.ethType().toShort() == Ethernet.TYPE_ARP) {
        log.warn("Installing ARP rule to table 60");
        // currently need to punt from ACL table should use:
        // OF apply-actions-instruction
        // To use OF write-actions-instruction
        /*TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
            fwd.treatment().allInstructions().stream()
                .forEach(ti -> tb.deferred().add(ti));*/
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).makePermanent().forTable(ACL_TABLE);
        return Collections.singletonList(ruleBuilder.build());
    }
    // XXX not handling other versatile flows yet
    return Collections.emptySet();
}
#method_after
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        return Collections.emptySet();
    }
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    if (fwd.treatment() != null && fwd.treatment().allInstructions().size() == 1 && fwd.treatment().allInstructions().get(0).type() == Instruction.Type.OUTPUT) {
        OutputInstruction o = (OutputInstruction) fwd.treatment().allInstructions().get(0);
        if (o.port() == PortNumber.CONTROLLER) {
            FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).makePermanent().forTable(ACL_TABLE);
            return Collections.singletonList(ruleBuilder.build());
        } else {
            log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
            return Collections.emptySet();
        }
    }
    if (fwd.nextId() != null) {
        // XXX overide case
        log.warn("versatile objective --> next Id not yet implemeted");
    }
    return Collections.emptySet();
}
#end_block

#method_before
public Map<PortNumber, Ip4Address> getPortIPs(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        return deviceConfigMap.get(deviceId).gatewayIps;
    }
    return null;
}
#method_after
public List<Ip4Address> getPortIPs(DeviceId deviceId) {
    if (deviceConfigMap.get(deviceId) != null) {
        log.trace("getSubnetGatewayIps for device{} is {}", deviceId, deviceConfigMap.get(deviceId).gatewayIps.values());
        return new ArrayList<>(deviceConfigMap.get(deviceId).gatewayIps.values());
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public FlowClassifier decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    FlowClassifier.Builder resultBuilder = new DefaultFlowClassifier.Builder();
    String flowClassifierId = nullIsIllegal(json.get(FLOW_CLASSIFIER_ID), FLOW_CLASSIFIER_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setFlowClassifierId(FlowClassifierId.valueOf(flowClassifierId));
    String tenantId = nullIsIllegal(json.get(TENANT_ID), TENANT_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setTenantId(TenantId.tenantId(tenantId));
    String flowClassiferName = nullIsIllegal(json.get(NAME), NAME + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setFlowClassifierName(flowClassiferName);
    String flowClassiferDescription = nullIsIllegal(json.get(DESCRIPTION), DESCRIPTION + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setFlowClassifierDescription(flowClassiferDescription);
    String etherType = nullIsIllegal(json.get(ETHER_TYPE), ETHER_TYPE + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setEtherType(EtherType.valueOf(etherType));
    String protocol = nullIsIllegal(json.get(PROTOCOL), PROTOCOL + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setIpProtocol(protocol);
    int minSrcPortRange = nullIsIllegal(json.get(MIN_SRC_PORT_RANGE), MIN_SRC_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMinSrcPortRange(minSrcPortRange);
    int maxSrcPortRange = nullIsIllegal(json.get(MAX_SRC_PORT_RANGE), MAX_SRC_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMaxSrcPortRange(maxSrcPortRange);
    int minDstPortRange = nullIsIllegal(json.get(MIN_DST_PORT_RANGE), MIN_DST_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMinDstPortRange(minDstPortRange);
    int maxDstPortRange = nullIsIllegal(json.get(MAX_DST_PORT_RANGE), MAX_DST_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMaxDstPortRange(maxDstPortRange);
    String srcIpPrefix = nullIsIllegal(json.get(SRC_IP_PREFIX), SRC_IP_PREFIX + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setSrcIpPrefix(IpPrefix.valueOf(srcIpPrefix));
    String dstIpPrefix = nullIsIllegal(json.get(DST_IP_PREFIX), DST_IP_PREFIX + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setDstIpPrefix(IpPrefix.valueOf(dstIpPrefix));
    String srcPort = nullIsIllegal(json.get(SRC_PORT), SRC_PORT + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setSrcNeutronPort(NeutronPort.valueOf(srcPort));
    String dstPort = nullIsIllegal(json.get(DST_PORT), DST_PORT + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setDstNeutronPort(NeutronPort.valueOf(dstPort));
    return resultBuilder.build();
}
#method_after
@Override
public FlowClassifier decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    FlowClassifier.Builder resultBuilder = new DefaultFlowClassifier.Builder();
    String flowClassifierId = nullIsIllegal(json.get(FLOW_CLASSIFIER_ID), FLOW_CLASSIFIER_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setFlowClassifierId(FlowClassifierId.flowClassifierId(UUID.fromString(flowClassifierId)));
    String tenantId = nullIsIllegal(json.get(TENANT_ID), TENANT_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setTenantId(TenantId.tenantId(tenantId));
    String flowClassiferName = nullIsIllegal(json.get(NAME), NAME + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setName(flowClassiferName);
    String flowClassiferDescription = nullIsIllegal(json.get(DESCRIPTION), DESCRIPTION + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setDescription(flowClassiferDescription);
    String etherType = nullIsIllegal(json.get(ETHER_TYPE), ETHER_TYPE + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setEtherType(etherType);
    String protocol = nullIsIllegal(json.get(PROTOCOL), PROTOCOL + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setProtocol(protocol);
    int minSrcPortRange = nullIsIllegal(json.get(MIN_SRC_PORT_RANGE), MIN_SRC_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMinSrcPortRange(minSrcPortRange);
    int maxSrcPortRange = nullIsIllegal(json.get(MAX_SRC_PORT_RANGE), MAX_SRC_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMaxSrcPortRange(maxSrcPortRange);
    int minDstPortRange = nullIsIllegal(json.get(MIN_DST_PORT_RANGE), MIN_DST_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMinDstPortRange(minDstPortRange);
    int maxDstPortRange = nullIsIllegal(json.get(MAX_DST_PORT_RANGE), MAX_DST_PORT_RANGE + MISSING_MEMBER_MESSAGE).asInt();
    resultBuilder.setMaxDstPortRange(maxDstPortRange);
    String srcIpPrefix = nullIsIllegal(json.get(SRC_IP_PREFIX), SRC_IP_PREFIX + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setSrcIpPrefix(IpPrefix.valueOf(srcIpPrefix));
    String dstIpPrefix = nullIsIllegal(json.get(DST_IP_PREFIX), DST_IP_PREFIX + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setDstIpPrefix(IpPrefix.valueOf(dstIpPrefix));
    String srcPort = nullIsIllegal(json.get(SRC_PORT), SRC_PORT + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setSrcPort(VirtualPortId.portId(srcPort));
    String dstPort = nullIsIllegal(json.get(DST_PORT), DST_PORT + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setDstPort(VirtualPortId.portId(dstPort));
    return resultBuilder.build();
}
#end_block

#method_before
@Override
public ObjectNode encode(FlowClassifier flowClassifier, CodecContext context) {
    checkNotNull(flowClassifier, "flowClassifier cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put(FLOW_CLASSIFIER_ID, flowClassifier.flowClassifierId().toString()).put(TENANT_ID, flowClassifier.tenantId().toString()).put(NAME, flowClassifier.flowclassifierName()).put(DESCRIPTION, flowClassifier.flowClassifierDescription()).put(ETHER_TYPE, flowClassifier.etherType().toString()).put(PROTOCOL, flowClassifier.ipProtocol()).put(MIN_SRC_PORT_RANGE, flowClassifier.minSrcPortRange()).put(MAX_SRC_PORT_RANGE, flowClassifier.maxSrcPortRange()).put(MIN_DST_PORT_RANGE, flowClassifier.minDstPortRange()).put(MAX_DST_PORT_RANGE, flowClassifier.maxDstPortRange()).put(SRC_IP_PREFIX, flowClassifier.srcIpPrefix().toString()).put(DST_IP_PREFIX, flowClassifier.dstIpPrefix().toString()).put(SRC_PORT, flowClassifier.srcNeutronPort().toString()).put(DST_PORT, flowClassifier.dstNeutronPort().toString());
    return result;
}
#method_after
@Override
public ObjectNode encode(FlowClassifier flowClassifier, CodecContext context) {
    checkNotNull(flowClassifier, "flowClassifier cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("FLOW_CLASSIFIER_ID", flowClassifier.flowClassifierId().toString()).put("TENANT_ID", flowClassifier.tenantId().toString()).put("NAME", flowClassifier.name()).put("DESCRIPTION", flowClassifier.description()).put("ETHER_TYPE", flowClassifier.etherType()).put("PROTOCOL", flowClassifier.protocol()).put("MIN_SRC_PORT_RANGE", flowClassifier.minSrcPortRange()).put("MAX_SRC_PORT_RANGE", flowClassifier.maxSrcPortRange()).put("MIN_DST_PORT_RANGE", flowClassifier.minDstPortRange()).put("MAX_DST_PORT_RANGE", flowClassifier.maxDstPortRange()).put("SRC_IP_PREFIX", flowClassifier.srcIpPrefix().toString()).put("DST_IP_PREFIX", flowClassifier.dstIpPrefix().toString()).put("SRC_PORT", flowClassifier.srcPort().toString()).put("DST_PORT", flowClassifier.dstPort().toString());
    return result;
}
#end_block

#method_before
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    set = storageService.<String>setBuilder().withName(setName).withSerializer(serializer).build();
    // Add a single element to the set
    print(Arrays.asList(values).toString());
    if (values.length == 1) {
        if (set.add(values[0])) {
            print("[%s] was added to the set %s", values[0], setName);
        } else {
            print("[%s] was already in set %s", values[0], setName);
        }
    } else if (values.length >= 1) {
        // Add multiple elements to a set
        if (set.addAll(Arrays.asList(values))) {
            print("%s was added to the set %s", Arrays.asList(values), setName);
        } else {
            print("%s was already in set %s", Arrays.asList(values), setName);
        }
    }
}
#method_after
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    set = storageService.<String>setBuilder().withName(setName).withSerializer(serializer).build();
    // Add a single element to the set
    if (values.length == 1) {
        if (set.add(values[0])) {
            print("[%s] was added to the set %s", values[0], setName);
        } else {
            print("[%s] was already in set %s", values[0], setName);
        }
    } else if (values.length >= 1) {
        // Add multiple elements to a set
        if (set.addAll(Arrays.asList(values))) {
            print("%s was added to the set %s", Arrays.asList(values), setName);
        } else {
            print("%s was already in set %s", Arrays.asList(values), setName);
        }
    }
}
#end_block

#method_before
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    set = storageService.<String>setBuilder().withName(setName).withSerializer(serializer).build();
    Preconditions.checkArgument(!set.isEmpty(), "Error: Empty Set {}", set);
    // Print the set size
    if (size) {
        print("There are %d items in set %s:", set.size(), setName);
    } else {
        print("Items in set %s:", setName);
    }
    // Print the set
    for (String e : set.toArray(new String[set.size()])) {
        if (output.isEmpty()) {
            output += e;
        } else {
            output += ", " + e;
        }
    }
    print("[%s]", output);
    // Check if given values are in the set
    if (values == null) {
        return;
    } else if (values.length == 1) {
        // contains
        Preconditions.checkArgument(set.contains(values[0]), "Error: Set %s did not contain the value %s", setName, values[0]);
        print("Set %s contains the value %s", setName, values[0]);
    } else if (values.length > 1) {
        // containsAll
        Preconditions.checkArgument(set.containsAll(Arrays.asList(values)), "Error: Set %s did not contain the the subset %s", setName, Arrays.asList(values));
        print("Set %s contains the the subset %s", setName, Arrays.asList(values));
    }
}
#method_after
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    set = storageService.<String>setBuilder().withName(setName).withSerializer(serializer).build();
    // Print the set size
    if (size) {
        print("There are %d items in set %s:", set.size(), setName);
    } else {
        print("Items in set %s:", setName);
    }
    // Print the set
    if (set.isEmpty()) {
        print("[]");
    } else {
        for (String e : set.toArray(new String[set.size()])) {
            if (output.isEmpty()) {
                output += e;
            } else {
                output += ", " + e;
            }
        }
        print("[%s]", output);
    }
    // Check if given values are in the set
    if (values == null) {
        return;
    } else if (values.length == 1) {
        // contains
        if (set.contains(values[0])) {
            print("Set %s contains the value %s", setName, values[0]);
        } else {
            print("Set %s did not contain the value %s", setName, values[0]);
        }
    } else if (values.length > 1) {
        // containsAll
        if (set.containsAll(Arrays.asList(values))) {
            print("Set %s contains the the subset %s", setName, Arrays.asList(values));
        } else {
            print("Set %s did not contain the the subset %s", setName, Arrays.asList(values));
        }
    }
}
#end_block

#method_before
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    set = storageService.<String>setBuilder().withName(setName).withSerializer(serializer).build();
    if (clear) {
        set.clear();
        print("Set %s cleared", setName);
        return;
    } else {
        Preconditions.checkArgument(!set.isEmpty(), "Error: Empty Set {}", set);
    }
    if (values == null) {
        print("Error executing command: No value given");
        return;
    }
    if (retain) {
        // Keep only the given values
        Preconditions.checkArgument(set.retainAll(Arrays.asList(values)), "Error: Set %s did not contain the the subset %s", setName, Arrays.asList(values));
        set.retainAll(Arrays.asList(values));
        print("%s was pruned to contain only elements of set %s", setName, Arrays.asList(values));
    } else if (values.length == 1) {
        // Remove a single element from the set
        Preconditions.checkArgument(set.contains(values[0]), "Error: Set %s did not contain the value %s", setName, values[0]);
        set.remove(values[0]);
        print("[%s] was removed from the set %s", values[0], setName);
    } else if (values.length > 1) {
        // Remove multiple elements from a set
        Preconditions.checkArgument(set.containsAll(Arrays.asList(values)), "Error: No element of %s was in set %s", Arrays.asList(values), setName);
        set.removeAll(Arrays.asList(values));
        print("%s was removed from the set %s", Arrays.asList(values), setName);
    }
}
#method_after
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    set = storageService.<String>setBuilder().withName(setName).withSerializer(serializer).build();
    if (clear) {
        set.clear();
        print("Set %s cleared", setName);
        return;
    }
    if (values == null) {
        print("Error executing command: No value given");
        return;
    }
    if (retain) {
        // Keep only the given values
        if (set.retainAll(Arrays.asList(values))) {
            print("%s was pruned to contain only elements of set %s", setName, Arrays.asList(values));
        } else {
            print("%s was not changed by retaining only elements of the set %s", setName, Arrays.asList(values));
        }
    } else if (values.length == 1) {
        // Remove a single element from the set
        if (set.remove(values[0])) {
            print("[%s] was removed from the set %s", values[0], setName);
        } else {
            print("[%s] was not in set %s", values[0], setName);
        }
    } else if (values.length > 1) {
        // Remove multiple elements from a set
        if (set.removeAll(Arrays.asList(values))) {
            print("%s was removed from the set %s", Arrays.asList(values), setName);
        } else {
            print("No element of %s was in set %s", Arrays.asList(values), setName);
        }
    }
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null || !Partition.class.isInstance(other)) {
        return false;
    }
    Partition that = (Partition) other;
    if (!this.name.equals(that.name) || (this.members == null && that.members != null) || (this.members != null && that.members == null) || this.members.size() != that.members.size()) {
        return false;
    }
    NodeId[] sNodes = this.members.toArray(new NodeId[0]);
    NodeId[] tNodes = that.members.toArray(new NodeId[0]);
    Arrays.sort(sNodes, new Comparator<NodeId>() {

        @Override
        public int compare(NodeId o1, NodeId o2) {
            return o1.compareTo(o2);
        }
    });
    Arrays.sort(tNodes, new Comparator<NodeId>() {

        @Override
        public int compare(NodeId o1, NodeId o2) {
            return o1.compareTo(o2);
        }
    });
    for (int i = 0; i < sNodes.length; i++) {
        if (sNodes[i] != tNodes[i]) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null || !Partition.class.isInstance(other)) {
        return false;
    }
    Partition that = (Partition) other;
    if (!this.name.equals(that.name) || (this.members == null && that.members != null) || (this.members != null && that.members == null) || this.members.size() != that.members.size()) {
        return false;
    }
    return Sets.symmetricDifference(this.members, that.members).isEmpty();
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (!ClusterMetadata.class.isInstance(object)) {
        return false;
    }
    ClusterMetadata that = (ClusterMetadata) object;
    if (!this.name.equals(that.name)) {
        return false;
    }
    if (this.nodes.size() != that.nodes.size()) {
        return false;
    }
    if (this.partitions.size() != that.partitions.size()) {
        return false;
    }
    ControllerNode[] sNodes = new ControllerNode[this.nodes.size()];
    int idx = 0;
    for (ControllerNode node : this.nodes) {
        sNodes[idx] = node;
        idx += 1;
    }
    Arrays.sort(sNodes, new Comparator<ControllerNode>() {

        @Override
        public int compare(ControllerNode l, ControllerNode r) {
            return l.id().toString().compareTo(r.id().toString());
        }
    });
    ControllerNode[] tNodes = new ControllerNode[that.nodes.size()];
    idx = 0;
    for (ControllerNode node : that.nodes) {
        tNodes[idx] = node;
        idx += 1;
    }
    Arrays.sort(tNodes, new Comparator<ControllerNode>() {

        @Override
        public int compare(ControllerNode l, ControllerNode r) {
            return l.id().toString().compareTo(r.id().toString());
        }
    });
    for (int i = 0; i < sNodes.length; i++) {
        if (!sNodes[i].equals(tNodes[i])) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object object) {
    if (!ClusterMetadata.class.isInstance(object)) {
        return false;
    }
    ClusterMetadata that = (ClusterMetadata) object;
    if (!this.name.equals(that.name) || this.nodes.size() != that.nodes.size() || this.partitions.size() != that.partitions.size()) {
        return false;
    }
    return Sets.symmetricDifference(this.nodes, that.nodes).isEmpty() && Sets.symmetricDifference(this.partitions, that.partitions).isEmpty();
}
#end_block

#method_before
@Override
public void sendMsg(OFMessage msg) {
    if (role == RoleState.MASTER && channel.isConnected()) {
        channel.write(Collections.singletonList(msg)).addListener(future -> {
            if (!future.isSuccess()) {
                log.warn("Failed to write to switch {} (done:{}). cause: {} msg: {}", dpid, future.isDone(), msg, future.getCause());
            }
        });
    } else if (messagesPendingMastership != null) {
        messagesPendingMastership.add(msg);
        log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messagesPendingMastership.size());
    } else {
        log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msg);
    }
}
#method_after
@Override
public void sendMsg(OFMessage msg) {
    this.sendMsg(Collections.singletonList(msg));
}
#end_block

#method_before
@Override
public final void sendMsg(List<OFMessage> msgs) {
    if (role == RoleState.MASTER && channel.isConnected()) {
        channel.write(msgs).addListener(future -> {
            if (!future.isSuccess()) {
                log.warn("Failed to write to switch {} (done:{}). cause: {} msg: {}", dpid, future.isDone(), msgs, future.getCause());
            }
        });
    } else if (messagesPendingMastership != null) {
        messagesPendingMastership.addAll(msgs);
        log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messagesPendingMastership.size());
    } else {
        log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
    }
}
#method_after
@Override
public final void sendMsg(List<OFMessage> msgs) {
    if (role == RoleState.MASTER && channel.isConnected()) {
        channel.write(msgs);
    } else if (messagesPendingMastership != null) {
        messagesPendingMastership.addAll(msgs);
        log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messagesPendingMastership.size());
    } else {
        log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
    }
}
#end_block

#method_before
public static Criterion matchArpTpa(IpPrefix ip) {
    return new ArpTpaCriterion(ip, Type.ARP_TPA);
}
#method_after
public static Criterion matchArpTpa(Ip4Address ip) {
    return new ArpPaCriterion(ip, Type.ARP_TPA);
}
#end_block

#method_before
private OvsdbRowStore getRowStore(String dbName, String tableName) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return null;
    }
    return tableStore.getRows(tableName);
}
#method_after
private OvsdbRowStore getRowStore(String dbName, String tableName) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return null;
    }
    OvsdbRowStore rowStore = tableStore.getRows(tableName);
    if (rowStore == null) {
        rowStore = new OvsdbRowStore();
    }
    return rowStore;
}
#end_block

#method_before
@Override
public void setControllersWithUUID(UUID bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<UUID> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    removeControllers.forEach(c -> deleteConfig(OvsdbConstant.CONTROLLER, "_uuid", c.getRow().uuid().value(), OvsdbConstant.BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(UUID.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid.value(), bridge.getRow());
}
#method_after
@Override
public void setControllersWithUUID(UUID bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<UUID> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(OvsdbConstant.CONTROLLER, "_uuid", c.getRow().uuid().value(), OvsdbConstant.BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(UUID.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid.value(), bridge.getRow());
}
#end_block

#method_before
private List<Controller> getControllers(UUID bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        return null;
    }
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return null;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    // FIXME remove log
    log.warn("type of controller column", bridge.getControllerColumn().data().getClass());
    Set<UUID> controllerUuids = (Set<UUID>) ((OvsdbSet) bridge.getControllerColumn().data()).set();
    // Set<String> controllerUuidStrings = (Set<String>) bridge.getControllerColumn().data();
    List<Controller> ovsdbControllers = new ArrayList<>();
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.warn("There is no controller");
    } else {
        ConcurrentMap<String, Row> controllerTableRows = controllerRowStore.getRowStore();
        controllerTableRows.forEach((key, row) -> {
            if (!controllerUuids.contains(UUID.uuid(key))) {
                return;
            }
            Controller controller = (Controller) TableGenerator.getTable(dbSchema, row, OvsdbTable.CONTROLLER);
            ovsdbControllers.add(controller);
        });
    }
    return ovsdbControllers;
}
#method_after
private List<Controller> getControllers(UUID bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        return null;
    }
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return null;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    // FIXME remove log
    log.warn("type of controller column", bridge.getControllerColumn().data().getClass());
    Set<UUID> controllerUuids = (Set<UUID>) ((OvsdbSet) bridge.getControllerColumn().data()).set();
    // Set<String> controllerUuidStrings = (Set<String>) bridge.getControllerColumn().data();
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return null;
    }
    List<Controller> ovsdbControllers = new ArrayList<>();
    ConcurrentMap<String, Row> controllerTableRows = controllerRowStore.getRowStore();
    controllerTableRows.forEach((key, row) -> {
        if (!controllerUuids.contains(UUID.uuid(key))) {
            return;
        }
        Controller controller = (Controller) TableGenerator.getTable(dbSchema, row, OvsdbTable.CONTROLLER);
        ovsdbControllers.add(controller);
    });
    return ovsdbControllers;
}
#end_block

#method_before
@Override
protected void execute() {
    boolean deleted = false;
    McastRouteTable mrib = McastRouteTable.getInstance();
    if (egressList == null) {
        mrib.removeRoute(sAddr, gAddr);
        deleted = true;
    } else {
        // check list for validity before we begin to delete.
        for (String egress : egressList) {
            deleted = mrib.removeEgress(sAddr, gAddr, egress);
        }
    }
    if (deleted) {
        print("Removed the mcast route");
    } else {
        print("Unable to remove the mcast route");
    }
}
#method_after
@Override
protected void execute() {
    boolean deleted = false;
    McastRouteTable mrib = McastRouteTable.getInstance();
    if (egressList == null) {
        mrib.removeRoute(sAddr, gAddr);
        deleted = true;
    } else {
        // check list for validity before we begin to delete.
        for (String egress : egressList) {
            deleted = mrib.removeEgress(sAddr, gAddr, egress);
        }
    }
    if (deleted) {
        print("Successful delete");
    } else {
        print("Failed to delete");
    }
}
#end_block

#method_before
public boolean removeEgress(String saddr, String gaddr, String egress) {
    IpPrefix gpfx = IpPrefix.valueOf(gaddr);
    IpPrefix spfx = IpPrefix.valueOf(0, 0);
    if (saddr != null && !saddr.equals("*")) {
        spfx = IpPrefix.valueOf(saddr);
    }
    McastRouteSource src = (McastRouteSource) findBestMatch(spfx, gpfx);
    boolean removed = src.removeEgressPoint(egress);
    if (removed) {
        src.withdrawIntent();
        src.setIntent();
    }
    return removed;
}
#method_after
public boolean removeEgress(String saddr, String gaddr, String egress) {
    IpPrefix gpfx = IpPrefix.valueOf(gaddr);
    IpPrefix spfx = IpPrefix.valueOf(0, 0);
    if (saddr != null && !saddr.equals("*")) {
        spfx = IpPrefix.valueOf(saddr);
    }
    McastRouteSource src = (McastRouteSource) findBestMatch(spfx, gpfx);
    boolean removed = src.removeEgressPoint(egress);
    if (removed) {
        src.setIntent();
    }
    return removed;
}
#end_block

#method_before
public Set<OvsdbNodeConfig> ovsdbNodes() {
    Set<OvsdbNodeConfig> ovsdbNodes = Sets.newHashSet();
    JsonNode nodes = object.get(OVSDB_NODES);
    if (nodes == null) {
        return null;
    }
    nodes.forEach(jsonNode -> ovsdbNodes.add(new OvsdbNodeConfig(jsonNode.path(HOST).asText(), IpAddress.valueOf(jsonNode.path(IP).asText()), TpPort.tpPort(jsonNode.path(PORT).asInt()), jsonNode.path(BRIDGE_ID).asText())));
    return ovsdbNodes;
}
#method_after
public Set<OvsdbNodeConfig> ovsdbNodes() {
    Set<OvsdbNodeConfig> ovsdbNodes = Sets.newHashSet();
    JsonNode nodes = object.get(OVSDB_NODES);
    if (nodes == null) {
        return null;
    }
    nodes.forEach(jsonNode -> ovsdbNodes.add(new OvsdbNodeConfig(jsonNode.path(HOST).asText(), IpAddress.valueOf(jsonNode.path(IP).asText()), TpPort.tpPort(jsonNode.path(PORT).asInt()), DeviceId.deviceId(jsonNode.path(BRIDGE_ID).asText()))));
    return ovsdbNodes;
}
#end_block

#method_before
public String bridgeId() {
    return this.bridgeId;
}
#method_after
public DeviceId bridgeId() {
    return this.bridgeId;
}
#end_block

#method_before
@Override
public String intBrId() {
    return this.brId;
}
#method_after
@Override
public DeviceId intBrId() {
    return this.brId;
}
#end_block

#method_before
@Override
public void connected(Device device) {
    log.info("Ovsdb {} is connected", device.id());
    if (!mastershipService.isLocalMaster(device.id())) {
        return;
    }
    // TODO change to use bridge config
    OvsdbNode ovsdb = getNode(device.id());
    OvsdbClientService ovsdbClient = getOvsdbClient(ovsdb);
    List<ControllerInfo> controllers = new ArrayList<>();
    Sets.newHashSet(clusterService.getNodes()).forEach(controller -> controllers.add(new ControllerInfo(controller.ip(), OFPORT, "tcp")));
    String dpid = ovsdb.intBrId().substring(DPID_BEGIN);
    ovsdbClient.createBridge(DEFAULT_BRIDGE_NAME, dpid, controllers);
}
#method_after
@Override
public void connected(Device device) {
    log.info("Ovsdb {} is connected", device.id());
    if (!mastershipService.isLocalMaster(device.id())) {
        return;
    }
    // TODO change to use bridge config
    OvsdbNode ovsdb = getNode(device.id());
    OvsdbClientService ovsdbClient = getOvsdbClient(ovsdb);
    List<ControllerInfo> controllers = new ArrayList<>();
    Sets.newHashSet(clusterService.getNodes()).forEach(controller -> controllers.add(new ControllerInfo(controller.ip(), OFPORT, "tcp")));
    String dpid = ovsdb.intBrId().toString().substring(DPID_BEGIN);
    ovsdbClient.createBridge(DEFAULT_BRIDGE_NAME, dpid, controllers);
}
#end_block

#method_before
@Override
public void connected(Device device) {
    log.info("Integration Bridge {} is detected", device.id());
    OvsdbNode ovsdb = getNodes().stream().filter(node -> node.intBrId().equals(device.id().toString())).findFirst().get();
    if (ovsdb == null) {
        log.warn("Couldn't find OVSDB associated with {}", device.id());
        return;
    }
    if (!mastershipService.isLocalMaster(ovsdb.deviceId())) {
        return;
    }
    // TODO change to use tunnel config and tunnel description
    OvsdbClientService ovsdbClient = getOvsdbClient(ovsdb);
    ovsdbClient.createTunnel(DEFAULT_BRIDGE_NAME, "vxlan", "vxlan", VXLAN_OPTIONS);
}
#method_after
@Override
public void connected(Device device) {
    log.info("Integration Bridge {} is detected", device.id());
    OvsdbNode ovsdb = getNodes().stream().filter(node -> node.intBrId().equals(device.id())).findFirst().get();
    if (ovsdb == null) {
        log.warn("Couldn't find OVSDB associated with {}", device.id());
        return;
    }
    if (!mastershipService.isLocalMaster(ovsdb.deviceId())) {
        return;
    }
    // TODO change to use tunnel config and tunnel description
    OvsdbClientService ovsdbClient = getOvsdbClient(ovsdb);
    ovsdbClient.createTunnel(DEFAULT_BRIDGE_NAME, "vxlan", "vxlan", VXLAN_OPTIONS);
}
#end_block

#method_before
@Override
public void run() {
    log.debug("Sending periodic KeepAlive");
    try {
        handler.sendKeepAliveMessage();
        handler.getBgpPacketStats().addOutPacket();
    } catch (Exception e) {
        log.info("Exception occured while sending keepAlive message");
    }
}
#method_after
@Override
public void run() {
    log.debug("Sending periodic KeepAlive");
    try {
        // Send keep alive message
        handler.sendKeepAliveMessage();
        handler.getBgpPacketStats().addOutPacket();
    } catch (Exception e) {
        log.info("Exception occured while sending keepAlive message" + e.toString());
    }
}
#end_block

#method_before
public ConcurrentHashMap getConnectedPeers() {
    return connectedPeers;
}
#method_after
public ConcurrentHashMap<BGPId, BGPPeer> getConnectedPeers() {
    return connectedPeers;
}
#end_block

#method_before
@Override
public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
    BGPPeerCfg.State peerCfgState;
    channel = e.getChannel();
    log.info("BGP disconnected callback for bgp:{}. Cleaning up ...", getPeerInfoString());
    address = channel.getRemoteAddress();
    if (!(address instanceof InetSocketAddress)) {
        throw new IOException("Invalid peer connection.");
    }
    inetAddress = (InetSocketAddress) address;
    ipAddress = IpAddress.valueOf(inetAddress.getAddress());
    peerAddr = ipAddress.toString();
    if (thisbgpId != null) {
        if (!duplicateBGPIdFound) {
            // if the disconnected peer (on this ChannelHandler)
            // was not one with a duplicate, it is safe to remove all
            // state for it at the controller. Notice that if the disconnected
            // peer was a duplicate-ip, calling the method below would clear
            // all state for the original peer (with the same ip),
            // which we obviously don't want.
            log.debug("{}:removal called", getPeerInfoString());
            if (bgpPeer != null) {
                peerManager.removeConnectedPeer(thisbgpId);
            }
        } else {
            // A duplicate was disconnected on this ChannelHandler,
            // this is the same peer reconnecting, but the original state was
            // not cleaned up - XXX check liveness of original ChannelHandler
            log.debug("{}:duplicate found", getPeerInfoString());
            duplicateBGPIdFound = Boolean.FALSE;
        }
        if (null != keepAliveTimer) {
            keepAliveTimer.getKeepAliveTimer().cancel();
        }
    } else {
        log.warn("No bgp ip in channelHandler registered for " + "disconnected peer {}", getPeerInfoString());
    }
}
#method_after
@Override
public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
    channel = e.getChannel();
    log.info("BGP disconnected callback for bgp:{}. Cleaning up ...", getPeerInfoString());
    address = channel.getRemoteAddress();
    if (!(address instanceof InetSocketAddress)) {
        throw new IOException("Invalid peer connection.");
    }
    inetAddress = (InetSocketAddress) address;
    ipAddress = IpAddress.valueOf(inetAddress.getAddress());
    peerAddr = ipAddress.toString();
    if (thisbgpId != null) {
        if (!duplicateBGPIdFound) {
            // if the disconnected peer (on this ChannelHandler)
            // was not one with a duplicate, it is safe to remove all
            // state for it at the controller. Notice that if the disconnected
            // peer was a duplicate-ip, calling the method below would clear
            // all state for the original peer (with the same ip),
            // which we obviously don't want.
            log.debug("{}:removal called", getPeerInfoString());
            if (bgpPeer != null) {
                peerManager.removeConnectedPeer(thisbgpId);
            }
        } else {
            // A duplicate was disconnected on this ChannelHandler,
            // this is the same peer reconnecting, but the original state was
            // not cleaned up - XXX check liveness of original ChannelHandler
            log.debug("{}:duplicate found", getPeerInfoString());
            duplicateBGPIdFound = Boolean.FALSE;
        }
        if (null != keepAliveTimer) {
            keepAliveTimer.getKeepAliveTimer().cancel();
        }
    } else {
        log.warn("No bgp ip in channelHandler registered for " + "disconnected peer {}", getPeerInfoString());
    }
}
#end_block

#method_before
// *************************
// Channel utility methods
public void setHandshakeComplete(boolean handshakeComplete) {
    this.state.setHandshakeComplete(handshakeComplete);
}
#method_after
// *************************
// Channel utility methods
// *************************
public void setHandshakeComplete(boolean handshakeComplete) {
    this.state.setHandshakeComplete(handshakeComplete);
}
#end_block

#method_before
public boolean openMsgValidation(BGPChannelHandler h, BGPOpenMsg pOpenmsg) throws BGPParseException {
    // TODO: Open message validation.
    return true;
}
#method_after
public boolean openMsgValidation(BGPChannelHandler h) throws BGPParseException {
    // TODO: Open message validation.
    return true;
}
#end_block

#method_before
@Override
public void run() {
    try {
        while (true) {
            Event event = null;
            synchronized (threadSchedulerLock) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED) {
                processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                processLinkRemoved((Link) event.subject());
            // } else if (event.type() == GroupEvent.Type.GROUP_ADDED) {
            // processGroupAdded((Group) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                if (deviceService.isAvailable(((Device) event.subject()).id())) {
                    processDeviceAdded((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
                processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#method_after
@Override
public void run() {
    try {
        while (true) {
            Event event = null;
            synchronized (threadSchedulerLock) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED) {
                processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                if (deviceService.isAvailable(((Device) event.subject()).id())) {
                    processDeviceAdded((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_REMOVED) {
                processPortRemoved((Device) event.subject(), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#end_block

#method_before
@Override
public ObjectNode encodeCriterion(ObjectNode root, Criterion criterion) {
    final OduSignalTypeCriterion oduSignalTypeCriterion = (OduSignalTypeCriterion) criterion;
    return root.put(CriterionCodec.SIGNAL_TYPE, oduSignalTypeCriterion.signalType().name());
}
#method_after
@Override
public ObjectNode encodeCriterion(ObjectNode root, Criterion criterion) {
    final OduSignalTypeCriterion oduSignalTypeCriterion = (OduSignalTypeCriterion) criterion;
    return root.put(CriterionCodec.ODU_SIGNAL_TYPE, oduSignalTypeCriterion.signalType().name());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).omitNullValues().add("tributaryPortNumber", tributaryPortNumber).add("tributarySlotLen", tributarySlotLength).add("tributarySlotBitmap", bytesToHex(tributarySlotBitmap)).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).omitNullValues().add("tributaryPortNumber", tributaryPortNumber).add("tributarySlotLength", tributarySlotLength).add("tributarySlotBitmap", HexString.toHexString(tributarySlotBitmap)).toString();
}
#end_block

#method_before
@Activate
public void activate() {
    mastershipService.addListener(mastershipListener);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    mastershipService.addListener(mastershipListener);
    localId = clusterService.getLocalNode().id();
    leadershipService.addListener(leadershipListener);
    leadershipService.runForLeadership(REBALANCE_MASTERSHIP);
    processLeadershipChange(leadershipService.getLeader(REBALANCE_MASTERSHIP));
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    mastershipService.removeListener(mastershipListener);
    executorService.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    mastershipService.removeListener(mastershipListener);
    leadershipService.withdraw(REBALANCE_MASTERSHIP);
    leadershipService.removeListener(leadershipListener);
    cancelBalance();
    executorService.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(MastershipEvent event) {
    // Sets flag at execution to indicate there is currently a scheduled rebalancing, reverts upon completion
    if (!scheduled) {
        executorService.schedule(mastershipAdminService::balanceRoles, 30, TimeUnit.SECONDS).addListener(() -> {
            scheduled = false;
            log.info("Completed balance roles");
        }, MoreExecutors.directExecutor());
        scheduled = true;
    }
}
#method_after
@Override
public void event(MastershipEvent event) {
    // Sets flag at execution to indicate there is currently a scheduled rebalancing, reverts upon completion
    scheduleBalance();
}
#end_block

#method_before
@Override
public void createTunnel(String bridgeName, String portName, String tunnelType, Map<String, String> options) {
}
#method_after
@Override
public boolean createTunnel(String bridgeName, String portName, String tunnelType, Map<String, String> options) {
    return true;
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
}
#method_after
@Override
public boolean createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    return true;
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.warn("Couldn't find database Open_vSwitch");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid != null) {
        log.warn("Bridge {} is already exist", bridgeName);
        // remove existing one and re-create?
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    bridge.setName(bridgeName);
    Set<String> failMode = new HashSet<>(Arrays.asList("secure"));
    bridge.setFailMode(failMode);
    Set<String> protocols = new HashSet<>(Arrays.asList(OvsdbConstant.OPENFLOW13));
    bridge.setProtocols(protocols);
    Map<String, String> options = new HashMap<>();
    options.put("datapath-id", dpid);
    bridge.setOtherConfig(options);
    bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
    if (bridgeUuid != null) {
        createPort(bridgeName, bridgeName);
    } else {
        log.warn("Failed to create bridge {} on {}", bridgeName, nodeId.toString());
        return;
    }
    setControllersWithUUID(UUID.uuid(bridgeUuid), controllers);
}
#method_after
@Override
public boolean createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.warn("Couldn't find database Open_vSwitch");
        return false;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid != null) {
        log.warn("Bridge {} is already exist", bridgeName);
        // remove existing one and re-create?
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    bridge.setName(bridgeName);
    Set<String> failMode = new HashSet<>(Arrays.asList("secure"));
    bridge.setFailMode(failMode);
    Set<String> protocols = new HashSet<>(Arrays.asList(OvsdbConstant.OPENFLOW13));
    bridge.setProtocols(protocols);
    Map<String, String> options = new HashMap<>();
    options.put("datapath-id", dpid);
    bridge.setOtherConfig(options);
    bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
    if (bridgeUuid != null) {
        createPort(bridgeName, bridgeName);
    } else {
        log.warn("Failed to create bridge {} on {}", bridgeName, nodeId.toString());
        return false;
    }
    setControllersWithUUID(UUID.uuid(bridgeUuid), controllers);
    return true;
}
#end_block

#method_before
private void setControllerAuto(String bridgeUuid) {
    String controllerUuid = null;
    String iPAddress = IpAddress.valueOf(((InetSocketAddress) channel.localAddress()).getAddress().getHostAddress()).toString();
    String target = "tcp:" + iPAddress + ":" + OvsdbConstant.OFPORT;
    log.debug("controller IP {}: port {}", iPAddress, OvsdbConstant.OFPORT);
    setController(bridgeUuid, target);
}
#method_after
private void setControllerAuto(String bridgeUuid) {
    IpAddress ipAddress = IpAddress.valueOf(((InetSocketAddress) channel.localAddress()).getAddress());
    ControllerInfo controllerInfo = new ControllerInfo(ipAddress, OvsdbConstant.OFPORT, "tcp");
    log.debug("Automatically setting controller for bridge {} to {}", bridgeUuid, controllerInfo.target());
    setControllersWithUUID(UUID.uuid(bridgeUuid), ImmutableList.of(controllerInfo));
}
#end_block

#method_before
@Override
public void setControllersWithUUID(UUID bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<UUID> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    // removeControllers.forEach(c -> controllerRowStore.deleteRow(c.getRow().uuid().value()));
    removeControllers.forEach(c -> deleteConfig(OvsdbConstant.CONTROLLER, "_uuid", c.getRow().uuid().value(), OvsdbConstant.BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        // UUID uuid = c.getRow().uuid();
        // controllerRowStore.insertRow(uuid.value(), c.getRow());
        // newControllerUuids.add(uuid);
        String uuid = insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        log.warn("insertConfig uuid {}", uuid);
        log.warn("row uuid {}", c.getRow().uuid());
        // log.warn("rowStore uuid {}", controllerRowStore.getRowStore());
        newControllerUuids.add(UUID.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid.value(), bridge.getRow());
// rowStore.insertRow(bridgeUuid.value(), bridge.getRow()); //TODO do we need to do this?
}
#method_after
@Override
public void setControllersWithUUID(UUID bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<UUID> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(OvsdbConstant.CONTROLLER, "_uuid", c.getRow().uuid().value(), OvsdbConstant.BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(UUID.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid.value(), bridge.getRow());
}
#end_block

#method_before
@Override
public void createTunnel(String bridgeName, String portName, String tunnelType, Map<String, String> options) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    if (getPortUuid(portName, bridgeUuid) != null) {
        log.warn("Port {} already exists", portName);
        // remove existing one and re-create?
        return;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    // insert a new port to the port table
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    Insert portInsert = new Insert(dbSchema.getTableSchema("Port"), "Port", port.getRow());
    portInsert.getRow().put("interfaces", UUID.uuid("Interface"));
    operations.add(portInsert);
    // update the bridge table
    Condition condition = ConditionUtil.equals("_uuid", UUID.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert("ports", UUID.uuid("Port"));
    List<Condition> conditions = new ArrayList<>(Arrays.asList(condition));
    List<Mutation> mutations = new ArrayList<>(Arrays.asList(mutation));
    operations.add(new Mutate(dbSchema.getTableSchema("Bridge"), conditions, mutations));
    // insert a tunnel interface
    Interface intf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    intf.setName(portName);
    intf.setType(tunnelType);
    intf.setOptions(options);
    Insert intfInsert = new Insert(dbSchema.getTableSchema("Interface"), "Interface", intf.getRow());
    operations.add(intfInsert);
    transactConfig(OvsdbConstant.DATABASENAME, operations);
}
#method_after
@Override
public boolean createTunnel(String bridgeName, String portName, String tunnelType, Map<String, String> options) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    if (getPortUuid(portName, bridgeUuid) != null) {
        log.warn("Port {} already exists", portName);
        // remove existing one and re-create?
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    // insert a new port to the port table
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    Insert portInsert = new Insert(dbSchema.getTableSchema("Port"), "Port", port.getRow());
    portInsert.getRow().put("interfaces", UUID.uuid("Interface"));
    operations.add(portInsert);
    // update the bridge table
    Condition condition = ConditionUtil.equals("_uuid", UUID.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert("ports", UUID.uuid("Port"));
    List<Condition> conditions = new ArrayList<>(Arrays.asList(condition));
    List<Mutation> mutations = new ArrayList<>(Arrays.asList(mutation));
    operations.add(new Mutate(dbSchema.getTableSchema("Bridge"), conditions, mutations));
    // insert a tunnel interface
    Interface intf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    intf.setName(portName);
    intf.setType(tunnelType);
    intf.setOptions(options);
    Insert intfInsert = new Insert(dbSchema.getTableSchema("Interface"), "Interface", intf.getRow());
    operations.add(intfInsert);
    transactConfig(OvsdbConstant.DATABASENAME, operations);
    return true;
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    communicationService.removeSubscriber(PACKET_OUT_SUBJECT);
    messageHandlingExecutor.shutdown();
    tracker.shutdown();
    tracker = null;
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    communicationService.removeSubscriber(PACKET_OUT_SUBJECT);
    messageHandlingExecutor.shutdown();
    tracker = null;
    log.info("Stopped");
}
#end_block

#method_before
public void add(PacketRequest request) {
    requests.compute(request.selector(), (s, existingRequests) -> {
        if (existingRequests == null) {
            return ImmutableSet.of(request);
        } else if (!existingRequests.contains(request)) {
            return ImmutableSet.<PacketRequest>builder().addAll(existingRequests).add(request).build();
        } else {
            return existingRequests;
        }
    });
}
#method_after
public void add(PacketRequest request) {
    AtomicBoolean firstRequest = new AtomicBoolean(false);
    requests.compute(request.selector(), (s, existingRequests) -> {
        if (existingRequests == null) {
            firstRequest.set(true);
            return ImmutableSet.of(request);
        } else if (!existingRequests.contains(request)) {
            return ImmutableSet.<PacketRequest>builder().addAll(existingRequests).add(request).build();
        } else {
            return existingRequests;
        }
    });
    if (firstRequest.get() && delegate != null) {
        // The instance that makes the first request will push to all devices
        delegate.requestPackets(request);
    }
}
#end_block

#method_before
public void remove(PacketRequest request) {
    requests.compute(request.selector(), (s, existingRequests) -> {
        if (existingRequests == null) {
            return null;
        } else if (existingRequests.contains(request)) {
            HashSet<PacketRequest> newRequests = Sets.newHashSet(existingRequests);
            newRequests.remove(request);
            return newRequests.size() > 0 ? ImmutableSet.copyOf(newRequests) : null;
        } else {
            return existingRequests;
        }
    });
}
#method_after
public void remove(PacketRequest request) {
    AtomicBoolean removedLast = new AtomicBoolean(false);
    requests.computeIfPresent(request.selector(), (s, existingRequests) -> {
        if (existingRequests.contains(request)) {
            Set<PacketRequest> newRequests = Sets.newHashSet(existingRequests);
            newRequests.remove(request);
            if (newRequests.size() > 0) {
                return ImmutableSet.copyOf(newRequests);
            } else {
                removedLast.set(true);
                return null;
            }
        } else {
            return existingRequests;
        }
    });
    if (removedLast.get() && delegate != null) {
        // The instance that removes the last request will remove from all devices
        delegate.cancelPackets(request);
    }
}
#end_block

#method_before
@Override
public BGPKeepaliveMsg readFrom(ChannelBuffer cb, BGPHeader bgpHeader) throws BGPParseException {
    // get Marker
    byte[] marker = new byte[MARKER_LENGTH];
    marker = bgpHeader.getMarker();
    // get message length
    short length = bgpHeader.getLength();
    // get message type
    byte type = bgpHeader.getType();
    return new BGPKeepaliveMsgVer4();
}
#method_after
@Override
public BGPKeepaliveMsg readFrom(ChannelBuffer cb, BGPHeader bgpHeader) throws BGPParseException {
    /* bgpHeader is not required in case of keepalive message and
            Header is already read and no other fields except header in keepalive message.*/
    return new BGPKeepaliveMsgVer4();
}
#end_block

#method_before
@Override
public void setControllersWithUUID(UUID bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<UUID> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getTableUuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> controllerRowStore.deleteRow(c.getTableUuid().value()));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        UUID uuid = c.getTableUuid();
        controllerRowStore.insertRow(uuid.value(), c.getRow());
        newControllerUuids.add(uuid);
    });
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(newControllerUuids);
    // TODO do we need to do this?
    rowStore.insertRow(bridgeUuid.value(), bridge.getRow());
}
#method_after
@Override
public void setControllersWithUUID(UUID bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<UUID> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    // removeControllers.forEach(c -> controllerRowStore.deleteRow(c.getRow().uuid().value()));
    removeControllers.forEach(c -> deleteConfig(OvsdbConstant.CONTROLLER, "_uuid", c.getRow().uuid().value(), OvsdbConstant.BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        // UUID uuid = c.getRow().uuid();
        // controllerRowStore.insertRow(uuid.value(), c.getRow());
        // newControllerUuids.add(uuid);
        String uuid = insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        log.warn("insertConfig uuid {}", uuid);
        log.warn("row uuid {}", c.getRow().uuid());
        // log.warn("rowStore uuid {}", controllerRowStore.getRowStore());
        newControllerUuids.add(UUID.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid.value(), bridge.getRow());
// rowStore.insertRow(bridgeUuid.value(), bridge.getRow()); //TODO do we need to do this?
}
#end_block

#method_before
private void setController(String bridgeUuid, String target) {
    String controllerUuid;
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    // 1. get the bridge row
    // 2. delete different controllers and save the same controller.
    // 3. add new controllers
    // 4. update bridge row
    controllerUuid = getControllerUuid(OvsdbConstant.CONTROLLER, target);
    Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
    if (controller != null) {
        if (controllerUuid == null) {
            insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid, controller.getRow());
        } else {
            Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
            Set<UUID> controllerUuids = new HashSet<>();
            controllerUuids.add(UUID.uuid(controllerUuid));
            bridge.setController(controllerUuids);
            updateConfig(OvsdbConstant.CONTROLLER, "_uuid", bridgeUuid, bridge.getRow());
        }
    }
}
#method_after
private void setController(String bridgeUuid, String target) {
    String controllerUuid;
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    // 1. get the bridge row
    // 2. delete different controllers and save the same controller.
    // 3. add new controllers
    // 4. update bridge row
    controllerUuid = getControllerUuid(OvsdbConstant.CONTROLLER, target);
    Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
    if (controller != null) {
        if (controllerUuid == null) {
            insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid, controller.getRow());
        } else {
            Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
            Set<UUID> controllerUuids = new HashSet<>();
            controllerUuids.add(UUID.uuid(controllerUuid));
            bridge.setController(OvsdbSet.ovsdbSet(controllerUuids));
            updateConfig(OvsdbConstant.CONTROLLER, "_uuid", bridgeUuid, bridge.getRow());
        }
    }
}
#end_block

#method_before
@Override
public ListenableFuture<List<OperationResult>> transactConfig(String dbName, List<Operation> operations) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<List<JsonNode>, List<OperationResult>> rowFunction = new Function<List<JsonNode>, List<OperationResult>>() {

            @Override
            public List<OperationResult> apply(List<JsonNode> input) {
                log.info("Get ovsdb operation result");
                List<OperationResult> result = FromJsonUtil.jsonNodeToOperationResult(input, operations);
                if (result == null) {
                    log.debug("The operation result is null");
                    return null;
                }
                return result;
            }
        };
        return Futures.transform(transact(dbSchema, operations), rowFunction);
    }
    return null;
}
#method_after
@Override
public ListenableFuture<List<OperationResult>> transactConfig(String dbName, List<Operation> operations) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<List<JsonNode>, List<OperationResult>> rowFunction = (input -> {
            log.info("Get ovsdb operation result");
            List<OperationResult> result = FromJsonUtil.jsonNodeToOperationResult(input, operations);
            if (result == null) {
                log.debug("The operation result is null");
                return null;
            }
            return result;
        });
        return Futures.transform(transact(dbSchema, operations), rowFunction);
    }
    return null;
}
#end_block

#method_before
private List<Controller> getControllers(UUID bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        return null;
    }
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return null;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    // FIXME remove log
    log.warn("type of controller column", bridge.getControllerColumn().data().getClass());
    List<String> controllerUuidStrings = (List<String>) bridge.getControllerColumn().data();
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return null;
    }
    List<Controller> ovsdbControllers = new ArrayList<>();
    ConcurrentMap<String, Row> controllerTableRows = controllerRowStore.getRowStore();
    controllerTableRows.forEach((key, row) -> {
        if (!controllerUuidStrings.contains(key)) {
            return;
        }
        Controller controller = (Controller) TableGenerator.getTable(dbSchema, row, OvsdbTable.CONTROLLER);
        ovsdbControllers.add(controller);
    });
    return ovsdbControllers;
}
#method_after
private List<Controller> getControllers(UUID bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        return null;
    }
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return null;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    // FIXME remove log
    log.warn("type of controller column", bridge.getControllerColumn().data().getClass());
    Set<UUID> controllerUuids = (Set<UUID>) ((OvsdbSet) bridge.getControllerColumn().data()).set();
    // Set<String> controllerUuidStrings = (Set<String>) bridge.getControllerColumn().data();
    OvsdbRowStore controllerRowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return null;
    }
    List<Controller> ovsdbControllers = new ArrayList<>();
    ConcurrentMap<String, Row> controllerTableRows = controllerRowStore.getRowStore();
    controllerTableRows.forEach((key, row) -> {
        if (!controllerUuids.contains(UUID.uuid(key))) {
            return;
        }
        Controller controller = (Controller) TableGenerator.getTable(dbSchema, row, OvsdbTable.CONTROLLER);
        ovsdbControllers.add(controller);
    });
    return ovsdbControllers;
}
#end_block

#method_before
private UUID getBridgeUUID(DeviceId openflowDeviceId) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        return null;
    }
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return null;
    }
    ConcurrentMap<String, Row> bridgeTableRows = rowStore.getRowStore();
    List<UUID> bridgeUuidStrings = bridgeTableRows.values().stream().map(row -> (Bridge) TableGenerator.getTable(dbSchema, row, OvsdbTable.BRIDGE)).filter(b -> openflowDeviceId.toString().contains(b.getDatapathIdColumn().data().toString())).map(bridge -> bridge.getTableUuid()).collect(Collectors.toList());
    if (bridgeUuidStrings.size() == 0) {
        log.debug("There is no bridge for {}", openflowDeviceId);
        return null;
    } else if (bridgeUuidStrings.size() > 1) {
        log.debug("There are multiple bridges for {}", openflowDeviceId);
        return null;
    }
    return bridgeUuidStrings.get(0);
}
#method_after
private UUID getBridgeUUID(DeviceId openflowDeviceId) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        return null;
    }
    OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return null;
    }
    ConcurrentMap<String, Row> bridgeTableRows = rowStore.getRowStore();
    final AtomicReference<UUID> uuid = new AtomicReference<>();
    for (Map.Entry<String, Row> entry : bridgeTableRows.entrySet()) {
        Bridge b = (Bridge) TableGenerator.getTable(dbSchema, entry.getValue(), OvsdbTable.BRIDGE);
        if (matchesDpid(b, openflowDeviceId)) {
            uuid.set(UUID.uuid(entry.getKey()));
            break;
        }
    }
    if (uuid.get() == null) {
        log.debug("There is no bridge for {}", openflowDeviceId);
    }
    return uuid.get();
}
#end_block

#method_before
public String target() {
    if (type.startsWith("p")) {
        return type + ":" + ip + ":" + port;
    } else {
        return type + ":" + port + ":" + ip;
    }
}
#method_after
public String target() {
    if (type.startsWith("p")) {
        return type + ":" + port + ":" + ip;
    } else {
        return type + ":" + ip + ":" + port;
    }
}
#end_block

#method_before
@Test
public void defaultValues() {
    String target = "tcp:192.168.1.1";
    ControllerInfo controllerInfo = new ControllerInfo(target);
    assertEquals("wrong type", controllerInfo.type(), "tcp");
    assertEquals("wrong ip", controllerInfo.ip(), IpAddress.valueOf("192.168.1.1"));
    assertEquals("wrong port", controllerInfo.port(), 6633);
    String target1 = "ptcp:5000:";
    ControllerInfo controllerInfo2 = new ControllerInfo(target1);
    assertEquals("wrong type", controllerInfo2.type(), "ptcp");
    assertEquals("wrong ip", controllerInfo2.ip(), IpAddress.valueOf("127.0.0.1"));
    assertEquals("wrong port", controllerInfo2.port(), 5000);
    String target2 = "ptcp:";
    ControllerInfo controllerInfo3 = new ControllerInfo(target2);
    assertEquals("wrong type", controllerInfo3.type(), "ptcp");
    assertEquals("wrong ip", controllerInfo3.ip(), IpAddress.valueOf("127.0.0.1"));
    assertEquals("wrong port", controllerInfo3.port(), 6633);
}
#method_after
@Test
public void defaultValues() {
    String target = "tcp:192.168.1.1";
    ControllerInfo controllerInfo = new ControllerInfo(target);
    assertEquals("wrong type", controllerInfo.type(), "tcp");
    assertEquals("wrong ip", controllerInfo.ip(), IpAddress.valueOf("192.168.1.1"));
    assertEquals("wrong port", controllerInfo.port(), 6653);
    String target1 = "ptcp:5000:";
    ControllerInfo controllerInfo2 = new ControllerInfo(target1);
    assertEquals("wrong type", controllerInfo2.type(), "ptcp");
    assertEquals("wrong ip", controllerInfo2.ip(), IpAddress.valueOf("0.0.0.0"));
    assertEquals("wrong port", controllerInfo2.port(), 5000);
    String target2 = "ptcp:";
    ControllerInfo controllerInfo3 = new ControllerInfo(target2);
    assertEquals("wrong type", controllerInfo3.type(), "ptcp");
    assertEquals("wrong ip", controllerInfo3.ip(), IpAddress.valueOf("0.0.0.0"));
    assertEquals("wrong port", controllerInfo3.port(), 6653);
}
#end_block

#method_before
private String[] getMacAndIfaceid(Interface intf) {
    OvsdbMap ovsdbMap = (OvsdbMap) intf.getExternalIdsColumn().data();
    @SuppressWarnings("unchecked")
    Map<String, String> externalIds = ovsdbMap.map();
    if (externalIds == null) {
        log.warn("The external_ids is null");
        return null;
    }
    String attachedMac = externalIds.get(OvsdbConstant.EXTERNAL_ID_VM_MAC);
    if (attachedMac == null) {
        log.warn("The attachedMac is null");
        return null;
    }
    String ifaceid = externalIds.get(OvsdbConstant.EXTERNAL_ID_INTERFACE_ID);
    if (ifaceid == null) {
        log.warn("The ifaceid is null");
        return null;
    }
    return new String[] { attachedMac, ifaceid };
}
#method_after
private String[] getMacAndIfaceid(Interface intf) {
    OvsdbMap ovsdbMap = (OvsdbMap) intf.getExternalIdsColumn().data();
    @SuppressWarnings("unchecked")
    Map<String, String> externalIds = ovsdbMap.map();
    if (externalIds == null) {
        log.warn("The external_ids is null");
        return null;
    }
    String attachedMac = externalIds.get(OvsdbConstant.EXTERNAL_ID_VM_MAC);
    if (attachedMac == null) {
        // FIXME why always null?
        log.debug("The attachedMac is null");
        return null;
    }
    String ifaceid = externalIds.get(OvsdbConstant.EXTERNAL_ID_INTERFACE_ID);
    if (ifaceid == null) {
        log.warn("The ifaceid is null");
        return null;
    }
    return new String[] { attachedMac, ifaceid };
}
#end_block

#method_before
@Override
public List<ControllerInfo> getControllers(DeviceId openflowDeviceId) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<ControllerInfo> controllers = clientService.getControllers(openflowDeviceId);
    return new ArrayList<>(controllers);
}
#method_after
@Override
public List<ControllerInfo> getControllers() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<ControllerInfo> controllers = clientService.getControllers(handler().data().deviceId());
    return new ArrayList<>(controllers);
}
#end_block

#method_before
@Override
public void setControllers(DeviceId openflowDeviceId, List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    if (clientService.getControllers(openflowDeviceId).equals(controllers)) {
        clientService.setControllersWithDeviceId(openflowDeviceId, controllers);
    }
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    if (!clientService.getControllers(handler().data().deviceId()).equals(controllers)) {
        clientService.setControllersWithDeviceId(handler().data().deviceId(), controllers);
    }
}
#end_block

#method_before
private OvsdbClientService getOvsdbClientService(DriverHandler handler) {
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceService deviceService = handler.get(DeviceService.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    String[] mgmtAddress = deviceService.getDevice(ofDeviceId).annotations().value(AnnotationKeys.MANAGEMENT_ADDRESS).split(":");
    String targetIp = mgmtAddress[0];
    TpPort targetPort = null;
    if (mgmtAddress.length > 1) {
        targetPort = TpPort.tpPort(Integer.parseInt(mgmtAddress[1]));
    }
    List<OvsdbNodeId> nodeIds = ovsController.getNodeIds().stream().filter(nodeId -> nodeId.getIpAddress().equals(targetIp)).collect(Collectors.toList());
    if (nodeIds.size() == 0) {
        // TODO decide what port?
        ovsController.connect(IpAddress.valueOf(targetIp), targetPort == null ? TpPort.tpPort(6640) : targetPort);
    }
    List<OvsdbClientService> clientServices = ovsController.getNodeIds().stream().filter(nodeId -> nodeId.getIpAddress().equals(targetIp)).map(ovsController::getOvsdbClient).filter(cs -> cs.getBridges().stream().anyMatch(b -> b.datapathId().value().equals(ofDeviceId.uri().getHost()))).collect(Collectors.toList());
    // FIXME add connection to management address if null --> done ?
    return clientServices.size() > 0 ? clientServices.get(0) : null;
}
#method_after
private OvsdbClientService getOvsdbClientService(DriverHandler handler) {
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceService deviceService = handler.get(DeviceService.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    String[] mgmtAddress = deviceService.getDevice(ofDeviceId).annotations().value(AnnotationKeys.MANAGEMENT_ADDRESS).split(":");
    String targetIp = mgmtAddress[0];
    TpPort targetPort = null;
    if (mgmtAddress.length > 1) {
        targetPort = TpPort.tpPort(Integer.parseInt(mgmtAddress[1]));
    }
    List<OvsdbNodeId> nodeIds = ovsController.getNodeIds().stream().filter(nodeId -> nodeId.getIpAddress().equals(targetIp)).collect(Collectors.toList());
    if (nodeIds.size() == 0) {
        // TODO decide what port?
        ovsController.connect(IpAddress.valueOf(targetIp), targetPort == null ? TpPort.tpPort(6640) : targetPort);
        // FIXME... connect is async
        delay(1000);
    }
    List<OvsdbClientService> clientServices = ovsController.getNodeIds().stream().filter(nodeId -> nodeId.getIpAddress().equals(targetIp)).map(ovsController::getOvsdbClient).filter(cs -> cs.getBridges().stream().anyMatch(b -> dpidMatches(b, ofDeviceId))).collect(Collectors.toList());
    checkState(clientServices.size() > 0, "No clientServices found");
    // FIXME add connection to management address if null --> done ?
    return clientServices.size() > 0 ? clientServices.get(0) : null;
}
#end_block

#method_before
@Override
protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception {
    log.debug("BGPMessageEncoder::encode");
    if (!(msg instanceof List)) {
        log.debug("Invalid msg.");
        return msg;
    }
    @SuppressWarnings("unchecked")
    List<BGPMessage> msglist = (List<BGPMessage>) msg;
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    log.debug("SENDING MESSAGE");
    for (BGPMessage pm : msglist) {
        pm.writeTo(buf);
    }
    HexDump.bgpHexDump(buf);
    return buf;
}
#method_after
@Override
protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception {
    log.debug("BGPMessageEncoder::encode");
    if (!(msg instanceof List)) {
        log.debug("Invalid msg.");
        return msg;
    }
    @SuppressWarnings("unchecked")
    List<BGPMessage> msglist = (List<BGPMessage>) msg;
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    log.debug("SENDING MESSAGE");
    for (BGPMessage pm : msglist) {
        pm.writeTo(buf);
    }
    HexDump.dump(buf);
    return buf;
}
#end_block

#method_before
@Override
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
    List<BGPMessage> msgList = new LinkedList<BGPMessage>();
    log.debug("MESSAGE IS RECEIVED.");
    if (!channel.isConnected()) {
        log.info("Channel is not connected.");
        return null;
    }
    HexDump.bgpHexDump(buffer);
    // TODO: decode bgp messages
    return msgList;
}
#method_after
@Override
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
    List<BGPMessage> msgList = new LinkedList<BGPMessage>();
    log.debug("MESSAGE IS RECEIVED.");
    if (!channel.isConnected()) {
        log.info("Channel is not connected.");
        return null;
    }
    HexDump.dump(buffer);
    // TODO: decode bgp messages
    return msgList;
}
#end_block

#method_before
@Override
public void allocateResources(LinkResourceAllocations allocations) {
    checkNotNull(allocations);
    TransactionContext tx = getTxContext();
    tx.begin();
    try {
        TransactionalMap<IntentId, LinkResourceAllocations> intentAllocs = getIntentAllocs(tx);
        intentAllocs.put(allocations.intentId(), allocations);
        allocations.links().forEach(link -> allocateLinkResource(tx, link, allocations));
        tx.commit();
    } catch (TransactionException | ResourceAllocationException e) {
        log.error("Exception thrown, rolling back", e);
        tx.abort();
        throw e;
    }
}
#method_after
@Override
public void allocateResources(LinkResourceAllocations allocations) {
    checkNotNull(allocations);
    TransactionContext tx = getTxContext();
    tx.begin();
    try {
        TransactionalMap<IntentId, LinkResourceAllocations> intentAllocs = getIntentAllocs(tx);
        intentAllocs.put(allocations.intentId(), allocations);
        allocations.links().forEach(link -> allocateLinkResource(tx, link, allocations));
        tx.commit();
    } catch (TransactionException | ResourceAllocationException e) {
        log.error("Exception thrown, rolling back", e);
        tx.abort();
    } catch (Exception e) {
        log.error("Exception thrown, rolling back", e);
        tx.abort();
        throw e;
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    for (OpenFlowSwitch sw : controller.getSwitches()) {
        try {
            listener.switchAdded(new Dpid(sw.getId()));
        } catch (Exception e) {
            LOG.warn("Failed initially adding {} : {}", sw.getStringId(), e.getMessage());
            LOG.debug("Error details:", e);
            // disconnect to trigger switch-add later
            sw.disconnectSwitch();
        }
        PortStatsCollector psc = new PortStatsCollector(sw, portStatsPollFrequency);
        psc.start();
        collectors.put(new Dpid(sw.getId()), psc);
    }
    LOG.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    connectInitialDevices();
    LOG.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    providerRegistry.unregister(this);
    controller.removeListener(listener);
    collectors.values().forEach(PortStatsCollector::stop);
    providerService = null;
    LOG.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    controller.removeListener(listener);
    disconnectDevices();
    providerRegistry.unregister(this);
    collectors.values().forEach(PortStatsCollector::stop);
    providerService = null;
    LOG.info("Stopped");
}
#end_block

#method_before
@Override
public boolean isReachable(DeviceId deviceId) {
    OpenFlowSwitch sw = controller.getSwitch(dpid(deviceId.uri()));
    if (sw == null || !sw.isConnected()) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean isReachable(DeviceId deviceId) {
    OpenFlowSwitch sw = controller.getSwitch(dpid(deviceId.uri()));
    return sw != null && sw.isConnected();
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    Map<String, String> properties = readComponentConfiguration(context);
    ctrl.setConfigParams(properties);
    ctrl.start(agent, driverService);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    ctrl.setConfigParams(context.getProperties());
    ctrl.start(agent, driverService);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Map<String, String> properties = readComponentConfiguration(context);
    ctrl.stop();
    ctrl.setConfigParams(properties);
    ctrl.start(agent, driverService);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    ctrl.stop();
    ctrl.setConfigParams(context.getProperties());
    ctrl.start(agent, driverService);
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    return FluentIterable.from(getFlowTable(deviceId).values()).transformAndConcat(new Function<List<StoredFlowEntry>, Iterable<? extends FlowEntry>>() {

        @Override
        public Iterable<? extends FlowEntry> apply(List<StoredFlowEntry> input) {
            return Collections.unmodifiableList(input);
        }
    });
}
#method_after
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    return FluentIterable.from(getFlowTable(deviceId).values()).transformAndConcat(Collections::unmodifiableList);
}
#end_block

#method_before
@Override
public void pushFlowMetrics(DeviceId deviceId, Iterable<FlowEntry> flowEntries) {
    Map<FlowEntry, FlowEntry> storedRules = Maps.newHashMap();
    store.getFlowEntries(deviceId).forEach(f -> storedRules.put(f, f));
    for (FlowEntry rule : flowEntries) {
        try {
            FlowEntry storedRule = storedRules.remove(rule);
            if (storedRule != null) {
                if (storedRule.exactMatch(rule)) {
                    // we both have the rule, let's update some info then.
                    flowAdded(rule);
                } else {
                    // the two rules are not an exact match - remove the
                    // switch's rule and install our rule
                    extraneousFlow(rule);
                    flowMissing(storedRule);
                }
            } else {
                // the device has a rule the store does not have
                if (!allowExtraneousRules) {
                    extraneousFlow(rule);
                }
            }
        } catch (Exception e) {
            log.debug("Can't process added or extra rule {}", e.getMessage());
            continue;
        }
    }
    for (FlowEntry rule : storedRules.keySet()) {
        try {
            // there are rules in the store that aren't on the switch
            log.debug("Adding rule in store, but not on switch {}", rule);
            flowMissing(rule);
        } catch (Exception e) {
            log.debug("Can't add missing flow rule {}", e.getMessage());
            continue;
        }
    }
}
#method_after
@Override
public void pushFlowMetrics(DeviceId deviceId, Iterable<FlowEntry> flowEntries) {
    pushFlowMetricsInternal(deviceId, flowEntries, true);
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started with flowPollFrequency = {}, adaptiveFlowSampling = {}", flowPollFrequency, adaptiveFlowSampling);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
    boolean newAdaptiveFlowSampling;
    String s = get(properties, "adaptiveFlowSampling");
    newAdaptiveFlowSampling = isNullOrEmpty(s) ? adaptiveFlowSampling : Boolean.parseBoolean(s.trim());
    if (newAdaptiveFlowSampling != adaptiveFlowSampling) {
        // stop previous collector
        stopCollectors();
        adaptiveFlowSampling = newAdaptiveFlowSampling;
        // create new collectors
        createCollectors();
    }
    log.info("Settings: adaptiveFlowSampling={}", adaptiveFlowSampling);
}
#end_block

#method_before
private void createCollector(OpenFlowSwitch sw) {
    FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
    fsc.start();
    collectors.put(new Dpid(sw.getId()), fsc);
    TableStatisticsCollector tsc = new TableStatisticsCollector(timer, sw, flowPollFrequency);
    tsc.start();
    tableStatsCollectors.put(new Dpid(sw.getId()), tsc);
}
#method_after
private void createCollector(OpenFlowSwitch sw) {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(sw, flowPollFrequency);
        fsc.start();
        afsCollectors.put(new Dpid(sw.getId()), fsc);
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        fsc.start();
        simpleCollectors.put(new Dpid(sw.getId()), fsc);
    }
    TableStatisticsCollector tsc = new TableStatisticsCollector(timer, sw, flowPollFrequency);
    tsc.start();
    tableStatsCollectors.put(new Dpid(sw.getId()), tsc);
}
#end_block

#method_before
private void stopCollectors() {
    collectors.values().forEach(FlowStatsCollector::stop);
    collectors.clear();
    tableStatsCollectors.values().forEach(TableStatisticsCollector::stop);
    tableStatsCollectors.clear();
}
#method_after
private void stopCollectors() {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Destructor
        afsCollectors.values().forEach(NewAdaptiveFlowStatsCollector::stop);
        afsCollectors.clear();
    } else {
        simpleCollectors.values().forEach(FlowStatsCollector::stop);
        simpleCollectors.clear();
    }
    tableStatsCollectors.values().forEach(TableStatisticsCollector::stop);
    tableStatsCollectors.clear();
}
#end_block

#method_before
private void adjustRate() {
    DefaultLoad.setPollInterval(flowPollFrequency);
    collectors.values().forEach(fsc -> fsc.adjustPollInterval(flowPollFrequency));
    tableStatsCollectors.values().forEach(tsc -> tsc.adjustPollInterval(flowPollFrequency));
}
#method_after
private void adjustRate() {
    DefaultLoad.setPollInterval(flowPollFrequency);
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector calAndPollInterval
        afsCollectors.values().forEach(fsc -> fsc.adjustCalAndPollInterval(flowPollFrequency));
    } else {
        simpleCollectors.values().forEach(fsc -> fsc.adjustPollInterval(flowPollFrequency));
    }
    tableStatsCollectors.values().forEach(tsc -> tsc.adjustPollInterval(flowPollFrequency));
}
#end_block

#method_before
private void applyRule(FlowRule flowRule) {
    OpenFlowSwitch sw = controller.getSwitch(Dpid.dpid(flowRule.deviceId().uri()));
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowAdd());
}
#method_after
private void applyRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowAdd());
    if (adaptiveFlowSampling) {
        // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
        afsCollectors.get(dpid).addWithFlowRule(flowRule);
    }
}
#end_block

#method_before
private void removeRule(FlowRule flowRule) {
    OpenFlowSwitch sw = controller.getSwitch(Dpid.dpid(flowRule.deviceId().uri()));
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowDel());
}
#method_after
private void removeRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowDel());
    if (adaptiveFlowSampling) {
        // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
        afsCollectors.get(dpid).removeFlows(flowRule);
    }
}
#end_block

#method_before
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    OpenFlowSwitch sw = controller.getSwitch(Dpid.dpid(batch.deviceId().uri()));
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()));
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#method_after
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    checkNotNull(batch);
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()));
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                if (adaptiveFlowSampling) {
                    // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    afsCollectors.get(dpid).addWithFlowRule(fbe.target());
                }
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                if (adaptiveFlowSampling) {
                    // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    afsCollectors.get(dpid).removeFlows(fbe.target());
                }
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                if (adaptiveFlowSampling) {
                    // Add or Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    // afsCollectors.get(dpid).addWithFlowRule(fbe.target()); //check if add is good or not
                    afsCollectors.get(dpid).addOrUpdateFlows((FlowEntry) fbe.target());
                }
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#end_block

#method_before
@Override
public void switchAdded(Dpid dpid) {
    createCollector(controller.getSwitch(dpid));
}
#method_after
@Override
public void switchAdded(Dpid dpid) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    createCollector(controller.getSwitch(dpid));
}
#end_block

#method_before
@Override
public void switchRemoved(Dpid dpid) {
    FlowStatsCollector collector = collectors.remove(dpid);
    if (collector != null) {
        collector.stop();
    }
    TableStatisticsCollector tsc = tableStatsCollectors.remove(dpid);
    if (tsc != null) {
        tsc.stop();
    }
}
#method_after
@Override
public void switchRemoved(Dpid dpid) {
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector collector = afsCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    } else {
        FlowStatsCollector collector = simpleCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    }
    TableStatisticsCollector tsc = tableStatsCollectors.remove(dpid);
    if (tsc != null) {
        tsc.stop();
    }
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(dpid, fm).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            if (adaptiveFlowSampling) {
                // Removed TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                afsCollectors.get(dpid).flowRemoved(fr);
            }
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(dpid, fm).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    List<FlowEntry> flowEntries = replies.getEntries().stream().map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    providerService.pushFlowMetrics(did, flowEntries);
}
#method_after
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    List<FlowEntry> flowEntries = replies.getEntries().stream().map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector afsc = afsCollectors.get(dpid);
        synchronized (afsc) {
            if (afsc.getFlowMissingXid() != NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID) {
                log.debug("OpenFlowRuleProvider:pushFlowMetrics, flowMissingXid={}, " + "OFFlowStatsReply Xid={}, for {}", afsc.getFlowMissingXid(), replies.getXid(), dpid);
            }
            // Check that OFFlowStatsReply Xid is same with the one of OFFlowStatsRequest?
            if (afsc.getFlowMissingXid() != NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID) {
                if (afsc.getFlowMissingXid() == replies.getXid()) {
                    // call entire flow stats update with flowMissing synchronization.
                    // used existing pushFlowMetrics
                    providerService.pushFlowMetrics(did, flowEntries);
                }
                // reset flowMissingXid to NO_FLOW_MISSING_XID
                afsc.setFlowMissingXid(NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID);
            } else {
                // call individual flow stats update
                providerService.pushFlowMetricsWithoutFlowMissing(did, flowEntries);
            }
            // Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
            afsc.pushFlowMetrics(flowEntries);
        }
    } else {
        // call existing entire flow stats update with flowMissing synchronization
        providerService.pushFlowMetrics(did, flowEntries);
    }
}
#end_block

#method_before
@Path("show-all")
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response showAll() throws IOException {
    McastRouteTable mrt = McastRouteTable.getInstance();
    ObjectNode pushContent = new MRibCodec().encode(mrt, this);
    return ok(pushContent.toString()).build();
}
#method_after
@Path("show")
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response showAll() throws IOException {
    McastRouteTable mrt = McastRouteTable.getInstance();
    ObjectNode pushContent = new MRibCodec().encode(mrt, this);
    return ok(pushContent.toString()).build();
}
#end_block

#method_before
@Override
public void setUpConnectivityHostToInternet(IpAddress hostIp, IpPrefix prefix, IpAddress nextHopIpAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return;
    }
    Set<Host> hosts = hostService.getHostsByIp(nextHopIpAddress);
    if (hosts.isEmpty()) {
        log.warn("No host found for next hop IP address");
        return;
    }
    MacAddress nextHopMacAddress = null;
    for (Host host : hosts) {
        nextHopMacAddress = host.mac();
        break;
    }
    hosts = hostService.getHostsByIp(hostIp);
    if (hosts.isEmpty()) {
        log.warn("No host found for host IP address");
        return;
    }
    Host host = hosts.stream().findFirst().get();
    ConnectPoint ingressPoint = host.location();
    // Generate the intent itself
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    // Match the destination IP prefix at the first hop
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchIPDst(prefix);
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchIPv6Dst(prefix);
    }
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    if (!egressInterface.vlan().equals(VlanId.NONE)) {
        treatment.setVlanId(egressInterface.vlan());
        // If we set VLAN ID, we have to make sure a VLAN tag exists.
        // TODO support no VLAN -> VLAN routing
        selector.matchVlanId(VlanId.ANY);
    }
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    Key key = Key.of(prefix.toString(), appId);
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(Collections.singleton(ingressPoint)).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
    submitReactiveIntent(prefix, intent);
}
#method_after
@Override
public void setUpConnectivityHostToInternet(IpAddress hostIp, IpPrefix prefix, IpAddress nextHopIpAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return;
    }
    Set<Host> hosts = hostService.getHostsByIp(nextHopIpAddress);
    if (hosts.isEmpty()) {
        log.warn("No host found for next hop IP address");
        return;
    }
    MacAddress nextHopMacAddress = null;
    for (Host host : hosts) {
        nextHopMacAddress = host.mac();
        break;
    }
    hosts = hostService.getHostsByIp(hostIp);
    if (hosts.isEmpty()) {
        log.warn("No host found for host IP address");
        return;
    }
    Host host = hosts.stream().findFirst().get();
    ConnectPoint ingressPoint = host.location();
    // Generate the intent itself
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    // Match the destination IP prefix at the first hop
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchIPDst(prefix);
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchIPv6Dst(prefix);
    }
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    if (!egressInterface.vlan().equals(VlanId.NONE)) {
        treatment.setVlanId(egressInterface.vlan());
        // If we set VLAN ID, we have to make sure a VLAN tag exists.
        // TODO support no VLAN -> VLAN routing
        selector.matchVlanId(VlanId.ANY);
    }
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    Key key = Key.of(prefix.toString() + "-reactive", appId);
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(Collections.singleton(ingressPoint)).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
    submitReactiveIntent(prefix, intent);
}
#end_block

#method_before
@Override
public boolean addPeer(String routerid, int remoteAs, short holdTime) {
    BGPPeerConfig lspeer = new BGPPeerConfig();
    if (this.bgpPeerTree.get(routerid) == null) {
        lspeer.setPeerRouterId(routerid);
        lspeer.setAsNumber(remoteAs);
        lspeer.setHoldtime(holdTime);
        lspeer.setState(BGPPeerCfg.State.IDLE);
        lspeer.setSelfInnitConnection(false);
        if (this.getAsNumber() == remoteAs) {
            lspeer.setIsIBgp(true);
        } else {
            lspeer.setIsIBgp(false);
        }
        this.bgpPeerTree.put(routerid, lspeer);
        log.debug("added successfully");
        return true;
    } else {
        log.debug("already exists: \n");
        return false;
    }
}
#method_after
@Override
public boolean addPeer(String routerid, int remoteAs, short holdTime) {
    BGPPeerConfig lspeer = new BGPPeerConfig();
    if (this.bgpPeerTree.get(routerid) == null) {
        lspeer.setPeerRouterId(routerid);
        lspeer.setAsNumber(remoteAs);
        lspeer.setHoldtime(holdTime);
        lspeer.setState(BGPPeerCfg.State.IDLE);
        lspeer.setSelfInnitConnection(false);
        if (this.getAsNumber() == remoteAs) {
            lspeer.setIsIBgp(true);
        } else {
            lspeer.setIsIBgp(false);
        }
        this.bgpPeerTree.put(routerid, lspeer);
        log.debug("added successfully");
        return true;
    } else {
        log.debug("already exists");
        return false;
    }
}
#end_block

#method_before
@Override
public boolean removePeer(String routerid) {
    BGPPeerCfg lspeer = this.bgpPeerTree.get(routerid);
    if (lspeer != null) {
        // TODO DISCONNECT PEER
        disconnectPeer(routerid);
        lspeer.setSelfInnitConnection(false);
        lspeer = this.bgpPeerTree.remove(routerid);
        log.debug("Deleted : " + routerid + " successfully");
        return true;
    } else {
        log.debug("\n Did not find : " + routerid + "\n");
        return false;
    }
}
#method_after
@Override
public boolean removePeer(String routerid) {
    BGPPeerCfg lspeer = this.bgpPeerTree.get(routerid);
    if (lspeer != null) {
        // TODO DISCONNECT PEER
        disconnectPeer(routerid);
        lspeer.setSelfInnitConnection(false);
        lspeer = this.bgpPeerTree.remove(routerid);
        log.debug("Deleted : " + routerid + " successfully");
        return true;
    } else {
        log.debug("Did not find : " + routerid);
        return false;
    }
}
#end_block

#method_before
@Override
public boolean disconnectPeer(String routerid) {
    BGPPeerCfg lspeer = this.bgpPeerTree.get(routerid);
    if (lspeer != null) {
        // TODO DISCONNECT PEER
        lspeer.setState(BGPPeerCfg.State.IDLE);
        lspeer.setSelfInnitConnection(false);
        log.debug("\n Disconnected : " + routerid + " successfully\n");
        return true;
    } else {
        log.debug("\n Did not find : " + routerid + "\n");
        return false;
    }
}
#method_after
@Override
public boolean disconnectPeer(String routerid) {
    BGPPeerCfg lspeer = this.bgpPeerTree.get(routerid);
    if (lspeer != null) {
        // TODO DISCONNECT PEER
        lspeer.setState(BGPPeerCfg.State.IDLE);
        lspeer.setSelfInnitConnection(false);
        log.debug("Disconnected : " + routerid + " successfully");
        return true;
    } else {
        log.debug("Did not find : " + routerid);
        return false;
    }
}
#end_block

#method_before
@Override
public void setPeerConnState(String routerid, BGPPeerCfg.State state) {
    BGPPeerCfg lspeer = this.bgpPeerTree.get(routerid);
    if (lspeer != null) {
        lspeer.setState(state);
        log.debug("\n Peer : " + routerid + " is not available \n");
        return;
    } else {
        log.debug("\n Did not find : " + routerid + "\n");
        return;
    }
}
#method_after
@Override
public void setPeerConnState(String routerid, BGPPeerCfg.State state) {
    BGPPeerCfg lspeer = this.bgpPeerTree.get(routerid);
    if (lspeer != null) {
        lspeer.setState(state);
        log.debug("Peer : " + routerid + " is not available");
        return;
    } else {
        log.debug("Did not find : " + routerid);
        return;
    }
}
#end_block

#method_before
@Override
public TreeMap<String, BGPPeerCfg> displayPeers() {
    if (this.bgpPeerTree.isEmpty()) {
        log.debug("There are no BGP peers\n");
    } else {
        Set<Entry<String, BGPPeerCfg>> set = this.bgpPeerTree.entrySet();
        Iterator<Entry<String, BGPPeerCfg>> list = set.iterator();
        BGPPeerCfg lspeer;
        while (list.hasNext()) {
            Entry<String, BGPPeerCfg> me = list.next();
            lspeer = me.getValue();
            log.debug("\n Peer neighbor IP :" + me.getKey());
            log.debug(", AS Number : " + lspeer.getAsNumber());
            log.debug(", Hold Timer : " + lspeer.getHoldtime());
            log.debug(", Is iBGP : " + lspeer.getIsIBgp());
        }
    }
    return null;
}
#method_after
@Override
public TreeMap<String, BGPPeerCfg> displayPeers() {
    if (this.bgpPeerTree.isEmpty()) {
        log.debug("There are no BGP peers");
    } else {
        Set<Entry<String, BGPPeerCfg>> set = this.bgpPeerTree.entrySet();
        Iterator<Entry<String, BGPPeerCfg>> list = set.iterator();
        BGPPeerCfg lspeer;
        while (list.hasNext()) {
            Entry<String, BGPPeerCfg> me = list.next();
            lspeer = me.getValue();
            log.debug("Peer neighbor IP :" + me.getKey());
            log.debug(", AS Number : " + lspeer.getAsNumber());
            log.debug(", Hold Timer : " + lspeer.getHoldtime());
            log.debug(", Is iBGP : " + lspeer.getIsIBgp());
        }
    }
    return null;
}
#end_block

#method_before
@Override
public BGPPeerCfg displayPeers(String routerid) {
    if (this.bgpPeerTree.isEmpty()) {
        log.debug("There are no BGP peers\n");
    } else {
        return this.bgpPeerTree.get(routerid);
    }
    return null;
}
#method_after
@Override
public BGPPeerCfg displayPeers(String routerid) {
    if (this.bgpPeerTree.isEmpty()) {
        log.debug("There are no BGP peers");
    } else {
        return this.bgpPeerTree.get(routerid);
    }
    return null;
}
#end_block

#method_before
public synchronized void updateFlowStatistic(FlowEntry rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    Set<FlowEntry> curr = current.get(cp);
    if (curr == null) {
        addFlowStatistic(rule);
    } else {
        FlowEntry f = curr.stream().filter(c -> rule.equals(c)).findAny().orElse(null);
        if (f != null && rule.bytes() < f.bytes()) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " Invalid Flow Update! Will be removed!!" + " curr flowId=" + Long.toHexString(rule.id().value()) + ", prev flowId=" + Long.toHexString(f.id().value()) + ", curr bytes=" + rule.bytes() + ", prev bytes=" + f.bytes() + ", curr life=" + rule.life() + ", prev life=" + f.life() + ", curr lastSeen=" + rule.lastSeen() + ", prev lastSeen=" + f.lastSeen());
            // something is wrong! invalid flow entry, so delete it
            removeFlowStatistic(rule);
            return;
        }
        Set<FlowEntry> prev = previous.get(cp);
        if (prev == null) {
            prev = new HashSet<>();
            previous.put(cp, prev);
        }
        // previous one is exist
        if (f != null) {
            // remove old one and add new one
            prev.remove(rule);
            if (!prev.add(f)) {
                log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " flowId={}, add failed into previous.", Long.toHexString(rule.id().value()));
            }
        }
        // remove old one and add new one
        curr.remove(rule);
        if (!curr.add(rule)) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " flowId={}, add failed into current.", Long.toHexString(rule.id().value()));
        }
    }
}
#method_after
public synchronized void updateFlowStatistic(FlowEntry rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    Set<FlowEntry> curr = current.get(cp);
    if (curr == null) {
        addFlowStatistic(rule);
    } else {
        Optional<FlowEntry> f = curr.stream().filter(c -> rule.equals(c)).findAny();
        if (f.isPresent() && rule.bytes() < f.get().bytes()) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " Invalid Flow Update! Will be removed!!" + " curr flowId=" + Long.toHexString(rule.id().value()) + ", prev flowId=" + Long.toHexString(f.get().id().value()) + ", curr bytes=" + rule.bytes() + ", prev bytes=" + f.get().bytes() + ", curr life=" + rule.life() + ", prev life=" + f.get().life() + ", curr lastSeen=" + rule.lastSeen() + ", prev lastSeen=" + f.get().lastSeen());
            // something is wrong! invalid flow entry, so delete it
            removeFlowStatistic(rule);
            return;
        }
        Set<FlowEntry> prev = previous.get(cp);
        if (prev == null) {
            prev = new HashSet<>();
            previous.put(cp, prev);
        }
        // previous one is exist
        if (f.isPresent()) {
            // remove old one and add new one
            prev.remove(rule);
            if (!prev.add(f.get())) {
                log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " flowId={}, add failed into previous.", Long.toHexString(rule.id().value()));
            }
        }
        // remove old one and add new one
        curr.remove(rule);
        if (!curr.add(rule)) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " flowId={}, add failed into current.", Long.toHexString(rule.id().value()));
        }
    }
}
#end_block

#method_before
@Override
protected void execute() {
    DeviceService deviceService = get(DeviceService.class);
    FlowStatisticService flowStatsService = get(FlowStatisticService.class);
    String deviceURI = getDeviceId(devicePort);
    String portURI = getPortNumber(devicePort);
    DeviceId ingressDeviceId = deviceId(deviceURI);
    PortNumber ingressPortNumber;
    if (portURI.length() == 0) {
        ingressPortNumber = null;
    } else {
        ingressPortNumber = portNumber(portURI);
    }
    Device device = deviceService.getDevice(ingressDeviceId);
    if (device == null) {
        error("No such device %s", ingressDeviceId.uri());
        return;
    }
    if (ingressPortNumber != null) {
        Port port = deviceService.getPort(ingressDeviceId, ingressPortNumber);
        if (port == null) {
            error("No such port %s on device %s", portURI, ingressDeviceId.uri());
            return;
        }
    }
    if (flowLiveType != null) {
        flowLiveType = flowLiveType.toUpperCase();
    }
    if (instructionType != null) {
        instructionType = instructionType.toUpperCase();
    }
    // convert String to FlowLiveType and check validity
    TypedStoredFlowEntry.FlowLiveType inLiveType;
    if (flowLiveType == null) {
        inLiveType = null;
    } else {
        inLiveType = getFlowLiveType(flowLiveType);
        if (inLiveType == null) {
            error("Invalid flow live type [%s] error", flowLiveType);
            return;
        }
    }
    // convert String to InstructionType and check validity
    Instruction.Type inInstructionType;
    if (instructionType == null) {
        inInstructionType = null;
    } else {
        inInstructionType = getInstructionType(instructionType);
        if (inInstructionType == null) {
            error("Invalid instruction type [%s] error", instructionType);
            return;
        }
    }
    if (showTopn != null) {
        int topn = Integer.parseInt(showTopn);
        if (topn <= 0) {
            // default value
            topn = 100;
        } else if (topn > 1000) {
            // max value
            topn = 1000;
        }
        // print show topn head line with type
        print("deviceId=%s, show TOPN=%s flows, live type=%s, instruction type=%s", deviceURI, Integer.toString(topn), flowLiveType == null ? "ALL" : flowLiveType, instructionType == null ? "ALL" : instructionType);
        if (ingressPortNumber == null) {
            Map<ConnectPoint, List<TypedFlowEntryWithLoad>> typedFlowLoadMap = flowStatsService.loadTopnByType(device, inLiveType, inInstructionType, topn);
            // print all ports topn flows load for a given device
            for (ConnectPoint cp : typedFlowLoadMap.keySet()) {
                printPortFlowsLoad(cp, typedFlowLoadMap.get(cp));
            }
        } else {
            List<TypedFlowEntryWithLoad> typedFlowLoad = flowStatsService.loadTopnByType(device, ingressPortNumber, inLiveType, inInstructionType, topn);
            // print device/port topn flows load
            ConnectPoint cp = new ConnectPoint(ingressDeviceId, ingressPortNumber);
            printPortFlowsLoad(cp, typedFlowLoad);
        }
    } else if (showAll) {
        // is true?
        // print show all head line with type
        print("deviceId=%s, show ALL flows, live type=%s, instruction type=%s", deviceURI, flowLiveType == null ? "ALL" : flowLiveType, instructionType == null ? "ALL" : instructionType);
        if (ingressPortNumber == null) {
            Map<ConnectPoint, List<TypedFlowEntryWithLoad>> typedFlowLoadMap = flowStatsService.loadAllByType(device, inLiveType, inInstructionType);
            // print all ports all flows load for a given device
            for (ConnectPoint cp : typedFlowLoadMap.keySet()) {
                printPortFlowsLoad(cp, typedFlowLoadMap.get(cp));
            }
        } else {
            List<TypedFlowEntryWithLoad> typedFlowLoad = flowStatsService.loadAllByType(device, ingressPortNumber, inLiveType, inInstructionType);
            // print device/port all flows load
            ConnectPoint cp = new ConnectPoint(ingressDeviceId, ingressPortNumber);
            printPortFlowsLoad(cp, typedFlowLoad);
        }
    } else {
        // if (showSummary == true) //always true
        // print show summary head line
        print("deviceId=%s, show SUMMARY flows", deviceURI);
        if (ingressPortNumber == null) {
            Map<ConnectPoint, SummaryFlowEntryWithLoad> summaryFlowLoadMap = flowStatsService.loadSummary(device);
            // print all ports flow load summary for a given device
            for (ConnectPoint cp : summaryFlowLoadMap.keySet()) {
                printPortSummaryLoad(cp, summaryFlowLoadMap.get(cp));
            }
        } else {
            SummaryFlowEntryWithLoad summaryFlowLoad = flowStatsService.loadSummary(device, ingressPortNumber);
            // print device/port flow load summary
            ConnectPoint cp = new ConnectPoint(ingressDeviceId, ingressPortNumber);
            printPortSummaryLoad(cp, summaryFlowLoad);
        }
    }
}
#method_after
@Override
protected void execute() {
    DeviceService deviceService = get(DeviceService.class);
    FlowStatisticService flowStatsService = get(FlowStatisticService.class);
    String deviceURI = getDeviceId(devicePort);
    String portURI = getPortNumber(devicePort);
    DeviceId ingressDeviceId = deviceId(deviceURI);
    PortNumber ingressPortNumber;
    if (portURI.length() == 0) {
        ingressPortNumber = null;
    } else {
        ingressPortNumber = portNumber(portURI);
    }
    Device device = deviceService.getDevice(ingressDeviceId);
    if (device == null) {
        error("No such device %s", ingressDeviceId.uri());
        return;
    }
    if (ingressPortNumber != null) {
        Port port = deviceService.getPort(ingressDeviceId, ingressPortNumber);
        if (port == null) {
            error("No such port %s on device %s", portURI, ingressDeviceId.uri());
            return;
        }
    }
    if (flowLiveType != null) {
        flowLiveType = flowLiveType.toUpperCase();
    }
    if (instructionType != null) {
        instructionType = instructionType.toUpperCase();
    }
    // convert String to FlowLiveType and check validity
    TypedStoredFlowEntry.FlowLiveType inLiveType;
    if (flowLiveType == null) {
        inLiveType = null;
    } else {
        inLiveType = getFlowLiveType(flowLiveType);
        if (inLiveType == null) {
            error("Invalid flow live type [%s] error", flowLiveType);
            return;
        }
    }
    // convert String to InstructionType and check validity
    Instruction.Type inInstructionType;
    if (instructionType == null) {
        inInstructionType = null;
    } else {
        inInstructionType = getInstructionType(instructionType);
        if (inInstructionType == null) {
            error("Invalid instruction type [%s] error", instructionType);
            return;
        }
    }
    if (showTopn != null) {
        int topn = Integer.parseInt(showTopn);
        if (topn <= 0) {
            // default value
            topn = 100;
        } else if (topn > 1000) {
            // max value
            topn = 1000;
        }
        // print show topn head line with type
        print("deviceId=%s, show TOPN=%s flows, live type=%s, instruction type=%s", deviceURI, Integer.toString(topn), flowLiveType == null ? "ALL" : flowLiveType, instructionType == null ? "ALL" : instructionType);
        if (ingressPortNumber == null) {
            Map<ConnectPoint, List<TypedFlowEntryWithLoad>> typedFlowLoadMap = flowStatsService.loadTopnByType(device, inLiveType, inInstructionType, topn);
            // print all ports topn flows load for a given device
            for (ConnectPoint cp : typedFlowLoadMap.keySet()) {
                printPortFlowsLoad(cp, typedFlowLoadMap.get(cp));
            }
        } else {
            List<TypedFlowEntryWithLoad> typedFlowLoad = flowStatsService.loadTopnByType(device, ingressPortNumber, inLiveType, inInstructionType, topn);
            // print device/port topn flows load
            ConnectPoint cp = new ConnectPoint(ingressDeviceId, ingressPortNumber);
            printPortFlowsLoad(cp, typedFlowLoad);
        }
    } else if (showAll) {
        // is true?
        // print show all head line with type
        print("deviceId=%s, show ALL flows, live type=%s, instruction type=%s", deviceURI, flowLiveType == null ? "ALL" : flowLiveType, instructionType == null ? "ALL" : instructionType);
        if (ingressPortNumber == null) {
            Map<ConnectPoint, List<TypedFlowEntryWithLoad>> typedFlowLoadMap = flowStatsService.loadAllByType(device, inLiveType, inInstructionType);
            // print all ports all flows load for a given device
            for (ConnectPoint cp : typedFlowLoadMap.keySet()) {
                printPortFlowsLoad(cp, typedFlowLoadMap.get(cp));
            }
        } else {
            List<TypedFlowEntryWithLoad> typedFlowLoad = flowStatsService.loadAllByType(device, ingressPortNumber, inLiveType, inInstructionType);
            // print device/port all flows load
            ConnectPoint cp = new ConnectPoint(ingressDeviceId, ingressPortNumber);
            printPortFlowsLoad(cp, typedFlowLoad);
        }
    } else {
        // if (showSummary == true) //always is true
        // print show summary head line
        print("deviceId=%s, show SUMMARY flows", deviceURI);
        if (ingressPortNumber == null) {
            Map<ConnectPoint, SummaryFlowEntryWithLoad> summaryFlowLoadMap = flowStatsService.loadSummary(device);
            // print all ports flow load summary for a given device
            for (ConnectPoint cp : summaryFlowLoadMap.keySet()) {
                printPortSummaryLoad(cp, summaryFlowLoadMap.get(cp));
            }
        } else {
            SummaryFlowEntryWithLoad summaryFlowLoad = flowStatsService.loadSummary(device, ingressPortNumber);
            // print device/port flow load summary
            ConnectPoint cp = new ConnectPoint(ingressDeviceId, ingressPortNumber);
            printPortSummaryLoad(cp, summaryFlowLoad);
        }
    }
}
#end_block

#method_before
private String getPortNumber(String deviceString) {
    int slash = deviceString.indexOf('/');
    if (slash <= 0) {
        // return when no port number
        return "";
    }
    return deviceString.substring(slash + 1, deviceString.length());
}
#method_after
private String getPortNumber(String deviceString) {
    if (deviceString == null) {
        return "";
    }
    int slash = deviceString.indexOf('/');
    if (slash <= 0) {
        // return when no port number
        return "";
    }
    return deviceString.substring(slash + 1, deviceString.length());
}
#end_block

#method_before
private String getDeviceId(String deviceString) {
    int slash = deviceString.indexOf('/');
    if (slash <= 0) {
        // return only included device ID
        return deviceString;
    }
    return deviceString.substring(0, slash);
}
#method_after
private String getDeviceId(String deviceString) {
    if (deviceString == null) {
        return "";
    }
    int slash = deviceString.indexOf('/');
    if (slash <= 0) {
        // return only included device ID
        return deviceString;
    }
    return deviceString.substring(0, slash);
}
#end_block

#method_before
private void printPortFlowsLoad(ConnectPoint cp, List<TypedFlowEntryWithLoad> typedFlowLoad) {
    print("  deviceId/Port=%s/%s, %s flows", cp.elementId(), cp.port(), typedFlowLoad.size());
    for (TypedFlowEntryWithLoad tfel : typedFlowLoad) {
        TypedStoredFlowEntry tfe = tfel.typedStoredFlowEntry();
        print("    flowId=%s, state=%s, liveType=%s -> %s", Long.toHexString(tfe.id().value()), tfe.state(), tfe.flowLiveType(), tfel.load().isValid() ? tfel.load() : "Load{rate=0, NOT VALID}");
    }
}
#method_after
private void printPortFlowsLoad(ConnectPoint cp, List<TypedFlowEntryWithLoad> typedFlowLoad) {
    print("  deviceId/Port=%s/%s, %s flows", cp.elementId(), cp.port(), typedFlowLoad.size());
    for (TypedFlowEntryWithLoad tfel : typedFlowLoad) {
        TypedStoredFlowEntry tfe = tfel.typedStoredFlowEntry();
        print("    flowId=%s, state=%s, liveType=%s, life=%s -> %s", Long.toHexString(tfe.id().value()), tfe.state(), tfe.flowLiveType(), tfe.life(), tfel.load().isValid() ? tfel.load() : "Load{rate=0, NOT VALID}");
    }
}
#end_block

#method_before
private void printPortSummaryLoad(ConnectPoint cp, SummaryFlowEntryWithLoad summaryFlowLoad) {
    print("  deviceId/Port=%s/%s, Total=%s, Immediate=%s, Short=%s, Mid=%s, Long=%s, Unknown=%s", cp.elementId(), cp.port(), summaryFlowLoad.totalLoad().isValid() ? summaryFlowLoad.totalLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.immediatLoad().isValid() ? summaryFlowLoad.immediatLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.shortLoad().isValid() ? summaryFlowLoad.shortLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.midLoad().isValid() ? summaryFlowLoad.midLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.longLoad().isValid() ? summaryFlowLoad.longLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.unknownLoad().isValid() ? summaryFlowLoad.unknownLoad() : "Load{rate=0, NOT VALID}");
}
#method_after
private void printPortSummaryLoad(ConnectPoint cp, SummaryFlowEntryWithLoad summaryFlowLoad) {
    print("  deviceId/Port=%s/%s, Total=%s, Immediate=%s, Short=%s, Mid=%s, Long=%s, Unknown=%s", cp.elementId(), cp.port(), summaryFlowLoad.totalLoad().isValid() ? summaryFlowLoad.totalLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.immediateLoad().isValid() ? summaryFlowLoad.immediateLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.shortLoad().isValid() ? summaryFlowLoad.shortLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.midLoad().isValid() ? summaryFlowLoad.midLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.longLoad().isValid() ? summaryFlowLoad.longLoad() : "Load{rate=0, NOT VALID}", summaryFlowLoad.unknownLoad().isValid() ? summaryFlowLoad.unknownLoad() : "Load{rate=0, NOT VALID}");
}
#end_block

#method_before
private void initMemberVars(int pollInterval) {
    if (pollInterval < MIN_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MIN_CAL_AND_POLL_FREQUENCY;
    } else if (pollInterval >= MAX_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MAX_CAL_AND_POLL_FREQUENCY;
    } else {
        this.calAndPollInterval = pollInterval;
    }
    calAndPollInterval = CAL_AND_POLL_TIMES * calAndPollInterval;
    midPollInterval = MID_POLL_TIMES * calAndPollInterval;
    longPollInterval = LONG_POLL_TIMES * calAndPollInterval;
    entirePollInterval = ENTIRE_POLL_TIMES * calAndPollInterval;
    callCountCalAndShortFlowsTask = 0;
    callCountMidFlowsTask = 0;
    callCountLongFlowsTask = 0;
}
#method_after
private void initMemberVars(int pollInterval) {
    if (pollInterval < MIN_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MIN_CAL_AND_POLL_FREQUENCY;
    } else if (pollInterval >= MAX_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MAX_CAL_AND_POLL_FREQUENCY;
    } else {
        this.calAndPollInterval = pollInterval;
    }
    calAndPollInterval = CAL_AND_POLL_TIMES * calAndPollInterval;
    midPollInterval = MID_POLL_TIMES * calAndPollInterval;
    longPollInterval = LONG_POLL_TIMES * calAndPollInterval;
    entirePollInterval = ENTIRE_POLL_TIMES * calAndPollInterval;
    callCountCalAndShortFlowsTask = 0;
    callCountMidFlowsTask = 0;
    callCountLongFlowsTask = 0;
    flowMissingXid = NO_FLOW_MISSING_XID;
}
#end_block

#method_before
synchronized void adjustCalAndPollInterval(int pollInterval) {
    initMemberVars(pollInterval);
    if (calAndShortFlowsThread != null) {
        calAndShortFlowsThread.cancel(false);
    }
    if (midFlowsThread != null) {
        midFlowsThread.cancel(false);
    }
    if (longFlowsThread != null) {
        longFlowsThread.cancel(false);
    }
    calAndShortFlowsTask = new CalAndShortFlowsTask();
    calAndShortFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(calAndShortFlowsTask, 0, calAndPollInterval, TimeUnit.SECONDS);
    midFlowsTask = new MidFlowsTask();
    midFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(midFlowsTask, 0, midPollInterval, TimeUnit.SECONDS);
    longFlowsTask = new LongFlowsTask();
    longFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(longFlowsTask, 0, longPollInterval, TimeUnit.SECONDS);
    log.info("calAndPollInterval=" + calAndPollInterval + "is adjusted");
}
#method_after
synchronized void adjustCalAndPollInterval(int pollInterval) {
    initMemberVars(pollInterval);
    if (calAndShortFlowsThread != null) {
        calAndShortFlowsThread.cancel(false);
    }
    if (midFlowsThread != null) {
        midFlowsThread.cancel(false);
    }
    if (longFlowsThread != null) {
        longFlowsThread.cancel(false);
    }
    calAndShortFlowsTask = new CalAndShortFlowsTask();
    calAndShortFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(calAndShortFlowsTask, 0, calAndPollInterval, TimeUnit.SECONDS);
    midFlowsTask = new MidFlowsTask();
    midFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(midFlowsTask, 0, midPollInterval, TimeUnit.SECONDS);
    longFlowsTask = new LongFlowsTask();
    longFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(longFlowsTask, 0, longPollInterval, TimeUnit.SECONDS);
    log.debug("calAndPollInterval=" + calAndPollInterval + "is adjusted");
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("CalAndShortFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        if (isFirstTimeStart) {
            // isFirstTimeStart, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats at first time start for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = 0;
            isFirstTimeStart = false;
        } else if (callCountCalAndShortFlowsTask == ENTIRE_POLL_TIMES) {
            // entrire_poll_times, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = 0;
        // TODO: check flows deleted in switch, but exist in controller flow table, then remove them
        // 
        } else {
            calAndShortFlowsTaskInternal();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("CalAndShortFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        if (isFirstTimeStart) {
            // isFirstTimeStart, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats at first time start for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
            isFirstTimeStart = false;
        } else if (callCountCalAndShortFlowsTask == ENTIRE_POLL_TIMES) {
            // entire_poll_times, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = CAL_AND_POLL_TIMES;
        // TODO: check flows deleted in switch, but exist in controller flow table, then remove them
        // 
        } else {
            calAndShortFlowsTaskInternal();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
        }
    }
}
#end_block

#method_before
private void ofFlowStatsRequestAllSend() {
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestAllSend() {
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
    synchronized (this) {
        // set the request xid to check the reply in OpenFlowRuleProvider
        // After processing the reply of this request message,
        // this must be set to NO_FLOW_MISSING_XID(-1) by provider
        setFlowMissingXid(request.getXid());
        log.debug("ofFlowStatsRequestAllSend,Request={},for {}", request.toString(), sw.getStringId());
        sw.sendMsg(request);
    }
}
#end_block

#method_before
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty()).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(// .setMatch(sw.factory().matchWildcardAll())
    match).setTableId(// .setTableId(TableId.ALL)
    tableId).setOutPort(// .setOutPort(OFPort.NO_MASK)
    ofPort).build();
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty()).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(match).setTableId(tableId).setOutPort(ofPort).build();
    synchronized (this) {
        if (getFlowMissingXid() != NO_FLOW_MISSING_XID) {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll does not be processed yet," + " set no flow missing xid anyway, for {}", sw.getStringId());
            setFlowMissingXid(NO_FLOW_MISSING_XID);
        }
        sw.sendMsg(request);
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("MidFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountMidFlowsTask == ENTIRE_POLL_TIMES) {
            callCountMidFlowsTask = 0;
        } else {
            midFlowsTaskInternal();
            callCountMidFlowsTask += MID_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("MidFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountMidFlowsTask == ENTIRE_POLL_TIMES) {
            callCountMidFlowsTask = MID_POLL_TIMES;
        } else {
            midFlowsTaskInternal();
            callCountMidFlowsTask += MID_POLL_TIMES;
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("LongFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountLongFlowsTask == ENTIRE_POLL_TIMES) {
            callCountLongFlowsTask = 0;
        } else {
            longFlowsTaskInternal();
            callCountLongFlowsTask += LONG_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("LongFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountLongFlowsTask == ENTIRE_POLL_TIMES) {
            callCountLongFlowsTask = LONG_POLL_TIMES;
        } else {
            longFlowsTaskInternal();
            callCountLongFlowsTask += LONG_POLL_TIMES;
        }
    }
}
#end_block

#method_before
public boolean addWithFlowRule(FlowRule... flowRules) {
    for (FlowRule fr : flowRules) {
        // First remove old entry unconditionally, if exist
        deviceFlowTable.remove(fr);
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fr, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
    return true;
}
#method_after
public synchronized void addWithFlowRule(FlowRule... flowRules) {
    for (FlowRule fr : flowRules) {
        // First remove old entry unconditionally, if exist
        deviceFlowTable.remove(fr);
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fr, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
public boolean addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
    return true;
}
#method_after
public synchronized void addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        // check if this new rule is an update to an existing entry
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            // duplicated flow entry is collected!, just skip
            if (fe.bytes() == stored.bytes() && fe.packets() == stored.packets() && fe.life() == stored.life()) {
                log.debug("addOrUpdateFlows:, FlowId=" + Long.toHexString(fe.id().value()) + ",is DUPLICATED stats collection, just skip." + " AdaptiveStats collection thread for {}", sw.getStringId());
                stored.setLastSeen();
                continue;
            } else if (fe.life() < stored.life()) {
                // Invalid updates the stats values, i.e., bytes, packets, durations ...
                log.debug("addOrUpdateFlows():" + " Invalid Flow Update! The new life is SMALLER than the previous one, jus skip." + " new flowId=" + Long.toHexString(fe.id().value()) + ", old flowId=" + Long.toHexString(stored.id().value()) + ", new bytes=" + fe.bytes() + ", old bytes=" + stored.bytes() + ", new life=" + fe.life() + ", old life=" + stored.life() + ", new lastSeen=" + fe.lastSeen() + ", old lastSeen=" + stored.lastSeen());
                // go next
                stored.setLastSeen();
                continue;
            }
            // update now
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
public boolean removeFlows(FlowRule... flowRules) {
    for (FlowRule rule : flowRules) {
        deviceFlowTable.remove(rule);
    }
    return true;
}
#method_after
public synchronized void removeFlows(FlowRule... flowRules) {
    for (FlowRule rule : flowRules) {
        deviceFlowTable.remove(rule);
    }
}
#end_block

#method_before
public boolean flowRemoved(FlowRule... flowRules) {
    removeFlows(flowRules);
    return true;
}
#method_after
// same as removeFlows() function
public void flowRemoved(FlowRule... flowRules) {
    removeFlows(flowRules);
}
#end_block

#method_before
public boolean pushFlowMetrics(List<FlowEntry> flowEntries) {
    flowEntries.forEach(fe -> addOrUpdateFlows(fe));
    return true;
}
#method_after
// same as addOrUpdateFlows() function
public void pushFlowMetrics(List<FlowEntry> flowEntries) {
    flowEntries.forEach(fe -> {
        addOrUpdateFlows(fe);
    });
}
#end_block

#method_before
public TypedStoredFlowEntry getFlowEntry(FlowRule rule) {
    return getFlowEntryInternal(rule);
}
#method_after
public TypedStoredFlowEntry getFlowEntry(FlowRule rule) {
    checkNotNull(rule);
    return getFlowEntryInternal(rule);
}
#end_block

#method_before
public Set<StoredFlowEntry> getShortFlows() {
    // Sets.newHashSet(shortFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(shortFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getShortFlows() {
    // Sets.newHashSet(shortFlows);
    return ImmutableSet.copyOf(shortFlows);
}
#end_block

#method_before
public Set<StoredFlowEntry> getMidFlows() {
    // Sets.newHashSet(midFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(midFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getMidFlows() {
    // Sets.newHashSet(midFlows);
    return ImmutableSet.copyOf(midFlows);
}
#end_block

#method_before
public Set<StoredFlowEntry> getLongFlows() {
    // Sets.newHashSet(longFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(longFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getLongFlows() {
    // Sets.newHashSet(longFlows);
    return ImmutableSet.copyOf(longFlows);
}
#end_block

#method_before
public void add(TypedStoredFlowEntry rule) {
    // rule have to be new new DefaultTypedFlowEntry
    getFlowEntriesInternal(rule.id()).add(rule);
    addCount++;
// log.debug("add, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
public synchronized void add(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    // rule have to be new DefaultTypedFlowEntry
    boolean result = getFlowEntriesInternal(rule.id()).add(rule);
    if (result) {
        addCount++;
    }
}
#end_block

#method_before
public void calAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    calAndSetFlowLiveTypeInternal(rule);
}
#method_after
public void calAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    calAndSetFlowLiveTypeInternal(rule);
}
#end_block

#method_before
public void addWithCalAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    // rule have to be new DefaultTypedFlowEntry
    getFlowEntriesInternal(rule.id()).add(rule);
    calAndSetFlowLiveTypeInternal(rule);
    addWithSetFlowLiveTypeCount++;
// log.debug("addWithSetFlowLiveType, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
public synchronized void addWithCalAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    // rule have to be new DefaultTypedFlowEntry
    boolean result = getFlowEntriesInternal(rule.id()).add(rule);
    if (result) {
        calAndSetFlowLiveTypeInternal(rule);
        addWithSetFlowLiveTypeCount++;
    } else {
        log.debug("addWithCalAndSetFlowLiveType, FlowId=" + Long.toHexString(rule.id().value()) + " ADD Failed, cause it may already exists in table !!!," + " AdaptiveStats collection thread for {}", sw.getStringId());
    }
}
#end_block

#method_before
private void calAndSetFlowLiveTypeInternal(TypedStoredFlowEntry rule) {
    long life = rule.life();
    FlowLiveType prevFlowLiveType = rule.flowLiveType();
    if (life >= longPollInterval) {
        rule.setFlowLiveType(FlowLiveType.LONG_FLOW);
        longFlows.add(rule);
    } else if (life >= midPollInterval) {
        rule.setFlowLiveType(FlowLiveType.MID_FLOW);
        midFlows.add(rule);
    } else if (life >= calAndPollInterval) {
        rule.setFlowLiveType(FlowLiveType.SHORT_FLOW);
        shortFlows.add(rule);
    } else if (life >= 0) {
        rule.setFlowLiveType(FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        rule.setFlowLiveType(FlowLiveType.UNKNOWN_FLOW);
    }
    if (rule.flowLiveType() != prevFlowLiveType) {
        switch(prevFlowLiveType) {
            // delete it from previous flow table
            case SHORT_FLOW:
                shortFlows.remove(rule);
                break;
            case MID_FLOW:
                midFlows.remove(rule);
                break;
            case LONG_FLOW:
                longFlows.remove(rule);
                break;
            default:
                break;
        }
    }
// log.debug("setFlowLiveTypeInternal, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + ", life=" + life
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
// In real, calculates and set the flow live type at the first time,
private void calAndSetFlowLiveTypeInternal(TypedStoredFlowEntry rule) {
    long life = rule.life();
    FlowLiveType prevFlowLiveType = rule.flowLiveType();
    if (life >= longPollInterval) {
        rule.setFlowLiveType(FlowLiveType.LONG_FLOW);
        longFlows.add(rule);
    } else if (life >= midPollInterval) {
        rule.setFlowLiveType(FlowLiveType.MID_FLOW);
        midFlows.add(rule);
    } else if (life >= calAndPollInterval) {
        rule.setFlowLiveType(FlowLiveType.SHORT_FLOW);
        shortFlows.add(rule);
    } else if (life >= 0) {
        rule.setFlowLiveType(FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        rule.setFlowLiveType(FlowLiveType.UNKNOWN_FLOW);
    }
    if (rule.flowLiveType() != prevFlowLiveType) {
        switch(prevFlowLiveType) {
            // delete it from previous flow table
            case SHORT_FLOW:
                shortFlows.remove(rule);
                break;
            case MID_FLOW:
                midFlows.remove(rule);
                break;
            case LONG_FLOW:
                longFlows.remove(rule);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void checkAndMoveLiveFlowAll() {
    Set<TypedStoredFlowEntry> typedFlowEntries = getFlowEntriesInternal();
    long calCurTime = System.currentTimeMillis();
    typedFlowEntries.forEach(fe -> {
        if (!checkAndMoveLiveFlow(fe, calCurTime)) {
            remove(fe);
        }
    });
    log.debug("checkAndMoveLiveFlowAll, Total Flow_Count=" + getFlowCount() + ", add - remove_Count=" + (addCount + addWithSetFlowLiveTypeCount - removeCount) + ", IMMEDIATE_FLOW_Count=" + (getFlowCount() - shortFlows.size() - midFlows.size() - longFlows.size()) + ", SHORT_FLOW_Count=" + shortFlows.size() + ", MID_FLOW_Count=" + midFlows.size() + ", LONG_FLOW_Count=" + longFlows.size() + ", add_Count=" + addCount + ",addWithSetFlowLiveType_Count=" + addWithSetFlowLiveTypeCount + ", remove_Count=" + removeCount + " AdaptiveStats collection thread for {}", sw.getStringId());
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#method_after
public void checkAndMoveLiveFlowAll() {
    Set<TypedStoredFlowEntry> typedFlowEntries = getFlowEntriesInternal();
    long calCurTime = System.currentTimeMillis();
    typedFlowEntries.forEach(fe -> {
        if (!checkAndMoveLiveFlowInternal(fe, calCurTime)) {
            remove(fe);
        }
    });
    // print table counts for debug
    if (log.isDebugEnabled()) {
        synchronized (this) {
            long totalFlowCount = getFlowCount();
            long shortFlowCount = shortFlows.size();
            long midFlowCount = midFlows.size();
            long longFlowCount = longFlows.size();
            long immediateFlowCount = totalFlowCount - shortFlowCount - midFlowCount - longFlowCount;
            long calTotalCount = addCount + addWithSetFlowLiveTypeCount - removeCount;
            log.debug("--------------------------------------------------------------------------- for {}", sw.getStringId());
            log.debug("checkAndMoveLiveFlowAll, Total Flow_Count=" + totalFlowCount + ", add - remove_Count=" + calTotalCount + ", IMMEDIATE_FLOW_Count=" + immediateFlowCount + ", SHORT_FLOW_Count=" + shortFlowCount + ", MID_FLOW_Count=" + midFlowCount + ", LONG_FLOW_Count=" + longFlowCount + ", add_Count=" + addCount + ", addWithSetFlowLiveType_Count=" + addWithSetFlowLiveTypeCount + ", remove_Count=" + removeCount + " AdaptiveStats collection thread for {}", sw.getStringId());
            log.debug("--------------------------------------------------------------------------- for {}", sw.getStringId());
            if (totalFlowCount != calTotalCount) {
                log.error("checkAndMoveLiveFlowAll, Real total flow count and " + "calculated total flow count do NOT match, something is wrong internally " + "or check counter value bound is over!");
            }
            if (immediateFlowCount < 0) {
                log.error("checkAndMoveLiveFlowAll, IMMEDIATE_FLOW count is negative, " + "something is wrong internally " + "or check counter value bound is over!");
            }
        }
    }
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#end_block

#method_before
public boolean remove(FlowRule rule) {
    TypedStoredFlowEntry removeStore = getFlowEntryInternal(rule);
    if (removeStore != null) {
        // log.debug("remove, FlowId=" + removeStore.id() + ", liveType=" + removeStore.flowLiveType()
        // + " AdaptiveStats collection thread for {}", sw.getStringId());
        removeLiveFlowsInternal((TypedStoredFlowEntry) removeStore);
        boolean result = getFlowEntriesInternal(rule.id()).remove(removeStore);
        removeCount++;
        return result;
    }
    return false;
}
#method_after
public synchronized void remove(FlowRule rule) {
    checkNotNull(rule);
    TypedStoredFlowEntry removeStore = getFlowEntryInternal(rule);
    if (removeStore != null) {
        removeLiveFlowsInternal((TypedStoredFlowEntry) removeStore);
        boolean result = getFlowEntriesInternal(rule.id()).remove(removeStore);
        if (result) {
            removeCount++;
        }
    }
}
#end_block

#method_before
private boolean removeLiveFlowsInternal(TypedStoredFlowEntry fe) {
    switch(fe.flowLiveType()) {
        case IMMEDIATE_FLOW:
            // do nothing
            break;
        case SHORT_FLOW:
            shortFlows.remove(fe);
            break;
        case MID_FLOW:
            midFlows.remove(fe);
            break;
        case LONG_FLOW:
            longFlows.remove(fe);
            break;
        default:
            // error in Flow Live Type
            return false;
    }
    return true;
}
#method_after
private void removeLiveFlowsInternal(TypedStoredFlowEntry fe) {
    switch(fe.flowLiveType()) {
        case IMMEDIATE_FLOW:
            // do nothing
            break;
        case SHORT_FLOW:
            shortFlows.remove(fe);
            break;
        case MID_FLOW:
            midFlows.remove(fe);
            break;
        case LONG_FLOW:
            longFlows.remove(fe);
            break;
        default:
            // error in Flow Live Type
            log.error("removeLiveFlowsInternal, Unknown Live Type error!");
            break;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/statistic", "message-handlers"));
    clusterCommunicator.addSubscriber(GET_CURRENT, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            ConnectPoint cp = SERIALIZER.decode(message.payload());
            message.respond(SERIALIZER.encode(getCurrentStatisticInternal(cp)));
        }
    }, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(GET_PREVIOUS, new ClusterMessageHandler() {

        @Override
        public void handle(ClusterMessage message) {
            ConnectPoint cp = SERIALIZER.decode(message.payload());
            message.respond(SERIALIZER.encode(getPreviousStatisticInternal(cp)));
        }
    }, messageHandlingExecutor);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    local = clusterService.getLocalNode().id();
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/statistic", "message-handlers"));
    clusterCommunicator.addSubscriber(GET_CURRENT, SERIALIZER::decode, this::getCurrentStatisticInternal, SERIALIZER::encode, messageHandlingExecutor);
    clusterCommunicator.addSubscriber(GET_CURRENT, SERIALIZER::decode, this::getPreviousStatisticInternal, SERIALIZER::encode, messageHandlingExecutor);
    log.info("Started");
}
#end_block

#method_before
@Override
public synchronized void removeFlowStatistic(FlowRule rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    Set<FlowEntry> values = current.get(cp);
    if (values != null) {
        values.remove(rule);
    }
    values = previous.get(cp);
    if (values != null) {
        values.remove(rule);
    }
}
#method_after
@Override
public synchronized void removeFlowStatistic(FlowRule rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    // remove this rule if present from current map
    current.computeIfPresent(cp, (c, e) -> {
        e.remove(rule);
        return e;
    });
    // remove this on if present from previous map
    previous.computeIfPresent(cp, (c, e) -> {
        e.remove(rule);
        return e;
    });
}
#end_block

#method_before
@Override
public synchronized void addFlowStatistic(FlowEntry rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    Set<FlowEntry> values = current.get(cp);
    if (values == null) {
        values = new HashSet<>();
        current.put(cp, values);
    }
    values.add(rule);
    // remove previous one
    values = previous.get(cp);
    if (values != null) {
        values.remove(rule);
    }
}
#method_after
@Override
public synchronized void addFlowStatistic(FlowEntry rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    // create one if absent and add this rule
    current.putIfAbsent(cp, new HashSet<>());
    current.computeIfPresent(cp, (c, e) -> {
        e.add(rule);
        return e;
    });
    // remove previous one if present
    previous.computeIfPresent(cp, (c, e) -> {
        e.remove(rule);
        return e;
    });
}
#end_block

#method_before
public synchronized void updateFlowStatistic(FlowEntry rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    Set<FlowEntry> curr = current.get(cp);
    if (curr == null) {
        addFlowStatistic(rule);
    } else {
        FlowEntry f = curr.stream().filter(c -> rule.equals(c)).findAny().orElse(new DefaultFlowEntry((FlowRule) rule));
        if (rule.bytes() < f.bytes()) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " Invalid Flow Update! Will be removed!!" + " curr flowId=" + Long.toHexString(rule.id().value()) + ", prev flowId=" + Long.toHexString(f.id().value()) + ", curr bytes=" + rule.bytes() + ", prev bytes=" + f.bytes() + ", curr life=" + rule.life() + ", prev life=" + f.life() + ", curr lastSeen=" + rule.lastSeen() + ", prev lastSeen=" + f.lastSeen());
            // something is wrong! invalid flow entry, so delete it
            removeFlowStatistic(rule);
            return;
        }
        Set<FlowEntry> prev = previous.get(cp);
        if (prev == null) {
            prev = new HashSet<>();
            previous.put(cp, prev);
        }
        prev.add(f);
        curr.add(rule);
    }
}
#method_after
public synchronized void updateFlowStatistic(FlowEntry rule) {
    ConnectPoint cp = buildConnectPoint(rule);
    if (cp == null) {
        return;
    }
    Set<FlowEntry> curr = current.get(cp);
    if (curr == null) {
        addFlowStatistic(rule);
    } else {
        FlowEntry f = curr.stream().filter(c -> rule.equals(c)).findAny().orElse(null);
        if (rule.bytes() < f.bytes()) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " Invalid Flow Update! Will be removed!!" + " curr flowId=" + Long.toHexString(rule.id().value()) + ", prev flowId=" + Long.toHexString(f.id().value()) + ", curr bytes=" + rule.bytes() + ", prev bytes=" + f.bytes() + ", curr life=" + rule.life() + ", prev life=" + f.life() + ", curr lastSeen=" + rule.lastSeen() + ", prev lastSeen=" + f.lastSeen());
            // something is wrong! invalid flow entry, so delete it
            removeFlowStatistic(rule);
            return;
        }
        Set<FlowEntry> prev = previous.get(cp);
        if (prev == null) {
            prev = new HashSet<>();
            previous.put(cp, prev);
        }
        // previous one is exist
        if (f != null) {
            // remove old one and add new one
            prev.remove(rule);
            if (!prev.add(f)) {
                log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " flowId={}, add failed into previous.", Long.toHexString(rule.id().value()));
            }
        }
        // remove old one and add new one
        curr.remove(rule);
        if (!curr.add(rule)) {
            log.debug("DistributedFlowStatisticStore:updateFlowStatistic():" + " flowId={}, add failed into current.", Long.toHexString(rule.id().value()));
        }
    }
}
#end_block

#method_before
@Override
public Set<FlowEntry> getCurrentFlowStatistic(ConnectPoint connectPoint) {
    final DeviceId deviceId = connectPoint.deviceId();
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
    if (!replicaInfo.master().isPresent()) {
        log.warn("No master for {}", deviceId);
        return Collections.emptySet();
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return getCurrentStatisticInternal(connectPoint);
    } else {
        return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(connectPoint, GET_CURRENT, SERIALIZER::encode, SERIALIZER::decode, replicaInfo.master().get()), STATISTIC_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, Collections.emptySet());
    }
}
#method_after
@Override
public Set<FlowEntry> getCurrentFlowStatistic(ConnectPoint connectPoint) {
    final DeviceId deviceId = connectPoint.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (master == null) {
        log.warn("No master for {}", deviceId);
        return Collections.emptySet();
    }
    if (Objects.equal(local, master)) {
        return getCurrentStatisticInternal(connectPoint);
    } else {
        return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(connectPoint, GET_CURRENT, SERIALIZER::encode, SERIALIZER::decode, master), STATISTIC_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, Collections.emptySet());
    }
}
#end_block

#method_before
@Override
public Set<FlowEntry> getPreviousFlowStatistic(ConnectPoint connectPoint) {
    final DeviceId deviceId = connectPoint.deviceId();
    ReplicaInfo replicaInfo = replicaInfoManager.getReplicaInfoFor(deviceId);
    if (!replicaInfo.master().isPresent()) {
        log.warn("No master for {}", deviceId);
        return Collections.emptySet();
    }
    if (replicaInfo.master().get().equals(clusterService.getLocalNode().id())) {
        return getPreviousStatisticInternal(connectPoint);
    } else {
        return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(connectPoint, GET_PREVIOUS, SERIALIZER::encode, SERIALIZER::decode, replicaInfo.master().get()), STATISTIC_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, Collections.emptySet());
    }
}
#method_after
@Override
public Set<FlowEntry> getPreviousFlowStatistic(ConnectPoint connectPoint) {
    final DeviceId deviceId = connectPoint.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (master == null) {
        log.warn("No master for {}", deviceId);
        return Collections.emptySet();
    }
    if (Objects.equal(local, master)) {
        return getPreviousStatisticInternal(connectPoint);
    } else {
        return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(connectPoint, GET_PREVIOUS, SERIALIZER::encode, SERIALIZER::decode, master), STATISTIC_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, Collections.emptySet());
    }
}
#end_block

#method_before
public static long typedPollInterval(TypedStoredFlowEntry tfe) {
    if (tfe == null) {
        // return default
        return CAL_AND_POLL_INTERVAL;
    }
    switch(tfe.flowLiveType()) {
        case LONG_FLOW:
            return LONG_POLL_INTERVAL;
        case MID_FLOW:
            return MID_POLL_INTERVAL;
        case SHORT_FLOW:
        case IMMEDIATE_FLOW:
        default:
            return CAL_AND_POLL_INTERVAL;
    }
}
#method_after
public static long typedPollInterval(TypedStoredFlowEntry tfe) {
    checkNotNull(tfe, "TypedStoredFlowEntry cannot be null");
    switch(tfe.flowLiveType()) {
        case LONG_FLOW:
            return LONG_POLL_INTERVAL;
        case MID_FLOW:
            return MID_POLL_INTERVAL;
        case SHORT_FLOW:
        case IMMEDIATE_FLOW:
        default:
            return CAL_AND_POLL_INTERVAL;
    }
}
#end_block

#method_before
public static TypedStoredFlowEntry newTypedStoredFlowEntry(FlowEntry fe) {
    if (fe == null) {
        return null;
    }
    long life = fe.life();
    if (life >= CAL_AND_POLL_INTERVAL) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.LONG_FLOW);
    } else if (life >= MID_POLL_INTERVAL) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.MID_FLOW);
    } else if (life >= LONG_POLL_INTERVAL) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.SHORT_FLOW);
    } else if (life >= 0) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.SHORT_FLOW);
    } else {
        // life < 0
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.UNKNOWN_FLOW);
    }
}
#method_after
public static TypedStoredFlowEntry newTypedStoredFlowEntry(FlowEntry fe) {
    if (fe == null) {
        return null;
    }
    long life = fe.life();
    if (life >= LONG_POLL_INTERVAL) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.LONG_FLOW);
    } else if (life >= MID_POLL_INTERVAL) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.MID_FLOW);
    } else if (life >= CAL_AND_POLL_INTERVAL) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.SHORT_FLOW);
    } else if (life >= 0) {
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        return new DefaultTypedFlowEntry(fe, TypedStoredFlowEntry.FlowLiveType.UNKNOWN_FLOW);
    }
}
#end_block

#method_before
@Override
public Map<ConnectPoint, SummaryFlowEntryWithLoad> loadSummary(Device device) {
    checkPermission(Permission.STATISTIC_READ);
    Map<ConnectPoint, SummaryFlowEntryWithLoad> summaryLoad = new TreeMap<>(Comparators.CONNECT_POINT_COMPARATOR);
    if (device == null) {
        return summaryLoad;
    }
    List<Port> ports = new ArrayList<>(deviceService.getPorts(device.id()));
    for (Port port : ports) {
        ConnectPoint cp = new ConnectPoint(device.id(), port.number());
        SummaryFlowEntryWithLoad sfe = loadSummaryPortInternal(cp);
        summaryLoad.put(cp, sfe);
    }
    return summaryLoad;
}
#method_after
@Override
public Map<ConnectPoint, SummaryFlowEntryWithLoad> loadSummary(Device device) {
    checkPermission(STATISTIC_READ);
    Map<ConnectPoint, SummaryFlowEntryWithLoad> summaryLoad = new TreeMap<>(Comparators.CONNECT_POINT_COMPARATOR);
    if (device == null) {
        return summaryLoad;
    }
    List<Port> ports = new ArrayList<>(deviceService.getPorts(device.id()));
    for (Port port : ports) {
        ConnectPoint cp = new ConnectPoint(device.id(), port.number());
        SummaryFlowEntryWithLoad sfe = loadSummaryPortInternal(cp);
        summaryLoad.put(cp, sfe);
    }
    return summaryLoad;
}
#end_block

#method_before
@Override
public SummaryFlowEntryWithLoad loadSummary(Device device, PortNumber pNumber) {
    checkPermission(Permission.STATISTIC_READ);
    ConnectPoint cp = new ConnectPoint(device.id(), pNumber);
    return loadSummaryPortInternal(cp);
}
#method_after
@Override
public SummaryFlowEntryWithLoad loadSummary(Device device, PortNumber pNumber) {
    checkPermission(STATISTIC_READ);
    ConnectPoint cp = new ConnectPoint(device.id(), pNumber);
    return loadSummaryPortInternal(cp);
}
#end_block

#method_before
@Override
public Map<ConnectPoint, List<TypedFlowEntryWithLoad>> loadAllByType(Device device, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType) {
    checkPermission(Permission.STATISTIC_READ);
    Map<ConnectPoint, List<TypedFlowEntryWithLoad>> allLoad = new TreeMap<>(Comparators.CONNECT_POINT_COMPARATOR);
    if (device == null) {
        return allLoad;
    }
    List<Port> ports = new ArrayList<>(deviceService.getPorts(device.id()));
    for (Port port : ports) {
        ConnectPoint cp = new ConnectPoint(device.id(), port.number());
        List<TypedFlowEntryWithLoad> tfel = loadAllPortInternal(cp, liveType, instType);
        allLoad.put(cp, tfel);
    }
    return allLoad;
}
#method_after
@Override
public Map<ConnectPoint, List<TypedFlowEntryWithLoad>> loadAllByType(Device device, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType) {
    checkPermission(STATISTIC_READ);
    Map<ConnectPoint, List<TypedFlowEntryWithLoad>> allLoad = new TreeMap<>(Comparators.CONNECT_POINT_COMPARATOR);
    if (device == null) {
        return allLoad;
    }
    List<Port> ports = new ArrayList<>(deviceService.getPorts(device.id()));
    for (Port port : ports) {
        ConnectPoint cp = new ConnectPoint(device.id(), port.number());
        List<TypedFlowEntryWithLoad> tfel = loadAllPortInternal(cp, liveType, instType);
        allLoad.put(cp, tfel);
    }
    return allLoad;
}
#end_block

#method_before
@Override
public List<TypedFlowEntryWithLoad> loadAllByType(Device device, PortNumber pNumber, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType) {
    checkPermission(Permission.STATISTIC_READ);
    ConnectPoint cp = new ConnectPoint(device.id(), pNumber);
    return loadAllPortInternal(cp, liveType, instType);
}
#method_after
@Override
public List<TypedFlowEntryWithLoad> loadAllByType(Device device, PortNumber pNumber, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType) {
    checkPermission(STATISTIC_READ);
    ConnectPoint cp = new ConnectPoint(device.id(), pNumber);
    return loadAllPortInternal(cp, liveType, instType);
}
#end_block

#method_before
@Override
public Map<ConnectPoint, List<TypedFlowEntryWithLoad>> loadTopnByType(Device device, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType, int topn) {
    checkPermission(Permission.STATISTIC_READ);
    Map<ConnectPoint, List<TypedFlowEntryWithLoad>> allLoad = new TreeMap<>(Comparators.CONNECT_POINT_COMPARATOR);
    if (device == null) {
        return allLoad;
    }
    List<Port> ports = new ArrayList<>(deviceService.getPorts(device.id()));
    for (Port port : ports) {
        ConnectPoint cp = new ConnectPoint(device.id(), port.number());
        List<TypedFlowEntryWithLoad> tfel = loadTopnPortInternal(cp, liveType, instType, topn);
        allLoad.put(cp, tfel);
    }
    return allLoad;
}
#method_after
@Override
public Map<ConnectPoint, List<TypedFlowEntryWithLoad>> loadTopnByType(Device device, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType, int topn) {
    checkPermission(STATISTIC_READ);
    Map<ConnectPoint, List<TypedFlowEntryWithLoad>> allLoad = new TreeMap<>(Comparators.CONNECT_POINT_COMPARATOR);
    if (device == null) {
        return allLoad;
    }
    List<Port> ports = new ArrayList<>(deviceService.getPorts(device.id()));
    for (Port port : ports) {
        ConnectPoint cp = new ConnectPoint(device.id(), port.number());
        List<TypedFlowEntryWithLoad> tfel = loadTopnPortInternal(cp, liveType, instType, topn);
        allLoad.put(cp, tfel);
    }
    return allLoad;
}
#end_block

#method_before
@Override
public List<TypedFlowEntryWithLoad> loadTopnByType(Device device, PortNumber pNumber, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType, int topn) {
    checkPermission(Permission.STATISTIC_READ);
    ConnectPoint cp = new ConnectPoint(device.id(), pNumber);
    return loadTopnPortInternal(cp, liveType, instType, topn);
}
#method_after
@Override
public List<TypedFlowEntryWithLoad> loadTopnByType(Device device, PortNumber pNumber, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType, int topn) {
    checkPermission(STATISTIC_READ);
    ConnectPoint cp = new ConnectPoint(device.id(), pNumber);
    return loadTopnPortInternal(cp, liveType, instType, topn);
}
#end_block

#method_before
private SummaryFlowEntryWithLoad loadSummaryPortInternal(ConnectPoint cp) {
    checkPermission(Permission.STATISTIC_READ);
    Set<FlowEntry> currentStats;
    Set<FlowEntry> previousStats;
    TypedStatistics typedStatistics;
    synchronized (flowStatisticStore) {
        currentStats = flowStatisticStore.getCurrentFlowStatistic(cp);
        if (currentStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        previousStats = flowStatisticStore.getPreviousFlowStatistic(cp);
        if (previousStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        // copy to local flow entry se
        typedStatistics = new TypedStatistics(currentStats, previousStats);
        checkLoadValidity(currentStats, previousStats);
    }
    // current and previous set is not empty!
    Set<FlowEntry> currentSet = typedStatistics.current();
    Set<FlowEntry> previousSet = typedStatistics.previous();
    Load totalLoad = new DefaultLoad(aggregateBytesSet(currentSet), aggregateBytesSet(previousSet), TypedFlowEntryWithLoad.avgPollInterval());
    Map<FlowRule, TypedStoredFlowEntry> currentMap;
    Map<FlowRule, TypedStoredFlowEntry> previousMap;
    currentMap = typedStatistics.currentImmediate();
    previousMap = typedStatistics.previousImmediate();
    Load immediateLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.shortPollInterval());
    currentMap = typedStatistics.currentShort();
    previousMap = typedStatistics.previousShort();
    Load shortLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.shortPollInterval());
    currentMap = typedStatistics.currentMid();
    previousMap = typedStatistics.previousMid();
    Load midLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.midPollInterval());
    currentMap = typedStatistics.currentLong();
    previousMap = typedStatistics.previousLong();
    Load longLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.longPollInterval());
    currentMap = typedStatistics.currentUnknown();
    previousMap = typedStatistics.previousUnknown();
    Load unknownLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.avgPollInterval());
    return new SummaryFlowEntryWithLoad(cp, totalLoad, immediateLoad, shortLoad, midLoad, longLoad, unknownLoad);
}
#method_after
private SummaryFlowEntryWithLoad loadSummaryPortInternal(ConnectPoint cp) {
    checkPermission(STATISTIC_READ);
    Set<FlowEntry> currentStats;
    Set<FlowEntry> previousStats;
    TypedStatistics typedStatistics;
    synchronized (flowStatisticStore) {
        currentStats = flowStatisticStore.getCurrentFlowStatistic(cp);
        if (currentStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        previousStats = flowStatisticStore.getPreviousFlowStatistic(cp);
        if (previousStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        // copy to local flow entry
        typedStatistics = new TypedStatistics(currentStats, previousStats);
        // Check for validity of this stats data
        checkLoadValidity(currentStats, previousStats);
    }
    // current and previous set is not empty!
    Set<FlowEntry> currentSet = typedStatistics.current();
    Set<FlowEntry> previousSet = typedStatistics.previous();
    Load totalLoad = new DefaultLoad(aggregateBytesSet(currentSet), aggregateBytesSet(previousSet), TypedFlowEntryWithLoad.avgPollInterval());
    Map<FlowRule, TypedStoredFlowEntry> currentMap;
    Map<FlowRule, TypedStoredFlowEntry> previousMap;
    currentMap = typedStatistics.currentImmediate();
    previousMap = typedStatistics.previousImmediate();
    Load immediateLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.shortPollInterval());
    currentMap = typedStatistics.currentShort();
    previousMap = typedStatistics.previousShort();
    Load shortLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.shortPollInterval());
    currentMap = typedStatistics.currentMid();
    previousMap = typedStatistics.previousMid();
    Load midLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.midPollInterval());
    currentMap = typedStatistics.currentLong();
    previousMap = typedStatistics.previousLong();
    Load longLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.longPollInterval());
    currentMap = typedStatistics.currentUnknown();
    previousMap = typedStatistics.previousUnknown();
    Load unknownLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), TypedFlowEntryWithLoad.avgPollInterval());
    return new SummaryFlowEntryWithLoad(cp, totalLoad, immediateLoad, shortLoad, midLoad, longLoad, unknownLoad);
}
#end_block

#method_before
private List<TypedFlowEntryWithLoad> loadAllPortInternal(ConnectPoint cp, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType) {
    checkPermission(Permission.STATISTIC_READ);
    List<TypedFlowEntryWithLoad> retTFEL = new ArrayList<>();
    Set<FlowEntry> currentStats;
    Set<FlowEntry> previousStats;
    TypedStatistics typedStatistics;
    synchronized (flowStatisticStore) {
        currentStats = flowStatisticStore.getCurrentFlowStatistic(cp);
        if (currentStats == null) {
            return retTFEL;
        }
        previousStats = flowStatisticStore.getPreviousFlowStatistic(cp);
        if (previousStats == null) {
            return retTFEL;
        }
        // copy to local flow entry set
        typedStatistics = new TypedStatistics(currentStats, previousStats);
        checkLoadValidity(currentStats, previousStats);
    }
    // current and previous set is not empty!
    // null is all live type
    boolean isAllLiveType = (liveType == null ? true : false);
    // null is all inst type
    boolean isAllInstType = (instType == null ? true : false);
    Map<FlowRule, TypedStoredFlowEntry> currentMap;
    Map<FlowRule, TypedStoredFlowEntry> previousMap;
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.IMMEDIATE_FLOW) {
        currentMap = typedStatistics.currentImmediate();
        previousMap = typedStatistics.previousImmediate();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.shortPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.SHORT_FLOW) {
        currentMap = typedStatistics.currentShort();
        previousMap = typedStatistics.previousShort();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.shortPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.MID_FLOW) {
        currentMap = typedStatistics.currentMid();
        previousMap = typedStatistics.previousMid();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.midPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.LONG_FLOW) {
        currentMap = typedStatistics.currentLong();
        previousMap = typedStatistics.previousLong();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.longPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.UNKNOWN_FLOW) {
        currentMap = typedStatistics.currentUnknown();
        previousMap = typedStatistics.previousUnknown();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.avgPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    return retTFEL;
}
#method_after
private List<TypedFlowEntryWithLoad> loadAllPortInternal(ConnectPoint cp, TypedStoredFlowEntry.FlowLiveType liveType, Instruction.Type instType) {
    checkPermission(STATISTIC_READ);
    List<TypedFlowEntryWithLoad> retTFEL = new ArrayList<>();
    Set<FlowEntry> currentStats;
    Set<FlowEntry> previousStats;
    TypedStatistics typedStatistics;
    synchronized (flowStatisticStore) {
        currentStats = flowStatisticStore.getCurrentFlowStatistic(cp);
        if (currentStats == null) {
            return retTFEL;
        }
        previousStats = flowStatisticStore.getPreviousFlowStatistic(cp);
        if (previousStats == null) {
            return retTFEL;
        }
        // copy to local flow entry set
        typedStatistics = new TypedStatistics(currentStats, previousStats);
        // Check for validity of this stats data
        checkLoadValidity(currentStats, previousStats);
    }
    // current and previous set is not empty!
    // null is all live type
    boolean isAllLiveType = (liveType == null ? true : false);
    // null is all inst type
    boolean isAllInstType = (instType == null ? true : false);
    Map<FlowRule, TypedStoredFlowEntry> currentMap;
    Map<FlowRule, TypedStoredFlowEntry> previousMap;
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.IMMEDIATE_FLOW) {
        currentMap = typedStatistics.currentImmediate();
        previousMap = typedStatistics.previousImmediate();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.shortPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.SHORT_FLOW) {
        currentMap = typedStatistics.currentShort();
        previousMap = typedStatistics.previousShort();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.shortPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.MID_FLOW) {
        currentMap = typedStatistics.currentMid();
        previousMap = typedStatistics.previousMid();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.midPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.LONG_FLOW) {
        currentMap = typedStatistics.currentLong();
        previousMap = typedStatistics.previousLong();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.longPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    if (isAllLiveType || liveType == TypedStoredFlowEntry.FlowLiveType.UNKNOWN_FLOW) {
        currentMap = typedStatistics.currentUnknown();
        previousMap = typedStatistics.previousUnknown();
        List<TypedFlowEntryWithLoad> fel = typedFlowEntryLoadByInstInternal(cp, currentMap, previousMap, isAllInstType, instType, TypedFlowEntryWithLoad.avgPollInterval());
        if (fel.size() > 0) {
            retTFEL.addAll(fel);
        }
    }
    return retTFEL;
}
#end_block

#method_before
private List<TypedFlowEntryWithLoad> typedFlowEntryLoadByInstInternal(ConnectPoint cp, Map<FlowRule, TypedStoredFlowEntry> currentMap, Map<FlowRule, TypedStoredFlowEntry> previousMap, boolean isAllInstType, Instruction.Type instType, int liveTypePollInterval) {
    List<TypedFlowEntryWithLoad> fel = new ArrayList<>();
    for (TypedStoredFlowEntry tfe : currentMap.values()) {
        if (isAllInstType || tfe.treatment().allInstructions().stream().filter(i -> i.type() == instType).findAny().isPresent()) {
            long currentBytes = tfe.bytes();
            long previousBytes = previousMap.getOrDefault(tfe, new DefaultTypedFlowEntry((FlowRule) tfe)).bytes();
            // if (currentBytes < previousBytes) {
            // TypedStoredFlowEntry t = previousMap.getOrDefault(tfe, new DefaultTypedFlowEntry((FlowRule) tfe));
            // log.debug("FlowStatisticManager:" +
            // " Current Bytes=" + currentBytes + ", Previous Bytes=" + previousBytes);
            // log.debug("FlowStatisticManager:" + " Current Flow Entry=" + tfe.toString() + ", " +
            // "life=" + tfe.life() + ", packets=" + tfe.packets() + ", bytes=" + tfe.bytes() +
            // ", lastSeen=" + tfe.lastSeen());
            // log.debug("FlowStatisticManager:" + "Previous Flow Entry=" + t.toString() +
            // ", life=" + t.life() + ", packets=" + t.packets() + ", bytes=" + t.bytes() +
            // ", lastSeen=" + t.lastSeen());
            // }
            Load fLoad = new DefaultLoad(currentBytes, previousBytes, liveTypePollInterval);
            fel.add(new TypedFlowEntryWithLoad(cp, tfe, fLoad));
        }
    }
    return fel;
}
#method_after
private List<TypedFlowEntryWithLoad> typedFlowEntryLoadByInstInternal(ConnectPoint cp, Map<FlowRule, TypedStoredFlowEntry> currentMap, Map<FlowRule, TypedStoredFlowEntry> previousMap, boolean isAllInstType, Instruction.Type instType, int liveTypePollInterval) {
    List<TypedFlowEntryWithLoad> fel = new ArrayList<>();
    for (TypedStoredFlowEntry tfe : currentMap.values()) {
        if (isAllInstType || tfe.treatment().allInstructions().stream().filter(i -> i.type() == instType).findAny().isPresent()) {
            long currentBytes = tfe.bytes();
            long previousBytes = previousMap.getOrDefault(tfe, new DefaultTypedFlowEntry((FlowRule) tfe)).bytes();
            Load fLoad = new DefaultLoad(currentBytes, previousBytes, liveTypePollInterval);
            fel.add(new TypedFlowEntryWithLoad(cp, tfe, fLoad));
        }
    }
    return fel;
}
#end_block

#method_before
@Test
public void openMessageTest1() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV, )
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x24, 0x01, 0x10, 0x00, 0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest1() throws PcepParseException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x24, 0x01, 0x10, 0x00, 0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest2() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, // STATEFUL-PCE-CAPABILITY
    0x0f };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest2() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, // STATEFUL-PCE-CAPABILITY
    0x0f };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest3() throws PcepParseException {
    // OPEN OBJECT (GmplsCapability).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x00, 0x00, // GMPLS-CAPABILITY-TLV
    0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest3() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x00, 0x00, // GMPLS-CAPABILITY-TLV
    0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest4() throws PcepParseException {
    // OPEN OBJECT (StatefulLspDbVerTlv).
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x18, 0x01, 0x10, 0x00, 0x14, 0x20, 0x1e, 0x78, 0x20, 0x00, 0x17, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // StatefulLspDbVerTlv
    0x02 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest4() throws PcepParseException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x18, 0x01, 0x10, 0x00, 0x14, 0x20, 0x1e, 0x78, 0x20, 0x00, 0x17, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // StatefulLspDbVerTlv
    0x02 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest5() throws PcepParseException {
    // OPEN OBJECT (no Tlvs).
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x0C, 0x01, 0x10, 0x00, 0x08, 0x20, 0x1e, 0x78, // no Tlvs in open messsage
    (byte) 0xbd };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest5() throws PcepParseException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x0C, 0x01, 0x10, 0x00, 0x08, 0x20, 0x1e, 0x78, // no Tlvs in open messsage
    (byte) 0xbd };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest6() throws PcepParseException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV) with
        p bit not set & i bit set.
         */
    byte[] openMsg = new byte[] { // p bit not set & i bit set
    0x20, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x24, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x11, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest6() throws PcepParseException {
    byte[] openMsg = new byte[] { // p bit not set & i bit set
    0x20, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x24, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x11, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest7() throws PcepParseException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV)
        with p bit set & i bit not set.
         */
    byte[] openMsg = new byte[] { // p bit set & i bit not set
    0x20, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x24, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x12, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest7() throws PcepParseException {
    byte[] openMsg = new byte[] { // p bit set & i bit not set
    0x20, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x24, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x12, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest8() throws PcepParseException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV)
        with p bit set & i bit set.
         */
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest8() throws PcepParseException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV)
        with p bit set & i bit set.
         */
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest9() throws PcepParseException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV)
        with p bit set & i bit set.
         */
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, // invalid sessionID
    0x20, // invalid sessionID
    0x1e, // invalid sessionID
    0x78, // invalid sessionID
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest9() throws PcepParseException {
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, // invalid sessionID
    0x20, // invalid sessionID
    0x1e, // invalid sessionID
    0x78, // invalid sessionID
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest10() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest10() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest11() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV, TED Capability TLV).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x2C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // TED Capability TLV
    0x00, // TED Capability TLV
    0x00, // TED Capability TLV
    0x00, // TED Capability TLV
    0x03, // TED Capability TLV
    0x00, // TED Capability TLV
    (byte) 0x84, // TED Capability TLV
    0x00, // TED Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest11() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x2C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // TED Capability TLV
    0x00, // TED Capability TLV
    0x00, // TED Capability TLV
    0x00, // TED Capability TLV
    0x03, // TED Capability TLV
    0x00, // TED Capability TLV
    (byte) 0x84, // TED Capability TLV
    0x00, // TED Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest12() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x24, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x20, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x03 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest12() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x24, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x20, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x03 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest13() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest13() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest14() throws PcepParseException {
    // OPEN OBJECT (STATEFUL-PCE-CAPABILITY).
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest14() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest15() throws PcepParseException {
    // OPEN OBJECT.
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x0c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of Pcep Open Message", message instanceof PcepOpenMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int iReadLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[iReadLen];
    buf.readBytes(testOpenMsg, 0, iReadLen);
    Assert.assertArrayEquals("Pcep open messages are not equal", openMsg, testOpenMsg);
}
#method_after
@Test
public void openMessageTest15() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x0c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepOpenMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void closeMessageTest1() {
    byte[] closeMsg = new byte[] { 0x20, 0x07, 0x00, 0x0C, 0x0f, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02 };
    byte[] testCloseMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(closeMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        Assert.fail("Exception occured due to " + e.getMessage());
    }
    Assert.assertThat("Pcep Message is instance of PcepCloseMsg", message, sameInstance((PcepCloseMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    try {
        message.writeTo(buf);
    } catch (PcepParseException e) {
        Assert.fail("Exception occured due to " + e.getMessage());
    }
    testCloseMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testCloseMsg = new byte[readLen];
    buf.readBytes(testCloseMsg, 0, readLen);
    Assert.assertThat("PcepCloseMsgs are not equal", testCloseMsg, is(closeMsg));
}
#method_after
@Test
public void closeMessageTest1() throws PcepParseException {
    byte[] closeMsg = new byte[] { 0x20, 0x07, 0x00, 0x0C, 0x0f, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02 };
    byte[] testCloseMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(closeMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepCloseMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testCloseMsg = buf.array();
    int readLen = buf.writerIndex();
    testCloseMsg = new byte[readLen];
    buf.readBytes(testCloseMsg, 0, readLen);
    assertThat(testCloseMsg, is(closeMsg));
}
#end_block

#method_before
private DefaultForwardingObjective.Builder createBuilder(PacketRequest request) {
    return DefaultForwardingObjective.builder().withPriority(request.priority().priorityValue()).withSelector(request.selector()).fromApp(request.appId()).withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(DefaultTrafficTreatment.builder().punt().build()).makePermanent();
}
#method_after
private DefaultForwardingObjective.Builder createBuilder(PacketRequest request) {
    return DefaultForwardingObjective.builder().withPriority(request.priority().priorityValue()).withSelector(request.selector()).fromApp(appId).withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(DefaultTrafficTreatment.builder().punt().build()).makePermanent();
}
#end_block

#method_before
@Override
public Ip4Address releaseIP(HostId hostId) {
    if (allocationMap.containsKey(hostId)) {
        IpAssignment newAssignment = IpAssignment.builder(allocationMap.get(hostId).value()).assignmentStatus(IpAssignment.AssignmentStatus.Option_Expired).build();
        Ip4Address freeIP = newAssignment.ipAddress();
        allocationMap.put(hostId, newAssignment);
        if (ipWithinRange(freeIP)) {
            freeIPPool.add(freeIP);
            return freeIP;
        }
    }
    return null;
}
#method_after
@Override
public Ip4Address releaseIP(HostId hostId) {
    if (allocationMap.containsKey(hostId)) {
        IpAssignment newAssignment = IpAssignment.builder(allocationMap.get(hostId).value()).assignmentStatus(IpAssignment.AssignmentStatus.Option_Expired).build();
        Ip4Address freeIP = newAssignment.ipAddress();
        allocationMap.put(hostId, newAssignment);
        if (ipWithinRange(freeIP)) {
            freeIPPool.add(freeIP);
        }
        return freeIP;
    }
    return null;
}
#end_block

#method_before
@Override
public HostEvent removeIp(HostId hostId, IpAddress ipAddress) {
    DefaultHost host = hosts.compute(hostId, (id, existingHost) -> {
        if (existingHost != null) {
            checkState(Objects.equals(hostId.mac(), existingHost.mac()), "Existing and new MAC addresses differ.");
            checkState(Objects.equals(hostId.vlanId(), existingHost.vlan()), "Existing and new VLANs differ.");
            Set<IpAddress> addresses = existingHost.ipAddresses();
            if (addresses != null && addresses.contains(ipAddress)) {
                addresses.remove(ipAddress);
                return new DefaultHost(existingHost.providerId(), hostId, existingHost.mac(), existingHost.vlan(), existingHost.location(), ImmutableSet.copyOf(addresses), existingHost.annotations());
            } else {
                return existingHost;
            }
        }
        return null;
    });
    return host != null ? new HostEvent(HOST_UPDATED, host) : null;
}
#method_after
@Override
public HostEvent removeIp(HostId hostId, IpAddress ipAddress) {
    DefaultHost host = hosts.compute(hostId, (id, existingHost) -> {
        if (existingHost != null) {
            checkState(Objects.equals(hostId.mac(), existingHost.mac()), "Existing and new MAC addresses differ.");
            checkState(Objects.equals(hostId.vlanId(), existingHost.vlan()), "Existing and new VLANs differ.");
            Set<IpAddress> addresses = new HashSet<>(existingHost.ipAddresses());
            if (addresses != null && addresses.contains(ipAddress)) {
                addresses.remove(ipAddress);
                return new DefaultHost(existingHost.providerId(), hostId, existingHost.mac(), existingHost.vlan(), existingHost.location(), ImmutableSet.copyOf(addresses), existingHost.annotations());
            } else {
                return existingHost;
            }
        }
        return null;
    });
    return host != null ? new HostEvent(HOST_UPDATED, host) : null;
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    nodeId = clusterService.getLocalNode().id();
    appId = coreService.registerApplication("org.onosproject.intentperf." + nodeId.toString());
    // TODO: replace with shared timer
    reportTimer = new Timer("onos-intent-perf-reporter");
    workers = Executors.newFixedThreadPool(DEFAULT_NUM_WORKERS, groupedThreads("onos/intent-perf", "worker-%d"));
    // disable flow backups for testing
    configService.setProperty("org.onosproject.store.flow.impl.newDistributedFlowRuleStore", "backupEnabled", "true");
    // TODO: replace with shared executor
    messageHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/perf", "command-handler"));
    communicationService.addSubscriber(CONTROL, new InternalControl(), messageHandlingExecutor);
    listener = new Listener();
    intentService.addListener(listener);
    // TODO: investigate why this seems to be necessary for configs to get picked up on initial activation
    modify(context);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    nodeId = clusterService.getLocalNode().id();
    appId = coreService.registerApplication("org.onosproject.intentperf." + nodeId.toString());
    // TODO: replace with shared timer
    reportTimer = new Timer("onos-intent-perf-reporter");
    workers = Executors.newFixedThreadPool(DEFAULT_NUM_WORKERS, groupedThreads("onos/intent-perf", "worker-%d"));
    // disable flow backups for testing
    configService.setProperty("org.onosproject.store.flow.impl.NewDistributedFlowRuleStore", "backupEnabled", "true");
    // TODO: replace with shared executor
    messageHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/perf", "command-handler"));
    communicationService.addSubscriber(CONTROL, new InternalControl(), messageHandlingExecutor);
    listener = new Listener();
    intentService.addListener(listener);
    // TODO: investigate why this seems to be necessary for configs to get picked up on initial activation
    modify(context);
}
#end_block

#method_before
public static void processHello(Ethernet ethPkt, ConnectPoint receivedFrom) {
    MacAddress srcmac = ethPkt.getSourceMAC();
    IPv4 ip = (IPv4) ethPkt.getPayload();
    Ip4Address srcip = Ip4Address.valueOf(ip.getSourceAddress());
    PIM pim = (PIM) ip.getPayload();
    PIMHello hello = (PIMHello) pim.getPayload();
    PIMNeighbor nbr = PIMNeighbors.findOrCreate(srcip, srcmac, receivedFrom);
    if (nbr == null) {
        log.error("Could not create a neighbor for: {1}", srcip.toString());
        return;
    }
    nbr.setConnectPoint(receivedFrom);
    nbr.refresh(hello);
}
#method_after
public static void processHello(Ethernet ethPkt, ConnectPoint receivedFrom) {
    checkNotNull(ethPkt);
    checkNotNull(ethPkt);
    MacAddress srcmac = ethPkt.getSourceMAC();
    IPv4 ip = (IPv4) ethPkt.getPayload();
    Ip4Address srcip = Ip4Address.valueOf(ip.getSourceAddress());
    PIM pim = (PIM) ip.getPayload();
    checkNotNull(pim);
    PIMHello hello = (PIMHello) pim.getPayload();
    checkNotNull(hello);
    PIMNeighbor nbr = PIMNeighbors.findOrCreate(srcip, srcmac, receivedFrom);
    if (nbr == null) {
        log.error("Could not create a neighbor for: {1}", srcip.toString());
        return;
    }
    nbr.setConnectPoint(receivedFrom);
    nbr.refresh(hello);
}
#end_block

#method_before
public void addNeighbor(PIMNeighbor nbr) {
    if (neighbors.containsKey(nbr.getPrimaryAddr())) {
        // TODO: this is really a bug.
        neighbors.remove(nbr.getPrimaryAddr(), nbr);
    }
    nbr.setNeighbors(this);
    neighbors.put(nbr.getPrimaryAddr(), nbr);
}
#method_after
public void addNeighbor(PIMNeighbor nbr) {
    if (neighbors.containsKey(nbr.getPrimaryAddr())) {
        // TODO: Hmmm, how should this be handled?
        log.debug("We are adding a neighbor that already exists: {}", nbr.toString());
        neighbors.remove(nbr.getPrimaryAddr(), nbr);
    }
    nbr.setNeighbors(this);
    neighbors.put(nbr.getPrimaryAddr(), nbr);
}
#end_block

#method_before
private void sendHelloPacket() {
    PIMHello hello = new PIMHello();
// TODO: we will need to implement the network config service to assign ip addresses
// and such from a config file./
/*
        hello.createDefaultOptions();

        Ethernet eth = hello.createPIMHello(this.ourIpAddress);
        hello.sendPacket(this.connectPoint);
        */
}
#method_after
private void sendHelloPacket() {
    PIMHello hello = new PIMHello();
// TODO: we will need to implement the network config service to assign ip addresses & options
/*
        hello.createDefaultOptions();

        Ethernet eth = hello.createPIMHello(this.ourIpAddress);
        hello.sendPacket(this.connectPoint);
        */
}
#end_block

#method_before
public String toString() {
    String out = "PIM Neighbors: ";
    if (this.ourIpAddress != null) {
        out += "IP: " + this.ourIpAddress.toString();
    } else {
        out += "IP: *Null*";
    }
    out += "\tPR: " + String.valueOf(this.ourPriority) + "\n";
    return out;
}
#method_after
@Override
public String toString() {
    String out = "PIM Neighbors: ";
    if (this.ourIpAddress != null) {
        out += "IP: " + this.ourIpAddress.toString();
    } else {
        out += "IP: *Null*";
    }
    out += "\tPR: " + String.valueOf(this.ourPriority) + "\n";
    return out;
}
#end_block

#method_before
public void refresh(PIMHello hello) {
    for (PIMHelloOption opt : hello.getOptions().values()) {
        int len = opt.getOptLength();
        byte[] value = new byte[len];
        ByteBuffer bb = ByteBuffer.wrap(value);
        switch(opt.getOptType()) {
            case PIMHelloOption.OPT_GENID:
                int newid = bb.getInt();
                if (this.genId != newid) {
                    // TODO: we have a newly rebooted neighbor.  Send them our joins.
                    this.genId = newid;
                }
                break;
            case PIMHelloOption.OPT_PRIORITY:
                int newpri = bb.getInt();
                if (this.priority != newpri) {
                    // The priorities have changed.  We may need to re-elect a new DR?
                    if (this.isDr || this.neighbors.getDesignatedRouter().getPriority() < priority) {
                        reelect = true;
                    }
                    this.priority = newpri;
                }
                break;
            case PIMHelloOption.OPT_HOLDTIME:
                short holdtime = bb.getShort();
                if (this.holdtime != holdtime) {
                    this.holdtime = holdtime;
                    if (holdtime == 0) {
                        // TODO: What else do we need to do when a neighbor goes down?
                        return;
                    }
                }
                break;
            case PIMHelloOption.OPT_PRUNEDELAY:
            case PIMHelloOption.OPT_ADDRLIST:
            default:
                log.debug("PIM Hello option type: {} not yet supported or unknown.", opt.getOptType());
                break;
        }
    }
    if (reelect) {
        this.neighbors.electDR(this);
    }
    // Reset the next timeout timer
    this.resetTimeout();
}
#method_after
public void refresh(PIMHello hello) {
    checkNotNull(hello);
    for (PIMHelloOption opt : hello.getOptions().values()) {
        int len = opt.getOptLength();
        byte[] value = new byte[len];
        ByteBuffer bb = ByteBuffer.wrap(value);
        switch(opt.getOptType()) {
            case PIMHelloOption.OPT_GENID:
                int newid = bb.getInt();
                if (this.genId != newid) {
                    // TODO: we have a newly rebooted neighbor.  Send them our joins.
                    this.genId = newid;
                }
                break;
            case PIMHelloOption.OPT_PRIORITY:
                int newpri = bb.getInt();
                if (this.priority != newpri) {
                    // The priorities have changed.  We may need to re-elect a new DR?
                    if (this.isDr || this.neighbors.getDesignatedRouter().getPriority() < priority) {
                        reelect = true;
                    }
                    this.priority = newpri;
                }
                break;
            case PIMHelloOption.OPT_HOLDTIME:
                short holdtime = bb.getShort();
                if (this.holdtime != holdtime) {
                    this.holdtime = holdtime;
                    if (holdtime == 0) {
                        // We have a neighbor going down.  We can remove all joins
                        // we have learned from them.
                        // TODO: What else do we need to do when a neighbor goes down?
                        log.debug("PIM Neighbor has timed out: {}", this.primaryAddr.toString());
                        return;
                    }
                }
                break;
            case PIMHelloOption.OPT_PRUNEDELAY:
            case PIMHelloOption.OPT_ADDRLIST:
            default:
                log.debug("PIM Hello option type: {} not yet supported or unknown.", opt.getOptType());
                break;
        }
    }
    if (reelect) {
        this.neighbors.electDR(this);
    }
    // Reset the next timeout timer
    this.resetTimeout();
}
#end_block

#method_before
/* --------------------------------------- Timer functions -------------------------- */
private void resetTimeout() {
    if (this.holdtime == 0) {
        // log("shutting down timer for nbr");
        if (this.timeout != null) {
            this.timeout.cancel();
            this.timeout = null;
        }
        return;
    }
    // Cancel the existing timeout and start a fresh new one.
    if (this.timeout != null) {
        this.timeout.cancel();
    }
    this.timeout = PIMTimer.getTimer().newTimeout(new NeighborTimeoutTask(this), holdtime, TimeUnit.SECONDS);
}
#method_after
/* --------------------------------------- Timer functions -------------------------- */
private void resetTimeout() {
    if (this.holdtime == 0) {
        // Prepare to die.
        log.debug("shutting down timer for nbr {}", this.primaryAddr.toString());
        if (this.timeout != null) {
            this.timeout.cancel();
            this.timeout = null;
        }
        return;
    }
    // Cancel the existing timeout and start a fresh new one.
    if (this.timeout != null) {
        this.timeout.cancel();
    }
    this.timeout = PIMTimer.getTimer().newTimeout(new NeighborTimeoutTask(this), holdtime, TimeUnit.SECONDS);
}
#end_block

#method_before
public String toString() {
    String out = "";
    if (this.isDr) {
        out += "*NBR:";
    } else {
        out += "NBR:";
    }
    out += "\tIP: " + this.primaryAddr.toString();
    out += "\tPr: " + String.valueOf(this.priority);
    out += "\tHoldTime: " + String.valueOf(this.holdtime);
    out += "\tGenID: " + String.valueOf(this.genId) + "\n";
    return out;
}
#method_after
@Override
public String toString() {
    String out = "";
    if (this.isDr) {
        out += "*NBR:";
    } else {
        out += "NBR:";
    }
    out += "\tIP: " + this.primaryAddr.toString();
    out += "\tPr: " + String.valueOf(this.priority);
    out += "\tHoldTime: " + String.valueOf(this.holdtime);
    out += "\tGenID: " + String.valueOf(this.genId) + "\n";
    return out;
}
#end_block

#method_before
private static synchronized void initTimer() {
    if (PIMTimer.timer == null) {
        HashedWheelTimer hwTimer = new HashedWheelTimer();
        hwTimer.start();
        PIMTimer.timer = hwTimer;
    }
}
#method_after
private static synchronized void initTimer() {
    if (PIMTimer.timer == null) {
        // Create and start a new hashed wheel timer, if it does not exist.
        HashedWheelTimer hwTimer = new HashedWheelTimer();
        hwTimer.start();
        PIMTimer.timer = hwTimer;
    }
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    /*
             * IPv6 MLD packets are handled by ICMP6. We'll only deal
             * with IPv4.
             */
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4) {
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + "\tingress port: " + context.inPacket().receivedFrom().toString());
    if (ip.getProtocol() != IPv4.PROTOCOL_PIM) {
        log.debug("PIM Picked up a non PIM packet: IP protocol: " + ip.getProtocol());
        return;
    }
    // TODO: check incoming to be PIM.PIM_ADDRESS or "Our" address.
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    PIM pim = (PIM) ip.getPayload();
    switch(pim.getPimMsgType()) {
        case PIM.TYPE_HELLO:
            PIMNeighbors.processHello(ethPkt, context.inPacket().receivedFrom());
            break;
        case PIM.TYPE_JOIN_PRUNE_REQUEST:
            // Create the function
            break;
        case PIM.TYPE_ASSERT:
        case PIM.TYPE_BOOTSTRAP:
        case PIM.TYPE_CANDIDATE_RP_ADV:
        case PIM.TYPE_GRAFT:
        case PIM.TYPE_GRAFT_ACK:
        case PIM.TYPE_REGISTER:
        case PIM.TYPE_REGISTER_STOP:
            log.debug("Unsupported PIM message type: " + pim.getPimMsgType());
            break;
        default:
            log.debug("Unkown PIM message type: " + pim.getPimMsgType());
            break;
    }
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    if (pkt == null) {
        return;
    }
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    /*
             * IPv6 MLD packets are handled by ICMP6. We'll only deal
             * with IPv4.
             */
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4) {
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + "\tingress port: " + context.inPacket().receivedFrom().toString());
    if (ip.getProtocol() != IPv4.PROTOCOL_PIM) {
        log.debug("PIM Picked up a non PIM packet: IP protocol: " + ip.getProtocol());
        return;
    }
    // TODO: check incoming to be PIM.PIM_ADDRESS or "Our" address.
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    PIM pim = (PIM) ip.getPayload();
    switch(pim.getPimMsgType()) {
        case PIM.TYPE_HELLO:
            PIMNeighbors.processHello(ethPkt, context.inPacket().receivedFrom());
            break;
        case PIM.TYPE_JOIN_PRUNE_REQUEST:
            // Create the function
            break;
        case PIM.TYPE_ASSERT:
        case PIM.TYPE_BOOTSTRAP:
        case PIM.TYPE_CANDIDATE_RP_ADV:
        case PIM.TYPE_GRAFT:
        case PIM.TYPE_GRAFT_ACK:
        case PIM.TYPE_REGISTER:
        case PIM.TYPE_REGISTER_STOP:
            log.debug("Unsupported PIM message type: " + pim.getPimMsgType());
            break;
        default:
            log.debug("Unkown PIM message type: " + pim.getPimMsgType());
            break;
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started with flowPollFrequency = {}, adaptiveFlowSampling = {}", flowPollFrequency, adaptiveFlowSampling);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
    boolean newAdaptiveFlowSampling;
    String s = get(properties, "adaptiveFlowSampling");
    newAdaptiveFlowSampling = isNullOrEmpty(s) ? adaptiveFlowSampling : Boolean.parseBoolean(s.trim());
    if (newAdaptiveFlowSampling != adaptiveFlowSampling) {
        // stop previous collector
        stopCollectors();
        adaptiveFlowSampling = newAdaptiveFlowSampling;
        // create new collectors
        createCollectors();
    }
    log.info("Settings: adaptiveFlowSampling={}", adaptiveFlowSampling);
}
#end_block

#method_before
private void createCollector(OpenFlowSwitch sw) {
    // NewAdaptiveFlowStatsCollector Constructor
    NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(sw, flowPollFrequency);
    fsc.start();
    collectors.put(new Dpid(sw.getId()), fsc);
}
#method_after
private void createCollector(OpenFlowSwitch sw) {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(sw, flowPollFrequency);
        fsc.start();
        afsCollectors.put(new Dpid(sw.getId()), fsc);
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        fsc.start();
        simpleCollectors.put(new Dpid(sw.getId()), fsc);
    }
}
#end_block

#method_before
private void stopCollectors() {
    // NewAdaptiveFlowStatsCollector Destructor
    collectors.values().forEach(NewAdaptiveFlowStatsCollector::stop);
    collectors.clear();
}
#method_after
private void stopCollectors() {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Destructor
        afsCollectors.values().forEach(NewAdaptiveFlowStatsCollector::stop);
        afsCollectors.clear();
    } else {
        simpleCollectors.values().forEach(FlowStatsCollector::stop);
        simpleCollectors.clear();
    }
}
#end_block

#method_before
private void adjustRate() {
    DefaultLoad.setPollInterval(flowPollFrequency);
    // NewAdaptiveFlowStatsCollector calAndPollInterval
    collectors.values().forEach(fsc -> fsc.adjustCalAndPollInterval(flowPollFrequency));
}
#method_after
private void adjustRate() {
    DefaultLoad.setPollInterval(flowPollFrequency);
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector calAndPollInterval
        afsCollectors.values().forEach(fsc -> fsc.adjustCalAndPollInterval(flowPollFrequency));
    } else {
        simpleCollectors.values().forEach(fsc -> fsc.adjustPollInterval(flowPollFrequency));
    }
}
#end_block

#method_before
private void applyRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowAdd());
    // 
    // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
    // 
    collectors.get(dpid).addWithFlowRule(flowRule);
}
#method_after
private void applyRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowAdd());
    if (adaptiveFlowSampling) {
        // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
        afsCollectors.get(dpid).addWithFlowRule(flowRule);
    }
}
#end_block

#method_before
private void removeRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowDel());
    // 
    // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
    // 
    collectors.get(dpid).removeFlows(flowRule);
}
#method_after
private void removeRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowDel());
    if (adaptiveFlowSampling) {
        // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
        afsCollectors.get(dpid).removeFlows(flowRule);
    }
}
#end_block

#method_before
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()));
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                // 
                // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                // 
                collectors.get(dpid).addWithFlowRule(fbe.target());
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                // 
                // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                // 
                collectors.get(dpid).removeFlows(fbe.target());
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                // 
                // Add or Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                // 
                collectors.get(dpid).addWithFlowRule(fbe.target());
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#method_after
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    checkNotNull(batch);
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()));
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                if (adaptiveFlowSampling) {
                    // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    afsCollectors.get(dpid).addWithFlowRule(fbe.target());
                }
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                if (adaptiveFlowSampling) {
                    // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    afsCollectors.get(dpid).removeFlows(fbe.target());
                }
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                if (adaptiveFlowSampling) {
                    // Add or Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    // afsCollectors.get(dpid).addWithFlowRule(fbe.target()); //check if add is good or not
                    afsCollectors.get(dpid).addOrUpdateFlows((FlowEntry) fbe.target());
                }
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#end_block

#method_before
@Override
public void switchAdded(Dpid dpid) {
    createCollector(controller.getSwitch(dpid));
}
#method_after
@Override
public void switchAdded(Dpid dpid) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    createCollector(controller.getSwitch(dpid));
}
#end_block

#method_before
@Override
public void switchRemoved(Dpid dpid) {
    NewAdaptiveFlowStatsCollector collector = collectors.remove(dpid);
    if (collector != null) {
        collector.stop();
    }
}
#method_after
@Override
public void switchRemoved(Dpid dpid) {
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector collector = afsCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    } else {
        FlowStatsCollector collector = simpleCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    }
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            // 
            // Removed TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
            // 
            collectors.get(dpid).flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(dpid, fm).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            if (adaptiveFlowSampling) {
                // Removed TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                afsCollectors.get(dpid).flowRemoved(fr);
            }
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(dpid, fm).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    List<FlowEntry> flowEntries = replies.getEntries().stream().map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    providerService.pushFlowMetrics(did, flowEntries);
    // 
    // Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
    // 
    collectors.get(dpid).pushFlowMetrics(flowEntries);
}
#method_after
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    List<FlowEntry> flowEntries = replies.getEntries().stream().map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector afsc = afsCollectors.get(dpid);
        synchronized (afsc) {
            if (afsc.getFlowMissingXid() != NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID) {
                log.debug("OpenFlowRuleProvider:pushFlowMetrics, flowMissingXid={}, " + "OFFlowStatsReply Xid={}, for {}", afsc.getFlowMissingXid(), replies.getXid(), dpid);
            }
            // Check that OFFlowStatsReply Xid is same with the one of OFFlowStatsRequest?
            if (afsc.getFlowMissingXid() != NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID) {
                if (afsc.getFlowMissingXid() == replies.getXid()) {
                    // call entire flow stats update with flowMissing synchronization.
                    // used existing pushFlowMetrics
                    providerService.pushFlowMetrics(did, flowEntries);
                }
                // reset flowMissingXid to NO_FLOW_MISSING_XID
                afsc.setFlowMissingXid(NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID);
            } else {
                // call individual flow stats update
                providerService.pushFlowMetricsWithoutFlowMissing(did, flowEntries);
            }
            // Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
            afsc.pushFlowMetrics(flowEntries);
        }
    } else {
        // call existing entire flow stats update with flowMissing synchronization
        providerService.pushFlowMetrics(did, flowEntries);
    }
}
#end_block

#method_before
private void initMemberVars(int pollInterval) {
    if (pollInterval < MIN_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MIN_CAL_AND_POLL_FREQUENCY;
    } else if (pollInterval >= MAX_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MAX_CAL_AND_POLL_FREQUENCY;
    } else {
        this.calAndPollInterval = pollInterval;
    }
    calAndPollInterval = CAL_AND_POLL_TIMES * calAndPollInterval;
    midPollInterval = MID_POLL_TIMES * calAndPollInterval;
    longPollInterval = LONG_POLL_TIMES * calAndPollInterval;
    entirePollInterval = ENTIRE_POLL_TIMES * calAndPollInterval;
    callCountCalAndShortFlowsTask = 0;
    callCountMidFlowsTask = 0;
    callCountLongFlowsTask = 0;
}
#method_after
private void initMemberVars(int pollInterval) {
    if (pollInterval < MIN_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MIN_CAL_AND_POLL_FREQUENCY;
    } else if (pollInterval >= MAX_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MAX_CAL_AND_POLL_FREQUENCY;
    } else {
        this.calAndPollInterval = pollInterval;
    }
    calAndPollInterval = CAL_AND_POLL_TIMES * calAndPollInterval;
    midPollInterval = MID_POLL_TIMES * calAndPollInterval;
    longPollInterval = LONG_POLL_TIMES * calAndPollInterval;
    entirePollInterval = ENTIRE_POLL_TIMES * calAndPollInterval;
    callCountCalAndShortFlowsTask = 0;
    callCountMidFlowsTask = 0;
    callCountLongFlowsTask = 0;
    flowMissingXid = NO_FLOW_MISSING_XID;
}
#end_block

#method_before
synchronized void adjustCalAndPollInterval(int pollInterval) {
    initMemberVars(pollInterval);
    if (calAndShortFlowsThread != null) {
        calAndShortFlowsThread.cancel(false);
    }
    if (midFlowsThread != null) {
        midFlowsThread.cancel(false);
    }
    if (longFlowsThread != null) {
        longFlowsThread.cancel(false);
    }
    calAndShortFlowsTask = new CalAndShortFlowsTask();
    calAndShortFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(calAndShortFlowsTask, 0, calAndPollInterval, TimeUnit.SECONDS);
    midFlowsTask = new MidFlowsTask();
    midFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(midFlowsTask, 0, midPollInterval, TimeUnit.SECONDS);
    longFlowsTask = new LongFlowsTask();
    longFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(longFlowsTask, 0, longPollInterval, TimeUnit.SECONDS);
    log.info("calAndPollInterval=" + calAndPollInterval + "is adjusted");
}
#method_after
synchronized void adjustCalAndPollInterval(int pollInterval) {
    initMemberVars(pollInterval);
    if (calAndShortFlowsThread != null) {
        calAndShortFlowsThread.cancel(false);
    }
    if (midFlowsThread != null) {
        midFlowsThread.cancel(false);
    }
    if (longFlowsThread != null) {
        longFlowsThread.cancel(false);
    }
    calAndShortFlowsTask = new CalAndShortFlowsTask();
    calAndShortFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(calAndShortFlowsTask, 0, calAndPollInterval, TimeUnit.SECONDS);
    midFlowsTask = new MidFlowsTask();
    midFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(midFlowsTask, 0, midPollInterval, TimeUnit.SECONDS);
    longFlowsTask = new LongFlowsTask();
    longFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(longFlowsTask, 0, longPollInterval, TimeUnit.SECONDS);
    log.debug("calAndPollInterval=" + calAndPollInterval + "is adjusted");
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("CalAndShortFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        if (isFirstTimeStart) {
            // isFirstTimeStart, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats at first time start for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = 0;
            isFirstTimeStart = false;
        } else if (callCountCalAndShortFlowsTask == ENTIRE_POLL_TIMES) {
            // entrire_poll_times, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = 0;
        // TODO: check flows deleted in switch, but exist in controller flow table, then remove them
        // 
        } else {
            calAndShortFlowsTaskInternal();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("CalAndShortFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        if (isFirstTimeStart) {
            // isFirstTimeStart, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats at first time start for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
            isFirstTimeStart = false;
        } else if (callCountCalAndShortFlowsTask == ENTIRE_POLL_TIMES) {
            // entire_poll_times, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = CAL_AND_POLL_TIMES;
        // TODO: check flows deleted in switch, but exist in controller flow table, then remove them
        // 
        } else {
            calAndShortFlowsTaskInternal();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
        }
    }
}
#end_block

#method_before
private void ofFlowStatsRequestAllSend() {
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestAllSend() {
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
    synchronized (this) {
        // set the request xid to check the reply in OpenFlowRuleProvider
        // After processing the reply of this request message,
        // this must be set to NO_FLOW_MISSING_XID(-1) by provider
        setFlowMissingXid(request.getXid());
        log.debug("ofFlowStatsRequestAllSend,Request={},for {}", request.toString(), sw.getStringId());
        sw.sendMsg(request);
    }
}
#end_block

#method_before
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty()).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(// .setMatch(sw.factory().matchWildcardAll())
    match).setTableId(// .setTableId(TableId.ALL)
    tableId).setOutPort(// .setOutPort(OFPort.NO_MASK)
    ofPort).build();
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty()).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(match).setTableId(tableId).setOutPort(ofPort).build();
    synchronized (this) {
        if (getFlowMissingXid() != NO_FLOW_MISSING_XID) {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll does not be processed yet," + " set no flow missing xid anyway, for {}", sw.getStringId());
            setFlowMissingXid(NO_FLOW_MISSING_XID);
        }
        sw.sendMsg(request);
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("MidFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountMidFlowsTask == ENTIRE_POLL_TIMES) {
            callCountMidFlowsTask = 0;
        } else {
            midFlowsTaskInternal();
            callCountMidFlowsTask += MID_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("MidFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountMidFlowsTask == ENTIRE_POLL_TIMES) {
            callCountMidFlowsTask = MID_POLL_TIMES;
        } else {
            midFlowsTaskInternal();
            callCountMidFlowsTask += MID_POLL_TIMES;
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("LongFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountLongFlowsTask == ENTIRE_POLL_TIMES) {
            callCountLongFlowsTask = 0;
        } else {
            longFlowsTaskInternal();
            callCountLongFlowsTask += LONG_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("LongFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountLongFlowsTask == ENTIRE_POLL_TIMES) {
            callCountLongFlowsTask = LONG_POLL_TIMES;
        } else {
            longFlowsTaskInternal();
            callCountLongFlowsTask += LONG_POLL_TIMES;
        }
    }
}
#end_block

#method_before
public boolean addWithFlowRule(FlowRule... flowRules) {
    for (FlowRule fr : flowRules) {
        // First remove old entry unconditionally, if exist
        deviceFlowTable.remove(fr);
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fr, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
    return true;
}
#method_after
public synchronized void addWithFlowRule(FlowRule... flowRules) {
    for (FlowRule fr : flowRules) {
        // First remove old entry unconditionally, if exist
        deviceFlowTable.remove(fr);
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fr, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
public boolean addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
    return true;
}
#method_after
public synchronized void addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        // check if this new rule is an update to an existing entry
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            // duplicated flow entry is collected!, just skip
            if (fe.bytes() == stored.bytes() && fe.packets() == stored.packets() && fe.life() == stored.life()) {
                log.debug("addOrUpdateFlows:, FlowId=" + Long.toHexString(fe.id().value()) + ",is DUPLICATED stats collection, just skip." + " AdaptiveStats collection thread for {}", sw.getStringId());
                stored.setLastSeen();
                continue;
            } else if (fe.life() < stored.life()) {
                // Invalid updates the stats values, i.e., bytes, packets, durations ...
                log.debug("addOrUpdateFlows():" + " Invalid Flow Update! The new life is SMALLER than the previous one, jus skip." + " new flowId=" + Long.toHexString(fe.id().value()) + ", old flowId=" + Long.toHexString(stored.id().value()) + ", new bytes=" + fe.bytes() + ", old bytes=" + stored.bytes() + ", new life=" + fe.life() + ", old life=" + stored.life() + ", new lastSeen=" + fe.lastSeen() + ", old lastSeen=" + stored.lastSeen());
                // go next
                stored.setLastSeen();
                continue;
            }
            // update now
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
public boolean removeFlows(FlowRule... flowRules) {
    for (FlowRule rule : flowRules) {
        deviceFlowTable.remove(rule);
    }
    return true;
}
#method_after
public synchronized void removeFlows(FlowRule... flowRules) {
    for (FlowRule rule : flowRules) {
        deviceFlowTable.remove(rule);
    }
}
#end_block

#method_before
public boolean flowRemoved(FlowRule... flowRules) {
    removeFlows(flowRules);
    return true;
}
#method_after
// same as removeFlows() function
public void flowRemoved(FlowRule... flowRules) {
    removeFlows(flowRules);
}
#end_block

#method_before
public boolean pushFlowMetrics(List<FlowEntry> flowEntries) {
    flowEntries.forEach(fe -> addOrUpdateFlows(fe));
    return true;
}
#method_after
// same as addOrUpdateFlows() function
public void pushFlowMetrics(List<FlowEntry> flowEntries) {
    flowEntries.forEach(fe -> {
        addOrUpdateFlows(fe);
    });
}
#end_block

#method_before
public int getFlowCount() {
    return flowEntries.values().stream().mapToInt(Set::size).sum();
}
#method_after
public long getFlowCount() {
    return flowEntries.values().stream().mapToLong(Set::size).sum();
}
#end_block

#method_before
public TypedStoredFlowEntry getFlowEntry(FlowRule rule) {
    return getFlowEntryInternal(rule);
}
#method_after
public TypedStoredFlowEntry getFlowEntry(FlowRule rule) {
    checkNotNull(rule);
    return getFlowEntryInternal(rule);
}
#end_block

#method_before
public Set<StoredFlowEntry> getShortFlows() {
    // Sets.newHashSet(shortFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(shortFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getShortFlows() {
    // Sets.newHashSet(shortFlows);
    return ImmutableSet.copyOf(shortFlows);
}
#end_block

#method_before
public Set<StoredFlowEntry> getMidFlows() {
    // Sets.newHashSet(midFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(midFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getMidFlows() {
    // Sets.newHashSet(midFlows);
    return ImmutableSet.copyOf(midFlows);
}
#end_block

#method_before
public Set<StoredFlowEntry> getLongFlows() {
    // Sets.newHashSet(longFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(longFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getLongFlows() {
    // Sets.newHashSet(longFlows);
    return ImmutableSet.copyOf(longFlows);
}
#end_block

#method_before
public void add(TypedStoredFlowEntry rule) {
    // rule have to be new new DefaultTypedFlowEntry
    getFlowEntriesInternal(rule.id()).add(rule);
    addCount++;
// log.debug("add, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
public synchronized void add(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    // rule have to be new DefaultTypedFlowEntry
    boolean result = getFlowEntriesInternal(rule.id()).add(rule);
    if (result) {
        addCount++;
    }
}
#end_block

#method_before
public void calAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    calAndSetFlowLiveTypeInternal(rule);
}
#method_after
public void calAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    calAndSetFlowLiveTypeInternal(rule);
}
#end_block

#method_before
public void addWithCalAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    // rule have to be new new DefaultTypedFlowEntry
    getFlowEntriesInternal(rule.id()).add(rule);
    calAndSetFlowLiveTypeInternal(rule);
    addWithSetFlowLiveTypeCount++;
// log.debug("addWithSetFlowLiveType, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
public synchronized void addWithCalAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    // rule have to be new DefaultTypedFlowEntry
    boolean result = getFlowEntriesInternal(rule.id()).add(rule);
    if (result) {
        calAndSetFlowLiveTypeInternal(rule);
        addWithSetFlowLiveTypeCount++;
    } else {
        log.debug("addWithCalAndSetFlowLiveType, FlowId=" + Long.toHexString(rule.id().value()) + " ADD Failed, cause it may already exists in table !!!," + " AdaptiveStats collection thread for {}", sw.getStringId());
    }
}
#end_block

#method_before
private void calAndSetFlowLiveTypeInternal(TypedStoredFlowEntry rule) {
    long life = rule.life();
    FlowLiveType prevFlowLiveType = rule.flowLiveType();
    if (life >= longPollInterval) {
        rule.setFlowLiveType(FlowLiveType.LONG_FLOW);
        longFlows.add(rule);
    } else if (life >= midPollInterval) {
        rule.setFlowLiveType(FlowLiveType.MID_FLOW);
        midFlows.add(rule);
    } else if (life >= calAndPollInterval) {
        rule.setFlowLiveType(FlowLiveType.SHORT_FLOW);
        shortFlows.add(rule);
    } else if (life >= 0) {
        rule.setFlowLiveType(FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        rule.setFlowLiveType(FlowLiveType.UNKNOWN_FLOW);
    }
    if (rule.flowLiveType() != prevFlowLiveType) {
        switch(prevFlowLiveType) {
            // delete it from previous flow table
            case SHORT_FLOW:
                shortFlows.remove(rule);
                break;
            case MID_FLOW:
                midFlows.remove(rule);
                break;
            case LONG_FLOW:
                longFlows.remove(rule);
                break;
            default:
                break;
        }
    }
// log.debug("setFlowLiveTypeInternal, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + ", life=" + life
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
// In real, calculates and set the flow live type at the first time,
private void calAndSetFlowLiveTypeInternal(TypedStoredFlowEntry rule) {
    long life = rule.life();
    FlowLiveType prevFlowLiveType = rule.flowLiveType();
    if (life >= longPollInterval) {
        rule.setFlowLiveType(FlowLiveType.LONG_FLOW);
        longFlows.add(rule);
    } else if (life >= midPollInterval) {
        rule.setFlowLiveType(FlowLiveType.MID_FLOW);
        midFlows.add(rule);
    } else if (life >= calAndPollInterval) {
        rule.setFlowLiveType(FlowLiveType.SHORT_FLOW);
        shortFlows.add(rule);
    } else if (life >= 0) {
        rule.setFlowLiveType(FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        rule.setFlowLiveType(FlowLiveType.UNKNOWN_FLOW);
    }
    if (rule.flowLiveType() != prevFlowLiveType) {
        switch(prevFlowLiveType) {
            // delete it from previous flow table
            case SHORT_FLOW:
                shortFlows.remove(rule);
                break;
            case MID_FLOW:
                midFlows.remove(rule);
                break;
            case LONG_FLOW:
                longFlows.remove(rule);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void checkAndMoveLiveFlowAll() {
    Set<TypedStoredFlowEntry> typedFlowEntries = getFlowEntriesInternal();
    long calCurTime = System.currentTimeMillis();
    typedFlowEntries.forEach(fe -> {
        if (!checkAndMoveLiveFlow(fe, calCurTime)) {
            remove(fe);
        }
    });
    log.debug("checkAndMoveLiveFlowAll, Total Flow_Count=" + getFlowCount() + ", add - remove_Count=" + (addCount + addWithSetFlowLiveTypeCount - removeCount) + ", IMMEDIATE_FLOW_Count=" + (getFlowCount() - shortFlows.size() - midFlows.size() - longFlows.size()) + ", SHORT_FLOW_Count=" + shortFlows.size() + ", MID_FLOW_Count=" + midFlows.size() + ", LONG_FLOW_Count=" + longFlows.size() + ", add_Count=" + addCount + ",addWithSetFlowLiveType_Count=" + addWithSetFlowLiveTypeCount + ", remove_Count=" + removeCount + " AdaptiveStats collection thread for {}", sw.getStringId());
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#method_after
public void checkAndMoveLiveFlowAll() {
    Set<TypedStoredFlowEntry> typedFlowEntries = getFlowEntriesInternal();
    long calCurTime = System.currentTimeMillis();
    typedFlowEntries.forEach(fe -> {
        if (!checkAndMoveLiveFlowInternal(fe, calCurTime)) {
            remove(fe);
        }
    });
    // print table counts for debug
    if (log.isDebugEnabled()) {
        synchronized (this) {
            long totalFlowCount = getFlowCount();
            long shortFlowCount = shortFlows.size();
            long midFlowCount = midFlows.size();
            long longFlowCount = longFlows.size();
            long immediateFlowCount = totalFlowCount - shortFlowCount - midFlowCount - longFlowCount;
            long calTotalCount = addCount + addWithSetFlowLiveTypeCount - removeCount;
            log.debug("--------------------------------------------------------------------------- for {}", sw.getStringId());
            log.debug("checkAndMoveLiveFlowAll, Total Flow_Count=" + totalFlowCount + ", add - remove_Count=" + calTotalCount + ", IMMEDIATE_FLOW_Count=" + immediateFlowCount + ", SHORT_FLOW_Count=" + shortFlowCount + ", MID_FLOW_Count=" + midFlowCount + ", LONG_FLOW_Count=" + longFlowCount + ", add_Count=" + addCount + ", addWithSetFlowLiveType_Count=" + addWithSetFlowLiveTypeCount + ", remove_Count=" + removeCount + " AdaptiveStats collection thread for {}", sw.getStringId());
            log.debug("--------------------------------------------------------------------------- for {}", sw.getStringId());
            if (totalFlowCount != calTotalCount) {
                log.error("checkAndMoveLiveFlowAll, Real total flow count and " + "calculated total flow count do NOT match, something is wrong internally " + "or check counter value bound is over!");
            }
            if (immediateFlowCount < 0) {
                log.error("checkAndMoveLiveFlowAll, IMMEDIATE_FLOW count is negative, " + "something is wrong internally " + "or check counter value bound is over!");
            }
        }
    }
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#end_block

#method_before
public boolean remove(FlowRule rule) {
    TypedStoredFlowEntry removeStore = getFlowEntryInternal(rule);
    if (removeStore != null) {
        // log.debug("remove, FlowId=" + removeStore.id() + ", liveType=" + removeStore.flowLiveType()
        // + " AdaptiveStats collection thread for {}", sw.getStringId());
        removeLiveFlowsInternal((TypedStoredFlowEntry) removeStore);
        boolean result = getFlowEntriesInternal(rule.id()).remove(removeStore);
        removeCount++;
        return result;
    }
    return false;
}
#method_after
public synchronized void remove(FlowRule rule) {
    checkNotNull(rule);
    TypedStoredFlowEntry removeStore = getFlowEntryInternal(rule);
    if (removeStore != null) {
        removeLiveFlowsInternal((TypedStoredFlowEntry) removeStore);
        boolean result = getFlowEntriesInternal(rule.id()).remove(removeStore);
        if (result) {
            removeCount++;
        }
    }
}
#end_block

#method_before
private boolean removeLiveFlowsInternal(TypedStoredFlowEntry fe) {
    switch(fe.flowLiveType()) {
        case IMMEDIATE_FLOW:
            // do nothing
            break;
        case SHORT_FLOW:
            shortFlows.remove(fe);
            break;
        case MID_FLOW:
            midFlows.remove(fe);
            break;
        case LONG_FLOW:
            longFlows.remove(fe);
            break;
        default:
            // error in Flow Live Type
            return false;
    }
    return true;
}
#method_after
private void removeLiveFlowsInternal(TypedStoredFlowEntry fe) {
    switch(fe.flowLiveType()) {
        case IMMEDIATE_FLOW:
            // do nothing
            break;
        case SHORT_FLOW:
            shortFlows.remove(fe);
            break;
        case MID_FLOW:
            midFlows.remove(fe);
            break;
        case LONG_FLOW:
            longFlows.remove(fe);
            break;
        default:
            // error in Flow Live Type
            log.error("removeLiveFlowsInternal, Unknown Live Type error!");
            break;
    }
}
#end_block

